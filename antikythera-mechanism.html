<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Antikythera Mechanism Simulator</title>
    <meta name="description" content="A physically accurate, interactive 3D simulation of the ancient Greek analog computer. Turn the crank to predict eclipses and planetary positions.">
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; color: #e0e0e0; font-family: 'Cinzel', serif; }
        #canvas-container { width: 100vw; height: 100vh; }
        #ui-panel {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(10, 10, 10, 0.85);
            border: 1px solid #8b5a2b;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            width: 80%;
            max-width: 600px;
            box-shadow: 0 0 20px rgba(139, 90, 43, 0.2);
        }
        h1 { margin: 0 0 10px 0; color: #d4af37; font-size: 1.5rem; letter-spacing: 2px; text-transform: uppercase; }
        .controls { display: flex; align-items: center; justify-content: center; gap: 20px; margin-top: 15px; }
        input[type=range] { width: 200px; accent-color: #d4af37; }
        .date-display { font-size: 1.2rem; color: #fff; margin: 10px 0; font-family: monospace; }
        .info-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; text-align: left; font-size: 0.9rem; margin-top: 15px; border-top: 1px solid #333; padding-top: 10px; }
        .info-item span { color: #d4af37; float: right; }
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #d4af37; font-size: 2rem; pointer-events: none; transition: opacity 0.5s; }
        
        /* Ancient Greek Font Style */
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap');
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <div id="loading">Constructing Mechanism...</div>
    <div id="canvas-container"></div>
    
    <div id="ui-panel">
        <h1>Antikythera Mechanism</h1>
        <div class="date-display" id="date-display">Year: 100 BC</div>
        
        <div class="controls">
            <button id="btn-reverse" style="background:none; border:1px solid #d4af37; color:#d4af37; padding:5px 10px; cursor:pointer;">◀ Reverse</button>
            <input type="range" id="crank" min="0" max="1000" value="0" step="0.1">
            <button id="btn-forward" style="background:none; border:1px solid #d4af37; color:#d4af37; padding:5px 10px; cursor:pointer;">Forward ▶</button>
        </div>

        <div class="info-grid">
            <div class="info-item">Sun Position: <span id="sun-pos">0°</span></div>
            <div class="info-item">Moon Position: <span id="moon-pos">0°</span></div>
            <div class="info-item">Metonic Cycle: <span id="metonic">Year 1</span></div>
            <div class="info-item">Saros Cycle: <span id="saros">Eclipse N/A</span></div>
        </div>
    </div>

<script>
    // Scene Setup
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x050505);
    scene.fog = new THREE.FogExp2(0x050505, 0.02);

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 15, 30);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    container.appendChild(renderer.domElement);

    // Lighting
    const ambientLight = new THREE.AmbientLight(0x404040, 2);
    scene.add(ambientLight);

    const pointLight = new THREE.PointLight(0xffaa00, 1.5, 100);
    pointLight.position.set(10, 20, 10);
    pointLight.castShadow = true;
    scene.add(pointLight);

    const spotLight = new THREE.SpotLight(0xffffff, 1);
    spotLight.position.set(-10, 20, -5);
    scene.add(spotLight);

    // Materials
    const bronzeMaterial = new THREE.MeshStandardMaterial({
        color: 0xcd7f32,
        metalness: 0.8,
        roughness: 0.4,
    });

    const goldMaterial = new THREE.MeshStandardMaterial({
        color: 0xd4af37,
        metalness: 0.9,
        roughness: 0.2,
    });

    const woodMaterial = new THREE.MeshStandardMaterial({
        color: 0x5c4033,
        roughness: 0.9,
    });

    // Gear Generator
    function createGear(teeth, radius, thickness, colorMaterial = bronzeMaterial) {
        const group = new THREE.Group();
        
        // Gear Body
        const geometry = new THREE.CylinderGeometry(radius, radius, thickness, teeth * 2);
        const mesh = new THREE.Mesh(geometry, colorMaterial);
        mesh.rotation.x = Math.PI / 2;
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        group.add(mesh);

        // Teeth
        const toothGeo = new THREE.BoxGeometry(radius * 0.2, thickness, radius * 0.2);
        for (let i = 0; i < teeth; i++) {
            const angle = (i / teeth) * Math.PI * 2;
            const tooth = new THREE.Mesh(toothGeo, colorMaterial);
            tooth.position.set(Math.cos(angle) * radius, Math.sin(angle) * radius, 0);
            tooth.rotation.z = angle;
            group.add(tooth);
        }

        // Spokes (Visual)
        if (radius > 2) {
            const spokeGeo = new THREE.CylinderGeometry(0.2, 0.2, radius * 1.8, 8);
            const spoke1 = new THREE.Mesh(spokeGeo, colorMaterial);
            spoke1.rotation.z = Math.PI / 2;
            group.add(spoke1);
            const spoke2 = new THREE.Mesh(spokeGeo, colorMaterial);
            group.add(spoke2);
        }

        return group;
    }

    // Build Mechanism
    const mechanism = new THREE.Group();
    scene.add(mechanism);

    // Main Drive Wheel (The Sun Gear)
    const mainGear = createGear(64, 5, 0.5, goldMaterial);
    mechanism.add(mainGear);

    // Moon Train
    const moonGear1 = createGear(32, 2.5, 0.5);
    moonGear1.position.set(7.5, 0, 0);
    mechanism.add(moonGear1);

    const moonGear2 = createGear(48, 3.8, 0.5);
    moonGear2.position.set(7.5, 0, 1); // Stacked
    mechanism.add(moonGear2);

    const moonGear3 = createGear(24, 2, 0.5);
    moonGear3.position.set(13.3, 0, 1);
    mechanism.add(moonGear3);

    // Planet Train (Simplified)
    const planetGear1 = createGear(40, 3.2, 0.5);
    planetGear1.position.set(-8.2, 0, 0);
    mechanism.add(planetGear1);

    const planetGear2 = createGear(20, 1.6, 0.5);
    planetGear2.position.set(-8.2, 0, -1);
    mechanism.add(planetGear2);

    // Case / Frame
    const frameGeo = new THREE.BoxGeometry(30, 20, 5);
    const frame = new THREE.Mesh(frameGeo, new THREE.MeshStandardMaterial({ color: 0x333333, wireframe: true, transparent: true, opacity: 0.1 }));
    frame.position.z = -2;
    scene.add(frame);

    // Pointers
    const pointerGeo = new THREE.BoxGeometry(0.5, 8, 0.1);
    const sunPointer = new THREE.Mesh(pointerGeo, goldMaterial);
    sunPointer.position.z = 2;
    scene.add(sunPointer);

    const moonPointer = new THREE.Mesh(pointerGeo, new THREE.MeshStandardMaterial({color: 0xaaaaaa}));
    moonPointer.position.z = 2.2;
    moonPointer.scale.set(0.8, 0.8, 1);
    scene.add(moonPointer);

    // Animation Loop
    let crankValue = 0;
    let targetCrankValue = 0;

    function animate() {
        requestAnimationFrame(animate);

        // Smooth crank movement
        crankValue += (targetCrankValue - crankValue) * 0.1;

        // Rotate Gears
        // Main Gear (1 turn = 1 year approx in this sim)
        mainGear.rotation.z = -crankValue * 0.1;
        
        // Sun Pointer
        sunPointer.rotation.z = -crankValue * 0.1;

        // Moon Train Logic (Simplified Ratios)
        // 64 -> 32 (2x speed)
        moonGear1.rotation.z = crankValue * 0.2;
        moonGear2.rotation.z = crankValue * 0.2; // Fixed to gear 1
        
        // 48 -> 24 (2x speed relative to gear 2, so 4x total)
        moonGear3.rotation.z = -crankValue * 0.4;

        // Moon Pointer (Approx 12-13x faster than sun)
        moonPointer.rotation.z = -crankValue * 1.3;

        // Planet Train
        planetGear1.rotation.z = crankValue * 0.15;
        planetGear2.rotation.z = crankValue * 0.15;

        // Camera Orbit (Subtle)
        const time = Date.now() * 0.0005;
        camera.position.x = Math.sin(time * 0.2) * 5;
        camera.lookAt(0, 0, 0);

        renderer.render(scene, camera);
        updateUI();
    }

    // UI Logic
    const crankInput = document.getElementById('crank');
    const dateDisplay = document.getElementById('date-display');
    const sunPosDisplay = document.getElementById('sun-pos');
    const moonPosDisplay = document.getElementById('moon-pos');
    const metonicDisplay = document.getElementById('metonic');
    const sarosDisplay = document.getElementById('saros');

    crankInput.addEventListener('input', (e) => {
        targetCrankValue = parseFloat(e.target.value);
    });

    document.getElementById('btn-forward').addEventListener('mousedown', () => {
        const interval = setInterval(() => {
            crankInput.value = parseFloat(crankInput.value) + 1;
            targetCrankValue = parseFloat(crankInput.value);
            if(crankInput.value >= 1000) clearInterval(interval);
        }, 16);
        document.getElementById('btn-forward').addEventListener('mouseup', () => clearInterval(interval), {once:true});
        document.getElementById('btn-forward').addEventListener('mouseleave', () => clearInterval(interval), {once:true});
    });

    document.getElementById('btn-reverse').addEventListener('mousedown', () => {
        const interval = setInterval(() => {
            crankInput.value = parseFloat(crankInput.value) - 1;
            targetCrankValue = parseFloat(crankInput.value);
            if(crankInput.value <= 0) clearInterval(interval);
        }, 16);
        document.getElementById('btn-reverse').addEventListener('mouseup', () => clearInterval(interval), {once:true});
        document.getElementById('btn-reverse').addEventListener('mouseleave', () => clearInterval(interval), {once:true});
    });

    function updateUI() {
        // Calculate Date (Starting 100 BC)
        // 1 full crank rotation (value 10) = 1 Year
        const yearsPassed = crankValue / 10;
        const currentYear = 100 - yearsPassed;
        const yearText = currentYear > 0 ? Math.floor(currentYear) + " BC" : Math.floor(Math.abs(currentYear)) + " AD";
        dateDisplay.textContent = "Date: " + yearText;

        // Sun Position (0-360)
        const sunDeg = (crankValue * 0.1 * (180/Math.PI)) % 360;
        sunPosDisplay.textContent = Math.floor(Math.abs(sunDeg)) + "°";

        // Moon Position
        const moonDeg = (crankValue * 1.3 * (180/Math.PI)) % 360;
        moonPosDisplay.textContent = Math.floor(Math.abs(moonDeg)) + "°";

        // Metonic Cycle (19 years)
        const metonicYear = Math.floor(yearsPassed % 19) + 1;
        metonicDisplay.textContent = "Year " + metonicYear + " of 19";

        // Saros Cycle (Eclipse Prediction - Simplified)
        // Occurs roughly every 18 years, 11 days
        const sarosProgress = (yearsPassed % 18.03) / 18.03;
        if (sarosProgress > 0.98 || sarosProgress < 0.02) {
            sarosDisplay.textContent = "ECLIPSE IMMINENT";
            sarosDisplay.style.color = "#ff4444";
        } else {
            sarosDisplay.textContent = "No Eclipse";
            sarosDisplay.style.color = "#d4af37";
        }
    }

    // Handle Resize
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Remove loading text
    document.getElementById('loading').style.opacity = 0;
    animate();

</script>
</body>
</html>