<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Antikythera Mechanism: Gear Sandbox</title>
    <style>
        :root {
            --bg: #1a1a1a;
            --panel: #252525;
            --text: #e0e0e0;
            --accent: #d4af37; /* Gold/Brass */
            --accent-hover: #f4cf57;
            --grid: #333;
        }
        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg);
            color: var(--text);
            font-family: 'Segoe UI', monospace;
            user-select: none;
        }
        #canvas {
            display: block;
            cursor: crosshair;
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: none;
        }
        .panel {
            background: var(--panel);
            padding: 10px;
            border: 1px solid #444;
            border-radius: 4px;
            pointer-events: auto;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            width: 200px;
        }
        .panel h2 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 1px;
            border-bottom: 1px solid #444;
            padding-bottom: 5px;
        }
        .control-group {
            margin-bottom: 10px;
        }
        .control-group label {
            display: block;
            font-size: 11px;
            color: #888;
            margin-bottom: 2px;
        }
        button {
            background: #333;
            color: #fff;
            border: 1px solid #555;
            padding: 6px 12px;
            cursor: pointer;
            border-radius: 2px;
            font-size: 12px;
            width: 100%;
            margin-bottom: 5px;
            transition: all 0.2s;
        }
        button:hover {
            background: #444;
            border-color: var(--accent);
            color: var(--accent);
        }
        button.active {
            background: var(--accent);
            color: #000;
            border-color: var(--accent);
        }
        input[type="range"] {
            width: 100%;
            accent-color: var(--accent);
        }
        input[type="number"] {
            background: #111;
            border: 1px solid #444;
            color: #fff;
            padding: 4px;
            width: 60px;
        }
        .info-value {
            float: right;
            color: var(--accent);
            font-weight: bold;
        }
        #tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            display: none;
            border: 1px solid var(--accent);
            z-index: 100;
        }
    </style>
</head>
<body>

    <div id="ui">
        <div class="panel">
            <h2>Toolbox</h2>
            <button onclick="app.setTool('select')" id="btn-select" class="active">Select / Drag</button>
            <button onclick="app.setTool('belt')" id="btn-belt">Add Belt (Click 2 Gears)</button>
            <button onclick="app.addGear()">Add Gear</button>
            <button onclick="app.addMotor()">Add Motor</button>
            <button onclick="app.clearScene()">Clear All</button>
        </div>
        
        <div class="panel" id="properties-panel" style="display: none;">
            <h2>Properties</h2>
            <div class="control-group">
                <label>Teeth Count <span id="teeth-val" class="info-value">20</span></label>
                <input type="range" id="teeth-input" min="8" max="60" step="1" value="20" oninput="app.updateSelected('teeth', this.value)">
            </div>
            <div class="control-group">
                <label>Speed (RPM)</label>
                <div id="rpm-display" style="font-family: monospace; font-size: 14px; color: #fff;">0.00</div>
            </div>
            <div class="control-group">
                <label>Ratio (to Driver)</label>
                <div id="ratio-display" style="font-family: monospace; font-size: 14px; color: #fff;">1:1</div>
            </div>
            <button onclick="app.deleteSelected()" style="background: #522; border-color: #844;">Delete</button>
        </div>

        <div class="panel">
            <h2>Simulation</h2>
            <div class="control-group">
                <label>Motor Speed</label>
                <input type="range" id="motor-speed" min="-100" max="100" value="20" oninput="app.updateMotorSpeed(this.value)">
            </div>
            <div class="control-group">
                <label>Show Connections <input type="checkbox" checked onchange="app.toggleDebug(this.checked)" style="float:right; width:auto;"></label>
            </div>
        </div>
    </div>

    <div id="tooltip"></div>
    <canvas id="canvas"></canvas>

<script>
/**
 * The Antikythera Mechanism - Gear Sandbox
 * A kinematic gear simulator.
 */

const MODULE = 10; // Size scaling factor for teeth
const PRESSURE_ANGLE = 20 * (Math.PI / 180); // Standard gear pressure angle

class Gear {
    constructor(x, y, teeth) {
        this.id = Math.random().toString(36).substr(2, 9);
        this.x = x;
        this.y = y;
        this.teeth = teeth;
        this.angle = 0;
        this.rpm = 0;
        this.ratio = 1; // Ratio relative to driver
        this.isDriver = false;
        this.connected = []; // List of connected gears
        this.color = '#d4af37'; // Brass
        this.updateGeometry();
    }

    updateGeometry() {
        // Pitch Diameter = Module * Teeth
        // Pitch Radius = Pitch Diameter / 2
        this.radius = (MODULE * this.teeth) / 2;
        this.outerRadius = this.radius + MODULE;
        this.innerRadius = this.radius - MODULE * 1.25;
    }

    draw(ctx, isSelected) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);

        // Draw Gear Body
        ctx.beginPath();
        const holeRadius = MODULE * 1.5;
        
        // Gear shape with teeth
        const numPoints = this.teeth * 2;
        for (let i = 0; i < numPoints; i++) {
            const theta = (i / numPoints) * Math.PI * 2;
            const r = (i % 2 === 0) ? this.outerRadius : this.innerRadius;
            // Involute approximation (trapezoidal teeth)
            // Simple visual approximation
            const toothDepth = MODULE * 2.25;
            const rBase = this.radius - toothDepth/2;
            const rTip = this.radius + toothDepth/2;
            
            // Better visual drawing
            // We'll just draw a circle with notches for now for performance/simplicity
            // or a proper polygon
        }

        // Draw solid circle for body
        ctx.fillStyle = this.isDriver ? '#cd7f32' : '#555'; // Copper for driver, Steel for others
        if (this.color === '#d4af37') ctx.fillStyle = '#d4af37'; // Brass default
        
        if (isSelected) {
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur = 15;
        }

        // Draw Teeth
        ctx.fillStyle = isSelected ? '#ffeebb' : this.color;
        
        const toothAngle = (Math.PI * 2) / this.teeth;
        const halfTooth = toothAngle / 2;
        
        ctx.beginPath();
        for (let i = 0; i < this.teeth; i++) {
            const a0 = i * toothAngle;
            const a1 = a0 + halfTooth * 0.3; // Tooth start
            const a2 = a0 + halfTooth * 0.7; // Tooth tip start
            const a3 = a0 + toothAngle - halfTooth * 0.7; // Tooth tip end
            const a4 = a0 + toothAngle - halfTooth * 0.3; // Tooth end
            
            // Base
            ctx.arc(0, 0, this.innerRadius, a4 - toothAngle, a1);
            // Tooth
            ctx.lineTo(Math.cos(a2) * this.outerRadius, Math.sin(a2) * this.outerRadius);
            ctx.arc(0, 0, this.outerRadius, a2, a3);
            ctx.lineTo(Math.cos(a4) * this.innerRadius, Math.sin(a4) * this.innerRadius);
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        // Inner hole
        ctx.beginPath();
        ctx.arc(0, 0, holeRadius, 0, Math.PI * 2);
        ctx.fillStyle = '#1a1a1a';
        ctx.fill();
        ctx.strokeStyle = '#333';
        ctx.stroke();

        // Spokes
        ctx.beginPath();
        ctx.strokeStyle = isSelected ? '#b8860b' : '#8b4513';
        ctx.lineWidth = 2;
        if (this.teeth > 15) {
            for(let i=0; i<4; i++) {
                ctx.moveTo(Math.cos(i*Math.PI/2)*holeRadius, Math.sin(i*Math.PI/2)*holeRadius);
                ctx.lineTo(Math.cos(i*Math.PI/2)*(this.innerRadius-5), Math.sin(i*Math.PI/2)*(this.innerRadius-5));
            }
            ctx.stroke();
        }

        // Visual Marker to see rotation
        ctx.beginPath();
        ctx.fillStyle = '#000';
        ctx.arc(this.radius * 0.7, 0, 3, 0, Math.PI*2);
        ctx.fill();

        ctx.restore();

        // Draw Motor Icon if driver
        if (this.isDriver) {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.fillStyle = '#ff4444';
            ctx.beginPath();
            ctx.arc(0, 0, 5, 0, Math.PI*2);
            ctx.fill();
            ctx.restore();
        }
    }
}

class App {
    constructor() {
        this.canvas = document.getElementById('canvas');
        this.ctx = this.canvas.getContext('2d');
        this.gears = [];
        this.belts = []; // { g1, g2 }
        this.selectedGear = null;
        this.draggedGear = null;
        this.beltStartGear = null; // For creating belts
        this.dragOffset = { x: 0, y: 0 };
        this.tool = 'select';
        this.motorSpeed = 20; // RPM
        this.showDebug = true;
        
        this.resize();
        window.addEventListener('resize', () => this.resize());
        
        // Input Handling
        this.canvas.addEventListener('mousedown', e => this.onMouseDown(e));
        this.canvas.addEventListener('mousemove', e => this.onMouseMove(e));
        this.canvas.addEventListener('mouseup', e => this.onMouseUp(e));
        this.canvas.addEventListener('wheel', e => this.onWheel(e));

        // Start Loop
        this.lastTime = performance.now();
        this.animate();
    }

    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
    }

    setTool(tool) {
        this.tool = tool;
        document.querySelectorAll('#ui button').forEach(b => b.classList.remove('active'));
        if(tool === 'select') document.getElementById('btn-select').classList.add('active');
    }

    addGear() {
        const g = new Gear(this.canvas.width/2, this.canvas.height/2, 20);
        // Random slight offset to avoid perfect stacking
        g.x += (Math.random() - 0.5) * 50;
        g.y += (Math.random() - 0.5) * 50;
        this.gears.push(g);
        this.selectGear(g);
    }

    addMotor() {
        const g = new Gear(this.canvas.width/2, this.canvas.height/2, 12);
        g.isDriver = true;
        g.color = '#cd7f32'; // Copper
        this.gears.push(g);
        this.selectGear(g);
    }

    clearScene() {
        this.gears = [];
        this.belts = [];
        this.selectedGear = null;
        document.getElementById('properties-panel').style.display = 'none';
    }

    deleteSelected() {
        if (this.selectedGear) {
            // Remove belts connected to this gear
            this.belts = this.belts.filter(b => b.g1 !== this.selectedGear && b.g2 !== this.selectedGear);
            
            const idx = this.gears.indexOf(this.selectedGear);
            if (idx > -1) this.gears.splice(idx, 1);
            this.selectedGear = null;
            document.getElementById('properties-panel').style.display = 'none';
        }
    }

    updateSelected(prop, val) {
        if (this.selectedGear) {
            if (prop === 'teeth') {
                this.selectedGear.teeth = parseInt(val);
                this.selectedGear.updateGeometry();
                document.getElementById('teeth-val').textContent = val;
            }
        }
    }

    updateMotorSpeed(val) {
        this.motorSpeed = parseFloat(val);
    }

    toggleDebug(val) {
        this.showDebug = val;
    }

    selectGear(g) {
        this.selectedGear = g;
        const panel = document.getElementById('properties-panel');
        if (g) {
            panel.style.display = 'block';
            document.getElementById('teeth-input').value = g.teeth;
            document.getElementById('teeth-val').textContent = g.teeth;
        } else {
            panel.style.display = 'none';
        }
    }

    getGearAt(x, y) {
        // Reverse iterate to pick top-most
        for (let i = this.gears.length - 1; i >= 0; i--) {
            const g = this.gears[i];
            const dx = x - g.x;
            const dy = y - g.y;
            if (dx*dx + dy*dy < g.radius * g.radius) {
                return g;
            }
        }
        return null;
    }

    onMouseDown(e) {
        const rect = this.canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        const g = this.getGearAt(x, y);
        
        if (this.tool === 'belt') {
            if (g) {
                if (!this.beltStartGear) {
                    this.beltStartGear = g;
                    // Visual feedback?
                } else {
                    if (g !== this.beltStartGear) {
                        // Create Belt
                        this.belts.push({ g1: this.beltStartGear, g2: g });
                        this.beltStartGear = null;
                        this.setTool('select'); // Auto switch back
                    }
                }
            } else {
                this.beltStartGear = null; // Cancel
            }
            return;
        }
        
        if (g) {
            this.selectGear(g);
            this.draggedGear = g;
            this.dragOffset.x = x - g.x;
            this.dragOffset.y = y - g.y;
        } else {
            this.selectGear(null);
        }
    }

    onMouseMove(e) {
        const rect = this.canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        if (this.draggedGear) {
            this.draggedGear.x = x - this.dragOffset.x;
            this.draggedGear.y = y - this.dragOffset.y;
            
            // Snap Logic
            // Find closest gear
            let closest = null;
            let minDist = Infinity;
            
            for (const other of this.gears) {
                if (other === this.draggedGear) continue;
                const dx = this.draggedGear.x - other.x;
                const dy = this.draggedGear.y - other.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                const targetDist = this.draggedGear.radius + other.radius;
                
                // Snap distance threshold
                if (Math.abs(dist - targetDist) < 15) {
                    if (dist < minDist) {
                        minDist = dist;
                        closest = other;
                    }
                }
            }
            
            if (closest) {
                // Snap position
                const dx = this.draggedGear.x - closest.x;
                const dy = this.draggedGear.y - closest.y;
                const angle = Math.atan2(dy, dx);
                const targetDist = this.draggedGear.radius + closest.radius; // Add small gap? No, pitch circles touch.
                
                this.draggedGear.x = closest.x + Math.cos(angle) * targetDist;
                this.draggedGear.y = closest.y + Math.sin(angle) * targetDist;
                
                // Align teeth visually (simple rotation snap)
                // This is purely visual, the solver handles the math
            }
        }
        
        // Tooltip
        const hoverGear = this.getGearAt(x, y);
        const tip = document.getElementById('tooltip');
        if (hoverGear) {
            tip.style.display = 'block';
            tip.style.left = (e.clientX + 15) + 'px';
            tip.style.top = (e.clientY + 15) + 'px';
            tip.innerHTML = `Teeth: ${hoverGear.teeth}<br>RPM: ${hoverGear.rpm.toFixed(2)}`;
        } else {
            tip.style.display = 'none';
        }
    }

    onMouseUp(e) {
        this.draggedGear = null;
    }
    
    onWheel(e) {
        // Zoom? Maybe later.
    }

    // --- Physics / Kinematics Solver ---
    
    solve() {
        // 1. Reset all gears to 0 RPM (except drivers)
        for (const g of this.gears) {
            if (g.isDriver) {
                g.rpm = this.motorSpeed;
            } else {
                g.rpm = 0;
                g.ratio = 0;
            }
            g.visited = false;
        }

        // 2. Build Graph / Find Connections
        // We do this every frame for dynamic dragging. In a static sim, we'd cache this.
        const connections = [];
        
        // Gear Meshing
        for (let i = 0; i < this.gears.length; i++) {
            for (let j = i + 1; j < this.gears.length; j++) {
                const g1 = this.gears[i];
                const g2 = this.gears[j];
                
                const dx = g1.x - g2.x;
                const dy = g1.y - g2.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                const targetDist = g1.radius + g2.radius;
                
                // Tolerance for meshing
                if (Math.abs(dist - targetDist) < 2) {
                    connections.push({ g1, g2, type: 'mesh' });
                }
            }
        }
        
        // Belts
        for (const b of this.belts) {
            connections.push({ g1: b.g1, g2: b.g2, type: 'belt' });
        }

        // 3. Propagate Rotation (BFS)
        const queue = this.gears.filter(g => g.isDriver);
        queue.forEach(g => g.visited = true);
        
        while (queue.length > 0) {
            const current = queue.shift();
            
            // Find neighbors
            for (const conn of connections) {
                let neighbor = null;
                if (conn.g1 === current) neighbor = conn.g2;
                else if (conn.g2 === current) neighbor = conn.g1;
                
                if (neighbor && !neighbor.visited) {
                    // Calculate Ratio
                    // Gear Ratio = T1 / T2
                    
                    const ratio = current.teeth / neighbor.teeth;
                    
                    if (conn.type === 'mesh') {
                        // Mesh: Reverse direction
                        neighbor.rpm = current.rpm * ratio * -1;
                        neighbor.ratio = current.ratio * ratio * -1;
                    } else {
                        // Belt: Same direction (usually)
                        // Belt Ratio depends on radii (which depends on teeth if module is same)
                        // R1 * w1 = R2 * w2 => w2 = w1 * (R1/R2) = w1 * (T1/T2)
                        neighbor.rpm = current.rpm * ratio;
                        neighbor.ratio = current.ratio * ratio;
                    }
                    
                    neighbor.visited = true;
                    queue.push(neighbor);
                } else if (neighbor && neighbor.visited) {
                    // Conflict check? (Jamming)
                    // For this sandbox, we ignore jamming and let the first path win
                    // Or we could highlight it red
                }
            }
        }
    }

    animate() {
        const now = performance.now();
        const dt = (now - this.lastTime) / 1000; // Seconds
        this.lastTime = now;

        this.solve();

        // Update Angles
        for (const g of this.gears) {
            // RPM to Radians per second
            // RPM * 2PI / 60
            const radPerSec = g.rpm * (Math.PI * 2) / 60;
            g.angle += radPerSec * dt;
        }
        
        // Update UI for selected
        if (this.selectedGear) {
            document.getElementById('rpm-display').textContent = this.selectedGear.rpm.toFixed(2);
            const r = Math.abs(this.selectedGear.rpm / (this.motorSpeed || 1));
            document.getElementById('ratio-display').textContent = r.toFixed(3) + ":1";
        }

        // Draw
        this.ctx.fillStyle = '#1a1a1a';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Draw Grid
        this.ctx.strokeStyle = '#222';
        this.ctx.lineWidth = 1;
        this.ctx.beginPath();
        for(let x=0; x<this.canvas.width; x+=50) { this.ctx.moveTo(x,0); this.ctx.lineTo(x,this.canvas.height); }
        for(let y=0; y<this.canvas.height; y+=50) { this.ctx.moveTo(0,y); this.ctx.lineTo(this.canvas.width,y); }
        this.ctx.stroke();

        // Draw Connections (Debug)
        if (this.showDebug) {
            this.ctx.strokeStyle = '#00ff00';
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            for (let i = 0; i < this.gears.length; i++) {
                for (let j = i + 1; j < this.gears.length; j++) {
                    const g1 = this.gears[i];
                    const g2 = this.gears[j];
                    const dist = Math.hypot(g1.x - g2.x, g1.y - g2.y);
                    if (Math.abs(dist - (g1.radius + g2.radius)) < 2) {
                        this.ctx.moveTo(g1.x, g1.y);
                        this.ctx.lineTo(g2.x, g2.y);
                    }
                }
            }
            this.ctx.stroke();
        }

        // Draw Belts
        this.ctx.lineWidth = 4;
        this.ctx.lineCap = 'round';
        this.ctx.lineJoin = 'round';
        
        for (const b of this.belts) {
            const g1 = b.g1;
            const g2 = b.g2;
            
            // Tangent lines for belt
            // Simple visual approximation: Line between edges
            // Real belt drawing is complex (tangent points of two circles)
            // We'll just draw a thick line between centers behind gears for now, 
            // or slightly better: lines connecting the outer radii
            
            const angle = Math.atan2(g2.y - g1.y, g2.x - g1.x);
            const perp = angle + Math.PI/2;
            
            this.ctx.strokeStyle = '#554433'; // Leather belt color
            
            this.ctx.beginPath();
            // Top line
            this.ctx.moveTo(g1.x + Math.cos(perp)*g1.radius, g1.y + Math.sin(perp)*g1.radius);
            this.ctx.lineTo(g2.x + Math.cos(perp)*g2.radius, g2.y + Math.sin(perp)*g2.radius);
            // Bottom line
            this.ctx.moveTo(g1.x - Math.cos(perp)*g1.radius, g1.y - Math.sin(perp)*g1.radius);
            this.ctx.lineTo(g2.x - Math.cos(perp)*g2.radius, g2.y - Math.sin(perp)*g2.radius);
            this.ctx.stroke();
        }

        // Draw Gears
        for (const g of this.gears) {
            g.draw(this.ctx, g === this.selectedGear);
        }
        
        // Draw Belt Creation Line
        if (this.tool === 'belt' && this.beltStartGear) {
            // We need mouse pos here, but we don't store it globally. 
            // Let's skip for MVP or add mouse tracking.
        }

        requestAnimationFrame(() => this.animate());
    }
}

const app = new App();

// Initial Demo Scene
app.addMotor();
const driver = app.gears[0];
driver.x = window.innerWidth/2 - 100;

const g2 = new Gear(window.innerWidth/2, window.innerHeight/2, 40);
app.gears.push(g2);
// Snap g2 to driver
g2.x = driver.x + driver.radius + g2.radius;
g2.y = driver.y;

const g3 = new Gear(window.innerWidth/2 + 100, window.innerHeight/2, 10);
app.gears.push(g3);
// Snap g3 to g2
g3.x = g2.x + g2.radius + g3.radius;
g3.y = g2.y;

</script>
</body>
</html>