<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Dual Camera AR Scene Creator - iOS</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', 'Helvetica Neue', sans-serif;
            background-color: #000;
            color: #fff;
            height: 100vh;
            overflow: hidden;
            position: fixed;
            width: 100%;
        }

        .app-container {
            height: 100vh;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .header {
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            padding: env(safe-area-inset-top) 15px 10px;
            text-align: center;
            position: fixed;
            width: 100%;
            top: 0;
            z-index: 100;
            border-bottom: 0.5px solid rgba(255, 255, 255, 0.1);
        }

        .header h1 {
            font-size: 17px;
            font-weight: 600;
            margin: 0;
        }

        .status {
            font-size: 13px;
            color: #86868b;
            margin-top: 2px;
        }

        .status.recording {
            color: #ff3b30;
            animation: pulse 1.5s infinite;
        }

        .status.processing {
            color: #007aff;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding-top: calc(env(safe-area-inset-top) + 60px);
            height: 100vh;
        }

        .camera-container {
            flex: 1;
            position: relative;
            display: flex;
            background: #000;
        }

        .video-split {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        .video-split:first-child {
            border-right: 1px solid rgba(255, 255, 255, 0.1);
        }

        video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }

        .video-label {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 500;
        }

        .ar-viewer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: none;
            z-index: 50;
        }

        .ar-viewer.active {
            display: block;
        }

        #arCanvas {
            width: 100%;
            height: 100%;
            display: block;
            touch-action: none;
        }

        .controls-container {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            padding: 15px;
            padding-bottom: calc(env(safe-area-inset-bottom) + 15px);
            border-top: 0.5px solid rgba(255, 255, 255, 0.1);
            z-index: 101;
        }

        .control-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 10px;
        }

        button {
            background: #1c1c1e;
            border: none;
            color: #fff;
            padding: 12px 20px;
            border-radius: 10px;
            font-size: 15px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.2s;
            flex: 1;
            justify-content: center;
            max-width: 150px;
        }

        button:active {
            transform: scale(0.95);
            opacity: 0.7;
        }

        button:disabled {
            opacity: 0.3;
        }

        button.primary {
            background: #007aff;
        }

        button.danger {
            background: #ff3b30;
        }

        button.success {
            background: #34c759;
        }

        .view-controls {
            display: none;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
        }

        .view-controls.active {
            display: flex;
        }

        .view-controls button {
            flex: 0 0 auto;
            padding: 8px 12px;
            font-size: 13px;
        }

        .progress-bar {
            height: 3px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            margin: 10px 0;
            overflow: hidden;
            display: none;
        }

        .progress-bar.active {
            display: block;
        }

        .progress-fill {
            height: 100%;
            background: #007aff;
            border-radius: 2px;
            transition: width 0.3s ease;
            width: 0%;
        }

        .stats-row {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 10px;
            font-size: 12px;
            color: #86868b;
        }

        .stat {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .stat strong {
            color: #fff;
        }

        .error-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            padding: 20px;
            border-radius: 12px;
            max-width: 80%;
            text-align: center;
            z-index: 200;
            display: none;
        }

        .error-message.active {
            display: block;
        }

        .loading-spinner {
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-top-color: #007aff;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            display: inline-block;
            margin-right: 8px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        @media (orientation: landscape) {
            .camera-container {
                flex-direction: row;
            }
        }

        @media (max-height: 600px) {
            .header {
                padding-top: 10px;
            }
            .main-content {
                padding-top: 50px;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="header">
            <h1>Dual Camera AR</h1>
            <div class="status" id="status">Initializing cameras...</div>
        </div>

        <div class="main-content">
            <div class="camera-container" id="cameraContainer">
                <div class="video-split">
                    <video id="frontVideo" autoplay muted playsinline></video>
                    <div class="video-label">Front</div>
                </div>
                <div class="video-split">
                    <video id="backVideo" autoplay muted playsinline></video>
                    <div class="video-label">Back</div>
                </div>
            </div>

            <div class="ar-viewer" id="arViewer">
                <canvas id="arCanvas"></canvas>
            </div>
        </div>

        <div class="controls-container">
            <div class="control-buttons" id="recordControls">
                <button id="startBtn" class="primary" disabled>
                    <span>üî¥</span> Record
                </button>
                <button id="stopBtn" class="danger" disabled>
                    <span>‚èπ</span> Stop
                </button>
            </div>

            <div class="control-buttons" id="processControls" style="display: none;">
                <button id="processBtn" class="primary">
                    <span>üé®</span> Create 3D
                </button>
                <button id="viewToggleBtn">
                    <span>üëÅ</span> View
                </button>
            </div>

            <div class="view-controls" id="viewControls">
                <button id="resetViewBtn">Reset</button>
                <button id="togglePointsBtn">Points</button>
                <button id="toggleMeshBtn">Mesh</button>
                <button id="exportBtn" class="success">Export</button>
            </div>

            <div class="progress-bar" id="progressBar">
                <div class="progress-fill" id="progressFill"></div>
            </div>

            <div class="stats-row" id="statsRow" style="display: none;">
                <div class="stat">
                    <span>Points:</span> <strong id="pointCount">0</strong>
                </div>
                <div class="stat">
                    <span>Frames:</span> <strong id="frameCount">0</strong>
                </div>
                <div class="stat">
                    <span>Quality:</span> <strong id="quality">-</strong>
                </div>
            </div>
        </div>

        <div class="error-message" id="errorMessage">
            <p id="errorText"></p>
            <button onclick="location.reload()">Reload</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // iOS-specific optimizations
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
        
        // Global variables
        let frontStream = null;
        let backStream = null;
        let frontRecorder = null;
        let backRecorder = null;
        let frontChunks = [];
        let backChunks = [];
        let isRecording = false;
        let scene, camera, renderer;
        let pointCloud, mesh;
        let capturedFrames = [];
        let recordedBlobs = null;

        // DOM elements
        const frontVideo = document.getElementById('frontVideo');
        const backVideo = document.getElementById('backVideo');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const processBtn = document.getElementById('processBtn');
        const viewToggleBtn = document.getElementById('viewToggleBtn');
        const exportBtn = document.getElementById('exportBtn');
        const status = document.getElementById('status');
        const progressBar = document.getElementById('progressBar');
        const progressFill = document.getElementById('progressFill');
        const arCanvas = document.getElementById('arCanvas');
        const arViewer = document.getElementById('arViewer');
        const cameraContainer = document.getElementById('cameraContainer');
        const recordControls = document.getElementById('recordControls');
        const processControls = document.getElementById('processControls');
        const viewControls = document.getElementById('viewControls');
        const statsRow = document.getElementById('statsRow');
        const errorMessage = document.getElementById('errorMessage');
        const errorText = document.getElementById('errorText');

        // Show error message
        function showError(message) {
            errorText.textContent = message;
            errorMessage.classList.add('active');
        }

        // Initialize cameras with iOS-specific constraints
        async function initCameras() {
            try {
                status.innerHTML = '<span class="loading-spinner"></span>Setting up cameras...';
                
                // Get camera permissions first
                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoDevices = devices.filter(device => device.kind === 'videoinput');
                
                console.log('Found video devices:', videoDevices.length);
                
                if (videoDevices.length < 2) {
                    throw new Error('Two cameras required. Please ensure camera access is granted.');
                }

                // iOS-specific camera constraints - MAX QUALITY
                const constraints = {
                    front: {
                        video: {
                            facingMode: 'user',
                            width: { ideal: 1920 },
                            height: { ideal: 1080 },
                            frameRate: { ideal: 30 }
                        },
                        audio: false
                    },
                    back: {
                        video: {
                            facingMode: { exact: 'environment' },
                            width: { ideal: 1920 },
                            height: { ideal: 1080 },
                            frameRate: { ideal: 30 }
                        },
                        audio: false
                    }
                };

                // Get front camera
                try {
                    frontStream = await navigator.mediaDevices.getUserMedia(constraints.front);
                    frontVideo.srcObject = frontStream;
                    await frontVideo.play();
                } catch (err) {
                    console.error('Front camera error:', err);
                    throw new Error('Unable to access front camera');
                }

                // Get back camera
                try {
                    backStream = await navigator.mediaDevices.getUserMedia(constraints.back);
                    backVideo.srcObject = backStream;
                    await backVideo.play();
                } catch (err) {
                    console.error('Back camera error:', err);
                    // Try without exact constraint
                    constraints.back.video.facingMode = 'environment';
                    backStream = await navigator.mediaDevices.getUserMedia(constraints.back);
                    backVideo.srcObject = backStream;
                    await backVideo.play();
                }

                status.textContent = 'Ready to record';
                startBtn.disabled = false;
            } catch (err) {
                console.error('Camera initialization error:', err);
                showError(err.message);
                status.textContent = 'Camera error';
            }
        }

        // Initialize Three.js scene
        function initThreeJS() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);

            const aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(60, aspect, 0.1, 1000);
            camera.position.z = 5;

            renderer = new THREE.WebGLRenderer({ 
                canvas: arCanvas,
                antialias: true,
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio); // Full device resolution

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            scene.add(directionalLight);

            // Touch controls
            let touchStartX = 0, touchStartY = 0;
            let currentRotationX = 0, currentRotationY = 0;
            
            arCanvas.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    touchStartX = e.touches[0].clientX;
                    touchStartY = e.touches[0].clientY;
                }
            });
            
            arCanvas.addEventListener('touchmove', (e) => {
                if (e.touches.length === 1) {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const deltaX = touch.clientX - touchStartX;
                    const deltaY = touch.clientY - touchStartY;
                    
                    currentRotationX += deltaX * 0.01;
                    currentRotationY = Math.max(-Math.PI/3, Math.min(Math.PI/3, currentRotationY + deltaY * 0.01));
                    
                    touchStartX = touch.clientX;
                    touchStartY = touch.clientY;
                    
                    updateCameraPosition();
                }
            });

            // Pinch to zoom
            let initialPinchDistance = 0;
            let currentZoom = 5;
            
            arCanvas.addEventListener('touchstart', (e) => {
                if (e.touches.length === 2) {
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    initialPinchDistance = Math.sqrt(dx * dx + dy * dy);
                }
            });
            
            arCanvas.addEventListener('touchmove', (e) => {
                if (e.touches.length === 2) {
                    e.preventDefault();
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    const scale = distance / initialPinchDistance;
                    currentZoom = Math.max(2, Math.min(10, currentZoom / scale));
                    initialPinchDistance = distance;
                    
                    updateCameraPosition();
                }
            });

            function updateCameraPosition() {
                camera.position.x = Math.sin(currentRotationX) * Math.cos(currentRotationY) * currentZoom;
                camera.position.y = Math.sin(currentRotationY) * currentZoom;
                camera.position.z = Math.cos(currentRotationX) * Math.cos(currentRotationY) * currentZoom;
                camera.lookAt(0, 0, 0);
            }

            animate();
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        // Start recording
        function startRecording() {
            frontChunks = [];
            backChunks = [];
            capturedFrames = [];
            isRecording = true;

            // iOS MediaRecorder options
            const options = { 
                mimeType: isIOS ? 'video/mp4' : 'video/webm;codecs=vp9'
            };
            
            if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                options.mimeType = 'video/webm';
            }

            try {
                frontRecorder = new MediaRecorder(frontStream, options);
                backRecorder = new MediaRecorder(backStream, options);

                frontRecorder.ondataavailable = (e) => {
                    if (e.data.size > 0) frontChunks.push(e.data);
                };

                backRecorder.ondataavailable = (e) => {
                    if (e.data.size > 0) backChunks.push(e.data);
                };

                frontRecorder.onstop = handleRecordingStop;
                backRecorder.onstop = handleRecordingStop;

                frontRecorder.start(50); // Collect data every 50ms for high quality
                backRecorder.start(50);

                // Capture frames periodically
                captureFramesPeriodically();

                startBtn.disabled = true;
                stopBtn.disabled = false;
                status.textContent = 'Recording...';
                status.classList.add('recording');
            } catch (err) {
                console.error('Recording error:', err);
                showError('Recording failed. Please try again.');
                isRecording = false;
            }
        }

        // Capture frames periodically
        function captureFramesPeriodically() {
            if (!isRecording) return;

            const frontCanvas = document.createElement('canvas');
            const backCanvas = document.createElement('canvas');
            const frontCtx = frontCanvas.getContext('2d');
            const backCtx = backCanvas.getContext('2d');

            // HIGH FIDELITY - Full resolution capture
            const scale = 1.0; // No downscaling!
            frontCanvas.width = frontVideo.videoWidth * scale;
            frontCanvas.height = frontVideo.videoHeight * scale;
            backCanvas.width = backVideo.videoWidth * scale;
            backCanvas.height = backVideo.videoHeight * scale;

            frontCtx.drawImage(frontVideo, 0, 0, frontCanvas.width, frontCanvas.height);
            backCtx.drawImage(backVideo, 0, 0, backCanvas.width, backCanvas.height);

            capturedFrames.push({
                front: frontCtx.getImageData(0, 0, frontCanvas.width, frontCanvas.height),
                back: backCtx.getImageData(0, 0, backCanvas.width, backCanvas.height),
                timestamp: Date.now()
            });

            document.getElementById('frameCount').textContent = capturedFrames.length;

            // HIGH FIDELITY - Capture frame every 100ms (10fps) for dense reconstruction
            setTimeout(() => captureFramesPeriodically(), 100);
        }

        // Stop recording
        let stoppedCount = 0;
        function stopRecording() {
            isRecording = false;
            
            if (frontRecorder && frontRecorder.state !== 'inactive') {
                frontRecorder.stop();
            }
            if (backRecorder && backRecorder.state !== 'inactive') {
                backRecorder.stop();
            }

            startBtn.disabled = false;
            stopBtn.disabled = true;
            status.textContent = 'Processing...';
            status.classList.remove('recording');
        }

        function handleRecordingStop() {
            stoppedCount++;
            
            if (stoppedCount === 2) {
                stoppedCount = 0;
                
                // Create blobs
                const mimeType = isIOS ? 'video/mp4' : 'video/webm';
                recordedBlobs = {
                    front: new Blob(frontChunks, { type: mimeType }),
                    back: new Blob(backChunks, { type: mimeType })
                };
                
                // Show process controls
                recordControls.style.display = 'none';
                processControls.style.display = 'flex';
                statsRow.style.display = 'flex';
                
                status.textContent = 'Ready to create 3D scene';
            }
        }

        // Process AR scene
        async function processARScene() {
            status.textContent = 'Creating 3D scene...';
            status.classList.add('processing');
            progressBar.classList.add('active');

            // Clear previous scene
            if (pointCloud) scene.remove(pointCloud);
            if (mesh) scene.remove(mesh);

            const points = [];
            const colors = [];

            // Process frames with high detail feature extraction
            for (let i = 0; i < capturedFrames.length; i++) {
                const frame = capturedFrames[i];
                
                // Extract more features for higher fidelity
                const gridSize = 50; // Dense grid sampling
                const stepX = Math.floor(frame.front.width / gridSize);
                const stepY = Math.floor(frame.front.height / gridSize);
                
                for (let gx = 0; gx < gridSize; gx++) {
                    for (let gy = 0; gy < gridSize; gy++) {
                        const x = gx * stepX;
                        const y = gy * stepY;
                        const pixelIndex = (y * frame.front.width + x) * 4;
                        
                        // Get color from front camera
                        const r = frame.front.data[pixelIndex] / 255;
                        const g = frame.front.data[pixelIndex + 1] / 255;
                        const b = frame.front.data[pixelIndex + 2] / 255;
                        
                        // Skip very dark pixels
                        if (r + g + b < 0.1) continue;
                        
                        // Create 3D point with better depth estimation
                        const normalizedX = (x / frame.front.width - 0.5) * 2;
                        const normalizedY = (y / frame.front.height - 0.5) * 2;
                        
                        const angle = (i / capturedFrames.length) * Math.PI * 2;
                        const baseRadius = 1.5;
                        
                        // Simulate depth from brightness/disparity
                        const brightness = (r + g + b) / 3;
                        const depthVariation = 0.3 + brightness * 0.4;
                        const radius = baseRadius * depthVariation;
                        
                        // Transform based on camera rotation
                        const px = normalizedX * radius * Math.cos(angle) - normalizedY * 0.1 * Math.sin(angle);
                        const py = normalizedY * 1.2;
                        const pz = normalizedX * radius * Math.sin(angle) + normalizedY * 0.1 * Math.cos(angle);
                        
                        points.push(px, py, pz);
                        colors.push(r, g, b);
                    }
                }

                progressFill.style.width = `${((i + 1) / capturedFrames.length) * 100}%`;
                await new Promise(resolve => setTimeout(resolve, 10)); // Faster processing
            }

            // Create point cloud
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(points, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.computeBoundingSphere();

            const material = new THREE.PointsMaterial({
                size: 0.005, // Smaller points for higher detail
                vertexColors: true,
                sizeAttenuation: true,
                alphaTest: 0.8
            });

            pointCloud = new THREE.Points(geometry, material);
            scene.add(pointCloud);

            // Simple mesh
            const meshGeometry = new THREE.SphereGeometry(1.5, 16, 12);
            const meshMaterial = new THREE.MeshPhongMaterial({
                color: 0x2196F3,
                opacity: 0.2,
                transparent: true,
                wireframe: true
            });

            mesh = new THREE.Mesh(meshGeometry, meshMaterial);
            mesh.visible = false;
            scene.add(mesh);

            // Update stats
            document.getElementById('pointCount').textContent = Math.floor(points.length / 3).toLocaleString();
            document.getElementById('quality').textContent = capturedFrames.length > 20 ? 'High' : capturedFrames.length > 10 ? 'Medium' : 'Low';

            status.textContent = '3D scene created!';
            status.classList.remove('processing');
            progressBar.classList.remove('active');
            progressFill.style.width = '0%';

            // Auto show AR viewer
            showARViewer();
        }

        // Toggle between camera and AR view
        function toggleView() {
            if (arViewer.classList.contains('active')) {
                hideARViewer();
            } else {
                showARViewer();
            }
        }

        function showARViewer() {
            arViewer.classList.add('active');
            viewControls.classList.add('active');
            viewToggleBtn.innerHTML = '<span>üì∑</span> Camera';
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function hideARViewer() {
            arViewer.classList.remove('active');
            viewControls.classList.remove('active');
            viewToggleBtn.innerHTML = '<span>üëÅ</span> View 3D';
        }

        // Export functions
        function exportARScene() {
            status.textContent = 'Exporting...';
            
            // Export as PLY
            const plyData = exportToPLY();
            const plyBlob = new Blob([plyData], { type: 'text/plain' });
            const plyUrl = URL.createObjectURL(plyBlob);
            const plyLink = document.createElement('a');
            plyLink.href = plyUrl;
            plyLink.download = `ar-scene-${new Date().toISOString().slice(0, 19)}.ply`;
            plyLink.click();
            URL.revokeObjectURL(plyUrl);

            status.textContent = 'Exported!';
            setTimeout(() => {
                status.textContent = '3D scene created!';
            }, 2000);
        }

        function exportToPLY() {
            if (!pointCloud) return '';

            const positions = pointCloud.geometry.attributes.position.array;
            const colors = pointCloud.geometry.attributes.color.array;
            const numPoints = positions.length / 3;

            let ply = 'ply\n';
            ply += 'format ascii 1.0\n';
            ply += `element vertex ${numPoints}\n`;
            ply += 'property float x\n';
            ply += 'property float y\n';
            ply += 'property float z\n';
            ply += 'property uchar red\n';
            ply += 'property uchar green\n';
            ply += 'property uchar blue\n';
            ply += 'end_header\n';

            for (let i = 0; i < numPoints; i++) {
                const idx = i * 3;
                ply += `${positions[idx]} ${positions[idx + 1]} ${positions[idx + 2]} `;
                ply += `${Math.floor(colors[idx] * 255)} ${Math.floor(colors[idx + 1] * 255)} ${Math.floor(colors[idx + 2] * 255)}\n`;
            }

            return ply;
        }

        // Event listeners
        startBtn.addEventListener('click', startRecording);
        stopBtn.addEventListener('click', stopRecording);
        processBtn.addEventListener('click', processARScene);
        viewToggleBtn.addEventListener('click', toggleView);
        exportBtn.addEventListener('click', exportARScene);

        document.getElementById('resetViewBtn').addEventListener('click', () => {
            camera.position.set(0, 0, 5);
            camera.lookAt(0, 0, 0);
        });

        document.getElementById('togglePointsBtn').addEventListener('click', () => {
            if (pointCloud) pointCloud.visible = !pointCloud.visible;
        });

        document.getElementById('toggleMeshBtn').addEventListener('click', () => {
            if (mesh) mesh.visible = !mesh.visible;
        });

        // Handle orientation changes
        window.addEventListener('orientationchange', () => {
            setTimeout(() => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }, 100);
        });

        // Prevent iOS bounce scrolling
        document.body.addEventListener('touchmove', (e) => {
            if (e.target === arCanvas) {
                e.preventDefault();
            }
        }, { passive: false });

        // Initialize
        initCameras();
        initThreeJS();

        // Wake lock to prevent screen dimming during recording
        if ('wakeLock' in navigator && isIOS) {
            let wakeLock = null;
            
            async function requestWakeLock() {
                try {
                    wakeLock = await navigator.wakeLock.request('screen');
                } catch (err) {
                    console.log('Wake Lock error:', err);
                }
            }

            document.addEventListener('visibilitychange', () => {
                if (document.visibilityState === 'visible' && isRecording) {
                    requestWakeLock();
                }
            });
        }
    </script>
</body>
</html>