<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithm Visualizer Pro</title>
    <meta name="description" content="Interactive algorithm visualization: sorting (bubble, quick, merge, insertion) and searching algorithms with step-by-step animation and complexity analysis">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: #e0e0e0;
            height: 100vh;
            overflow: hidden;
        }
        #app { display: flex; height: 100vh; }
        #sidebar {
            width: 320px;
            background: rgba(20, 20, 40, 0.95);
            padding: 20px;
            overflow-y: auto;
            border-right: 2px solid #2a5298;
        }
        h1 { font-size: 18px; color: #4fc3f7; margin-bottom: 20px; }
        .section {
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }
        .section h3 { font-size: 12px; color: #4fc3f7; margin-bottom: 12px; text-transform: uppercase; }
        .algo-btn {
            width: 100%;
            padding: 10px;
            background: rgba(79, 195, 247, 0.2);
            border: 1px solid #4fc3f7;
            color: #e0e0e0;
            border-radius: 5px;
            cursor: pointer;
            margin-bottom: 8px;
            text-align: left;
            font-size: 13px;
        }
        .algo-btn:hover { background: rgba(79, 195, 247, 0.3); }
        .algo-btn.active { background: #4fc3f7; color: #000; font-weight: bold; }
        label { display: block; margin-bottom: 5px; font-size: 11px; color: #aaa; }
        input[type="range"] {
            width: 100%;
            margin-bottom: 15px;
        }
        button {
            width: 100%;
            padding: 10px;
            background: #4fc3f7;
            color: #000;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            margin-bottom: 8px;
        }
        button:hover { background: #6fd8ff; }
        button:disabled {
            background: #444;
            color: #666;
            cursor: not-allowed;
        }
        #main { flex: 1; display: flex; flex-direction: column; }
        #header {
            background: rgba(20, 20, 40, 0.95);
            padding: 20px;
            border-bottom: 2px solid #2a5298;
        }
        #header h2 { color: #4fc3f7; font-size: 20px; margin-bottom: 10px; }
        #info { font-size: 12px; color: #aaa; line-height: 1.6; }
        #canvas-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            position: relative;
        }
        canvas {
            background: rgba(20, 20, 40, 0.5);
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }
        #controls {
            background: rgba(20, 20, 40, 0.95);
            padding: 15px 20px;
            border-top: 1px solid #2a5298;
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: center;
        }
        .control-btn {
            padding: 10px 20px;
            background: #4fc3f7;
            color: #000;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }
        .control-btn:hover { background: #6fd8ff; }
        .control-btn:disabled {
            background: #444;
            color: #666;
            cursor: not-allowed;
        }
        #stats {
            position: absolute;
            top: 30px;
            right: 30px;
            background: rgba(20, 20, 40, 0.9);
            padding: 15px;
            border-radius: 8px;
            font-size: 12px;
            border: 1px solid #4fc3f7;
        }
        .stat-item { margin-bottom: 8px; }
        .stat-label { color: #aaa; }
        .stat-value { color: #4fc3f7; font-weight: bold; }
        .value-display { float: right; color: #4fc3f7; font-weight: bold; }
        .description {
            font-size: 11px;
            color: #aaa;
            margin-top: 5px;
            line-height: 1.4;
        }
        .complexity {
            background: rgba(0, 0, 0, 0.3);
            padding: 8px;
            border-radius: 4px;
            margin-top: 10px;
            font-size: 11px;
        }
        .complexity-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
        }
    </style>
</head>
<body>
    <div id="app">
        <div id="sidebar">
            <h1>üßÆ Algorithm Visualizer</h1>

            <div class="section">
                <h3>Sorting Algorithms</h3>
                <button class="algo-btn active" data-algo="bubble">Bubble Sort</button>
                <button class="algo-btn" data-algo="quick">Quick Sort</button>
                <button class="algo-btn" data-algo="merge">Merge Sort</button>
                <button class="algo-btn" data-algo="insertion">Insertion Sort</button>
                <button class="algo-btn" data-algo="selection">Selection Sort</button>
            </div>

            <div class="section">
                <h3>Searching Algorithms</h3>
                <button class="algo-btn" data-algo="linear">Linear Search</button>
                <button class="algo-btn" data-algo="binary">Binary Search</button>
            </div>

            <div class="section">
                <h3>Array Settings</h3>
                <label>Array Size <span class="value-display" id="sizeVal">50</span></label>
                <input type="range" id="arraySize" min="10" max="150" value="50">

                <label>Animation Speed <span class="value-display" id="speedVal">50ms</span></label>
                <input type="range" id="speed" min="1" max="200" value="50">

                <button onclick="generateNewArray()">üîÑ Generate New Array</button>
            </div>

            <div class="section">
                <h3>Current Algorithm</h3>
                <div id="algo-info">
                    <strong style="color: #4fc3f7;">Bubble Sort</strong>
                    <div class="description">
                        Repeatedly steps through the list, compares adjacent elements and swaps them if they're in the wrong order.
                    </div>
                    <div class="complexity">
                        <div class="complexity-item">
                            <span>Time (Best):</span>
                            <span class="stat-value">O(n)</span>
                        </div>
                        <div class="complexity-item">
                            <span>Time (Avg):</span>
                            <span class="stat-value">O(n¬≤)</span>
                        </div>
                        <div class="complexity-item">
                            <span>Space:</span>
                            <span class="stat-value">O(1)</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="main">
            <div id="header">
                <h2 id="title">Bubble Sort Visualization</h2>
                <div id="info">Click "Start" to begin the algorithm visualization. Bars will be color-coded: <span style="color: #4fc3f7;">blue (comparing)</span>, <span style="color: #ff6b6b;">red (swapping)</span>, <span style="color: #51cf66;">green (sorted)</span>.</div>
            </div>

            <div id="canvas-container">
                <canvas id="canvas" width="900" height="500"></canvas>
                <div id="stats">
                    <div class="stat-item">
                        <span class="stat-label">Comparisons:</span>
                        <span class="stat-value" id="comparisons">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Swaps:</span>
                        <span class="stat-value" id="swaps">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Array Access:</span>
                        <span class="stat-value" id="accesses">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Time:</span>
                        <span class="stat-value" id="time">0ms</span>
                    </div>
                </div>
            </div>

            <div id="controls">
                <button class="control-btn" id="startBtn" onclick="startVisualization()">‚ñ∂Ô∏è Start</button>
                <button class="control-btn" id="pauseBtn" onclick="pauseVisualization()" disabled>‚è∏Ô∏è Pause</button>
                <button class="control-btn" id="resetBtn" onclick="resetVisualization()">üîÑ Reset</button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let array = [];
        let currentAlgorithm = 'bubble';
        let animationSpeed = 50;
        let arraySize = 50;
        let isRunning = false;
        let isPaused = false;
        let stats = { comparisons: 0, swaps: 0, accesses: 0, startTime: 0 };
        let animationFrames = [];
        let currentFrame = 0;

        const algorithmInfo = {
            bubble: {
                name: 'Bubble Sort',
                description: 'Repeatedly steps through the list, compares adjacent elements and swaps them if they\'re in the wrong order.',
                complexity: { best: 'O(n)', average: 'O(n¬≤)', worst: 'O(n¬≤)', space: 'O(1)' }
            },
            quick: {
                name: 'Quick Sort',
                description: 'Divides the array using a pivot element and recursively sorts the sub-arrays.',
                complexity: { best: 'O(n log n)', average: 'O(n log n)', worst: 'O(n¬≤)', space: 'O(log n)' }
            },
            merge: {
                name: 'Merge Sort',
                description: 'Divides the array into halves, recursively sorts them, and merges the sorted halves.',
                complexity: { best: 'O(n log n)', average: 'O(n log n)', worst: 'O(n log n)', space: 'O(n)' }
            },
            insertion: {
                name: 'Insertion Sort',
                description: 'Builds the final sorted array one item at a time by inserting elements into their correct position.',
                complexity: { best: 'O(n)', average: 'O(n¬≤)', worst: 'O(n¬≤)', space: 'O(1)' }
            },
            selection: {
                name: 'Selection Sort',
                description: 'Finds the minimum element and places it at the beginning, then repeats for the remaining array.',
                complexity: { best: 'O(n¬≤)', average: 'O(n¬≤)', worst: 'O(n¬≤)', space: 'O(1)' }
            },
            linear: {
                name: 'Linear Search',
                description: 'Sequentially checks each element until the target is found or the end is reached.',
                complexity: { best: 'O(1)', average: 'O(n)', worst: 'O(n)', space: 'O(1)' }
            },
            binary: {
                name: 'Binary Search',
                description: 'Efficiently finds target in sorted array by repeatedly dividing search interval in half.',
                complexity: { best: 'O(1)', average: 'O(log n)', worst: 'O(log n)', space: 'O(1)' }
            }
        };

        function generateNewArray() {
            array = Array.from({ length: arraySize }, () => Math.floor(Math.random() * 400) + 10);
            resetVisualization();
            drawArray();
        }

        function drawArray(highlights = {}) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const barWidth = canvas.width / array.length;
            const maxHeight = Math.max(...array);

            array.forEach((value, index) => {
                const barHeight = (value / maxHeight) * (canvas.height - 40);
                const x = index * barWidth;
                const y = canvas.height - barHeight;

                // Color coding
                if (highlights.sorted && highlights.sorted.includes(index)) {
                    ctx.fillStyle = '#51cf66';
                } else if (highlights.comparing && highlights.comparing.includes(index)) {
                    ctx.fillStyle = '#4fc3f7';
                } else if (highlights.swapping && highlights.swapping.includes(index)) {
                    ctx.fillStyle = '#ff6b6b';
                } else if (highlights.pivot && highlights.pivot === index) {
                    ctx.fillStyle = '#ffd93d';
                } else {
                    ctx.fillStyle = '#aaa';
                }

                ctx.fillRect(x + 2, y, barWidth - 4, barHeight);
            });
        }

        function updateStats() {
            document.getElementById('comparisons').textContent = stats.comparisons;
            document.getElementById('swaps').textContent = stats.swaps;
            document.getElementById('accesses').textContent = stats.accesses;
            const elapsed = Date.now() - stats.startTime;
            document.getElementById('time').textContent = elapsed + 'ms';
        }

        function resetStats() {
            stats = { comparisons: 0, swaps: 0, accesses: 0, startTime: Date.now() };
            updateStats();
        }

        async function* bubbleSort(arr) {
            const n = arr.length;
            for (let i = 0; i < n - 1; i++) {
                for (let j = 0; j < n - i - 1; j++) {
                    stats.comparisons++;
                    stats.accesses += 2;
                    yield { comparing: [j, j + 1] };

                    if (arr[j] > arr[j + 1]) {
                        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
                        stats.swaps++;
                        yield { swapping: [j, j + 1] };
                    }
                }
                yield { sorted: Array.from({ length: i + 1 }, (_, k) => n - 1 - k) };
            }
            yield { sorted: Array.from({ length: n }, (_, i) => i) };
        }

        async function* insertionSort(arr) {
            const n = arr.length;
            yield { sorted: [0] };

            for (let i = 1; i < n; i++) {
                let key = arr[i];
                let j = i - 1;
                stats.accesses++;

                yield { comparing: [i] };

                while (j >= 0 && arr[j] > key) {
                    stats.comparisons++;
                    stats.accesses += 2;
                    arr[j + 1] = arr[j];
                    stats.swaps++;
                    yield { swapping: [j, j + 1] };
                    j--;
                }

                arr[j + 1] = key;
                yield { sorted: Array.from({ length: i + 1 }, (_, k) => k) };
            }
            yield { sorted: Array.from({ length: n }, (_, i) => i) };
        }

        async function* selectionSort(arr) {
            const n = arr.length;

            for (let i = 0; i < n - 1; i++) {
                let minIdx = i;

                for (let j = i + 1; j < n; j++) {
                    stats.comparisons++;
                    stats.accesses += 2;
                    yield { comparing: [minIdx, j] };

                    if (arr[j] < arr[minIdx]) {
                        minIdx = j;
                    }
                }

                if (minIdx !== i) {
                    [arr[i], arr[minIdx]] = [arr[minIdx], arr[i]];
                    stats.swaps++;
                    yield { swapping: [i, minIdx] };
                }

                yield { sorted: Array.from({ length: i + 1 }, (_, k) => k) };
            }
            yield { sorted: Array.from({ length: n }, (_, i) => i) };
        }

        async function* quickSort(arr, low = 0, high = arr.length - 1, sortedIndices = new Set()) {
            if (low < high) {
                let pivot = arr[high];
                let i = low - 1;
                stats.accesses++;

                for (let j = low; j < high; j++) {
                    stats.comparisons++;
                    stats.accesses++;
                    yield { comparing: [j], pivot: high };

                    if (arr[j] < pivot) {
                        i++;
                        [arr[i], arr[j]] = [arr[j], arr[i]];
                        stats.swaps++;
                        stats.accesses += 2;
                        yield { swapping: [i, j], pivot: high };
                    }
                }

                [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];
                stats.swaps++;
                stats.accesses += 2;
                yield { swapping: [i + 1, high] };

                const pivotIndex = i + 1;
                sortedIndices.add(pivotIndex);
                yield { sorted: Array.from(sortedIndices), pivot: pivotIndex };

                yield* quickSort(arr, low, pivotIndex - 1, sortedIndices);
                yield* quickSort(arr, pivotIndex + 1, high, sortedIndices);
            } else if (low === high) {
                sortedIndices.add(low);
                yield { sorted: Array.from(sortedIndices) };
            }

            if (low === 0 && high === arr.length - 1) {
                yield { sorted: Array.from({ length: arr.length }, (_, i) => i) };
            }
        }

        async function* mergeSort(arr, left = 0, right = arr.length - 1, sortedRanges = []) {
            if (left < right) {
                const mid = Math.floor((left + right) / 2);

                yield* mergeSort(arr, left, mid, sortedRanges);
                yield* mergeSort(arr, mid + 1, right, sortedRanges);

                // Merge
                let temp = [];
                let i = left, j = mid + 1;

                while (i <= mid && j <= right) {
                    stats.comparisons++;
                    stats.accesses += 2;
                    yield { comparing: [i, j] };

                    if (arr[i] <= arr[j]) {
                        temp.push(arr[i++]);
                    } else {
                        temp.push(arr[j++]);
                    }
                }

                while (i <= mid) {
                    stats.accesses++;
                    temp.push(arr[i++]);
                }
                while (j <= right) {
                    stats.accesses++;
                    temp.push(arr[j++]);
                }

                for (let i = 0; i < temp.length; i++) {
                    arr[left + i] = temp[i];
                    stats.swaps++;
                    yield { swapping: [left + i] };
                }
            }

            if (left === 0 && right === arr.length - 1) {
                yield { sorted: Array.from({ length: arr.length }, (_, i) => i) };
            }
        }

        async function* linearSearch(arr, target) {
            for (let i = 0; i < arr.length; i++) {
                stats.comparisons++;
                stats.accesses++;
                yield { comparing: [i] };

                if (arr[i] === target) {
                    yield { sorted: [i] };
                    return;
                }
            }
            yield {};
        }

        async function* binarySearch(arr, target) {
            // First sort the array
            const sorted = [...arr].sort((a, b) => a - b);
            for (let i = 0; i < arr.length; i++) {
                array[i] = sorted[i];
            }
            yield {};

            let left = 0, right = arr.length - 1;

            while (left <= right) {
                const mid = Math.floor((left + right) / 2);
                stats.comparisons++;
                stats.accesses++;
                yield { comparing: [mid] };

                if (arr[mid] === target) {
                    yield { sorted: [mid] };
                    return;
                } else if (arr[mid] < target) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
            yield {};
        }

        async function startVisualization() {
            if (isRunning) return;

            isRunning = true;
            isPaused = false;
            document.getElementById('startBtn').disabled = true;
            document.getElementById('pauseBtn').disabled = false;
            resetStats();

            let generator;
            const workArray = [...array];

            if (currentAlgorithm === 'bubble') {
                generator = bubbleSort(workArray);
            } else if (currentAlgorithm === 'insertion') {
                generator = insertionSort(workArray);
            } else if (currentAlgorithm === 'selection') {
                generator = selectionSort(workArray);
            } else if (currentAlgorithm === 'quick') {
                generator = quickSort(workArray);
            } else if (currentAlgorithm === 'merge') {
                generator = mergeSort(workArray);
            } else if (currentAlgorithm === 'linear') {
                const target = workArray[Math.floor(Math.random() * workArray.length)];
                generator = linearSearch(workArray, target);
            } else if (currentAlgorithm === 'binary') {
                const sortedArray = [...workArray].sort((a, b) => a - b);
                const target = sortedArray[Math.floor(Math.random() * sortedArray.length)];
                generator = binarySearch(workArray, target);
            }

            for await (const frame of generator) {
                if (!isRunning) break;
                while (isPaused) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                }

                array = [...workArray];
                drawArray(frame);
                updateStats();
                await new Promise(resolve => setTimeout(resolve, animationSpeed));
            }

            isRunning = false;
            document.getElementById('startBtn').disabled = false;
            document.getElementById('pauseBtn').disabled = true;
        }

        function pauseVisualization() {
            isPaused = !isPaused;
            document.getElementById('pauseBtn').textContent = isPaused ? '‚ñ∂Ô∏è Resume' : '‚è∏Ô∏è Pause';
        }

        function resetVisualization() {
            isRunning = false;
            isPaused = false;
            document.getElementById('startBtn').disabled = false;
            document.getElementById('pauseBtn').disabled = true;
            document.getElementById('pauseBtn').textContent = '‚è∏Ô∏è Pause';
            generateNewArray();
            resetStats();
        }

        document.querySelectorAll('.algo-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                if (isRunning) return;

                document.querySelectorAll('.algo-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentAlgorithm = btn.dataset.algo;

                const info = algorithmInfo[currentAlgorithm];
                document.getElementById('title').textContent = info.name + ' Visualization';
                document.getElementById('algo-info').innerHTML = `
                    <strong style="color: #4fc3f7;">${info.name}</strong>
                    <div class="description">${info.description}</div>
                    <div class="complexity">
                        <div class="complexity-item">
                            <span>Time (Best):</span>
                            <span class="stat-value">${info.complexity.best}</span>
                        </div>
                        <div class="complexity-item">
                            <span>Time (Avg):</span>
                            <span class="stat-value">${info.complexity.average}</span>
                        </div>
                        <div class="complexity-item">
                            <span>Space:</span>
                            <span class="stat-value">${info.complexity.space}</span>
                        </div>
                    </div>
                `;

                resetVisualization();
            });
        });

        document.getElementById('arraySize').addEventListener('input', (e) => {
            if (isRunning) return;
            arraySize = parseInt(e.target.value);
            document.getElementById('sizeVal').textContent = arraySize;
            generateNewArray();
        });

        document.getElementById('speed').addEventListener('input', (e) => {
            animationSpeed = parseInt(e.target.value);
            document.getElementById('speedVal').textContent = animationSpeed + 'ms';
        });

        generateNewArray();
    </script>
</body>
</html>