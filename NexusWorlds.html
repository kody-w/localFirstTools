<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Nexus Hub - World Explorer</title>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
            -webkit-overflow-scrolling: touch;
        }

        #three-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        /* Gamepad Indicator */
        #gamepad-indicator {
            position: fixed;
            top: 140px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border-radius: 20px;
            color: #06ffa5;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        #gamepad-indicator.active {
            opacity: 1;
        }

        /* Scene Recorder Button */
        .scene-recorder-button {
            position: fixed;
            bottom: calc(env(safe-area-inset-bottom, 30px) + 500px);
            right: calc(env(safe-area-inset-right, 30px));
            width: 60px;
            height: 60px;
            background: rgba(255, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 0, 0, 0.5);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 1002;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.3);
        }

        .scene-recorder-button:hover {
            background: rgba(255, 0, 0, 0.5);
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.5);
        }

        .scene-recorder-button.recording {
            animation: recordPulse 1s infinite;
        }

        @keyframes recordPulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(255, 0, 0, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0); }
        }

        .scene-recorder-button svg {
            width: 28px;
            height: 28px;
            color: white;
        }

        /* Scene Recorder Modal */
        .scene-recorder-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 3002;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(5px);
        }

        .scene-recorder-modal.show {
            display: flex;
        }

        .scene-recorder-content {
            background: rgba(20, 20, 40, 0.95);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            padding: 30px;
            max-width: 600px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 0 50px rgba(255, 0, 0, 0.3);
        }

.scene-recorder-content h3 {
            margin: 0 0 20px 0;
            font-size: 24px;
            background: linear-gradient(45deg, #ff0000, #ff6b6b);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            text-align: center;
        }

        .recording-status {
            background: rgba(255, 0, 0, 0.1);
            border: 1px solid rgba(255, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
            text-align: center;
        }

        .recording-status.active {
            animation: pulse 2s infinite;
        }

        .recording-timer {
            font-size: 24px;
            font-weight: bold;
            color: #ff6b6b;
            margin: 10px 0;
        }

        .recording-info {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.7);
        }

        .scene-controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .scene-control-btn {
            background: linear-gradient(45deg, #ff0000, #ff6b6b);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .scene-control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(255, 0, 0, 0.4);
        }

        .scene-control-btn.stop {
            background: linear-gradient(45deg, #666, #999);
        }

        .scene-control-btn.play {
            background: linear-gradient(45deg, #06ffa5, #00ff88);
            color: #000;
        }

        .scene-control-btn.export {
            background: linear-gradient(45deg, #3a86ff, #8338ec);
        }

        .scene-list {
            margin: 20px 0;
        }

        .scene-item {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s ease;
        }

        .scene-item:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateX(5px);
        }

        .scene-item-info {
            flex: 1;
        }

        .scene-item-name {
            font-weight: bold;
            color: #ff6b6b;
            margin-bottom: 5px;
        }

        .scene-item-details {
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.6);
        }

        .scene-item-actions {
            display: flex;
            gap: 10px;
        }

        .scene-action-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            padding: 8px 12px;
            border-radius: 10px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
        }

        .scene-action-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
        }

        .scene-action-btn.delete {
            background: rgba(255, 0, 0, 0.3);
        }

        .scene-action-btn.delete:hover {
            background: rgba(255, 0, 0, 0.5);
        }

        .scene-timeline {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
        }

        .timeline-progress {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            overflow: hidden;
            margin: 10px 0;
        }

        .timeline-bar {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ff6b6b);
            width: 0%;
            transition: width 0.1s linear;
        }

        .timeline-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 10px;
        }

        .timeline-time {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
        }

        .playback-speed {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .speed-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            padding: 5px 10px;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            font-size: 12px;
        }

        .speed-btn.active {
            background: rgba(255, 0, 0, 0.5);
        }

        .scene-import-input {
            display: none;
        }

        .replay-overlay {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 30px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 0, 0, 0.5);
            z-index: 2000;
            display: none;
        }

        .replay-overlay.active {
            display: block;
        }

        .replay-text {
            color: #ff6b6b;
            font-size: 18px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        /* Replay Controls */
        .replay-controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 15px 25px;
            border-radius: 25px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 0, 0, 0.5);
            z-index: 2001;
            display: none;
            gap: 15px;
            align-items: center;
        }

        .replay-controls.active {
            display: flex;
        }

        .replay-control-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            padding: 10px 20px;
            border-radius: 15px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
        }

        .replay-control-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
        }

        .replay-control-btn.active {
            background: rgba(255, 0, 0, 0.5);
        }

        .replay-status {
            color: #ff6b6b;
            font-size: 14px;
            margin: 0 15px;
        }

        /* Portal Manager */
        .portal-manager {
            position: fixed;
            bottom: calc(env(safe-area-inset-bottom, 30px) + 430px);
            right: calc(env(safe-area-inset-right, 30px));
            width: 60px;
            height: 60px;
            background: rgba(0, 255, 255, 0.3);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 1002;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }

        .portal-manager:hover {
            background: rgba(0, 255, 255, 0.5);
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
        }

        .portal-manager svg {
            width: 28px;
            height: 28px;
            color: white;
        }

        .portal-manager-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 3002;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(5px);
        }

        .portal-manager-modal.show {
            display: flex;
        }

        .portal-manager-content {
            background: rgba(20, 20, 40, 0.95);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.3);
        }

        .portal-manager-content h3 {
            margin: 0 0 20px 0;
            font-size: 24px;
            background: linear-gradient(45deg, #00ffff, #0088ff);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            text-align: center;
        }

        .portal-list {
            margin: 20px 0;
        }

        .portal-item {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .portal-item:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateX(5px);
            border-color: rgba(0, 255, 255, 0.5);
        }

        .portal-item-info {
            flex: 1;
        }

        .portal-item-name {
            font-weight: bold;
            color: #06ffa5;
            margin-bottom: 5px;
        }

        .portal-item-location {
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.6);
        }

        .portal-item-actions {
            display: flex;
            gap: 10px;
        }

        .portal-action-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            padding: 8px 12px;
            border-radius: 10px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
        }

        .portal-action-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
        }

        .portal-action-btn.enter {
            background: linear-gradient(45deg, #06ffa5, #00ff88);
            color: #000;
            font-weight: bold;
        }

        .portal-action-btn.enter:hover {
            box-shadow: 0 3px 15px rgba(6, 255, 165, 0.4);
        }

        .portal-action-btn.delete {
            background: rgba(255, 0, 0, 0.3);
        }

        .portal-action-btn.delete:hover {
            background: rgba(255, 0, 0, 0.5);
        }

        .portal-import-export {
            margin: 20px 0;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .import-export-btn {
            background: linear-gradient(45deg, #00ffff, #0088ff);
            color: #000;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .import-export-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(0, 255, 255, 0.4);
        }

        .import-file-input {
            display: none;
        }

        .portal-close-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            font-size: 30px;
            cursor: pointer;
            color: #fff;
            transition: all 0.3s;
        }

        .portal-close-btn:hover {
            color: #ff006e;
            transform: rotate(90deg);
        }

        /* AI Companion Modal */
        .ai-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 2002;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(5px);
        }

        .ai-modal.show {
            display: flex;
        }

        .ai-modal-content {
            background: rgba(20, 20, 40, 0.95);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            text-align: center;
            position: relative;
            box-shadow: 0 0 50px rgba(138, 56, 236, 0.3);
        }

        .ai-modal-close {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            font-size: 30px;
            cursor: pointer;
            color: #fff;
            transition: all 0.3s;
        }

        .ai-modal-close:hover {
            color: #ff006e;
            transform: rotate(90deg);
        }

        .ai-modal h3 {
            margin: 0 0 20px 0;
            font-size: 24px;
            background: linear-gradient(45deg, #ff006e, #8338ec, #3a86ff, #06ffa5);
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .ai-api-key-input {
            width: 100%;
            padding: 12px;
            margin: 10px 0;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            color: white;
            font-size: 14px;
            font-family: monospace;
        }

        .ai-api-key-input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .ai-activate-btn {
            background: linear-gradient(45deg, #8338ec, #3a86ff);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 10px;
        }

        .ai-activate-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(131, 56, 236, 0.4);
        }

        .ai-companion-list {
            margin: 20px 0;
            text-align: left;
        }

        .ai-companion-item {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .ai-companion-name {
            font-weight: bold;
            color: #06ffa5;
        }

        .ai-companion-status {
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.6);
        }

        /* AI Chat Interface - Modified for better visibility */
        .ai-chat-interface {
            position: fixed;
            bottom: calc(env(safe-area-inset-bottom, 20px) + 100px);
            right: calc(env(safe-area-inset-right, 20px));
            width: 350px;
            height: 450px;
            background: rgba(20, 20, 40, 0.85); /* More transparent */
            border: 2px solid rgba(138, 56, 236, 0.5);
            border-radius: 20px;
            display: none;
            flex-direction: column;
            z-index: 1003;
            box-shadow: 0 0 30px rgba(138, 56, 236, 0.3);
            backdrop-filter: blur(5px); /* Less blur for better transparency */
        }

        .ai-chat-interface.active {
            display: flex;
        }

        .ai-chat-header {
            padding: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .ai-chat-title {
            font-weight: bold;
            color: #06ffa5;
        }

        .ai-chat-messages {
            flex: 1;
            padding: 15px;
            overflow-y: auto;
            scroll-behavior: smooth;
        }

        .ai-message {
            margin: 10px 0;
            padding: 10px 15px;
            border-radius: 15px;
            max-width: 80%;
            word-wrap: break-word;
            overflow-wrap: break-word;
            word-break: break-word;
            font-size: 15px;
            line-height: 1.6;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            transition: all 0.2s ease;
            max-width: 100%;
            overflow-x: auto;
        }

        .ai-message.user {
            background: rgba(131, 56, 236, 0.3);
            margin-left: auto;
            text-align: right;
        }

        .ai-message.ai {
            background: rgba(6, 255, 165, 0.2);
            margin-right: auto;
        }

        .ai-message.task-replay {
            border: 1px solid rgba(255, 106, 0, 0.5);
            opacity: 0.8;
            font-style: italic;
        }

        /* Agent Logs Styling */
        .ai-message.system {
            background: rgba(255, 106, 0, 0.1);
            border: 1px solid rgba(255, 106, 0, 0.3);
            font-family: monospace;
            font-size: 13px;
            color: rgba(255, 255, 255, 0.8);
            white-space: pre-wrap;
            overflow-x: auto;
            max-width: 100%;
        }

        .agent-log-section {
            margin: 10px 0;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border-left: 3px solid #ff6a00;
        }

        .agent-log-header {
            color: #ffa500;
            font-weight: bold;
            margin-bottom: 5px;
            font-size: 14px;
        }

        .agent-log-content {
            color: rgba(255, 255, 255, 0.9);
            line-height: 1.5;
        }

        .agent-status {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: bold;
            margin-right: 5px;
        }

        .agent-status.thinking {
            background: rgba(58, 134, 255, 0.3);
            color: #4DD0E1;
        }

        .agent-status.searching {
            background: rgba(255, 152, 0, 0.3);
            color: #ffaa00;
        }

        .agent-status.processing {
            background: rgba(156, 39, 176, 0.3);
            color: #BA68C8;
        }

        .agent-status.complete {
            background: rgba(76, 175, 80, 0.3);
            color: #81C784;
        }

        .agent-step {
            margin: 5px 0;
            padding-left: 20px;
            position: relative;
        }

        .agent-step::before {
            content: '▸';
            position: absolute;
            left: 5px;
            color: #06ffa5;
        }

        .agent-error {
            color: #ff6b6b;
            background: rgba(255, 0, 0, 0.1);
            padding: 5px;
            border-radius: 5px;
            margin: 5px 0;
        }

        .agent-success {
            color: #51cf66;
            background: rgba(0, 255, 0, 0.1);
            padding: 5px;
            border-radius: 5px;
            margin: 5px 0;
        }

        /* 3D Agent Log Display */
        .agent-log-3d {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid rgba(255, 106, 0, 0.5);
            border-radius: 10px;
            padding: 10px;
            max-width: 300px;
            font-family: monospace;
            font-size: 12px;
            color: #ffa500;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .agent-log-3d.visible {
            opacity: 1;
        }

        .ai-typing {
            margin: 10px 0;
            padding: 10px 15px;
            border-radius: 15px;
            max-width: 80%;
            background: rgba(6, 255, 165, 0.2);
            margin-right: auto;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .typing-dot {
            width: 8px;
            height: 8px;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            animation: typingPulse 1.4s infinite ease-in-out;
        }

        .typing-dot:nth-child(1) {
            animation-delay: -0.32s;
        }

        .typing-dot:nth-child(2) {
            animation-delay: -0.16s;
        }

        @keyframes typingPulse {
            0%, 80%, 100% {
                transform: scale(0.8);
                opacity: 0.5;
            }
            40% {
                transform: scale(1);
                opacity: 1;
            }
        }

        .ai-chat-input-container {
            padding: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            gap: 10px;
        }

        .ai-chat-input {
            flex: 1;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            color: white;
            font-size: 14px;
        }

        .ai-chat-send {
            background: linear-gradient(45deg, #8338ec, #3a86ff);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .ai-chat-send:hover {
            transform: scale(1.05);
        }

        /* Save as Task Button */
        .save-task-btn {
            background: linear-gradient(45deg, #ff6a00, #ff8c00);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 15px;
            cursor: pointer;
            font-size: 12px;
            margin-left: 10px;
            transition: all 0.3s ease;
            display: none; /* Hidden since we're using conversation replay */
        }

        .save-task-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 3px 15px rgba(255, 106, 0, 0.4);
        }

        /* AI Companion Button */
        .ai-companion-button {
            position: fixed;
            bottom: calc(env(safe-area-inset-bottom, 30px) + 220px);
            right: calc(env(safe-area-inset-right, 30px));
            width: 60px;
            height: 60px;
            background: rgba(131, 56, 236, 0.3);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(131, 56, 236, 0.5);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 1002;
            box-shadow: 0 0 20px rgba(131, 56, 236, 0.3);
        }

        .ai-companion-button:hover {
            background: rgba(131, 56, 236, 0.5);
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(131, 56, 236, 0.5);
        }

        .ai-companion-button.active {
            background: rgba(6, 255, 165, 0.3);
            border-color: rgba(6, 255, 165, 0.5);
        }

        /* Task List Panel - Updated for conversation replay */
        .task-panel {
            position: fixed;
            bottom: calc(env(safe-area-inset-bottom, 100px));
            left: calc(env(safe-area-inset-left, 20px));
            background: rgba(20, 20, 40, 0.95);
            border: 2px solid rgba(255, 106, 0, 0.5);
            border-radius: 20px;
            padding: 20px;
            z-index: 1002;
            max-width: 350px;
            max-height: 400px;
            overflow-y: auto;
            box-shadow: 0 0 30px rgba(255, 106, 0, 0.3);
            display: none;
        }

        .task-panel.active {
            display: block;
        }

        .task-panel h3 {
            margin: 0 0 15px 0;
            font-size: 20px;
            background: linear-gradient(45deg, #ff6a00, #ff8c00, #ffa500);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .task-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 12px;
            margin: 8px 0;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid transparent;
        }

        .task-item:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 106, 0, 0.5);
            transform: translateX(5px);
        }

        .task-item strong {
            color: #ffa500;
            display: block;
            margin-bottom: 5px;
        }

        .task-item small {
            color: rgba(255, 255, 255, 0.6);
            display: block;
            margin-top: 5px;
        }

        .task-item .conversation-info {
            font-size: 0.85em;
            color: rgba(255, 255, 255, 0.7);
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .task-replay-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 106, 0, 0.8);
            padding: 5px 10px;
            border-radius: 10px;
            font-size: 12px;
            display: none;
        }

        .task-replay-indicator.active {
            display: block;
            animation: pulse 1s infinite;
        }

        /* Tasks Button */
        .tasks-button {
            position: fixed;
            bottom: calc(env(safe-area-inset-bottom, 30px) + 360px);
            right: calc(env(safe-area-inset-right, 30px));
            width: 60px;
            height: 60px;
            background: rgba(255, 106, 0, 0.3);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 106, 0, 0.5);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 1002;
            box-shadow: 0 0 20px rgba(255, 106, 0, 0.3);
        }

        .tasks-button:hover {
            background: rgba(255, 106, 0, 0.5);
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(255, 106, 0, 0.5);
        }

        .tasks-button svg {
            width: 28px;
            height: 28px;
            color: white;
        }

        /* Upload conversation button styles */
        .upload-conversation-btn {
            background: linear-gradient(45deg, #742774, #4a90e2);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 15px;
            cursor: pointer;
            font-size: 14px;
            margin: 10px 0;
            width: 100%;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .upload-conversation-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(116, 39, 116, 0.4);
        }

        .conversation-upload-input {
            display: none;
        }

        @keyframes shimmer {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        /* World Scanner Styles */
        .scanner-button {
            position: fixed;
            bottom: calc(env(safe-area-inset-bottom, 30px) + 290px);
            right: calc(env(safe-area-inset-right, 30px));
            width: 60px;
            height: 60px;
            background: rgba(255, 106, 0, 0.3);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 106, 0, 0.5);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 1002;
            box-shadow: 0 0 20px rgba(255, 106, 0, 0.3);
        }

        .scanner-button:hover {
            background: rgba(255, 106, 0, 0.5);
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(255, 106, 0, 0.5);
        }

        .scanner-button svg {
            width: 28px;
            height: 28px;
            color: white;
        }

        .world-scanner {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: black;
            z-index: 3000;
            display: none;
        }

        .world-scanner.active {
            display: block;
        }

        .scanner-container {
            width: 100%;
            height: 100%;
            position: relative;
        }

        #scanner-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .scanner-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            pointer-events: none;
        }

        .scanner-frame {
            width: 250px;
            height: 250px;
            border: 3px solid rgba(255, 255, 255, 0.5);
            border-radius: 20px;
            position: relative;
        }

        .scanner-frame::before {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            background: linear-gradient(45deg, #ff006e, #8338ec, #3a86ff, #06ffa5);
            border-radius: 20px;
            opacity: 0.5;
            animation: pulse 2s infinite;
        }

        .scanner-instruction {
            margin-top: 20px;
            color: white;
            font-size: 18px;
            text-align: center;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 20px;
        }

        .scanner-controls {
            position: absolute;
            bottom: 30px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: center;
            gap: 20px;
            pointer-events: auto;
        }

        .capture-btn, .cancel-scan-btn {
            background: linear-gradient(45deg, #ff006e, #8338ec);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 30px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .capture-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(255, 0, 110, 0.4);
        }

        .cancel-scan-btn {
            background: rgba(255, 255, 255, 0.2);
        }

        .world-creation-form {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 3001;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(10px);
        }

        .form-container {
            background: rgba(20, 20, 40, 0.95);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 0 50px rgba(138, 56, 236, 0.3);
        }

        .form-container h2 {
            margin: 0 0 20px 0;
            font-size: 24px;
            background: linear-gradient(45deg, #ff006e, #8338ec, #3a86ff, #06ffa5);
            -webkit-background-clip:text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            text-align: center;
        }

        .anchor-preview {
            width: 100%;
            max-width: 300px;
            height: 200px;
            object-fit: cover;
            border-radius: 10px;
            margin: 0 auto 20px;
            display: block;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .form-container input,
        .form-container textarea,
        .form-container select {
            width: 100%;
            padding: 12px;
            margin: 10px 0;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            color: white;
            font-size: 16px;
        }

        .form-container input::placeholder,
        .form-container textarea::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .create-world-btn {
            width: 100%;
            background: linear-gradient(45deg, #06ffa5, #00ff88);
            color: #000;
            border: none;
            padding: 15px;
            border-radius: 25px;
            font-weight: bold;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 20px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .create-world-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(6, 255, 165, 0.4);
        }

        .form-close-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            font-size: 30px;
            cursor: pointer;
            color: #fff;
            transition: all 0.3s;
        }

        .form-close-btn:hover {
            color: #ff006e;
            transform: rotate(90deg);
        }

        .download-json-btn {
            background: linear-gradient(45deg, #3a86ff, #8338ec);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 10px;
            width: 100%;
        }

        .download-json-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(58, 134, 255, 0.4);
        }

        /* QR Code Share Button */
        .share-button {
            position: fixed;
            bottom: calc(env(safe-area-inset-bottom, 30px) + 80px);
            right: calc(env(safe-area-inset-right, 30px));
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 1000;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.1);
        }

        .share-button:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(255, 255, 255, 0.3);
        }

        .share-button.multiplayer {
            background: rgba(0, 255, 0, 0.2);
            border-color: rgba(0, 255, 0, 0.5);
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
        }

        .share-icon {
            width: 24px;
            height: 24px;
            color: white;
        }

        /* QR Code Modal */
        .qr-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 2001;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(5px);
        }

        .qr-modal.show {
            display: flex;
        }

        .qr-modal-content {
            background: rgba(20, 20, 40, 0.95);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            padding: 30px;
            max-width: 400px;
            width: 90%;
            text-align: center;
            position: relative;
            box-shadow: 0 0 50px rgba(138, 56, 236, 0.3);
        }

        .qr-close {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            font-size: 30px;
            cursor: pointer;
            color: #fff;
            transition: all 0.3s;
        }

        .qr-close:hover {
            color: #ff006e;
            transform: rotate(90deg);
        }

        .qr-modal h3 {
            margin: 0 0 20px 0;
            font-size: 24px;
            background: linear-gradient(45deg, #ff006e, #8338ec, #3a86ff, #06ffa5);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .multiplayer-info {
            background: rgba(0, 255, 0, 0.1);
            border: 1px solid rgba(0, 255, 0, 0.3);
            border-radius: 10px;
            padding: 10px;
            margin: 15px 0;
            font-size: 0.9em;
            color: #06ffa5;
        }

        #qr-code-container {
            margin: 20px auto;
            display: flex;
            justify-content: center;
            padding: 20px;
            background: white;
            border-radius: 15px;
        }

        #qr-code-container canvas,
        #qr-code-container img {
            border-radius: 10px;
        }

        .qr-url {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            word-break: break-all;
            margin: 20px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            font-family: monospace;
        }

        .copy-url-btn {
            background: linear-gradient(45deg, #ff006e, #8338ec);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .copy-url-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(255, 0, 110, 0.4);
        }

        .copy-url-btn.copied {
            background: linear-gradient(45deg, #06ffa5, #00ff88);
        }

        @keyframes shimmer {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .world-ui {
            position: absolute;
            top: env(safe-area-inset-top, 20px);
            left: env(safe-area-inset-left, 20px);
            z-index: 1001;
            pointer-events: none;
        }

        .world-title {
            font-size: 3em;
            font-weight: 100;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            background: linear-gradient(45deg, #ff006e, #8338ec, #3a86ff, #06ffa5);
            background-size: 400% 100%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: shimmer 8s ease-in-out infinite;
            margin-bottom: 10px;
        }

        .world-description {
            font-size: 1.2em;
            color: rgba(255, 255, 255, 0.6);
            max-width: 400px;
        }

        .world-origin {
            position: absolute;
            top: env(safe-area-inset-top, 20px);
            right: env(safe-area-inset-right, 20px);
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.8);
            z-index: 1001;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            display: none;
        }

        .world-origin.visible {
            display: block;
        }

        .origin-label {
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.8em;
        }

        .origin-world {
            color: #06ffa5;
            font-weight: 500;
        }

        /* Multiplayer Status */
        .multiplayer-status {
            position: fixed;
            top: env(safe-area-inset-top, 80px);
            right: env(safe-area-inset-right, 20px);
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border-radius: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            z-index: 1000;
        }

        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #888;
            transition: all 0.3s ease;
        }

        .status-indicator.connected {
            background: #00ff00;
            box-shadow: 0 0 10px #00ff00;
        }

        .status-indicator.hosting {
            background: #06ffa5;
            box-shadow: 0 0 10px #06ffa5;
        }

        .status-text {
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.9em;
        }

        .player-count {
            color: #06ffa5;
            font-weight: bold;
        }

        /* Multiplayer Notifications */
        .multiplayer-notification {
            position: fixed;
            top: 100px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            border: 2px solid rgba(0, 255, 255, 0.5);
            animation: slideIn 0.3s ease;
            z-index: 1005;
            backdrop-filter: blur(10px);
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }

        .controls-hint {
            position: absolute;
            bottom: env(safe-area-inset-bottom, 30px);
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.8);
            z-index: 1001;
            text-align: center;
            backdrop-filter: blur(10px);
            pointer-events: none;
        }

        .portal-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            padding: 20px;
            max-width: 300px;
            display: none;
            z-index: 1002;
            pointer-events: none;
            backdrop-filter: blur(10px);
        }

        .portal-tooltip.visible {
            display: block;
        }

        .tooltip-title {
            font-size: 1.4em;
            font-weight: 300;
            margin-bottom: 10px;
            color: #06ffa5;
        }

        .tooltip-description {
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.7);
            line-height: 1.5;
        }

        .tooltip-instruction {
            font-size: 0.85em;
            color: #ff006e;
            text-align: center;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* Mobile controls */
        .mobile-controls {
            position: fixed;
            bottom: calc(env(safe-area-inset-bottom, 0px) + 20px);
            left: 0;
            right: 0;
            display: none;
            z-index: 1001;
            padding: 0 20px;
            pointer-events: none;
        }

        .mobile-controls.show {
            display: block;
        }

        .controls-container {
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            width: 100%;
            max-width: 600px;
            margin: 0 auto;
        }

        .joystick-container {
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            position: relative;
            pointer-events: auto;
            touch-action: none;
        }

        .joystick-handle {
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        .look-area {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 200px;
            z-index: 999;
            touch-action: none;
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            font-size: 1.2em;
            color: rgba(255, 255, 255, 0.4);
            font-weight: 200;
            letter-spacing: 0.1em;
            z-index: 2000;
        }

        .loading::after {
            content: '';
            display: block;
            width: 60px;
            height: 1px;
            background: linear-gradient(90deg, transparent, #fff, transparent);
            margin: 30px auto;
            animation: scan 2s linear infinite;
        }

        @keyframes scan {
            0% { transform: translateX(-100px); }
            100% { transform: translateX(100px); }
        }

        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.8; }
            100% { transform: scale(1); opacity: 1; }
        }

        @media (max-width: 768px) {
            .world-title {
                font-size: 2em;}

            .world-description {
                font-size: 1em;
                max-width: 300px;
            }

            .ai-chat-interface {
                width: calc(100% - 40px);
                right: 20px;
                left: 20px;
            }
        }

        /* iOS specific fixes */
        @supports (-webkit-touch-callout: none) {
            body {
                position: fixed;
                height: 100vh;
                height: -webkit-fill-available;
            }

            #three-container {
                height: 100vh;
                height: -webkit-fill-available;
            }
        }</style>
</head>
<body>
    <div id="three-container"></div>

    <!-- Gamepad Indicator -->
    <div id="gamepad-indicator">
        🎮 Gamepad Mode
        <span style="font-size: 12px; color: rgba(255, 255, 255, 0.6); margin-left: 10px;">
            LS: Move | RS: Look | A: Enter Portal
        </span>
    </div>

    <!-- Scene Recorder Button -->
    <div class="scene-recorder-button" id="scene-recorder-button">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="12" cy="12" r="11"/>
            <circle cx="12" cy="12" r="5" fill="currentColor"/>
        </svg>
    </div>

    <!-- Scene Recorder Modal -->
    <div class="scene-recorder-modal" id="scene-recorder-modal">
        <div class="scene-recorder-content">
            <button class="portal-close-btn" id="scene-recorder-close">&times;</button>
            <h3>Scene Recorder & Player</h3>
            
            <div class="recording-status" id="recording-status">
                <div class="recording-timer" id="recording-timer">00:00</div>
                <div class="recording-info" id="recording-info">Ready to record</div>
            </div>

            <div class="scene-controls">
                <button class="scene-control-btn" id="start-recording-btn">
                    ▶️ Start Recording
                </button>
                <button class="scene-control-btn stop" id="stop-recording-btn" style="display:none;">
                    ⏹️ Stop Recording
                </button>
                <button class="scene-control-btn export" id="export-scene-btn">
                    📤 Export Scene
                </button>
                <button class="scene-control-btn" onclick="document.getElementById('scene-import-input').click()">
                    📥 Import Scene
                </button>
                <input type="file" id="scene-import-input" class="scene-import-input" accept=".json" onchange="window.worldNavigator.sceneRecorder.importScene(event)">
            </div>

            <div class="scene-timeline" id="scene-timeline" style="display:none;">
                <div class="timeline-progress">
                    <div class="timeline-bar" id="timeline-bar"></div>
                </div>
                <div class="timeline-controls">
                    <div class="timeline-time">
                        <span id="current-time">00:00</span> / <span id="total-time">00:00</span>
                    </div>
                    <div class="playback-speed">
                        <button class="speed-btn" data-speed="0.5">0.5x</button>
                        <button class="speed-btn active" data-speed="1">1x</button>
                        <button class="speed-btn" data-speed="2">2x</button>
                    </div>
                </div>
            </div>

            <div class="scene-list" id="scene-list">
                <h4 style="color: #ff6b6b; margin-bottom: 10px;">Recorded Scenes:</h4>
                <!-- Scene items will be populated here -->
            </div>
        </div>
    </div>

    <!-- Replay Overlay -->
    <div class="replay-overlay" id="replay-overlay">
        <div class="replay-text">▶️ REPLAYING SCENE</div>
    </div>

    <!-- Replay Controls -->
    <div class="replay-controls" id="replay-controls">
        <button class="replay-control-btn" id="replay-play-pause">⏸️ Pause</button>
        <span class="replay-status" id="replay-status">Step 1 of 1</span>
        <button class="replay-control-btn" id="replay-next-step">Next ⏭️</button>
        <button class="replay-control-btn" id="replay-stop">⏹️ Stop</button>
    </div>

    <!-- Portal Manager Button -->
    <div class="portal-manager" id="portal-manager-btn">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="12" cy="12" r="10"/>
            <path d="M12 2v20M2 12h20"/>
            <circle cx="12" cy="12" r="3"/>
        </svg>
    </div>

    <!-- Portal Manager Modal -->
    <div class="portal-manager-modal" id="portal-manager-modal">
        <div class="portal-manager-content">
            <button class="portal-close-btn" id="portal-close">&times;</button>
            <h3>Portal Manager</h3>
            <p style="color: rgba(255, 255, 255, 0.7); margin-bottom: 20px; text-align: center;">
                Import, export, and fast travel through your portal network.
            </p>
            
            <div class="portal-list" id="portal-list">
                <h4 style="color: #06ffa5; margin-bottom: 10px;">Active Portals:</h4>
                <!-- Portal items will be populated here -->
            </div>
            
            <div class="portal-import-export">
                <button class="import-export-btn" onclick="window.worldNavigator.portalManager.exportPortals()">
                    📤 Export Portals
                </button>
                <button class="import-export-btn" onclick="document.getElementById('import-file').click()">
                    📥 Import Portals
                </button>
                <input type="file" id="import-file" class="import-file-input" accept=".json" onchange="window.worldNavigator.portalManager.importPortals(event)">
            </div>
        </div>
    </div>

    <!-- AI Companion Modal -->
    <div class="ai-modal" id="ai-modal">
        <div class="ai-modal-content">
            <button class="ai-modal-close" id="ai-close">&times;</button>
            <h3>AI Companion Settings</h3>
            <p style="color: rgba(255, 255, 255, 0.7); margin-bottom: 20px;">
                Activate AI companions to join your world. They can interact with you and other players in real-time.
            </p>
            <input type="password" class="ai-api-key-input" id="ai-api-key" placeholder="Enter your API key to wake up AI companions">
            <button class="ai-activate-btn" id="ai-activate-btn">Activate AI Companions</button>

            <div class="ai-companion-list" id="ai-companion-list">
                <h4 style="color: #06ffa5; margin-top: 20px;">Active Companions:</h4>
                <div class="ai-companion-item">
                    <div>
                        <div class="ai-companion-name">No AI companions active</div>
                        <div class="ai-companion-status">Enter API key to activate</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- AI Chat Interface -->
    <div class="ai-chat-interface" id="ai-chat-interface">
        <div class="ai-chat-header">
            <div class="ai-chat-title">AI Companion Chat</div>
            <button class="ai-modal-close" onclick="document.getElementById('ai-chat-interface').classList.remove('active')">&times;</button>
        </div>
        <div class="task-replay-indicator" id="task-replay-indicator">🔄 Replaying Conversation...</div>
        <div class="ai-chat-messages" id="ai-chat-messages"></div>
        <div class="ai-chat-input-container">
            <input type="text" class="ai-chat-input" id="ai-chat-input" placeholder="Type a message..." onkeypress="if(event.key==='Enter') window.worldNavigator.aiManager.sendMessage()">
            <button class="ai-chat-send" onclick="window.worldNavigator.aiManager.sendMessage()">Send</button>
        </div>
    </div>

    <!-- Task Panel -->
    <div class="task-panel" id="task-panel">
        <h3>📚 Saved Conversations</h3>
        <button class="upload-conversation-btn" onclick="document.getElementById('conversation-upload-input').click()">
            <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"></path>
                <polyline points="17 8 12 3 7 8"></polyline>
                <line x1="12" y1="3" x2="12" y2="15"></line>
            </svg>
            Upload Conversation JSON
        </button>
        <input type="file" id="conversation-upload-input" class="conversation-upload-input" accept=".json" onchange="window.worldNavigator.taskManager.uploadConversation(event)">
        <div id="task-list">
            <!-- Tasks populated here -->
        </div>
    </div>

    <div class="look-area" id="look-area"></div>

    <div class="world-ui">
        <h1 class="world-title" id="world-title">NEXUS HUB</h1>
        <p class="world-description" id="world-description">The central hub connecting all worlds. Step through the portals to explore different dimensions.</p>
    </div>

    <div class="world-origin" id="world-origin">
        <span class="origin-label">Arrived from:</span>
        <span class="origin-world" id="origin-world-name">Origin</span>
    </div>

    <!-- Multiplayer Status -->
    <div class="multiplayer-status" id="multiplayer-status">
        <div class="status-indicator" id="status-indicator"></div>
        <span class="status-text" id="status-text">Connecting...</span>
        <div class="player-count">
            <span id="player-count">1</span> players
        </div>
    </div>

    <!-- AI Companion Button -->
    <div class="ai-companion-button" id="ai-companion-button">
        <svg class="view-toggle-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"></path>
        </svg>
    </div>

    <!-- Tasks Button -->
    <div class="tasks-button" id="tasks-button">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M9 11l3 3L22 4"></path>
            <path d="M21 12v7a2 2 0 01-2 2H5a2 2 0 01-2-2V5a2 2 0 012-2h11"></path>
        </svg>
    </div>

    <!-- World Scanner Button -->
    <div class="scanner-button" id="scanner-button">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <rect x="3" y="3" width="18" height="18" rx="2"/>
            <circle cx="12" cy="12" r="3"/>
            <circle cx="12" cy="12" r="1"/>
        </svg>
    </div>

    <!-- World Scanner UI -->
    <div class="world-scanner" id="world-scanner">
        <div class="scanner-container">
            <video id="scanner-video" autoplay playsinline></video>
            <div class="scanner-overlay">
                <div class="scanner-frame"></div>
                <p class="scanner-instruction">Point at object to create portal anchor</p>
            </div>
            <div class="scanner-controls">
                <button class="capture-btn" id="capture-btn">📸 Capture Anchor</button>
                <button class="cancel-scan-btn" id="cancel-scan-btn">Cancel</button>
            </div>
        </div>
    </div>

    <div class="controls-hint" id="controls-hint">Use WASD to move, Mouse to look around, Click on portals to travel</div>

    <div class="mobile-controls" id="mobile-controls">
        <div class="controls-container">
            <div class="joystick-container" id="movement-joystick">
                <div class="joystick-handle" id="movement-handle"></div>
            </div>
        </div>
    </div>

    <div class="portal-tooltip" id="portal-tooltip">
        <h3 class="tooltip-title"></h3>
        <p class="tooltip-description"></p>
        <p class="tooltip-instruction">Tap to enter world</p>
    </div>

    <div class="loading" id="loading">Initializing nexus...</div>

    <!-- QR Code Share Button -->
    <div class="share-button" id="share-button">
        <svg class="share-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M4 12v8a2 2 0 002 2h12a2 2 0 002-2v-8"></path>
            <polyline points="16 6 12 2 8 6"></polyline>
            <line x1="12" y1="2" x2="12" y2="15"></line>
        </svg>
    </div>

    <!-- QR Code Modal -->
    <div class="qr-modal" id="qr-modal">
        <div class="qr-modal-content">
            <button class="qr-close" id="qr-close">&times;</button>
            <h3>Share This World</h3>
            <div class="multiplayer-info" id="multiplayer-info" style="display:none;">
                🌐 Multiplayer Session Active - Others who scan this code will join your world!
            </div>
            <div id="qr-code-container"></div>
            <p class="qr-url" id="qr-url"></p>
            <button class="copy-url-btn" id="copy-url-btn">Copy URL</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script>
        // Add FontLoader to THREE namespace
        THREE.FontLoader = class FontLoader extends THREE.Loader {
            constructor(manager) {
                super(manager);
            }

            load(url, onLoad, onProgress, onError) {
                const scope = this;
                const loader = new THREE.FileLoader(this.manager);
                loader.setPath(this.path);
                loader.setRequestHeader(this.requestHeader);
                loader.setWithCredentials(this.withCredentials);
                loader.load(url, function(text) {
                    try {
                        const json = JSON.parse(text);
                        const font = scope.parse(json);
                        if (onLoad) onLoad(font);
                    } catch (e) {
                        console.warn('THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.');
                        if (onError) onError(e);
                    }
                }, onProgress, onError);
            }

            parse(json) {
                return new THREE.Font(json);
            }
        };

        // Add Font class
        THREE.Font = class Font {
            constructor(data) {
                this.type = 'Font';
                this.data = data;
            }

            generateShapes(text, size = 100) {
                const shapes = [];
                const paths = createPaths(text, size, this.data);

                for (let p = 0, pl = paths.length; p < pl; p++) {
                    Array.prototype.push.apply(shapes, paths[p].toShapes());
                }

                return shapes;
            }
        };

        // Add TextGeometry
        THREE.TextGeometry = class TextGeometry extends THREE.ExtrudeGeometry {
            constructor(text, parameters = {}) {
                const font = parameters.font;

                if (!font || !font.data) {
                    console.error('THREE.TextGeometry: font parameter is not an instance of THREE.Font.');
                    super();
                    return;
                }

                const shapes = font.generateShapes(text, parameters.size);

                parameters.depth = parameters.height !== undefined ? parameters.height : 50;

                if (parameters.bevelThickness === undefined) parameters.bevelThickness = 10;
                if (parameters.bevelSize === undefined) parameters.bevelSize = 8;
                if (parameters.bevelEnabled === undefined) parameters.bevelEnabled = false;

                super(shapes, parameters);

                this.type = 'TextGeometry';
            }
        };

        // Helper function for font paths
        function createPaths(text, size, data) {
            const chars = Array.from(text);
            const scale = size / data.resolution;
            const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;

            const paths = [];

            let offsetX = 0, offsetY = 0;

            for (let i = 0; i < chars.length; i++) {
                const char = chars[i];

                if (char === '\n') {
                    offsetX = 0;
                    offsetY -= line_height;
                } else {
                    const ret = createPath(char, scale, offsetX, offsetY, data);
                    if (ret) {
                        offsetX += ret.offsetX;
                        paths.push(ret.path);
                    }
                }
            }

            return paths;
        }

        function createPath(char, scale, offsetX, offsetY, data) {
            const glyph = data.glyphs[char] || data.glyphs['?'];

            if (!glyph) {
                console.error('THREE.Font: character "' + char + '" does not exists in font family ' + data.familyName + '.');
                return;
            }

            const path = new THREE.ShapePath();

            let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;

            if (glyph.o) {
                const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '));

                for (let i = 0, l = outline.length; i < l;) {
                    const action = outline[i++];

                    switch (action) {
                        case 'm': // moveTo
                            x = outline[i++] * scale + offsetX;
                            y = outline[i++] * scale + offsetY;
                            path.moveTo(x, y);
                            break;

                        case 'l': // lineTo
                            x = outline[i++] * scale + offsetX;
                            y = outline[i++] * scale + offsetY;
                            path.lineTo(x, y);
                            break;

                        case 'q': // quadraticCurveTo
                            cpx = outline[i++] * scale + offsetX;
                            cpy = outline[i++] * scale + offsetY;
                            cpx1 = outline[i++] * scale + offsetX;
                            cpy1 = outline[i++] * scale + offsetY;
                            path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
                            break;

                        case 'b': // bezierCurveTo
                            cpx = outline[i++] * scale + offsetX;
                            cpy = outline[i++] * scale + offsetY;
                            cpx1 = outline[i++] * scale + offsetX;
                            cpy1 = outline[i++] * scale + offsetY;
                            cpx2 = outline[i++] * scale + offsetX;
                            cpy2 = outline[i++] * scale + offsetY;
                            path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
                            break;
                    }
                }
            }

            return { offsetX: glyph.ha * scale, path: path };
        }

        // Configuration - Update these with your GitHub details
        const REPO_OWNER = 'kody-w'; // Replace with your GitHub username
        const REPO_NAME = 'AINexus'; // Replace with your repository name
        const BRANCH = 'main';
        
        // GitHub Pages URL base
        const GITHUB_PAGES_BASE = `https://${REPO_OWNER}.github.io/${REPO_NAME}/`;

        // Default world attributes
        const DEFAULT_WORLD_ATTRIBUTES = {
            name: "Nexus Hub",
            description: "The central hub connecting all worlds. Step through the portals to explore different dimensions.",
            ambientColor: 0x0a0a0a,
            fogColor: 0x000033,
            groundColor: 0x1a1a2e,
            skyColor: 0x16213e,
            moveSpeed: 0.15,
            lookSpeed: 0.002,
            portalColor1: 0x00ffff,
            portalColor2: 0xff00ff,
            particleCount: 1000,
            cameraHeight: 2,
            fogNear: 10,
            fogFar: 100
        };

        // Parse inherited attributes from URL
        function parseInheritedAttributes() {
            let paramString = window.INJECTED_PARAMS || window.location.search;

            if (window.location.protocol === 'blob:') {
                const storedParams = sessionStorage.getItem('worldInheritanceParams');
                if (storedParams) {
                    paramString = storedParams;
                }
            }

            if (!paramString || paramString === '?') {
                const transitionData = localStorage.getItem('worldTransition');
                if (transitionData) {
                    try {
                        const data = JSON.parse(transitionData);
                        if (Date.now() - data.timestamp < 5000) {
                            paramString = '?' + data.params;
                        }
                    } catch (e) {
                        console.error('Error parsing transition data:', e);
                    }
                    localStorage.removeItem('worldTransition');
                }
            }

            const params = new URLSearchParams(paramString);
            const inherited = {};

            inherited.sourceWorld = params.get('from') || null;
            inherited.sourceWorldName = params.get('fromName') || null;

            // Visual attributes only (no moveSpeed)
            if (params.has('lookSpeed')) inherited.lookSpeed = parseFloat(params.get('lookSpeed'));
            if (params.has('ambientColor')) inherited.ambientColor = parseInt(params.get('ambientColor'), 16);
            if (params.has('fogColor')) inherited.fogColor = parseInt(params.get('fogColor'), 16);
            if (params.has('portalColor1')) inherited.portalColor1 = parseInt(params.get('portalColor1'), 16);
            if (params.has('portalColor2')) inherited.portalColor2 = parseInt(params.get('portalColor2'), 16);
            if (params.has('particleCount')) inherited.particleCount = parseInt(params.get('particleCount'));
            if (params.has('cameraHeight')) inherited.cameraHeight = parseFloat(params.get('cameraHeight'));
            if (params.has('fogNear')) inherited.fogNear = parseFloat(params.get('fogNear'));
            if (params.has('fogFar')) inherited.fogFar = parseFloat(params.get('fogFar'));

            console.log('Parsed inherited attributes:', inherited);
            return inherited;
        }

        const inheritedAttributes = parseInheritedAttributes();
        const CURRENT_WORLD = { ...DEFAULT_WORLD_ATTRIBUTES, ...inheritedAttributes };

        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                        (window.matchMedia && window.matchMedia('(max-width: 768px)').matches) ||
                        (window.matchMedia && window.matchMedia('(pointer: coarse)').matches);

        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;

        // Enhanced Scene Recorder Class
        class SceneRecorder {
            constructor(worldInstance) {
                this.world = worldInstance;
                this.isRecording = false;
                this.isPlaying = false;
                this.isPaused = false;
                this.stepByStep = false;
                this.recordedActions = [];
                this.recordStartTime = 0;
                this.playbackStartTime = 0;
                this.playbackIndex = 0;
                this.playbackSpeed = 1;
                this.recordingTimer = null;
                this.playbackTimer = null;
                this.savedScenes = new Map();
                this.currentScene = null;

                this.setupEventListeners();
                this.loadSavedScenes();
            }

            setupEventListeners() {
                // Scene recorder button
                document.getElementById('scene-recorder-button').addEventListener('click', () => {
                    this.showModal();
                });

                // Close button
                document.getElementById('scene-recorder-close').addEventListener('click', () => {
                    this.hideModal();
                });

                // Control buttons
                document.getElementById('start-recording-btn').addEventListener('click', () => {
                    this.startRecording();
                });

                document.getElementById('stop-recording-btn').addEventListener('click', () => {
                    this.stopRecording();
                });

                document.getElementById('export-scene-btn').addEventListener('click', () => {
                    this.exportScene();
                });

                // Speed buttons
                document.querySelectorAll('.speed-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        this.setPlaybackSpeed(parseFloat(e.target.dataset.speed));
                        document.querySelectorAll('.speed-btn').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                    });
                });

                // Replay controls
                document.getElementById('replay-play-pause').addEventListener('click', () => {
                    this.togglePlayPause();
                });

                document.getElementById('replay-next-step').addEventListener('click', () => {
                    this.nextStep();
                });

                document.getElementById('replay-stop').addEventListener('click', () => {
                    this.stopPlayback();
                });

                // Close on outside click
                document.getElementById('scene-recorder-modal').addEventListener('click', (e) => {
                    if (e.target.id === 'scene-recorder-modal') {
                        this.hideModal();
                    }
                });
            }

            showModal() {
                document.getElementById('scene-recorder-modal').classList.add('show');
                this.updateSceneList();
            }

            hideModal() {
                document.getElementById('scene-recorder-modal').classList.remove('show');
            }

            startRecording() {
                if (this.isRecording) return;

                this.isRecording = true;
                this.recordedActions = [];
                this.recordStartTime = Date.now();

                // Update UI
                document.getElementById('scene-recorder-button').classList.add('recording');
                document.getElementById('start-recording-btn').style.display = 'none';
                document.getElementById('stop-recording-btn').style.display = 'inline-block';
                document.getElementById('recording-status').classList.add('active');
                document.getElementById('recording-info').textContent = 'Recording in progress...';

                // Start recording timer
                this.updateRecordingTimer();

                // Record initial state
                this.recordAction({
                    type: 'init',
                    data: {
                        cameraPosition: this.world.camera.position.clone(),
                        cameraRotation: {
                            x: this.world.rotation.x,
                            y: this.world.rotation.y
                        },
                        worldAttributes: CURRENT_WORLD
                    }
                });

                this.world.showNotification('Recording started!');
            }

            stopRecording() {
                if (!this.isRecording) return;

                this.isRecording = false;
                clearInterval(this.recordingTimer);

                // Update UI
                document.getElementById('scene-recorder-button').classList.remove('recording');
                document.getElementById('start-recording-btn').style.display = 'inline-block';
                document.getElementById('stop-recording-btn').style.display = 'none';
                document.getElementById('recording-status').classList.remove('active');
                document.getElementById('recording-info').textContent = 'Recording complete';

                // Save the recording
                const sceneId = `scene_${Date.now()}`;
                const sceneData = {
                    id: sceneId,
                    name: `Scene ${new Date().toLocaleString()}`,
                    duration: Date.now() - this.recordStartTime,
                    actions: this.recordedActions,
                    timestamp: new Date().toISOString()
                };

                this.savedScenes.set(sceneId, sceneData);
                this.saveToLocalStorage();
                this.updateSceneList();

                this.world.showNotification('Recording saved!');
            }

            recordAction(action) {
                if (!this.isRecording) return;

                action.timestamp = Date.now() - this.recordStartTime;
                this.recordedActions.push(action);
            }

            // Called from world's update loop
            recordFrame() {
                if (!this.isRecording) return;

                // Record camera movement
                this.recordAction({
                    type: 'camera',
                    data: {
                        position: this.world.camera.position.clone(),
                        rotation: {
                            x: this.world.rotation.x,
                            y: this.world.rotation.y
                        }
                    }
                });

                // Record player movement if multiplayer is active
                if (this.world.multiplayer && this.world.multiplayer.connections.size > 0) {
                    const players = [];
                    this.world.multiplayer.players.forEach((player, peerId) => {
                        players.push({
                            id: peerId,
                            position: player.avatar.position.clone(),
                            username: player.username
                        });
                    });

                    if (players.length > 0) {
                        this.recordAction({
                            type: 'players',
                            data: players
                        });
                    }
                }

                // Record AI companion state
                if (this.world.aiManager && this.world.aiManager.isActive) {
                    const companion = this.world.aiManager.companions.get('ai-assistant');
                    if (companion) {
                        this.recordAction({
                            type: 'ai_companion',
                            data: {
                                position: companion.object.position.clone(),
                                active: true
                            }
                        });
                    }
                }
            }

            recordPortalInteraction(portalName, url) {
                this.recordAction({
                    type: 'portal_interaction',
                    data: {
                        portalName: portalName,
                        url: url,
                        timestamp: Date.now() - this.recordStartTime
                    }
                });
            }

            recordChatMessage(message, sender) {
                this.recordAction({
                    type: 'chat',
                    data: {
                        message: message,
                        sender: sender,
                        timestamp: Date.now() - this.recordStartTime
                    }
                });
            }

            playScene(sceneId, stepMode = false) {
                const scene = this.savedScenes.get(sceneId);
                if (!scene) return;

                this.currentScene = scene;
                this.isPlaying = true;
                this.stepByStep = stepMode;
                this.isPaused = false;
                this.playbackIndex = 0;
                this.playbackStartTime = Date.now();

                // Show replay overlay and controls
                document.getElementById('replay-overlay').classList.add('active');
                document.getElementById('replay-controls').classList.add('active');
                document.getElementById('scene-timeline').style.display = 'block';
                document.getElementById('total-time').textContent = this.formatTime(scene.duration);

                // Update step counter
                this.updateStepCounter();

                // Initialize scene state
                const initAction = scene.actions.find(a => a.type === 'init');
                if (initAction) {
                    this.world.camera.position.copy(initAction.data.cameraPosition);
                    this.world.rotation.x = initAction.data.cameraRotation.x;
                    this.world.rotation.y = initAction.data.cameraRotation.y;
                }

                this.world.showNotification(stepMode ? 'Starting step-by-step replay...' : 'Starting scene replay...');

                // Start playback
                if (stepMode) {
                    this.isPaused = true;
                    this.executeCurrentAction();
                } else {
                    this.playNextAction(scene);
                }
            }

            togglePlayPause() {
                if (!this.isPlaying) return;

                this.isPaused = !this.isPaused;
                const btn = document.getElementById('replay-play-pause');
                btn.textContent = this.isPaused ? '▶️ Play' : '⏸️ Pause';

                if (!this.isPaused && this.stepByStep) {
                    this.stepByStep = false;
                    this.playNextAction(this.currentScene);
                }
            }

            nextStep() {
                if (!this.isPlaying || !this.currentScene) return;

                if (this.playbackIndex < this.currentScene.actions.length - 1) {
                    this.playbackIndex++;
                    this.executeCurrentAction();
                    this.updateStepCounter();
                } else {
                    this.world.showNotification('Reached end of recording');
                }
            }

            executeCurrentAction() {
                if (!this.currentScene || this.playbackIndex >= this.currentScene.actions.length) return;

                const action = this.currentScene.actions[this.playbackIndex];
                this.executeAction(action);

                // Update timeline
                const progress = (this.playbackIndex / this.currentScene.actions.length) * 100;
                document.getElementById('timeline-bar').style.width = `${progress}%`;
                document.getElementById('current-time').textContent = this.formatTime(action.timestamp);
            }

            updateStepCounter() {
                const status = document.getElementById('replay-status');
                if (this.currentScene) {
                    status.textContent = `Step ${this.playbackIndex + 1} of ${this.currentScene.actions.length}`;
                }
            }

            playNextAction(scene) {
                if (!this.isPlaying || this.playbackIndex >= scene.actions.length) {
                    this.stopPlayback();
                    return;
                }

                if (this.isPaused) {
                    requestAnimationFrame(() => this.playNextAction(scene));
                    return;
                }

                const currentTime = (Date.now() - this.playbackStartTime) * this.playbackSpeed;
                const action = scene.actions[this.playbackIndex];

                // Update timeline
                const progress = (currentTime / scene.duration) * 100;
                document.getElementById('timeline-bar').style.width = `${progress}%`;
                document.getElementById('current-time').textContent = this.formatTime(currentTime);

                // Execute actions that should have happened by now
                while (this.playbackIndex < scene.actions.length && 
                       scene.actions[this.playbackIndex].timestamp <= currentTime) {
                    
                    const action = scene.actions[this.playbackIndex];
                    this.executeAction(action);
                    this.playbackIndex++;
                    this.updateStepCounter();
                }

                // Continue playback
                requestAnimationFrame(() => this.playNextAction(scene));
            }

            executeAction(action) {
                switch (action.type) {
                    case 'camera':
                        this.world.camera.position.lerp(action.data.position, 0.1);
                        this.world.rotation.x = action.data.rotation.x;
                        this.world.rotation.y = action.data.rotation.y;
                        break;

                    case 'portal_interaction':
                        this.world.showNotification(`Portal interaction: ${action.data.portalName}`);
                        // Highlight the portal
                        this.world.portals.forEach(portal => {
                            if (portal.userData.name === action.data.portalName) {
                                portal.userData.material.uniforms.color1.value = new THREE.Color(0xff0000);
                                setTimeout(() => {
                                    portal.userData.material.uniforms.color1.value = new THREE.Color(CURRENT_WORLD.portalColor1);
                                }, 1000);
                            }
                        });
                        break;

                    case 'chat':
                        if (this.world.aiManager && this.world.aiManager.chatInterface.classList.contains('active')) {
                            this.world.aiManager.addMessage(action.data.message, action.data.sender);
                        }
                        break;

                    case 'players':
                        // Show player movements (simplified)
                        action.data.forEach(playerData => {
                            // Could create ghost players here
                        });
                        break;

                    case 'ai_companion':
                        if (this.world.aiManager && action.data.active) {
                            const companion = this.world.aiManager.companions.get('ai-assistant');
                            if (companion) {
                                companion.object.position.copy(action.data.position);
                            }
                        }
                        break;
                }
            }

            stopPlayback() {
                this.isPlaying = false;
                this.isPaused = false;
                this.stepByStep = false;
                this.currentScene = null;
                document.getElementById('replay-overlay').classList.remove('active');
                document.getElementById('replay-controls').classList.remove('active');
                document.getElementById('scene-timeline').style.display = 'none';
                this.world.showNotification('Playback complete!');
            }

            setPlaybackSpeed(speed) {
                this.playbackSpeed = speed;
            }

            updateRecordingTimer() {
                this.recordingTimer = setInterval(() => {
                    const elapsed = Date.now() - this.recordStartTime;
                    document.getElementById('recording-timer').textContent = this.formatTime(elapsed);
                }, 100);
            }

            formatTime(ms) {
                const seconds = Math.floor(ms / 1000);
                const minutes = Math.floor(seconds / 60);
                const secs = seconds % 60;
                return `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }

            exportScene() {
                if (this.savedScenes.size === 0) {
                    this.world.showNotification('No scenes to export!');
                    return;
                }

                const exportData = {
                    version: '1.0',
                    exportDate: new Date().toISOString(),
                    scenes: Array.from(this.savedScenes.values())
                };

                const jsonStr = JSON.stringify(exportData, null, 2);
                const blob = new Blob([jsonStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = `nexus_scenes_${Date.now()}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                this.world.showNotification('Scenes exported successfully!');
            }

            async importScene(event) {
                const file = event.target.files[0];
                if (!file) return;

                try {
                    const text = await file.text();
                    const importData = JSON.parse(text);

                    if (!importData.version || !importData.scenes) {
                        throw new Error('Invalid scene file format');
                    }

                    // Import each scene
                    importData.scenes.forEach(scene => {
                        this.savedScenes.set(scene.id, scene);
                    });

                    this.saveToLocalStorage();
                    this.updateSceneList();

                    this.world.showNotification(`Imported ${importData.scenes.length} scenes successfully!`);

                } catch (error) {
                    console.error('Error importing scenes:', error);
                    this.world.showNotification('Failed to import scenes. Check file format.');
                }

                // Reset file input
                event.target.value = '';
            }

            updateSceneList() {
                const sceneList = document.getElementById('scene-list');
                sceneList.innerHTML = '<h4 style="color: #ff6b6b; margin-bottom: 10px;">Recorded Scenes:</h4>';

                if (this.savedScenes.size === 0) {
                    sceneList.innerHTML += '<p style="color: rgba(255, 255, 255, 0.5); text-align: center;">No recorded scenes yet. Click "Start Recording" to create your first scene!</p>';
                    return;
                }

                this.savedScenes.forEach((scene, sceneId) => {
                    const sceneItem = document.createElement('div');
                    sceneItem.className = 'scene-item';
                    
                    sceneItem.innerHTML = `
                        <div class="scene-item-info">
                            <div class="scene-item-name">${scene.name}</div>
                            <div class="scene-item-details">
                                Duration: ${this.formatTime(scene.duration)} • 
                                Actions: ${scene.actions.length} • 
                                ${new Date(scene.timestamp).toLocaleDateString()}
                            </div>
                        </div>
                        <div class="scene-item-actions">
                            <button class="scene-action-btn play" onclick="window.worldNavigator.sceneRecorder.playScene('${sceneId}')">▶️ Play</button>
                            <button class="scene-action-btn" onclick="window.worldNavigator.sceneRecorder.playScene('${sceneId}', true)">⏭️ Step</button>
                            <button class="scene-action-btn delete" onclick="window.worldNavigator.sceneRecorder.deleteScene('${sceneId}')">Delete</button>
                        </div>
                    `;
                    
                    sceneList.appendChild(sceneItem);
                });
            }

            deleteScene(sceneId) {
                this.savedScenes.delete(sceneId);
                this.saveToLocalStorage();
                this.updateSceneList();
                this.world.showNotification('Scene deleted');
            }

            saveToLocalStorage() {
                const scenesArray = Array.from(this.savedScenes.values());
                localStorage.setItem('nexus_recorded_scenes', JSON.stringify(scenesArray));
            }

            loadSavedScenes() {
                try {
                    const saved = localStorage.getItem('nexus_recorded_scenes');
                    if (saved) {
                        const scenes = JSON.parse(saved);
                        scenes.forEach(scene => {
                            this.savedScenes.set(scene.id, scene);
                        });
                    }
                } catch (error) {
                    console.error('Error loading saved scenes:', error);
                }
            }
        }

        // Enhanced Portal Manager Class with Fast Travel
        class PortalManager {
            constructor(worldInstance) {
                this.world = worldInstance;
                this.customPortals = new Map(); // Store custom imported portals
                this.setupEventListeners();
            }

            setupEventListeners() {
                // Portal manager button
                document.getElementById('portal-manager-btn').addEventListener('click', () => {
                    this.showModal();
                });

                // Close button
                document.getElementById('portal-close').addEventListener('click', () => {
                    this.hideModal();
                });

                // Close on outside click
                document.getElementById('portal-manager-modal').addEventListener('click', (e) => {
                    if (e.target.id === 'portal-manager-modal') {
                        this.hideModal();
                    }
                });
            }

            showModal() {
                document.getElementById('portal-manager-modal').classList.add('show');
                this.updatePortalList();
            }

            hideModal() {
                document.getElementById('portal-manager-modal').classList.remove('show');
            }

            updatePortalList() {
                const portalList = document.getElementById('portal-list');
                portalList.innerHTML = '<h4 style="color: #06ffa5; margin-bottom: 10px;">Active Portals:</h4>';

                // Combine default worlds and custom portals
                const allPortals = [...this.world.worlds];
                this.customPortals.forEach((portal) => {
                    allPortals.push(portal);
                });

                if (allPortals.length === 0) {
                    portalList.innerHTML += '<p style="color: rgba(255, 255, 255, 0.5); text-align: center;">No portals active. Import portals to add worlds!</p>';
                    return;
                }

                allPortals.forEach((portal, index) => {
                    const portalItem = document.createElement('div');
                    portalItem.className = 'portal-item';

                    portalItem.innerHTML = `
                        <div class="portal-item-info">
                            <div class="portal-item-name">${portal.emoji || '🌀'} ${portal.name}</div>
                            <div class="portal-item-location">Portal ${index + 1}</div>
                        </div>
                        <div class="portal-item-actions">
                            <button class="portal-action-btn enter" onclick="window.worldNavigator.portalManager.fastTravel('${portal.pages_url || portal.url || portal.raw_url || '#'}', '${portal.name}')">Enter</button>
                            ${portal.isCustom ? `<button class="portal-action-btn delete" onclick="window.worldNavigator.portalManager.removePortal('${portal.id}')">Remove</button>` : ''}
                        </div>
                    `;
                    
                    // Make the entire item clickable for fast travel
                    portalItem.onclick = (e) => {
                        if (!e.target.classList.contains('portal-action-btn')) {
                            this.fastTravel(portal.pages_url || portal.url || portal.raw_url || '#', portal.name);
                        }
                    };
                    
                    portalList.appendChild(portalItem);
                });
            }

            fastTravel(url, portalName) {
                // Record the fast travel action if recording
                if (this.world.sceneRecorder && this.world.sceneRecorder.isRecording) {
                    this.world.sceneRecorder.recordPortalInteraction(portalName, url);
                }

                // Close the modal
                this.hideModal();

                // Show notification
                this.world.showNotification(`Fast traveling to ${portalName}...`);

                // Enter the world
                this.world.enterWorld(url);
            }

            exportPortals() {
                // Prepare portal data for export
                const exportData = {
                    version: "1.0",
                    exportDate: new Date().toISOString(),
                    portals: []
                };

                // Export all current portals (including custom ones)
                this.world.portals.forEach(portal => {
                    const portalData = {
                        name: portal.userData.name,
                        description: portal.userData.description,
                        emoji: portal.userData.world.emoji || '🌀',
                        url: portal.userData.url,
                        // Include visual properties from the captured world
                        worldAttributes: {
                            ambientColor: CURRENT_WORLD.ambientColor,
                            fogColor: CURRENT_WORLD.fogColor,
                            portalColor1: CURRENT_WORLD.portalColor1,
                            portalColor2: CURRENT_WORLD.portalColor2
                        }
                    };

                    // If this was a scanned world, include the anchor image
                    if (portal.userData.anchorImage) {
                        portalData.anchorImage = portal.userData.anchorImage;
                    }

                    exportData.portals.push(portalData);
                });

                // Create and download JSON file
                const jsonStr = JSON.stringify(exportData, null, 2);
                const blob = new Blob([jsonStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = `nexus_portals_${Date.now()}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                this.world.showNotification('Portals exported successfully!');
            }

            async importPortals(event) {
                const file = event.target.files[0];
                if (!file) return;

                try {
                    const text = await file.text();
                    const importData = JSON.parse(text);

                    // Validate import data
                    if (!importData.version || !importData.portals) {
                        throw new Error('Invalid portal file format');
                    }

                    // Import each portal
                    importData.portals.forEach(portalData => {
                        const portalId = `imported_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                        
                        const portal = {
                            id: portalId,
                            name: portalData.name,
                            description: portalData.description,
                            emoji: portalData.emoji || '🌀',
                            url: portalData.url || '#', // Placeholder URL if not provided
                            isCustom: true,
                            anchorImage: portalData.anchorImage,
                            worldAttributes: portalData.worldAttributes
                        };

                        this.customPortals.set(portalId, portal);
                    });

                    // Recreate portals in the 3D world
                    this.world.recreatePortals();

                    this.world.showNotification(`Imported ${importData.portals.length} portals successfully!`);
                    this.updatePortalList();

                } catch (error) {
                    console.error('Error importing portals:', error);
                    this.world.showNotification('Failed to import portals. Check file format.');
                }

                // Reset file input
                event.target.value = '';
            }

            removePortal(portalId) {
                this.customPortals.delete(portalId);
                this.world.recreatePortals();
                this.updatePortalList();
                this.world.showNotification('Portal removed');
            }

            // Add a portal from the world scanner
            addScannedPortal(worldData) {
                const portalId = worldData.id;
                
                const portal = {
                    id: portalId,
                    name: worldData.name,
                    description: worldData.description,
                    emoji: worldData.emoji || '🌀',
                    url: worldData.url || '#',
                    isCustom: true,
                    anchorImage: worldData.anchorImage,
                    worldAttributes: worldData.worldAttributes,
                    portalPosition: worldData.portalPosition
                };

                this.customPortals.set(portalId, portal);
                this.world.recreatePortals();
                this.world.showNotification(`Portal "${portal.name}" added to world!`);
            }
        }

        // Enhanced Task Manager for step-by-step conversation replay
        class TaskManager {
            constructor(worldInstance) {
                this.world = worldInstance;
                this.conversations = new Map(); // Store imported conversations
                this.currentReplay = null;
                this.isReplaying = false;
                this.isPaused = false;
                this.stepByStep = false;

                this.setupEventListeners();
            }

            setupEventListeners() {
                // Tasks button
                document.getElementById('tasks-button').addEventListener('click', () => {
                    this.toggleTaskPanel();
                });
            }

            toggleTaskPanel() {
                const panel = document.getElementById('task-panel');
                panel.classList.toggle('active');
                if (panel.classList.contains('active')) {
                    this.updateTaskList();
                }
            }

            updateTaskList() {
                const taskList = document.getElementById('task-list');
                taskList.innerHTML = '';

                if (this.conversations.size === 0) {
                    taskList.innerHTML = '<p style="color: rgba(255, 255, 255, 0.5); text-align: center; margin-top: 20px;">No conversations loaded yet. Upload a Teacher-Learner conversation JSON to replay it in 3D space!</p>';
                    return;
                }

                this.conversations.forEach((conversation, conversationId) => {
                    const taskEl = document.createElement('div');
                    taskEl.className = 'task-item';
                    
                    // Extract conversation info
                    const messageCount = conversation.conversation ? conversation.conversation.length : 0;
                    const timestamp = conversation.timestamp ? new Date(conversation.timestamp).toLocaleString() : 'Unknown';
                    const appName = conversation.appName || 'Unnamed Conversation';
                    
                    taskEl.innerHTML = `
                        <strong>${appName}</strong>
                        <small>Saved: ${timestamp}</small>
                        <div class="conversation-info">
                            ${messageCount} messages • 
                            ${conversation.guid ? 'User ID: ' + conversation.guid.slice(0, 8) + '...' : 'No user ID'}
                        </div>
                    `;
                    taskEl.onclick = () => this.startConversationReplay(conversationId);
                    taskList.appendChild(taskEl);
                });
            }

            async uploadConversation(event) {
                const file = event.target.files[0];
                if (!file) return;

                try {
                    const text = await file.text();
                    const conversationData = JSON.parse(text);

                    // Validate conversation format
                    if (!conversationData.conversation || !Array.isArray(conversationData.conversation)) {
                        throw new Error('Invalid conversation format');
                    }

                    // Generate unique ID for this conversation
                    const conversationId = `conv_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                    
                    // Store conversation
                    this.conversations.set(conversationId, conversationData);

                    // Update UI
                    this.updateTaskList();
                    this.world.showNotification('Conversation uploaded successfully!');

                } catch (error) {
                    console.error('Error uploading conversation:', error);
                    this.world.showNotification('Failed to upload conversation. Check file format.');
                }

                // Reset file input
                event.target.value = '';
            }

            async startConversationReplay(conversationId) {
                const conversation = this.conversations.get(conversationId);
                if (!conversation) return;

                // Start recording if not already recording
                if (this.world.sceneRecorder && !this.world.sceneRecorder.isRecording) {
                    this.world.sceneRecorder.startRecording();
                    this.world.showNotification('Recording started for conversation replay');
                }

                // Show notification
                this.world.showNotification(`Starting conversation replay...`);

                // Open chat interface
                document.getElementById('ai-chat-interface').classList.add('active');

                // Show replay indicator and controls
                document.getElementById('task-replay-indicator').classList.add('active');
                document.getElementById('replay-controls').classList.add('active');

                // Clear current chat
                const chatMessages = document.getElementById('ai-chat-messages');
                chatMessages.innerHTML = '';

                // Set replaying flag
                this.isReplaying = true;
                this.stepByStep = true;
                this.isPaused = true;
                this.currentReplay = {
                    conversation: conversation,
                    currentIndex: 0
                };

                // Update controls
                this.updateReplayControls();

                // Show first message
                await this.showNextMessage();
            }

            updateReplayControls() {
                const status = document.getElementById('replay-status');
                if (this.currentReplay) {
                    const current = this.currentReplay.currentIndex + 1;
                    const total = this.currentReplay.conversation.conversation.length;
                    status.textContent = `Message ${current} of ${total}`;
                }
            }

            async showNextMessage() {
                if (!this.isReplaying || !this.currentReplay) return;

                const { conversation, currentIndex } = this.currentReplay;
                
                if (currentIndex >= conversation.conversation.length) {
                    // Replay complete
                    this.endReplay();
                    return;
                }

                const message = conversation.conversation[currentIndex];

                // Process the message
                await this.processMessage(message);

                // Update index
                this.currentReplay.currentIndex++;
                this.updateReplayControls();

                // If not in step mode, continue automatically
                if (!this.stepByStep && !this.isPaused) {
                    const nextDelay = message.role === 'system' ? 500 : 2000;
                    setTimeout(() => this.showNextMessage(), nextDelay);
                }
            }

            async processMessage(message) {
                // Add message to chat
                if (message.role === 'user') {
                    this.addReplayMessage(message.content, 'user');
                    
                    // Record in scene recorder
                    if (this.world.sceneRecorder && this.world.sceneRecorder.isRecording) {
                        this.world.sceneRecorder.recordChatMessage(message.content, 'user');
                    }

                    // Simulate user movement
                    this.simulateUserAction(message.content);
                    
                } else if (message.role === 'assistant') {
                    // Show typing indicator for assistant
                    this.world.aiManager.showTypingIndicator();
                    
                    // Wait a bit for realism
                    await this.delay(1500);
                    
                    this.world.aiManager.hideTypingIndicator();
                    this.addReplayMessage(message.content, 'ai');
                    
                    // Animate 3D text if AI manager is active
                    if (this.world.aiManager && this.world.aiManager.isActive) {
                        this.world.aiManager.animateTextResponse(message.content);
                    }
                    
                    // Record in scene recorder
                    if (this.world.sceneRecorder && this.world.sceneRecorder.isRecording) {
                        this.world.sceneRecorder.recordChatMessage(message.content, 'ai');
                    }

                    // Simulate AI companion actions
                    this.simulateAIAction(message.content);
                    
                } else if (message.role === 'system') {
                    // Show system messages differently
                    this.addReplayMessage(message.content, 'system');
                    
                    // Show simplified log in 3D if it contains agent logs
                    if (message.content.includes('Performed') || message.content.includes('Stage')) {
                        const simplifiedLog = this.extractWorkshopStatus(message.content);
                        if (simplifiedLog && this.world.aiManager && this.world.aiManager.isActive) {
                            this.world.aiManager.animateAgentLog(simplifiedLog);
                        }
                    }

                    // Simulate system actions
                    this.simulateSystemAction(message.content);
                }
            }

            simulateUserAction(messageContent) {
                // Simulate user movement based on message content
                const lowerContent = messageContent.toLowerCase();
                
                if (lowerContent.includes('portal') || lowerContent.includes('enter') || lowerContent.includes('go to')) {
                    // Move camera towards a random portal
                    const portalIndex = Math.floor(Math.random() * this.world.portals.length);
                    const portal = this.world.portals[portalIndex];
                    if (portal) {
                        const targetPos = portal.parent.position.clone();
                        targetPos.y = this.world.camera.position.y;
                        
                        // Animate camera movement
                        const startPos = this.world.camera.position.clone();
                        const animateMove = (progress) => {
                            if (progress <= 1) {
                                this.world.camera.position.lerpVectors(startPos, targetPos, progress);
                                requestAnimationFrame(() => animateMove(progress + 0.02));
                            }
                        };
                        animateMove(0);
                    }
                }
                
                if (lowerContent.includes('look') || lowerContent.includes('see') || lowerContent.includes('view')) {
                    // Rotate camera
                    const targetRotation = this.world.rotation.y + (Math.random() - 0.5) * Math.PI;
                    const startRotation = this.world.rotation.y;
                    const animateRotation = (progress) => {
                        if (progress <= 1) {
                            this.world.rotation.y = startRotation + (targetRotation - startRotation) * progress;
                            requestAnimationFrame(() => animateRotation(progress + 0.02));
                        }
                    };
                    animateRotation(0);
                }
            }

            simulateAIAction(messageContent) {
                // Simulate AI companion movement based on response
                if (!this.world.aiManager || !this.world.aiManager.isActive) return;
                
                const companion = this.world.aiManager.companions.get('ai-assistant');
                if (!companion) return;

                const lowerContent = messageContent.toLowerCase();
                
                if (lowerContent.includes('follow') || lowerContent.includes('come') || lowerContent.includes('join')) {
                    // Move companion closer to camera
                    const targetPos = this.world.camera.position.clone();
                    targetPos.x += 3;
                    targetPos.z += 3;
                    companion.object.position.lerp(targetPos, 0.1);
                }
                
                if (lowerContent.includes('portal') || lowerContent.includes('world')) {
                    // Make companion orbit around its position
                    companion.orb.material.emissiveIntensity = 0.8;
                    companion.light.intensity = 4;
                }
            }

            simulateSystemAction(messageContent) {
                // Simulate world changes based on system messages
                if (messageContent.includes('Workshop Initialized')) {
                    // Flash all portals
                    this.world.portals.forEach(portal => {
                        portal.userData.material.uniforms.color2.value = new THREE.Color(0x00ff00);
                        setTimeout(() => {
                            portal.userData.material.uniforms.color2.value = new THREE.Color(CURRENT_WORLD.portalColor2);
                        }, 500);
                    });
                }
            }

            extractWorkshopStatus(systemMessage) {
                // Extract key status from workshop system messages
                if (systemMessage.includes('Workshop Initialized')) return '🚀 Workshop Started';
                if (systemMessage.includes('Stage 1 Complete')) return '✅ Pain Points Captured';
                if (systemMessage.includes('Stage 2 Complete')) return '📝 Stories Generated';
                if (systemMessage.includes('Stage 3 Complete')) return '🎯 Stories Refined';
                if (systemMessage.includes('Stage 4 Complete')) return '🏆 Priorities Set';
                if (systemMessage.includes('Stage 5')) return '🔍 Analyzing Current State';
                return null;
            }

            addReplayMessage(text, sender) {
                const chatMessages = document.getElementById('ai-chat-messages');
                const messageDiv = document.createElement('div');
                messageDiv.className = `ai-message ${sender} task-replay`;
                
                if (sender === 'system') {
                    // Format system messages
                    messageDiv.innerHTML = this.world.aiManager.formatAgentLog(text);
                } else {
                    messageDiv.textContent = text;
                }

                chatMessages.appendChild(messageDiv);
                chatMessages.scrollTop = chatMessages.scrollHeight;

                // Animate companion if AI message
                if (sender === 'ai' && this.world.aiManager && this.world.aiManager.isActive) {
                    this.world.aiManager.animateCompanionSpeaking();
                }
            }

            toggleReplayPause() {
                if (!this.isReplaying) return;
                
                this.isPaused = !this.isPaused;
                const btn = document.getElementById('replay-play-pause');
                btn.textContent = this.isPaused ? '▶️ Play' : '⏸️ Pause';

                if (!this.isPaused && this.stepByStep) {
                    this.stepByStep = false;
                    this.showNextMessage();
                }
            }

            nextReplayStep() {
                if (!this.isReplaying || !this.currentReplay) return;

                if (this.currentReplay.currentIndex < this.currentReplay.conversation.conversation.length) {
                    this.showNextMessage();
                } else {
                    this.world.showNotification('Reached end of conversation');
                }
            }

            stopReplay() {
                this.endReplay();
            }

            endReplay() {
                this.isReplaying = false;
                this.isPaused = false;
                this.stepByStep = false;
                this.currentReplay = null;
                
                // Hide replay indicator and controls
                document.getElementById('task-replay-indicator').classList.remove('active');
                document.getElementById('replay-controls').classList.remove('active');
                
                this.world.showNotification('Conversation replay completed!');

                // Stop recording if it was started for this replay
                if (this.world.sceneRecorder && this.world.sceneRecorder.isRecording) {
                    this.world.sceneRecorder.stopRecording();
                }
            }

            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }

        // World Creator Class
        class WorldCreator {
            constructor(worldInstance) {
                this.world = worldInstance;
                this.isScanning = false;
                this.scannedImage = null;
                this.stream = null;
                this.newWorldData = {
                    name: '',
                    description: '',
                    anchorImage: null,
                    createdBy: null,
                    timestamp: null,
                    id: null
                };

                this.setupEventListeners();
            }

            setupEventListeners() {
                // Scanner button
                document.getElementById('scanner-button').addEventListener('click', () => {
                    this.startScanning();
                });

                // Capture button
                document.getElementById('capture-btn').addEventListener('click', () => {
                    this.captureAnchor();
                });

                // Cancel button
                document.getElementById('cancel-scan-btn').addEventListener('click', () => {
                    this.stopScanning();
                });
            }

            async startScanning() {
                try {
                    // Show scanner UI
                    document.getElementById('world-scanner').classList.add('active');
                    this.isScanning = true;

                    // Get camera stream
                    const video = document.getElementById('scanner-video');
                    this.stream = await navigator.mediaDevices.getUserMedia({
                        video: { 
                            facingMode: 'environment',
                            width: { ideal: 1920 },
                            height: { ideal: 1080 }
                        }
                    });
                    video.srcObject = this.stream;

                } catch (error) {
                    console.error('Error starting scanner:', error);
                    this.world.showNotification('Camera access denied or not available');
                    this.stopScanning();
                }
            }

            captureAnchor() {
                const video = document.getElementById('scanner-video');
                const canvas = document.createElement('canvas');
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(video, 0, 0);

                // Store captured image
                this.scannedImage = canvas.toDataURL('image/jpeg', 0.8);

                // Stop scanner
                this.stopScanning();

                // Show world creation form
                this.showWorldCreationForm();
            }

            stopScanning() {
                document.getElementById('world-scanner').classList.remove('active');
                this.isScanning = false;

                // Stop camera stream
                if (this.stream) {
                    this.stream.getTracks().forEach(track => track.stop());
                    this.stream = null;
                }

                const video = document.getElementById('scanner-video');
                video.srcObject = null;
            }

            showWorldCreationForm() {
                const formUI = document.createElement('div');
                formUI.className = 'world-creation-form';
                formUI.id = 'world-creation-form';
                formUI.innerHTML = `
                    <div class="form-container">
                        <button class="form-close-btn" onclick="document.getElementById('world-creation-form').remove()">&times;</button>
                        <h2>Create New Portal World</h2>
                        <img src="${this.scannedImage}" class="anchor-preview">
                        <input type="text" id="world-name" placeholder="World Name" required>
                        <textarea id="world-description" placeholder="Describe this world..." rows="3"></textarea>
                        <select id="world-template">
                            <option value="custom">Custom World</option>
                            <option value="crystal">Crystal Cave Template</option>
                            <option value="neon">Neon City Template</option>
                            <option value="forest">Enchanted Forest Template</option>
                            <option value="space">Space Station Template</option>
                            <option value="ocean">Ocean Depths Template</option>
                        </select>
                        <input type="text" id="world-emoji" placeholder="Choose an emoji for your world (e.g., 🌟)" maxlength="2">
                        <button class="create-world-btn" onclick="window.worldNavigator.worldCreator.createWorld()">
                            ✨ Create Portal
                        </button>
                        <button class="download-json-btn" onclick="window.worldNavigator.worldCreator.downloadWorldJSON()">
                            💾 Download World Data (JSON)
                        </button>
                    </div>
                `;
                document.body.appendChild(formUI);
            }

            generateWorldID() {
                return 'world_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            }

            createWorld() {
                const name = document.getElementById('world-name').value;
                const description = document.getElementById('world-description').value;
                const template = document.getElementById('world-template').value;
                const emoji = document.getElementById('world-emoji').value || '🌀';

                if (!name) {
                    this.world.showNotification('Please enter a world name');
                    return;
                }

                // Create comprehensive world data
                this.newWorldData = {
                    id: this.generateWorldID(),
                    name: name,
                    description: description,
                    template: template,
                    emoji: emoji,
                    anchorImage: this.scannedImage,
                    createdBy: this.world.multiplayer?.peer?.id || 'anonymous',
                    createdAt: new Date().toISOString(),
                    worldAttributes: {
                        ...CURRENT_WORLD,
                        name: name,
                        description: description
                    },
                    portalPosition: this.calculatePortalPosition()
                };

                // Add portal to the world immediately
                this.world.portalManager.addScannedPortal(this.newWorldData);

                // Show success and download prompt
                this.showCreationSuccess();
            }

            calculatePortalPosition() {
                // Calculate where this portal should appear in 3D space
                const angle = Math.random() * Math.PI * 2;
                const distance = 10 + Math.random() * 10; // 10-20 units from center

                return {
                    x: Math.cos(angle) * distance,
                    y: 3,
                    z: Math.sin(angle) * distance,
                    rotation: -angle + Math.PI
                };
            }

            downloadWorldJSON() {
                if (!this.newWorldData.id) {
                    this.createWorld();
                    return;
                }

                // Create downloadable JSON
                const jsonData = JSON.stringify(this.newWorldData, null, 2);
                const blob = new Blob([jsonData], { type: 'application/json' });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = `${this.newWorldData.id}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                this.world.showNotification('World data downloaded! Use the World Builder tool to generate the HTML.');
            }

            showCreationSuccess() {
                const formContainer = document.querySelector('.form-container');
                formContainer.innerHTML = `
                    <h2>🎉 Portal Created!</h2>
                    <img src="${this.scannedImage}" class="anchor-preview">
                    <p style="color: #06ffa5; text-align: center; margin: 20px 0;">
                        <strong>${this.newWorldData.name}</strong><br>
                        ${this.newWorldData.description}
                    </p>
                    <button class="download-json-btn" onclick="window.worldNavigator.worldCreator.downloadWorldJSON()">
                        💾 Download World Data (JSON)
                    </button>
                    <p style="color: rgba(255, 255, 255, 0.5); text-align: center; margin-top: 20px; font-size: 14px;">
                        The portal has been added to your world! You can also download the JSON to create a full HTML world file.
                    </p>
                    <button class="create-world-btn" onclick="document.getElementById('world-creation-form').remove()">
                        Close
                    </button>
                `;
            }
        }

        // Main AI Manager Class
        class AIManager {
            constructor(worldInstance) {
                this.world = worldInstance;
                this.apiKey = null;
                this.endpoint = 'https://azfbusinessbot.azurewebsites.net/api/businessinsightbot_function';
                this.companions = new Map();
                this.conversationHistory = [];
                this.isActive = false;
                this.userGuid = this.generateUserGuid();

                // UI elements
                this.chatInterface = document.getElementById('ai-chat-interface');
                this.chatMessages = document.getElementById('ai-chat-messages');
                this.chatInput = document.getElementById('ai-chat-input');
                this.companionButton = document.getElementById('ai-companion-button');
                this.aiModal = document.getElementById('ai-modal');

                // 3D Text display
                this.textMeshes = [];
                this.currentTextAnimation = null;
                this.textGroup = null;

                // Agent log display
                this.agentLogMeshes = [];
                this.agentLogGroup = null;

                // Orbiting letters
                this.orbitingLetters = [];
                this.orbitGroup = null;

                this.setupEventListeners();

                // Check for cached API key
                this.checkCachedApiKey();
            }

            generateUserGuid() {
                return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                    const r = Math.random() * 16 | 0;
                    const v = c === 'x' ? r : (r & 0x3 | 0x8);
                    return v.toString(16);
                });
            }

            async checkCachedApiKey() {
                // Check if API key exists in localStorage
                const cachedApiKey = localStorage.getItem('nexus_ai_api_key');
                if (cachedApiKey) {
                    this.apiKey = cachedApiKey;

                    try {
                        // Test the cached API key with a simple request
                        const response = await this.sendToAPI('System check - testing cached API key.');

                        if (response.assistant_response) {
                            // Cached key is valid, activate AI automatically
                            this.isActive = true;
                            this.companionButton.classList.add('active');
                            this.showNotification('AI Companion activated with cached key!');

                            // Create AI companion in the world
                            this.createAICompanion();

                            // Update companion list
                            this.updateCompanionList();

                            // Don't show the initial message for auto-activation
                            console.log('AI Companion auto-activated with cached API key');
                        }
                    } catch (error) {
                        // Cached key is invalid, clear it
                        console.error('Cached API key is invalid:', error);
                        localStorage.removeItem('nexus_ai_api_key');
                        this.apiKey = null;
                        this.showNotification('Cached API key expired. Please enter a new one.');
                    }
                }
            }

            setupEventListeners() {
                // AI Companion button
                this.companionButton.addEventListener('click', () => {
                    if (this.isActive) {
                        this.chatInterface.classList.toggle('active');
                    } else {
                        this.aiModal.classList.add('show');
                    }
                });

                // AI Modal events
                document.getElementById('ai-close').addEventListener('click', () => {
                    this.aiModal.classList.remove('show');
                });

                document.getElementById('ai-activate-btn').addEventListener('click', () => {
                    this.activateAI();
                });

                // Close modal on outside click
                this.aiModal.addEventListener('click', (e) => {
                    if (e.target === this.aiModal) {
                        this.aiModal.classList.remove('show');
                    }
                });

                // Connect replay controls to task manager
                document.getElementById('replay-play-pause').addEventListener('click', () => {
                    if (this.world.taskManager && this.world.taskManager.isReplaying) {
                        this.world.taskManager.toggleReplayPause();
                    }
                });

                document.getElementById('replay-next-step').addEventListener('click', () => {
                    if (this.world.taskManager && this.world.taskManager.isReplaying) {
                        this.world.taskManager.nextReplayStep();
                    }
                });

                document.getElementById('replay-stop').addEventListener('click', () => {
                    if (this.world.taskManager && this.world.taskManager.isReplaying) {
                        this.world.taskManager.stopReplay();
                    }
                });
            }

            async activateAI() {
                const apiKeyInput = document.getElementById('ai-api-key');
                const apiKey = apiKeyInput.value.trim();

                if (!apiKey) {
                    this.showNotification('Please enter an API key');
                    return;
                }

                this.apiKey = apiKey;

                try {
                    // Test the API key with an initial request
                    const response = await this.sendToAPI('Hello! I have joined the Nexus world.');

                    if (response.assistant_response) {
                        this.isActive = true;
                        this.companionButton.classList.add('active');
                        this.aiModal.classList.remove('show');
                        this.showNotification('AI Companion activated!');

                        // Save API key to localStorage for future sessions
                        localStorage.setItem('nexus_ai_api_key', apiKey);

                        // Create AI companion in the world
                        this.createAICompanion();

                        // Update companion list
                        this.updateCompanionList();

                        // Show initial message
                        this.addMessage(response.assistant_response, 'ai');

                        // Display text in 3D world
                        this.animateTextResponse(response.assistant_response);

                        // Record in scene if recording
                        if (this.world.sceneRecorder && this.world.sceneRecorder.isRecording) {
                            this.world.sceneRecorder.recordChatMessage(response.assistant_response, 'ai');
                        }

                        // Clear the API key input for security
                        apiKeyInput.value = '';
                    }
                } catch (error) {
                    console.error('Failed to activate AI:', error);
                    this.showNotification('Failed to activate AI. Please check your API key.');
                }
            }

            createAICompanion() {
                // Create a visual representation of the AI companion in the world
                const companionGroup = new THREE.Group();

                // Create a glowing orb as the AI companion
                const geometry = new THREE.SphereGeometry(0.8, 32, 32);
                const material = new THREE.MeshStandardMaterial({
                    color: 0x8338ec,
                    emissive: 0x8338ec,
                    emissiveIntensity: 0.5,
                    metalness: 0.8,
                    roughness: 0.2,
                    transparent: true,
                    opacity: 0.8
                });

                const orb = new THREE.Mesh(geometry, material);
                orb.position.y = 2;
                companionGroup.add(orb);

                // Add glow effect
                const glowLight = new THREE.PointLight(0x8338ec, 2, 10);
                glowLight.position.y = 2;
                companionGroup.add(glowLight);

                // Add particle effect around the orb
                const particleGeometry = new THREE.BufferGeometry();
                const particleCount = 100;
                const positions = new Float32Array(particleCount * 3);

                for (let i = 0; i < particleCount * 3; i += 3) {
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    const radius = 1.5 + Math.random() * 0.5;

                    positions[i] = radius * Math.sin(phi) * Math.cos(theta);
                    positions[i + 1] = radius * Math.sin(phi) * Math.sin(theta) + 2;
                    positions[i + 2] = radius * Math.cos(phi);
                }

                particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

                const particleMaterial = new THREE.PointsMaterial({
                    color: 0x06ffa5,
                    size: 0.05,
                    transparent: true,
                    opacity: 0.6
                });

                const particles = new THREE.Points(particleGeometry, particleMaterial);
                companionGroup.add(particles);

                // Create text display group
                this.textGroup = new THREE.Group();
                this.textGroup.position.y = 4; // Position above the orb
                companionGroup.add(this.textGroup);

                // Create agent log display group
                this.agentLogGroup = new THREE.Group();
                this.agentLogGroup.position.y = 1; // Position below the orb
                companionGroup.add(this.agentLogGroup);

                // Create orbiting letters group
                this.orbitGroup = new THREE.Group();
                this.orbitGroup.position.y = 2; // Same height as orb
                companionGroup.add(this.orbitGroup);

                // Position near the player but further away
                companionGroup.position.set(8, 0, 8); // Increased distance from player

                // Add to scene
                this.world.scene.add(companionGroup);

                // Store reference
                this.companions.set('ai-assistant', {
                    object: companionGroup,
                    orb: orb,
                    particles: particles,
                    light: glowLight
                });

                // Load font for 3D text
                this.loadFont();

                // Animate the companion
                this.animateCompanion();
            }

            loadFont() {
                const loader = new THREE.FontLoader();
                loader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', (font) => {
                    this.font = font;
                });
            }

            create3DText(text, position = new THREE.Vector3(0, 0, 0), isAgentLog = false) {
                if (!this.font) {
                    console.warn('Font not loaded yet');
                    return null;
                }

                const textGeometry = new THREE.TextGeometry(text, {
                    font: this.font,
                    size: isAgentLog ? 0.2 : 0.3,
                    height: 0.05,
                    curveSegments: 12,
                    bevelEnabled: true,
                    bevelThickness: 0.01,
                    bevelSize: 0.01,
                    bevelSegments: 8
                });

                textGeometry.center();

                const textMaterial = new THREE.MeshStandardMaterial({
                    color: isAgentLog ? 0xffa500 : 0xffeb3b, // Yellow like Star Wars
                    emissive: isAgentLog ? 0xffa500 : 0xffeb3b,
                    emissiveIntensity: 0.3,
                    metalness: 0.5,
                    roughness: 0.3,
                    transparent: true,
                    opacity: 0
                });

                const textMesh = new THREE.Mesh(textGeometry, textMaterial);
                textMesh.position.copy(position);

                return textMesh;
            }

            createLetterMesh(letter, index) {
                if (!this.font) return null;

                const geometry = new THREE.TextGeometry(letter, {
                    font: this.font,
                    size: 0.2,
                    height: 0.02,
                    curveSegments: 8,
                    bevelEnabled: true,
                    bevelThickness: 0.005,
                    bevelSize: 0.005,
                    bevelSegments: 4
                });

                geometry.center();

                const material = new THREE.MeshStandardMaterial({
                    color: 0xffeb3b,
                    emissive: 0xffeb3b,
                    emissiveIntensity: 0.2,
                    metalness: 0.7,
                    roughness: 0.3,
                    transparent: true,
                    opacity: 0.8
                });

                const mesh = new THREE.Mesh(geometry, material);
                
                // Random orbit parameters
                mesh.userData = {
                    radius: 3 + Math.random() * 2,
                    speed: 0.5 + Math.random() * 0.5,
                    offset: Math.random() * Math.PI * 2,
                    yOffset: (Math.random() - 0.5) * 2,
                    rotationSpeed: Math.random() * 0.02
                };

                return mesh;
            }

            async animateTextResponse(fullText) {
                // Clear previous text meshes
                this.clearTextMeshes();

                // Cancel any ongoing animation
                if (this.currentTextAnimation) {
                    clearInterval(this.currentTextAnimation);
                }

                // Split text into lines (max ~40 chars per line)
                const words = fullText.split(' ');
                const lines = [];
                let currentLine = '';

                for (const word of words) {
                    if ((currentLine + word).length > 40) {
                        lines.push(currentLine.trim());
                        currentLine = word + ' ';
                    } else {
                        currentLine += word + ' ';
                    }
                }
                if (currentLine.trim()) {
                    lines.push(currentLine.trim());
                }

                // Star Wars style animation starting from much lower
                const textContainer = new THREE.Group();
                textContainer.position.y = -5; // Start below the camera view
                this.textGroup.add(textContainer);

                // Create all text lines at once
                lines.forEach((line, index) => {
                    const yOffset = -index * 0.6;
                    const textMesh = this.create3DText(line, new THREE.Vector3(0, yOffset, 0));
                    if (textMesh) {
                        textMesh.material.opacity = 1;
                        textContainer.add(textMesh);
                        this.textMeshes.push(textMesh);
                    }
                });

                // Animate text scrolling away like Star Wars
                let scrollProgress = 0;
                const scrollSpeed = 0.02;
                const lettersToOrbit = [];
                
                this.currentTextAnimation = setInterval(() => {
                    scrollProgress += scrollSpeed;
                    
                    // Move text up and away
                    textContainer.position.y = -5 + (scrollProgress * 3);
                    textContainer.position.z = -scrollProgress * 3;
                    
                    // Rotate for perspective effect
                    textContainer.rotation.x = -0.3 - (scrollProgress * 0.1);
                    
                    // Fade out
                    const fadeStart = 2;
                    const fadeEnd = 3;
                    if (scrollProgress > fadeStart) {
                        const fadeProgress = (scrollProgress - fadeStart) / (fadeEnd - fadeStart);
                        this.textMeshes.forEach(mesh => {
                            mesh.material.opacity = Math.max(0, 1 - fadeProgress);
                        });
                    }
                    
                    // Add letters to orbit as text fades
                    if (scrollProgress > fadeStart && lettersToOrbit.length === 0) {
                        // Extract some letters from the text to orbit
                        const allText = lines.join(' ');
                        const letterCount = Math.min(allText.length, 20); // Limit to 20 letters
                        for (let i = 0; i < letterCount; i++) {
                            const charIndex = Math.floor(Math.random() * allText.length);
                            const letter = allText[charIndex];
                            if (letter !== ' ') {
                                lettersToOrbit.push(letter);
                            }
                        }
                        
                        // Create orbiting letter meshes
                        lettersToOrbit.forEach((letter, index) => {
                            const letterMesh = this.createLetterMesh(letter, index);
                            if (letterMesh) {
                                this.orbitGroup.add(letterMesh);
                                this.orbitingLetters.push(letterMesh);
                            }
                        });
                    }
                    
                    // Stop and clean up when fully faded
                    if (scrollProgress > fadeEnd) {
                        clearInterval(this.currentTextAnimation);
                        this.currentTextAnimation = null;
                        this.clearTextMeshes();
                    }
                }, 50);
            }

            animateAgentLog(logText){
                // Clear previous agent log meshes
                this.clearAgentLogs();

                const logMesh = this.create3DText(logText, new THREE.Vector3(0, 0, 0), true);
                if (logMesh) {
                    this.agentLogGroup.add(logMesh);
                    this.agentLogMeshes.push(logMesh);

                    // Fade in animation
                    const fadeInInterval = setInterval(() => {
                        logMesh.material.opacity += 0.1;
                        if (logMesh.material.opacity >= 1) {
                            clearInterval(fadeInInterval);

                            // Fade out after 3 seconds
                            setTimeout(() => {
                                const fadeOutInterval = setInterval(() => {
                                    logMesh.material.opacity -= 0.02;
                                    if (logMesh.material.opacity <= 0) {
                                        clearInterval(fadeOutInterval);
                                        this.clearAgentLogs();
                                    }
                                }, 50);
                            }, 3000);
                        }
                    }, 50);
                }
            }

            clearTextMeshes() {
                this.textMeshes.forEach(mesh => {
                    if (mesh.geometry) mesh.geometry.dispose();
                    if (mesh.material) mesh.material.dispose();
                    mesh.parent?.remove(mesh);
                });
                this.textMeshes = [];
                
                // Clear any text containers
                while (this.textGroup.children.length > 0) {
                    this.textGroup.remove(this.textGroup.children[0]);
                }
            }

            clearAgentLogs() {
                this.agentLogMeshes.forEach(mesh => {
                    if (mesh.geometry) mesh.geometry.dispose();
                    if (mesh.material) mesh.material.dispose();
                    this.agentLogGroup.remove(mesh);
                });
                this.agentLogMeshes = [];
            }

            animateCompanion() {
                const companion = this.companions.get('ai-assistant');
                if (!companion) return;

                const animate = () => {
                    if (!this.isActive) return;

                    const time = Date.now() * 0.001;

                    // Float animation
                    companion.orb.position.y = 2 + Math.sin(time * 2) * 0.2;

                    // Rotate particles
                    companion.particles.rotation.y = time * 0.5;

                    // Pulse glow
                    companion.light.intensity = 2 + Math.sin(time * 3) * 0.5;

                    // Follow player at a greater distance
                    const targetPos = new THREE.Vector3();
                    targetPos.copy(this.world.camera.position);
                    targetPos.x += 8; // Increased distance
                    targetPos.z += 8; // Increased distance

                    companion.object.position.lerp(targetPos, 0.05);

                    // Make text face the camera
                    if (this.textGroup) {
                        this.textGroup.lookAt(this.world.camera.position);
                    }

                    // Make agent logs face the camera
                    if (this.agentLogGroup) {
                        this.agentLogGroup.lookAt(this.world.camera.position);
                    }

                    // Animate orbiting letters
                    this.orbitingLetters.forEach((letter, index) => {
                        const userData = letter.userData;
                        const angle = time * userData.speed + userData.offset;
                        
                        letter.position.x = Math.cos(angle) * userData.radius;
                        letter.position.z = Math.sin(angle) * userData.radius;
                        letter.position.y = userData.yOffset + Math.sin(time * 2 + index) * 0.2;
                        
                        letter.rotation.y += userData.rotationSpeed;
                        letter.rotation.x = Math.sin(time + index) * 0.2;
                    });

                    requestAnimationFrame(animate);
                };

                animate();
            }

            async sendToAPI(message) {
                const headers = {
                    'Content-Type': 'application/json',
                    'x-functions-key': this.apiKey
                };

                const body = {
                    user_input: message,
                    conversation_history: this.conversationHistory,
                    user_guid: this.userGuid
                };

                const response = await fetch(this.endpoint, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(body)
                });

                if (!response.ok) {
                    throw new Error(`API request failed: ${response.status}`);
                }

                return await response.json();
            }

            async sendMessage() {
                const message = this.chatInput.value.trim();
                if (!message || !this.isActive) return;

                // Check if currently replaying a conversation
                if (this.world.taskManager && this.world.taskManager.isReplaying) {
                    this.showNotification('Cannot send messages during conversation replay');
                    return;
                }

                // Add user message to chat
                this.addMessage(message, 'user');
                this.chatInput.value = '';

                // Record in scene if recording
                if (this.world.sceneRecorder && this.world.sceneRecorder.isRecording) {
                    this.world.sceneRecorder.recordChatMessage(message, 'user');
                }

                // Show typing indicator
                this.showTypingIndicator();

                // Add to conversation history
                this.conversationHistory.push({
                    role: 'user',
                    content: message
                });

                try {
                    // Send to API
                    const response = await this.sendToAPI(message);

                    // Remove typing indicator
                    this.hideTypingIndicator();

                    if (response.assistant_response) {
                        // Add AI response to chat
                        this.addMessage(response.assistant_response, 'ai');

                        // Add to conversation history
                        this.conversationHistory.push({
                            role: 'assistant',
                            content: response.assistant_response
                        });

                        // Animate companion when speaking
                        this.animateCompanionSpeaking();

                        // Display text in 3D world
                        this.animateTextResponse(response.assistant_response);

                        // Record in scene if recording
                        if (this.world.sceneRecorder && this.world.sceneRecorder.isRecording) {
                            this.world.sceneRecorder.recordChatMessage(response.assistant_response, 'ai');
                        }
                    }

                    // Handle agent logs if present
                    if (response.agent_logs) {
                        this.addAgentLog(response.agent_logs);

                        // Show simplified log in 3D
                        const simplifiedLog = this.extractAgentStatus(response.agent_logs);
                        if (simplifiedLog) {
                            this.animateAgentLog(simplifiedLog);
                        }
                    }
                } catch (error) {
                    console.error('Failed to send message:', error);
                    this.hideTypingIndicator();
                    this.addMessage('Sorry, I encountered an error. Please try again.', 'ai');
                }
            }

            extractAgentStatus(agentLogs) {
                // Extract key status from agent logs for 3D display
                if (agentLogs.includes('thinking')) return '🤔 Thinking...';
                if (agentLogs.includes('searching')) return '🔍 Searching...';
                if (agentLogs.includes('processing')) return '⚙️ Processing...';
                if (agentLogs.includes('analyzing')) return '📊 Analyzing...';
                if (agentLogs.includes('complete')) return '✅ Complete!';
                return '💭 Working...';
            }

            showTypingIndicator() {
                const typingDiv = document.createElement('div');
                typingDiv.className = 'ai-message ai-typing';
                typingDiv.id = 'ai-typing-indicator';
                typingDiv.innerHTML = `
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                `;

                this.chatMessages.appendChild(typingDiv);
                this.chatMessages.scrollTop = this.chatMessages.scrollHeight;
            }

            hideTypingIndicator() {
                const typingIndicator = document.getElementById('ai-typing-indicator');
                if (typingIndicator) {
                    typingIndicator.remove();
                }
            }

            addMessage(text, sender) {
                const messageDiv = document.createElement('div');
                messageDiv.className = `ai-message ${sender}`;
                messageDiv.textContent = text;

                this.chatMessages.appendChild(messageDiv);
                this.chatMessages.scrollTop = this.chatMessages.scrollHeight;
            }

            addAgentLog(logText) {
                const messageDiv = document.createElement('div');
                messageDiv.className = 'ai-message system';

                // Parse and format the agent logs
                const formattedLog = this.formatAgentLog(logText);
                messageDiv.innerHTML = formattedLog;

                this.chatMessages.appendChild(messageDiv);
                this.chatMessages.scrollTop = this.chatMessages.scrollHeight;
            }

            formatAgentLog(logText) {
                // Parse and format agent logs for better display
                let formatted = logText;

                // Add status indicators
                formatted = formatted.replace(/thinking/gi, '<span class="agent-status thinking">THINKING</span>');
                formatted = formatted.replace(/searching/gi, '<span class="agent-status searching">SEARCHING</span>');
                formatted = formatted.replace(/processing/gi, '<span class="agent-status processing">PROCESSING</span>');
                formatted = formatted.replace(/complete/gi, '<span class="agent-status complete">COMPLETE</span>');

                // Format steps
                formatted = formatted.replace(/Step \d+:/g, (match) => `<div class="agent-step">${match}</div>`);

                // Format errors
                formatted = formatted.replace(/Error:([^\n]*)/g, '<div class="agent-error">Error: $1</div>');

                // Format success messages
                formatted = formatted.replace(/Success:([^\n]*)/g, '<div class="agent-success">Success: $1</div>');

                // Wrap in container
                return `
                    <div class="agent-log-section">
                        <div class="agent-log-header">🤖 Agent Process Log</div>
                        <div class="agent-log-content">${formatted}</div>
                    </div>
                `;
            }

            animateCompanionSpeaking() {
                const companion = this.companions.get('ai-assistant');
                if (!companion) return;

                // Quick pulse animation
                const originalScale = companion.orb.scale.x;
                const pulseAnimation = () => {
                    let progress = 0;
                    const animate = () => {
                        progress += 0.1;
                        if (progress > 1) return;

                        const scale = originalScale + Math.sin(progress * Math.PI) * 0.3;
                        companion.orb.scale.setScalar(scale);

                        // Increase glow while speaking
                        companion.light.intensity = 3 + Math.sin(progress * Math.PI * 2) * 1;
                        companion.orb.material.emissiveIntensity = 0.5 + Math.sin(progress * Math.PI) * 0.3;

                        requestAnimationFrame(animate);
                    };
                    animate();
                };

                pulseAnimation();
            }

            updateCompanionList() {
                const listContainer = document.getElementById('ai-companion-list');
                listContainer.innerHTML = `
                    <h4 style="color: #06ffa5; margin-top: 20px;">Active Companions:</h4>
                    <div class="ai-companion-item">
                        <div>
                            <div class="ai-companion-name">AI Assistant</div>
                            <div class="ai-companion-status">Active and ready to chat</div>
                        </div>
                    </div>
                `;
            }

            showNotification(message) {
                const notification = document.createElement('div');
                notification.className = 'multiplayer-notification';
                notification.textContent = message;

                document.body.appendChild(notification);

                setTimeout(() => {
                    notification.style.animation = 'slideOut 0.3s ease';
                    setTimeout(() => notification.remove(), 300);
                }, 3000);
            }

            // Broadcast AI presence to multiplayer
            broadcastPresence() {
                if (this.world.multiplayer) {
                    this.world.multiplayer.broadcastAIPresence({
                        type: 'ai_companion',
                        name: 'AI Assistant',
                        position: this.companions.get('ai-assistant')?.object.position
                    });
                }
            }
        }

        // Multiplayer Manager Class
        class MultiplayerManager {
            constructor(worldInstance) {
                this.world = worldInstance;
                this.peer = null;
                this.connections = new Map();
                this.players = new Map();
                this.isHost = false;
                this.roomId = null;

                // Player update frequency (ms)
                this.updateInterval = 50;
                this.lastUpdate = 0;

                // Initialize peer connection
                this.initializePeer();
            }

            initializePeer() {
                // Generate or get peer ID
                const urlParams = new URLSearchParams(window.location.search);
                const hostId = urlParams.get('host');

                try {
                    if (hostId) {
                        // Joining someone's world
                        this.roomId = hostId;
                        this.peer = new Peer();

                        this.peer.on('open', (id) => {
                            console.log('My peer ID:', id);
                            console.log('Attempting to join room:', this.roomId);
                            
                            // Delay connection attempt to ensure host is ready
                            setTimeout(() => {
                                this.connectToHost(this.roomId);
                            }, 1000);
                            
                            this.updateStatus('Connecting...', false);
                        });
                    } else {
                        // Creating a new room
                        this.isHost = true;
                        this.peer = new Peer();

                        this.peer.on('open', (id) => {
                            this.roomId = id;
                            console.log('Created room with ID:', this.roomId);
                            this.updateShareUrl();
                            this.updateStatus('Hosting', true);
                        });
                    }

                    // Handle incoming connections
                    this.peer.on('connection', (conn) => {
                        console.log('Incoming connection from:', conn.peer);
                        this.handleNewConnection(conn);
                    });

                    // Handle errors
                    this.peer.on('error', (err) => {
                        console.error('Peer error:', err);
                        
                        // Handle specific error types
                        if (err.type === 'peer-unavailable') {
                            this.showError('Host not found. Make sure the host is online.');
                        } else if (err.type === 'network') {
                            this.showError('Network error. Check your connection.');
                        } else {
                            this.showError('Connection error: ' + err.message);
                        }
                        
                        this.updateStatus('Error', false);
                    });

                    // Handle disconnection
                    this.peer.on('disconnected', () => {
                        console.log('Disconnected from peer server');
                        this.updateStatus('Disconnected', false);
                        
                        // Try to reconnect
                        setTimeout(() => {
                            if (!this.peer.destroyed) {
                                console.log('Attempting to reconnect...');
                                this.peer.reconnect();
                            }
                        }, 3000);
                    });

                } catch (error) {
                    console.error('Failed to initialize peer:', error);
                    this.showError('Failed to initialize multiplayer');
                }
            }

            connectToHost(hostId) {
                try {
                    console.log('Connecting to host:', hostId);
                    
                    const conn = this.peer.connect(hostId, {
                        reliable: true,
                        serialization: 'json',
                        metadata: {
                            username: this.generateUsername(),
                            worldData: this.world.getCurrentWorldData()
                        }
                    });

                    // Set connection timeout
                    const connectionTimeout = setTimeout(() => {
                        if (conn.open === false) {
                            console.error('Connection timeout');
                            this.showError('Connection timeout. Host may be offline.');
                            conn.close();
                        }
                    }, 10000);

                    conn.on('open', () => {
                        clearTimeout(connectionTimeout);
                        console.log('Connected to host successfully');
                        this.updateStatus('Connected', true);
                    });

                    this.handleNewConnection(conn);
                } catch (error) {
                    console.error('Failed to connect to host:', error);
                    this.showError('Failed to connect to host');
                }
            }

            handleNewConnection(conn) {
                const peerId = conn.peer;

                conn.on('open', () => {
                    console.log('Connection opened with peer:', peerId);
                    this.connections.set(peerId, conn);

                    // Send initial player data
                    this.sendPlayerData(conn);

                    // Create player avatar
                    this.createPlayerAvatar(peerId, conn.metadata);

                    // Show notification
                    this.showNotification(`Player joined: ${conn.metadata?.username || 'Anonymous'}`);

                    // Update player count
                    this.updatePlayerCount();

                    // If we're the host, send world state to new player
                    if (this.isHost) {
                        this.sendWorldState(conn);
                    }
                });

                conn.on('data', (data) => {
                    try {
                        this.handlePeerData(peerId, data);
                    } catch (error) {
                        console.error('Error handling peer data:', error);
                    }
                });

                conn.on('close', () => {
                    console.log('Peer disconnected:', peerId);
                    this.removePlayer(peerId);
                    this.connections.delete(peerId);
                    this.updatePlayerCount();
                });

                conn.on('error', (err) => {
                    console.error('Connection error with peer', peerId, ':', err);
                });
            }

            handlePeerData(peerId, data) {
                switch (data.type) {
                    case 'playerUpdate':
                        this.updatePlayerPosition(peerId, data.position, data.rotation);
                        break;

                    case 'chat':
                        this.displayChat(peerId, data.message);
                        break;

                    case 'interaction':
                        this.showPlayerInteraction(peerId, data.target);
                        break;

                    case 'worldSync':
                        if (!this.isHost) {
                            this.syncWorldState(data.worldState);
                        }
                        break;

                    case 'ai_companion':
                        this.handleAICompanionData(peerId, data);
                        break;
                }
            }

            sendWorldState(conn) {
                // Send current world state to new player
                const worldState = {
                    type: 'worldSync',
                    worldState: {
                        worlds: this.world.worlds,
                        portals: this.world.portals.map(portal => ({
                            position: portal.position,
                            userData: portal.userData
                        }))
                    }
                };

                if (conn && conn.open) {
                    conn.send(worldState);
                }
            }

            syncWorldState(worldState) {
                // Sync world state from host
                console.log('Syncing world state from host');
                // Implementation depends on your world structure
            }

            handleAICompanionData(peerId, data) {
                // Handle AI companion presence from other players
                console.log(`AI companion data from ${peerId}:`, data);
                // Could show AI companions from other players here
            }

            createPlayerAvatar(peerId, metadata) {
                // Create a simple avatar for the player
                const avatarGroup = new THREE.Group();

                // Body (capsule-like shape)
                const bodyGeometry = new THREE.CylinderGeometry(0.5, 0.5, 2, 8);
                const bodyMaterial = new THREE.MeshStandardMaterial({
                    color: this.getPlayerColor(peerId),
                    metalness: 0.3,
                    roughness: 0.7
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 1;
                avatarGroup.add(body);

                // Head
                const headGeometry = new THREE.SphereGeometry(0.3, 8, 6);
                const head = new THREE.Mesh(headGeometry, bodyMaterial);
                head.position.y = 2.3;
                avatarGroup.add(head);

                // Name tag
                const nameTag = this.createNameTag(peerId, metadata);
                nameTag.position.y = 3;
                avatarGroup.add(nameTag);

                // Glow effect
                const light = new THREE.PointLight(this.getPlayerColor(peerId), 0.5, 5);
                light.position.y = 1.5;
                avatarGroup.add(light);

                // Add to scene
                this.world.scene.add(avatarGroup);
                this.players.set(peerId, {
                    avatar: avatarGroup,
                    lastUpdate: Date.now(),
                    username: metadata?.username || 'Anonymous'
                });
            }

            createNameTag(peerId, metadata) {
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');

                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, 256, 64);

                ctx.font = '32px Arial';
                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.fillText(metadata?.username || this.getPlayerName(peerId), 128, 40);

                const texture = new THREE.CanvasTexture(canvas);
                const material = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(material);
                sprite.scale.set(2, 0.5, 1);

                return sprite;
            }

            updatePlayerPosition(peerId, position, rotation) {
                const player = this.players.get(peerId);
                if (!player) return;

                // Smooth interpolation
                const targetPos = new THREE.Vector3(position.x, position.y, position.z);
                player.avatar.position.lerp(targetPos, 0.3);

                // Update rotation
                player.avatar.rotation.y = rotation.y;

                player.lastUpdate = Date.now();
            }

            sendPlayerData(conn) {
                const data = {
                    type: 'playerUpdate',
                    position: {
                        x: this.world.camera.position.x,
                        y: this.world.camera.position.y,
                        z: this.world.camera.position.z
                    },
                    rotation: {
                        x: this.world.camera.rotation.x,
                        y: this.world.camera.rotation.y
                    }
                };

                if (conn && conn.open) {
                    try {
                        conn.send(data);
                    } catch (error) {
                        console.error('Failed to send player data:', error);
                    }
                }
            }

            broadcastPlayerUpdate() {
                const now = Date.now();
                if (now - this.lastUpdate < this.updateInterval) return;

                this.connections.forEach((conn) => {
                    this.sendPlayerData(conn);
                });

                this.lastUpdate = now;
            }

            broadcastAIPresence(aiData) {
                this.connections.forEach((conn) => {
                    if (conn && conn.open) {
                        try {
                            conn.send({
                                type: 'ai_companion',
                                ...aiData
                            });
                        } catch (error) {
                            console.error('Failed to broadcast AI presence:', error);
                        }
                    }
                });
            }

            updateShareUrl() {
                // Update QR code to include host parameter
                const currentFile = window.location.pathname.split('/').pop() || 'index.html';
                const params = new URLSearchParams({
                    host: this.roomId
                });
                const shareUrl = `https://${REPO_OWNER}.github.io/${REPO_NAME}/${currentFile}?${params}`;

                // Update QR code
                const qrUrlElement = document.getElementById('qr-url');
                if (qrUrlElement) {
                    qrUrlElement.textContent = shareUrl;
                }

                // Regenerate QR code
                if (this.world.generateQRCode) {
                    this.world.generateQRCode(shareUrl);
                }

                // Update share button to show multiplayer status
                const shareButton = document.getElementById('share-button');
                if (shareButton) {
                    shareButton.classList.add('multiplayer');
                }

                // Show multiplayer info in modal
                const multiplayerInfo = document.getElementById('multiplayer-info');
                if (multiplayerInfo) {
                    multiplayerInfo.style.display = 'block';
                }
            }

            updateStatus(status, connected) {
                const statusText = document.getElementById('status-text');
                const statusIndicator = document.getElementById('status-indicator');

                if (statusText) statusText.textContent = status;
                if (statusIndicator) {
                    statusIndicator.classList.toggle('connected', connected);
                    statusIndicator.classList.toggle('hosting', this.isHost);
                }
            }

            updatePlayerCount() {
                const count = this.connections.size + 1; // +1 for self
                const playerCountEl = document.getElementById('player-count');
                if (playerCountEl) playerCountEl.textContent = count;
            }

            getPlayerColor(peerId) {
                // Generate consistent color based on peer ID
                const colors = [0xff006e, 0x06ffa5, 0x3a86ff, 0xffaa00, 0xff00ff];
                const index = peerId.charCodeAt(0) % colors.length;
                return colors[index];
            }

            getPlayerName(peerId) {
                const player = this.players.get(peerId);
                return player?.username || 'Player ' + peerId.substr(0, 4);
            }

            generateUsername() {
                const adjectives = ['Swift', 'Neon', 'Cyber', 'Quantum', 'Digital'];
                const nouns = ['Explorer', 'Wanderer', 'Voyager', 'Pilot', 'Navigator'];
                const adj = adjectives[Math.floor(Math.random() * adjectives.length)];
                const noun = nouns[Math.floor(Math.random() * nouns.length)];
                return `${adj}${noun}${Math.floor(Math.random() * 100)}`;
            }

            removePlayer(peerId) {
                const player = this.players.get(peerId);
                if (player) {
                    this.world.scene.remove(player.avatar);
                    this.players.delete(peerId);
                    this.showNotification(`Player left: ${player.username}`);
                }
            }

            showNotification(message) {
                // Create notification element
                const notification = document.createElement('div');
                notification.className = 'multiplayer-notification';
                notification.textContent = message;

                document.body.appendChild(notification);

                setTimeout(() => {
                    notification.style.animation = 'slideOut 0.3s ease';
                    setTimeout(() => notification.remove(), 300);
                }, 3000);
            }

            showError(message) {
                console.error(message);
                this.showNotification('⚠️ ' + message);
            }

            // Call this in the animation loop
            update() {
                this.broadcastPlayerUpdate();

                // Remove inactive players
                const now = Date.now();
                this.players.forEach((player, peerId) => {
                    if (now - player.lastUpdate > 5000) {
                        this.removePlayer(peerId);
                    }
                });
            }
        }

        // Main World Navigator Class
        class WorldNavigator {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.portals = [];
                this.worlds = [];
                this.raycaster = new THREE.Raycaster();
                this.clock = new THREE.Clock();

                this.moveSpeed = CURRENT_WORLD.moveSpeed;
                this.lookSpeed = CURRENT_WORLD.lookSpeed;
                this.keys = { w: false, a: false, s: false, d: false };
                this.rotation = { x: 0, y: 0 };

                this.isMobile = isMobile;
                this.isIOS = isIOS;
                this.joystickActive = false;
                this.joystickVector = new THREE.Vector2();
                this.lookTouch = null;
                this.joystickTouch = null;

                this.touches = new Map();
                this.lastTap = 0;

                this.hoveredPortal = null;
                this.tooltip = document.getElementById('portal-tooltip');
                this.tooltipTitle = this.tooltip.querySelector('.tooltip-title');
                this.tooltipDescription = this.tooltip.querySelector('.tooltip-description');
                this.isPointerLocked = false;

                this.inheritedAttributes = inheritedAttributes;

                // Gamepad support
                this.gamepad = null;
                this.gamepadDeadzone = 0.15;
                this.gamepadButtonStates = {};

                // Managers
                this.multiplayer = null;
                this.aiManager = null;
                this.worldCreator = null;
                this.taskManager = null;
                this.portalManager = null;
                this.sceneRecorder = null;

                if (this.isIOS) {
                    document.body.addEventListener('touchmove', (e) => {
                        if (e.target === document.body) {
                            e.preventDefault();
                        }
                    }, { passive: false });
                }
            }

            async init() {
                if (this.inheritedAttributes.sourceWorldName) {
                    const originDiv = document.getElementById('world-origin');
                    const originName = document.getElementById('origin-world-name');
                    originName.textContent = this.inheritedAttributes.sourceWorldName;
                    originDiv.classList.add('visible');
                    console.log('Arrived from:', this.inheritedAttributes.sourceWorldName);
                }

                setTimeout(() => {
                    document.getElementById('loading').style.display = 'none';
                }, 1000);

                document.getElementById('world-title').textContent = CURRENT_WORLD.name;
                document.getElementById('world-description').textContent = CURRENT_WORLD.description;

                this.setupScene();
                this.setupLighting();
                await this.loadWorlds();
                this.createEnvironment();
                this.createPortals();
                this.setupEventListeners();
                this.setupQRCode();

                // Initialize multiplayer
                this.multiplayer = new MultiplayerManager(this);

                // Initialize AI manager
                this.aiManager = new AIManager(this);

                // Initialize World Creator
                this.worldCreator = new WorldCreator(this);

                // Initialize Task Manager
                this.taskManager = new TaskManager(this);

                // Initialize Portal Manager
                this.portalManager = new PortalManager(this);

                // Initialize Scene Recorder
                this.sceneRecorder = new SceneRecorder(this);

                if (this.isMobile) {
                    document.getElementById('controls-hint').textContent = 'Touch & drag to look around, Use joystick to move, Tap on portals to travel';
                    document.getElementById('mobile-controls').classList.add('show');

                    const instruction = this.tooltip.querySelector('.tooltip-instruction');
                    if (instruction) {
                        instruction.textContent = 'Tap to enter world';
                    }
                }

                // Make WorldNavigator globally accessible for AI chat
                window.worldNavigator = this;

                this.animate();
            }

            getCurrentWorldData() {
                return {
                    worldName: CURRENT_WORLD.name,
                    position: this.camera.position,
                    rotation: this.camera.rotation
                };
            }

            setupScene() {
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.Fog(CURRENT_WORLD.fogColor, CURRENT_WORLD.fogNear, CURRENT_WORLD.fogFar);

                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, CURRENT_WORLD.cameraHeight, 10);

                this.renderer = new THREE.WebGLRenderer({ 
                    antialias: true, 
                    alpha: true,
                    powerPreference: "high-performance"
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.getElementById('three-container').appendChild(this.renderer.domElement);
            }

            setupLighting() {
                const ambientLight = new THREE.AmbientLight(CURRENT_WORLD.ambientColor, 0.5);
                this.scene.add(ambientLight);

                const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
                dirLight.position.set(10, 20, 10);
                dirLight.castShadow = true;
                dirLight.shadow.camera.near = 0.1;
                dirLight.shadow.camera.far = 100;
                dirLight.shadow.camera.left = -50;
                dirLight.shadow.camera.right = 50;
                dirLight.shadow.camera.top = 50;
                dirLight.shadow.camera.bottom = -50;
                this.scene.add(dirLight);
            }

            async loadWorlds() {
                try {
                    const apiUrl = `https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/git/trees/${BRANCH}?recursive=1`;
                    const response = await fetch(apiUrl);

                    if (!response.ok) {
                        throw new Error(`GitHub API error: ${response.status}`);
                    }

                    const data = await response.json();

                    this.worlds = data.tree
                        .filter(item => 
                            item.type === 'blob' && 
                            item.path.endsWith('.html') && 
                            !item.path.includes('/') &&
                            !item.path.toLowerCase().includes('index') &&
                            !item.path.toLowerCase().includes('readme')
                        )
                        .map(item => ({
                            path: item.path,
                            name: this.formatWorldName(item.path),
                            url: `https://raw.githubusercontent.com/${REPO_OWNER}/${REPO_NAME}/${BRANCH}/${item.path}`,
                            raw_url: `https://raw.githubusercontent.com/${REPO_OWNER}/${REPO_NAME}/${BRANCH}/${item.path}`,
                            pages_url: `${GITHUB_PAGES_BASE}${item.path}`,
                            emoji: this.getWorldEmoji(item.path)
                        }));

                    console.log(`Found ${this.worlds.length} worlds to connect`);

                } catch (error) {
                    console.error("Error loading worlds:", error);
                    this.worlds = this.getDemoWorlds();
                }
            }

            formatWorldName(filename) {
                return filename
                    .replace('.html', '')
                    .replace(/[-_]/g, ' ')
                    .replace(/\b\w/g, l => l.toUpperCase());
            }

            getWorldEmoji(filename) {
                // Assign emojis based on world names
                const emojiMap = {
                    'crystal': '💎',
                    'cave': '🏔️',
                    'sky': '☁️',
                    'island': '🏝️',
                    'neon': '🌃',
                    'city': '🏙️',
                    'ancient': '🏛️',
                    'ruins': '🗿',
                    'ocean': '🌊',
                    'water': '💧',
                    'forest': '🌲',
                    'desert': '🏜️',
                    'space': '🚀',
                    'cyber': '💻',
                    'magic': '✨'
                };

                const lower = filename.toLowerCase();
                for (const [key, emoji] of Object.entries(emojiMap)) {
                    if (lower.includes(key)) return emoji;
                }
                return '🌀'; // Default portal emoji
            }

            getDemoWorlds() {
                return [
                    { name: "Crystal Caves", description: "A world of glowing crystals and underground mysteries", emoji: "💎" },
                    { name: "Sky Islands", description: "Floating islands connected by bridges of light", emoji: "☁️" },
                    { name: "Neon City", description: "A cyberpunk metropolis bathed in neon lights", emoji: "🌃" },
                    { name: "Ancient Ruins", description: "Explore the remnants of a lost civilization", emoji: "🏛️" },
                    { name: "Ocean Depths", description: "An underwater realm of bioluminescent wonders", emoji: "🌊" }
                ];
            }

            createEnvironment() {
                const groundGeometry = new THREE.PlaneGeometry(200, 200, 50, 50);
                const groundMaterial = new THREE.MeshStandardMaterial({
                    color: CURRENT_WORLD.groundColor,
                    roughness: 0.8,
                    metalness: 0.2
                });

                const vertices = groundGeometry.attributes.position.array;
                for (let i = 0; i < vertices.length; i += 3) {
                    vertices[i + 2] = Math.sin(vertices[i] * 0.1) * Math.cos(vertices[i + 1] * 0.1) * 0.5;
                }
                groundGeometry.computeVertexNormals();

                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.receiveShadow = true;
                this.scene.add(ground);

                const gridHelper = new THREE.GridHelper(200, 100, 0x444444, 0x222222);
                gridHelper.position.y = 0.1;
                this.scene.add(gridHelper);

                const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
                const skyMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        topColor: { value: new THREE.Color(CURRENT_WORLD.skyColor) },
                        bottomColor: { value: new THREE.Color(CURRENT_WORLD.fogColor) },
                        offset: { value: 33 },
                        exponent: { value: 0.6 }
                    },
                    vertexShader: `
                        varying vec3 vWorldPosition;
                        void main() {
                            vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                            vWorldPosition = worldPosition.xyz;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform vec3 topColor;
                        uniform vec3 bottomColor;
                        uniform float offset;
                        uniform float exponent;
                        varying vec3 vWorldPosition;
                        void main() {
                            float h = normalize(vWorldPosition + offset).y;
                            gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 1.0);
                        }
                    `,
                    side: THREE.BackSide
                });
                const sky = new THREE.Mesh(skyGeometry, skyMaterial);
                this.scene.add(sky);

                const particleGeometry = new THREE.BufferGeometry();
                const particleCount = CURRENT_WORLD.particleCount;
                const positions = new Float32Array(particleCount * 3);

                for (let i = 0; i < particleCount * 3; i += 3) {
                    positions[i] = (Math.random() - 0.5) * 100;
                    positions[i + 1] = Math.random() * 50;
                    positions[i + 2] = (Math.random() - 0.5) * 100;
                }

                particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

                const particleMaterial = new THREE.PointsMaterial({
                    color: 0xffffff,
                    size: 0.1,
                    transparent: true,
                    opacity: 0.6
                });

                const particles = new THREE.Points(particleGeometry, particleMaterial);
                this.scene.add(particles);
            }

            recreatePortals() {
                // Clear existing portals
                this.portals.forEach(portal => {
                    if (portal.parent) {
                        portal.parent.parent?.remove(portal.parent);
                    }
                });
                this.portals = [];

                // Create portals again with updated world list
                this.createPortals();
            }

            createPortals() {
                // Combine default worlds with custom imported portals
                const allWorlds = [...this.worlds];
                if (this.portalManager) {
                    this.portalManager.customPortals.forEach((portal) => {
                        allWorlds.push(portal);
                    });
                }

                const numPortals = Math.min(allWorlds.length, 16); // Increased max portals
                const radius = 15;

                for (let i = 0; i < numPortals; i++) {
                    const world = allWorlds[i];
                    
                    // Use custom position if available
                    let position, rotation;
                    if (world.portalPosition) {
                        position = world.portalPosition;
                        rotation = { y: world.portalPosition.rotation || 0 };
                    } else {
                        // Default circular arrangement
                        const angle = (i / numPortals) * Math.PI * 2;
                        position = {
                            x: Math.cos(angle) * radius,
                            y: 3,
                            z: Math.sin(angle) * radius
                        };
                        rotation = { y: -angle + Math.PI };
                    }

                    const portalGroup = new THREE.Group();

                    const frameGeometry = new THREE.TorusGeometry(3, 0.3, 16, 32);
                    const frameMaterial = new THREE.MeshStandardMaterial({
                        color: 0x8338ec,
                        emissive: 0x8338ec,
                        emissiveIntensity: 0.5,
                        metalness: 0.8,
                        roughness: 0.2
                    });
                    const frame = new THREE.Mesh(frameGeometry, frameMaterial);

                    const portalGeometry = new THREE.CircleGeometry(2.7, 32);
                    const portalMaterial = new THREE.ShaderMaterial({
                        uniforms: {
                            time: { value: 0 },
                            color1: { value: new THREE.Color(CURRENT_WORLD.portalColor1) },
                            color2: { value: new THREE.Color(CURRENT_WORLD.portalColor2) },
                            accessible: { value: 0.8 } // Always accessible in teleport mode
                        },
                        vertexShader: `
                            varying vec2 vUv;
                            void main() {
                                vUv = uv;
                                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                            }
                        `,
                        fragmentShader: `
                            uniform float time;
                            uniform vec3 color1;
                            uniform vec3 color2;
                            uniform float accessible;
                            varying vec2 vUv;

                            void main() {
                                vec2 center = vUv - 0.5;
                                float dist = length(center);
                                float wave = sin(dist * 10.0 - time * 2.0) * 0.5 + 0.5;
                                vec3 color = mix(color1, color2, wave);
                                float alpha = (1.0 - smoothstep(0.4, 0.5, dist)) * accessible;
                                gl_FragColor = vec4(color, alpha);
                            }
                        `,
                        transparent: true,
                        side: THREE.DoubleSide
                    });
                    const portal = new THREE.Mesh(portalGeometry, portalMaterial);
                    portal.position.z = 0.1;

                    portalGroup.add(frame);
                    portalGroup.add(portal);

                    portalGroup.position.set(position.x, position.y, position.z);
                    portalGroup.rotation.y = rotation.y;

                    const light = new THREE.PointLight(0x8338ec, 1, 10);
                    light.position.copy(portalGroup.position);
                    this.scene.add(light);

                    portal.userData = {
                        world: world,
                        material: portalMaterial,
                        light: light,
                        url: world.pages_url || world.url || world.raw_url || '#',
                        name: world.name,
                        description: world.description || `Enter the ${world.name} world`,
                        accessible: true // Always accessible in teleport mode
                    };

                    this.portals.push(portal);
                    this.scene.add(portalGroup);

                    const platformGeometry = new THREE.CylinderGeometry(4, 4, 0.5, 32);
                    const platformMaterial = new THREE.MeshStandardMaterial({
                        color: 0x444444,
                        metalness: 0.5,
                        roughness: 0.5
                    });
                    const platform = new THREE.Mesh(platformGeometry, platformMaterial);
                    platform.position.copy(portalGroup.position);
                    platform.position.y = 0.25;
                    platform.receiveShadow = true;
                    platform.castShadow = true;
                    this.scene.add(platform);
                }
            }

            buildInheritanceParams() {
                const params = new URLSearchParams();

                params.set('from', window.location.pathname.split('/').pop() || 'index.html');
                params.set('fromName', CURRENT_WORLD.name);

                // Visual attributes
                params.set('lookSpeed', this.lookSpeed.toString());
                params.set('ambientColor', CURRENT_WORLD.ambientColor.toString(16).padStart(6, '0'));
                params.set('fogColor', CURRENT_WORLD.fogColor.toString(16).padStart(6, '0'));
                params.set('portalColor1', CURRENT_WORLD.portalColor1.toString(16).padStart(6, '0'));
                params.set('portalColor2', CURRENT_WORLD.portalColor2.toString(16).padStart(6, '0'));
                params.set('particleCount', CURRENT_WORLD.particleCount.toString());
                params.set('cameraHeight', this.camera.position.y.toString());
                params.set('fogNear', CURRENT_WORLD.fogNear.toString());
                params.set('fogFar', CURRENT_WORLD.fogFar.toString());

                return params.toString();
            }

            setupQRCode() {
                const shareButton = document.getElementById('share-button');
                const qrModal = document.getElementById('qr-modal');
                const qrClose = document.getElementById('qr-close');
                const copyButton = document.getElementById('copy-url-btn');
                const qrUrlElement = document.getElementById('qr-url');

                // Check if we're in multiplayer mode
                const urlParams = new URLSearchParams(window.location.search);
                const hostId = urlParams.get('host');
                const currentFile = window.location.pathname.split('/').pop() || 'index.html';

                let worldUrl;
                if (this.multiplayer && this.multiplayer.isHost) {
                    // Host URL includes room ID
                    const params = new URLSearchParams({
                        host: this.multiplayer.roomId
                    });
                    worldUrl = `https://${REPO_OWNER}.github.io/${REPO_NAME}/${currentFile}?${params}`;
                } else if (hostId) {
                    // Already in multiplayer session
                    worldUrl = window.location.href;
                } else {
                    // Single player URL
                    worldUrl = `https://${REPO_OWNER}.github.io/${REPO_NAME}/${currentFile}`;
                }

                qrUrlElement.textContent = worldUrl;

                shareButton.addEventListener('click', () => {
                    qrModal.classList.add('show');
                    // Update URL if multiplayer is active
                    if (this.multiplayer && this.multiplayer.roomId) {
                        const params = new URLSearchParams({
                            host: this.multiplayer.roomId
                        });
                        const multiplayerUrl = `https://${REPO_OWNER}.github.io/${REPO_NAME}/${currentFile}?${params}`;
                        qrUrlElement.textContent = multiplayerUrl;
                        this.generateQRCode(multiplayerUrl);
                    } else {
                        this.generateQRCode(worldUrl);
                    }
                });

                qrClose.addEventListener('click', () => {
                    qrModal.classList.remove('show');
                });

                qrModal.addEventListener('click', (e) => {
                    if (e.target === qrModal) {
                        qrModal.classList.remove('show');
                    }
                });

                copyButton.addEventListener('click', async () => {
                    try {
                        const urlToCopy = qrUrlElement.textContent;
                        await navigator.clipboard.writeText(urlToCopy);
                        copyButton.textContent = 'Copied!';
                        copyButton.classList.add('copied');

                        setTimeout(() => {
                            copyButton.textContent = 'Copy URL';
                            copyButton.classList.remove('copied');
                        }, 2000);
                    } catch (err) {
                        console.error('Failed to copy:', err);
                    }
                });
            }

            generateQRCode(url) {
                const container = document.getElementById('qr-code-container');
                container.innerHTML = '';

                const loadQRious = () => {
                    return new Promise((resolve, reject) => {
                        if (window.QRious) {
                            resolve();
                        } else {
                            const script = document.createElement('script');
                            script.src = 'https://cdnjs.cloudflare.com/ajax/libs/qrious/4.0.2/qrious.min.js';
                            script.onload = resolve;
                            script.onerror = reject;
                            document.head.appendChild(script);
                        }
                    });
                };

                loadQRious().then(() => {
                    const canvas = document.createElement('canvas');
                    container.appendChild(canvas);

                    new window.QRious({
                        element: canvas,
                        value: url,
                        size: 250,
                        background: 'white',
                        foreground: 'black',
                        level: 'H'
                    });
                }).catch(() => {
                    const img = document.createElement('img');
                    img.src = `https://api.qrserver.com/v1/create-qr-code/?size=250x250&data=${encodeURIComponent(url)}`;
                    img.alt = 'QR Code';
                    container.appendChild(img);
                });
            }

            setupEventListeners() {
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });

                if (this.isMobile) {
                    this.setupMobileControls();
                } else {
                    this.setupDesktopControls();
                }

                // Setup gamepad controls
                this.setupGamepadControls();
            }

            setupGamepadControls() {
                // Check for gamepad support
                if (!('getGamepads' in navigator)) {
                    console.log('Gamepad API not supported');
                    return;
                }

                // Listen for gamepad connection
                window.addEventListener('gamepadconnected', (e) => {
                    console.log('Gamepad connected:', e.gamepad.id);
                    this.gamepad = e.gamepad.index;
                    this.showNotification('🎮 Gamepad connected! Use left stick to move, right stick to look');
                    
                    // Show gamepad indicator
                    const indicator = document.getElementById('gamepad-indicator');
                    if (indicator) {
                        indicator.classList.add('active');
                    } else {
                        // Create indicator if it doesn't exist
                        this.createGamepadIndicator();
                    }
                });

                window.addEventListener('gamepaddisconnected', (e) => {
                    console.log('Gamepad disconnected');
                    if (this.gamepad === e.gamepad.index) {
                        this.gamepad = null;
                        
                        // Hide gamepad indicator
                        const indicator = document.getElementById('gamepad-indicator');
                        if (indicator) {
                            indicator.classList.remove('active');
                        }
                    }
                });
            }

            createGamepadIndicator() {
                const indicator = document.createElement('div');
                indicator.id = 'gamepad-indicator';
                indicator.className = 'active';
                indicator.innerHTML = `
                    🎮 Gamepad Mode
                    <span style="font-size: 12px; color: rgba(255, 255, 255, 0.6); margin-left: 10px;">
                        LS: Move | RS: Look | A: Enter Portal
                    </span>
                `;
                document.body.appendChild(indicator);
            }

            updateGamepadInput() {
                if (this.gamepad === null) return;

                const gamepads = navigator.getGamepads();
                const gp = gamepads[this.gamepad];
                
                if (!gp || !gp.connected) return;

                // Left stick for movement (axes 0 and 1)
                const leftX = this.applyDeadzone(gp.axes[0]);
                const leftY = this.applyDeadzone(gp.axes[1]);

                // Right stick for camera look (axes 2 and 3)
                const rightX = this.applyDeadzone(gp.axes[2]);
                const rightY = this.applyDeadzone(gp.axes[3]);

                // Movement
                if (Math.abs(leftX) > 0 || Math.abs(leftY) > 0) {
                    const forward = new THREE.Vector3();
                    const right = new THREE.Vector3();

                    this.camera.getWorldDirection(forward);
                    forward.y = 0;
                    forward.normalize();

                    right.crossVectors(forward, new THREE.Vector3(0, 1, 0));

                    // Move based on left stick
                    const moveForward = forward.multiplyScalar(-leftY * this.moveSpeed);
                    const moveRight = right.multiplyScalar(leftX * this.moveSpeed);
                    
                    this.camera.position.add(moveForward);
                    this.camera.position.add(moveRight);
                }

                // Camera look with right stick
                if (Math.abs(rightX) > 0 || Math.abs(rightY) > 0) {
                    this.rotation.y -= rightX * this.lookSpeed * 2;
                    this.rotation.x -= rightY * this.lookSpeed * 2;
                    this.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.rotation.x));
                }

                // A button (button 0) for interact/enter portal
                if (gp.buttons[0].pressed) {
                    this.handleGamepadInteraction();
                }

                // B button (button 1) for toggle map view
                if (gp.buttons[1].pressed && !this.gamepadButtonStates.b) {
                    // Map functionality removed
                }

                // X button (button 2) for AI companion
                if (gp.buttons[2].pressed && !this.gamepadButtonStates.x) {
                    this.companionButton.click();
                }

                // Y button (button 3) for toggle share/QR
                if (gp.buttons[3].pressed && !this.gamepadButtonStates.y) {
                    document.getElementById('share-button').click();
                }

                // Left trigger (button 6) for slower movement
                if (gp.buttons[6].pressed) {
                    this.moveSpeed = CURRENT_WORLD.moveSpeed * 0.3;
                } else {
                    this.moveSpeed = CURRENT_WORLD.moveSpeed;
                }

                // Right trigger (button 7) for sprint
                if (gp.buttons[7].pressed) {
                    this.moveSpeed = CURRENT_WORLD.moveSpeed * 2;
                }

                // Update button states to detect single presses
                this.updateGamepadButtonStates(gp);
            }

            applyDeadzone(value) {
                if (Math.abs(value) < this.gamepadDeadzone) {
                    return 0;
                }
                return value;
            }

            updateGamepadButtonStates(gp) {
                if (!this.gamepadButtonStates) {
                    this.gamepadButtonStates = {};
                }
                
                this.gamepadButtonStates.a = gp.buttons[0].pressed;
                this.gamepadButtonStates.b = gp.buttons[1].pressed;
                this.gamepadButtonStates.x = gp.buttons[2].pressed;
                this.gamepadButtonStates.y = gp.buttons[3].pressed;
            }

            handleGamepadInteraction() {
                this.raycaster.setFromCamera(new THREE.Vector2(0, 0), this.camera);
                const intersects = this.raycaster.intersectObjects(this.portals);

                if (intersects.length > 0) {
                    const portal = intersects[0].object;
                    if (portal.userData.url) {
                        // Record portal interaction if recording
                        if (this.sceneRecorder && this.sceneRecorder.isRecording) {
                            this.sceneRecorder.recordPortalInteraction(portal.userData.name, portal.userData.url);
                        }
                        this.enterWorld(portal.userData.url);
                    }
                }
            }

            setupDesktopControls() {
                window.addEventListener('keydown', (e) => {
                    if (e.key.toLowerCase() in this.keys) {
                        this.keys[e.key.toLowerCase()] = true;
                    }
                });

                window.addEventListener('keyup', (e) => {
                    if (e.key.toLowerCase() in this.keys) {
                        this.keys[e.key.toLowerCase()] = false;
                    }
                });

                this.renderer.domElement.addEventListener('click', (e) => {
                    if (!this.isPointerLocked) {
                        this.renderer.domElement.requestPointerLock();
                    } else {
                        this.raycaster.setFromCamera(new THREE.Vector2(0, 0), this.camera);
                        const intersects = this.raycaster.intersectObjects(this.portals);

                        if (intersects.length > 0) {
                            const portal = intersects[0].object;
                            // Always allow entering worlds in teleport mode
                            if (portal.userData.url) {
                                // Record portal interaction if recording
                                if (this.sceneRecorder && this.sceneRecorder.isRecording) {
                                    this.sceneRecorder.recordPortalInteraction(portal.userData.name, portal.userData.url);
                                }
                                this.enterWorld(portal.userData.url);
                            }
                        }
                    }
                });

                document.addEventListener('pointerlockchange', () => {
                    this.isPointerLocked = document.pointerLockElement === this.renderer.domElement;
                });

                document.addEventListener('mousemove', (e) => {
                    if (this.isPointerLocked) {
                        this.rotation.y -= e.movementX * this.lookSpeed;
                        this.rotation.x -= e.movementY * this.lookSpeed;
                        this.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.rotation.x));
                    }
                });
            }

            setupMobileControls() {
                const lookArea = document.getElementById('look-area');

                lookArea.addEventListener('touchstart', (e) => {
                    const touch = e.touches[0];

                    const rect = this.renderer.domElement.getBoundingClientRect();
                    const x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
                    const y = -((touch.clientY - rect.top) / rect.height) * 2 + 1;

                    this.raycaster.setFromCamera(new THREE.Vector2(x, y), this.camera);
                    const intersects = this.raycaster.intersectObjects(this.portals);

                    if (intersects.length > 0) {
                        const portal = intersects[0].object;
                        // Always allow entering worlds in teleport mode
                        if (portal.userData.url) {
                            e.preventDefault();
                            // Record portal interaction if recording
                            if (this.sceneRecorder && this.sceneRecorder.isRecording) {
                                this.sceneRecorder.recordPortalInteraction(portal.userData.name, portal.userData.url);
                            }
                            this.enterWorld(portal.userData.url);
                            return;
                        }
                    }

                    this.lookTouch = {
                        id: touch.identifier,
                        startX: touch.clientX,
                        startY: touch.clientY,
                        currentX: touch.clientX,
                        currentY: touch.clientY
                    };
                }, { passive: true });

                lookArea.addEventListener('touchmove', (e) => {
                    if (!this.lookTouch) return;

                    for (let i = 0; i < e.touches.length; i++) {
                        const touch = e.touches[i];
                        if (touch.identifier === this.lookTouch.id) {
                            const deltaX = touch.clientX - this.lookTouch.currentX;
                            const deltaY = touch.clientY - this.lookTouch.currentY;

                            this.rotation.y -= deltaX * this.lookSpeed * 2;
                            this.rotation.x -= deltaY * this.lookSpeed * 2;
                            this.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.rotation.x));

                            this.lookTouch.currentX = touch.clientX;
                            this.lookTouch.currentY = touch.clientY;

                            e.preventDefault();
                            break;
                        }
                    }
                }, { passive: false });

                lookArea.addEventListener('touchend', (e) => {
                    for (let i = 0; i < e.changedTouches.length; i++) {
                        const touch = e.changedTouches[i];
                        if (this.lookTouch && touch.identifier === this.lookTouch.id) {
                            this.lookTouch = null;
                            break;
                        }
                    }
                }, { passive: true });

                const joystick = document.getElementById('movement-joystick');
                const handle = document.getElementById('movement-handle');

                joystick.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    e.stopPropagation();

                    const touch = e.touches[0];
                    this.joystickTouch = {
                        id: touch.identifier
                    };

                    this.joystickActive = true;
                    this.updateJoystick(touch, joystick, handle);
                }, { passive: false });

                joystick.addEventListener('touchmove', (e) => {
                    if (!this.joystickActive || !this.joystickTouch) return;

                    e.preventDefault();
                    e.stopPropagation();

                    for (let i = 0; i < e.touches.length; i++) {
                        const touch = e.touches[i];
                        if (touch.identifier === this.joystickTouch.id) {
                            this.updateJoystick(touch, joystick, handle);
                            break;
                        }
                    }
                }, { passive: false });

                joystick.addEventListener('touchend', (e) => {
                    for (let i = 0; i < e.changedTouches.length; i++) {
                        const touch = e.changedTouches[i];
                        if (this.joystickTouch && touch.identifier === this.joystickTouch.id) {
                            this.joystickActive = false;
                            this.joystickTouch = null;
                            this.joystickVector.set(0, 0);
                            handle.style.transform = 'translate(-50%, -50%)';

                            e.preventDefault();
                            e.stopPropagation();
                            break;
                        }
                    }
                }, { passive: false });

                window.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    return false;
                });
            }

            updateJoystick(touch, joystick, handle) {
                const rect = joystick.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;

                let deltaX = touch.clientX - centerX;
                let deltaY = touch.clientY - centerY;

                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                const maxDistance = rect.width / 2 - 25;

                if (distance > maxDistance) {
                    deltaX = (deltaX / distance) * maxDistance;
                    deltaY = (deltaY / distance) * maxDistance;
                }

                handle.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;

                this.joystickVector.x = deltaX / maxDistance;
                this.joystickVector.y = -deltaY / maxDistance;
            }

            updateMovement() {
                const forward = new THREE.Vector3();
                const right = new THREE.Vector3();

                this.camera.getWorldDirection(forward);
                forward.y = 0;
                forward.normalize();

                right.crossVectors(forward, new THREE.Vector3(0, 1, 0));

                if (this.isMobile) {
                    if (this.joystickActive) {
                        const moveForward = forward.multiplyScalar(this.joystickVector.y * this.moveSpeed);
                        const moveRight = right.multiplyScalar(this.joystickVector.x * this.moveSpeed);
                        this.camera.position.add(moveForward);
                        this.camera.position.add(moveRight);
                    }
                } else {
                    if (this.keys.w) this.camera.position.add(forward.multiplyScalar(this.moveSpeed));
                    if (this.keys.s) this.camera.position.add(forward.multiplyScalar(-this.moveSpeed));
                    if (this.keys.a) this.camera.position.add(right.multiplyScalar(-this.moveSpeed));
                    if (this.keys.d) this.camera.position.add(right.multiplyScalar(this.moveSpeed));
                }

                this.camera.rotation.order = 'YXZ';
                this.camera.rotation.y = this.rotation.y;
                this.camera.rotation.x = this.rotation.x;
            }

            updateHover() {
                this.raycaster.setFromCamera(new THREE.Vector2(0, 0), this.camera);
                const intersects = this.raycaster.intersectObjects(this.portals);

                if (intersects.length > 0) {
                    const portal = intersects[0].object;

                    if (portal !== this.hoveredPortal) {
                        this.hoveredPortal = portal;

                        this.tooltipTitle.textContent = portal.userData.name;
                        this.tooltipDescription.textContent = portal.userData.description;

                        this.tooltip.classList.add('visible');

                        const vector = new THREE.Vector3();
                        portal.getWorldPosition(vector);
                        vector.project(this.camera);
                        const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                        const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;

                        this.tooltip.style.left = `${Math.min(x + 20, window.innerWidth - 320)}px`;
                        this.tooltip.style.top = `${Math.min(y - 50, window.innerHeight - 200)}px`;
                    }
                } else {
                    if (this.hoveredPortal) {
                        this.hoveredPortal = null;
                        this.tooltip.classList.remove('visible');
                    }
                }
            }

            showNotification(message) {
                const notification = document.createElement('div');
                notification.className = 'multiplayer-notification';
                notification.textContent = message;

                document.body.appendChild(notification);

                setTimeout(() => {
                    notification.style.animation = 'slideOut 0.3s ease';
                    setTimeout(() => notification.remove(), 300);
                }, 3000);
            }

            async enterWorld(url) {
                try {
                    console.log('Entering world with URL:', url);
                    
                    // Simply navigate to the GitHub Pages URL
                    const inheritanceParams = this.buildInheritanceParams();
                    
                    // If in multiplayer, preserve the host parameter
                    const urlParams = new URLSearchParams(window.location.search);
                    const hostId = urlParams.get('host');
                    if (hostId) {
                        inheritanceParams += `&host=${hostId}`;
                    }
                    
                    // Build the final URL with parameters
                    const separator = url.includes('?') ? '&' : '?';
                    const finalUrl = `${url}${separator}${inheritanceParams}`;
                    
                    console.log('Navigating to:', finalUrl);
                    window.location.href = finalUrl;

                } catch (error) {
                    console.error('Error entering world:', error);
                    document.getElementById('loading').innerHTML = 'Failed to enter world. Please try again.';
                    setTimeout(() => {
                        document.getElementById('loading').style.display = 'none';
                    }, 3000);
                }
            }

            animate() {
                requestAnimationFrame(() => this.animate());

                const time = this.clock.getElapsedTime();

                // Update gamepad input
                this.updateGamepadInput();

                this.updateMovement();
                this.updateHover();

                // Update multiplayer
                if (this.multiplayer) {
                    this.multiplayer.update();
                }

                // Record frame if scene recorder is active
                if (this.sceneRecorder && this.sceneRecorder.isRecording) {
                    this.sceneRecorder.recordFrame();
                }

                this.portals.forEach((portal, index) => {
                    if (portal.userData.material) {
                        portal.userData.material.uniforms.time.value = time;

                        const baseIntensity = 0.8; // Always bright in teleport mode
                        const intensity = baseIntensity + Math.sin(time * 2 + index) * 0.2;
                        portal.userData.light.intensity = intensity;
                    }

                    portal.rotation.z = Math.sin(time * 0.5 + index) * 0.1;
                });

                const particles = this.scene.getObjectByProperty('type', 'Points');
                if (particles) {
                    particles.rotation.y = time * 0.05;
                    particles.position.y = Math.sin(time * 0.2) * 2;
                }

                this.renderer.render(this.scene, this.camera);
            }
        }

        window.addEventListener('DOMContentLoaded', () => {
            const navigator = new WorldNavigator();
            navigator.init();
        });

        let lastY = 0;
        window.addEventListener('touchstart', (e) => {
            lastY = e.touches[0].clientY;
        }, { passive: true });

        window.addEventListener('touchmove', (e) => {
            const y = e.touches[0].clientY;
            const scrollingUp = y > lastY;
            const atTop = window.pageYOffset === 0;

            if (scrollingUp && atTop) {
                e.preventDefault();
            }
            lastY = y;
        }, { passive: false });
    </script>
</body>
</html>