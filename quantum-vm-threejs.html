<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Virtual Machine - Three.js</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #000;
            color: #0ff;
            overflow: hidden;
            position: relative;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .control-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #0ff;
            border-radius: 10px;
            padding: 20px;
            max-width: 350px;
            max-height: 90vh;
            overflow-y: auto;
            z-index: 100;
        }

        .info-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #0ff;
            border-radius: 10px;
            padding: 20px;
            width: 300px;
            z-index: 100;
        }

        h1 {
            color: #0ff;
            font-size: 1.5em;
            margin-bottom: 15px;
            text-shadow: 0 0 10px #0ff;
        }

        h2 {
            color: #0ff;
            font-size: 1.2em;
            margin: 15px 0 10px 0;
            border-bottom: 1px solid #0ff;
            padding-bottom: 5px;
        }

        button {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid #0ff;
            color: #0ff;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            transition: all 0.3s;
        }

        button:hover {
            background: rgba(0, 255, 255, 0.3);
            box-shadow: 0 0 10px #0ff;
        }

        button.active {
            background: rgba(0, 255, 255, 0.4);
            box-shadow: 0 0 20px #0ff;
        }

        .gate-button {
            background: rgba(255, 0, 255, 0.1);
            border-color: #f0f;
        }

        .gate-button:hover {
            background: rgba(255, 0, 255, 0.3);
            box-shadow: 0 0 10px #f0f;
        }

        .execute-button {
            background: rgba(0, 255, 0, 0.1);
            border-color: #0f0;
            font-weight: bold;
        }

        .execute-button:hover {
            background: rgba(0, 255, 0, 0.3);
            box-shadow: 0 0 10px #0f0;
        }

        .state-display {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #0ff;
            border-radius: 5px;
            padding: 10px;
            margin: 10px 0;
            font-size: 0.9em;
            word-break: break-all;
        }

        .amplitude {
            color: #f0f;
            font-weight: bold;
        }

        .probability {
            color: #0f0;
        }

        .circuit-display {
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #f0f;
            border-radius: 5px;
            padding: 10px;
            margin: 10px 0;
            min-height: 50px;
            font-size: 0.9em;
        }

        .measurement-result {
            background: rgba(0, 255, 0, 0.1);
            border: 1px solid #0f0;
            border-radius: 5px;
            padding: 10px;
            margin: 10px 0;
            text-align: center;
            font-size: 1.2em;
        }

        .qubit-selector {
            display: flex;
            gap: 10px;
            margin: 10px 0;
        }

        .qubit-btn {
            flex: 1;
            padding: 5px;
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid #0ff;
            color: #0ff;
            cursor: pointer;
        }

        .qubit-btn.selected {
            background: rgba(0, 255, 255, 0.4);
        }

        input[type="number"] {
            width: 100%;
            padding: 5px;
            margin: 5px 0;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #0ff;
            color: #0ff;
            font-family: 'Courier New', monospace;
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #0ff;
            padding: 10px;
            border-radius: 5px;
            font-size: 0.9em;
            pointer-events: none;
            z-index: 1000;
            display: none;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div class="control-panel">
        <h1>‚öõÔ∏è Quantum VM Control</h1>
        
        <h2>System Configuration</h2>
        <label>Number of Qubits:</label>
        <input type="number" id="qubitCount" value="3" min="1" max="8">
        <button onclick="initializeSystem()">Initialize System</button>
        
        <h2>Select Target Qubit</h2>
        <div class="qubit-selector" id="qubitSelector"></div>
        
        <h2>Single Qubit Gates</h2>
        <button class="gate-button" onclick="applyGate('H')">Hadamard (H)</button>
        <button class="gate-button" onclick="applyGate('X')">Pauli-X (NOT)</button>
        <button class="gate-button" onclick="applyGate('Y')">Pauli-Y</button>
        <button class="gate-button" onclick="applyGate('Z')">Pauli-Z</button>
        <button class="gate-button" onclick="applyGate('S')">Phase (S)</button>
        <button class="gate-button" onclick="applyGate('T')">T Gate (œÄ/8)</button>
        
        <h2>Two-Qubit Gates</h2>
        <button class="gate-button" onclick="applyGate('CNOT')">CNOT (Control-X)</button>
        <button class="gate-button" onclick="applyGate('CZ')">Control-Z</button>
        <button class="gate-button" onclick="applyGate('SWAP')">SWAP</button>
        
        <h2>Circuit Operations</h2>
        <button class="execute-button" onclick="executeCircuit()">‚ö° Execute Circuit</button>
        <button onclick="measureAll()">üìä Measure All Qubits</button>
        <button onclick="clearCircuit()">üóëÔ∏è Clear Circuit</button>
        <button onclick="createGHZ()">üîó Create GHZ State</button>
        <button onclick="createBellPair()">üîó Create Bell Pair</button>
        
        <div class="circuit-display" id="circuitDisplay">
            Circuit: Empty
        </div>
        
        <div class="measurement-result" id="measurementResult" style="display: none;">
            Measurement: <span id="measurementValue">|000‚ü©</span>
        </div>
    </div>
    
    <div class="info-panel">
        <h2>Quantum State</h2>
        <div class="state-display" id="stateDisplay">
            |œà‚ü© = |000‚ü©
        </div>
        
        <h2>State Vector</h2>
        <div class="state-display" id="vectorDisplay">
            Initializing...
        </div>
        
        <h2>Probabilities</h2>
        <div class="state-display" id="probabilityDisplay">
            |000‚ü©: 100%
        </div>
        
        <h2>Entanglement</h2>
        <div class="state-display" id="entanglementDisplay">
            No entanglement
        </div>
    </div>
    
    <div class="tooltip" id="tooltip"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Quantum Virtual Machine Core
        class QuantumVM {
            constructor(numQubits = 3) {
                this.numQubits = numQubits;
                this.stateSize = Math.pow(2, numQubits);
                this.state = new Array(this.stateSize).fill(0);
                this.state[0] = { real: 1, imag: 0 }; // Initialize to |000...‚ü©
                this.circuit = [];
                this.selectedQubit = 0;
                this.targetQubit = 1;
            }

            // Complex number operations
            complexMultiply(a, b) {
                return {
                    real: a.real * b.real - a.imag * b.imag,
                    imag: a.real * b.imag + a.imag * b.real
                };
            }

            complexAdd(a, b) {
                return {
                    real: a.real + b.real,
                    imag: a.imag + b.imag
                };
            }

            complexMagnitude(c) {
                return Math.sqrt(c.real * c.real + c.imag * c.imag);
            }

            // Initialize state vector
            initializeState() {
                this.state = new Array(this.stateSize).fill(null).map(() => ({ real: 0, imag: 0 }));
                this.state[0] = { real: 1, imag: 0 };
                this.circuit = [];
            }

            // Gate matrices
            getGateMatrix(gate) {
                const sqrt2 = Math.sqrt(2);
                const gates = {
                    'H': [
                        [{ real: 1/sqrt2, imag: 0 }, { real: 1/sqrt2, imag: 0 }],
                        [{ real: 1/sqrt2, imag: 0 }, { real: -1/sqrt2, imag: 0 }]
                    ],
                    'X': [
                        [{ real: 0, imag: 0 }, { real: 1, imag: 0 }],
                        [{ real: 1, imag: 0 }, { real: 0, imag: 0 }]
                    ],
                    'Y': [
                        [{ real: 0, imag: 0 }, { real: 0, imag: -1 }],
                        [{ real: 0, imag: 1 }, { real: 0, imag: 0 }]
                    ],
                    'Z': [
                        [{ real: 1, imag: 0 }, { real: 0, imag: 0 }],
                        [{ real: 0, imag: 0 }, { real: -1, imag: 0 }]
                    ],
                    'S': [
                        [{ real: 1, imag: 0 }, { real: 0, imag: 0 }],
                        [{ real: 0, imag: 0 }, { real: 0, imag: 1 }]
                    ],
                    'T': [
                        [{ real: 1, imag: 0 }, { real: 0, imag: 0 }],
                        [{ real: 0, imag: 0 }, { real: 1/sqrt2, imag: 1/sqrt2 }]
                    ]
                };
                return gates[gate];
            }

            // Apply single qubit gate
            applySingleQubitGate(gate, qubit) {
                const matrix = this.getGateMatrix(gate);
                const newState = new Array(this.stateSize).fill(null).map(() => ({ real: 0, imag: 0 }));
                
                for (let i = 0; i < this.stateSize; i++) {
                    const bit = (i >> qubit) & 1;
                    const i0 = i & ~(1 << qubit);
                    const i1 = i | (1 << qubit);
                    
                    if (bit === 0) {
                        newState[i0] = this.complexAdd(
                            this.complexMultiply(matrix[0][0], this.state[i0]),
                            this.complexMultiply(matrix[0][1], this.state[i1])
                        );
                    } else {
                        newState[i1] = this.complexAdd(
                            this.complexMultiply(matrix[1][0], this.state[i0]),
                            this.complexMultiply(matrix[1][1], this.state[i1])
                        );
                    }
                }
                
                this.state = newState;
            }

            // Apply CNOT gate
            applyCNOT(control, target) {
                const newState = [...this.state];
                
                for (let i = 0; i < this.stateSize; i++) {
                    const controlBit = (i >> control) & 1;
                    if (controlBit === 1) {
                        const targetBit = (i >> target) & 1;
                        const flippedIndex = i ^ (1 << target);
                        [newState[i], newState[flippedIndex]] = [newState[flippedIndex], newState[i]];
                    }
                }
                
                this.state = newState;
            }

            // Apply CZ gate
            applyCZ(control, target) {
                for (let i = 0; i < this.stateSize; i++) {
                    const controlBit = (i >> control) & 1;
                    const targetBit = (i >> target) & 1;
                    if (controlBit === 1 && targetBit === 1) {
                        this.state[i] = this.complexMultiply(this.state[i], { real: -1, imag: 0 });
                    }
                }
            }

            // Apply SWAP gate
            applySWAP(qubit1, qubit2) {
                const newState = [...this.state];
                
                for (let i = 0; i < this.stateSize; i++) {
                    const bit1 = (i >> qubit1) & 1;
                    const bit2 = (i >> qubit2) & 1;
                    if (bit1 !== bit2) {
                        const swappedIndex = i ^ (1 << qubit1) ^ (1 << qubit2);
                        if (i < swappedIndex) {
                            [newState[i], newState[swappedIndex]] = [newState[swappedIndex], newState[i]];
                        }
                    }
                }
                
                this.state = newState;
            }

            // Measure all qubits
            measureAll() {
                const probabilities = this.state.map(amp => 
                    Math.pow(this.complexMagnitude(amp), 2)
                );
                
                const random = Math.random();
                let cumulative = 0;
                
                for (let i = 0; i < probabilities.length; i++) {
                    cumulative += probabilities[i];
                    if (random < cumulative) {
                        // Collapse to measured state
                        this.state = new Array(this.stateSize).fill(null).map(() => ({ real: 0, imag: 0 }));
                        this.state[i] = { real: 1, imag: 0 };
                        return i;
                    }
                }
                
                return 0;
            }

            // Get state as string
            getStateString() {
                const threshold = 0.001;
                const terms = [];
                
                for (let i = 0; i < this.stateSize; i++) {
                    const magnitude = this.complexMagnitude(this.state[i]);
                    if (magnitude > threshold) {
                        const binary = i.toString(2).padStart(this.numQubits, '0');
                        const sign = this.state[i].real < 0 ? '-' : '+';
                        terms.push(`${sign}${magnitude.toFixed(3)}|${binary}‚ü©`);
                    }
                }
                
                return terms.length > 0 ? terms.join(' ') : '|0‚ü©';
            }

            // Check entanglement
            isEntangled() {
                // Simple check: if more than one basis state has non-zero amplitude
                const nonZeroStates = this.state.filter(amp => 
                    this.complexMagnitude(amp) > 0.001
                ).length;
                return nonZeroStates > 1;
            }
        }

        // Three.js Visualization
        let scene, camera, renderer;
        let qubits = [];
        let connections = [];
        let vm = new QuantumVM(3);
        let animationId;

        function initThreeJS() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000000, 1, 1000);
            
            camera = new THREE.PerspectiveCamera(
                75, 
                window.innerWidth / window.innerHeight, 
                0.1, 
                1000
            );
            camera.position.set(0, 0, 10);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000);
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);
            
            // Point lights
            const pointLight1 = new THREE.PointLight(0x00ffff, 1, 100);
            pointLight1.position.set(10, 10, 10);
            scene.add(pointLight1);
            
            const pointLight2 = new THREE.PointLight(0xff00ff, 1, 100);
            pointLight2.position.set(-10, -10, 10);
            scene.add(pointLight2);
            
            createQubits();
            animate();
        }

        function createQubits() {
            // Clear existing qubits
            qubits.forEach(q => scene.remove(q.mesh));
            connections.forEach(c => scene.remove(c));
            qubits = [];
            connections = [];
            
            const radius = 3;
            
            for (let i = 0; i < vm.numQubits; i++) {
                const angle = (i / vm.numQubits) * Math.PI * 2;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                
                // Qubit sphere
                const geometry = new THREE.SphereGeometry(0.5, 32, 32);
                const material = new THREE.MeshPhongMaterial({
                    color: 0x00ffff,
                    emissive: 0x00ffff,
                    emissiveIntensity: 0.2,
                    transparent: true,
                    opacity: 0.8
                });
                
                const qubitMesh = new THREE.Mesh(geometry, material);
                qubitMesh.position.set(x, y, 0);
                scene.add(qubitMesh);
                
                // Bloch sphere axes
                const axesHelper = new THREE.AxesHelper(0.7);
                qubitMesh.add(axesHelper);
                
                // State vector
                const vectorGeometry = new THREE.ConeGeometry(0.1, 0.3, 8);
                const vectorMaterial = new THREE.MeshBasicMaterial({ color: 0xff00ff });
                const vectorMesh = new THREE.Mesh(vectorGeometry, vectorMaterial);
                vectorMesh.position.set(0, 0.3, 0);
                qubitMesh.add(vectorMesh);
                
                qubits.push({
                    mesh: qubitMesh,
                    vector: vectorMesh,
                    index: i,
                    basePosition: { x, y, z: 0 }
                });
            }
            
            // Create entanglement connections
            updateConnections();
        }

        function updateConnections() {
            // Remove old connections
            connections.forEach(c => scene.remove(c));
            connections = [];
            
            if (vm.isEntangled()) {
                // Create glowing connections between entangled qubits
                for (let i = 0; i < qubits.length - 1; i++) {
                    for (let j = i + 1; j < qubits.length; j++) {
                        const geometry = new THREE.BufferGeometry().setFromPoints([
                            qubits[i].mesh.position,
                            qubits[j].mesh.position
                        ]);
                        
                        const material = new THREE.LineBasicMaterial({
                            color: 0xff00ff,
                            linewidth: 2,
                            transparent: true,
                            opacity: 0.5
                        });
                        
                        const line = new THREE.Line(geometry, material);
                        scene.add(line);
                        connections.push(line);
                    }
                }
            }
        }

        function animate() {
            animationId = requestAnimationFrame(animate);
            
            // Rotate qubits based on their quantum state
            qubits.forEach((qubit, idx) => {
                // Calculate rotation based on quantum state
                const stateIndex = 1 << idx;
                const amplitude = vm.state[stateIndex] || { real: 0, imag: 0 };
                const phase = Math.atan2(amplitude.imag, amplitude.real);
                
                qubit.mesh.rotation.y += 0.01;
                qubit.mesh.rotation.z = phase;
                
                // Pulse effect for superposition
                const magnitude = vm.complexMagnitude(amplitude);
                const scale = 1 + Math.sin(Date.now() * 0.001) * 0.1 * magnitude;
                qubit.mesh.scale.set(scale, scale, scale);
                
                // Update color based on state
                const color = new THREE.Color();
                color.setHSL(phase / (Math.PI * 2), 1, 0.5);
                qubit.mesh.material.color = color;
                qubit.mesh.material.emissive = color;
            });
            
            // Animate connections
            connections.forEach(conn => {
                conn.material.opacity = 0.3 + Math.sin(Date.now() * 0.002) * 0.2;
            });
            
            // Camera orbit
            const time = Date.now() * 0.0005;
            camera.position.x = Math.cos(time) * 10;
            camera.position.z = Math.sin(time) * 10;
            camera.lookAt(0, 0, 0);
            
            renderer.render(scene, camera);
        }

        // UI Functions
        function initializeSystem() {
            const numQubits = parseInt(document.getElementById('qubitCount').value);
            vm = new QuantumVM(numQubits);
            createQubits();
            updateQubitSelector();
            updateDisplay();
        }

        function updateQubitSelector() {
            const selector = document.getElementById('qubitSelector');
            selector.innerHTML = '';
            
            for (let i = 0; i < vm.numQubits; i++) {
                const btn = document.createElement('button');
                btn.className = 'qubit-btn';
                btn.textContent = `Q${i}`;
                btn.onclick = () => selectQubit(i);
                if (i === vm.selectedQubit) btn.classList.add('selected');
                selector.appendChild(btn);
            }
        }

        function selectQubit(index) {
            vm.selectedQubit = index;
            updateQubitSelector();
        }

        function applyGate(gate) {
            if (['H', 'X', 'Y', 'Z', 'S', 'T'].includes(gate)) {
                vm.circuit.push({ gate, qubit: vm.selectedQubit });
            } else if (gate === 'CNOT' || gate === 'CZ') {
                const target = (vm.selectedQubit + 1) % vm.numQubits;
                vm.circuit.push({ gate, control: vm.selectedQubit, target });
            } else if (gate === 'SWAP') {
                const target = (vm.selectedQubit + 1) % vm.numQubits;
                vm.circuit.push({ gate, qubit1: vm.selectedQubit, qubit2: target });
            }
            
            updateCircuitDisplay();
        }

        function executeCircuit() {
            vm.initializeState();
            
            for (const op of vm.circuit) {
                if (['H', 'X', 'Y', 'Z', 'S', 'T'].includes(op.gate)) {
                    vm.applySingleQubitGate(op.gate, op.qubit);
                } else if (op.gate === 'CNOT') {
                    vm.applyCNOT(op.control, op.target);
                } else if (op.gate === 'CZ') {
                    vm.applyCZ(op.control, op.target);
                } else if (op.gate === 'SWAP') {
                    vm.applySWAP(op.qubit1, op.qubit2);
                }
            }
            
            updateDisplay();
            updateConnections();
        }

        function measureAll() {
            const result = vm.measureAll();
            const binary = result.toString(2).padStart(vm.numQubits, '0');
            
            document.getElementById('measurementResult').style.display = 'block';
            document.getElementById('measurementValue').textContent = `|${binary}‚ü©`;
            
            updateDisplay();
            updateConnections();
        }

        function clearCircuit() {
            vm.circuit = [];
            vm.initializeState();
            updateCircuitDisplay();
            updateDisplay();
            updateConnections();
            document.getElementById('measurementResult').style.display = 'none';
        }

        function createGHZ() {
            vm.circuit = [];
            vm.circuit.push({ gate: 'H', qubit: 0 });
            for (let i = 1; i < vm.numQubits; i++) {
                vm.circuit.push({ gate: 'CNOT', control: 0, target: i });
            }
            executeCircuit();
            updateCircuitDisplay();
        }

        function createBellPair() {
            if (vm.numQubits < 2) {
                alert('Need at least 2 qubits for Bell pair');
                return;
            }
            vm.circuit = [];
            vm.circuit.push({ gate: 'H', qubit: 0 });
            vm.circuit.push({ gate: 'CNOT', control: 0, target: 1 });
            executeCircuit();
            updateCircuitDisplay();
        }

        function updateCircuitDisplay() {
            const display = document.getElementById('circuitDisplay');
            if (vm.circuit.length === 0) {
                display.textContent = 'Circuit: Empty';
            } else {
                const circuitStr = vm.circuit.map(op => {
                    if (op.control !== undefined) {
                        return `${op.gate}(${op.control},${op.target})`;
                    } else if (op.qubit1 !== undefined) {
                        return `${op.gate}(${op.qubit1},${op.qubit2})`;
                    } else {
                        return `${op.gate}[${op.qubit}]`;
                    }
                }).join(' ‚Üí ');
                display.textContent = `Circuit: ${circuitStr}`;
            }
        }

        function updateDisplay() {
            // Update state display
            document.getElementById('stateDisplay').innerHTML = 
                `|œà‚ü© = ${vm.getStateString()}`;
            
            // Update vector display
            const vectorDisplay = document.getElementById('vectorDisplay');
            let vectorHTML = '';
            vm.state.forEach((amp, idx) => {
                const magnitude = vm.complexMagnitude(amp);
                if (magnitude > 0.001) {
                    const binary = idx.toString(2).padStart(vm.numQubits, '0');
                    vectorHTML += `|${binary}‚ü©: <span class="amplitude">${magnitude.toFixed(3)}</span><br>`;
                }
            });
            vectorDisplay.innerHTML = vectorHTML || 'All amplitudes near zero';
            
            // Update probability display
            const probDisplay = document.getElementById('probabilityDisplay');
            let probHTML = '';
            vm.state.forEach((amp, idx) => {
                const prob = Math.pow(vm.complexMagnitude(amp), 2);
                if (prob > 0.001) {
                    const binary = idx.toString(2).padStart(vm.numQubits, '0');
                    probHTML += `|${binary}‚ü©: <span class="probability">${(prob * 100).toFixed(1)}%</span><br>`;
                }
            });
            probDisplay.innerHTML = probHTML || 'No significant probabilities';
            
            // Update entanglement display
            const entDisplay = document.getElementById('entanglementDisplay');
            if (vm.isEntangled()) {
                entDisplay.innerHTML = '<span style="color: #f0f;">‚úì Qubits are entangled</span>';
            } else {
                entDisplay.innerHTML = '<span style="color: #888;">No entanglement detected</span>';
            }
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Initialize everything
        initThreeJS();
        updateQubitSelector();
        updateDisplay();
    </script>
</body>
</html>