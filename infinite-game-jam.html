<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infinite Game Jam: Self-Evolving Game</title>
    <meta name="description" content="Watch a game evolve itself through AI playtesting - autonomous game design through computational iteration">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --bg-dark: #0a0a0f;
            --bg-panel: #12121a;
            --accent: #00ff88;
            --accent-dim: #00aa55;
            --warning: #ffaa00;
            --danger: #ff4444;
            --text: #e0e0e0;
            --text-dim: #888;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: var(--bg-dark);
            color: var(--text);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            display: grid;
            grid-template-columns: 1fr 380px;
            grid-template-rows: auto 1fr auto;
            height: 100vh;
            gap: 1px;
            background: #333;
        }

        header {
            grid-column: 1 / -1;
            background: var(--bg-panel);
            padding: 1rem 2rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid #333;
        }

        h1 {
            font-size: 1.5rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        h1 span { font-size: 1.75rem; }

        .generation-badge {
            background: linear-gradient(135deg, var(--accent), #00ccff);
            color: #000;
            padding: 0.4rem 1rem;
            border-radius: 2rem;
            font-weight: 700;
            font-size: 0.9rem;
        }

        .controls {
            display: flex;
            gap: 0.75rem;
        }

        button {
            background: var(--bg-dark);
            border: 1px solid #444;
            color: var(--text);
            padding: 0.6rem 1.25rem;
            border-radius: 0.5rem;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
        }

        button:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        button.primary {
            background: var(--accent);
            color: #000;
            border-color: var(--accent);
            font-weight: 600;
        }

        button.primary:hover {
            background: #00ffaa;
            transform: scale(1.02);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .game-area {
            background: var(--bg-panel);
            display: flex;
            flex-direction: column;
            position: relative;
        }

        #gameCanvas {
            width: 100%;
            flex: 1;
            background: #000;
        }

        .game-hud {
            position: absolute;
            top: 1rem;
            left: 1rem;
            right: 1rem;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
        }

        .hud-stat {
            background: rgba(0,0,0,0.7);
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-family: monospace;
        }

        .sidebar {
            background: var(--bg-panel);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .panel {
            padding: 1rem;
            border-bottom: 1px solid #333;
        }

        .panel h3 {
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-dim);
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
        }

        .metric {
            background: var(--bg-dark);
            padding: 0.75rem;
            border-radius: 0.5rem;
            text-align: center;
        }

        .metric-value {
            font-size: 1.5rem;
            font-weight: 700;
            font-family: monospace;
        }

        .metric-label {
            font-size: 0.7rem;
            color: var(--text-dim);
            text-transform: uppercase;
        }

        .metric.good .metric-value { color: var(--accent); }
        .metric.warning .metric-value { color: var(--warning); }
        .metric.bad .metric-value { color: var(--danger); }

        .evolution-log {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
        }

        .log-entry {
            background: var(--bg-dark);
            padding: 0.75rem;
            border-radius: 0.5rem;
            margin-bottom: 0.5rem;
            font-size: 0.85rem;
            border-left: 3px solid var(--accent);
        }

        .log-entry.mutation {
            border-left-color: #ff00ff;
        }

        .log-entry.analysis {
            border-left-color: #00aaff;
        }

        .log-entry .gen {
            color: var(--accent);
            font-weight: 600;
        }

        .log-entry .time {
            color: var(--text-dim);
            font-size: 0.75rem;
            float: right;
        }

        .progress-bar {
            height: 4px;
            background: var(--bg-dark);
            border-radius: 2px;
            overflow: hidden;
            margin-top: 0.5rem;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent), #00ccff);
            transition: width 0.3s;
        }

        .gene-display {
            display: grid;
            gap: 0.4rem;
            font-family: monospace;
            font-size: 0.8rem;
        }

        .gene {
            display: flex;
            justify-content: space-between;
            background: var(--bg-dark);
            padding: 0.4rem 0.6rem;
            border-radius: 0.25rem;
        }

        .gene-name { color: var(--text-dim); }
        .gene-value { color: var(--accent); }
        .gene-change { font-size: 0.7rem; margin-left: 0.5rem; }
        .gene-change.up { color: var(--accent); }
        .gene-change.down { color: var(--danger); }

        footer {
            grid-column: 1 / -1;
            background: var(--bg-panel);
            padding: 0.75rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.85rem;
            color: var(--text-dim);
            border-top: 1px solid #333;
        }

        .fitness-bar {
            display: flex;
            align-items: center;
            gap: 1rem;
            flex: 1;
            max-width: 400px;
        }

        .fitness-track {
            flex: 1;
            height: 8px;
            background: var(--bg-dark);
            border-radius: 4px;
            overflow: hidden;
        }

        .fitness-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--danger), var(--warning), var(--accent));
            transition: width 0.5s;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .evolving {
            animation: pulse 1s infinite;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .speed-control input {
            width: 100px;
        }

        /* Death heatmap overlay */
        .heatmap-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            opacity: 0.3;
        }

        .evolution-graph {
            background: var(--bg-dark);
            border-radius: 0.5rem;
            padding: 0.5rem;
            margin-top: 0.5rem;
        }

        #fitnessGraph {
            width: 100%;
            height: 80px;
            display: block;
        }

        .best-dna-banner {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            border: 1px solid var(--accent);
            border-radius: 0.5rem;
            padding: 0.75rem;
            margin-top: 0.5rem;
            display: none;
        }

        .best-dna-banner.show {
            display: block;
        }

        .best-dna-banner h4 {
            color: var(--accent);
            font-size: 0.8rem;
            margin-bottom: 0.5rem;
        }

        .best-score {
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--accent);
        }

        .load-best-btn {
            margin-top: 0.5rem;
            width: 100%;
            background: var(--accent-dim);
            border: none;
        }

        .death-chart {
            display: flex;
            gap: 0.25rem;
            margin-top: 0.5rem;
        }

        .death-bar {
            flex: 1;
            height: 20px;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.6rem;
            color: #fff;
        }

        .death-bar.fall { background: #3498db; }
        .death-bar.obstacle { background: #e74c3c; }
        .death-bar.leftEdge { background: #9b59b6; }
        .death-bar.survived { background: var(--accent); }

        /* ============================================
           CYCLE 1: 8-STRATEGY CONSENSUS FEATURES
           ============================================ */

        /* FEATURE 1: Virtual Touch Controls */
        .touch-controls {
            position: absolute;
            bottom: 20px;
            left: 0;
            right: 0;
            display: none;
            justify-content: space-between;
            padding: 0 20px;
            pointer-events: none;
            z-index: 100;
        }

        .touch-controls.active {
            display: flex;
        }

        .touch-dpad {
            display: grid;
            grid-template-columns: repeat(3, 60px);
            grid-template-rows: repeat(2, 60px);
            gap: 5px;
            pointer-events: auto;
        }

        .touch-btn {
            width: 60px;
            height: 60px;
            border-radius: 12px;
            background: rgba(0, 255, 136, 0.3);
            border: 2px solid var(--accent);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            color: var(--accent);
            user-select: none;
            -webkit-user-select: none;
            touch-action: manipulation;
            transition: transform 0.1s, background 0.1s;
        }

        .touch-btn:active, .touch-btn.pressed {
            transform: scale(0.9);
            background: rgba(0, 255, 136, 0.6);
        }

        .touch-btn.left { grid-column: 1; grid-row: 2; }
        .touch-btn.right { grid-column: 3; grid-row: 2; }
        .touch-btn.spacer { visibility: hidden; grid-column: 2; }

        .touch-jump {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: rgba(0, 255, 136, 0.3);
            border: 3px solid var(--accent);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            color: var(--accent);
            pointer-events: auto;
            user-select: none;
            -webkit-user-select: none;
            touch-action: manipulation;
            align-self: flex-end;
        }

        .touch-jump:active, .touch-jump.pressed {
            transform: scale(0.9);
            background: rgba(0, 255, 136, 0.6);
        }

        /* FEATURE 2: Momentum/Combo HUD */
        .momentum-hud {
            position: absolute;
            top: 50px;
            left: 1rem;
            background: rgba(0,0,0,0.8);
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-family: monospace;
            pointer-events: none;
            display: none;
        }

        .momentum-hud.active {
            display: block;
        }

        .momentum-bar {
            width: 120px;
            height: 8px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 4px;
        }

        .momentum-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent), #00ccff, #ff00ff);
            transition: width 0.2s;
        }

        .combo-display {
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--warning);
            text-shadow: 0 0 10px var(--warning);
        }

        .combo-display.high {
            color: #ff00ff;
            text-shadow: 0 0 15px #ff00ff;
            animation: comboPulse 0.3s ease-in-out;
        }

        @keyframes comboPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }

        /* CYCLE 4: Jump Availability Indicator */
        .jump-indicator {
            position: absolute;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            gap: 8px;
            pointer-events: none;
            z-index: 100;
        }

        .jump-indicator.active {
            display: flex;
        }

        .jump-pip {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: rgba(0, 255, 136, 0.3);
            border: 2px solid var(--accent);
            transition: all 0.15s ease-out;
        }

        .jump-pip.available {
            background: var(--accent);
            box-shadow: 0 0 10px var(--accent);
        }

        .jump-pip.used {
            background: rgba(100, 100, 100, 0.3);
            border-color: #555;
            transform: scale(0.8);
        }

        /* Responsive Mobile Layout */
        @media (max-width: 768px) {
            .container {
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr auto auto;
            }

            header {
                padding: 0.5rem 1rem;
                flex-wrap: wrap;
                gap: 0.5rem;
            }

            h1 { font-size: 1.1rem; }

            .controls {
                flex-wrap: wrap;
                justify-content: center;
            }

            button {
                padding: 0.5rem 0.75rem;
                font-size: 0.8rem;
                min-height: 44px;
            }

            .sidebar {
                max-height: 35vh;
                order: 4;
            }

            .speed-control {
                display: none;
            }

            .generation-badge {
                font-size: 0.75rem;
                padding: 0.3rem 0.75rem;
            }
        }

        /* Reduced Motion Support */
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* Focus indicators for accessibility */
        button:focus-visible {
            outline: 3px solid var(--accent);
            outline-offset: 2px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1><span>üéÆ</span> Infinite Game Jam</h1>
            <div class="generation-badge" id="genBadge">Generation 0</div>
            <div class="controls">
                <button id="playHuman">Play Yourself</button>
                <button id="evolveOnce">Evolve Once</button>
                <button id="autoEvolve" class="primary">Auto-Evolve</button>
                <div class="speed-control">
                    <label>Speed:</label>
                    <input type="range" id="speedSlider" min="1" max="100" value="50">
                </div>
            </div>
        </header>

        <div class="game-area">
            <canvas id="gameCanvas"></canvas>
            <div class="game-hud">
                <div class="hud-stat" id="hudScore">Score: 0</div>
                <div class="hud-stat" id="hudStatus">AI Playtesting...</div>
            </div>
            <!-- CYCLE 1: Momentum/Combo HUD -->
            <div class="momentum-hud" id="momentumHud">
                <div class="combo-display" id="comboDisplay">x1</div>
                <div class="momentum-bar">
                    <div class="momentum-fill" id="momentumFill" style="width: 0%"></div>
                </div>
            </div>
            <!-- CYCLE 4: Jump Availability Indicator -->
            <div class="jump-indicator" id="jumpIndicator">
                <div class="jump-pip" id="jumpPip1"></div>
                <div class="jump-pip" id="jumpPip2"></div>
            </div>
            <!-- CYCLE 1: Virtual Touch Controls -->
            <div class="touch-controls" id="touchControls">
                <div class="touch-dpad">
                    <div class="touch-btn spacer"></div>
                    <div class="touch-btn spacer"></div>
                    <div class="touch-btn spacer"></div>
                    <div class="touch-btn left" id="touchLeft">‚óÄ</div>
                    <div class="touch-btn spacer"></div>
                    <div class="touch-btn right" id="touchRight">‚ñ∂</div>
                </div>
                <div class="touch-jump" id="touchJump">JUMP</div>
            </div>
        </div>

        <div class="sidebar">
            <div class="panel">
                <h3>üìä Current Metrics</h3>
                <div class="metrics-grid">
                    <div class="metric" id="metricSurvival">
                        <div class="metric-value">0%</div>
                        <div class="metric-label">Survival Rate</div>
                    </div>
                    <div class="metric" id="metricAvgScore">
                        <div class="metric-value">0</div>
                        <div class="metric-label">Avg Score</div>
                    </div>
                    <div class="metric" id="metricFun">
                        <div class="metric-value">0</div>
                        <div class="metric-label">Fun Score</div>
                    </div>
                    <div class="metric" id="metricDifficulty">
                        <div class="metric-value">?</div>
                        <div class="metric-label">Difficulty</div>
                    </div>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="testProgress" style="width: 0%"></div>
                </div>
                <div class="death-chart" id="deathChart"></div>
                <div class="evolution-graph">
                    <canvas id="fitnessGraph"></canvas>
                </div>
                <div class="best-dna-banner" id="bestDNABanner">
                    <h4>üèÜ Best Generation</h4>
                    <span>Gen <span id="bestGen">0</span>: </span>
                    <span class="best-score" id="bestScore">0%</span> fun
                    <button class="load-best-btn" id="loadBest">Load Best DNA</button>
                </div>
            </div>

            <div class="panel">
                <h3>üß¨ Game DNA</h3>
                <div class="gene-display" id="geneDisplay">
                    <!-- Filled dynamically -->
                </div>
            </div>

            <div class="panel evolution-log" id="evolutionLog">
                <h3>üìú Evolution Log</h3>
                <!-- Log entries appear here -->
            </div>
        </div>

        <footer>
            <div class="fitness-bar">
                <span>Fitness:</span>
                <div class="fitness-track">
                    <div class="fitness-fill" id="fitnessFill" style="width: 10%"></div>
                </div>
                <span id="fitnessValue">10%</span>
            </div>
            <div id="statusText">Ready to evolve</div>
        </footer>
    </div>

    <script>
        // ============================================
        // INFINITE GAME JAM: SELF-EVOLVING GAME ENGINE
        // ============================================

        // Game DNA - all tweakable parameters that define the game
        let gameDNA = {
            // Player physics
            playerSpeed: 5,
            jumpForce: 12,
            gravity: 0.5,
            airControl: 0.8,

            // Platform generation
            platformWidth: 100,
            platformGap: 150,
            platformVariance: 50,
            movingPlatformChance: 0.2,
            movingPlatformSpeed: 2,

            // Obstacles
            obstacleChance: 0.3,
            obstacleSpeed: 3,
            obstacleSize: 30,

            // Collectibles
            coinChance: 0.5,
            coinValue: 10,
            powerupChance: 0.1,

            // Difficulty scaling
            difficultyRamp: 0.001,
            maxDifficulty: 2.0,

            // World
            scrollSpeed: 3,
            worldWidth: 800,
            worldHeight: 600
        };

        // Evolution state
        let generation = 0;
        let isAutoEvolving = false;
        let evolutionSpeed = 50;
        let testResults = [];
        let evolutionHistory = [];
        let bestDNA = null;
        let bestFunScore = 0;
        let bestGeneration = 0;
        let fitnessHistory = [];

        // CYCLE 5: Personal Best Tracking
        let personalBests = {
            score: 0,
            distance: 0,
            combo: 0
        };

        function loadPersonalBests() {
            try {
                const stored = localStorage.getItem('infiniteGameJam_personalBests');
                if (stored) {
                    personalBests = JSON.parse(stored);
                }
            } catch (e) {
                console.warn('Could not load personal bests:', e);
            }
        }

        function savePersonalBests() {
            try {
                localStorage.setItem('infiniteGameJam_personalBests', JSON.stringify(personalBests));
            } catch (e) {
                console.warn('Could not save personal bests:', e);
            }
        }
        loadPersonalBests(); // Load on startup

        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            const rect = canvas.parentElement.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            gameDNA.worldWidth = canvas.width;
            gameDNA.worldHeight = canvas.height;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // ============================================
        // CYCLE 1: PARTICLE POOL (Object Pooling)
        // ============================================
        class ParticlePool {
            constructor(maxSize = 200) {
                this.maxSize = maxSize;
                this.pool = [];
                this.active = [];

                // Pre-allocate particles
                for (let i = 0; i < maxSize; i++) {
                    this.pool.push({
                        x: 0, y: 0,
                        vx: 0, vy: 0,
                        color: '#fff',
                        life: 0,
                        maxLife: 0,
                        active: false
                    });
                }
            }

            acquire(x, y, vx, vy, color, life) {
                let particle;
                if (this.pool.length > 0) {
                    particle = this.pool.pop();
                } else if (this.active.length > 0) {
                    // Recycle oldest active particle if pool empty
                    particle = this.active.shift();
                } else {
                    return null; // Should never happen with proper sizing
                }

                particle.x = x;
                particle.y = y;
                particle.vx = vx;
                particle.vy = vy;
                particle.color = color;
                particle.life = life;
                particle.maxLife = life;
                particle.active = true;
                this.active.push(particle);
                return particle;
            }

            update() {
                for (let i = this.active.length - 1; i >= 0; i--) {
                    const p = this.active[i];
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.2;
                    p.life--;

                    if (p.life <= 0) {
                        p.active = false;
                        this.pool.push(this.active.splice(i, 1)[0]);
                    }
                }
            }

            clear() {
                while (this.active.length > 0) {
                    const p = this.active.pop();
                    p.active = false;
                    this.pool.push(p);
                }
            }

            getActive() {
                return this.active;
            }
        }

        // Global particle pool (shared across game instances for efficiency)
        const particlePool = new ParticlePool(200);

        // ============================================
        // CYCLE 4: PROCEDURAL AUDIO SYSTEM
        // ============================================
        const Audio = {
            ctx: null,
            masterGain: null,
            enabled: true,

            init() {
                if (this.ctx) return;
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.25;
                this.masterGain.connect(this.ctx.destination);
            },

            resume() {
                if (this.ctx && this.ctx.state === 'suspended') this.ctx.resume();
            },

            playJump(isDouble = false) {
                if (!this.enabled || !this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.frequency.setValueAtTime(isDouble ? 280 : 200, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(isDouble ? 560 : 400, this.ctx.currentTime + 0.08);
                gain.gain.setValueAtTime(0.15, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.08);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.08);
            },

            playCoin(momentum = 1) {
                if (!this.enabled || !this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain);
                gain.connect(this.masterGain);
                const basePitch = 800 + momentum * 200;
                osc.frequency.setValueAtTime(basePitch, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(basePitch * 1.5, this.ctx.currentTime + 0.05);
                gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.05);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.05);
            },

            playDeath() {
                if (!this.enabled || !this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.frequency.setValueAtTime(300, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(60, this.ctx.currentTime + 0.2);
                gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.2);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.2);
            }
        };

        // ============================================
        // GAME ENGINE
        // ============================================

        class Game {
            constructor(dna, isAI = true) {
                this.dna = { ...dna };
                this.isAI = isAI;
                this.reset();
            }

            reset() {
                this.player = {
                    x: 100,
                    y: this.dna.worldHeight / 2,
                    vx: 0,
                    vy: 0,
                    width: 30,
                    height: 40,
                    grounded: false,
                    jumpsLeft: 2
                };

                this.platforms = [];
                this.obstacles = [];
                this.coins = [];
                // CYCLE 1: Use particle pool instead of array
                particlePool.clear();

                this.score = 0;
                this.distance = 0;
                this.time = 0;
                this.alive = true;
                this.won = false;

                this.difficulty = 1;
                this.scrollOffset = 0;

                // Analytics
                this.deathLocation = null;
                this.coinsMissed = 0;
                this.coinsCollected = 0;
                this.jumpsUsed = 0;
                this.closeCallCount = 0;
                this.idleTime = 0;
                this.actionVariety = new Set();

                // CYCLE 1: Momentum/Combo System
                this.momentum = 1.0;        // Multiplier from 1.0 to 3.0
                this.combo = 0;             // Current combo count
                this.maxCombo = 0;          // Best combo this run
                this.lastPlatformTime = 0;  // For chain bonus tracking
                this.platformChain = 0;     // Consecutive platform landings

                // CYCLE 2: Physics Feel Improvements
                this.coyoteTimer = 0;       // Frames of grace after leaving platform
                this.jumpBufferTimer = 0;   // Frames to remember jump input
                this.isJumpHeld = false;    // For variable jump height
                this.wasGrounded = false;   // Track ground state changes

                // CYCLE 2: Visual Juice
                this.shakeIntensity = 0;    // Screen shake on death
                this.floatingTexts = [];    // Floating score popups

                // CYCLE 3: Animation and Polish
                this.scaleX = 1.0;          // Squash/stretch horizontal
                this.scaleY = 1.0;          // Squash/stretch vertical
                this.targetScaleX = 1.0;
                this.targetScaleY = 1.0;
                this.afterimages = [];      // Position history for trail
                this.cameraX = 0;           // Smooth camera position
                this.cameraTargetX = 0;

                // CYCLE 4: Death flash effect
                this.deathFlash = 0;

                // CYCLE 5: Distance milestones
                this.lastMilestone = 0;
                this.milestones = [100, 250, 500, 1000, 2000, 5000];

                // Generate initial platforms
                this.generateInitialWorld();
            }

            generateInitialWorld() {
                let x = 50;
                for (let i = 0; i < 20; i++) {
                    this.addPlatform(x);
                    x += this.dna.platformGap + (Math.random() - 0.5) * this.dna.platformVariance;
                }
            }

            addPlatform(x) {
                const isMoving = Math.random() < this.dna.movingPlatformChance * this.difficulty;
                const platform = {
                    x: x,
                    y: 100 + Math.random() * (this.dna.worldHeight - 250),
                    width: this.dna.platformWidth * (0.7 + Math.random() * 0.6),
                    height: 20,
                    isMoving: isMoving,
                    moveDir: Math.random() > 0.5 ? 1 : -1,
                    moveRange: 50 + Math.random() * 50,
                    baseY: 0
                };
                platform.baseY = platform.y;
                this.platforms.push(platform);

                // Maybe add obstacle
                if (Math.random() < this.dna.obstacleChance * this.difficulty && this.platforms.length > 3) {
                    this.obstacles.push({
                        x: x + platform.width / 2,
                        y: platform.y - this.dna.obstacleSize - 10,
                        size: this.dna.obstacleSize,
                        vx: (Math.random() > 0.5 ? 1 : -1) * this.dna.obstacleSpeed
                    });
                }

                // Maybe add coin
                if (Math.random() < this.dna.coinChance) {
                    this.coins.push({
                        x: x + Math.random() * platform.width,
                        y: platform.y - 40 - Math.random() * 60,
                        collected: false
                    });
                }
            }

            update(input) {
                if (!this.alive) return;

                this.time++;
                const dt = 1;

                // Apply difficulty scaling
                this.difficulty = Math.min(
                    this.dna.maxDifficulty,
                    1 + this.distance * this.dna.difficultyRamp
                );

                // Player input
                if (input.left) {
                    this.player.vx -= this.dna.playerSpeed * (this.player.grounded ? 1 : this.dna.airControl);
                    this.actionVariety.add('left');
                }
                if (input.right) {
                    this.player.vx += this.dna.playerSpeed * (this.player.grounded ? 1 : this.dna.airControl);
                    this.actionVariety.add('right');
                }

                // CYCLE 2: Coyote Time - grace frames after leaving platform
                if (this.player.grounded) {
                    this.coyoteTimer = 8; // 8 frames of grace
                } else if (this.coyoteTimer > 0) {
                    this.coyoteTimer--;
                }

                // CYCLE 2: Jump Buffering - remember jump input
                if (input.jump) {
                    this.jumpBufferTimer = 8; // Remember for 8 frames
                    this.isJumpHeld = true;
                } else {
                    this.isJumpHeld = false;
                }
                if (this.jumpBufferTimer > 0) this.jumpBufferTimer--;

                // CYCLE 2: Enhanced Jump with Coyote Time + Buffer
                const canJump = (this.coyoteTimer > 0 || this.player.jumpsLeft > 0);
                const wantsJump = (input.jump || this.jumpBufferTimer > 0);

                if (wantsJump && canJump && this.player.vy >= 0) {
                    const isDoubleJump = this.player.jumpsLeft < 2 && !this.player.grounded;
                    this.player.vy = -this.dna.jumpForce;
                    this.player.jumpsLeft = Math.max(0, this.player.jumpsLeft - 1);
                    this.player.grounded = false;
                    this.coyoteTimer = 0;
                    this.jumpBufferTimer = 0;
                    this.jumpsUsed++;
                    this.actionVariety.add('jump');
                    // CYCLE 3: Stretch on jump
                    this.targetScaleX = 0.75;
                    this.targetScaleY = 1.3;
                    // CYCLE 4: Jump sound
                    if (!this.isAI) Audio.playJump(isDoubleJump);
                }

                // CYCLE 2: Variable Jump Height - cut jump when button released
                if (!this.isJumpHeld && this.player.vy < -this.dna.jumpForce * 0.3) {
                    this.player.vy *= 0.5; // Cut jump height in half
                }

                // Physics
                this.player.vy += this.dna.gravity;
                this.player.vx *= 0.9; // Friction

                this.player.x += this.player.vx;
                this.player.y += this.player.vy;

                // Platform collision
                this.player.grounded = false;
                for (const plat of this.platforms) {
                    // Update moving platforms
                    if (plat.isMoving) {
                        plat.y = plat.baseY + Math.sin(this.time * 0.02 * this.dna.movingPlatformSpeed) * plat.moveRange;
                    }

                    if (this.collides(this.player, plat) && this.player.vy >= 0) {
                        if (this.player.y + this.player.height - this.player.vy <= plat.y + 10) {
                            // CYCLE 1: Platform chain bonus
                            if (!this.player.grounded) {
                                this.platformChain++;
                                const timeSinceLast = this.time - this.lastPlatformTime;
                                // Quick landing = bigger bonus
                                if (timeSinceLast < 60 && this.platformChain > 1) {
                                    const chainBonus = this.platformChain * 5 * (plat.isMoving ? 2 : 1);
                                    const earnedBonus = Math.round(chainBonus * this.momentum);
                                    this.score += earnedBonus;
                                    this.combo++;
                                    this.maxCombo = Math.max(this.maxCombo, this.combo);
                                    this.momentum = Math.min(3.0, this.momentum + 0.1);
                                    // CYCLE 2: Floating chain bonus text
                                    this.spawnFloatingText(this.player.x, this.player.y - 30, `CHAIN x${this.platformChain}!`, '#00ff88');
                                }
                                this.lastPlatformTime = this.time;
                            }

                            this.player.y = plat.y - this.player.height;
                            this.player.vy = 0;
                            this.player.grounded = true;
                            this.player.jumpsLeft = 2;
                            // CYCLE 3: Squash on landing
                            if (!this.wasGrounded) {
                                this.targetScaleX = 1.35;
                                this.targetScaleY = 0.65;
                            }
                        }
                    }
                }

                // Obstacle collision
                for (const obs of this.obstacles) {
                    obs.x += obs.vx;

                    // Bounce off screen edges
                    if (obs.x < this.scrollOffset || obs.x > this.scrollOffset + this.dna.worldWidth) {
                        obs.vx *= -1;
                    }

                    const dist = Math.hypot(
                        this.player.x + this.player.width/2 - obs.x,
                        this.player.y + this.player.height/2 - obs.y
                    );

                    if (dist < obs.size/2 + 15) {
                        this.die('obstacle');
                    } else if (dist < obs.size/2 + 40) {
                        this.closeCallCount++;
                        // CYCLE 1: Close call momentum boost
                        this.momentum = Math.min(3.0, this.momentum + 0.05);
                        this.combo++;
                        this.maxCombo = Math.max(this.maxCombo, this.combo);
                    }
                }

                // Coin collection with momentum multiplier
                for (const coin of this.coins) {
                    if (coin.collected) continue;
                    const dist = Math.hypot(
                        this.player.x + this.player.width/2 - coin.x,
                        this.player.y + this.player.height/2 - coin.y
                    );
                    if (dist < 25) {
                        coin.collected = true;
                        // CYCLE 1: Score multiplied by momentum
                        const coinScore = Math.round(this.dna.coinValue * this.momentum);
                        this.score += coinScore;
                        this.coinsCollected++;
                        this.combo++;
                        this.maxCombo = Math.max(this.maxCombo, this.combo);
                        this.momentum = Math.min(3.0, this.momentum + 0.02);
                        this.spawnParticles(coin.x, coin.y, '#ffdd00', 5);
                        // CYCLE 2: Floating score text
                        this.spawnFloatingText(coin.x, coin.y - 20, `+${coinScore}`, '#ffcc00');
                        // CYCLE 4: Coin sound (pitch increases with momentum)
                        if (!this.isAI) Audio.playCoin(this.momentum);
                    }
                }

                // World scrolling
                const targetScroll = this.player.x - 200;
                if (targetScroll > this.scrollOffset) {
                    this.scrollOffset = targetScroll;
                    this.distance = this.scrollOffset;

                    // CYCLE 5: Distance milestone callouts
                    for (const milestone of this.milestones) {
                        if (this.distance >= milestone && this.lastMilestone < milestone) {
                            this.lastMilestone = milestone;
                            this.spawnFloatingText(
                                this.player.x,
                                this.player.y - 60,
                                `${milestone}m!`,
                                milestone >= 1000 ? '#ff00ff' : '#00ffff'
                            );
                            if (!this.isAI) Audio.playCoin(2.5); // High-pitch milestone sound
                            this.shakeIntensity = 5; // Small celebration shake
                        }
                    }

                    // Generate new platforms ahead
                    const lastPlatX = Math.max(...this.platforms.map(p => p.x));
                    if (lastPlatX < this.scrollOffset + this.dna.worldWidth + 200) {
                        this.addPlatform(lastPlatX + this.dna.platformGap + (Math.random() - 0.5) * this.dna.platformVariance);
                    }

                    // Clean up old platforms
                    this.platforms = this.platforms.filter(p => p.x + p.width > this.scrollOffset - 100);
                    this.obstacles = this.obstacles.filter(o => o.x > this.scrollOffset - 100);

                    // Track missed coins
                    const oldCoins = this.coins.length;
                    this.coins = this.coins.filter(c => c.x > this.scrollOffset - 50);
                    this.coinsMissed += oldCoins - this.coins.length - this.coins.filter(c => c.collected).length;
                }

                // Fall death
                if (this.player.y > this.dna.worldHeight + 50) {
                    this.die('fall');
                }

                // Screen edge death
                if (this.player.x < this.scrollOffset - 50) {
                    this.die('leftEdge');
                }

                // CYCLE 1: Update particles via pool (more efficient)
                particlePool.update();

                // Track idle time
                if (!input.left && !input.right && !input.jump) {
                    this.idleTime++;
                    // CYCLE 1: Momentum decay when idle
                    this.momentum = Math.max(1.0, this.momentum - 0.01);
                    if (this.time - this.lastPlatformTime > 120) {
                        this.combo = 0; // Reset combo after 2 seconds of no chains
                        this.platformChain = 0;
                    }
                } else if (input.right) {
                    // CYCLE 1: Moving forward builds momentum slightly
                    this.momentum = Math.min(3.0, this.momentum + 0.001);
                } else if (input.left) {
                    // CYCLE 1: Moving backward decays momentum
                    this.momentum = Math.max(1.0, this.momentum - 0.005);
                }

                // CYCLE 3: Squash/Stretch interpolation
                this.scaleX += (this.targetScaleX - this.scaleX) * 0.2;
                this.scaleY += (this.targetScaleY - this.scaleY) * 0.2;
                this.targetScaleX += (1.0 - this.targetScaleX) * 0.15;
                this.targetScaleY += (1.0 - this.targetScaleY) * 0.15;

                // CYCLE 3: Afterimage trail (only when moving fast and high momentum)
                if (this.momentum > 1.3 && this.time % 3 === 0) {
                    this.afterimages.push({
                        x: this.player.x, y: this.player.y,
                        alpha: 0.4, scaleX: this.scaleX, scaleY: this.scaleY
                    });
                    if (this.afterimages.length > 8) this.afterimages.shift();
                }
                // Fade out afterimages
                for (let i = this.afterimages.length - 1; i >= 0; i--) {
                    this.afterimages[i].alpha -= 0.05;
                    if (this.afterimages[i].alpha <= 0) this.afterimages.splice(i, 1);
                }

                // CYCLE 3: Smooth camera following
                this.cameraTargetX = this.player.x - 200;
                if (this.cameraTargetX > this.cameraX) {
                    this.cameraX += (this.cameraTargetX - this.cameraX) * 0.08;
                }

                // Track grounded state for landing detection
                this.wasGrounded = this.player.grounded;
            }

            collides(a, b) {
                return a.x < b.x + b.width &&
                       a.x + a.width > b.x &&
                       a.y < b.y + b.height &&
                       a.y + a.height > b.y;
            }

            die(reason) {
                this.alive = false;
                this.deathLocation = {
                    x: this.player.x,
                    y: this.player.y,
                    reason: reason,
                    distance: this.distance
                };
                this.spawnParticles(this.player.x, this.player.y, '#ff4444', 15);
                // CYCLE 2: Screen shake on death
                this.shakeIntensity = 15;
                // CYCLE 4: Death sound
                if (!this.isAI) Audio.playDeath();
                // CYCLE 4: Death flash intensity
                this.deathFlash = 1.0;

                // CYCLE 5: Check personal bests (human players only)
                if (!this.isAI) {
                    let newBest = false;
                    if (this.score > personalBests.score) {
                        personalBests.score = this.score;
                        newBest = true;
                    }
                    if (this.distance > personalBests.distance) {
                        personalBests.distance = Math.round(this.distance);
                        newBest = true;
                    }
                    if (this.maxCombo > personalBests.combo) {
                        personalBests.combo = this.maxCombo;
                        newBest = true;
                    }
                    if (newBest) {
                        savePersonalBests();
                        this.spawnFloatingText(this.player.x, this.player.y - 80, 'NEW BEST!', '#ff00ff');
                    }
                }
            }

            // CYCLE 2: Spawn floating score text
            spawnFloatingText(x, y, text, color = '#ffcc00') {
                this.floatingTexts.push({
                    x, y, text, color,
                    vy: -2,
                    alpha: 1.0
                });
            }

            spawnParticles(x, y, color, count) {
                // CYCLE 1: Use particle pool for efficiency
                for (let i = 0; i < count; i++) {
                    particlePool.acquire(
                        x, y,
                        (Math.random() - 0.5) * 8,
                        (Math.random() - 1) * 8,
                        color,
                        30 + Math.random() * 20
                    );
                }
            }

            render() {
                ctx.fillStyle = '#1a1a2e';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // CYCLE 2: Apply screen shake
                ctx.save();
                if (this.shakeIntensity > 0) {
                    const shakeX = (Math.random() - 0.5) * this.shakeIntensity;
                    const shakeY = (Math.random() - 0.5) * this.shakeIntensity;
                    ctx.translate(shakeX, shakeY);
                    this.shakeIntensity *= 0.85; // Decay shake
                    if (this.shakeIntensity < 0.5) this.shakeIntensity = 0;
                }

                // Parallax background
                const bgOffset = this.scrollOffset * 0.3;
                ctx.fillStyle = '#16213e';
                for (let i = 0; i < 20; i++) {
                    const x = ((i * 100 - bgOffset) % (canvas.width + 100)) - 50;
                    ctx.fillRect(x, 100 + (i % 5) * 80, 40, 300);
                }

                ctx.save();
                // CYCLE 3: Use smooth camera instead of hard scrollOffset
                ctx.translate(-this.cameraX, 0);

                // CYCLE 3: Draw afterimages first (behind player)
                for (const ghost of this.afterimages) {
                    ctx.globalAlpha = ghost.alpha * 0.5;
                    ctx.fillStyle = '#00ff88';
                    const gw = this.player.width * ghost.scaleX;
                    const gh = this.player.height * ghost.scaleY;
                    ctx.fillRect(
                        ghost.x + (this.player.width - gw) / 2,
                        ghost.y + (this.player.height - gh),
                        gw, gh
                    );
                }
                ctx.globalAlpha = 1;

                // Platforms
                for (const plat of this.platforms) {
                    ctx.fillStyle = plat.isMoving ? '#4a69bd' : '#6a89cc';
                    ctx.fillRect(plat.x, plat.y, plat.width, plat.height);
                    ctx.fillStyle = '#82ccdd';
                    ctx.fillRect(plat.x, plat.y, plat.width, 4);
                }

                // Coins
                for (const coin of this.coins) {
                    if (coin.collected) continue;
                    ctx.fillStyle = '#ffd700';
                    ctx.beginPath();
                    ctx.arc(coin.x, coin.y, 10, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#ffed4a';
                    ctx.beginPath();
                    ctx.arc(coin.x - 2, coin.y - 2, 4, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Obstacles - CYCLE 5: Orange with glow (distinct from death flash)
                for (const obs of this.obstacles) {
                    // Glow effect
                    ctx.shadowColor = '#ffaa00';
                    ctx.shadowBlur = 12;
                    ctx.fillStyle = '#ff9500';
                    ctx.beginPath();
                    ctx.moveTo(obs.x, obs.y - obs.size/2);
                    ctx.lineTo(obs.x + obs.size/2, obs.y + obs.size/2);
                    ctx.lineTo(obs.x - obs.size/2, obs.y + obs.size/2);
                    ctx.closePath();
                    ctx.fill();
                    // Border accent
                    ctx.strokeStyle = '#ffd700';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }

                // Player with CYCLE 3 Squash/Stretch
                if (this.alive) {
                    const pw = this.player.width * this.scaleX;
                    const ph = this.player.height * this.scaleY;
                    const px = this.player.x + (this.player.width - pw) / 2;
                    const py = this.player.y + (this.player.height - ph);

                    // Momentum-based color shift (green -> cyan at high momentum)
                    const colorMix = (this.momentum - 1) / 2; // 0 to 1
                    const r = Math.floor(0 + colorMix * 0);
                    const g = Math.floor(255 - colorMix * 55);
                    const b = Math.floor(136 + colorMix * 119);
                    ctx.fillStyle = `rgb(${r},${g},${b})`;

                    ctx.fillRect(px, py, pw, ph);
                    // Eyes (scaled)
                    ctx.fillStyle = '#000';
                    const eyeScale = Math.min(this.scaleX, this.scaleY);
                    ctx.fillRect(px + 8 * eyeScale, py + 10 * eyeScale, 5 * eyeScale, 5 * eyeScale);
                    ctx.fillRect(px + 18 * eyeScale, py + 10 * eyeScale, 5 * eyeScale, 5 * eyeScale);
                }

                // CYCLE 1: Particles from pool
                for (const p of particlePool.getActive()) {
                    ctx.fillStyle = p.color;
                    ctx.globalAlpha = p.life / p.maxLife;
                    ctx.fillRect(p.x - 3, p.y - 3, 6, 6);
                }
                ctx.globalAlpha = 1;

                // CYCLE 2: Floating score texts
                ctx.font = 'bold 16px system-ui';
                ctx.textAlign = 'center';
                for (let i = this.floatingTexts.length - 1; i >= 0; i--) {
                    const ft = this.floatingTexts[i];
                    ft.y += ft.vy;
                    ft.alpha -= 0.025;
                    if (ft.alpha <= 0) {
                        this.floatingTexts.splice(i, 1);
                        continue;
                    }
                    ctx.globalAlpha = ft.alpha;
                    ctx.fillStyle = ft.color;
                    ctx.fillText(ft.text, ft.x, ft.y);
                }
                ctx.globalAlpha = 1;

                ctx.restore(); // World transform

                // Death location marker (uses smooth camera)
                if (this.deathLocation) {
                    ctx.fillStyle = 'rgba(255,0,0,0.5)';
                    ctx.beginPath();
                    ctx.arc(
                        this.deathLocation.x - this.cameraX,
                        this.deathLocation.y,
                        20, 0, Math.PI * 2
                    );
                    ctx.fill();
                }

                // CYCLE 4: Death flash overlay
                if (this.deathFlash > 0) {
                    ctx.fillStyle = `rgba(255, 68, 68, ${this.deathFlash * 0.6})`;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    this.deathFlash *= 0.85; // Rapid fade out
                    if (this.deathFlash < 0.05) this.deathFlash = 0;
                }

                ctx.restore(); // CYCLE 2: Screen shake restore
            }

            getAnalytics() {
                return {
                    score: this.score,
                    distance: this.distance,
                    timeAlive: this.time,
                    deathReason: this.deathLocation?.reason || 'survived',
                    deathDistance: this.deathLocation?.distance || this.distance,
                    coinsCollected: this.coinsCollected,
                    coinsMissed: this.coinsMissed,
                    jumpsUsed: this.jumpsUsed,
                    closeCallCount: this.closeCallCount,
                    idleTimeRatio: this.idleTime / Math.max(1, this.time),
                    actionVariety: this.actionVariety.size
                };
            }
        }

        // ============================================
        // AI PLAYTESTER
        // ============================================

        class AIPlayer {
            constructor(skill = 0.7) {
                this.skill = skill; // 0-1, affects reaction time and decision quality
                this.reactionDelay = Math.floor((1 - skill) * 10);
                this.jumpBuffer = 0;
            }

            getInput(game) {
                const input = { left: false, right: false, jump: false };
                const player = game.player;

                // Find nearest platform ahead
                let targetPlatform = null;
                let minDist = Infinity;

                for (const plat of game.platforms) {
                    if (plat.x + plat.width > player.x && plat.x > player.x - 50) {
                        const dist = plat.x - player.x;
                        if (dist < minDist && dist > 0) {
                            minDist = dist;
                            targetPlatform = plat;
                        }
                    }
                }

                // Check for obstacles
                let dangerAhead = false;
                for (const obs of game.obstacles) {
                    if (obs.x > player.x && obs.x < player.x + 150) {
                        if (Math.abs(obs.y - player.y) < 60) {
                            dangerAhead = true;
                        }
                    }
                }

                // Decision making with skill factor
                const makeGoodDecision = Math.random() < this.skill;

                // Always try to move right (it's an endless runner)
                input.right = true;

                // Jump logic
                if (targetPlatform) {
                    const needsJump = targetPlatform.y < player.y - 20 ||
                                     !player.grounded ||
                                     minDist > 80;

                    if (needsJump && makeGoodDecision) {
                        // Predictive jump timing
                        const timeToReach = minDist / (game.dna.playerSpeed * 0.9);
                        const jumpTime = Math.sqrt(2 * Math.abs(targetPlatform.y - player.y) / game.dna.gravity);

                        if (timeToReach < jumpTime + 5 + this.reactionDelay) {
                            input.jump = player.grounded || player.jumpsLeft > 0;
                        }
                    }
                }

                // Dodge obstacles
                if (dangerAhead && makeGoodDecision) {
                    input.jump = true;
                }

                // Prevent falling off screen
                if (player.y > game.dna.worldHeight - 150 && !player.grounded) {
                    input.jump = player.jumpsLeft > 0;
                }

                // Random mistakes based on skill
                if (Math.random() > this.skill * 0.95) {
                    input.jump = !input.jump;
                }

                return input;
            }
        }

        // ============================================
        // EVOLUTION ENGINE
        // ============================================

        class EvolutionEngine {
            constructor() {
                this.populationSize = 50; // AI runs per generation
                this.mutationRate = 0.15;
                this.mutationStrength = 0.2;
                this.evolutionStrategy = 'balanced'; // balanced, conservative, aggressive, themed
                this.presets = new Map();
                this.loadPresets();
            }

            setStrategy(strategy, theme = null) {
                this.evolutionStrategy = strategy;
                this.currentTheme = theme;

                switch(strategy) {
                    case 'conservative':
                        this.mutationRate = 0.08;
                        this.mutationStrength = 0.1;
                        break;
                    case 'aggressive':
                        this.mutationRate = 0.25;
                        this.mutationStrength = 0.35;
                        break;
                    case 'themed':
                        this.mutationRate = 0.15;
                        this.mutationStrength = 0.25;
                        break;
                    default: // balanced
                        this.mutationRate = 0.15;
                        this.mutationStrength = 0.2;
                }
            }

            savePreset(name, dna, analysis) {
                this.presets.set(name, {
                    dna: {...dna},
                    analysis: {...analysis},
                    timestamp: new Date().toISOString(),
                    generation: generation
                });
                this.savePresetsToStorage();
            }

            savePresetsToStorage() {
                const presetsObj = {};
                this.presets.forEach((val, key) => {
                    presetsObj[key] = val;
                });
                localStorage.setItem('gameJamPresets', JSON.stringify(presetsObj));
            }

            loadPresets() {
                try {
                    const stored = localStorage.getItem('gameJamPresets');
                    if (stored) {
                        const presetsObj = JSON.parse(stored);
                        Object.entries(presetsObj).forEach(([key, val]) => {
                            this.presets.set(key, val);
                        });
                    }
                } catch(e) {
                    console.warn('Could not load presets:', e);
                }
            }

            loadPreset(name) {
                return this.presets.get(name);
            }

            async runGeneration(dna, onProgress) {
                const results = [];
                const aiSkills = [0.5, 0.6, 0.7, 0.8, 0.9]; // Different skill levels

                for (let i = 0; i < this.populationSize; i++) {
                    const skill = aiSkills[i % aiSkills.length];
                    const ai = new AIPlayer(skill);
                    const game = new Game(dna, true);

                    // Run simulation
                    const maxSteps = 3000;
                    for (let step = 0; step < maxSteps && game.alive; step++) {
                        const input = ai.getInput(game);
                        game.update(input);

                        // Visualize occasionally
                        if (i === 0 && step % 5 === 0) {
                            game.render();
                            await new Promise(r => setTimeout(r, Math.max(1, 50 - evolutionSpeed)));
                        }
                    }

                    results.push(game.getAnalytics());
                    onProgress((i + 1) / this.populationSize);
                }

                return this.analyzeResults(results);
            }

            analyzeResults(results) {
                const analysis = {
                    avgScore: 0,
                    avgDistance: 0,
                    avgTimeAlive: 0,
                    survivalRate: 0,
                    deathReasons: {},
                    avgCoinsCollected: 0,
                    avgCoinsMissed: 0,
                    avgCloseCall: 0,
                    avgIdleRatio: 0,
                    difficultyAssessment: 'balanced',
                    funScore: 0,
                    issues: [],
                    recommendations: []
                };

                // Aggregate stats
                for (const r of results) {
                    analysis.avgScore += r.score;
                    analysis.avgDistance += r.distance;
                    analysis.avgTimeAlive += r.timeAlive;
                    analysis.survivalRate += r.deathReason === 'survived' ? 1 : 0;
                    analysis.deathReasons[r.deathReason] = (analysis.deathReasons[r.deathReason] || 0) + 1;
                    analysis.avgCoinsCollected += r.coinsCollected;
                    analysis.avgCoinsMissed += r.coinsMissed;
                    analysis.avgCloseCall += r.closeCallCount;
                    analysis.avgIdleRatio += r.idleTimeRatio;
                }

                const n = results.length;
                analysis.avgScore /= n;
                analysis.avgDistance /= n;
                analysis.avgTimeAlive /= n;
                analysis.survivalRate /= n;
                analysis.avgCoinsCollected /= n;
                analysis.avgCoinsMissed /= n;
                analysis.avgCloseCall /= n;
                analysis.avgIdleRatio /= n;

                // Assess difficulty
                if (analysis.survivalRate < 0.1) {
                    analysis.difficultyAssessment = 'too hard';
                    analysis.issues.push('Game is too difficult - most players die quickly');
                } else if (analysis.survivalRate > 0.8) {
                    analysis.difficultyAssessment = 'too easy';
                    analysis.issues.push('Game is too easy - not enough challenge');
                } else if (analysis.avgDistance < 500) {
                    analysis.difficultyAssessment = 'frustrating start';
                    analysis.issues.push('Early game is too punishing');
                }

                // Assess engagement
                if (analysis.avgIdleRatio > 0.3) {
                    analysis.issues.push('Too much idle time - game feels slow');
                }
                if (analysis.avgCloseCall < 2) {
                    analysis.issues.push('Not enough exciting moments');
                }
                if (analysis.avgCoinsMissed > analysis.avgCoinsCollected * 2) {
                    analysis.issues.push('Coins are too hard to collect');
                }

                // Death analysis
                const topDeathReason = Object.entries(analysis.deathReasons)
                    .sort((a, b) => b[1] - a[1])[0];
                if (topDeathReason) {
                    if (topDeathReason[0] === 'fall' && topDeathReason[1] > n * 0.5) {
                        analysis.issues.push('Too many fall deaths - platforms too far apart');
                    }
                    if (topDeathReason[0] === 'obstacle' && topDeathReason[1] > n * 0.5) {
                        analysis.issues.push('Obstacles are too deadly');
                    }
                }

                // Calculate fun score (0-100)
                analysis.funScore = Math.min(100, Math.max(0,
                    50 +
                    (analysis.survivalRate - 0.3) * 50 +
                    Math.min(analysis.avgCloseCall, 10) * 3 -
                    analysis.avgIdleRatio * 30 +
                    Math.min(analysis.avgDistance / 100, 20) -
                    analysis.issues.length * 10
                ));

                // Generate recommendations
                this.generateRecommendations(analysis);

                return analysis;
            }

            generateRecommendations(analysis) {
                if (analysis.difficultyAssessment === 'too hard') {
                    analysis.recommendations.push({ gene: 'platformGap', direction: 'decrease', reason: 'reduce jump distance' });
                    analysis.recommendations.push({ gene: 'obstacleChance', direction: 'decrease', reason: 'fewer obstacles' });
                    analysis.recommendations.push({ gene: 'jumpForce', direction: 'increase', reason: 'higher jumps help' });
                }

                if (analysis.difficultyAssessment === 'too easy') {
                    analysis.recommendations.push({ gene: 'obstacleChance', direction: 'increase', reason: 'add challenge' });
                    analysis.recommendations.push({ gene: 'difficultyRamp', direction: 'increase', reason: 'faster scaling' });
                    analysis.recommendations.push({ gene: 'movingPlatformChance', direction: 'increase', reason: 'more dynamic' });
                }

                if (analysis.avgIdleRatio > 0.3) {
                    analysis.recommendations.push({ gene: 'scrollSpeed', direction: 'increase', reason: 'force action' });
                    analysis.recommendations.push({ gene: 'coinChance', direction: 'increase', reason: 'more goals' });
                }

                if (analysis.avgCloseCall < 2) {
                    analysis.recommendations.push({ gene: 'obstacleSpeed', direction: 'increase', reason: 'more tension' });
                    analysis.recommendations.push({ gene: 'obstacleSize', direction: 'decrease', reason: 'closer dodges' });
                }

                if (analysis.avgCoinsMissed > analysis.avgCoinsCollected * 2) {
                    analysis.recommendations.push({ gene: 'coinValue', direction: 'increase', reason: 'reward collection more' });
                }
            }

            mutate(dna, analysis) {
                const newDNA = { ...dna };
                const changes = [];

                // Apply themed mutations if in themed mode
                if (this.evolutionStrategy === 'themed' && this.currentTheme) {
                    this.applyThemedMutation(newDNA, changes);
                }

                // Apply recommendations
                const recApplyRate = this.evolutionStrategy === 'aggressive' ? 0.85 : 0.7;
                for (const rec of analysis.recommendations) {
                    if (Math.random() < recApplyRate) {
                        const oldVal = newDNA[rec.gene];
                        const change = oldVal * this.mutationStrength;

                        if (rec.direction === 'increase') {
                            newDNA[rec.gene] = oldVal + change;
                        } else {
                            newDNA[rec.gene] = Math.max(oldVal * 0.1, oldVal - change);
                        }

                        changes.push({
                            gene: rec.gene,
                            old: oldVal,
                            new: newDNA[rec.gene],
                            reason: rec.reason
                        });
                    }
                }

                // Random mutations for exploration
                const genes = Object.keys(dna).filter(k => typeof dna[k] === 'number');
                for (const gene of genes) {
                    if (Math.random() < this.mutationRate) {
                        const oldVal = newDNA[gene];
                        const mutation = (Math.random() - 0.5) * 2 * this.mutationStrength * oldVal;
                        newDNA[gene] = Math.max(0.1, oldVal + mutation);

                        if (!changes.find(c => c.gene === gene)) {
                            changes.push({
                                gene: gene,
                                old: oldVal,
                                new: newDNA[gene],
                                reason: 'random exploration'
                            });
                        }
                    }
                }

                return { dna: newDNA, changes };
            }

            applyThemedMutation(dna, changes) {
                const themes = {
                    'better-jumps': ['jumpForce', 'gravity', 'airControl'],
                    'better-flow': ['scrollSpeed', 'platformGap', 'platformVariance'],
                    'more-exciting': ['obstacleChance', 'obstacleSpeed', 'movingPlatformChance'],
                    'more-rewarding': ['coinChance', 'coinValue', 'powerupChance'],
                    'smoother-difficulty': ['difficultyRamp', 'maxDifficulty'],
                    'speedrun-mode': ['scrollSpeed', 'playerSpeed', 'jumpForce', 'gravity'],
                    'hardcore-mode': ['obstacleChance', 'obstacleSpeed', 'platformGap', 'difficultyRamp'],
                    'casual-mode': ['platformWidth', 'platformGap', 'jumpForce', 'coinChance']
                };

                const targetGenes = themes[this.currentTheme] || [];
                for (const gene of targetGenes) {
                    if (dna[gene] !== undefined) {
                        const oldVal = dna[gene];
                        const mutation = (Math.random() - 0.5) * 2 * this.mutationStrength * 1.5 * oldVal;
                        dna[gene] = Math.max(0.1, oldVal + mutation);

                        changes.push({
                            gene: gene,
                            old: oldVal,
                            new: dna[gene],
                            reason: `themed: ${this.currentTheme}`
                        });
                    }
                }
            }
        }

        // ============================================
        // UI UPDATES
        // ============================================

        const evolutionEngine = new EvolutionEngine();
        let currentGame = new Game(gameDNA, false);
        let humanPlaying = false;

        function updateGeneDisplay() {
            const display = document.getElementById('geneDisplay');
            const genes = [
                ['jumpForce', 'Jump Force'],
                ['gravity', 'Gravity'],
                ['platformGap', 'Platform Gap'],
                ['obstacleChance', 'Obstacle %'],
                ['coinChance', 'Coin %'],
                ['scrollSpeed', 'Scroll Speed'],
                ['difficultyRamp', 'Difficulty Ramp']
            ];

            display.innerHTML = genes.map(([key, label]) => `
                <div class="gene">
                    <span class="gene-name">${label}</span>
                    <span class="gene-value">${gameDNA[key].toFixed(2)}</span>
                </div>
            `).join('');
        }

        function updateMetrics(analysis) {
            const survivalEl = document.getElementById('metricSurvival');
            const survivalPct = (analysis.survivalRate * 100).toFixed(0);
            survivalEl.querySelector('.metric-value').textContent = survivalPct + '%';
            survivalEl.className = 'metric ' + (survivalPct > 50 ? 'good' : survivalPct > 20 ? 'warning' : 'bad');

            const scoreEl = document.getElementById('metricAvgScore');
            scoreEl.querySelector('.metric-value').textContent = Math.round(analysis.avgScore);

            const funEl = document.getElementById('metricFun');
            funEl.querySelector('.metric-value').textContent = Math.round(analysis.funScore);
            funEl.className = 'metric ' + (analysis.funScore > 60 ? 'good' : analysis.funScore > 40 ? 'warning' : 'bad');

            const diffEl = document.getElementById('metricDifficulty');
            diffEl.querySelector('.metric-value').textContent = analysis.difficultyAssessment.split(' ')[0];
            diffEl.className = 'metric ' + (analysis.difficultyAssessment === 'balanced' ? 'good' : 'warning');

            document.getElementById('fitnessFill').style.width = analysis.funScore + '%';
            document.getElementById('fitnessValue').textContent = Math.round(analysis.funScore) + '%';

            // Update death chart
            updateDeathChart(analysis.deathReasons);

            // Update fitness graph
            fitnessHistory.push(analysis.funScore);
            drawFitnessGraph();

            // Track best DNA
            if (analysis.funScore > bestFunScore) {
                bestFunScore = analysis.funScore;
                bestDNA = { ...gameDNA };
                bestGeneration = generation;
                document.getElementById('bestGen').textContent = generation;
                document.getElementById('bestScore').textContent = Math.round(analysis.funScore) + '%';
                document.getElementById('bestDNABanner').classList.add('show');
            }
        }

        function updateDeathChart(deathReasons) {
            const chart = document.getElementById('deathChart');
            const total = Object.values(deathReasons).reduce((a, b) => a + b, 0);
            if (total === 0) return;

            const colors = {
                fall: 'fall',
                obstacle: 'obstacle',
                leftEdge: 'leftEdge',
                survived: 'survived'
            };

            chart.innerHTML = Object.entries(deathReasons)
                .filter(([_, count]) => count > 0)
                .map(([reason, count]) => {
                    const pct = Math.round(count / total * 100);
                    return `<div class="death-bar ${colors[reason] || ''}" style="flex: ${count}">${pct}% ${reason}</div>`;
                }).join('');
        }

        function drawFitnessGraph() {
            const graphCanvas = document.getElementById('fitnessGraph');
            const gctx = graphCanvas.getContext('2d');
            const rect = graphCanvas.parentElement.getBoundingClientRect();
            graphCanvas.width = rect.width - 16;
            graphCanvas.height = 80;

            const w = graphCanvas.width;
            const h = graphCanvas.height;

            // Clear
            gctx.fillStyle = '#0a0a0f';
            gctx.fillRect(0, 0, w, h);

            // Grid lines
            gctx.strokeStyle = '#222';
            gctx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const y = (i / 4) * h;
                gctx.beginPath();
                gctx.moveTo(0, y);
                gctx.lineTo(w, y);
                gctx.stroke();
            }

            if (fitnessHistory.length < 2) return;

            // Draw fitness line
            const maxPoints = 50;
            const data = fitnessHistory.slice(-maxPoints);
            const step = w / (maxPoints - 1);

            gctx.beginPath();
            gctx.strokeStyle = '#00ff88';
            gctx.lineWidth = 2;

            data.forEach((val, i) => {
                const x = i * step;
                const y = h - (val / 100) * h;
                if (i === 0) gctx.moveTo(x, y);
                else gctx.lineTo(x, y);
            });
            gctx.stroke();

            // Fill under curve
            gctx.lineTo((data.length - 1) * step, h);
            gctx.lineTo(0, h);
            gctx.closePath();
            gctx.fillStyle = 'rgba(0, 255, 136, 0.1)';
            gctx.fill();

            // Current value marker
            const lastVal = data[data.length - 1];
            const lastX = (data.length - 1) * step;
            const lastY = h - (lastVal / 100) * h;
            gctx.fillStyle = '#00ff88';
            gctx.beginPath();
            gctx.arc(lastX, lastY, 4, 0, Math.PI * 2);
            gctx.fill();
        }

        function addLogEntry(message, type = 'info') {
            const log = document.getElementById('evolutionLog');
            const entry = document.createElement('div');
            entry.className = 'log-entry ' + type;
            entry.innerHTML = `
                <span class="gen">Gen ${generation}</span>
                <span class="time">${new Date().toLocaleTimeString()}</span>
                <div>${message}</div>
            `;
            log.insertBefore(entry, log.querySelector('.log-entry'));

            // Keep only last 50 entries
            while (log.querySelectorAll('.log-entry').length > 50) {
                log.removeChild(log.lastElementChild);
            }
        }

        async function evolveOnce() {
            generation++;
            document.getElementById('genBadge').textContent = `Generation ${generation}`;
            document.getElementById('genBadge').classList.add('evolving');
            document.getElementById('statusText').textContent = 'Running AI playtests...';

            addLogEntry('Starting AI playtest population...', 'analysis');

            // Run tests
            const analysis = await evolutionEngine.runGeneration(gameDNA, (progress) => {
                document.getElementById('testProgress').style.width = (progress * 100) + '%';
            });

            updateMetrics(analysis);

            // Log issues
            for (const issue of analysis.issues) {
                addLogEntry(`Issue: ${issue}`, 'analysis');
            }

            // Mutate
            const { dna: newDNA, changes } = evolutionEngine.mutate(gameDNA, analysis);
            gameDNA = newDNA;

            // Log changes
            for (const change of changes) {
                const direction = change.new > change.old ? '‚Üë' : '‚Üì';
                addLogEntry(`Mutated ${change.gene}: ${change.old.toFixed(2)} ‚Üí ${change.new.toFixed(2)} ${direction} (${change.reason})`, 'mutation');
            }

            updateGeneDisplay();

            evolutionHistory.push({
                generation,
                funScore: analysis.funScore,
                dna: { ...gameDNA },
                analysis
            });

            // Auto-save presets at milestones
            if (generation % 10 === 0) {
                evolutionEngine.savePreset(`Generation_${generation}`, gameDNA, analysis);
                addLogEntry(`Milestone preset saved: Generation_${generation}`, 'info');
                console.log(`[MILESTONE] Gen ${generation}: Fun=${Math.round(analysis.funScore)}%, Survival=${Math.round(analysis.survivalRate*100)}%, AvgDist=${Math.round(analysis.avgDistance)}`);
            }

            // Console log for autonomous tracking
            console.log(`[GEN ${generation}] Strategy: ${evolutionEngine.evolutionStrategy}, Fun: ${Math.round(analysis.funScore)}%, Issues: ${analysis.issues.length}, Changes: ${changes.length}`);

            document.getElementById('genBadge').classList.remove('evolving');
            document.getElementById('statusText').textContent = `Gen ${generation} complete. Fun score: ${Math.round(analysis.funScore)}%`;

            return analysis;
        }

        async function autoEvolve() {
            isAutoEvolving = !isAutoEvolving;
            const btn = document.getElementById('autoEvolve');
            btn.textContent = isAutoEvolving ? 'Stop Evolution' : 'Auto-Evolve';
            btn.classList.toggle('primary', !isAutoEvolving);

            // Autonomous evolution orchestrator
            let strategyPhase = 0;
            const strategies = [
                { name: 'conservative', cycles: 10, description: 'Baseline establishment' },
                { name: 'aggressive', cycles: 15, description: 'Aggressive exploration' },
                { name: 'balanced', cycles: 10, description: 'Refinement phase' },
                { name: 'themed', cycles: 5, description: 'Themed optimization', theme: 'better-flow' },
                { name: 'aggressive', cycles: 10, description: 'Second exploration' },
                { name: 'balanced', cycles: 10, description: 'Final refinement' }
            ];

            let cyclesInPhase = 0;
            let stagnantGenerations = 0;
            let lastBestScore = bestFunScore;

            while (isAutoEvolving) {
                // Switch strategy based on progress
                if (strategyPhase < strategies.length) {
                    const currentStrategy = strategies[strategyPhase];

                    if (cyclesInPhase === 0) {
                        evolutionEngine.setStrategy(currentStrategy.name, currentStrategy.theme);
                        addLogEntry(`Strategy: ${currentStrategy.description} (${currentStrategy.name})`, 'info');
                        console.log(`[STRATEGY CHANGE] Phase ${strategyPhase + 1}: ${currentStrategy.description}`);
                    }

                    cyclesInPhase++;

                    if (cyclesInPhase >= currentStrategy.cycles) {
                        cyclesInPhase = 0;
                        strategyPhase++;
                    }
                }

                const analysis = await evolveOnce();

                // Track stagnation
                if (analysis.funScore <= lastBestScore + 1) {
                    stagnantGenerations++;
                } else {
                    stagnantGenerations = 0;
                    lastBestScore = analysis.funScore;
                }

                // Adaptive strategy switching on stagnation
                if (stagnantGenerations >= 5 && generation > 15) {
                    addLogEntry(`Detected stagnation. Switching to aggressive exploration.`, 'info');
                    evolutionEngine.setStrategy('aggressive');
                    stagnantGenerations = 0;
                    console.log('[ADAPTIVE] Stagnation detected, switching to aggressive mode');
                }

                // Try themed evolution if stuck
                if (stagnantGenerations >= 8 && generation > 20) {
                    const themes = ['better-jumps', 'better-flow', 'more-exciting', 'more-rewarding'];
                    const randomTheme = themes[Math.floor(Math.random() * themes.length)];
                    addLogEntry(`Deep stagnation. Trying themed evolution: ${randomTheme}`, 'info');
                    evolutionEngine.setStrategy('themed', randomTheme);
                    stagnantGenerations = 0;
                    console.log(`[ADAPTIVE] Deep stagnation, trying theme: ${randomTheme}`);
                }

                // Stop if we've achieved target or hit generation limit
                if (analysis.funScore >= 80) {
                    addLogEntry(`Target achieved! Fun score: ${Math.round(analysis.funScore)}%`, 'info');
                    console.log(`[SUCCESS] Target fun score reached at generation ${generation}`);
                    evolutionEngine.savePreset('Target_Achieved', gameDNA, analysis);
                    isAutoEvolving = false;
                    btn.textContent = 'Auto-Evolve';
                    btn.classList.add('primary');
                } else if (generation >= 100) {
                    addLogEntry(`Reached generation limit (100). Best score: ${Math.round(bestFunScore)}%`, 'info');
                    console.log(`[LIMIT] Generation limit reached. Best: ${Math.round(bestFunScore)}%`);
                    isAutoEvolving = false;
                    btn.textContent = 'Auto-Evolve';
                    btn.classList.add('primary');
                }

                await new Promise(r => setTimeout(r, 500));
            }

            // Export data when stopping
            if (generation > 0) {
                console.log('[AUTO-EVOLVE] Stopped. Exporting evolution data...');
                exportEvolutionData();
            }
        }

        function playHuman() {
            humanPlaying = !humanPlaying;
            document.getElementById('playHuman').textContent = humanPlaying ? 'Stop Playing' : 'Play Yourself';
            document.getElementById('hudStatus').textContent = humanPlaying ? 'You are playing!' : 'AI Playtesting...';

            // CYCLE 1: Toggle touch controls and momentum HUD
            const touchControls = document.getElementById('touchControls');
            const momentumHud = document.getElementById('momentumHud');

            if (humanPlaying) {
                // CYCLE 4: Initialize audio on user gesture
                Audio.init();
                Audio.resume();
                currentGame = new Game(gameDNA, false);
                // Show touch controls on mobile devices
                if (isMobile && touchControls) {
                    touchControls.classList.add('active');
                }
                // Always show momentum HUD when playing
                if (momentumHud) {
                    momentumHud.classList.add('active');
                }
                // CYCLE 4: Show jump indicator
                if (jumpIndicator) {
                    jumpIndicator.classList.add('active');
                }
                gameLoop();
            } else {
                // Hide controls when stopping
                if (touchControls) touchControls.classList.remove('active');
                if (momentumHud) momentumHud.classList.remove('active');
                if (jumpIndicator) jumpIndicator.classList.remove('active');
            }
        }

        const keys = { left: false, right: false, jump: false };
        document.addEventListener('keydown', e => {
            if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = true;
            if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = true;
            if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') {
                keys.jump = true;
                e.preventDefault();
            }
        });
        document.addEventListener('keyup', e => {
            if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = false;
            if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = false;
            if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') keys.jump = false;
        });

        // ============================================
        // CYCLE 1: Touch Controls Setup
        // ============================================
        const touchLeft = document.getElementById('touchLeft');
        const touchRight = document.getElementById('touchRight');
        const touchJump = document.getElementById('touchJump');
        const touchControls = document.getElementById('touchControls');
        const momentumHud = document.getElementById('momentumHud');
        const momentumFill = document.getElementById('momentumFill');
        const comboDisplay = document.getElementById('comboDisplay');

        // CYCLE 4: Jump indicator elements
        const jumpIndicator = document.getElementById('jumpIndicator');
        const jumpPip1 = document.getElementById('jumpPip1');
        const jumpPip2 = document.getElementById('jumpPip2');

        // Detect mobile device
        const isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

        function setupTouchControls() {
            if (!touchLeft || !touchRight || !touchJump) return;

            // Left button
            touchLeft.addEventListener('touchstart', (e) => {
                e.preventDefault();
                keys.left = true;
                touchLeft.classList.add('pressed');
            }, { passive: false });
            touchLeft.addEventListener('touchend', () => {
                keys.left = false;
                touchLeft.classList.remove('pressed');
            });

            // Right button
            touchRight.addEventListener('touchstart', (e) => {
                e.preventDefault();
                keys.right = true;
                touchRight.classList.add('pressed');
            }, { passive: false });
            touchRight.addEventListener('touchend', () => {
                keys.right = false;
                touchRight.classList.remove('pressed');
            });

            // Jump button
            touchJump.addEventListener('touchstart', (e) => {
                e.preventDefault();
                keys.jump = true;
                touchJump.classList.add('pressed');
            }, { passive: false });
            touchJump.addEventListener('touchend', () => {
                touchJump.classList.remove('pressed');
            });
        }
        setupTouchControls();

        function gameLoop() {
            if (!humanPlaying) return;

            if (currentGame.alive) {
                currentGame.update(keys);
                keys.jump = false; // Consume jump

                // CYCLE 1: Update momentum HUD
                if (momentumFill && comboDisplay) {
                    const momentumPct = ((currentGame.momentum - 1) / 2) * 100;
                    momentumFill.style.width = momentumPct + '%';

                    if (currentGame.combo > 0) {
                        comboDisplay.textContent = `x${currentGame.combo}`;
                        comboDisplay.classList.toggle('high', currentGame.combo >= 5);
                    } else {
                        comboDisplay.textContent = `x${currentGame.momentum.toFixed(1)}`;
                        comboDisplay.classList.remove('high');
                    }
                }

                // CYCLE 4: Update jump availability indicator
                if (jumpPip1 && jumpPip2) {
                    const jumps = currentGame.player.jumpsLeft;
                    jumpPip1.className = 'jump-pip ' + (jumps >= 1 ? 'available' : 'used');
                    jumpPip2.className = 'jump-pip ' + (jumps >= 2 ? 'available' : 'used');
                }
            } else {
                // CYCLE 4: Quick respawn (reduced from 1000ms to 500ms)
                setTimeout(() => {
                    if (humanPlaying) {
                        currentGame = new Game(gameDNA, false);
                    }
                }, 500);
            }

            currentGame.render();
            document.getElementById('hudScore').textContent = `Score: ${currentGame.score} | Combo: x${currentGame.combo} | Dist: ${Math.round(currentGame.distance)}`;

            requestAnimationFrame(gameLoop);
        }

        // Export evolution data for analysis
        function exportEvolutionData() {
            const exportData = {
                timestamp: new Date().toISOString(),
                totalGenerations: generation,
                bestGeneration: bestGeneration,
                bestFunScore: bestFunScore,
                bestDNA: bestDNA,
                currentDNA: gameDNA,
                evolutionHistory: evolutionHistory,
                fitnessHistory: fitnessHistory,
                presets: Array.from(evolutionEngine.presets.entries()).map(([name, data]) => ({name, ...data}))
            };

            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `evolution-data-gen${generation}.json`;
            link.click();
            URL.revokeObjectURL(url);

            console.log('[EXPORT] Evolution data exported:', exportData);
            addLogEntry('Evolution data exported to JSON file', 'info');
        }

        // Create specialized game modes from best DNA
        function createGameModes() {
            if (!bestDNA) {
                console.log('[MODES] No best DNA found yet');
                return;
            }

            // Hardcore Mode - amp up difficulty
            const hardcoreDNA = {...bestDNA};
            hardcoreDNA.obstacleChance *= 1.5;
            hardcoreDNA.obstacleSpeed *= 1.3;
            hardcoreDNA.platformGap *= 1.2;
            hardcoreDNA.difficultyRamp *= 1.5;
            hardcoreDNA.movingPlatformChance *= 1.4;
            evolutionEngine.savePreset('Hardcore_Mode', hardcoreDNA, {funScore: 0, difficultyAssessment: 'hardcore'});

            // Casual Mode - make it easier and more relaxed
            const casualDNA = {...bestDNA};
            casualDNA.platformWidth *= 1.3;
            casualDNA.platformGap *= 0.8;
            casualDNA.jumpForce *= 1.2;
            casualDNA.coinChance *= 1.5;
            casualDNA.obstacleChance *= 0.6;
            casualDNA.scrollSpeed *= 0.8;
            evolutionEngine.savePreset('Casual_Mode', casualDNA, {funScore: 0, difficultyAssessment: 'casual'});

            // Speedrun Mode - fast and smooth
            const speedrunDNA = {...bestDNA};
            speedrunDNA.scrollSpeed *= 1.5;
            speedrunDNA.playerSpeed *= 1.4;
            speedrunDNA.jumpForce *= 1.2;
            speedrunDNA.gravity *= 1.1;
            speedrunDNA.platformGap *= 1.1;
            speedrunDNA.coinValue *= 2;
            evolutionEngine.savePreset('Speedrun_Mode', speedrunDNA, {funScore: 0, difficultyAssessment: 'speedrun'});

            console.log('[MODES] Created specialized game modes: Hardcore, Casual, Speedrun');
            addLogEntry('Created specialized game modes from best DNA', 'info');

            return {hardcore: hardcoreDNA, casual: casualDNA, speedrun: speedrunDNA};
        }

        // Make functions available via console
        window.exportEvolutionData = exportEvolutionData;
        window.createGameModes = createGameModes;
        window.setEvolutionStrategy = (strategy, theme) => {
            evolutionEngine.setStrategy(strategy, theme);
            console.log(`[STRATEGY] Set to ${strategy}${theme ? ` with theme ${theme}` : ''}`);
        };

        // Event listeners
        document.getElementById('evolveOnce').addEventListener('click', evolveOnce);
        document.getElementById('autoEvolve').addEventListener('click', autoEvolve);
        document.getElementById('playHuman').addEventListener('click', playHuman);
        document.getElementById('speedSlider').addEventListener('input', e => {
            evolutionSpeed = parseInt(e.target.value);
        });
        document.getElementById('loadBest').addEventListener('click', () => {
            if (bestDNA) {
                gameDNA = { ...bestDNA };
                updateGeneDisplay();
                addLogEntry(`Loaded best DNA from generation ${bestGeneration} (${Math.round(bestFunScore)}% fun)`, 'info');
                currentGame = new Game(gameDNA, false);
                currentGame.render();
            }
        });

        // Initial setup
        updateGeneDisplay();
        addLogEntry('Infinite Game Jam initialized. Click "Auto-Evolve" to begin!', 'info');

        // Render initial state
        currentGame.render();
    </script>
</body>
</html>
