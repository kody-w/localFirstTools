<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infinite Game Jam: Self-Evolving Game</title>
    <meta name="description" content="Watch a game evolve itself through AI playtesting - autonomous game design through computational iteration">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --bg-dark: #0a0a0f;
            --bg-panel: #12121a;
            --accent: #00ff88;
            --accent-dim: #00aa55;
            --warning: #ffaa00;
            --danger: #ff4444;
            --text: #e0e0e0;
            --text-dim: #888;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: var(--bg-dark);
            color: var(--text);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            display: grid;
            grid-template-columns: 1fr 380px;
            grid-template-rows: auto 1fr auto;
            height: 100vh;
            gap: 1px;
            background: #333;
        }

        header {
            grid-column: 1 / -1;
            background: var(--bg-panel);
            padding: 1rem 2rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid #333;
        }

        h1 {
            font-size: 1.5rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        h1 span { font-size: 1.75rem; }

        .generation-badge {
            background: linear-gradient(135deg, var(--accent), #00ccff);
            color: #000;
            padding: 0.4rem 1rem;
            border-radius: 2rem;
            font-weight: 700;
            font-size: 0.9rem;
        }

        .controls {
            display: flex;
            gap: 0.75rem;
        }

        button {
            background: var(--bg-dark);
            border: 1px solid #444;
            color: var(--text);
            padding: 0.6rem 1.25rem;
            border-radius: 0.5rem;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
        }

        button:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        button.primary {
            background: var(--accent);
            color: #000;
            border-color: var(--accent);
            font-weight: 600;
        }

        button.primary:hover {
            background: #00ffaa;
            transform: scale(1.02);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .game-area {
            background: var(--bg-panel);
            display: flex;
            flex-direction: column;
            position: relative;
        }

        #gameCanvas {
            width: 100%;
            flex: 1;
            background: #000;
        }

        .game-hud {
            position: absolute;
            top: 1rem;
            left: 1rem;
            right: 1rem;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
        }

        .hud-stat {
            background: rgba(0,0,0,0.7);
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-family: monospace;
        }

        .sidebar {
            background: var(--bg-panel);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .panel {
            padding: 1rem;
            border-bottom: 1px solid #333;
        }

        .panel h3 {
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-dim);
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
        }

        .metric {
            background: var(--bg-dark);
            padding: 0.75rem;
            border-radius: 0.5rem;
            text-align: center;
        }

        .metric-value {
            font-size: 1.5rem;
            font-weight: 700;
            font-family: monospace;
        }

        .metric-label {
            font-size: 0.7rem;
            color: var(--text-dim);
            text-transform: uppercase;
        }

        .metric.good .metric-value { color: var(--accent); }
        .metric.warning .metric-value { color: var(--warning); }
        .metric.bad .metric-value { color: var(--danger); }

        .evolution-log {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
        }

        .log-entry {
            background: var(--bg-dark);
            padding: 0.75rem;
            border-radius: 0.5rem;
            margin-bottom: 0.5rem;
            font-size: 0.85rem;
            border-left: 3px solid var(--accent);
        }

        .log-entry.mutation {
            border-left-color: #ff00ff;
        }

        .log-entry.analysis {
            border-left-color: #00aaff;
        }

        .log-entry .gen {
            color: var(--accent);
            font-weight: 600;
        }

        .log-entry .time {
            color: var(--text-dim);
            font-size: 0.75rem;
            float: right;
        }

        .progress-bar {
            height: 4px;
            background: var(--bg-dark);
            border-radius: 2px;
            overflow: hidden;
            margin-top: 0.5rem;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent), #00ccff);
            transition: width 0.3s;
        }

        .gene-display {
            display: grid;
            gap: 0.4rem;
            font-family: monospace;
            font-size: 0.8rem;
        }

        .gene {
            display: flex;
            justify-content: space-between;
            background: var(--bg-dark);
            padding: 0.4rem 0.6rem;
            border-radius: 0.25rem;
        }

        .gene-name { color: var(--text-dim); }
        .gene-value { color: var(--accent); }
        .gene-change { font-size: 0.7rem; margin-left: 0.5rem; }
        .gene-change.up { color: var(--accent); }
        .gene-change.down { color: var(--danger); }

        footer {
            grid-column: 1 / -1;
            background: var(--bg-panel);
            padding: 0.75rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.85rem;
            color: var(--text-dim);
            border-top: 1px solid #333;
        }

        .fitness-bar {
            display: flex;
            align-items: center;
            gap: 1rem;
            flex: 1;
            max-width: 400px;
        }

        .fitness-track {
            flex: 1;
            height: 8px;
            background: var(--bg-dark);
            border-radius: 4px;
            overflow: hidden;
        }

        .fitness-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--danger), var(--warning), var(--accent));
            transition: width 0.5s;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .evolving {
            animation: pulse 1s infinite;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .speed-control input {
            width: 100px;
        }

        /* Death heatmap overlay */
        .heatmap-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            opacity: 0.3;
        }

        .evolution-graph {
            background: var(--bg-dark);
            border-radius: 0.5rem;
            padding: 0.5rem;
            margin-top: 0.5rem;
        }

        #fitnessGraph {
            width: 100%;
            height: 80px;
            display: block;
        }

        .best-dna-banner {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            border: 1px solid var(--accent);
            border-radius: 0.5rem;
            padding: 0.75rem;
            margin-top: 0.5rem;
            display: none;
        }

        .best-dna-banner.show {
            display: block;
        }

        .best-dna-banner h4 {
            color: var(--accent);
            font-size: 0.8rem;
            margin-bottom: 0.5rem;
        }

        .best-score {
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--accent);
        }

        .load-best-btn {
            margin-top: 0.5rem;
            width: 100%;
            background: var(--accent-dim);
            border: none;
        }

        .death-chart {
            display: flex;
            gap: 0.25rem;
            margin-top: 0.5rem;
        }

        .death-bar {
            flex: 1;
            height: 20px;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.6rem;
            color: #fff;
        }

        .death-bar.fall { background: #3498db; }
        .death-bar.obstacle { background: #e74c3c; }
        .death-bar.leftEdge { background: #9b59b6; }
        .death-bar.survived { background: var(--accent); }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1><span>üéÆ</span> Infinite Game Jam</h1>
            <div class="generation-badge" id="genBadge">Generation 0</div>
            <div class="controls">
                <button id="playHuman">Play Yourself</button>
                <button id="evolveOnce">Evolve Once</button>
                <button id="autoEvolve" class="primary">Auto-Evolve</button>
                <div class="speed-control">
                    <label>Speed:</label>
                    <input type="range" id="speedSlider" min="1" max="100" value="50">
                </div>
            </div>
        </header>

        <div class="game-area">
            <canvas id="gameCanvas"></canvas>
            <div class="game-hud">
                <div class="hud-stat" id="hudScore">Score: 0</div>
                <div class="hud-stat" id="hudStatus">AI Playtesting...</div>
            </div>
        </div>

        <div class="sidebar">
            <div class="panel">
                <h3>üìä Current Metrics</h3>
                <div class="metrics-grid">
                    <div class="metric" id="metricSurvival">
                        <div class="metric-value">0%</div>
                        <div class="metric-label">Survival Rate</div>
                    </div>
                    <div class="metric" id="metricAvgScore">
                        <div class="metric-value">0</div>
                        <div class="metric-label">Avg Score</div>
                    </div>
                    <div class="metric" id="metricFun">
                        <div class="metric-value">0</div>
                        <div class="metric-label">Fun Score</div>
                    </div>
                    <div class="metric" id="metricDifficulty">
                        <div class="metric-value">?</div>
                        <div class="metric-label">Difficulty</div>
                    </div>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="testProgress" style="width: 0%"></div>
                </div>
                <div class="death-chart" id="deathChart"></div>
                <div class="evolution-graph">
                    <canvas id="fitnessGraph"></canvas>
                </div>
                <div class="best-dna-banner" id="bestDNABanner">
                    <h4>üèÜ Best Generation</h4>
                    <span>Gen <span id="bestGen">0</span>: </span>
                    <span class="best-score" id="bestScore">0%</span> fun
                    <button class="load-best-btn" id="loadBest">Load Best DNA</button>
                </div>
            </div>

            <div class="panel">
                <h3>üß¨ Game DNA</h3>
                <div class="gene-display" id="geneDisplay">
                    <!-- Filled dynamically -->
                </div>
            </div>

            <div class="panel evolution-log" id="evolutionLog">
                <h3>üìú Evolution Log</h3>
                <!-- Log entries appear here -->
            </div>
        </div>

        <footer>
            <div class="fitness-bar">
                <span>Fitness:</span>
                <div class="fitness-track">
                    <div class="fitness-fill" id="fitnessFill" style="width: 10%"></div>
                </div>
                <span id="fitnessValue">10%</span>
            </div>
            <div id="statusText">Ready to evolve</div>
        </footer>
    </div>

    <script>
        // ============================================
        // INFINITE GAME JAM: SELF-EVOLVING GAME ENGINE
        // ============================================

        // Game DNA - all tweakable parameters that define the game
        let gameDNA = {
            // Player physics
            playerSpeed: 5,
            jumpForce: 12,
            gravity: 0.5,
            airControl: 0.8,

            // Platform generation
            platformWidth: 100,
            platformGap: 150,
            platformVariance: 50,
            movingPlatformChance: 0.2,
            movingPlatformSpeed: 2,

            // Obstacles
            obstacleChance: 0.3,
            obstacleSpeed: 3,
            obstacleSize: 30,

            // Collectibles
            coinChance: 0.5,
            coinValue: 10,
            powerupChance: 0.1,

            // Difficulty scaling
            difficultyRamp: 0.001,
            maxDifficulty: 2.0,

            // World
            scrollSpeed: 3,
            worldWidth: 800,
            worldHeight: 600
        };

        // Evolution state
        let generation = 0;
        let isAutoEvolving = false;
        let evolutionSpeed = 50;
        let testResults = [];
        let evolutionHistory = [];
        let bestDNA = null;
        let bestFunScore = 0;
        let bestGeneration = 0;
        let fitnessHistory = [];

        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            const rect = canvas.parentElement.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            gameDNA.worldWidth = canvas.width;
            gameDNA.worldHeight = canvas.height;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // ============================================
        // GAME ENGINE
        // ============================================

        class Game {
            constructor(dna, isAI = true) {
                this.dna = { ...dna };
                this.isAI = isAI;
                this.reset();
            }

            reset() {
                this.player = {
                    x: 100,
                    y: this.dna.worldHeight / 2,
                    vx: 0,
                    vy: 0,
                    width: 30,
                    height: 40,
                    grounded: false,
                    jumpsLeft: 2
                };

                this.platforms = [];
                this.obstacles = [];
                this.coins = [];
                this.particles = [];

                this.score = 0;
                this.distance = 0;
                this.time = 0;
                this.alive = true;
                this.won = false;

                this.difficulty = 1;
                this.scrollOffset = 0;

                // Analytics
                this.deathLocation = null;
                this.coinsMissed = 0;
                this.coinsCollected = 0;
                this.jumpsUsed = 0;
                this.closeCallCount = 0;
                this.idleTime = 0;
                this.actionVariety = new Set();

                // Generate initial platforms
                this.generateInitialWorld();
            }

            generateInitialWorld() {
                let x = 50;
                for (let i = 0; i < 20; i++) {
                    this.addPlatform(x);
                    x += this.dna.platformGap + (Math.random() - 0.5) * this.dna.platformVariance;
                }
            }

            addPlatform(x) {
                const isMoving = Math.random() < this.dna.movingPlatformChance * this.difficulty;
                const platform = {
                    x: x,
                    y: 100 + Math.random() * (this.dna.worldHeight - 250),
                    width: this.dna.platformWidth * (0.7 + Math.random() * 0.6),
                    height: 20,
                    isMoving: isMoving,
                    moveDir: Math.random() > 0.5 ? 1 : -1,
                    moveRange: 50 + Math.random() * 50,
                    baseY: 0
                };
                platform.baseY = platform.y;
                this.platforms.push(platform);

                // Maybe add obstacle
                if (Math.random() < this.dna.obstacleChance * this.difficulty && this.platforms.length > 3) {
                    this.obstacles.push({
                        x: x + platform.width / 2,
                        y: platform.y - this.dna.obstacleSize - 10,
                        size: this.dna.obstacleSize,
                        vx: (Math.random() > 0.5 ? 1 : -1) * this.dna.obstacleSpeed
                    });
                }

                // Maybe add coin
                if (Math.random() < this.dna.coinChance) {
                    this.coins.push({
                        x: x + Math.random() * platform.width,
                        y: platform.y - 40 - Math.random() * 60,
                        collected: false
                    });
                }
            }

            update(input) {
                if (!this.alive) return;

                this.time++;
                const dt = 1;

                // Apply difficulty scaling
                this.difficulty = Math.min(
                    this.dna.maxDifficulty,
                    1 + this.distance * this.dna.difficultyRamp
                );

                // Player input
                if (input.left) {
                    this.player.vx -= this.dna.playerSpeed * (this.player.grounded ? 1 : this.dna.airControl);
                    this.actionVariety.add('left');
                }
                if (input.right) {
                    this.player.vx += this.dna.playerSpeed * (this.player.grounded ? 1 : this.dna.airControl);
                    this.actionVariety.add('right');
                }
                if (input.jump && this.player.jumpsLeft > 0) {
                    this.player.vy = -this.dna.jumpForce;
                    this.player.jumpsLeft--;
                    this.player.grounded = false;
                    this.jumpsUsed++;
                    this.actionVariety.add('jump');
                }

                // Physics
                this.player.vy += this.dna.gravity;
                this.player.vx *= 0.9; // Friction

                this.player.x += this.player.vx;
                this.player.y += this.player.vy;

                // Platform collision
                this.player.grounded = false;
                for (const plat of this.platforms) {
                    // Update moving platforms
                    if (plat.isMoving) {
                        plat.y = plat.baseY + Math.sin(this.time * 0.02 * this.dna.movingPlatformSpeed) * plat.moveRange;
                    }

                    if (this.collides(this.player, plat) && this.player.vy >= 0) {
                        if (this.player.y + this.player.height - this.player.vy <= plat.y + 10) {
                            this.player.y = plat.y - this.player.height;
                            this.player.vy = 0;
                            this.player.grounded = true;
                            this.player.jumpsLeft = 2;
                        }
                    }
                }

                // Obstacle collision
                for (const obs of this.obstacles) {
                    obs.x += obs.vx;

                    // Bounce off screen edges
                    if (obs.x < this.scrollOffset || obs.x > this.scrollOffset + this.dna.worldWidth) {
                        obs.vx *= -1;
                    }

                    const dist = Math.hypot(
                        this.player.x + this.player.width/2 - obs.x,
                        this.player.y + this.player.height/2 - obs.y
                    );

                    if (dist < obs.size/2 + 15) {
                        this.die('obstacle');
                    } else if (dist < obs.size/2 + 40) {
                        this.closeCallCount++;
                    }
                }

                // Coin collection
                for (const coin of this.coins) {
                    if (coin.collected) continue;
                    const dist = Math.hypot(
                        this.player.x + this.player.width/2 - coin.x,
                        this.player.y + this.player.height/2 - coin.y
                    );
                    if (dist < 25) {
                        coin.collected = true;
                        this.score += this.dna.coinValue;
                        this.coinsCollected++;
                        this.spawnParticles(coin.x, coin.y, '#ffdd00', 5);
                    }
                }

                // World scrolling
                const targetScroll = this.player.x - 200;
                if (targetScroll > this.scrollOffset) {
                    this.scrollOffset = targetScroll;
                    this.distance = this.scrollOffset;

                    // Generate new platforms ahead
                    const lastPlatX = Math.max(...this.platforms.map(p => p.x));
                    if (lastPlatX < this.scrollOffset + this.dna.worldWidth + 200) {
                        this.addPlatform(lastPlatX + this.dna.platformGap + (Math.random() - 0.5) * this.dna.platformVariance);
                    }

                    // Clean up old platforms
                    this.platforms = this.platforms.filter(p => p.x + p.width > this.scrollOffset - 100);
                    this.obstacles = this.obstacles.filter(o => o.x > this.scrollOffset - 100);

                    // Track missed coins
                    const oldCoins = this.coins.length;
                    this.coins = this.coins.filter(c => c.x > this.scrollOffset - 50);
                    this.coinsMissed += oldCoins - this.coins.length - this.coins.filter(c => c.collected).length;
                }

                // Fall death
                if (this.player.y > this.dna.worldHeight + 50) {
                    this.die('fall');
                }

                // Screen edge death
                if (this.player.x < this.scrollOffset - 50) {
                    this.die('leftEdge');
                }

                // Update particles
                this.particles = this.particles.filter(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.2;
                    p.life--;
                    return p.life > 0;
                });

                // Track idle time
                if (!input.left && !input.right && !input.jump) {
                    this.idleTime++;
                }
            }

            collides(a, b) {
                return a.x < b.x + b.width &&
                       a.x + a.width > b.x &&
                       a.y < b.y + b.height &&
                       a.y + a.height > b.y;
            }

            die(reason) {
                this.alive = false;
                this.deathLocation = {
                    x: this.player.x,
                    y: this.player.y,
                    reason: reason,
                    distance: this.distance
                };
                this.spawnParticles(this.player.x, this.player.y, '#ff4444', 15);
            }

            spawnParticles(x, y, color, count) {
                for (let i = 0; i < count; i++) {
                    this.particles.push({
                        x, y,
                        vx: (Math.random() - 0.5) * 8,
                        vy: (Math.random() - 1) * 8,
                        color,
                        life: 30 + Math.random() * 20
                    });
                }
            }

            render() {
                ctx.fillStyle = '#1a1a2e';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Parallax background
                const bgOffset = this.scrollOffset * 0.3;
                ctx.fillStyle = '#16213e';
                for (let i = 0; i < 20; i++) {
                    const x = ((i * 100 - bgOffset) % (canvas.width + 100)) - 50;
                    ctx.fillRect(x, 100 + (i % 5) * 80, 40, 300);
                }

                ctx.save();
                ctx.translate(-this.scrollOffset, 0);

                // Platforms
                for (const plat of this.platforms) {
                    ctx.fillStyle = plat.isMoving ? '#4a69bd' : '#6a89cc';
                    ctx.fillRect(plat.x, plat.y, plat.width, plat.height);
                    ctx.fillStyle = '#82ccdd';
                    ctx.fillRect(plat.x, plat.y, plat.width, 4);
                }

                // Coins
                for (const coin of this.coins) {
                    if (coin.collected) continue;
                    ctx.fillStyle = '#ffd700';
                    ctx.beginPath();
                    ctx.arc(coin.x, coin.y, 10, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#ffed4a';
                    ctx.beginPath();
                    ctx.arc(coin.x - 2, coin.y - 2, 4, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Obstacles
                for (const obs of this.obstacles) {
                    ctx.fillStyle = '#e74c3c';
                    ctx.beginPath();
                    ctx.moveTo(obs.x, obs.y - obs.size/2);
                    ctx.lineTo(obs.x + obs.size/2, obs.y + obs.size/2);
                    ctx.lineTo(obs.x - obs.size/2, obs.y + obs.size/2);
                    ctx.closePath();
                    ctx.fill();
                }

                // Player
                if (this.alive) {
                    ctx.fillStyle = '#00ff88';
                    ctx.fillRect(this.player.x, this.player.y, this.player.width, this.player.height);
                    // Eyes
                    ctx.fillStyle = '#000';
                    ctx.fillRect(this.player.x + 8, this.player.y + 10, 5, 5);
                    ctx.fillRect(this.player.x + 18, this.player.y + 10, 5, 5);
                }

                // Particles
                for (const p of this.particles) {
                    ctx.fillStyle = p.color;
                    ctx.globalAlpha = p.life / 50;
                    ctx.fillRect(p.x - 3, p.y - 3, 6, 6);
                }
                ctx.globalAlpha = 1;

                ctx.restore();

                // Death location marker
                if (this.deathLocation) {
                    ctx.fillStyle = 'rgba(255,0,0,0.5)';
                    ctx.beginPath();
                    ctx.arc(
                        this.deathLocation.x - this.scrollOffset,
                        this.deathLocation.y,
                        20, 0, Math.PI * 2
                    );
                    ctx.fill();
                }
            }

            getAnalytics() {
                return {
                    score: this.score,
                    distance: this.distance,
                    timeAlive: this.time,
                    deathReason: this.deathLocation?.reason || 'survived',
                    deathDistance: this.deathLocation?.distance || this.distance,
                    coinsCollected: this.coinsCollected,
                    coinsMissed: this.coinsMissed,
                    jumpsUsed: this.jumpsUsed,
                    closeCallCount: this.closeCallCount,
                    idleTimeRatio: this.idleTime / Math.max(1, this.time),
                    actionVariety: this.actionVariety.size
                };
            }
        }

        // ============================================
        // AI PLAYTESTER
        // ============================================

        class AIPlayer {
            constructor(skill = 0.7) {
                this.skill = skill; // 0-1, affects reaction time and decision quality
                this.reactionDelay = Math.floor((1 - skill) * 10);
                this.jumpBuffer = 0;
            }

            getInput(game) {
                const input = { left: false, right: false, jump: false };
                const player = game.player;

                // Find nearest platform ahead
                let targetPlatform = null;
                let minDist = Infinity;

                for (const plat of game.platforms) {
                    if (plat.x + plat.width > player.x && plat.x > player.x - 50) {
                        const dist = plat.x - player.x;
                        if (dist < minDist && dist > 0) {
                            minDist = dist;
                            targetPlatform = plat;
                        }
                    }
                }

                // Check for obstacles
                let dangerAhead = false;
                for (const obs of game.obstacles) {
                    if (obs.x > player.x && obs.x < player.x + 150) {
                        if (Math.abs(obs.y - player.y) < 60) {
                            dangerAhead = true;
                        }
                    }
                }

                // Decision making with skill factor
                const makeGoodDecision = Math.random() < this.skill;

                // Always try to move right (it's an endless runner)
                input.right = true;

                // Jump logic
                if (targetPlatform) {
                    const needsJump = targetPlatform.y < player.y - 20 ||
                                     !player.grounded ||
                                     minDist > 80;

                    if (needsJump && makeGoodDecision) {
                        // Predictive jump timing
                        const timeToReach = minDist / (game.dna.playerSpeed * 0.9);
                        const jumpTime = Math.sqrt(2 * Math.abs(targetPlatform.y - player.y) / game.dna.gravity);

                        if (timeToReach < jumpTime + 5 + this.reactionDelay) {
                            input.jump = player.grounded || player.jumpsLeft > 0;
                        }
                    }
                }

                // Dodge obstacles
                if (dangerAhead && makeGoodDecision) {
                    input.jump = true;
                }

                // Prevent falling off screen
                if (player.y > game.dna.worldHeight - 150 && !player.grounded) {
                    input.jump = player.jumpsLeft > 0;
                }

                // Random mistakes based on skill
                if (Math.random() > this.skill * 0.95) {
                    input.jump = !input.jump;
                }

                return input;
            }
        }

        // ============================================
        // EVOLUTION ENGINE
        // ============================================

        class EvolutionEngine {
            constructor() {
                this.populationSize = 50; // AI runs per generation
                this.mutationRate = 0.15;
                this.mutationStrength = 0.2;
                this.evolutionStrategy = 'balanced'; // balanced, conservative, aggressive, themed
                this.presets = new Map();
                this.loadPresets();
            }

            setStrategy(strategy, theme = null) {
                this.evolutionStrategy = strategy;
                this.currentTheme = theme;

                switch(strategy) {
                    case 'conservative':
                        this.mutationRate = 0.08;
                        this.mutationStrength = 0.1;
                        break;
                    case 'aggressive':
                        this.mutationRate = 0.25;
                        this.mutationStrength = 0.35;
                        break;
                    case 'themed':
                        this.mutationRate = 0.15;
                        this.mutationStrength = 0.25;
                        break;
                    default: // balanced
                        this.mutationRate = 0.15;
                        this.mutationStrength = 0.2;
                }
            }

            savePreset(name, dna, analysis) {
                this.presets.set(name, {
                    dna: {...dna},
                    analysis: {...analysis},
                    timestamp: new Date().toISOString(),
                    generation: generation
                });
                this.savePresetsToStorage();
            }

            savePresetsToStorage() {
                const presetsObj = {};
                this.presets.forEach((val, key) => {
                    presetsObj[key] = val;
                });
                localStorage.setItem('gameJamPresets', JSON.stringify(presetsObj));
            }

            loadPresets() {
                try {
                    const stored = localStorage.getItem('gameJamPresets');
                    if (stored) {
                        const presetsObj = JSON.parse(stored);
                        Object.entries(presetsObj).forEach(([key, val]) => {
                            this.presets.set(key, val);
                        });
                    }
                } catch(e) {
                    console.warn('Could not load presets:', e);
                }
            }

            loadPreset(name) {
                return this.presets.get(name);
            }

            async runGeneration(dna, onProgress) {
                const results = [];
                const aiSkills = [0.5, 0.6, 0.7, 0.8, 0.9]; // Different skill levels

                for (let i = 0; i < this.populationSize; i++) {
                    const skill = aiSkills[i % aiSkills.length];
                    const ai = new AIPlayer(skill);
                    const game = new Game(dna, true);

                    // Run simulation
                    const maxSteps = 3000;
                    for (let step = 0; step < maxSteps && game.alive; step++) {
                        const input = ai.getInput(game);
                        game.update(input);

                        // Visualize occasionally
                        if (i === 0 && step % 5 === 0) {
                            game.render();
                            await new Promise(r => setTimeout(r, Math.max(1, 50 - evolutionSpeed)));
                        }
                    }

                    results.push(game.getAnalytics());
                    onProgress((i + 1) / this.populationSize);
                }

                return this.analyzeResults(results);
            }

            analyzeResults(results) {
                const analysis = {
                    avgScore: 0,
                    avgDistance: 0,
                    avgTimeAlive: 0,
                    survivalRate: 0,
                    deathReasons: {},
                    avgCoinsCollected: 0,
                    avgCoinsMissed: 0,
                    avgCloseCall: 0,
                    avgIdleRatio: 0,
                    difficultyAssessment: 'balanced',
                    funScore: 0,
                    issues: [],
                    recommendations: []
                };

                // Aggregate stats
                for (const r of results) {
                    analysis.avgScore += r.score;
                    analysis.avgDistance += r.distance;
                    analysis.avgTimeAlive += r.timeAlive;
                    analysis.survivalRate += r.deathReason === 'survived' ? 1 : 0;
                    analysis.deathReasons[r.deathReason] = (analysis.deathReasons[r.deathReason] || 0) + 1;
                    analysis.avgCoinsCollected += r.coinsCollected;
                    analysis.avgCoinsMissed += r.coinsMissed;
                    analysis.avgCloseCall += r.closeCallCount;
                    analysis.avgIdleRatio += r.idleTimeRatio;
                }

                const n = results.length;
                analysis.avgScore /= n;
                analysis.avgDistance /= n;
                analysis.avgTimeAlive /= n;
                analysis.survivalRate /= n;
                analysis.avgCoinsCollected /= n;
                analysis.avgCoinsMissed /= n;
                analysis.avgCloseCall /= n;
                analysis.avgIdleRatio /= n;

                // Assess difficulty
                if (analysis.survivalRate < 0.1) {
                    analysis.difficultyAssessment = 'too hard';
                    analysis.issues.push('Game is too difficult - most players die quickly');
                } else if (analysis.survivalRate > 0.8) {
                    analysis.difficultyAssessment = 'too easy';
                    analysis.issues.push('Game is too easy - not enough challenge');
                } else if (analysis.avgDistance < 500) {
                    analysis.difficultyAssessment = 'frustrating start';
                    analysis.issues.push('Early game is too punishing');
                }

                // Assess engagement
                if (analysis.avgIdleRatio > 0.3) {
                    analysis.issues.push('Too much idle time - game feels slow');
                }
                if (analysis.avgCloseCall < 2) {
                    analysis.issues.push('Not enough exciting moments');
                }
                if (analysis.avgCoinsMissed > analysis.avgCoinsCollected * 2) {
                    analysis.issues.push('Coins are too hard to collect');
                }

                // Death analysis
                const topDeathReason = Object.entries(analysis.deathReasons)
                    .sort((a, b) => b[1] - a[1])[0];
                if (topDeathReason) {
                    if (topDeathReason[0] === 'fall' && topDeathReason[1] > n * 0.5) {
                        analysis.issues.push('Too many fall deaths - platforms too far apart');
                    }
                    if (topDeathReason[0] === 'obstacle' && topDeathReason[1] > n * 0.5) {
                        analysis.issues.push('Obstacles are too deadly');
                    }
                }

                // Calculate fun score (0-100)
                analysis.funScore = Math.min(100, Math.max(0,
                    50 +
                    (analysis.survivalRate - 0.3) * 50 +
                    Math.min(analysis.avgCloseCall, 10) * 3 -
                    analysis.avgIdleRatio * 30 +
                    Math.min(analysis.avgDistance / 100, 20) -
                    analysis.issues.length * 10
                ));

                // Generate recommendations
                this.generateRecommendations(analysis);

                return analysis;
            }

            generateRecommendations(analysis) {
                if (analysis.difficultyAssessment === 'too hard') {
                    analysis.recommendations.push({ gene: 'platformGap', direction: 'decrease', reason: 'reduce jump distance' });
                    analysis.recommendations.push({ gene: 'obstacleChance', direction: 'decrease', reason: 'fewer obstacles' });
                    analysis.recommendations.push({ gene: 'jumpForce', direction: 'increase', reason: 'higher jumps help' });
                }

                if (analysis.difficultyAssessment === 'too easy') {
                    analysis.recommendations.push({ gene: 'obstacleChance', direction: 'increase', reason: 'add challenge' });
                    analysis.recommendations.push({ gene: 'difficultyRamp', direction: 'increase', reason: 'faster scaling' });
                    analysis.recommendations.push({ gene: 'movingPlatformChance', direction: 'increase', reason: 'more dynamic' });
                }

                if (analysis.avgIdleRatio > 0.3) {
                    analysis.recommendations.push({ gene: 'scrollSpeed', direction: 'increase', reason: 'force action' });
                    analysis.recommendations.push({ gene: 'coinChance', direction: 'increase', reason: 'more goals' });
                }

                if (analysis.avgCloseCall < 2) {
                    analysis.recommendations.push({ gene: 'obstacleSpeed', direction: 'increase', reason: 'more tension' });
                    analysis.recommendations.push({ gene: 'obstacleSize', direction: 'decrease', reason: 'closer dodges' });
                }

                if (analysis.avgCoinsMissed > analysis.avgCoinsCollected * 2) {
                    analysis.recommendations.push({ gene: 'coinValue', direction: 'increase', reason: 'reward collection more' });
                }
            }

            mutate(dna, analysis) {
                const newDNA = { ...dna };
                const changes = [];

                // Apply themed mutations if in themed mode
                if (this.evolutionStrategy === 'themed' && this.currentTheme) {
                    this.applyThemedMutation(newDNA, changes);
                }

                // Apply recommendations
                const recApplyRate = this.evolutionStrategy === 'aggressive' ? 0.85 : 0.7;
                for (const rec of analysis.recommendations) {
                    if (Math.random() < recApplyRate) {
                        const oldVal = newDNA[rec.gene];
                        const change = oldVal * this.mutationStrength;

                        if (rec.direction === 'increase') {
                            newDNA[rec.gene] = oldVal + change;
                        } else {
                            newDNA[rec.gene] = Math.max(oldVal * 0.1, oldVal - change);
                        }

                        changes.push({
                            gene: rec.gene,
                            old: oldVal,
                            new: newDNA[rec.gene],
                            reason: rec.reason
                        });
                    }
                }

                // Random mutations for exploration
                const genes = Object.keys(dna).filter(k => typeof dna[k] === 'number');
                for (const gene of genes) {
                    if (Math.random() < this.mutationRate) {
                        const oldVal = newDNA[gene];
                        const mutation = (Math.random() - 0.5) * 2 * this.mutationStrength * oldVal;
                        newDNA[gene] = Math.max(0.1, oldVal + mutation);

                        if (!changes.find(c => c.gene === gene)) {
                            changes.push({
                                gene: gene,
                                old: oldVal,
                                new: newDNA[gene],
                                reason: 'random exploration'
                            });
                        }
                    }
                }

                return { dna: newDNA, changes };
            }

            applyThemedMutation(dna, changes) {
                const themes = {
                    'better-jumps': ['jumpForce', 'gravity', 'airControl'],
                    'better-flow': ['scrollSpeed', 'platformGap', 'platformVariance'],
                    'more-exciting': ['obstacleChance', 'obstacleSpeed', 'movingPlatformChance'],
                    'more-rewarding': ['coinChance', 'coinValue', 'powerupChance'],
                    'smoother-difficulty': ['difficultyRamp', 'maxDifficulty'],
                    'speedrun-mode': ['scrollSpeed', 'playerSpeed', 'jumpForce', 'gravity'],
                    'hardcore-mode': ['obstacleChance', 'obstacleSpeed', 'platformGap', 'difficultyRamp'],
                    'casual-mode': ['platformWidth', 'platformGap', 'jumpForce', 'coinChance']
                };

                const targetGenes = themes[this.currentTheme] || [];
                for (const gene of targetGenes) {
                    if (dna[gene] !== undefined) {
                        const oldVal = dna[gene];
                        const mutation = (Math.random() - 0.5) * 2 * this.mutationStrength * 1.5 * oldVal;
                        dna[gene] = Math.max(0.1, oldVal + mutation);

                        changes.push({
                            gene: gene,
                            old: oldVal,
                            new: dna[gene],
                            reason: `themed: ${this.currentTheme}`
                        });
                    }
                }
            }
        }

        // ============================================
        // UI UPDATES
        // ============================================

        const evolutionEngine = new EvolutionEngine();
        let currentGame = new Game(gameDNA, false);
        let humanPlaying = false;

        function updateGeneDisplay() {
            const display = document.getElementById('geneDisplay');
            const genes = [
                ['jumpForce', 'Jump Force'],
                ['gravity', 'Gravity'],
                ['platformGap', 'Platform Gap'],
                ['obstacleChance', 'Obstacle %'],
                ['coinChance', 'Coin %'],
                ['scrollSpeed', 'Scroll Speed'],
                ['difficultyRamp', 'Difficulty Ramp']
            ];

            display.innerHTML = genes.map(([key, label]) => `
                <div class="gene">
                    <span class="gene-name">${label}</span>
                    <span class="gene-value">${gameDNA[key].toFixed(2)}</span>
                </div>
            `).join('');
        }

        function updateMetrics(analysis) {
            const survivalEl = document.getElementById('metricSurvival');
            const survivalPct = (analysis.survivalRate * 100).toFixed(0);
            survivalEl.querySelector('.metric-value').textContent = survivalPct + '%';
            survivalEl.className = 'metric ' + (survivalPct > 50 ? 'good' : survivalPct > 20 ? 'warning' : 'bad');

            const scoreEl = document.getElementById('metricAvgScore');
            scoreEl.querySelector('.metric-value').textContent = Math.round(analysis.avgScore);

            const funEl = document.getElementById('metricFun');
            funEl.querySelector('.metric-value').textContent = Math.round(analysis.funScore);
            funEl.className = 'metric ' + (analysis.funScore > 60 ? 'good' : analysis.funScore > 40 ? 'warning' : 'bad');

            const diffEl = document.getElementById('metricDifficulty');
            diffEl.querySelector('.metric-value').textContent = analysis.difficultyAssessment.split(' ')[0];
            diffEl.className = 'metric ' + (analysis.difficultyAssessment === 'balanced' ? 'good' : 'warning');

            document.getElementById('fitnessFill').style.width = analysis.funScore + '%';
            document.getElementById('fitnessValue').textContent = Math.round(analysis.funScore) + '%';

            // Update death chart
            updateDeathChart(analysis.deathReasons);

            // Update fitness graph
            fitnessHistory.push(analysis.funScore);
            drawFitnessGraph();

            // Track best DNA
            if (analysis.funScore > bestFunScore) {
                bestFunScore = analysis.funScore;
                bestDNA = { ...gameDNA };
                bestGeneration = generation;
                document.getElementById('bestGen').textContent = generation;
                document.getElementById('bestScore').textContent = Math.round(analysis.funScore) + '%';
                document.getElementById('bestDNABanner').classList.add('show');
            }
        }

        function updateDeathChart(deathReasons) {
            const chart = document.getElementById('deathChart');
            const total = Object.values(deathReasons).reduce((a, b) => a + b, 0);
            if (total === 0) return;

            const colors = {
                fall: 'fall',
                obstacle: 'obstacle',
                leftEdge: 'leftEdge',
                survived: 'survived'
            };

            chart.innerHTML = Object.entries(deathReasons)
                .filter(([_, count]) => count > 0)
                .map(([reason, count]) => {
                    const pct = Math.round(count / total * 100);
                    return `<div class="death-bar ${colors[reason] || ''}" style="flex: ${count}">${pct}% ${reason}</div>`;
                }).join('');
        }

        function drawFitnessGraph() {
            const graphCanvas = document.getElementById('fitnessGraph');
            const gctx = graphCanvas.getContext('2d');
            const rect = graphCanvas.parentElement.getBoundingClientRect();
            graphCanvas.width = rect.width - 16;
            graphCanvas.height = 80;

            const w = graphCanvas.width;
            const h = graphCanvas.height;

            // Clear
            gctx.fillStyle = '#0a0a0f';
            gctx.fillRect(0, 0, w, h);

            // Grid lines
            gctx.strokeStyle = '#222';
            gctx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const y = (i / 4) * h;
                gctx.beginPath();
                gctx.moveTo(0, y);
                gctx.lineTo(w, y);
                gctx.stroke();
            }

            if (fitnessHistory.length < 2) return;

            // Draw fitness line
            const maxPoints = 50;
            const data = fitnessHistory.slice(-maxPoints);
            const step = w / (maxPoints - 1);

            gctx.beginPath();
            gctx.strokeStyle = '#00ff88';
            gctx.lineWidth = 2;

            data.forEach((val, i) => {
                const x = i * step;
                const y = h - (val / 100) * h;
                if (i === 0) gctx.moveTo(x, y);
                else gctx.lineTo(x, y);
            });
            gctx.stroke();

            // Fill under curve
            gctx.lineTo((data.length - 1) * step, h);
            gctx.lineTo(0, h);
            gctx.closePath();
            gctx.fillStyle = 'rgba(0, 255, 136, 0.1)';
            gctx.fill();

            // Current value marker
            const lastVal = data[data.length - 1];
            const lastX = (data.length - 1) * step;
            const lastY = h - (lastVal / 100) * h;
            gctx.fillStyle = '#00ff88';
            gctx.beginPath();
            gctx.arc(lastX, lastY, 4, 0, Math.PI * 2);
            gctx.fill();
        }

        function addLogEntry(message, type = 'info') {
            const log = document.getElementById('evolutionLog');
            const entry = document.createElement('div');
            entry.className = 'log-entry ' + type;
            entry.innerHTML = `
                <span class="gen">Gen ${generation}</span>
                <span class="time">${new Date().toLocaleTimeString()}</span>
                <div>${message}</div>
            `;
            log.insertBefore(entry, log.querySelector('.log-entry'));

            // Keep only last 50 entries
            while (log.querySelectorAll('.log-entry').length > 50) {
                log.removeChild(log.lastElementChild);
            }
        }

        async function evolveOnce() {
            generation++;
            document.getElementById('genBadge').textContent = `Generation ${generation}`;
            document.getElementById('genBadge').classList.add('evolving');
            document.getElementById('statusText').textContent = 'Running AI playtests...';

            addLogEntry('Starting AI playtest population...', 'analysis');

            // Run tests
            const analysis = await evolutionEngine.runGeneration(gameDNA, (progress) => {
                document.getElementById('testProgress').style.width = (progress * 100) + '%';
            });

            updateMetrics(analysis);

            // Log issues
            for (const issue of analysis.issues) {
                addLogEntry(`Issue: ${issue}`, 'analysis');
            }

            // Mutate
            const { dna: newDNA, changes } = evolutionEngine.mutate(gameDNA, analysis);
            gameDNA = newDNA;

            // Log changes
            for (const change of changes) {
                const direction = change.new > change.old ? '‚Üë' : '‚Üì';
                addLogEntry(`Mutated ${change.gene}: ${change.old.toFixed(2)} ‚Üí ${change.new.toFixed(2)} ${direction} (${change.reason})`, 'mutation');
            }

            updateGeneDisplay();

            evolutionHistory.push({
                generation,
                funScore: analysis.funScore,
                dna: { ...gameDNA },
                analysis
            });

            // Auto-save presets at milestones
            if (generation % 10 === 0) {
                evolutionEngine.savePreset(`Generation_${generation}`, gameDNA, analysis);
                addLogEntry(`Milestone preset saved: Generation_${generation}`, 'info');
                console.log(`[MILESTONE] Gen ${generation}: Fun=${Math.round(analysis.funScore)}%, Survival=${Math.round(analysis.survivalRate*100)}%, AvgDist=${Math.round(analysis.avgDistance)}`);
            }

            // Console log for autonomous tracking
            console.log(`[GEN ${generation}] Strategy: ${evolutionEngine.evolutionStrategy}, Fun: ${Math.round(analysis.funScore)}%, Issues: ${analysis.issues.length}, Changes: ${changes.length}`);

            document.getElementById('genBadge').classList.remove('evolving');
            document.getElementById('statusText').textContent = `Gen ${generation} complete. Fun score: ${Math.round(analysis.funScore)}%`;

            return analysis;
        }

        async function autoEvolve() {
            isAutoEvolving = !isAutoEvolving;
            const btn = document.getElementById('autoEvolve');
            btn.textContent = isAutoEvolving ? 'Stop Evolution' : 'Auto-Evolve';
            btn.classList.toggle('primary', !isAutoEvolving);

            // Autonomous evolution orchestrator
            let strategyPhase = 0;
            const strategies = [
                { name: 'conservative', cycles: 10, description: 'Baseline establishment' },
                { name: 'aggressive', cycles: 15, description: 'Aggressive exploration' },
                { name: 'balanced', cycles: 10, description: 'Refinement phase' },
                { name: 'themed', cycles: 5, description: 'Themed optimization', theme: 'better-flow' },
                { name: 'aggressive', cycles: 10, description: 'Second exploration' },
                { name: 'balanced', cycles: 10, description: 'Final refinement' }
            ];

            let cyclesInPhase = 0;
            let stagnantGenerations = 0;
            let lastBestScore = bestFunScore;

            while (isAutoEvolving) {
                // Switch strategy based on progress
                if (strategyPhase < strategies.length) {
                    const currentStrategy = strategies[strategyPhase];

                    if (cyclesInPhase === 0) {
                        evolutionEngine.setStrategy(currentStrategy.name, currentStrategy.theme);
                        addLogEntry(`Strategy: ${currentStrategy.description} (${currentStrategy.name})`, 'info');
                        console.log(`[STRATEGY CHANGE] Phase ${strategyPhase + 1}: ${currentStrategy.description}`);
                    }

                    cyclesInPhase++;

                    if (cyclesInPhase >= currentStrategy.cycles) {
                        cyclesInPhase = 0;
                        strategyPhase++;
                    }
                }

                const analysis = await evolveOnce();

                // Track stagnation
                if (analysis.funScore <= lastBestScore + 1) {
                    stagnantGenerations++;
                } else {
                    stagnantGenerations = 0;
                    lastBestScore = analysis.funScore;
                }

                // Adaptive strategy switching on stagnation
                if (stagnantGenerations >= 5 && generation > 15) {
                    addLogEntry(`Detected stagnation. Switching to aggressive exploration.`, 'info');
                    evolutionEngine.setStrategy('aggressive');
                    stagnantGenerations = 0;
                    console.log('[ADAPTIVE] Stagnation detected, switching to aggressive mode');
                }

                // Try themed evolution if stuck
                if (stagnantGenerations >= 8 && generation > 20) {
                    const themes = ['better-jumps', 'better-flow', 'more-exciting', 'more-rewarding'];
                    const randomTheme = themes[Math.floor(Math.random() * themes.length)];
                    addLogEntry(`Deep stagnation. Trying themed evolution: ${randomTheme}`, 'info');
                    evolutionEngine.setStrategy('themed', randomTheme);
                    stagnantGenerations = 0;
                    console.log(`[ADAPTIVE] Deep stagnation, trying theme: ${randomTheme}`);
                }

                // Stop if we've achieved target or hit generation limit
                if (analysis.funScore >= 80) {
                    addLogEntry(`Target achieved! Fun score: ${Math.round(analysis.funScore)}%`, 'info');
                    console.log(`[SUCCESS] Target fun score reached at generation ${generation}`);
                    evolutionEngine.savePreset('Target_Achieved', gameDNA, analysis);
                    isAutoEvolving = false;
                    btn.textContent = 'Auto-Evolve';
                    btn.classList.add('primary');
                } else if (generation >= 100) {
                    addLogEntry(`Reached generation limit (100). Best score: ${Math.round(bestFunScore)}%`, 'info');
                    console.log(`[LIMIT] Generation limit reached. Best: ${Math.round(bestFunScore)}%`);
                    isAutoEvolving = false;
                    btn.textContent = 'Auto-Evolve';
                    btn.classList.add('primary');
                }

                await new Promise(r => setTimeout(r, 500));
            }

            // Export data when stopping
            if (generation > 0) {
                console.log('[AUTO-EVOLVE] Stopped. Exporting evolution data...');
                exportEvolutionData();
            }
        }

        function playHuman() {
            humanPlaying = !humanPlaying;
            document.getElementById('playHuman').textContent = humanPlaying ? 'Stop Playing' : 'Play Yourself';
            document.getElementById('hudStatus').textContent = humanPlaying ? 'You are playing!' : 'AI Playtesting...';

            if (humanPlaying) {
                currentGame = new Game(gameDNA, false);
                gameLoop();
            }
        }

        const keys = { left: false, right: false, jump: false };
        document.addEventListener('keydown', e => {
            if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = true;
            if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = true;
            if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') {
                keys.jump = true;
                e.preventDefault();
            }
        });
        document.addEventListener('keyup', e => {
            if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = false;
            if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = false;
            if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') keys.jump = false;
        });

        function gameLoop() {
            if (!humanPlaying) return;

            if (currentGame.alive) {
                currentGame.update(keys);
                keys.jump = false; // Consume jump
            } else {
                // Respawn after death
                setTimeout(() => {
                    if (humanPlaying) {
                        currentGame = new Game(gameDNA, false);
                    }
                }, 1000);
            }

            currentGame.render();
            document.getElementById('hudScore').textContent = `Score: ${currentGame.score} | Distance: ${Math.round(currentGame.distance)}`;

            requestAnimationFrame(gameLoop);
        }

        // Export evolution data for analysis
        function exportEvolutionData() {
            const exportData = {
                timestamp: new Date().toISOString(),
                totalGenerations: generation,
                bestGeneration: bestGeneration,
                bestFunScore: bestFunScore,
                bestDNA: bestDNA,
                currentDNA: gameDNA,
                evolutionHistory: evolutionHistory,
                fitnessHistory: fitnessHistory,
                presets: Array.from(evolutionEngine.presets.entries()).map(([name, data]) => ({name, ...data}))
            };

            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `evolution-data-gen${generation}.json`;
            link.click();
            URL.revokeObjectURL(url);

            console.log('[EXPORT] Evolution data exported:', exportData);
            addLogEntry('Evolution data exported to JSON file', 'info');
        }

        // Create specialized game modes from best DNA
        function createGameModes() {
            if (!bestDNA) {
                console.log('[MODES] No best DNA found yet');
                return;
            }

            // Hardcore Mode - amp up difficulty
            const hardcoreDNA = {...bestDNA};
            hardcoreDNA.obstacleChance *= 1.5;
            hardcoreDNA.obstacleSpeed *= 1.3;
            hardcoreDNA.platformGap *= 1.2;
            hardcoreDNA.difficultyRamp *= 1.5;
            hardcoreDNA.movingPlatformChance *= 1.4;
            evolutionEngine.savePreset('Hardcore_Mode', hardcoreDNA, {funScore: 0, difficultyAssessment: 'hardcore'});

            // Casual Mode - make it easier and more relaxed
            const casualDNA = {...bestDNA};
            casualDNA.platformWidth *= 1.3;
            casualDNA.platformGap *= 0.8;
            casualDNA.jumpForce *= 1.2;
            casualDNA.coinChance *= 1.5;
            casualDNA.obstacleChance *= 0.6;
            casualDNA.scrollSpeed *= 0.8;
            evolutionEngine.savePreset('Casual_Mode', casualDNA, {funScore: 0, difficultyAssessment: 'casual'});

            // Speedrun Mode - fast and smooth
            const speedrunDNA = {...bestDNA};
            speedrunDNA.scrollSpeed *= 1.5;
            speedrunDNA.playerSpeed *= 1.4;
            speedrunDNA.jumpForce *= 1.2;
            speedrunDNA.gravity *= 1.1;
            speedrunDNA.platformGap *= 1.1;
            speedrunDNA.coinValue *= 2;
            evolutionEngine.savePreset('Speedrun_Mode', speedrunDNA, {funScore: 0, difficultyAssessment: 'speedrun'});

            console.log('[MODES] Created specialized game modes: Hardcore, Casual, Speedrun');
            addLogEntry('Created specialized game modes from best DNA', 'info');

            return {hardcore: hardcoreDNA, casual: casualDNA, speedrun: speedrunDNA};
        }

        // Make functions available via console
        window.exportEvolutionData = exportEvolutionData;
        window.createGameModes = createGameModes;
        window.setEvolutionStrategy = (strategy, theme) => {
            evolutionEngine.setStrategy(strategy, theme);
            console.log(`[STRATEGY] Set to ${strategy}${theme ? ` with theme ${theme}` : ''}`);
        };

        // Event listeners
        document.getElementById('evolveOnce').addEventListener('click', evolveOnce);
        document.getElementById('autoEvolve').addEventListener('click', autoEvolve);
        document.getElementById('playHuman').addEventListener('click', playHuman);
        document.getElementById('speedSlider').addEventListener('input', e => {
            evolutionSpeed = parseInt(e.target.value);
        });
        document.getElementById('loadBest').addEventListener('click', () => {
            if (bestDNA) {
                gameDNA = { ...bestDNA };
                updateGeneDisplay();
                addLogEntry(`Loaded best DNA from generation ${bestGeneration} (${Math.round(bestFunScore)}% fun)`, 'info');
                currentGame = new Game(gameDNA, false);
                currentGame.render();
            }
        });

        // Initial setup
        updateGeneDisplay();
        addLogEntry('Infinite Game Jam initialized. Click "Auto-Evolve" to begin!', 'info');

        // Render initial state
        currentGame.render();
    </script>
</body>
</html>
