{
  "schemaVersion": "1.0.0",
  "description": "State persistence system for local HTML applications. Enables seamless updates where cached state survives page refreshes and new HTML versions can pick up exactly where the old version left off.",

  "architecture": {
    "dataSloshing": "State flows: App → LocalStorage → Page Refresh → New App Version → Restored State",
    "components": [
      "Service Worker - Caches HTML for offline/fast loads",
      "State Manager - Saves/restores application state",
      "Version Manager - Handles migration between schema versions",
      "Auto-update Detector - Checks for new HTML versions"
    ],
    "updateFlow": [
      "1. User uses app (state changes continuously)",
      "2. Before unload: Save complete state to localStorage",
      "3. Page refreshes/updates",
      "4. Service worker serves new HTML (if available)",
      "5. New HTML loads, checks for saved state",
      "6. State migrates to new schema (if needed)",
      "7. App restores to exact previous state",
      "8. User continues seamlessly"
    ]
  },

  "stateSchema": {
    "description": "Complete snapshot of application state",
    "structure": {
      "metadata": {
        "version": "string - App version that created this state",
        "schemaVersion": "string - State schema version",
        "timestamp": "number - Unix timestamp when saved",
        "appId": "string - Application identifier (windows95-emulator, linux-vm, etc.)",
        "sessionId": "string - Unique session identifier",
        "saveReason": "string - manual|auto|beforeUnload|crash"
      },

      "userState": {
        "description": "User-specific data and preferences",
        "preferences": {
          "theme": "string",
          "volume": "number",
          "soundMuted": "boolean",
          "animations": "boolean",
          "any": "Custom preference key-value pairs"
        },
        "settings": {
          "description": "App-specific settings",
          "example": {
            "cpuSpeed": 2,
            "memory": 32,
            "enableNetwork": true
          }
        }
      },

      "applicationState": {
        "description": "Current state of the application",
        "windows": [
          {
            "id": "string - Unique window ID",
            "title": "string",
            "program": "string - Program name",
            "position": { "x": "number", "y": "number" },
            "size": { "width": "number", "height": "number" },
            "zIndex": "number",
            "minimized": "boolean",
            "maximized": "boolean",
            "content": "string - Serialized window content/state",
            "customState": "object - Program-specific state"
          }
        ],
        "desktopIcons": [
          {
            "label": "string",
            "emoji": "string",
            "position": { "x": "number", "y": "number" },
            "selected": "boolean"
          }
        ],
        "taskbar": {
          "startMenuOpen": "boolean",
          "buttons": ["array of active taskbar buttons"]
        },
        "clipboard": {
          "items": [],
          "operation": "string",
          "source": "string"
        }
      },

      "programStates": {
        "description": "Specific state for each program",
        "notepad": {
          "documents": [
            {
              "title": "string",
              "content": "string",
              "cursor": "number",
              "modified": "boolean"
            }
          ]
        },
        "calculator": {
          "display": "string",
          "memory": "number",
          "lastOperation": "string"
        },
        "paint": {
          "canvas": "string - Base64 encoded canvas data",
          "tool": "string",
          "color": "string"
        },
        "minesweeper": {
          "difficulty": "string",
          "board": "array",
          "gameState": "playing|won|lost",
          "timer": "number",
          "flagsRemaining": "number"
        },
        "solitaire": {
          "deck": "array",
          "tableau": "array",
          "foundation": "array",
          "score": "number",
          "moves": "number"
        },
        "fileExplorer": {
          "currentPath": "string",
          "fileSystem": "object - Virtual file system",
          "selectedItems": []
        },
        "recycleBin": {
          "items": "array of deleted items"
        },
        "terminal": {
          "history": "array of command history",
          "currentDirectory": "string",
          "output": "array of terminal output"
        }
      },

      "systemState": {
        "description": "System-level state",
        "time": "number - System time",
        "uptime": "number - Session uptime in ms",
        "performance": {
          "fps": "number",
          "memory": "number",
          "cpu": "number"
        }
      },

      "customData": {
        "description": "Arbitrary app-specific data",
        "note": "Apps can store any custom state here"
      }
    }
  },

  "statePersistence": {
    "saveStrategies": {
      "continuous": {
        "description": "Save state continuously (debounced)",
        "interval": 5000,
        "debounce": true,
        "note": "Good for frequently changing state"
      },
      "beforeUnload": {
        "description": "Save when page is about to close",
        "event": "beforeunload",
        "note": "Ensures no state loss on close/refresh"
      },
      "manual": {
        "description": "User triggers save manually",
        "trigger": "User clicks save button",
        "note": "For explicit save points"
      },
      "milestone": {
        "description": "Save at significant events",
        "examples": [
          "Window opened/closed",
          "Program launched",
          "Game completed",
          "File saved"
        ]
      }
    },

    "storageStrategy": {
      "primary": "localStorage",
      "fallback": "IndexedDB for large states",
      "maxSize": "5-10MB for localStorage",
      "compression": "Optional JSON compression for large states",
      "encryption": "Optional for sensitive data"
    },

    "storageKeys": {
      "currentState": "app-state-current",
      "previousState": "app-state-previous",
      "backupState": "app-state-backup",
      "stateHistory": "app-state-history",
      "metadata": "app-state-metadata"
    }
  },

  "versionMigration": {
    "description": "Migrate state between schema versions",
    "process": [
      "1. Detect saved state version",
      "2. Compare with current app version",
      "3. Run migration functions if needed",
      "4. Update state to current schema",
      "5. Save migrated state"
    ],

    "migrationRegistry": {
      "description": "Map of migration functions",
      "example": {
        "1.0.0->1.1.0": {
          "description": "Add new window property",
          "function": "function migrate_1_0_to_1_1(state) { ... }"
        },
        "1.1.0->2.0.0": {
          "description": "Restructure file system",
          "function": "function migrate_1_1_to_2_0(state) { ... }"
        }
      }
    },

    "backwardCompatibility": {
      "strategy": "New versions can read old state schemas",
      "maxVersionGap": "3 major versions",
      "note": "Beyond 3 versions, migration may be lossy"
    }
  },

  "serviceWorkerCaching": {
    "description": "Cache HTML for offline/fast loads + updates",
    "strategy": "Cache-first with background update",
    "cacheKeys": {
      "htmlCache": "html-cache-v1",
      "assetCache": "asset-cache-v1",
      "stateCache": "state-cache-v1"
    },

    "updateDetection": {
      "method": "ETag or version header comparison",
      "frequency": "Check on every page load (in background)",
      "notification": "Prompt user when update available",
      "autoUpdate": "Optional immediate or on-next-load"
    },

    "offlineFirst": {
      "description": "App works completely offline",
      "fallback": "Serve cached HTML if network fails",
      "sync": "Sync state when online if multi-device"
    }
  },

  "stateRestoration": {
    "onLoad": [
      "1. Check for saved state in localStorage",
      "2. Validate state schema version",
      "3. Migrate if needed",
      "4. Restore application state",
      "5. Restore window positions and content",
      "6. Restore program states",
      "7. Resume user session exactly where they left off"
    ],

    "gracefulDegradation": {
      "corruptState": "Start fresh if state is corrupted",
      "partialState": "Restore what's valid, reset invalid parts",
      "missingState": "Use default initial state"
    },

    "userControl": {
      "clearState": "User can clear saved state",
      "exportState": "User can export state as JSON",
      "importState": "User can import state from JSON",
      "stateHistory": "View/restore previous states"
    }
  },

  "implementationPattern": {
    "description": "How to implement in HTML applications",

    "stateManager": {
      "description": "JavaScript class to manage state",
      "code": "class StateManager {\n  constructor(appId, schemaVersion) {\n    this.appId = appId;\n    this.schemaVersion = schemaVersion;\n    this.saveDebounced = this.debounce(this.save.bind(this), 5000);\n    window.addEventListener('beforeunload', () => this.save('beforeUnload'));\n  }\n\n  save(reason = 'auto') {\n    const state = this.captureState();\n    state.metadata.saveReason = reason;\n    localStorage.setItem('app-state-current', JSON.stringify(state));\n  }\n\n  restore() {\n    const saved = localStorage.getItem('app-state-current');\n    if (saved) {\n      const state = JSON.parse(saved);\n      return this.migrate(state);\n    }\n    return null;\n  }\n\n  captureState() {\n    return {\n      metadata: {\n        version: APP_VERSION,\n        schemaVersion: this.schemaVersion,\n        timestamp: Date.now(),\n        appId: this.appId\n      },\n      // ... capture all app state\n    };\n  }\n\n  migrate(state) {\n    // Run migration functions\n    return state;\n  }\n}"
    },

    "integration": {
      "description": "How to integrate into existing apps",
      "steps": [
        "1. Add StateManager class to HTML",
        "2. Initialize on DOMContentLoaded",
        "3. Call restore() after initialization",
        "4. Call save() on state changes (debounced)",
        "5. Add beforeunload listener for final save"
      ]
    }
  },

  "advancedFeatures": {
    "multiTab": {
      "description": "Sync state across multiple tabs",
      "method": "BroadcastChannel API or storage events",
      "conflict": "Last write wins or merge strategies"
    },

    "cloudSync": {
      "description": "Optional cloud state sync",
      "method": "POST state to API endpoint",
      "auth": "User authentication required",
      "merge": "Merge local and cloud state"
    },

    "timeTravel": {
      "description": "Undo/redo with state snapshots",
      "method": "Store state history array",
      "limit": "Keep last N states",
      "navigation": "Jump to any previous state"
    },

    "stateAnalytics": {
      "description": "Track state changes for insights",
      "metrics": [
        "State size over time",
        "Save frequency",
        "Program usage patterns",
        "Session duration"
      ]
    }
  },

  "exampleUsage": {
    "windows95Emulator": {
      "appId": "windows95-emulator",
      "schemaVersion": "1.0.0",
      "stateKeys": [
        "Desktop icons and positions",
        "Open windows and their states",
        "Program-specific data (notepad text, calculator display, etc.)",
        "System settings (volume, mute, etc.)",
        "File system state",
        "Recycle bin contents",
        "Clipboard data"
      ],
      "saveStrategy": "Continuous (5s debounced) + beforeunload",
      "restoreStrategy": "Full state restoration on load"
    },

    "linuxWasmVM": {
      "appId": "linux-wasm-vm",
      "schemaVersion": "1.0.0",
      "stateKeys": [
        "VM state (running/paused/stopped)",
        "Filesystem snapshot",
        "Terminal history",
        "Running processes",
        "Network state",
        "Memory snapshot"
      ],
      "saveStrategy": "Manual snapshots + beforeunload",
      "restoreStrategy": "Resume VM from snapshot"
    }
  },

  "benefits": {
    "userExperience": [
      "Never lose work on accidental refresh",
      "Seamless app updates without interruption",
      "Resume exactly where you left off",
      "Works offline",
      "Fast load times (cached HTML)"
    ],
    "developer": [
      "Easy to implement",
      "Version migration built-in",
      "State as single source of truth",
      "Easy debugging (inspect localStorage)",
      "Portable state (export/import)"
    ]
  },

  "implementation": {
    "nextSteps": [
      "1. Add StateManager class to windows95-emulator.html",
      "2. Add Service Worker for HTML caching",
      "3. Implement state capture for all systems",
      "4. Implement state restoration logic",
      "5. Add version migration framework",
      "6. Test save/restore cycle",
      "7. Add user controls (clear state, export, import)"
    ]
  }
}
