<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Physics Simulator Lab</title>
    <meta name="description" content="Interactive physics simulator teaching mechanics, gravity, collisions, projectile motion, pendulums, springs, and Newton's laws through hands-on experiments">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #e0e0e0;
            height: 100vh;
            overflow: hidden;
        }

        #app-container {
            display: flex;
            height: 100vh;
        }

        #simulation-section {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        #header {
            background: rgba(20, 20, 40, 0.95);
            padding: 15px 30px;
            border-bottom: 2px solid #00d9ff;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        h1 {
            font-size: 22px;
            color: #00d9ff;
            text-shadow: 0 0 10px rgba(0, 217, 255, 0.5);
        }

        #header-controls {
            display: flex;
            gap: 10px;
        }

        button {
            padding: 8px 16px;
            background: linear-gradient(135deg, #00d9ff 0%, #0099cc 100%);
            color: #0a0a1a;
            border: none;
            border-radius: 5px;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 217, 255, 0.4);
        }

        button.danger {
            background: linear-gradient(135deg, #ff006e 0%, #cc0055 100%);
            color: #fff;
        }

        #canvas-container {
            flex: 1;
            position: relative;
            background: linear-gradient(180deg, #0a0a1a 0%, #1a1a2e 100%);
            border-bottom: 1px solid rgba(0, 217, 255, 0.2);
        }

        #physics-canvas {
            width: 100%;
            height: 100%;
            display: block;
            cursor: crosshair;
        }

        #info-panel {
            background: rgba(20, 20, 40, 0.95);
            padding: 20px 30px;
            border-top: 1px solid rgba(0, 217, 255, 0.2);
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }

        .info-item {
            text-align: center;
        }

        .info-label {
            font-size: 10px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .info-value {
            font-size: 16px;
            color: #00d9ff;
            font-weight: bold;
            margin-top: 5px;
        }

        #controls-panel {
            width: 320px;
            background: rgba(20, 20, 40, 0.95);
            border-left: 1px solid rgba(0, 217, 255, 0.2);
            overflow-y: auto;
            padding: 20px;
        }

        .control-section {
            margin-bottom: 25px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 8px;
            border: 1px solid rgba(0, 217, 255, 0.1);
        }

        .control-section h2 {
            font-size: 14px;
            margin-bottom: 15px;
            color: #00d9ff;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .control-group {
            margin-bottom: 12px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-size: 11px;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .value-display {
            display: inline-block;
            float: right;
            color: #00d9ff;
            font-weight: bold;
            font-size: 11px;
        }

        input[type="range"] {
            width: 100%;
            height: 4px;
            border-radius: 2px;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #00d9ff;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 217, 255, 0.5);
        }

        input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #00d9ff;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 10px rgba(0, 217, 255, 0.5);
        }

        select {
            width: 100%;
            padding: 8px;
            background: rgba(255, 255, 255, 0.05);
            color: #e0e0e0;
            border: 1px solid rgba(0, 217, 255, 0.3);
            border-radius: 5px;
            font-size: 12px;
            cursor: pointer;
        }

        .simulation-btns {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 10px;
        }

        .sim-btn {
            padding: 10px;
            background: rgba(0, 217, 255, 0.1);
            border: 1px solid rgba(0, 217, 255, 0.3);
            border-radius: 5px;
            color: #e0e0e0;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .sim-btn:hover {
            background: rgba(0, 217, 255, 0.2);
            border-color: #00d9ff;
        }

        .sim-btn.active {
            background: linear-gradient(135deg, #00d9ff 0%, #0099cc 100%);
            color: #0a0a1a;
            border-color: #00d9ff;
        }

        @media (max-width: 1024px) {
            #app-container {
                flex-direction: column;
            }
            #controls-panel {
                width: 100%;
                height: 300px;
            }
        }
    </style>
</head>
<body>
    <div id="app-container">
        <div id="simulation-section">
            <div id="header">
                <h1>üî¨ Physics Simulator Lab</h1>
                <div id="header-controls">
                    <button id="playBtn">‚ñ∂Ô∏è Play</button>
                    <button id="resetBtn" class="danger">üîÑ Reset</button>
                    <button id="clearBtn" class="danger">üóëÔ∏è Clear</button>
                </div>
            </div>

            <div id="canvas-container">
                <canvas id="physics-canvas"></canvas>
            </div>

            <div id="info-panel">
                <div class="info-grid">
                    <div class="info-item">
                        <div class="info-label">Objects</div>
                        <div class="info-value" id="objectCount">0</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Total Energy</div>
                        <div class="info-value" id="energyValue">0 J</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Total Momentum</div>
                        <div class="info-value" id="momentumValue">0 kg‚ãÖm/s</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Time</div>
                        <div class="info-value" id="timeValue">0.0 s</div>
                    </div>
                </div>
            </div>
        </div>

        <div id="controls-panel">
            <div class="control-section">
                <h2>Simulation Type</h2>
                <div class="simulation-btns">
                    <div class="sim-btn active" data-sim="freefall">Free Fall</div>
                    <div class="sim-btn" data-sim="projectile">Projectile</div>
                    <div class="sim-btn" data-sim="collision">Collision</div>
                    <div class="sim-btn" data-sim="pendulum">Pendulum</div>
                    <div class="sim-btn" data-sim="spring">Spring</div>
                    <div class="sim-btn" data-sim="orbit">Orbit</div>
                </div>
            </div>

            <div class="control-section">
                <h2>Physics Parameters</h2>
                <div class="control-group">
                    <label>Gravity <span class="value-display" id="gravityValue">9.8</span> m/s¬≤</label>
                    <input type="range" id="gravity" min="0" max="20" step="0.1" value="9.8">
                </div>
                <div class="control-group">
                    <label>Air Resistance <span class="value-display" id="dragValue">0.0</span></label>
                    <input type="range" id="drag" min="0" max="1" step="0.01" value="0">
                </div>
                <div class="control-group">
                    <label>Elasticity <span class="value-display" id="elasticityValue">0.8</span></label>
                    <input type="range" id="elasticity" min="0" max="1" step="0.05" value="0.8">
                </div>
                <div class="control-group">
                    <label>Time Scale <span class="value-display" id="timeScaleValue">1.0x</span></label>
                    <input type="range" id="timeScale" min="0.1" max="3" step="0.1" value="1">
                </div>
            </div>

            <div class="control-section">
                <h2>Object Properties</h2>
                <div class="control-group">
                    <label>Mass <span class="value-display" id="massValue">5</span> kg</label>
                    <input type="range" id="mass" min="1" max="20" value="5">
                </div>
                <div class="control-group">
                    <label>Size <span class="value-display" id="sizeValue">20</span> px</label>
                    <input type="range" id="size" min="10" max="50" value="20">
                </div>
                <div class="control-group">
                    <label>Launch Speed <span class="value-display" id="speedValue">15</span> m/s</label>
                    <input type="range" id="speed" min="5" max="50" value="15">
                </div>
                <div class="control-group">
                    <label>Launch Angle <span class="value-display" id="angleValue">45</span>¬∞</label>
                    <input type="range" id="angle" min="0" max="90" value="45">
                </div>
            </div>

            <div class="control-section">
                <h2>Display Options</h2>
                <div class="control-group">
                    <label>Show Vectors</label>
                    <select id="showVectors">
                        <option value="none">None</option>
                        <option value="velocity">Velocity</option>
                        <option value="force">Force</option>
                        <option value="both" selected>Both</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Show Trails</label>
                    <select id="showTrails">
                        <option value="none">None</option>
                        <option value="short">Short</option>
                        <option value="medium" selected>Medium</option>
                        <option value="long">Long</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Show Grid</label>
                    <select id="showGrid">
                        <option value="false">No</option>
                        <option value="true" selected>Yes</option>
                    </select>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ========================================
        // Canvas Setup
        // ========================================
        const canvas = document.getElementById('physics-canvas');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            canvas.width = canvas.parentElement.clientWidth;
            canvas.height = canvas.parentElement.clientHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // ========================================
        // Physics Object Class
        // ========================================
        class PhysicsObject {
            constructor(x, y, vx, vy, mass, radius) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.mass = mass;
                this.radius = radius;
                this.trail = [];
                this.color = `hsl(${Math.random() * 360}, 70%, 60%)`;
            }

            update(dt) {
                const gravity = parseFloat(document.getElementById('gravity').value);
                const drag = parseFloat(document.getElementById('drag').value);

                // Apply gravity
                this.vy += gravity * dt * 50;

                // Apply drag
                if (drag > 0) {
                    const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                    const dragForce = drag * speed * 0.1;
                    if (speed > 0) {
                        this.vx -= (this.vx / speed) * dragForce * dt;
                        this.vy -= (this.vy / speed) * dragForce * dt;
                    }
                }

                // Update position
                this.x += this.vx * dt;
                this.y += this.vy * dt;

                // Trail
                this.trail.push({ x: this.x, y: this.y });
                const trailLength = {
                    none: 0,
                    short: 10,
                    medium: 30,
                    long: 100
                }[document.getElementById('showTrails').value] || 30;

                if (this.trail.length > trailLength) {
                    this.trail.shift();
                }

                // Boundary collision
                const elasticity = parseFloat(document.getElementById('elasticity').value);

                if (this.y + this.radius > canvas.height) {
                    this.y = canvas.height - this.radius;
                    this.vy *= -elasticity;
                    this.vx *= (1 - (1 - elasticity) * 0.3); // friction
                }

                if (this.y - this.radius < 0) {
                    this.y = this.radius;
                    this.vy *= -elasticity;
                }

                if (this.x + this.radius > canvas.width) {
                    this.x = canvas.width - this.radius;
                    this.vx *= -elasticity;
                }

                if (this.x - this.radius < 0) {
                    this.x = this.radius;
                    this.vx *= -elasticity;
                }
            }

            draw() {
                // Trail
                if (this.trail.length > 1) {
                    ctx.strokeStyle = this.color;
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = 0.5;
                    ctx.beginPath();
                    ctx.moveTo(this.trail[0].x, this.trail[0].y);
                    for (let i = 1; i < this.trail.length; i++) {
                        ctx.lineTo(this.trail[i].x, this.trail[i].y);
                    }
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }

                // Object
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;

                // Vectors
                const showVectors = document.getElementById('showVectors').value;

                if (showVectors === 'velocity' || showVectors === 'both') {
                    this.drawVector(this.vx * 2, this.vy * 2, '#00d9ff');
                }

                if (showVectors === 'force' || showVectors === 'both') {
                    const gravity = parseFloat(document.getElementById('gravity').value);
                    this.drawVector(0, gravity * this.mass * 0.5, '#ff006e');
                }
            }

            drawVector(vx, vy, color) {
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x + vx, this.y + vy);
                ctx.stroke();

                // Arrow head
                const angle = Math.atan2(vy, vx);
                const headLength = 10;
                ctx.beginPath();
                ctx.moveTo(this.x + vx, this.y + vy);
                ctx.lineTo(
                    this.x + vx - headLength * Math.cos(angle - Math.PI / 6),
                    this.y + vy - headLength * Math.sin(angle - Math.PI / 6)
                );
                ctx.moveTo(this.x + vx, this.y + vy);
                ctx.lineTo(
                    this.x + vx - headLength * Math.cos(angle + Math.PI / 6),
                    this.y + vy - headLength * Math.sin(angle + Math.PI / 6)
                );
                ctx.stroke();
            }
        }

        // ========================================
        // Simulation State
        // ========================================
        let objects = [];
        let isPlaying = false;
        let simulationTime = 0;
        let currentSimulation = 'freefall';

        // ========================================
        // Simulation Modes
        // ========================================
        function setupFreefall() {
            objects = [];
            const mass = parseFloat(document.getElementById('mass').value);
            const radius = parseFloat(document.getElementById('size').value);
            objects.push(new PhysicsObject(canvas.width / 2, 100, 0, 0, mass, radius));
        }

        function setupProjectile() {
            objects = [];
            const mass = parseFloat(document.getElementById('mass').value);
            const radius = parseFloat(document.getElementById('size').value);
            const speed = parseFloat(document.getElementById('speed').value);
            const angle = parseFloat(document.getElementById('angle').value) * Math.PI / 180;

            const vx = speed * Math.cos(angle) * 10;
            const vy = -speed * Math.sin(angle) * 10;

            objects.push(new PhysicsObject(50, canvas.height - 50, vx, vy, mass, radius));
        }

        function setupCollision() {
            objects = [];
            const mass = parseFloat(document.getElementById('mass').value);
            const radius = parseFloat(document.getElementById('size').value);

            objects.push(new PhysicsObject(canvas.width * 0.3, canvas.height / 2, 100, 0, mass, radius));
            objects.push(new PhysicsObject(canvas.width * 0.7, canvas.height / 2, -100, 0, mass, radius));
        }

        function setupPendulum() {
            objects = [];
            const mass = parseFloat(document.getElementById('mass').value);
            const radius = parseFloat(document.getElementById('size').value);
            const angle = parseFloat(document.getElementById('angle').value) * Math.PI / 180;
            const length = 200;

            const pivotX = canvas.width / 2;
            const pivotY = 100;
            const x = pivotX + length * Math.sin(angle);
            const y = pivotY + length * Math.cos(angle);

            const obj = new PhysicsObject(x, y, 0, 0, mass, radius);
            obj.isPendulum = true;
            obj.pivotX = pivotX;
            obj.pivotY = pivotY;
            obj.length = length;

            objects.push(obj);
        }

        function setupSpring() {
            objects = [];
            const mass = parseFloat(document.getElementById('mass').value);
            const radius = parseFloat(document.getElementById('size').value);

            const obj = new PhysicsObject(canvas.width / 2, canvas.height / 2 + 100, 0, 0, mass, radius);
            obj.isSpring = true;
            obj.anchorY = 100;
            obj.restLength = 200;
            obj.springConstant = 0.5;

            objects.push(obj);
        }

        function setupOrbit() {
            objects = [];
            const mass = parseFloat(document.getElementById('mass').value);
            const radius = parseFloat(document.getElementById('size').value);

            // Central body
            const sun = new PhysicsObject(canvas.width / 2, canvas.height / 2, 0, 0, mass * 50, radius * 3);
            sun.isStatic = true;
            sun.color = '#ffff00';
            objects.push(sun);

            // Orbiting body
            const orbitRadius = 200;
            const speed = Math.sqrt(500 / orbitRadius) * 10;
            objects.push(new PhysicsObject(canvas.width / 2 + orbitRadius, canvas.height / 2, 0, speed, mass, radius));
        }

        // ========================================
        // Update Physics
        // ========================================
        function updatePhysics(dt) {
            objects.forEach(obj => {
                if (obj.isStatic) return;

                if (obj.isPendulum) {
                    // Pendulum physics
                    const dx = obj.x - obj.pivotX;
                    const dy = obj.y - obj.pivotY;
                    const angle = Math.atan2(dx, dy);
                    const gravity = parseFloat(document.getElementById('gravity').value);
                    const angularAccel = -(gravity / obj.length) * Math.sin(angle) / 10;

                    obj.angularVel = (obj.angularVel || 0) + angularAccel * dt;
                    obj.angularVel *= 0.999; // damping

                    const newAngle = angle + obj.angularVel * dt;
                    obj.x = obj.pivotX + obj.length * Math.sin(newAngle);
                    obj.y = obj.pivotY + obj.length * Math.cos(newAngle);

                    obj.vx = (obj.x - dx) / dt;
                    obj.vy = (obj.y - dy) / dt;

                } else if (obj.isSpring) {
                    // Spring physics
                    const extension = obj.y - (obj.anchorY + obj.restLength);
                    const springForce = -obj.springConstant * extension;
                    const gravity = parseFloat(document.getElementById('gravity').value);

                    obj.vy += (springForce / obj.mass + gravity) * dt * 50;
                    obj.vy *= 0.99; // damping

                    obj.y += obj.vy * dt;
                } else {
                    obj.update(dt);
                }

                // Trail management
                obj.trail.push({ x: obj.x, y: obj.y });
                const trailLength = {
                    none: 0,
                    short: 10,
                    medium: 30,
                    long: 100
                }[document.getElementById('showTrails').value] || 30;

                if (obj.trail.length > trailLength) {
                    obj.trail.shift();
                }
            });

            // Collision detection
            for (let i = 0; i < objects.length; i++) {
                for (let j = i + 1; j < objects.length; j++) {
                    const obj1 = objects[i];
                    const obj2 = objects[j];

                    if (obj1.isStatic && obj2.isStatic) continue;

                    const dx = obj2.x - obj1.x;
                    const dy = obj2.y - obj1.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < obj1.radius + obj2.radius) {
                        // Collision response
                        const nx = dx / dist;
                        const ny = dy / dist;

                        const relVelX = obj2.vx - obj1.vx;
                        const relVelY = obj2.vy - obj1.vy;
                        const impactSpeed = relVelX * nx + relVelY * ny;

                        if (impactSpeed < 0) continue; // Moving apart

                        const elasticity = parseFloat(document.getElementById('elasticity').value);
                        const impulse = -(1 + elasticity) * impactSpeed / (1 / obj1.mass + 1 / obj2.mass);

                        if (!obj1.isStatic) {
                            obj1.vx -= impulse * nx / obj1.mass;
                            obj1.vy -= impulse * ny / obj1.mass;
                        }

                        if (!obj2.isStatic) {
                            obj2.vx += impulse * nx / obj2.mass;
                            obj2.vy += impulse * ny / obj2.mass;
                        }

                        // Separate objects
                        const overlap = (obj1.radius + obj2.radius) - dist;
                        if (!obj1.isStatic && !obj2.isStatic) {
                            obj1.x -= nx * overlap * 0.5;
                            obj1.y -= ny * overlap * 0.5;
                            obj2.x += nx * overlap * 0.5;
                            obj2.y += ny * overlap * 0.5;
                        } else if (!obj1.isStatic) {
                            obj1.x -= nx * overlap;
                            obj1.y -= ny * overlap;
                        } else {
                            obj2.x += nx * overlap;
                            obj2.y += ny * overlap;
                        }
                    }
                }
            }

            // Orbital gravity
            if (currentSimulation === 'orbit') {
                for (let i = 0; i < objects.length; i++) {
                    if (objects[i].isStatic) continue;

                    for (let j = 0; j < objects.length; j++) {
                        if (i === j || !objects[j].isStatic) continue;

                        const dx = objects[j].x - objects[i].x;
                        const dy = objects[j].y - objects[i].y;
                        const distSq = dx * dx + dy * dy;
                        const dist = Math.sqrt(distSq);

                        if (dist > 0) {
                            const force = 500 * objects[j].mass / distSq;
                            objects[i].vx += (dx / dist) * force * dt;
                            objects[i].vy += (dy / dist) * force * dt;
                        }
                    }
                }
            }
        }

        // ========================================
        // Draw Scene
        // ========================================
        function drawScene() {
            ctx.fillStyle = 'rgba(10, 10, 26, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Grid
            if (document.getElementById('showGrid').value === 'true') {
                ctx.strokeStyle = 'rgba(0, 217, 255, 0.1)';
                ctx.lineWidth = 1;

                for (let x = 0; x < canvas.width; x += 50) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.height);
                    ctx.stroke();
                }

                for (let y = 0; y < canvas.height; y += 50) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                }
            }

            // Draw pendulum rod
            objects.forEach(obj => {
                if (obj.isPendulum) {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(obj.pivotX, obj.pivotY);
                    ctx.lineTo(obj.x, obj.y);
                    ctx.stroke();

                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(obj.pivotX, obj.pivotY, 5, 0, Math.PI * 2);
                    ctx.fill();
                }

                if (obj.isSpring) {
                    // Draw spring
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.lineWidth = 2;
                    const segments = 10;
                    const amplitude = 10;

                    ctx.beginPath();
                    ctx.moveTo(canvas.width / 2, obj.anchorY);

                    for (let i = 0; i <= segments; i++) {
                        const y = obj.anchorY + (obj.y - obj.anchorY) * (i / segments);
                        const x = canvas.width / 2 + (i % 2 === 0 ? amplitude : -amplitude);
                        ctx.lineTo(x, y);
                    }

                    ctx.stroke();

                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(canvas.width / 2, obj.anchorY, 5, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            // Draw objects
            objects.forEach(obj => obj.draw());
        }

        // ========================================
        // Animation Loop
        // ========================================
        let lastTime = performance.now();

        function animate(currentTime) {
            requestAnimationFrame(animate);

            const dt = Math.min((currentTime - lastTime) / 1000, 0.033);
            lastTime = currentTime;

            if (isPlaying) {
                const timeScale = parseFloat(document.getElementById('timeScale').value);
                updatePhysics(dt * timeScale);
                simulationTime += dt * timeScale;
            }

            drawScene();
            updateStats();
        }

        // ========================================
        // Update Stats
        // ========================================
        function updateStats() {
            document.getElementById('objectCount').textContent = objects.length;
            document.getElementById('timeValue').textContent = simulationTime.toFixed(1) + ' s';

            let totalEnergy = 0;
            let totalMomentumX = 0;
            let totalMomentumY = 0;

            objects.forEach(obj => {
                if (obj.isStatic) return;

                const ke = 0.5 * obj.mass * (obj.vx * obj.vx + obj.vy * obj.vy);
                const gravity = parseFloat(document.getElementById('gravity').value);
                const pe = obj.mass * gravity * (canvas.height - obj.y) / 10;
                totalEnergy += ke + pe;

                totalMomentumX += obj.mass * obj.vx;
                totalMomentumY += obj.mass * obj.vy;
            });

            document.getElementById('energyValue').textContent = totalEnergy.toFixed(1) + ' J';
            const momentum = Math.sqrt(totalMomentumX * totalMomentumX + totalMomentumY * totalMomentumY);
            document.getElementById('momentumValue').textContent = momentum.toFixed(1) + ' kg‚ãÖm/s';
        }

        // ========================================
        // UI Controls
        // ========================================
        document.getElementById('playBtn').addEventListener('click', function() {
            isPlaying = !isPlaying;
            this.textContent = isPlaying ? '‚è∏Ô∏è Pause' : '‚ñ∂Ô∏è Play';
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            simulationTime = 0;
            setupSimulation(currentSimulation);
        });

        document.getElementById('clearBtn').addEventListener('click', () => {
            objects = [];
            simulationTime = 0;
        });

        document.querySelectorAll('.sim-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.sim-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentSimulation = btn.dataset.sim;
                simulationTime = 0;
                setupSimulation(currentSimulation);
            });
        });

        function setupSimulation(type) {
            switch(type) {
                case 'freefall': setupFreefall(); break;
                case 'projectile': setupProjectile(); break;
                case 'collision': setupCollision(); break;
                case 'pendulum': setupPendulum(); break;
                case 'spring': setupSpring(); break;
                case 'orbit': setupOrbit(); break;
            }
        }

        // Update value displays
        ['gravity', 'drag', 'elasticity', 'timeScale', 'mass', 'size', 'speed', 'angle'].forEach(id => {
            const element = document.getElementById(id);
            element.addEventListener('input', () => {
                let value = element.value;
                if (id === 'timeScale') value += 'x';
                else if (id === 'angle') value += '¬∞';
                document.getElementById(id + 'Value').textContent = value;
            });
        });

        // Canvas click to add objects
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const mass = parseFloat(document.getElementById('mass').value);
            const radius = parseFloat(document.getElementById('size').value);

            objects.push(new PhysicsObject(x, y, 0, 0, mass, radius));
        });

        // Initialize
        setupFreefall();
        animate(performance.now());
    </script>
</body>
</html>