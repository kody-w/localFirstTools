<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Nexus Hub - Gesture World Explorer</title>
    <link rel="icon" type="image/x-icon" href="data:image/x-icon;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
            -webkit-overflow-scrolling: touch;
        }

        #three-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        /* Hand Tracking UI */
        .hand-tracking-container {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 240px;
            height: 180px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid rgba(138, 56, 236, 0.5);
            border-radius: 15px;
            overflow: hidden;
            z-index: 2000;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }

        .hand-tracking-container.minimized {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            cursor: pointer;
        }

        .hand-tracking-container.minimized .webcam-feed,
        .hand-tracking-container.minimized .gesture-overlay,
        .hand-tracking-container.minimized .gesture-status {
            display: none;
        }

        .hand-tracking-container.minimized::after {
            content: '✋';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 30px;
        }

        .webcam-feed {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }

        .gesture-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
        }

        .gesture-status {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(138, 56, 236, 0.9);
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Hand Cursor */
        .hand-cursor {
            position: fixed;
            width: 50px;
            height: 50px;
            border: 3px solid rgba(6, 255, 165, 0.8);
            border-radius: 50%;
            pointer-events: none;
            z-index: 9999;
            display: none;
            transition: all 0.1s ease;
            box-shadow: 0 0 30px rgba(6, 255, 165, 0.5);
            background: radial-gradient(circle, rgba(6, 255, 165, 0.3), transparent);
        }

        .hand-cursor.pinching {
            background: radial-gradient(circle, rgba(6, 255, 165, 0.6), rgba(6, 255, 165, 0.2));
            transform: scale(0.8);
            border-color: rgba(255, 255, 255, 0.9);
        }

        .hand-cursor.pointing {
            border-color: rgba(255, 106, 0, 0.8);
            box-shadow: 0 0 30px rgba(255, 106, 0, 0.5);
        }

        /* Gesture Instructions */
        .gesture-guide {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            padding: 20px;
            z-index: 1500;
            max-width: 300px;
            transition: all 0.3s ease;
        }

        .gesture-guide.hidden {
            opacity: 0;
            pointer-events: none;
            transform: translateX(20px);
        }

        .gesture-guide h3 {
            color: #06ffa5;
            font-size: 16px;
            margin-bottom: 15px;
            font-weight: 500;
        }

        .gesture-item {
            display: flex;
            align-items: center;
            margin: 10px 0;
            color: rgba(255, 255, 255, 0.8);
            font-size: 13px;
        }

        .gesture-icon {
            font-size: 24px;
            margin-right: 15px;
            width: 40px;
            text-align: center;
        }

        .gesture-description {
            flex: 1;
        }

        /* Gesture Feedback */
        .gesture-feedback {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(138, 56, 236, 0.9);
            color: white;
            padding: 20px 40px;
            border-radius: 30px;
            font-size: 24px;
            font-weight: bold;
            opacity: 0;
            pointer-events: none;
            z-index: 3000;
            transition: all 0.3s ease;
        }

        .gesture-feedback.show {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1.1);
        }

        /* Camera Permission Error */
        .camera-error {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            padding: 40px;
            background: rgba(20, 20, 40, 0.95);
            border: 2px solid rgba(255, 0, 0, 0.5);
            border-radius: 20px;
            z-index: 2000;
            max-width: 500px;
            box-shadow: 0 0 50px rgba(255, 0, 0, 0.3);
        }

        .camera-error h3 {
            color: #ff6b6b;
            margin-bottom: 20px;
            font-size: 24px;
        }

        .camera-error p {
            margin: 15px 0;
            color: rgba(255, 255, 255, 0.8);
            line-height: 1.6;
        }

        .camera-error .error-details {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.6);
            margin: 20px 0;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            text-align: left;
        }

        .camera-error button {
            background: linear-gradient(45deg, #ff006e, #8338ec);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            margin: 10px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .camera-error button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(255, 0, 110, 0.4);
        }

        .camera-error .fallback-btn {
            background: linear-gradient(45deg, #666, #999);
        }

        /* Interactive Elements with Gesture Indicators */
        .gesture-interactive {
            position: relative;
            transition: all 0.3s ease;
        }

        .gesture-interactive::after {
            content: '';
            position: absolute;
            top: -5px;
            left: -5px;
            right: -5px;
            bottom: -5px;
            border: 2px solid rgba(6, 255, 165, 0.5);
            border-radius: inherit;
            opacity: 0;
            transition: all 0.3s ease;
            pointer-events: none;
        }

        .gesture-interactive.gesture-hover::after {
            opacity: 1;
            animation: pulseGlow 1s infinite;
        }

        .gesture-interactive.mouse-enabled {
            cursor: pointer !important;
        }

        @keyframes pulseGlow {
            0%, 100% { 
                border-color: rgba(6, 255, 165, 0.5);
                transform: scale(1);
            }
            50% { 
                border-color: rgba(6, 255, 165, 0.8);
                transform: scale(1.05);
            }
        }

        /* Portal Gesture Interaction */
        .portal-gesture-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            opacity: 0;
            transition: all 0.3s ease;
            pointer-events: none;
        }

        .portal-gesture-indicator.ready {
            opacity: 1;
            animation: portalReady 1s infinite;
        }

        @keyframes portalReady {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.2); }
        }

        /* Gesture-based Menu */
        .gesture-menu {
            position: fixed;
            right: -300px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(20, 20, 40, 0.95);
            border: 2px solid rgba(138, 56, 236, 0.5);
            border-radius: 20px 0 0 20px;
            padding: 30px;
            z-index: 1999;
            transition: all 0.3s ease;
            width: 300px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .gesture-menu.open {
            right: 0;
        }

        .gesture-menu-item {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            padding: 15px;
            margin: 10px 0;
            transition: all 0.3s ease;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .gesture-menu-item:hover,
        .gesture-menu-item.gesture-hover {
            background: rgba(138, 56, 236, 0.3);
            border-color: rgba(138, 56, 236, 0.5);
            transform: translateX(-10px);
        }

        .gesture-menu-icon {
            font-size: 30px;
            width: 40px;
            text-align: center;
        }

        .gesture-menu-text {
            flex: 1;
        }

        .gesture-menu-title {
            font-weight: bold;
            color: #06ffa5;
            margin-bottom: 5px;
        }

        .gesture-menu-description {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
        }

        /* AI Chat with Gesture Support */
        .ai-chat-interface {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 350px;
            height: 450px;
            background: rgba(20, 20, 40, 0.85);
            border: 2px solid rgba(138, 56, 236, 0.5);
            border-radius: 20px;
            display: none;
            flex-direction: column;
            z-index: 1003;
            box-shadow: 0 0 30px rgba(138, 56, 236, 0.3);
            backdrop-filter: blur(5px);
            transition: all 0.3s ease;
        }

        .ai-chat-interface.active {
            display: flex;
        }

        .ai-chat-interface.gesture-focus {
            border-color: rgba(6, 255, 165, 0.8);
            box-shadow: 0 0 40px rgba(6, 255, 165, 0.5);
        }

        /* Gesture Swipe Indicators */
        .swipe-indicator {
            position: fixed;
            z-index: 2500;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .swipe-indicator.left,
        .swipe-indicator.right {
            top: 50%;
            transform: translateY(-50%);
            font-size: 40px;
            color: rgba(6, 255, 165, 0.8);
        }

        .swipe-indicator.left {
            left: 20px;
        }

        .swipe-indicator.right {
            right: 20px;
        }

        .swipe-indicator.up,
        .swipe-indicator.down {
            left: 50%;
            transform: translateX(-50%);
            font-size: 40px;
            color: rgba(6, 255, 165, 0.8);
        }

        .swipe-indicator.up {
            top: 20px;
        }

        .swipe-indicator.down {
            bottom: 20px;
        }

        .swipe-indicator.active {
            opacity: 1;
        }

        /* Scene Recorder with Gestures */
        .scene-recorder-button {
            position: fixed;
            bottom: calc(env(safe-area-inset-bottom, 30px) + 220px);
            right: calc(env(safe-area-inset-right, 30px));
            width: 60px;
            height: 60px;
            background: rgba(255, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 0, 0, 0.5);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 1002;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.3);
        }

        .scene-recorder-button.gesture-hover {
            background: rgba(255, 0, 0, 0.5);
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.5);
        }

        .scene-recorder-button.recording {
            animation: recordPulse 1s infinite;
        }

        @keyframes recordPulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(255, 0, 0, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0); }
        }

        .scene-recorder-button svg {
            width: 28px;
            height: 28px;
            color: white;
        }

        /* Scene Recorder Modal */
        .scene-recorder-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 3002;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(5px);
        }

        .scene-recorder-modal.show {
            display: flex;
        }

        .scene-recorder-content {
            background: rgba(20, 20, 40, 0.95);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            padding: 30px;
            max-width: 600px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 0 50px rgba(255, 0, 0, 0.3);
        }

        .scene-recorder-content h3 {
            margin: 0 0 20px 0;
            font-size: 24px;
            background: linear-gradient(45deg, #ff0000, #ff6b6b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-align: center;
        }

        .recording-status {
            background: rgba(255, 0, 0, 0.1);
            border: 1px solid rgba(255, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
            text-align: center;
        }

        .recording-status.active {
            animation: pulse 2s infinite;
        }

        .recording-timer {
            font-size: 24px;
            font-weight: bold;
            color: #ff6b6b;
            margin: 10px 0;
        }

        .recording-info {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.7);
        }

        .scene-controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .scene-control-btn {
            background: linear-gradient(45deg, #ff0000, #ff6b6b);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .scene-control-btn.gesture-hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(255, 0, 0, 0.4);
        }

        .scene-control-btn.stop {
            background: linear-gradient(45deg, #666, #999);
        }

        .scene-control-btn.play {
            background: linear-gradient(45deg, #06ffa5, #00ff88);
            color: #000;
        }

        .scene-control-btn.export {
            background: linear-gradient(45deg, #3a86ff, #8338ec);
        }

        .scene-list {
            margin: 20px 0;
        }

        .scene-item {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s ease;
        }

        .scene-item.gesture-hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateX(5px);
        }

        .scene-item-info {
            flex: 1;
        }

        .scene-item-name {
            font-weight: bold;
            color: #ff6b6b;
            margin-bottom: 5px;
        }

        .scene-item-details {
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.6);
        }

        .scene-item-actions {
            display: flex;
            gap: 10px;
        }

        .scene-action-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            padding: 8px 12px;
            border-radius: 10px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
        }

        .scene-action-btn.gesture-hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
        }

        .scene-action-btn.delete {
            background: rgba(255, 0, 0, 0.3);
        }

        .scene-action-btn.delete.gesture-hover {
            background: rgba(255, 0, 0, 0.5);
        }

        .scene-timeline {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
        }

        .timeline-progress {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            overflow: hidden;
            margin: 10px 0;
        }

        .timeline-bar {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ff6b6b);
            width: 0%;
            transition: width 0.1s linear;
        }

        .timeline-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 10px;
        }

        .timeline-time {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
        }

        .playback-speed {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .speed-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            padding: 5px 10px;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            font-size: 12px;
        }

        .speed-btn.active {
            background: rgba(255, 0, 0, 0.5);
        }

        .scene-import-input {
            display: none;
        }

        .replay-overlay {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 30px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 0, 0, 0.5);
            z-index: 2000;
            display: none;
        }

        .replay-overlay.active {
            display: block;
        }

        .replay-text {
            color: #ff6b6b;
            font-size: 18px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        /* 3D Timeline Controls */
        .timeline-3d-controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 30px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(138, 56, 236, 0.5);
            z-index: 2001;
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .timeline-3d-controls.active {
            display: flex;
        }

        .timeline-step-info {
            color: #06ffa5;
            font-size: 16px;
            margin-bottom: 10px;
        }

        .timeline-3d-buttons {
            display: flex;
            gap: 15px;
        }

        .timeline-3d-btn {
            background: linear-gradient(45deg, #8338ec, #3a86ff);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
        }

        .timeline-3d-btn.gesture-hover {
            transform: scale(1.05);
            box-shadow: 0 4px 20px rgba(131, 56, 236, 0.4);
        }

        .timeline-3d-btn:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }

        /* Portal Import/Export UI */
        .portal-manager {
            position: fixed;
            bottom: calc(env(safe-area-inset-bottom, 30px) + 150px);
            right: calc(env(safe-area-inset-right, 30px));
            width: 60px;
            height: 60px;
            background: rgba(0, 255, 255, 0.3);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 1002;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }

        .portal-manager.gesture-hover {
            background: rgba(0, 255, 255, 0.5);
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
        }

        .portal-manager svg {
            width: 28px;
            height: 28px;
            color: white;
        }

        .portal-manager-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 3002;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(5px);
        }

        .portal-manager-modal.show {
            display: flex;
        }

        .portal-manager-content {
            background: rgba(20, 20, 40, 0.95);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.3);
        }

        .portal-manager-content h3 {
            margin: 0 0 20px 0;
            font-size: 24px;
            background: linear-gradient(45deg, #00ffff, #0088ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-align: center;
        }

        .portal-list {
            margin: 20px 0;
        }

        .portal-item {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s ease;
        }

        .portal-item.gesture-hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateX(5px);
        }

        .portal-item-info {
            flex: 1;
        }

        .portal-item-name {
            font-weight: bold;
            color: #06ffa5;
            margin-bottom: 5px;
        }

        .portal-item-location {
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.6);
        }

        .portal-item-actions {
            display: flex;
            gap: 10px;
        }

        .portal-action-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            padding: 8px 12px;
            border-radius: 10px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
        }

        .portal-action-btn.gesture-hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
        }

        .portal-action-btn.delete {
            background: rgba(255, 0, 0, 0.3);
        }

        .portal-action-btn.delete.gesture-hover {
            background: rgba(255, 0, 0, 0.5);
        }

        .portal-action-btn.enter {
            background: linear-gradient(45deg, #06ffa5, #00ff88);
            color: #000;
            font-weight: bold;
        }

        .portal-action-btn.enter.gesture-hover {
            background: linear-gradient(45deg, #00ff88, #06ffa5);
            box-shadow: 0 0 15px rgba(6, 255, 165, 0.5);
        }

        .portal-import-export {
            margin: 20px 0;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .import-export-btn {
            background: linear-gradient(45deg, #00ffff, #0088ff);
            color: #000;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .import-export-btn.gesture-hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(0, 255, 255, 0.4);
        }

        .import-file-input {
            display: none;
        }

        .portal-close-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            font-size: 30px;
            cursor: pointer;
            color: #fff;
            transition: all 0.3s;
        }

        .portal-close-btn.gesture-hover {
            color: #ff006e;
            transform: rotate(90deg);
        }

        /* AI Companion Modal */
        .ai-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 2002;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(5px);
        }

        .ai-modal.show {
            display: flex;
        }

        .ai-modal-content {
            background: rgba(20, 20, 40, 0.95);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            text-align: center;
            position: relative;
            box-shadow: 0 0 50px rgba(138, 56, 236, 0.3);
        }

        .ai-modal-close {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            font-size: 30px;
            cursor: pointer;
            color: #fff;
            transition: all 0.3s;
        }

        .ai-modal-close.gesture-hover {
            color: #ff006e;
            transform: rotate(90deg);
        }

        .ai-modal h3 {
            margin: 0 0 20px 0;
            font-size: 24px;
            background: linear-gradient(45deg, #ff006e, #8338ec, #3a86ff, #06ffa5);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .ai-api-key-input {
            width: 100%;
            padding: 12px;
            margin: 10px 0;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            color: white;
            font-size: 14px;
            font-family: monospace;
        }

        .ai-api-key-input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .ai-activate-btn {
            background: linear-gradient(45deg, #8338ec, #3a86ff);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 10px;
        }

        .ai-activate-btn.gesture-hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(131, 56, 236, 0.4);
        }

        .ai-companion-list {
            margin: 20px 0;
            text-align: left;
        }

        .ai-companion-item {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .ai-companion-name {
            font-weight: bold;
            color: #06ffa5;
        }

        .ai-companion-status {
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.6);
        }

        /* AI Chat Interface - Modified for better visibility */
        .ai-chat-header {
            padding: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .ai-chat-title {
            font-weight: bold;
            color: #06ffa5;
        }

        .task-replay-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 106, 0, 0.8);
            padding: 5px 10px;
            border-radius: 10px;
            font-size: 12px;
            display: none;
        }

        .task-replay-indicator.active {
            display: block;
            animation: pulse 1s infinite;
        }

        .ai-chat-messages {
            flex: 1;
            padding: 15px;
            overflow-y: auto;
            scroll-behavior: smooth;
        }

        .ai-message {
            margin: 10px 0;
            padding: 10px 15px;
            border-radius: 15px;
            max-width: 80%;
            word-wrap: break-word;
            overflow-wrap: break-word;
            word-break: break-word;
            font-size: 15px;
            line-height: 1.6;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            transition: all 0.2s ease;
            max-width: 100%;
            overflow-x: auto;
        }

        .ai-message.user {
            background: rgba(131, 56, 236, 0.3);
            margin-left: auto;
            text-align: right;
        }

        .ai-message.ai {
            background: rgba(6, 255, 165, 0.2);
            margin-right: auto;
        }

        .ai-message.task-replay {
            border: 1px solid rgba(255, 106, 0, 0.5);
            opacity: 0.8;
            font-style: italic;
        }

        /* Agent Logs Styling */
        .ai-message.system {
            background: rgba(255, 106, 0, 0.1);
            border: 1px solid rgba(255, 106, 0, 0.3);
            font-family: monospace;
            font-size: 13px;
            color: rgba(255, 255, 255, 0.8);
            white-space: pre-wrap;
            overflow-x: auto;
            max-width: 100%;
        }

        .agent-log-section {
            margin: 10px 0;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border-left: 3px solid #ff6a00;
        }

        .agent-log-header {
            color: #ffa500;
            font-weight: bold;
            margin-bottom: 5px;
            font-size: 14px;
        }

        .agent-log-content {
            color: rgba(255, 255, 255, 0.9);
            line-height: 1.5;
        }

        .agent-status {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: bold;
            margin-right: 5px;
        }

        .agent-status.thinking {
            background: rgba(58, 134, 255, 0.3);
            color: #4DD0E1;
        }

        .agent-status.searching {
            background: rgba(255, 152, 0, 0.3);
            color: #ffaa00;
        }

        .agent-status.processing {
            background: rgba(156, 39, 176, 0.3);
            color: #BA68C8;
        }

        .agent-status.complete {
            background: rgba(76, 175, 80, 0.3);
            color: #81C784;
        }

        .agent-step {
            margin: 5px 0;
            padding-left: 20px;
            position: relative;
        }

        .agent-step::before {
            content: '▸';
            position: absolute;
            left: 5px;
            color: #06ffa5;
        }

        .agent-error {
            color: #ff6b6b;
            background: rgba(255, 0, 0, 0.1);
            padding: 5px;
            border-radius: 5px;
            margin: 5px 0;
        }

        .agent-success {
            color: #51cf66;
            background: rgba(0, 255, 0, 0.1);
            padding: 5px;
            border-radius: 5px;
            margin: 5px 0;
        }

        /* 3D Agent Log Display */
        .agent-log-3d {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid rgba(255, 106, 0, 0.5);
            border-radius: 10px;
            padding: 10px;
            max-width: 300px;
            font-family: monospace;
            font-size: 12px;
            color: #ffa500;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .agent-log-3d.visible {
            opacity: 1;
        }

        .ai-typing {
            margin: 10px 0;
            padding: 10px 15px;
            border-radius: 15px;
            max-width: 80%;
            background: rgba(6, 255, 165, 0.2);
            margin-right: auto;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .typing-dot {
            width: 8px;
            height: 8px;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            animation: typingPulse 1.4s infinite ease-in-out;
        }

        .typing-dot:nth-child(1) {
            animation-delay: -0.32s;
        }

        .typing-dot:nth-child(2) {
            animation-delay: -0.16s;
        }

        @keyframes typingPulse {
            0%, 80%, 100% {
                transform: scale(0.8);
                opacity: 0.5;
            }
            40% {
                transform: scale(1);
                opacity: 1;
            }
        }

        .ai-chat-input-container {
            padding: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            gap: 10px;
        }

        .ai-chat-input {
            flex: 1;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            color: white;
            font-size: 14px;
        }

        .ai-chat-send {
            background: linear-gradient(45deg, #8338ec, #3a86ff);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .ai-chat-send.gesture-hover {
            transform: scale(1.05);
        }

        /* Save as Task Button */
        .save-task-btn {
            background: linear-gradient(45deg, #ff6a00, #ff8c00);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 15px;
            cursor: pointer;
            font-size: 12px;
            margin-left: 10px;
            transition: all 0.3s ease;
            display: none; /* Hidden since we're using conversation replay */
        }

        .save-task-btn.gesture-hover {
            transform: scale(1.05);
            box-shadow: 0 3px 15px rgba(255, 106, 0, 0.4);
        }

        /* AI Companion Button */
        .ai-companion-button {
            position: fixed;
            bottom: calc(env(safe-area-inset-bottom, 30px) + 80px);
            right: calc(env(safe-area-inset-right, 30px));
            width: 60px;
            height: 60px;
            background: rgba(131, 56, 236, 0.3);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(131, 56, 236, 0.5);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 1002;
            box-shadow: 0 0 20px rgba(131, 56, 236, 0.3);
        }

        .ai-companion-button.gesture-hover {
            background: rgba(131, 56, 236, 0.5);
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(131, 56, 236, 0.5);
        }

        .ai-companion-button.active {
            background: rgba(6, 255, 165, 0.3);
            border-color: rgba(6, 255, 165, 0.5);
        }

        /* Task List Panel - Updated for conversation replay */
        .task-panel {
            position: fixed;
            bottom: calc(env(safe-area-inset-bottom, 100px));
            left: calc(env(safe-area-inset-left, 20px));
            background: rgba(20, 20, 40, 0.95);
            border: 2px solid rgba(255, 106, 0, 0.5);
            border-radius: 20px;
            padding: 20px;
            z-index: 1002;
            max-width: 350px;
            max-height: 400px;
            overflow-y: auto;
            box-shadow: 0 0 30px rgba(255, 106, 0, 0.3);
            display: none;
        }

        .task-panel.active {
            display: block;
        }

        .task-panel h3 {
            margin: 0 0 15px 0;
            font-size: 20px;
            background: linear-gradient(45deg, #ff6a00, #ff8c00, #ffa500);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .task-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 12px;
            margin: 8px 0;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid transparent;
        }

        .task-item.gesture-hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 106, 0, 0.5);
            transform: translateX(5px);
        }

        .task-item strong {
            color: #ffa500;
            display: block;
            margin-bottom: 5px;
        }

        .task-item small {
            color: rgba(255, 255, 255, 0.6);
            display: block;
            margin-top: 5px;
        }

        .task-item .conversation-info {
            font-size: 0.85em;
            color: rgba(255, 255, 255, 0.7);
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* Tasks Button */
        .tasks-button {
            position: fixed;
            bottom: calc(env(safe-area-inset-bottom, 30px) + 290px);
            right: calc(env(safe-area-inset-right, 30px));
            width: 60px;
            height: 60px;
            background: rgba(255, 106, 0, 0.3);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 106, 0, 0.5);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 1002;
            box-shadow: 0 0 20px rgba(255, 106, 0, 0.3);
        }

        .tasks-button.gesture-hover {
            background: rgba(255, 106, 0, 0.5);
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(255, 106, 0, 0.5);
        }

        .tasks-button svg {
            width: 28px;
            height: 28px;
            color: white;
        }

        /* Upload conversation button styles */
        .upload-conversation-btn {
            background: linear-gradient(45deg, #742774, #4a90e2);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 15px;
            cursor: pointer;
            font-size: 14px;
            margin: 10px 0;
            width: 100%;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .upload-conversation-btn.gesture-hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(116, 39, 116, 0.4);
        }

        .conversation-upload-input {
            display: none;
        }

        @keyframes shimmer {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .world-ui {
            position: absolute;
            top: env(safe-area-inset-top, 20px);
            left: env(safe-area-inset-left, 20px);
            z-index: 1001;
            pointer-events: none;
        }

        .world-title {
            font-size: 3em;
            font-weight: 100;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            background: linear-gradient(45deg, #ff006e, #8338ec, #3a86ff, #06ffa5);
            background-size: 400% 100%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: shimmer 8s ease-in-out infinite;
            margin-bottom: 10px;
        }

        .world-description {
            font-size: 1.2em;
            color: rgba(255, 255, 255, 0.6);
            max-width: 400px;
        }

        .world-origin {
            position: absolute;
            top: env(safe-area-inset-top, 20px);
            right: env(safe-area-inset-right, 20px);
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.8);
            z-index: 1001;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            display: none;
        }

        .world-origin.visible {
            display: block;
        }

        .origin-label {
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.8em;
        }

        .origin-world {
            color: #06ffa5;
            font-weight: 500;
        }

        .controls-hint {
            position: absolute;
            bottom: env(safe-area-inset-bottom, 30px);
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.8);
            z-index: 1001;
            text-align: center;
            backdrop-filter: blur(10px);
            pointer-events: none;
        }

        .portal-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            padding: 20px;
            max-width: 300px;
            display: none;
            z-index: 1002;
            pointer-events: none;
            backdrop-filter: blur(10px);
        }

        .portal-tooltip.visible {
            display: block;
        }

        .tooltip-title {
            font-size: 1.4em;
            font-weight: 300;
            margin-bottom: 10px;
            color: #06ffa5;
        }

        .tooltip-description {
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.7);
            line-height: 1.5;
        }

        .tooltip-instruction {
            font-size: 0.85em;
            color: #ff006e;
            text-align: center;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            font-size: 1.2em;
            color: rgba(255, 255, 255, 0.4);
            font-weight: 200;
            letter-spacing: 0.1em;
            z-index: 2000;
        }

        .loading::after {
            content: '';
            display: block;
            width: 60px;
            height: 1px;
            background: linear-gradient(90deg, transparent, #fff, transparent);
            margin: 30px auto;
            animation: scan 2s linear infinite;
        }

        @keyframes scan {
            0% { transform: translateX(-100px); }
            100% { transform: translateX(100px); }
        }

        /* QR Code Share Button */
        .share-button {
            position: fixed;
            bottom: calc(env(safe-area-inset-bottom, 30px));
            right: calc(env(safe-area-inset-right, 30px));
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 1000;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.1);
        }

        .share-button.gesture-hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(255, 255, 255, 0.3);
        }

        .share-icon {
            width: 24px;
            height: 24px;
            color: white;
        }

        /* QR Code Modal */
        .qr-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 2001;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(5px);
        }

        .qr-modal.show {
            display: flex;
        }

        .qr-modal-content {
            background: rgba(20, 20, 40, 0.95);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            padding: 30px;
            max-width: 400px;
            width: 90%;
            text-align: center;
            position: relative;
            box-shadow: 0 0 50px rgba(138, 56, 236, 0.3);
        }

        .qr-close {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            font-size: 30px;
            cursor: pointer;
            color: #fff;
            transition: all 0.3s;
        }

        .qr-close.gesture-hover {
            color: #ff006e;
            transform: rotate(90deg);
        }

        .qr-modal h3 {
            margin: 0 0 20px 0;
            font-size: 24px;
            background: linear-gradient(45deg, #ff006e, #8338ec, #3a86ff, #06ffa5);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        #qr-code-container {
            margin: 20px auto;
            display: flex;
            justify-content: center;
            padding: 20px;
            background: white;
            border-radius: 15px;
        }

        #qr-code-container canvas,
        #qr-code-container img {
            border-radius: 10px;
        }

        .qr-url {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            word-break: break-all;
            margin: 20px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            font-family: monospace;
        }

        .copy-url-btn {
            background: linear-gradient(45deg, #ff006e, #8338ec);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .copy-url-btn.gesture-hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(255, 0, 110, 0.4);
        }

        .copy-url-btn.copied {
            background: linear-gradient(45deg, #06ffa5, #00ff88);
        }

        @media (max-width: 768px) {
            .world-title {
                font-size: 2em;
            }

            .world-description {
                font-size: 1em;
                max-width: 300px;
            }

            .ai-chat-interface {
                width: calc(100% - 40px);
                right: 20px;
                left: 20px;
            }
        }

        /* iOS specific fixes */
        @supports (-webkit-touch-callout: none) {
            body {
                position: fixed;
                height: 100vh;
                height: -webkit-fill-available;
            }

            #three-container {
                height: 100vh;
                height: -webkit-fill-available;
            }
        }
    </style>
</head>
<body>
    <div id="three-container"></div>

    <!-- Hand Tracking Container -->
    <div class="hand-tracking-container" id="hand-tracking-container">
        <video class="webcam-feed" id="webcam-video" autoplay playsinline></video>
        <canvas class="gesture-overlay" id="gesture-canvas"></canvas>
        <div class="gesture-status" id="gesture-status">Ready</div>
    </div>

    <!-- Hand Cursor -->
    <div class="hand-cursor" id="hand-cursor"></div>

    <!-- Gesture Guide -->
    <div class="gesture-guide" id="gesture-guide">
        <h3>Gesture Controls</h3>
        <div class="gesture-item">
            <div class="gesture-icon">👌</div>
            <div class="gesture-description">Pinch to select/interact</div>
        </div>
        <div class="gesture-item">
            <div class="gesture-icon">✋</div>
            <div class="gesture-description">Open hand to navigate</div>
        </div>
        <div class="gesture-item">
            <div class="gesture-icon">👊</div>
            <div class="gesture-description">Fist to rotate view</div>
        </div>
        <div class="gesture-item">
            <div class="gesture-icon">👋</div>
            <div class="gesture-description">Wave to open menu</div>
        </div>
        <div class="gesture-item">
            <div class="gesture-icon">✌️</div>
            <div class="gesture-description">Peace sign to zoom</div>
        </div>
        <div class="gesture-item">
            <div class="gesture-icon">☝️</div>
            <div class="gesture-description">Point to teleport</div>
        </div>
    </div>

    <!-- Gesture Feedback -->
    <div class="gesture-feedback" id="gesture-feedback"></div>

    <!-- Gesture Menu -->
    <div class="gesture-menu" id="gesture-menu">
        <div class="gesture-menu-item" data-action="toggleAI">
            <div class="gesture-menu-icon">🤖</div>
            <div class="gesture-menu-text">
                <div class="gesture-menu-title">AI Companion</div>
                <div class="gesture-menu-description">Chat with AI assistant</div>
            </div>
        </div>
        <div class="gesture-menu-item" data-action="togglePortals">
            <div class="gesture-menu-icon">🌀</div>
            <div class="gesture-menu-text">
                <div class="gesture-menu-title">Portal Manager</div>
                <div class="gesture-menu-description">Manage world portals</div>
            </div>
        </div>
        <div class="gesture-menu-item" data-action="toggleRecorder">
            <div class="gesture-menu-icon">🎬</div>
            <div class="gesture-menu-text">
                <div class="gesture-menu-title">Scene Recorder</div>
                <div class="gesture-menu-description">Record & replay scenes</div>
            </div>
        </div>
        <div class="gesture-menu-item" data-action="toggleTasks">
            <div class="gesture-menu-icon">📚</div>
            <div class="gesture-menu-text">
                <div class="gesture-menu-title">Saved Conversations</div>
                <div class="gesture-menu-description">View conversation history</div>
            </div>
        </div>
        <div class="gesture-menu-item" data-action="minimizeHand">
            <div class="gesture-menu-icon">👁️</div>
            <div class="gesture-menu-text">
                <div class="gesture-menu-title">Minimize Tracker</div>
                <div class="gesture-menu-description">Hide hand view</div>
            </div>
        </div>
    </div>

    <!-- Swipe Indicators -->
    <div class="swipe-indicator left" id="swipe-left">◀</div>
    <div class="swipe-indicator right" id="swipe-right">▶</div>
    <div class="swipe-indicator up" id="swipe-up">▲</div>
    <div class="swipe-indicator down" id="swipe-down">▼</div>

    <!-- Scene Recorder Button -->
    <div class="scene-recorder-button gesture-interactive" id="scene-recorder-button">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="12" cy="12" r="11"/>
            <circle cx="12" cy="12" r="5" fill="currentColor"/>
        </svg>
    </div>

    <!-- Scene Recorder Modal -->
    <div class="scene-recorder-modal" id="scene-recorder-modal">
        <div class="scene-recorder-content">
            <button class="portal-close-btn gesture-interactive" id="scene-recorder-close">&times;</button>
            <h3>Scene Recorder & Player</h3>
            
            <div class="recording-status" id="recording-status">
                <div class="recording-timer" id="recording-timer">00:00</div>
                <div class="recording-info" id="recording-info">Ready to record</div>
            </div>

            <div class="scene-controls">
                <button class="scene-control-btn gesture-interactive" id="start-recording-btn">
                    ▶️ Start Recording
                </button>
                <button class="scene-control-btn stop gesture-interactive" id="stop-recording-btn" style="display:none;">
                    ⏹️ Stop Recording
                </button>
                <button class="scene-control-btn export gesture-interactive" id="export-scene-btn">
                    📤 Export Scene
                </button>
                <button class="scene-control-btn gesture-interactive" onclick="document.getElementById('scene-import-input').click()">
                    📥 Import Scene
                </button>
                <input type="file" id="scene-import-input" class="scene-import-input" accept=".json" onchange="window.worldNavigator.sceneRecorder.importScene(event)">
            </div>

            <div class="scene-timeline" id="scene-timeline" style="display:none;">
                <div class="timeline-progress">
                    <div class="timeline-bar" id="timeline-bar"></div>
                </div>
                <div class="timeline-controls">
                    <div class="timeline-time">
                        <span id="current-time">00:00</span> / <span id="total-time">00:00</span>
                    </div>
                    <div class="playback-speed">
                        <button class="speed-btn gesture-interactive" data-speed="0.5">0.5x</button>
                        <button class="speed-btn active gesture-interactive" data-speed="1">1x</button>
                        <button class="speed-btn gesture-interactive" data-speed="2">2x</button>
                    </div>
                </div>
            </div>

            <div class="scene-list" id="scene-list">
                <h4 style="color: #ff6b6b; margin-bottom: 10px;">Recorded Scenes:</h4>
                <!-- Scene items will be populated here -->
            </div>
        </div>
    </div>

    <!-- Replay Overlay -->
    <div class="replay-overlay" id="replay-overlay">
        <div class="replay-text">▶️ REPLAYING SCENE</div>
    </div>

    <!-- 3D Timeline Controls -->
    <div class="timeline-3d-controls" id="timeline-3d-controls">
        <div class="timeline-step-info" id="timeline-step-info">
            Step 1 of 10 - User Message
        </div>
        <div class="timeline-3d-buttons">
            <button class="timeline-3d-btn gesture-interactive" id="timeline-prev-btn">◀ Previous</button>
            <button class="timeline-3d-btn gesture-interactive" id="timeline-play-pause-btn">⏸ Pause</button>
            <button class="timeline-3d-btn gesture-interactive" id="timeline-next-btn">Next ▶</button>
            <button class="timeline-3d-btn gesture-interactive" id="timeline-exit-btn">Exit</button>
        </div>
    </div>

    <!-- Portal Manager Button -->
    <div class="portal-manager gesture-interactive" id="portal-manager-btn">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="12" cy="12" r="10"/>
            <path d="M12 2v20M2 12h20"/>
            <circle cx="12" cy="12" r="3"/>
        </svg>
    </div>

    <!-- Portal Manager Modal -->
    <div class="portal-manager-modal" id="portal-manager-modal">
        <div class="portal-manager-content">
            <button class="portal-close-btn gesture-interactive" id="portal-close">&times;</button>
            <h3>Portal Manager</h3>
            <p style="color: rgba(255, 255, 255, 0.7); margin-bottom: 20px; text-align: center;">
                Use gestures to manage portals. Pinch to select, wave to navigate.
            </p>
            
            <div class="portal-list" id="portal-list">
                <h4 style="color: #06ffa5; margin-bottom: 10px;">Active Portals:</h4>
                <!-- Portal items will be populated here -->
            </div>
            
            <div class="portal-import-export">
                <button class="import-export-btn gesture-interactive" onclick="window.worldNavigator.portalManager.exportPortals()">
                    📤 Export Portals
                </button>
                <button class="import-export-btn gesture-interactive" onclick="document.getElementById('import-file').click()">
                    📥 Import Portals
                </button>
                <input type="file" id="import-file" class="import-file-input" accept=".json" onchange="window.worldNavigator.portalManager.importPortals(event)">
            </div>
        </div>
    </div>

    <!-- AI Companion Modal -->
    <div class="ai-modal" id="ai-modal">
        <div class="ai-modal-content">
            <button class="ai-modal-close gesture-interactive" id="ai-close">&times;</button>
            <h3>AI Companion Settings</h3>
            <p style="color: rgba(255, 255, 255, 0.7); margin-bottom: 20px;">
                Activate AI companions using gestures. They can interact with you and other players in real-time.
            </p>
            <input type="password" class="ai-api-key-input" id="ai-api-key" placeholder="Enter your API key to wake up AI companions">
            <button class="ai-activate-btn gesture-interactive" id="ai-activate-btn">Activate AI Companions</button>

            <div class="ai-companion-list" id="ai-companion-list">
                <h4 style="color: #06ffa5; margin-top: 20px;">Active Companions:</h4>
                <div class="ai-companion-item">
                    <div>
                        <div class="ai-companion-name">No AI companions active</div>
                        <div class="ai-companion-status">Enter API key to activate</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- AI Chat Interface -->
    <div class="ai-chat-interface" id="ai-chat-interface">
        <div class="ai-chat-header">
            <div class="ai-chat-title">AI Companion Chat</div>
            <button class="ai-modal-close gesture-interactive" onclick="document.getElementById('ai-chat-interface').classList.remove('active')">&times;</button>
        </div>
        <div class="task-replay-indicator" id="task-replay-indicator">🔄 Replaying Conversation...</div>
        <div class="ai-chat-messages" id="ai-chat-messages"></div>
        <div class="ai-chat-input-container">
            <input type="text" class="ai-chat-input" id="ai-chat-input" placeholder="Type a message..." onkeypress="if(event.key==='Enter') window.worldNavigator.aiManager.sendMessage()">
            <button class="ai-chat-send gesture-interactive" onclick="window.worldNavigator.aiManager.sendMessage()">Send</button>
        </div>
    </div>

    <!-- Task Panel -->
    <div class="task-panel" id="task-panel">
        <h3>📚 Saved Conversations</h3>
        <button class="upload-conversation-btn gesture-interactive" onclick="document.getElementById('conversation-upload-input').click()">
            <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"></path>
                <polyline points="17 8 12 3 7 8"></polyline>
                <line x1="12" y1="3" x2="12" y2="15"></line>
            </svg>
            Upload Conversation JSON
        </button>
        <input type="file" id="conversation-upload-input" class="conversation-upload-input" accept=".json" onchange="window.worldNavigator.taskManager.uploadConversation(event)">
        <div id="task-list">
            <!-- Tasks populated here -->
        </div>
    </div>

    <div class="world-ui">
        <h1 class="world-title" id="world-title">NEXUS HUB</h1>
        <p class="world-description" id="world-description">Use hand gestures to navigate. Pinch to interact with portals. Wave to open menu.</p>
    </div>

    <div class="world-origin" id="world-origin">
        <span class="origin-label">Arrived from:</span>
        <span class="origin-world" id="origin-world-name">Origin</span>
    </div>

    <!-- AI Companion Button -->
    <div class="ai-companion-button gesture-interactive" id="ai-companion-button">
        <svg class="view-toggle-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"></path>
        </svg>
    </div>

    <!-- Tasks Button -->
    <div class="tasks-button gesture-interactive" id="tasks-button">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M9 11l3 3L22 4"></path>
            <path d="M21 12v7a2 2 0 01-2 2H5a2 2 0 01-2-2V5a2 2 0 012-2h11"></path>
        </svg>
    </div>

    <div class="controls-hint" id="controls-hint">Use hand gestures to navigate - Wave to open menu - Pinch to interact</div>

    <div class="portal-tooltip" id="portal-tooltip">
        <h3 class="tooltip-title"></h3>
        <p class="tooltip-description"></p>
        <p class="tooltip-instruction">Pinch to enter world</p>
    </div>

    <div class="loading" id="loading">Initializing gesture controls...</div>

    <!-- QR Code Share Button -->
    <div class="share-button gesture-interactive" id="share-button">
        <svg class="share-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M4 12v8a2 2 0 002 2h12a2 2 0 002-2v-8"></path>
            <polyline points="16 6 12 2 8 6"></polyline>
            <line x1="12" y1="2" x2="12" y2="15"></line>
        </svg>
    </div>

    <!-- QR Code Modal -->
    <div class="qr-modal" id="qr-modal">
        <div class="qr-modal-content">
            <button class="qr-close gesture-interactive" id="qr-close">&times;</button>
            <h3>Share This World</h3>
            <div id="qr-code-container"></div>
            <p class="qr-url" id="qr-url"></p>
            <button class="copy-url-btn gesture-interactive" id="copy-url-btn">Copy URL</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script>
        // Initialize hand tracking and gesture recognition
        class GestureController {
            constructor() {
                this.hands = null;
                this.camera = null;
                this.isInitialized = false;
                this.currentGesture = null;
                this.lastGesture = null;
                this.gestureHistory = [];
                this.pinchThreshold = 0.08;
                this.hoveredElements = new Set();
                this.gestureStartTime = null;
                this.swipeStartPos = null;
                this.rotationStart = null;
                this.lastHandPosition = null;
                this.menuOpen = false;
                this.fallbackToMouse = false;
                
                this.initializeHandTracking();
            }

            async initializeHandTracking() {
                const videoElement = document.getElementById('webcam-video');
                const canvasElement = document.getElementById('gesture-canvas');
                const canvasCtx = canvasElement.getContext('2d');
                
                // Set canvas size
                canvasElement.width = 640;
                canvasElement.height = 480;
                
                this.hands = new Hands({
                    locateFile: (file) => {
                        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                    }
                });

                this.hands.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });

                this.hands.onResults((results) => this.onHandResults(results));

                this.camera = new Camera(videoElement, {
                    onFrame: async () => {
                        await this.hands.send({ image: videoElement });
                    },
                    width: 640,
                    height: 480
                });
                
                try {
                    await this.camera.start();
                    this.isInitialized = true;
                    document.getElementById('loading').style.display = 'none';
                    this.showGestureFeedback('Gesture controls active!');
                } catch (error) {
                    console.error('Failed to start camera:', error);
                    this.handleCameraError(error);
                }
            }

            handleCameraError(error) {
                // Create camera error UI
                const errorDiv = document.createElement('div');
                errorDiv.className = 'camera-error';
                errorDiv.innerHTML = `
                    <h3>Camera Access Required</h3>
                    <p>Gesture controls need camera permission to work properly.</p>
                    <div class="error-details">
                        <strong>Error:</strong> ${error.message || 'Camera access denied'}<br>
                        <strong>Solution:</strong> Allow camera access in your browser settings and refresh the page.
                    </div>
                    <p>You can still navigate using:</p>
                    <ul style="text-align: left; display: inline-block;">
                        <li>WASD keys to move</li>
                        <li>Mouse to look around</li>
                        <li>Click to interact with portals</li>
                    </ul>
                    <button onclick="location.reload()">Retry Camera Access</button>
                    <button class="fallback-btn" onclick="window.gestureController.enableMouseControls()">Use Mouse Controls</button>
                `;
                
                document.body.appendChild(errorDiv);
                
                // Hide gesture-specific UI
                document.getElementById('loading').style.display = 'none';
                document.getElementById('hand-tracking-container').style.display = 'none';
                document.getElementById('gesture-guide').classList.add('hidden');
                document.getElementById('hand-cursor').style.display = 'none';
                
                // Enable fallback controls
                this.fallbackToMouse = true;
                this.enableMouseControls();
            }

            enableMouseControls() {
                console.log('Enabling mouse controls as fallback');
                this.fallbackToMouse = true;
                
                // Remove camera error message if it exists
                const errorDiv = document.querySelector('.camera-error');
                if (errorDiv) {
                    errorDiv.remove();
                }
                
                // Enable mouse interactions on all interactive elements
                document.querySelectorAll('.gesture-interactive').forEach(el => {
                    el.classList.add('mouse-enabled');
                    el.style.cursor = 'pointer';
                    
                    // Add click handler
                    const existingHandler = el.onclick;
                    el.onclick = function(e) {
                        // Handle click based on element type
                        if (this.classList.contains('gesture-menu-item')) {
                            const action = this.dataset.action;
                            handleMenuAction(action);
                        } else if (existingHandler) {
                            existingHandler.call(this, e);
                        }
                    };
                });
                
                // Show controls hint for mouse
                const hint = document.getElementById('controls-hint');
                hint.textContent = 'Use WASD to move, Mouse to look, Click to interact';
                hint.style.opacity = '1';
                
                this.showGestureFeedback('Mouse controls enabled');
            }

            onHandResults(results) {
                const canvasElement = document.getElementById('gesture-canvas');
                const canvasCtx = canvasElement.getContext('2d');
                
                canvasCtx.save();
                canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
                
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const landmarks = results.multiHandLandmarks[0];
                    
                    // Draw hand skeleton
                    this.drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, 
                        { color: '#00FF00', lineWidth: 2 });
                    this.drawLandmarks(canvasCtx, landmarks, 
                        { color: '#FF0073', lineWidth: 1, radius: 3 });
                    
                    // Process gestures
                    this.processGesture(landmarks);
                    
                    // Update hand cursor position
                    this.updateHandCursor(landmarks);
                } else {
                    document.getElementById('hand-cursor').style.display = 'none';
                    this.currentGesture = null;
                }
                
                canvasCtx.restore();
            }

            processGesture(landmarks) {
                const gesture = this.detectGesture(landmarks);
                
                if (gesture !== this.lastGesture) {
                    this.onGestureChange(gesture);
                }
                
                // Handle gesture-specific actions
                switch (gesture) {
                    case 'pinch':
                        this.handlePinch(landmarks);
                        break;
                    case 'point':
                        this.handlePoint(landmarks);
                        break;
                    case 'fist':
                        this.handleFist(landmarks);
                        break;
                    case 'peace':
                        this.handlePeace(landmarks);
                        break;
                    case 'wave':
                        this.handleWave(landmarks);
                        break;
                    case 'open':
                        this.handleOpenHand(landmarks);
                        break;
                }
                
                this.lastGesture = gesture;
                this.currentGesture = gesture;
            }

            detectGesture(landmarks) {
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                const middleTip = landmarks[12];
                const ringTip = landmarks[16];
                const pinkyTip = landmarks[20];
                
                const indexMCP = landmarks[5];
                const middleMCP = landmarks[9];
                const ringMCP = landmarks[13];
                const pinkyMCP = landmarks[17];
                
                // Calculate pinch distance
                const pinchDistance = Math.sqrt(
                    Math.pow(thumbTip.x - indexTip.x, 2) + 
                    Math.pow(thumbTip.y - indexTip.y, 2)
                );
                
                // Check finger states
                const indexUp = indexTip.y < indexMCP.y;
                const middleUp = middleTip.y < middleMCP.y;
                const ringUp = ringTip.y < ringMCP.y;
                const pinkyUp = pinkyTip.y < pinkyMCP.y;
                
                // Detect wave gesture
                if (this.detectWaveMotion(landmarks)) {
                    return 'wave';
                }
                
                // Detect pinch
                if (pinchDistance < this.pinchThreshold) {
                    return 'pinch';
                }
                
                // Detect pointing
                if (indexUp && !middleUp && !ringUp && !pinkyUp) {
                    return 'point';
                }
                
                // Detect fist
                if (!indexUp && !middleUp && !ringUp && !pinkyUp) {
                    return 'fist';
                }
                
                // Detect peace sign
                if (indexUp && middleUp && !ringUp && !pinkyUp) {
                    return 'peace';
                }
                
                // Detect open hand
                if (indexUp && middleUp && ringUp && pinkyUp) {
                    return 'open';
                }
                
                return 'unknown';
            }

            detectWaveMotion(landmarks) {
                const wrist = landmarks[0];
                
                if (!this.lastHandPosition) {
                    this.lastHandPosition = { x: wrist.x, y: wrist.y };
                    return false;
                }
                
                const deltaX = Math.abs(wrist.x - this.lastHandPosition.x);
                const deltaY = Math.abs(wrist.y - this.lastHandPosition.y);
                
                this.gestureHistory.push({ deltaX, deltaY, time: Date.now() });
                
                // Keep only recent history
                const recentHistory = this.gestureHistory.filter(h => 
                    Date.now() - h.time < 500
                );
                this.gestureHistory = recentHistory;
                
                // Detect wave pattern
                if (recentHistory.length > 5) {
                    const avgDeltaX = recentHistory.reduce((sum, h) => sum + h.deltaX, 0) / recentHistory.length;
                    if (avgDeltaX > 0.02 && deltaY < 0.01) {
                        this.lastHandPosition = { x: wrist.x, y: wrist.y };
                        return true;
                    }
                }
                
                this.lastHandPosition = { x: wrist.x, y: wrist.y };
                return false;
            }

            onGestureChange(gesture) {
                document.getElementById('gesture-status').textContent = gesture.charAt(0).toUpperCase() + gesture.slice(1);
                
                if (gesture !== 'unknown') {
                    this.showGestureFeedback(gesture.charAt(0).toUpperCase() + gesture.slice(1));
                }
            }

            handlePinch(landmarks) {
                const indexTip = landmarks[8];
                const cursorX = (1 - indexTip.x) * window.innerWidth;
                const cursorY = indexTip.y * window.innerHeight;
                
                // Check for interactive elements
                const elements = document.elementsFromPoint(cursorX, cursorY);
                
                for (const element of elements) {
                    if (element.classList.contains('gesture-interactive') || 
                        element.classList.contains('portal') ||
                        element.classList.contains('gesture-menu-item')) {
                        element.click();
                        this.showGestureFeedback('Selected!');
                        break;
                    }
                }
            }

            handlePoint(landmarks) {
                const indexTip = landmarks[8];
                const cursorX = (1 - indexTip.x) * window.innerWidth;
                const cursorY = indexTip.y * window.innerHeight;
                
                // Teleport in 3D world
                if (window.worldNavigator && window.worldNavigator.gestureManager) {
                    window.worldNavigator.gestureManager.handleTeleport(cursorX, cursorY);
                }
            }

            handleFist(landmarks) {
                if (!this.rotationStart) {
                    this.rotationStart = { x: landmarks[0].x, y: landmarks[0].y };
                }
                
                const deltaX = (landmarks[0].x - this.rotationStart.x) * 5;
                const deltaY = (landmarks[0].y - this.rotationStart.y) * 5;
                
                // Rotate camera
                if (window.worldNavigator && window.worldNavigator.camera) {
                    window.worldNavigator.controls.rotateSpeed = 2;
                    window.worldNavigator.controls.rotate(deltaX, deltaY);
                }
                
                this.rotationStart = { x: landmarks[0].x, y: landmarks[0].y };
            }

            handlePeace(landmarks) {
                const indexTip = landmarks[8];
                const middleTip = landmarks[12];
                const distance = Math.abs(indexTip.y - middleTip.y);
                
                // Zoom camera
                if (window.worldNavigator && window.worldNavigator.camera) {
                    const zoom = 20 + distance * 100;
                    window.worldNavigator.camera.position.z = Math.max(10, Math.min(50, zoom));
                }
            }

            handleWave(landmarks) {
                // Toggle menu
                this.toggleMenu();
            }

            handleOpenHand(landmarks) {
                this.rotationStart = null;
                
                // Navigate in 3D space
                if (window.worldNavigator && this.lastHandPosition) {
                    const wrist = landmarks[0];
                    const deltaX = (wrist.x - 0.5) * 10;
                    const deltaZ = (wrist.y - 0.5) * 10;
                    
                    window.worldNavigator.movePlayer(deltaX, 0, deltaZ);
                }
            }

            updateHandCursor(landmarks) {
                const indexTip = landmarks[8];
                const cursorX = (1 - indexTip.x) * window.innerWidth;
                const cursorY = indexTip.y * window.innerHeight;
                
                const cursor = document.getElementById('hand-cursor');
                cursor.style.left = cursorX + 'px';
                cursor.style.top = cursorY + 'px';
                cursor.style.display = 'block';
                
                // Update cursor style based on gesture
                cursor.className = 'hand-cursor';
                if (this.currentGesture === 'pinch') {
                    cursor.classList.add('pinching');
                } else if (this.currentGesture === 'point') {
                    cursor.classList.add('pointing');
                }
                
                // Check for hover effects
                this.updateHoverEffects(cursorX, cursorY);
            }

            updateHoverEffects(x, y) {
                const elements = document.elementsFromPoint(x, y);
                const interactiveElements = new Set();
                
                for (const element of elements) {
                    if (element.classList.contains('gesture-interactive') || 
                        element.classList.contains('portal') ||
                        element.classList.contains('gesture-menu-item')) {
                        interactiveElements.add(element);
                        if (!this.hoveredElements.has(element)) {
                            element.classList.add('gesture-hover');
                        }
                    }
                }
                
                // Remove hover from elements no longer hovered
                for (const element of this.hoveredElements) {
                    if (!interactiveElements.has(element)) {
                        element.classList.remove('gesture-hover');
                    }
                }
                
                this.hoveredElements = interactiveElements;
            }

            showGestureFeedback(text) {
                const feedback = document.getElementById('gesture-feedback');
                feedback.textContent = text;
                feedback.classList.add('show');
                
                setTimeout(() => {
                    feedback.classList.remove('show');
                }, 1500);
            }

            toggleMenu() {
                const menu = document.getElementById('gesture-menu');
                this.menuOpen = !this.menuOpen;
                
                if (this.menuOpen) {
                    menu.classList.add('open');
                    this.showGestureFeedback('Menu opened');
                } else {
                    menu.classList.remove('open');
                    this.showGestureFeedback('Menu closed');
                }
            }

            drawConnectors(ctx, landmarks, connections, style) {
                ctx.strokeStyle = style.color;
                ctx.lineWidth = style.lineWidth;
                
                connections.forEach(([start, end]) => {
                    const startPoint = landmarks[start];
                    const endPoint = landmarks[end];
                    
                    ctx.beginPath();
                    ctx.moveTo(startPoint.x * ctx.canvas.width, startPoint.y * ctx.canvas.height);
                    ctx.lineTo(endPoint.x * ctx.canvas.width, endPoint.y * ctx.canvas.height);
                    ctx.stroke();
                });
            }

            drawLandmarks(ctx, landmarks, style) {
                ctx.fillStyle = style.color;
                
                landmarks.forEach(landmark => {
                    ctx.beginPath();
                    ctx.arc(
                        landmark.x * ctx.canvas.width,
                        landmark.y * ctx.canvas.height,
                        style.radius,
                        0,
                        2 * Math.PI
                    );
                    ctx.fill();
                });
            }

            minimizeTracker() {
                const container = document.getElementById('hand-tracking-container');
                container.classList.toggle('minimized');
                
                if (container.classList.contains('minimized')) {
                    this.showGestureFeedback('Tracker minimized');
                } else {
                    this.showGestureFeedback('Tracker restored');
                }
            }
        }

        // MediaPipe hand connections
        const HAND_CONNECTIONS = [
            [0, 1], [1, 2], [2, 3], [3, 4],
            [0, 5], [5, 6], [6, 7], [7, 8],
            [5, 9], [9, 10], [10, 11], [11, 12],
            [9, 13], [13, 14], [14, 15], [15, 16],
            [13, 17], [17, 18], [18, 19], [19, 20],
            [0, 17]
        ];

        // Initialize gesture controller globally
        window.gestureController = new GestureController();

        // Handle menu actions
        function handleMenuAction(action) {
            switch(action) {
                case 'toggleAI':
                    document.getElementById('ai-companion-button').click();
                    break;
                case 'togglePortals':
                    document.getElementById('portal-manager-btn').click();
                    break;
                case 'toggleRecorder':
                    document.getElementById('scene-recorder-button').click();
                    break;
                case 'toggleTasks':
                    document.getElementById('tasks-button').click();
                    break;
                case 'minimizeHand':
                    window.gestureController.minimizeTracker();
                    break;
            }
            
            if (!window.gestureController.fallbackToMouse) {
                window.gestureController.toggleMenu(); // Close menu after action
            }
        }

        // Gesture menu handlers
        document.querySelectorAll('.gesture-menu-item').forEach(item => {
            item.addEventListener('click', function() {
                const action = this.dataset.action;
                handleMenuAction(action);
            });
        });

        // Make hand tracking container clickable when minimized
        document.getElementById('hand-tracking-container').addEventListener('click', function(e) {
            if (this.classList.contains('minimized')) {
                window.gestureController.minimizeTracker();
            }
        });

        // Default world attributes
        const DEFAULT_WORLD_ATTRIBUTES = {
            name: "Nexus Hub",
            description: "The central hub connecting all worlds. Step through the portals to explore different dimensions.",
            ambientColor: 0x0a0a0a,
            fogColor: 0x000033,
            groundColor: 0x1a1a2e,
            skyColor: 0x16213e,
            moveSpeed: 0.15,
            lookSpeed: 0.002,
            portalColor1: 0x00ffff,
            portalColor2: 0xff00ff,
            particleCount: 1000,
            cameraHeight: 2,
            fogNear: 10,
            fogFar: 100
        };

        // Parse inherited attributes from URL
        function parseInheritedAttributes() {
            let paramString = window.INJECTED_PARAMS || window.location.search;

            if (window.location.protocol === 'blob:') {
                const storedParams = sessionStorage.getItem('worldInheritanceParams');
                if (storedParams) {
                    paramString = storedParams;
                }
            }

            if (!paramString || paramString === '?') {
                const transitionData = localStorage.getItem('worldTransition');
                if (transitionData) {
                    try {
                        const data = JSON.parse(transitionData);
                        if (Date.now() - data.timestamp < 5000) {
                            paramString = '?' + data.params;
                        }
                    } catch (e) {
                        console.error('Error parsing transition data:', e);
                    }
                    localStorage.removeItem('worldTransition');
                }
            }

            const params = new URLSearchParams(paramString);
            const inherited = {};

            inherited.sourceWorld = params.get('from') || null;
            inherited.sourceWorldName = params.get('fromName') || null;

            // Visual attributes only (no moveSpeed)
            if (params.has('lookSpeed')) inherited.lookSpeed = parseFloat(params.get('lookSpeed'));
            if (params.has('ambientColor')) inherited.ambientColor = parseInt(params.get('ambientColor'), 16);
            if (params.has('fogColor')) inherited.fogColor = parseInt(params.get('fogColor'), 16);
            if (params.has('portalColor1')) inherited.portalColor1 = parseInt(params.get('portalColor1'), 16);
            if (params.has('portalColor2')) inherited.portalColor2 = parseInt(params.get('portalColor2'), 16);
            if (params.has('particleCount')) inherited.particleCount = parseInt(params.get('particleCount'));
            if (params.has('cameraHeight')) inherited.cameraHeight = parseFloat(params.get('cameraHeight'));
            if (params.has('fogNear')) inherited.fogNear = parseFloat(params.get('fogNear'));
            if (params.has('fogFar')) inherited.fogFar = parseFloat(params.get('fogFar'));

            console.log('Parsed inherited attributes:', inherited);
            return inherited;
        }

        const inheritedAttributes = parseInheritedAttributes();
        const CURRENT_WORLD = { ...DEFAULT_WORLD_ATTRIBUTES, ...inheritedAttributes };

        // Add THREE.js extensions
        THREE.FontLoader = class FontLoader extends THREE.Loader {
            constructor(manager) {
                super(manager);
            }

            load(url, onLoad, onProgress, onError) {
                const scope = this;
                const loader = new THREE.FileLoader(this.manager);
                loader.setPath(this.path);
                loader.setRequestHeader(this.requestHeader);
                loader.setWithCredentials(this.withCredentials);
                loader.load(url, function(text) {
                    try {
                        const json = JSON.parse(text);
                        const font = scope.parse(json);
                        if (onLoad) onLoad(font);
                    } catch (e) {
                        console.warn('THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.');
                        if (onError) onError(e);
                    }
                }, onProgress, onError);
            }

            parse(json) {
                return new THREE.Font(json);
            }
        };

        THREE.Font = class Font {
            constructor(data) {
                this.type = 'Font';
                this.data = data;
            }

            generateShapes(text, size = 100) {
                const shapes = [];
                const paths = createPaths(text, size, this.data);

                for (let p = 0, pl = paths.length; p < pl; p++) {
                    Array.prototype.push.apply(shapes, paths[p].toShapes());
                }

                return shapes;
            }
        };

        THREE.TextGeometry = class TextGeometry extends THREE.ExtrudeGeometry {
            constructor(text, parameters = {}) {
                const font = parameters.font;

                if (!font || !font.data) {
                    console.error('THREE.TextGeometry: font parameter is not an instance of THREE.Font.');
                    super();
                    return;
                }

                const shapes = font.generateShapes(text, parameters.size);

                parameters.depth = parameters.height !== undefined ? parameters.height : 50;

                if (parameters.bevelThickness === undefined) parameters.bevelThickness = 10;
                if (parameters.bevelSize === undefined) parameters.bevelSize = 8;
                if (parameters.bevelEnabled === undefined) parameters.bevelEnabled = false;

                super(shapes, parameters);

                this.type = 'TextGeometry';
            }
        };

        function createPaths(text, size, data) {
            const chars = Array.from(text);
            const scale = size / data.resolution;
            const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;

            const paths = [];

            let offsetX = 0, offsetY = 0;

            for (let i = 0; i < chars.length; i++) {
                const char = chars[i];

                if (char === '\n') {
                    offsetX = 0;
                    offsetY -= line_height;
                } else {
                    const ret = createPath(char, scale, offsetX, offsetY, data);
                    if (ret) {
                        offsetX += ret.offsetX;
                        paths.push(ret.path);
                    }
                }
            }

            return paths;
        }

        function createPath(char, scale, offsetX, offsetY, data) {
            const glyph = data.glyphs[char] || data.glyphs['?'];

            if (!glyph) {
                console.error('THREE.Font: character "' + char + '" does not exists in font family ' + data.familyName + '.');
                return;
            }

            const path = new THREE.ShapePath();

            let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;

            if (glyph.o) {
                const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '));

                for (let i = 0, l = outline.length; i < l;) {
                    const action = outline[i++];

                    switch (action) {
                        case 'm':
                            x = outline[i++] * scale + offsetX;
                            y = outline[i++] * scale + offsetY;
                            path.moveTo(x, y);
                            break;

                        case 'l':
                            x = outline[i++] * scale + offsetX;
                            y = outline[i++] * scale + offsetY;
                            path.lineTo(x, y);
                            break;

                        case 'q':
                            cpx = outline[i++] * scale + offsetX;
                            cpy = outline[i++] * scale + offsetY;
                            cpx1 = outline[i++] * scale + offsetX;
                            cpy1 = outline[i++] * scale + offsetY;
                            path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
                            break;

                        case 'b':
                            cpx = outline[i++] * scale + offsetX;
                            cpy = outline[i++] * scale + offsetY;
                            cpx1 = outline[i++] * scale + offsetX;
                            cpy1 = outline[i++] * scale + offsetY;
                            cpx2 = outline[i++] * scale + offsetX;
                            cpy2 = outline[i++] * scale + offsetY;
                            path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
                            break;
                    }
                }
            }

            return { offsetX: glyph.ha * scale, path: path };
        }

        // Main World Navigator Class with Gesture Support
        class WorldNavigator {
            constructor() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                this.clock = new THREE.Clock();
                
                this.portals = [];
                this.particles = null;
                this.font = null;
                this.worldData = {};
                this.localPortals = [];
                
                // Player state
                this.player = {
                    position: new THREE.Vector3(0, CURRENT_WORLD.cameraHeight, 0),
                    velocity: new THREE.Vector3(0, 0, 0),
                    rotation: { x: 0, y: 0 },
                    grounded: true
                };

                // Controls
                this.keys = {};
                this.mouse = { x: 0, y: 0 };
                this.raycaster = new THREE.Raycaster();
                this.controls = null;

                // Gesture support
                this.gestureManager = {
                    handleTeleport: (x, y) => {
                        const mouse = new THREE.Vector2(
                            (x / window.innerWidth) * 2 - 1,
                            -(y / window.innerHeight) * 2 + 1
                        );
                        
                        this.raycaster.setFromCamera(mouse, this.camera);
                        const intersects = this.raycaster.intersectObject(this.ground);
                        
                        if (intersects.length > 0) {
                            const point = intersects[0].point;
                            this.teleportPlayer(point.x, point.y + CURRENT_WORLD.cameraHeight, point.z);
                            window.gestureController.showGestureFeedback('Teleported!');
                        }
                    }
                };

                // AI Manager
                this.aiManager = new AIManager();
                
                // Task Manager
                this.taskManager = new TaskManager();
                
                // Scene Recorder
                this.sceneRecorder = new SceneRecorder();
                
                // Portal Manager
                this.portalManager = new PortalManager();

                this.init();
            }

            init() {
                // Setup renderer
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.getElementById('three-container').appendChild(this.renderer.domElement);

                // Setup scene
                this.scene.fog = new THREE.Fog(CURRENT_WORLD.fogColor, CURRENT_WORLD.fogNear, CURRENT_WORLD.fogFar);
                
                // Setup camera
                this.camera.position.copy(this.player.position);
                
                // Load font
                const loader = new THREE.FontLoader();
                loader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', (font) => {
                    this.font = font;
                    this.createWorld();
                });

                // Setup lights
                this.setupLights();
                
                // Setup controls
                this.setupControls();
                
                // Setup events
                this.setupEvents();
                
                // Start animation
                this.animate();
            }

            setupLights() {
                const ambientLight = new THREE.AmbientLight(CURRENT_WORLD.ambientColor, 0.6);
                this.scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(50, 100, 50);
                directionalLight.castShadow = true;
                directionalLight.shadow.camera.left = -100;
                directionalLight.shadow.camera.right = 100;
                directionalLight.shadow.camera.top = 100;
                directionalLight.shadow.camera.bottom = -100;
                directionalLight.shadow.camera.near = 0.1;
                directionalLight.shadow.camera.far = 200;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                this.scene.add(directionalLight);
            }

            createWorld() {
                // Create ground
                const groundGeometry = new THREE.PlaneGeometry(500, 500, 50, 50);
                const groundMaterial = new THREE.MeshStandardMaterial({ 
                    color: CURRENT_WORLD.groundColor,
                    roughness: 0.8,
                    metalness: 0.2
                });
                
                // Add some terrain variation
                const vertices = groundGeometry.attributes.position.array;
                for (let i = 0; i < vertices.length; i += 3) {
                    vertices[i + 2] = Math.sin(vertices[i] * 0.05) * Math.cos(vertices[i + 1] * 0.05) * 2;
                }
                groundGeometry.computeVertexNormals();
                
                this.ground = new THREE.Mesh(groundGeometry, groundMaterial);
                this.ground.rotation.x = -Math.PI / 2;
                this.ground.receiveShadow = true;
                this.scene.add(this.ground);

                // Create skybox
                this.createSkybox();
                
                // Create particles
                this.createParticles();
                
                // Create center structure
                this.createCenterStructure();
                
                // Create default portals
                this.createDefaultPortals();
            }

            createSkybox() {
                const skyGeometry = new THREE.SphereGeometry(400, 32, 32);
                const skyMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        topColor: { value: new THREE.Color(CURRENT_WORLD.skyColor) },
                        bottomColor: { value: new THREE.Color(0x000000) },
                        offset: { value: 33 },
                        exponent: { value: 0.6 }
                    },
                    vertexShader: `
                        varying vec3 vWorldPosition;
                        void main() {
                            vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                            vWorldPosition = worldPosition.xyz;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform vec3 topColor;
                        uniform vec3 bottomColor;
                        uniform float offset;
                        uniform float exponent;
                        varying vec3 vWorldPosition;
                        void main() {
                            float h = normalize(vWorldPosition + offset).y;
                            gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 1.0);
                        }
                    `,
                    side: THREE.BackSide
                });
                
                const sky = new THREE.Mesh(skyGeometry, skyMaterial);
                this.scene.add(sky);
            }

            createParticles() {
                const particleCount = CURRENT_WORLD.particleCount;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);
                
                for (let i = 0; i < particleCount * 3; i += 3) {
                    positions[i] = (Math.random() - 0.5) * 200;
                    positions[i + 1] = Math.random() * 100;
                    positions[i + 2] = (Math.random() - 0.5) * 200;
                    
                    const color = new THREE.Color();
                    color.setHSL(Math.random() * 0.1 + 0.6, 0.8, 0.5);
                    colors[i] = color.r;
                    colors[i + 1] = color.g;
                    colors[i + 2] = color.b;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                
                const material = new THREE.PointsMaterial({
                    size: 0.5,
                    vertexColors: true,
                    blending: THREE.AdditiveBlending,
                    transparent: true,
                    opacity: 0.8
                });
                
                this.particles = new THREE.Points(geometry, material);
                this.scene.add(this.particles);
            }

            createCenterStructure() {
                const group = new THREE.Group();
                
                // Create rings
                for (let i = 0; i < 3; i++) {
                    const radius = 10 + i * 5;
                    const geometry = new THREE.TorusGeometry(radius, 0.5, 16, 100);
                    const material = new THREE.MeshStandardMaterial({
                        color: new THREE.Color().setHSL(0.6 + i * 0.1, 0.8, 0.5),
                        emissive: new THREE.Color().setHSL(0.6 + i * 0.1, 0.8, 0.3),
                        emissiveIntensity: 0.5,
                        metalness: 0.8,
                        roughness: 0.2
                    });
                    const ring = new THREE.Mesh(geometry, material);
                    ring.rotation.x = Math.PI / 2;
                    ring.position.y = 5 + i * 3;
                    group.add(ring);
                }
                
                // Create central crystal
                const crystalGeometry = new THREE.OctahedronGeometry(3, 0);
                const crystalMaterial = new THREE.MeshStandardMaterial({
                    color: 0x00ffff,
                    emissive: 0x00ffff,
                    emissiveIntensity: 0.5,
                    metalness: 0.9,
                    roughness: 0.1,
                    transparent: true,
                    opacity: 0.8
                });
                const crystal = new THREE.Mesh(crystalGeometry, crystalMaterial);
                crystal.position.y = 10;
                group.add(crystal);
                
                // Add floating text if font is loaded
                if (this.font && CURRENT_WORLD.name) {
                    const textGeometry = new THREE.TextGeometry(CURRENT_WORLD.name, {
                        font: this.font,
                        size: 3,
                        height: 0.5,
                        curveSegments: 12,
                        bevelEnabled: true,
                        bevelThickness: 0.1,
                        bevelSize: 0.1,
                        bevelSegments: 5
                    });
                    textGeometry.center();
                    
                    const textMaterial = new THREE.MeshStandardMaterial({
                        color: 0xffffff,
                        emissive: 0x00ffff,
                        emissiveIntensity: 0.3,
                        metalness: 0.7,
                        roughness: 0.3
                    });
                    
                    const textMesh = new THREE.Mesh(textGeometry, textMaterial);
                    textMesh.position.y = 20;
                    group.add(textMesh);
                }
                
                this.centerStructure = group;
                this.scene.add(group);
            }

            createDefaultPortals() {
                const defaultPortals = [
                    { name: "Cyber City", type: "tech", url: "cybercity.html", description: "A futuristic metropolis" },
                    { name: "Crystal Caves", type: "nature", url: "crystalcaves.html", description: "Underground crystal formations" },
                    { name: "Sky Islands", type: "fantasy", url: "skyislands.html", description: "Floating islands in the clouds" },
                    { name: "Quantum Lab", type: "science", url: "quantumlab.html", description: "Experimental physics laboratory" },
                    { name: "Ancient Temple", type: "mystery", url: "temple.html", description: "Mysterious ancient ruins" },
                    { name: "Space Station", type: "space", url: "spacestation.html", description: "Orbiting space habitat" }
                ];
                
                const angleStep = (Math.PI * 2) / defaultPortals.length;
                
                defaultPortals.forEach((portal, index) => {
                    const angle = angleStep * index;
                    const distance = 30;
                    const x = Math.cos(angle) * distance;
                    const z = Math.sin(angle) * distance;
                    
                    this.createPortal(x, 5, z, portal);
                });
            }

            createPortal(x, y, z, portalData) {
                const portalGroup = new THREE.Group();
                portalGroup.position.set(x, y, z);
                
                // Portal frame
                const frameGeometry = new THREE.TorusGeometry(4, 0.5, 8, 50);
                const frameMaterial = new THREE.MeshStandardMaterial({
                    color: CURRENT_WORLD.portalColor1,
                    emissive: CURRENT_WORLD.portalColor1,
                    emissiveIntensity: 0.5,
                    metalness: 0.9,
                    roughness: 0.1
                });
                const frame = new THREE.Mesh(frameGeometry, frameMaterial);
                portalGroup.add(frame);
                
                // Portal surface
                const portalGeometry = new THREE.CircleGeometry(3.5, 32);
                const portalMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        color1: { value: new THREE.Color(CURRENT_WORLD.portalColor1) },
                        color2: { value: new THREE.Color(CURRENT_WORLD.portalColor2) }
                    },
                    vertexShader: `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform float time;
                        uniform vec3 color1;
                        uniform vec3 color2;
                        varying vec2 vUv;
                        void main() {
                            vec2 center = vec2(0.5, 0.5);
                            float dist = distance(vUv, center);
                            float wave = sin(dist * 10.0 - time * 2.0) * 0.5 + 0.5;
                            vec3 color = mix(color1, color2, wave);
                            float alpha = 1.0 - dist * 2.0;
                            gl_FragColor = vec4(color, alpha * 0.8);
                        }
                    `,
                    transparent: true,
                    side: THREE.DoubleSide
                });
                const portal = new THREE.Mesh(portalGeometry, portalMaterial);
                portalGroup.add(portal);
                
                // Add portal label
                if (this.font && portalData.name) {
                    const labelGeometry = new THREE.TextGeometry(portalData.name, {
                        font: this.font,
                        size: 0.8,
                        height: 0.1,
                        curveSegments: 12
                    });
                    labelGeometry.center();
                    
                    const labelMaterial = new THREE.MeshStandardMaterial({
                        color: 0xffffff,
                        emissive: 0xffffff,
                        emissiveIntensity: 0.3
                    });
                    
                    const label = new THREE.Mesh(labelGeometry, labelMaterial);
                    label.position.y = 5;
                    portalGroup.add(label);
                }
                
                // Create invisible interaction sphere for gestures
                const interactionGeometry = new THREE.SphereGeometry(5, 16, 16);
                const interactionMaterial = new THREE.MeshBasicMaterial({visible: false
                });
                const interactionMesh = new THREE.Mesh(interactionGeometry, interactionMaterial);
                interactionMesh.userData = { portal: portalData, type: 'portal' };
                portalGroup.add(interactionMesh);
                
                // Store portal data
                portalGroup.userData = portalData;
                portalGroup.userData.portalMaterial = portalMaterial;
                
                // Add gesture indicator
                const indicatorGeometry = new THREE.RingGeometry(4.5, 5, 32);
                const indicatorMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ff00,
                    transparent: true,
                    opacity: 0,
                    side: THREE.DoubleSide
                });
                const indicator = new THREE.Mesh(indicatorGeometry, indicatorMaterial);
                indicator.userData.isIndicator = true;
                portalGroup.add(indicator);
                portalGroup.userData.indicator = indicator;
                
                this.portals.push(portalGroup);
                this.scene.add(portalGroup);
            }

            teleportPlayer(x, y, z) {
                this.player.position.set(x, y, z);
                this.camera.position.copy(this.player.position);
            }

            movePlayer(dx, dy, dz) {
                this.player.position.x += dx * 0.1;
                this.player.position.z += dz * 0.1;
                this.camera.position.copy(this.player.position);
            }

            setupControls() {
                // Pointer lock controls for non-gesture navigation
                this.controls = {
                    rotateSpeed: 1,
                    rotate: (dx, dy) => {
                        this.player.rotation.y -= dx * this.controls.rotateSpeed * 0.01;
                        this.player.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, 
                            this.player.rotation.x - dy * this.controls.rotateSpeed * 0.01));
                    }
                };

                // Keyboard controls
                document.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;
                });
                
                document.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                });
                
                // Mouse controls (disabled when using gestures)
                document.addEventListener('mousemove', (e) => {
                    if (window.gestureController && window.gestureController.fallbackToMouse) {
                        this.mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                        this.mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                    }
                });
                
                document.addEventListener('click', (e) => {
                    if (window.gestureController && window.gestureController.fallbackToMouse) {
                        this.handleClick(e);
                    }
                });
            }

            setupEvents() {
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
                
                // Handle visibility change
                document.addEventListener('visibilitychange', () => {
                    if (document.hidden) {
                        this.keys = {}; // Reset keys when tab loses focus
                    }
                });

                // Share button
                document.getElementById('share-button').addEventListener('click', () => {
                    document.getElementById('qr-modal').classList.add('show');
                    this.generateQRCode();
                });

                document.getElementById('qr-close').addEventListener('click', () => {
                    document.getElementById('qr-modal').classList.remove('show');
                });

                document.getElementById('copy-url-btn').addEventListener('click', () => {
                    const url = window.location.href;
                    navigator.clipboard.writeText(url).then(() => {
                        const btn = document.getElementById('copy-url-btn');
                        btn.textContent = 'Copied!';
                        btn.classList.add('copied');
                        setTimeout(() => {
                            btn.textContent = 'Copy URL';
                            btn.classList.remove('copied');
                        }, 2000);
                    });
                });
            }

            generateQRCode() {
                const url = window.location.href;
                document.getElementById('qr-url').textContent = url;
                
                // Create a simple QR code placeholder
                const container = document.getElementById('qr-code-container');
                container.innerHTML = `
                    <div style="width: 200px; height: 200px; display: flex; align-items: center; justify-content: center; background: #f0f0f0; color: #333; border-radius: 10px;">
                        <div style="text-align: center;">
                            <p style="margin: 0; font-size: 14px;">QR Code</p>
                            <p style="margin: 10px 0 0 0; font-size: 12px;">Share this world</p>
                        </div>
                    </div>
                `;
            }

            handleClick(event) {
                const mouse = new THREE.Vector2(
                    (event.clientX / window.innerWidth) * 2 - 1,
                    -(event.clientY / window.innerHeight) * 2 + 1
                );
                
                this.raycaster.setFromCamera(mouse, this.camera);
                
                // Check portal interactions
                for (const portal of this.portals) {
                    const interactionMesh = portal.children.find(child => 
                        child.userData && child.userData.type === 'portal'
                    );
                    
                    if (interactionMesh) {
                        const intersects = this.raycaster.intersectObject(interactionMesh);
                        if (intersects.length > 0) {
                            this.enterPortal(portal.userData);
                            break;
                        }
                    }
                }
            }

            enterPortal(portalData) {
                if (portalData.url) {
                    // Show transition effect
                    const transition = document.createElement('div');
                    transition.style.cssText = `
                        position: fixed;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: white;
                        opacity: 0;
                        z-index: 9999;
                        transition: opacity 0.5s;
                    `;
                    document.body.appendChild(transition);
                    
                    setTimeout(() => {
                        transition.style.opacity = '1';
                    }, 10);
                    
                    setTimeout(() => {
                        window.location.href = portalData.url;
                    }, 500);
                }
            }

            updatePlayer(delta) {
                // Handle keyboard movement
                const moveSpeed = CURRENT_WORLD.moveSpeed;
                const forward = new THREE.Vector3(0, 0, -1);
                const right = new THREE.Vector3(1, 0, 0);
                
                forward.applyEuler(new THREE.Euler(0, this.player.rotation.y, 0));
                right.applyEuler(new THREE.Euler(0, this.player.rotation.y, 0));
                
                if (this.keys['KeyW']) this.player.velocity.add(forward.multiplyScalar(moveSpeed));
                if (this.keys['KeyS']) this.player.velocity.add(forward.multiplyScalar(-moveSpeed));
                if (this.keys['KeyA']) this.player.velocity.add(right.multiplyScalar(-moveSpeed));
                if (this.keys['KeyD']) this.player.velocity.add(right.multiplyScalar(moveSpeed));
                
                // Apply velocity
                this.player.position.add(this.player.velocity);
                
                // Friction
                this.player.velocity.multiplyScalar(0.9);
                
                // Update camera
                this.camera.position.copy(this.player.position);
                this.camera.rotation.x = this.player.rotation.x;
                this.camera.rotation.y = this.player.rotation.y;
            }

            updatePortals(delta) {
                const time = this.clock.getElapsedTime();
                
                this.portals.forEach((portal, index) => {
                    // Rotate portal
                    portal.rotation.y += delta * 0.5;
                    
                    // Update shader time
                    if (portal.userData.portalMaterial) {
                        portal.userData.portalMaterial.uniforms.time.value = time;
                    }
                    
                    // Float animation
                    portal.position.y = 5 + Math.sin(time + index) * 0.5;
                    
                    // Check distance for gesture interaction
                    const distance = this.player.position.distanceTo(portal.position);
                    if (distance < 10 && portal.userData.indicator) {
                        portal.userData.indicator.material.opacity = 0.3 + Math.sin(time * 3) * 0.2;
                    } else if (portal.userData.indicator) {
                        portal.userData.indicator.material.opacity = 0;
                    }
                });
            }

            updateParticles(delta) {
                if (this.particles) {
                    this.particles.rotation.y += delta * 0.05;
                    
                    const positions = this.particles.geometry.attributes.position.array;
                    for (let i = 1; i < positions.length; i += 3) {
                        positions[i] -= delta * 10;
                        if (positions[i] < 0) {
                            positions[i] = 100;
                        }
                    }
                    this.particles.geometry.attributes.position.needsUpdate = true;
                }
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                
                const delta = this.clock.getDelta();
                
                this.updatePlayer(delta);
                this.updatePortals(delta);
                this.updateParticles(delta);
                
                if (this.centerStructure) {
                    this.centerStructure.rotation.y += delta * 0.1;
                }
                
                this.renderer.render(this.scene, this.camera);
            }
        }

        // AI Manager
        class AIManager {
            constructor() {
                this.apiKey = null;
                this.messages = [];
                this.isProcessing = false;
                
                this.setupUI();
            }

            setupUI() {
                // AI companion button
                document.getElementById('ai-companion-button').addEventListener('click', () => {
                    const chatInterface = document.getElementById('ai-chat-interface');
                    if (chatInterface.classList.contains('active')) {
                        chatInterface.classList.remove('active');
                    } else {
                        chatInterface.classList.add('active');
                        if (!this.apiKey) {
                            document.getElementById('ai-modal').classList.add('show');
                        }
                    }
                });

                // API key activation
                document.getElementById('ai-activate-btn').addEventListener('click', () => {
                    const apiKey = document.getElementById('ai-api-key').value;
                    if (apiKey) {
                        this.apiKey = apiKey;
                        document.getElementById('ai-modal').classList.remove('show');
                        this.addSystemMessage('AI Companion activated! How can I help you explore the Nexus?');
                    }
                });

                // Close buttons
                document.getElementById('ai-close').addEventListener('click', () => {
                    document.getElementById('ai-modal').classList.remove('show');
                });
            }

            async sendMessage(message) {
                if (!message) {
                    message = document.getElementById('ai-chat-input').value;
                }

                if (!message.trim() || !this.apiKey || this.isProcessing) return;

                // Add user message
                this.addMessage(message, 'user');
                document.getElementById('ai-chat-input').value = '';

                // Show typing indicator
                this.showTypingIndicator();
                this.isProcessing = true;

                try {
                    const response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${this.apiKey}`
                        },
                        body: JSON.stringify({
                            model: 'gpt-4',
                            messages: [
                                {
                                    role: 'system',
                                    content: 'You are an AI companion in a virtual world called the Nexus Hub. Help users navigate between worlds, understand the interface, and provide guidance about their journey through different dimensions. Be helpful, friendly, and immersive.'
                                },
                                ...this.messages.map(m => ({
                                    role: m.type === 'user' ? 'user' : 'assistant',
                                    content: m.content
                                })),
                                { role: 'user', content: message }
                            ],
                            max_tokens: 500,
                            temperature: 0.8
                        })
                    });

                    if (!response.ok) {
                        throw new Error('API request failed');
                    }

                    const data = await response.json();
                    const aiResponse = data.choices[0].message.content;

                    this.hideTypingIndicator();
                    this.addMessage(aiResponse, 'ai');

                } catch (error) {
                    console.error('AI Error:', error);
                    this.hideTypingIndicator();
                    this.addMessage('Sorry, I encountered an error. Please check your API key and try again.', 'ai');
                }

                this.isProcessing = false;
            }

            addMessage(content, type) {
                const message = { content, type, timestamp: Date.now() };
                this.messages.push(message);

                const messagesContainer = document.getElementById('ai-chat-messages');
                const messageEl = document.createElement('div');
                messageEl.className = `ai-message ${type}`;
                messageEl.textContent = content;
                messagesContainer.appendChild(messageEl);

                // Scroll to bottom
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }

            addSystemMessage(content) {
                const messagesContainer = document.getElementById('ai-chat-messages');
                const messageEl = document.createElement('div');
                messageEl.className = 'ai-message system';
                messageEl.innerHTML = `
                    <div class="agent-log-section">
                        <div class="agent-log-header">System</div>
                        <div class="agent-log-content">${content}</div>
                    </div>
                `;
                messagesContainer.appendChild(messageEl);
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }

            showTypingIndicator() {
                const messagesContainer = document.getElementById('ai-chat-messages');
                const typingEl = document.createElement('div');
                typingEl.className = 'ai-typing';
                typingEl.id = 'typing-indicator';
                typingEl.innerHTML = `
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                `;
                messagesContainer.appendChild(typingEl);
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }

            hideTypingIndicator() {
                const typingEl = document.getElementById('typing-indicator');
                if (typingEl) {
                    typingEl.remove();
                }
            }
        }

        // Task Manager
        class TaskManager {
            constructor() {
                this.tasks = this.loadTasks();
                this.setupUI();
            }

            setupUI() {
                document.getElementById('tasks-button').addEventListener('click', () => {
                    const panel = document.getElementById('task-panel');
                    panel.classList.toggle('active');
                    this.renderTasks();
                });

                // Handle conversation upload
                document.getElementById('conversation-upload-input').addEventListener('change', (e) => {
                    this.uploadConversation(e);
                });
            }

            loadTasks() {
                const saved = localStorage.getItem('nexus-tasks');
                return saved ? JSON.parse(saved) : [];
            }

            saveTasks() {
                localStorage.setItem('nexus-tasks', JSON.stringify(this.tasks));
            }

            uploadConversation(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const conversation = JSON.parse(e.target.result);
                        const task = {
                            id: Date.now(),
                            title: conversation.title || 'Uploaded Conversation',
                            conversation: conversation,
                            createdAt: new Date().toISOString()
                        };
                        this.tasks.push(task);
                        this.saveTasks();
                        this.renderTasks();
                        window.gestureController.showGestureFeedback('Conversation uploaded!');
                    } catch (error) {
                        console.error('Error parsing conversation:', error);
                        window.gestureController.showGestureFeedback('Invalid conversation file');
                    }
                };
                reader.readAsText(file);
            }

            renderTasks() {
                const taskList = document.getElementById('task-list');
                taskList.innerHTML = '';

                this.tasks.forEach(task => {
                    const taskEl = document.createElement('div');
                    taskEl.className = 'task-item gesture-interactive';
                    taskEl.innerHTML = `
                        <strong>${task.title}</strong>
                        <div class="conversation-info">
                            ${task.conversation.messages ? task.conversation.messages.length : 0} messages
                        </div>
                        <small>${new Date(task.createdAt).toLocaleDateString()}</small>
                    `;
                    taskEl.addEventListener('click', () => this.replayConversation(task));
                    taskList.appendChild(taskEl);
                });
            }

            replayConversation(task) {
                if (!task.conversation || !task.conversation.messages) return;

                const chatInterface = document.getElementById('ai-chat-interface');
                const messagesContainer = document.getElementById('ai-chat-messages');
                const replayIndicator = document.getElementById('task-replay-indicator');

                // Clear current messages
                messagesContainer.innerHTML = '';
                
                // Show chat interface and replay indicator
                chatInterface.classList.add('active');
                replayIndicator.classList.add('active');

                // Replay messages with delay
                let messageIndex = 0;
                const replayInterval = setInterval(() => {
                    if (messageIndex >= task.conversation.messages.length) {
                        clearInterval(replayInterval);
                        replayIndicator.classList.remove('active');
                        return;
                    }

                    const msg = task.conversation.messages[messageIndex];
                    const messageEl = document.createElement('div');
                    messageEl.className = `ai-message ${msg.role === 'user' ? 'user' : 'ai'} task-replay`;
                    messageEl.textContent = msg.content;
                    messagesContainer.appendChild(messageEl);
                    messagesContainer.scrollTop = messagesContainer.scrollHeight;

                    messageIndex++;
                }, 1000);
            }
        }

        // Scene Recorder
        class SceneRecorder {
            constructor() {
                this.isRecording = false;
                this.recordedFrames = [];
                this.startTime = 0;
                this.recordingInterval = null;
                this.playbackIndex = 0;
                this.playbackInterval = null;
                this.playbackSpeed = 1;
                this.savedScenes = this.loadScenes();
                
                this.setupUI();
            }

            setupUI() {
                // Recorder button
                document.getElementById('scene-recorder-button').addEventListener('click', () => {
                    document.getElementById('scene-recorder-modal').classList.add('show');
                    this.renderSceneList();
                });

                // Close button
                document.getElementById('scene-recorder-close').addEventListener('click', () => {
                    document.getElementById('scene-recorder-modal').classList.remove('show');
                });

                // Start/Stop recording
                document.getElementById('start-recording-btn').addEventListener('click', () => {
                    this.startRecording();
                });

                document.getElementById('stop-recording-btn').addEventListener('click', () => {
                    this.stopRecording();
                });

                // Export scene
                document.getElementById('export-scene-btn').addEventListener('click', () => {
                    this.exportScene();
                });

                // Speed controls
                document.querySelectorAll('.speed-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.speed-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.playbackSpeed = parseFloat(btn.dataset.speed);
                    });
                });
            }

            startRecording() {
                this.isRecording = true;
                this.recordedFrames = [];
                this.startTime = Date.now();
                
                document.getElementById('scene-recorder-button').classList.add('recording');
                document.getElementById('start-recording-btn').style.display = 'none';
                document.getElementById('stop-recording-btn').style.display = 'inline-block';
                document.getElementById('recording-status').classList.add('active');
                
                // Record frame every 100ms
                this.recordingInterval = setInterval(() => {
                    this.recordFrame();
                }, 100);
                
                // Update timer
                this.updateTimer();
            }

            stopRecording() {
                this.isRecording = false;
                clearInterval(this.recordingInterval);
                
                document.getElementById('scene-recorder-button').classList.remove('recording');
                document.getElementById('start-recording-btn').style.display = 'inline-block';
                document.getElementById('stop-recording-btn').style.display = 'none';
                document.getElementById('recording-status').classList.remove('active');
                
                // Save the scene
                const scene = {
                    id: Date.now(),
                    name: `Scene ${new Date().toLocaleString()}`,
                    duration: Date.now() - this.startTime,
                    frames: this.recordedFrames,
                    createdAt: new Date().toISOString()
                };
                
                this.savedScenes.push(scene);
                this.saveScenes();
                this.renderSceneList();
                
                window.gestureController.showGestureFeedback('Scene recorded!');
            }

            recordFrame() {
                if (!window.worldNavigator) return;
                
                const frame = {
                    timestamp: Date.now() - this.startTime,
                    camera: {
                        position: window.worldNavigator.camera.position.toArray(),
                        rotation: window.worldNavigator.camera.rotation.toArray()
                    },
                    player: {
                        position: window.worldNavigator.player.position.toArray(),
                        rotation: window.worldNavigator.player.rotation
                    }
                };
                
                this.recordedFrames.push(frame);
                this.updateTimer();
            }

            updateTimer() {
                const elapsed = this.isRecording ? Date.now() - this.startTime : 0;
                const minutes = Math.floor(elapsed / 60000);
                const seconds = Math.floor((elapsed % 60000) / 1000);
                document.getElementById('recording-timer').textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                
                if (this.isRecording) {
                    document.getElementById('recording-info').textContent = 
                        `Recording... ${this.recordedFrames.length} frames`;
                    setTimeout(() => this.updateTimer(), 100);
                }
            }

            playScene(scene) {
                if (!window.worldNavigator || !scene.frames || scene.frames.length === 0) return;
                
                // Show replay overlay
                document.getElementById('replay-overlay').classList.add('active');
                document.getElementById('scene-timeline').style.display = 'block';
                
                this.playbackIndex = 0;
                const frameDelay = 100 / this.playbackSpeed;
                
                this.playbackInterval = setInterval(() => {
                    if (this.playbackIndex >= scene.frames.length) {
                        this.stopPlayback();
                        return;
                    }
                    
                    const frame = scene.frames[this.playbackIndex];
                    
                    // Apply frame data
                    window.worldNavigator.camera.position.fromArray(frame.camera.position);
                    window.worldNavigator.camera.rotation.fromArray(frame.camera.rotation);
                    window.worldNavigator.player.position.fromArray(frame.player.position);
                    window.worldNavigator.player.rotation = frame.player.rotation;
                    
                    // Update timeline
                    const progress = (this.playbackIndex / scene.frames.length) * 100;
                    document.getElementById('timeline-bar').style.width = progress + '%';
                    
                    const currentTime = Math.floor(frame.timestamp / 1000);
                    const totalTime = Math.floor(scene.duration / 1000);
                    document.getElementById('current-time').textContent = 
                        `${Math.floor(currentTime / 60)}:${(currentTime % 60).toString().padStart(2, '0')}`;
                    document.getElementById('total-time').textContent = 
                        `${Math.floor(totalTime / 60)}:${(totalTime % 60).toString().padStart(2, '0')}`;
                    
                    this.playbackIndex++;
                }, frameDelay);
            }

            stopPlayback() {
                clearInterval(this.playbackInterval);
                document.getElementById('replay-overlay').classList.remove('active');
                document.getElementById('scene-timeline').style.display = 'none';
                document.getElementById('timeline-bar').style.width = '0%';
            }

            exportScene() {
                if (this.savedScenes.length === 0) return;
                
                const dataStr = JSON.stringify(this.savedScenes, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                
                const link = document.createElement('a');
                link.href = url;
                link.download = `nexus-scenes-${Date.now()}.json`;
                link.click();
                
                URL.revokeObjectURL(url);
                window.gestureController.showGestureFeedback('Scenes exported!');
            }

            importScene(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const scenes = JSON.parse(e.target.result);
                        this.savedScenes = this.savedScenes.concat(scenes);
                        this.saveScenes();
                        this.renderSceneList();
                        window.gestureController.showGestureFeedback('Scenes imported!');
                    } catch (error) {
                        console.error('Error importing scenes:', error);
                        window.gestureController.showGestureFeedback('Invalid scene file');
                    }
                };
                reader.readAsText(file);
            }

            renderSceneList() {
                const sceneList = document.getElementById('scene-list');
                sceneList.innerHTML = '<h4 style="color: #ff6b6b; margin-bottom: 10px;">Recorded Scenes:</h4>';
                
                this.savedScenes.forEach(scene => {
                    const sceneEl = document.createElement('div');
                    sceneEl.className = 'scene-item gesture-interactive';
                    sceneEl.innerHTML = `
                        <div class="scene-item-info">
                            <div class="scene-item-name">${scene.name}</div>
                            <div class="scene-item-details">
                                Duration: ${Math.floor(scene.duration / 1000)}s | 
                                Frames: ${scene.frames.length}
                            </div>
                        </div>
                        <div class="scene-item-actions">
                            <button class="scene-action-btn play gesture-interactive" data-id="${scene.id}">▶️</button>
                            <button class="scene-action-btn delete gesture-interactive" data-id="${scene.id}">🗑️</button>
                        </div>
                    `;
                    sceneList.appendChild(sceneEl);
                });
                
                // Add event listeners
                document.querySelectorAll('.scene-action-btn.play').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const id = parseInt(e.target.dataset.id);
                        const scene = this.savedScenes.find(s => s.id === id);
                        if (scene) this.playScene(scene);
                    });
                });
                
                document.querySelectorAll('.scene-action-btn.delete').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const id = parseInt(e.target.dataset.id);
                        this.savedScenes = this.savedScenes.filter(s => s.id !== id);
                        this.saveScenes();
                        this.renderSceneList();
                    });
                });
            }

            loadScenes() {
                const saved = localStorage.getItem('nexus-scenes');
                return saved ? JSON.parse(saved) : [];
            }

            saveScenes() {
                localStorage.setItem('nexus-scenes', JSON.stringify(this.savedScenes));
            }
        }

        // Portal Manager
        class PortalManager {
            constructor() {
                this.setupUI();
            }

            setupUI() {
                document.getElementById('portal-manager-btn').addEventListener('click', () => {
                    document.getElementById('portal-manager-modal').classList.add('show');
                    this.renderPortalList();
                });

                document.getElementById('portal-close').addEventListener('click', () => {
                    document.getElementById('portal-manager-modal').classList.remove('show');
                });
            }

            renderPortalList() {
                const portalList = document.getElementById('portal-list');
                portalList.innerHTML = '<h4 style="color: #06ffa5; margin-bottom: 10px;">Active Portals:</h4>';
                
                if (!window.worldNavigator || !window.worldNavigator.portals) {
                    portalList.innerHTML += '<p style="color: rgba(255, 255, 255, 0.5);">No portals available</p>';
                    return;
                }
                
                window.worldNavigator.portals.forEach((portal, index) => {
                    const portalEl = document.createElement('div');
                    portalEl.className = 'portal-item gesture-interactive';
                    portalEl.innerHTML = `
                        <div class="portal-item-info">
                            <div class="portal-item-name">${portal.userData.name || 'Unknown Portal'}</div>
                            <div class="portal-item-location">
                                Position: ${Math.round(portal.position.x)}, ${Math.round(portal.position.z)}
                            </div>
                        </div>
                        <div class="portal-item-actions">
                            <button class="portal-action-btn enter gesture-interactive" data-index="${index}">Enter</button>
                        </div>
                    `;
                    portalList.appendChild(portalEl);
                });
                
                // Add event listeners
                document.querySelectorAll('.portal-action-btn.enter').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const index = parseInt(e.target.dataset.index);
                        const portal = window.worldNavigator.portals[index];
                        if (portal && portal.userData) {
                            window.worldNavigator.enterPortal(portal.userData);
                        }
                    });
                });
            }

            exportPortals() {
                if (!window.worldNavigator || !window.worldNavigator.portals) return;
                
                const portalData = window.worldNavigator.portals.map(portal => ({
                    name: portal.userData.name,
                    type: portal.userData.type,
                    url: portal.userData.url,
                    position: portal.position.toArray()
                }));
                
                const dataStr = JSON.stringify(portalData, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                
                const link = document.createElement('a');
                link.href = url;
                link.download = `nexus-portals-${Date.now()}.json`;
                link.click();
                
                URL.revokeObjectURL(url);
                window.gestureController.showGestureFeedback('Portals exported!');
            }

            importPortals(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const portals = JSON.parse(e.target.result);
                        // Implementation would add these portals to the world
                        console.log('Imported portals:', portals);
                        window.gestureController.showGestureFeedback('Portals imported!');
                    } catch (error) {
                        console.error('Error importing portals:', error);
                        window.gestureController.showGestureFeedback('Invalid portal file');
                    }
                };
                reader.readAsText(file);
            }
        }

        // Initialize the world
        window.worldNavigator = new WorldNavigator();

        // Update controls hint for gestures
        setTimeout(() => {
            const hint = document.getElementById('controls-hint');
            if (!window.gestureController.fallbackToMouse) {
                hint.style.opacity = '0';
                setTimeout(() => {
                    hint.style.display = 'none';
                }, 1000);
            }
        }, 5000);

        // Show origin world if arriving from another world
        if (inheritedAttributes.sourceWorldName) {
            const originEl = document.getElementById('world-origin');
            const originName = document.getElementById('origin-world-name');
            originName.textContent = inheritedAttributes.sourceWorldName;
            originEl.classList.add('visible');
            
            setTimeout(() => {
                originEl.classList.remove('visible');
            }, 5000);
        }
    </script>
</body>
</html>