<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Solar System Builder</title>
    <meta name="description" content="Procedural 3D solar system generator with interactive zoom into planets and moons.">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            overflow: hidden;
            background-color: #000;
            color: white;
            font-family: 'Segoe UI', system-ui, sans-serif;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 10px;
            pointer-events: none;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            max-width: 300px;
        }

        #info h2 {
            background: linear-gradient(90deg, #ff6b6b, #4ecdc4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }

        #elapsed-time {
            margin-top: 10px;
            padding-top: 8px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 12px;
            color: #4ecdc4;
            font-family: 'Courier New', monospace;
        }

        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            padding: 15px 25px;
            border-radius: 30px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            display: flex;
            gap: 10px;
        }

        button {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 10px 20px;
            cursor: pointer;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button.secondary {
            background: rgba(255,255,255,0.1);
        }

        button.secondary:hover {
            background: rgba(255,255,255,0.2);
        }

        /* Active toggle state indicators */
        button.secondary.active {
            background: rgba(78, 205, 196, 0.3);
            border: 1px solid rgba(78, 205, 196, 0.6);
            box-shadow: 0 0 8px rgba(78, 205, 196, 0.3);
        }

        button.secondary.active::after {
            content: ' ✓';
            font-size: 10px;
            margin-left: 4px;
        }

        /* Data management buttons */
        .data-controls {
            position: absolute;
            bottom: 80px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .data-controls button {
            font-size: 12px;
            padding: 8px 15px;
            background: rgba(78, 205, 196, 0.3);
            border: 1px solid rgba(78, 205, 196, 0.5);
        }

        .data-controls button:hover {
            background: rgba(78, 205, 196, 0.5);
        }

        /* Keyboard help panel */
        #keyboard-help {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 10px;
            font-size: 12px;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            border: 1px solid rgba(255,255,255,0.1);
        }

        #keyboard-help.visible {
            opacity: 1;
        }

        #keyboard-help h4 {
            margin-bottom: 10px;
            color: #4ecdc4;
        }

        #keyboard-help .key-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            gap: 20px;
        }

        #keyboard-help .key {
            background: rgba(255,255,255,0.1);
            padding: 2px 8px;
            border-radius: 4px;
            font-family: monospace;
        }

        /* Focus indicator for accessibility */
        button:focus, .moon-item:focus {
            outline: 2px solid #4ecdc4;
            outline-offset: 2px;
        }

        /* Skip link for accessibility */
        .skip-link {
            position: absolute;
            top: -40px;
            left: 0;
            background: #4ecdc4;
            color: black;
            padding: 8px 16px;
            z-index: 10000;
            transition: top 0.3s;
        }

        .skip-link:focus {
            top: 0;
        }

        /* Planet selection indicator */
        .planet-selector {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .planet-selector.visible {
            opacity: 1;
        }

        .planet-selector-ring {
            width: 60px;
            height: 60px;
            border: 2px solid #4ecdc4;
            border-radius: 50%;
            animation: selectorPulse 1.5s ease-in-out infinite;
        }

        @keyframes selectorPulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.5; }
        }

        /* Pause indicator */
        #pause-indicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            color: rgba(255,255,255,0.8);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            text-shadow: 0 0 20px rgba(0,0,0,0.8);
        }

        #pause-indicator.visible {
            opacity: 1;
        }

        /* Pause button styling */
        #pause-btn {
            background: rgba(255, 107, 107, 0.6);
            min-width: 50px;
        }

        #pause-btn.paused {
            background: rgba(78, 205, 196, 0.6);
        }

        /* Mobile responsive styles */
        @media (max-width: 768px) {
            #info {
                top: 5px;
                left: 5px;
                right: 5px;
                max-width: none;
                padding: 10px;
                font-size: 12px;
            }

            #info h2 {
                font-size: 1.1em;
            }

            #controls {
                bottom: 10px;
                left: 5px;
                right: 5px;
                transform: none;
                padding: 10px;
                border-radius: 15px;
                flex-wrap: wrap;
                justify-content: center;
                gap: 6px;
            }

            button {
                padding: 12px 16px;
                font-size: 12px;
                min-height: 44px;
                min-width: 44px;
            }

            .data-controls {
                bottom: auto;
                top: 80px;
                left: 5px;
                flex-direction: row;
                flex-wrap: wrap;
                gap: 5px;
            }

            .data-controls button {
                padding: 10px 12px;
                min-height: 44px;
            }

            #detail-panel {
                right: 5px;
                left: 5px;
                width: auto;
                max-height: 50vh;
                overflow-y: auto;
                top: auto;
                bottom: 100px;
                transform: none;
                padding: 15px;
            }

            #detail-panel h3 {
                font-size: 1.2em;
            }

            #keyboard-help {
                display: none;
            }

            #click-hint {
                bottom: 130px;
                font-size: 0.8em;
                padding: 6px 15px;
            }

            #back-btn {
                top: 10px;
                right: 10px;
                padding: 12px 16px;
            }

            #view-mode {
                top: 10px;
                font-size: 0.8em;
                padding: 6px 15px;
            }

            #transmission-indicator {
                font-size: 0.6em;
            }

            #timestamp {
                bottom: 130px;
                font-size: 0.55em;
            }

            .moon-item {
                padding: 12px 15px;
                min-height: 44px;
            }
        }

        @media (max-width: 480px) {
            #controls button span.btn-text {
                display: none;
            }

            #controls {
                gap: 4px;
            }

            button {
                padding: 10px 12px;
            }
        }

        /* Touch feedback */
        @media (hover: none) and (pointer: coarse) {
            button:active {
                transform: scale(0.95);
                opacity: 0.8;
            }
        }

        /* Canvas touch optimization */
        canvas {
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        /* Floating labels for celestial bodies */
        .celestial-label {
            position: absolute;
            pointer-events: none;
            font-size: 11px;
            font-weight: 500;
            color: white;
            background: rgba(0,0,0,0.6);
            padding: 3px 8px;
            border-radius: 4px;
            white-space: nowrap;
            transform: translate(-50%, -100%);
            margin-top: -10px;
            transition: opacity 0.3s ease;
            text-shadow: 0 1px 2px rgba(0,0,0,0.8);
            border: 1px solid rgba(255,255,255,0.1);
        }

        .celestial-label.planet {
            border-left: 3px solid #4ecdc4;
        }

        .celestial-label.moon {
            font-size: 10px;
            border-left: 3px solid #ff6b6b;
            opacity: 0.8;
        }

        .celestial-label.star {
            border-left: 3px solid #ffcc33;
            font-weight: 600;
        }

        /* ARIA live region */
        #aria-announcer {
            position: absolute;
            left: -10000px;
            width: 1px;
            height: 1px;
            overflow: hidden;
        }

        /* Reduced motion support */
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* Minimap overlay */
        #minimap {
            position: absolute;
            bottom: 100px;
            left: 20px;
            width: 180px;
            height: 180px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            overflow: hidden;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        #minimap.visible {
            opacity: 1;
        }

        #minimap canvas {
            width: 100%;
            height: 100%;
        }

        #minimap-label {
            position: absolute;
            top: 5px;
            left: 8px;
            font-size: 10px;
            color: rgba(255, 255, 255, 0.5);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        @media (max-width: 768px) {
            #minimap {
                display: none;
            }
        }

        /* Habitable zone legend tooltip */
        #hz-legend {
            position: absolute;
            bottom: 100px;
            right: 20px;
            background: rgba(0,0,0,0.85);
            padding: 12px 16px;
            border-radius: 10px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 12px;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            border: 1px solid rgba(78, 205, 196, 0.3);
            max-width: 280px;
        }

        #hz-legend.visible {
            opacity: 1;
        }

        .hz-legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: rgba(78, 205, 196, 0.3);
            border: 2px solid rgba(78, 205, 196, 0.7);
            flex-shrink: 0;
        }

        .hz-legend-text {
            color: rgba(255, 255, 255, 0.9);
            line-height: 1.4;
        }

        .hz-legend-text strong {
            color: #4ecdc4;
            display: block;
            margin-bottom: 2px;
        }

        @media (max-width: 768px) {
            #hz-legend {
                bottom: 80px;
                right: 10px;
                max-width: 200px;
                font-size: 11px;
            }
        }

        /* Habitable zone indicator in detail panel */
        .habitable-badge {
            display: inline-block;
            background: rgba(78, 205, 196, 0.3);
            color: #4ecdc4;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            margin-top: 10px;
            border: 1px solid rgba(78, 205, 196, 0.5);
        }

        /* Object Detail Panel */
        #detail-panel {
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(0,0,0,0.85);
            padding: 25px;
            border-radius: 15px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255,255,255,0.15);
            width: 320px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.4s ease, transform 0.4s ease;
        }

        #detail-panel.visible {
            opacity: 1;
            pointer-events: all;
        }

        #detail-panel h3 {
            font-size: 1.5em;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        #detail-panel .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }

        #detail-panel .stat-label {
            color: rgba(255,255,255,0.6);
        }

        #detail-panel .stat-value {
            color: #4ecdc4;
            font-weight: 500;
        }

        #detail-panel .description {
            margin-top: 15px;
            color: rgba(255,255,255,0.7);
            line-height: 1.6;
            font-size: 0.9em;
        }

        #detail-panel .moons-section {
            margin-top: 20px;
        }

        #detail-panel .moons-section h4 {
            color: #ff6b6b;
            margin-bottom: 10px;
        }

        #detail-panel .moon-item {
            background: rgba(255,255,255,0.05);
            padding: 10px 15px;
            border-radius: 8px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #detail-panel .moon-item:hover {
            background: rgba(255,255,255,0.1);
            transform: translateX(5px);
        }

        #detail-panel .moon-item .zoom-hint {
            font-size: 0.8em;
            color: rgba(255,255,255,0.4);
        }

        #back-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            background: rgba(255,100,100,0.8);
        }

        #back-btn.visible {
            opacity: 1;
            pointer-events: all;
        }

        /* Clickable indicator */
        #click-hint {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.6);
            padding: 8px 20px;
            border-radius: 20px;
            font-size: 0.9em;
            color: rgba(255,255,255,0.7);
            pointer-events: none;
        }

        /* Loading indicator */
        .transitioning::after {
            content: '';
            position: fixed;
            top: 50%;
            left: 50%;
            width: 40px;
            height: 40px;
            margin: -20px 0 0 -20px;
            border: 3px solid rgba(255,255,255,0.1);
            border-top-color: #4ecdc4;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Star glow effect */
        .star-glow {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 200px;
            height: 200px;
            margin: -100px 0 0 -100px;
            background: radial-gradient(circle, rgba(255,200,100,0.3) 0%, transparent 70%);
            pointer-events: none;
            opacity: 0.5;
        }

        /* View mode indicator */
        #view-mode {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.8), rgba(118, 75, 162, 0.8));
            padding: 8px 25px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: 500;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        #view-mode.visible {
            opacity: 1;
        }

        /* ========================================
           BROADCAST TRANSMISSION EFFECTS
           ======================================== */

        /* Scanlines overlay - very subtle */
        .broadcast-overlay {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 9999;
        }

        .broadcast-overlay::before {
            content: '';
            position: absolute;
            inset: 0;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(0, 0, 0, 0.03) 2px,
                rgba(0, 0, 0, 0.03) 4px
            );
            animation: scanlineMove 8s linear infinite;
        }

        /* CRT vignette */
        .broadcast-overlay::after {
            content: '';
            position: absolute;
            inset: 0;
            background: radial-gradient(
                ellipse at center,
                transparent 60%,
                rgba(0, 0, 0, 0.3) 100%
            );
        }

        @keyframes scanlineMove {
            0% { transform: translateY(0); }
            100% { transform: translateY(4px); }
        }

        /* Signal interference flicker - rare */
        @keyframes signalFlicker {
            0%, 97%, 100% { opacity: 1; filter: none; }
            97.5% { opacity: 0.8; filter: brightness(1.2) contrast(1.1); }
            98% { opacity: 1; filter: hue-rotate(5deg); }
            98.5% { opacity: 0.95; filter: none; }
        }

        body.signal-active {
            animation: signalFlicker 15s infinite;
        }

        /* Transmission indicator */
        #transmission-indicator {
            position: fixed;
            top: 15px;
            right: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.7em;
            color: rgba(255, 255, 255, 0.4);
            font-family: 'Courier New', monospace;
            text-transform: uppercase;
            letter-spacing: 1px;
            z-index: 100;
        }

        #transmission-indicator .signal-dot {
            width: 6px;
            height: 6px;
            background: #4ecdc4;
            border-radius: 50%;
            animation: signalPulse 2s ease-in-out infinite;
            box-shadow: 0 0 6px #4ecdc4;
        }

        @keyframes signalPulse {
            0%, 100% { opacity: 0.4; }
            50% { opacity: 1; }
        }

        #transmission-indicator .signal-strength {
            display: flex;
            gap: 2px;
            align-items: flex-end;
        }

        #transmission-indicator .signal-bar {
            width: 3px;
            background: rgba(78, 205, 196, 0.6);
            border-radius: 1px;
        }

        /* Chromatic aberration on UI panels - very subtle */
        #info, #detail-panel, #controls {
            text-shadow:
                0.3px 0 0 rgba(255, 0, 0, 0.1),
                -0.3px 0 0 rgba(0, 255, 255, 0.1);
        }

        /* Glitch text effect class */
        .glitch-text {
            position: relative;
        }

        .glitch-text::before,
        .glitch-text::after {
            content: attr(data-text);
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
        }

        .glitch-text.glitching::before {
            animation: glitchTop 0.2s linear;
            color: #0ff;
            clip-path: polygon(0 0, 100% 0, 100% 45%, 0 45%);
        }

        .glitch-text.glitching::after {
            animation: glitchBottom 0.3s linear;
            color: #f0f;
            clip-path: polygon(0 55%, 100% 55%, 100% 100%, 0 100%);
        }

        @keyframes glitchTop {
            0% { opacity: 0; transform: translateX(0); }
            20% { opacity: 0.8; transform: translateX(-2px); }
            40% { opacity: 0; transform: translateX(2px); }
            60% { opacity: 0.6; transform: translateX(-1px); }
            80% { opacity: 0; transform: translateX(1px); }
            100% { opacity: 0; transform: translateX(0); }
        }

        @keyframes glitchBottom {
            0% { opacity: 0; transform: translateX(0); }
            25% { opacity: 0.7; transform: translateX(2px); }
            50% { opacity: 0; transform: translateX(-2px); }
            75% { opacity: 0.5; transform: translateX(1px); }
            100% { opacity: 0; transform: translateX(0); }
        }

        /* Noise grain overlay - extremely subtle */
        .noise-overlay {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 9998;
            opacity: 0.015;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%' height='100%' filter='url(%23noise)'/%3E%3C/svg%3E");
        }

        /* Subtle horizontal interference lines - very rare */
        .interference-line {
            position: fixed;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg,
                transparent,
                rgba(255,255,255,0.1) 20%,
                rgba(255,255,255,0.15) 50%,
                rgba(255,255,255,0.1) 80%,
                transparent
            );
            pointer-events: none;
            z-index: 9997;
            opacity: 0;
            transform: scaleX(0);
        }

        .interference-line.active {
            animation: interferencePass 0.15s ease-out forwards;
        }

        @keyframes interferencePass {
            0% { transform: scaleX(0); opacity: 1; }
            100% { transform: scaleX(1); opacity: 0; }
        }

        /* Timestamp display */
        #timestamp {
            position: fixed;
            bottom: 80px;
            right: 15px;
            font-family: 'Courier New', monospace;
            font-size: 0.65em;
            color: rgba(255, 255, 255, 0.25);
            letter-spacing: 1px;
            z-index: 100;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body class="signal-active">
    <!-- Skip link for accessibility -->
    <a href="#controls" class="skip-link" tabindex="0">Skip to controls</a>

    <!-- ARIA live region for screen reader announcements -->
    <div id="aria-announcer" role="status" aria-live="polite" aria-atomic="true"></div>

    <!-- Container for floating celestial body labels -->
    <div id="labels-container" aria-hidden="true"></div>

    <!-- Minimap overlay -->
    <div id="minimap" aria-hidden="true">
        <span id="minimap-label">System Map</span>
        <canvas id="minimap-canvas" width="180" height="180"></canvas>
    </div>

    <!-- Habitable zone legend -->
    <div id="hz-legend" aria-hidden="true">
        <div class="hz-legend-color"></div>
        <div class="hz-legend-text">
            <strong>Habitable Zone</strong>
            Region where liquid water could exist on planetary surfaces
        </div>
    </div>

    <!-- Broadcast transmission overlays -->
    <div class="broadcast-overlay"></div>
    <div class="noise-overlay"></div>
    <div class="interference-line" id="interference-line"></div>

    <!-- Planet selector for keyboard navigation -->
    <div class="planet-selector" id="planet-selector" aria-hidden="true">
        <div class="planet-selector-ring"></div>
    </div>

    <!-- Transmission status indicator -->
    <div id="transmission-indicator">
        <div class="signal-dot"></div>
        <span>LIVE FEED</span>
        <div class="signal-strength">
            <div class="signal-bar" style="height: 4px;"></div>
            <div class="signal-bar" style="height: 7px;"></div>
            <div class="signal-bar" style="height: 10px;"></div>
            <div class="signal-bar" style="height: 6px; opacity: 0.4;"></div>
        </div>
    </div>

    <div id="timestamp">TRANSMISSION: <span id="tx-time">00:00:00</span></div>

    <div id="info">
        <h2>Procedural Solar System</h2>
        <p>Click on any planet or moon to zoom in for an orbital view.</p>
        <div id="system-stats"></div>
        <div id="elapsed-time" aria-live="off">Elapsed: 0 years</div>
    </div>

    <div id="view-mode">Orbiting: <span id="view-target"></span></div>

    <button id="back-btn">Back to System View</button>

    <div id="detail-panel">
        <h3 id="detail-name">Planet Name</h3>
        <div id="detail-stats"></div>
        <div class="description" id="detail-description"></div>
        <div class="moons-section" id="moons-section" style="display: none;">
            <h4>Moons</h4>
            <div id="moons-list"></div>
        </div>
    </div>

    <!-- Pause indicator -->
    <div id="pause-indicator" aria-live="polite" aria-atomic="true">⏸ PAUSED</div>

    <div id="controls" role="toolbar" aria-label="Solar system controls">
        <button id="generate-btn" aria-label="Generate new solar system">Generate New System</button>
        <button id="pause-btn" class="secondary" aria-label="Pause simulation" aria-pressed="false">⏵</button>
        <button id="toggle-orbits" class="secondary active" aria-label="Toggle orbit lines" aria-pressed="true">Toggle Orbits</button>
        <button id="toggle-labels" class="secondary active" aria-label="Toggle labels" aria-pressed="true">Toggle Labels</button>
        <button id="speed-btn" class="secondary" aria-label="Change simulation speed">Speed: 1x</button>
    </div>

    <div id="click-hint">Click on any celestial body to explore</div>

    <!-- Data management controls -->
    <div class="data-controls">
        <button id="save-btn" title="Save current system to browser storage" aria-label="Save solar system">Save System</button>
        <button id="export-btn" title="Export system as JSON file" aria-label="Export solar system as JSON">Export JSON</button>
        <button id="import-btn" title="Import system from JSON file" aria-label="Import solar system from JSON">Import JSON</button>
        <input type="file" id="import-file" accept=".json" style="display: none;" aria-hidden="true">
    </div>

    <!-- Keyboard help panel -->
    <div id="keyboard-help" role="complementary" aria-label="Keyboard shortcuts">
        <h4>Keyboard Shortcuts</h4>
        <div class="key-row"><span class="key">?</span><span>Toggle this help</span></div>
        <div class="key-row"><span class="key">Space/P</span><span>Pause/play</span></div>
        <div class="key-row"><span class="key">G</span><span>Generate new system</span></div>
        <div class="key-row"><span class="key">O</span><span>Toggle orbit lines</span></div>
        <div class="key-row"><span class="key">L</span><span>Toggle labels</span></div>
        <div class="key-row"><span class="key">+/-</span><span>Change speed</span></div>
        <div class="key-row"><span class="key">1-9</span><span>Select planet</span></div>
        <div class="key-row"><span class="key">0</span><span>Select star</span></div>
        <div class="key-row"><span class="key">Arrows</span><span>Navigate planets</span></div>
        <div class="key-row"><span class="key">Enter</span><span>Zoom to selected</span></div>
        <div class="key-row"><span class="key">Esc</span><span>Return to system view</span></div>
        <div class="key-row"><span class="key">S</span><span>Save system</span></div>
        <div class="key-row"><span class="key">C</span><span>Screenshot</span></div>
        <div class="key-row"><span class="key">M</span><span>Toggle audio</span></div>
        <div class="key-row"><span class="key">T</span><span>Toggle trails</span></div>
        <div class="key-row"><span class="key">F/R/N</span><span>Faster/Slower/Normal</span></div>
        <div class="key-row"><span class="key">V</span><span>Toggle minimap</span></div>
        <div class="key-row"><span class="key">H</span><span>Toggle habitable zone</span></div>
        <div class="key-row"><span class="key">A</span><span>Toggle asteroids</span></div>
    </div>

    <script>
        // ========================================
        // WEBGL ERROR HANDLING
        // ========================================
        function showFallbackMessage(message) {
            document.body.innerHTML = `
                <div style="display: flex; align-items: center; justify-content: center; height: 100vh;
                            background: #000; color: #fff; font-family: sans-serif; text-align: center; padding: 20px;">
                    <div>
                        <h1 style="color: #ff6b6b;">Unable to Start Solar System</h1>
                        <p style="max-width: 500px; line-height: 1.6;">${message}</p>
                        <p style="margin-top: 20px;">
                            <a href="https://get.webgl.org/" style="color: #4ecdc4;">Learn more about WebGL</a>
                        </p>
                    </div>
                </div>
            `;
        }

        // Check WebGL support
        let renderer;
        try {
            const testCanvas = document.createElement('canvas');
            const gl = testCanvas.getContext('webgl') || testCanvas.getContext('experimental-webgl');
            if (!gl) {
                throw new Error('WebGL not supported');
            }
        } catch (e) {
            showFallbackMessage('WebGL is required but not available on your device. Please try a modern browser or update your graphics drivers.');
            throw e;
        }

        // ========================================
        // SCENE SETUP
        // ========================================
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 10000);
        try {
            renderer = new THREE.WebGLRenderer({
                antialias: true,
                preserveDrawingBuffer: true  // Required for screenshots
            });
        } catch (e) {
            showFallbackMessage('Failed to initialize WebGL renderer. Your browser may not support required features.');
            throw e;
        }
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // Orbit Controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 5;
        controls.maxDistance = 2000;
        controls.autoRotate = false;
        controls.autoRotateSpeed = 0.5;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x222222);
        scene.add(ambientLight);

        const pointLight = new THREE.PointLight(0xffffff, 2, 3000);
        scene.add(pointLight);

        // Raycaster for click detection
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // ========================================
        // STATE MANAGEMENT
        // ========================================
        let star = null;
        let planets = [];
        let allClickableObjects = [];
        let showOrbits = true;
        let showLabels = true;
        let timeSpeed = 1;
        let currentView = 'system'; // 'system', 'planet', 'moon'
        let focusedObject = null;
        let targetCameraPosition = null;
        let targetLookAt = null;
        let isTransitioning = false;
        let starData = null;
        let cameraOffset = null; // Store offset from focused object
        let isPaused = false; // Pause state
        let transitionProgress = 0; // For camera easing
        let isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        let showTrails = false; // Orbital trails
        let audioEnabled = false; // Audio system state
        let showMinimap = false; // Minimap toggle
        let showHabitableZone = false; // Habitable zone indicator
        let showAsteroids = true; // Asteroid belt toggle
        let habitableZoneMesh = null; // Habitable zone torus
        let asteroidBelt = null; // Instanced mesh for asteroids
        const SPEED_PRESETS = [0.1, 0.25, 0.5, 1, 2, 5, 10]; // Extended speed presets

        // Elapsed simulation time (in simulated years)
        let elapsedSimulatedYears = 0;
        const YEARS_PER_SECOND = 1000000; // 1 million years per real second at 1x speed

        // Battery saver / idle detection
        let lastInteractionTime = Date.now();
        const IDLE_THRESHOLD = 30000; // 30 seconds before idle mode
        let isIdle = false;
        let frameSkipCounter = 0;

        function resetIdleTimer() {
            lastInteractionTime = Date.now();
            if (isIdle) {
                isIdle = false;
                // Resume full speed rendering silently
            }
        }

        // ========================================
        // WEB AUDIO SYSTEM
        // ========================================
        let audioContext = null;
        let ambientOscillator = null;
        let ambientGain = null;

        function initAudio() {
            if (audioContext) return;
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();

                // Create ambient space drone
                ambientOscillator = audioContext.createOscillator();
                ambientGain = audioContext.createGain();

                ambientOscillator.type = 'sine';
                ambientOscillator.frequency.setValueAtTime(55, audioContext.currentTime); // Low hum
                ambientGain.gain.setValueAtTime(0, audioContext.currentTime);

                // Add subtle modulation
                const lfo = audioContext.createOscillator();
                const lfoGain = audioContext.createGain();
                lfo.frequency.setValueAtTime(0.1, audioContext.currentTime);
                lfoGain.gain.setValueAtTime(5, audioContext.currentTime);
                lfo.connect(lfoGain);
                lfoGain.connect(ambientOscillator.frequency);
                lfo.start();

                ambientOscillator.connect(ambientGain);
                ambientGain.connect(audioContext.destination);
                ambientOscillator.start();

            } catch (e) {
                console.log('Audio not supported');
            }
        }

        function toggleAudio() {
            if (!audioContext) {
                initAudio();
            }
            audioEnabled = !audioEnabled;
            if (audioEnabled && ambientGain) {
                ambientGain.gain.linearRampToValueAtTime(0.03, audioContext.currentTime + 0.5);
            } else if (ambientGain) {
                ambientGain.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.3);
            }
            showNotification(audioEnabled ? 'Audio enabled' : 'Audio muted');
            announce(audioEnabled ? 'Audio enabled' : 'Audio muted');
        }

        function playSelectionSound() {
            if (!audioEnabled || !audioContext) return;
            try {
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(440, audioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(880, audioContext.currentTime + 0.1);
                gain.gain.setValueAtTime(0.1, audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.3);
                osc.connect(gain);
                gain.connect(audioContext.destination);
                osc.start();
                osc.stop(audioContext.currentTime + 0.3);
            } catch (e) {}
        }

        function playZoomSound() {
            if (!audioEnabled || !audioContext) return;
            try {
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(200, audioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(600, audioContext.currentTime + 0.4);
                gain.gain.setValueAtTime(0.08, audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.5);
                osc.connect(gain);
                gain.connect(audioContext.destination);
                osc.start();
                osc.stop(audioContext.currentTime + 0.5);
            } catch (e) {}
        }

        // ========================================
        // MINIMAP SYSTEM
        // ========================================
        const minimapCanvas = document.getElementById('minimap-canvas');
        const minimapCtx = minimapCanvas ? minimapCanvas.getContext('2d') : null;
        const minimapEl = document.getElementById('minimap');

        function drawMinimap() {
            if (!minimapCtx || !showMinimap || !starData) return;

            const ctx = minimapCtx;
            const size = 180;
            const center = size / 2;

            // Clear
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, size, size);

            // Calculate scale to fit all planets
            let maxDist = 100;
            planets.forEach(p => {
                if (p.dist > maxDist) maxDist = p.dist;
            });
            const scale = (size / 2 - 15) / maxDist;

            // Draw habitable zone if visible
            if (showHabitableZone && starData) {
                const hzInner = starData.scale * 4 * scale;
                const hzOuter = starData.scale * 8 * scale;
                ctx.beginPath();
                ctx.arc(center, center, hzOuter, 0, Math.PI * 2);
                ctx.arc(center, center, hzInner, 0, Math.PI * 2, true);
                ctx.fillStyle = 'rgba(78, 205, 196, 0.15)';
                ctx.fill();
            }

            // Draw orbit lines
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
            ctx.lineWidth = 1;
            planets.forEach(p => {
                ctx.beginPath();
                ctx.arc(center, center, p.dist * scale, 0, Math.PI * 2);
                ctx.stroke();
            });

            // Draw star
            ctx.beginPath();
            ctx.arc(center, center, 4, 0, Math.PI * 2);
            ctx.fillStyle = '#ffcc33';
            ctx.fill();

            // Draw planets
            planets.forEach(p => {
                const x = center + Math.cos(p.angle) * p.dist * scale;
                const y = center + Math.sin(p.angle) * p.dist * scale;
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fillStyle = p.data.type === 'gas' ? '#8888ff' : '#88ff88';
                ctx.fill();
            });

            // Draw camera position indicator
            const camDist = Math.sqrt(camera.position.x * camera.position.x + camera.position.z * camera.position.z);
            const camAngle = Math.atan2(camera.position.z, camera.position.x);
            const camX = center + Math.cos(camAngle) * Math.min(camDist * scale, size / 2 - 5);
            const camY = center + Math.sin(camAngle) * Math.min(camDist * scale, size / 2 - 5);

            ctx.beginPath();
            ctx.arc(camX, camY, 4, 0, Math.PI * 2);
            ctx.fillStyle = '#ff6b6b';
            ctx.fill();
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        // ========================================
        // HABITABLE ZONE
        // ========================================
        function createHabitableZone() {
            if (habitableZoneMesh) {
                scene.remove(habitableZoneMesh);
                habitableZoneMesh.geometry.dispose();
                habitableZoneMesh.material.dispose();
            }

            if (!starData) return;

            // Calculate habitable zone based on star luminosity (simplified)
            const innerRadius = starData.scale * 4;
            const outerRadius = starData.scale * 8;
            const thickness = outerRadius - innerRadius;

            const geometry = new THREE.TorusGeometry(
                (innerRadius + outerRadius) / 2,
                thickness / 2,
                2,
                64
            );
            const material = new THREE.MeshBasicMaterial({
                color: 0x4ecdc4,
                transparent: true,
                opacity: 0.15,
                side: THREE.DoubleSide
            });

            habitableZoneMesh = new THREE.Mesh(geometry, material);
            habitableZoneMesh.rotation.x = Math.PI / 2;
            habitableZoneMesh.visible = showHabitableZone;
            scene.add(habitableZoneMesh);

            return { inner: innerRadius, outer: outerRadius };
        }

        function isInHabitableZone(planetDist) {
            if (!starData) return false;
            const inner = starData.scale * 4;
            const outer = starData.scale * 8;
            return planetDist >= inner && planetDist <= outer;
        }

        // ========================================
        // ASTEROID BELT
        // ========================================
        function createAsteroidBelt() {
            if (asteroidBelt) {
                scene.remove(asteroidBelt);
                asteroidBelt.geometry.dispose();
                asteroidBelt.material.dispose();
            }

            if (!starData || planets.length < 2) return;

            // Find a gap between planets for the asteroid belt (2:1 resonance position)
            let beltRadius = 0;
            for (let i = 0; i < planets.length - 1; i++) {
                const gap = planets[i + 1].dist - planets[i].dist;
                if (gap > 40) {
                    beltRadius = planets[i].dist + gap * 0.4; // 2:1 resonance position
                    break;
                }
            }

            if (beltRadius === 0) {
                // Use outer edge if no suitable gap
                beltRadius = planets[planets.length - 1].dist * 1.3;
            }

            const asteroidCount = 150;
            const geometry = new THREE.IcosahedronGeometry(0.3, 0);
            const material = new THREE.MeshStandardMaterial({
                color: 0x888888,
                roughness: 0.9,
                transparent: true,
                opacity: 0.6
            });

            asteroidBelt = new THREE.InstancedMesh(geometry, material, asteroidCount);

            const dummy = new THREE.Object3D();
            for (let i = 0; i < asteroidCount; i++) {
                const angle = (i / asteroidCount) * Math.PI * 2 + Math.random() * 0.3;
                const radiusVariation = beltRadius + (Math.random() - 0.5) * 15;
                const height = (Math.random() - 0.5) * 3;

                dummy.position.set(
                    Math.cos(angle) * radiusVariation,
                    height,
                    Math.sin(angle) * radiusVariation
                );
                dummy.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, 0);
                dummy.scale.setScalar(0.5 + Math.random() * 0.5);
                dummy.updateMatrix();
                asteroidBelt.setMatrixAt(i, dummy.matrix);
            }

            asteroidBelt.visible = showAsteroids;
            scene.add(asteroidBelt);
        }

        // XSS prevention for imported data
        function escapeHTML(str) {
            if (typeof str !== 'string') return str;
            const div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        }

        // Planet name generators
        const prefixes = ['Kepler', 'Proxima', 'Tau', 'Epsilon', 'Zeta', 'Omicron', 'Sigma', 'Delta', 'Gamma', 'Nova'];
        const suffixes = ['Prime', 'Major', 'Minor', 'Alpha', 'Beta', 'Centauri', 'Reticuli', 'Eridani', 'Cygni', 'Draconis'];
        const moonPrefixes = ['Io', 'Europa', 'Titan', 'Phobos', 'Deimos', 'Triton', 'Charon', 'Ganymede', 'Callisto', 'Enceladus'];

        function generateName() {
            return prefixes[Math.floor(Math.random() * prefixes.length)] + '-' +
                   Math.floor(Math.random() * 999) +
                   (Math.random() > 0.5 ? ' ' + suffixes[Math.floor(Math.random() * suffixes.length)] : '');
        }

        function generateMoonName() {
            return moonPrefixes[Math.floor(Math.random() * moonPrefixes.length)] + '-' +
                   String.fromCharCode(65 + Math.floor(Math.random() * 26));
        }

        // Planet type descriptions
        const planetDescriptions = {
            gas: [
                "A massive gas giant with swirling storms visible from orbit. Hydrogen and helium dominate its atmosphere.",
                "This jovian world features colorful bands of ammonia clouds racing around its equator at tremendous speeds.",
                "A frigid ice giant with a distinctive blue-green hue from methane in its upper atmosphere.",
                "Storm systems larger than terrestrial worlds rage across this gas giant's turbulent surface."
            ],
            terran: [
                "A rocky terrestrial world with potential for surface water and geological activity.",
                "This small rocky planet shows signs of ancient volcanic activity and impact craters.",
                "A dense iron-core world with a thin atmosphere of carbon dioxide and nitrogen.",
                "Surface scans reveal mountain ranges and vast plains of silicate rock."
            ]
        };

        const moonDescriptions = [
            "A small rocky satellite with a heavily cratered surface from billions of years of impacts.",
            "This moon shows signs of cryovolcanic activity, potentially harboring a subsurface ocean.",
            "Tidal forces from the parent planet keep this moon geologically active.",
            "A captured asteroid now locked in orbit around its host planet."
        ];

        // ========================================
        // TEXTURE GENERATION
        // ========================================
        function createPlanetTexture(type, colorHex) {
            const canvas = document.createElement('canvas');
            canvas.width = 1024;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            // Parse color
            const color = new THREE.Color(colorHex);
            const r = Math.floor(color.r * 255);
            const g = Math.floor(color.g * 255);
            const b = Math.floor(color.b * 255);

            // Base gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, 512);
            gradient.addColorStop(0, `rgba(${r},${g},${b},1)`);
            gradient.addColorStop(0.5, `rgba(${Math.floor(r*0.8)},${Math.floor(g*0.8)},${Math.floor(b*0.8)},1)`);
            gradient.addColorStop(1, `rgba(${r},${g},${b},1)`);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 1024, 512);

            // Add noise texture
            for (let i = 0; i < 5000; i++) {
                const x = Math.random() * 1024;
                const y = Math.random() * 512;
                const w = Math.random() * 30 + 5;
                const h = Math.random() * 15 + 3;
                const alpha = Math.random() * 0.15;
                ctx.fillStyle = Math.random() > 0.5 ?
                    `rgba(255,255,255,${alpha})` :
                    `rgba(0,0,0,${alpha})`;
                ctx.fillRect(x, y, w, h);
            }

            // Bands for gas giants
            if (type === 'gas') {
                for (let i = 0; i < 15; i++) {
                    const y = Math.random() * 512;
                    const h = Math.random() * 30 + 10;
                    ctx.fillStyle = `rgba(${Math.random() > 0.5 ? 255 : 0},${Math.random() > 0.5 ? 255 : 0},${Math.random() > 0.5 ? 255 : 0},${Math.random() * 0.2})`;
                    ctx.fillRect(0, y, 1024, h);
                }

                // Add storm spots
                for (let i = 0; i < 3; i++) {
                    const x = Math.random() * 1024;
                    const y = 150 + Math.random() * 200;
                    const radius = 20 + Math.random() * 40;
                    const grd = ctx.createRadialGradient(x, y, 0, x, y, radius);
                    grd.addColorStop(0, `rgba(255,200,150,0.5)`);
                    grd.addColorStop(1, 'transparent');
                    ctx.fillStyle = grd;
                    ctx.beginPath();
                    ctx.ellipse(x, y, radius * 1.5, radius, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
            } else {
                // Terran features - continents and oceans
                for (let i = 0; i < 8; i++) {
                    const x = Math.random() * 1024;
                    const y = Math.random() * 512;
                    const radius = 50 + Math.random() * 100;
                    const grd = ctx.createRadialGradient(x, y, 0, x, y, radius);
                    grd.addColorStop(0, `rgba(${100+Math.random()*50},${150+Math.random()*50},${100+Math.random()*50},0.6)`);
                    grd.addColorStop(1, 'transparent');
                    ctx.fillStyle = grd;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Ice caps
                ctx.fillStyle = 'rgba(255,255,255,0.4)';
                ctx.fillRect(0, 0, 1024, 30);
                ctx.fillRect(0, 482, 1024, 30);
            }

            return new THREE.CanvasTexture(canvas);
        }

        function createMoonTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');

            // Gray base
            ctx.fillStyle = '#666';
            ctx.fillRect(0, 0, 256, 128);

            // Craters
            for (let i = 0; i < 50; i++) {
                const x = Math.random() * 256;
                const y = Math.random() * 128;
                const radius = 2 + Math.random() * 8;
                const grd = ctx.createRadialGradient(x, y, 0, x, y, radius);
                grd.addColorStop(0, 'rgba(40,40,40,0.8)');
                grd.addColorStop(0.7, 'rgba(80,80,80,0.5)');
                grd.addColorStop(1, 'transparent');
                ctx.fillStyle = grd;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }

            return new THREE.CanvasTexture(canvas);
        }

        function createStarTexture(color) {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');

            const c = new THREE.Color(color);
            const gradient = ctx.createRadialGradient(128, 128, 0, 128, 128, 128);
            gradient.addColorStop(0, 'white');
            gradient.addColorStop(0.1, `rgb(${Math.floor(c.r*255)},${Math.floor(c.g*255)},${Math.floor(c.b*255)})`);
            gradient.addColorStop(0.4, `rgba(${Math.floor(c.r*200)},${Math.floor(c.g*150)},${Math.floor(c.b*100)},0.5)`);
            gradient.addColorStop(1, 'transparent');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 256, 256);

            return new THREE.CanvasTexture(canvas);
        }

        // ========================================
        // STARFIELD BACKGROUND
        // ========================================
        function createStarfield() {
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const colors = [];

            for (let i = 0; i < 10000; i++) {
                const x = (Math.random() - 0.5) * 8000;
                const y = (Math.random() - 0.5) * 8000;
                const z = (Math.random() - 0.5) * 8000;
                vertices.push(x, y, z);

                const brightness = 0.5 + Math.random() * 0.5;
                colors.push(brightness, brightness, brightness);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 2,
                vertexColors: true,
                transparent: true,
                opacity: 0.8
            });

            return new THREE.Points(geometry, material);
        }

        const starfield = createStarfield();
        scene.add(starfield);

        // ========================================
        // SOLAR SYSTEM GENERATION
        // ========================================
        function generateSystem() {
            // Clear old system
            if (star) {
                scene.remove(star);
                star.geometry.dispose();
                star.material.dispose();
            }

            // Clear habitable zone
            if (habitableZoneMesh) {
                scene.remove(habitableZoneMesh);
                habitableZoneMesh.geometry.dispose();
                habitableZoneMesh.material.dispose();
                habitableZoneMesh = null;
            }

            // Clear asteroid belt
            if (asteroidBelt) {
                scene.remove(asteroidBelt);
                asteroidBelt.geometry.dispose();
                asteroidBelt.material.dispose();
                asteroidBelt = null;
            }

            planets.forEach(p => {
                scene.remove(p.mesh);
                scene.remove(p.orbitLine);
                if (p.label) scene.remove(p.label);
                p.mesh.geometry.dispose();
                p.mesh.material.dispose();
                if (p.moons) {
                    p.moons.forEach(m => {
                        p.mesh.remove(m.mesh);
                        if (m.label) p.mesh.remove(m.label);
                        m.mesh.geometry.dispose();
                        m.mesh.material.dispose();
                    });
                }
            });

            planets = [];
            allClickableObjects = [];

            // Reset elapsed time
            elapsedSimulatedYears = 0;

            // Reset view
            currentView = 'system';
            focusedObject = null;
            cameraOffset = null;
            document.getElementById('detail-panel').classList.remove('visible');
            document.getElementById('back-btn').classList.remove('visible');
            document.getElementById('view-mode').classList.remove('visible');
            controls.autoRotate = false;

            // Generate Star
            const starTypes = [
                { color: 0xffcc33, scale: 12, name: "Yellow Dwarf", temp: "5,500K", age: "4.6 billion years" },
                { color: 0xff5533, scale: 8, name: "Red Dwarf", temp: "3,000K", age: "10 billion years" },
                { color: 0x6699ff, scale: 18, name: "Blue Giant", temp: "20,000K", age: "10 million years" },
                { color: 0xffffff, scale: 14, name: "White Star", temp: "8,000K", age: "1 billion years" },
                { color: 0xffaa66, scale: 25, name: "Orange Giant", temp: "4,500K", age: "8 billion years" }
            ];

            const starType = starTypes[Math.floor(Math.random() * starTypes.length)];
            starData = { ...starType, systemName: generateName().split('-')[0] + ' System' };

            const starGeo = new THREE.SphereGeometry(starType.scale, 64, 64);
            const starMat = new THREE.MeshBasicMaterial({
                color: starType.color,
                transparent: true,
                opacity: 0.95
            });
            star = new THREE.Mesh(starGeo, starMat);
            star.userData = { type: 'star', data: starData };
            scene.add(star);
            allClickableObjects.push(star);

            // Star glow
            const glowGeo = new THREE.SphereGeometry(starType.scale * 1.5, 32, 32);
            const glowMat = new THREE.MeshBasicMaterial({
                color: starType.color,
                transparent: true,
                opacity: 0.2,
                side: THREE.BackSide
            });
            const glow = new THREE.Mesh(glowGeo, glowMat);
            star.add(glow);

            pointLight.color.setHex(starType.color);
            pointLight.intensity = starType.scale / 5;

            // Generate Planets
            const numPlanets = Math.floor(Math.random() * 7) + 4;
            let currentDist = starType.scale * 2.5 + 30;

            for (let i = 0; i < numPlanets; i++) {
                const type = Math.random() > 0.5 ? 'gas' : 'terran';
                const size = type === 'gas' ? (Math.random() * 5 + 4) : (Math.random() * 2 + 1);
                const dist = currentDist + Math.random() * 40 + 25;
                currentDist = dist;

                const speed = 0.008 / Math.sqrt(dist * 0.1);
                const colorHex = Math.random() * 0xffffff;
                const name = generateName();

                const planetGeo = new THREE.SphereGeometry(size, 64, 64);
                const planetMat = new THREE.MeshStandardMaterial({
                    map: createPlanetTexture(type, '#' + new THREE.Color(colorHex).getHexString()),
                    roughness: type === 'gas' ? 0.9 : 0.7,
                    metalness: type === 'gas' ? 0 : 0.1
                });
                const planet = new THREE.Mesh(planetGeo, planetMat);

                // Planet data
                const planetData = {
                    name: name,
                    type: type,
                    radius: size,
                    distance: dist,
                    orbitalPeriod: Math.floor(dist * 2) + ' Earth days',
                    temperature: type === 'gas' ? '-150C (cloud tops)' : (dist < 100 ? '+' + Math.floor(300 - dist * 2) + 'C' : Math.floor(dist * -1) + 'C'),
                    description: planetDescriptions[type][Math.floor(Math.random() * planetDescriptions[type].length)],
                    moons: []
                };

                planet.userData = { type: 'planet', data: planetData, index: i };
                allClickableObjects.push(planet);

                // Orbit Line
                const orbitGeo = new THREE.RingGeometry(dist - 0.3, dist + 0.3, 128);
                const orbitMat = new THREE.MeshBasicMaterial({
                    color: 0x444466,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.3
                });
                const orbitLine = new THREE.Mesh(orbitGeo, orbitMat);
                orbitLine.rotation.x = Math.PI / 2;
                scene.add(orbitLine);
                if (!showOrbits) orbitLine.visible = false;

                // Moons
                const moons = [];
                const numMoons = type === 'gas' ? Math.floor(Math.random() * 5) + 1 : (Math.random() > 0.6 ? Math.floor(Math.random() * 2) + 1 : 0);

                for (let j = 0; j < numMoons; j++) {
                    const mSize = size * (0.1 + Math.random() * 0.15);
                    const mDist = size * 2.5 + j * (size * 1.5) + Math.random() * 3;
                    const mSpeed = 0.03 + Math.random() * 0.03;
                    const moonName = generateMoonName();

                    const mGeo = new THREE.SphereGeometry(mSize, 32, 32);
                    const mMat = new THREE.MeshStandardMaterial({
                        map: createMoonTexture(),
                        roughness: 0.9
                    });
                    const moon = new THREE.Mesh(mGeo, mMat);

                    const moonData = {
                        name: moonName,
                        radius: mSize,
                        distance: mDist,
                        orbitalPeriod: Math.floor(mDist * 5) + ' hours',
                        description: moonDescriptions[Math.floor(Math.random() * moonDescriptions.length)],
                        parentPlanet: planetData.name
                    };

                    moon.userData = { type: 'moon', data: moonData, parentIndex: i };
                    allClickableObjects.push(moon);

                    planet.add(moon);
                    moons.push({
                        mesh: moon,
                        dist: mDist,
                        speed: mSpeed,
                        angle: Math.random() * Math.PI * 2,
                        data: moonData
                    });

                    planetData.moons.push(moonData);
                }

                // Rings for some gas giants
                if (type === 'gas' && Math.random() > 0.6) {
                    const ringGeo = new THREE.RingGeometry(size * 1.4, size * 2.2, 64);
                    const ringMat = new THREE.MeshBasicMaterial({
                        color: 0xccbbaa,
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 0.5
                    });
                    const ring = new THREE.Mesh(ringGeo, ringMat);
                    ring.rotation.x = Math.PI / 2 + (Math.random() - 0.5) * 0.3;
                    planet.add(ring);
                    planetData.hasRings = true;
                }

                scene.add(planet);
                planets.push({
                    mesh: planet,
                    dist: dist,
                    speed: speed,
                    angle: Math.random() * Math.PI * 2,
                    orbitLine: orbitLine,
                    moons: moons,
                    data: planetData
                });
            }

            // Update UI
            document.getElementById('system-stats').innerHTML = `
                <strong>System:</strong> ${starData.systemName}<br>
                <strong>Star:</strong> ${starType.name} (${starType.temp})<br>
                <strong>Planets:</strong> ${numPlanets}
            `;

            // Reset camera
            camera.position.set(0, 150, 300);
            camera.lookAt(0, 0, 0);
            controls.target.set(0, 0, 0);

            // Create habitable zone and asteroid belt
            createHabitableZone();
            createAsteroidBelt();

            // ARIA announcement for new system
            if (typeof announce === 'function') {
                announce(`New solar system generated: ${starData.systemName} with ${numPlanets} planets`);
            }
        }

        // ========================================
        // CAMERA TRANSITIONS
        // ========================================
        function focusOnObject(object, viewType) {
            if (isTransitioning) return;

            isTransitioning = true;
            document.body.classList.add('transitioning');

            const data = object.userData.data;
            currentView = viewType;
            focusedObject = object;

            // Calculate target position based on object type
            let targetPos, targetLook;

            if (viewType === 'planet') {
                const planetPos = new THREE.Vector3();
                object.getWorldPosition(planetPos);
                const distance = data.radius * 6;

                targetPos = new THREE.Vector3(
                    planetPos.x + distance,
                    planetPos.y + distance * 0.5,
                    planetPos.z + distance
                );
                targetLook = planetPos;

                // Show detail panel
                showDetailPanel(data, 'planet');

            } else if (viewType === 'moon') {
                const moonPos = new THREE.Vector3();
                object.getWorldPosition(moonPos);
                const distance = data.radius * 15;

                targetPos = new THREE.Vector3(
                    moonPos.x + distance,
                    moonPos.y + distance * 0.3,
                    moonPos.z + distance
                );
                targetLook = moonPos;

                // Show detail panel for moon
                showDetailPanel(data, 'moon');

            } else if (viewType === 'star') {
                const distance = starData.scale * 5;
                targetPos = new THREE.Vector3(distance, distance * 0.5, distance);
                targetLook = new THREE.Vector3(0, 0, 0);

                showDetailPanel(starData, 'star');
            }

            targetCameraPosition = targetPos;
            targetLookAt = targetLook;
            transitionProgress = 0; // Reset for easing

            // Play zoom sound
            playZoomSound();

            // Update UI
            document.getElementById('view-mode').classList.add('visible');
            document.getElementById('view-target').textContent = data.name;
            document.getElementById('back-btn').classList.add('visible');

            // Enable auto-rotate for nice orbit view
            setTimeout(() => {
                controls.autoRotate = true;
                controls.autoRotateSpeed = 0.5;
            }, 1500);
        }

        function returnToSystemView() {
            if (isTransitioning) return;

            isTransitioning = true;
            document.body.classList.add('transitioning');

            currentView = 'system';
            focusedObject = null;
            cameraOffset = null; // Reset offset
            controls.autoRotate = false;

            targetCameraPosition = new THREE.Vector3(0, 150, 300);
            targetLookAt = new THREE.Vector3(0, 0, 0);

            document.getElementById('detail-panel').classList.remove('visible');
            document.getElementById('view-mode').classList.remove('visible');
            document.getElementById('back-btn').classList.remove('visible');
        }

        function showDetailPanel(data, type) {
            const panel = document.getElementById('detail-panel');
            const nameEl = document.getElementById('detail-name');
            const statsEl = document.getElementById('detail-stats');
            const descEl = document.getElementById('detail-description');
            const moonsSection = document.getElementById('moons-section');
            const moonsList = document.getElementById('moons-list');

            nameEl.textContent = data.name;

            if (type === 'star') {
                statsEl.innerHTML = `
                    <div class="stat-row"><span class="stat-label">Type</span><span class="stat-value">${escapeHTML(data.name)}</span></div>
                    <div class="stat-row"><span class="stat-label">Temperature</span><span class="stat-value">${escapeHTML(data.temp)}</span></div>
                    <div class="stat-row"><span class="stat-label">Age</span><span class="stat-value">${escapeHTML(data.age)}</span></div>
                    <div class="stat-row"><span class="stat-label">Radius</span><span class="stat-value">${data.scale} solar units</span></div>
                `;
                descEl.textContent = "The central star of this system, providing light and warmth to all orbiting bodies.";
                moonsSection.style.display = 'none';

            } else if (type === 'planet') {
                statsEl.innerHTML = `
                    <div class="stat-row"><span class="stat-label">Type</span><span class="stat-value">${escapeHTML(data.type) === 'gas' ? 'Gas Giant' : 'Terrestrial'}</span></div>
                    <div class="stat-row"><span class="stat-label">Radius</span><span class="stat-value">${data.radius.toFixed(1)} Earth radii</span></div>
                    <div class="stat-row"><span class="stat-label">Orbital Distance</span><span class="stat-value">${data.distance.toFixed(0)} AU</span></div>
                    <div class="stat-row"><span class="stat-label">Orbital Period</span><span class="stat-value">${escapeHTML(data.orbitalPeriod)}</span></div>
                    <div class="stat-row"><span class="stat-label">Temperature</span><span class="stat-value">${escapeHTML(data.temperature)}</span></div>
                    ${data.hasRings ? '<div class="stat-row"><span class="stat-label">Features</span><span class="stat-value">Ring System</span></div>' : ''}
                `;
                descEl.textContent = data.description;

                // Show moons if any
                if (data.moons && data.moons.length > 0) {
                    moonsSection.style.display = 'block';
                    moonsList.setAttribute('role', 'listbox');
                    moonsList.setAttribute('aria-label', 'Moons of ' + data.name);
                    moonsList.innerHTML = data.moons.map((moon, idx) => `
                        <div class="moon-item" data-moon-index="${idx}" role="option" tabindex="0"
                             aria-label="${escapeHTML(moon.name)}, click or press Enter to zoom">
                            <span>${escapeHTML(moon.name)}</span>
                            <span class="zoom-hint">Click to zoom</span>
                        </div>
                    `).join('');

                    // Add click and keyboard handlers for moons
                    moonsList.querySelectorAll('.moon-item').forEach((item, idx) => {
                        const handleMoonSelect = () => {
                            const planet = planets.find(p => p.data.name === data.name);
                            if (planet && planet.moons[idx]) {
                                focusOnObject(planet.moons[idx].mesh, 'moon');
                            }
                        };
                        item.addEventListener('click', handleMoonSelect);
                        item.addEventListener('keydown', (e) => {
                            if (e.key === 'Enter' || e.key === ' ') {
                                e.preventDefault();
                                handleMoonSelect();
                            }
                            // Arrow key navigation within moon list
                            if (e.key === 'ArrowDown') {
                                e.preventDefault();
                                const next = item.nextElementSibling;
                                if (next) next.focus();
                            }
                            if (e.key === 'ArrowUp') {
                                e.preventDefault();
                                const prev = item.previousElementSibling;
                                if (prev) prev.focus();
                            }
                        });
                    });
                } else {
                    moonsSection.style.display = 'none';
                }

            } else if (type === 'moon') {
                statsEl.innerHTML = `
                    <div class="stat-row"><span class="stat-label">Parent</span><span class="stat-value">${escapeHTML(data.parentPlanet)}</span></div>
                    <div class="stat-row"><span class="stat-label">Radius</span><span class="stat-value">${data.radius.toFixed(2)} Earth radii</span></div>
                    <div class="stat-row"><span class="stat-label">Orbital Distance</span><span class="stat-value">${data.distance.toFixed(1)} planet radii</span></div>
                    <div class="stat-row"><span class="stat-label">Orbital Period</span><span class="stat-value">${escapeHTML(data.orbitalPeriod)}</span></div>
                `;
                descEl.textContent = data.description;
                moonsSection.style.display = 'none';
            }

            panel.classList.add('visible');
        }

        // ========================================
        // ANIMATION LOOP
        // ========================================
        function animate() {
            requestAnimationFrame(animate);

            // Battery saver - check for idle state
            if (!isIdle && Date.now() - lastInteractionTime > IDLE_THRESHOLD) {
                isIdle = true;
            }

            // Skip frames when idle (render at ~15fps instead of 60fps)
            if (isIdle) {
                frameSkipCounter++;
                if (frameSkipCounter < 4) return; // Skip 3 out of 4 frames
                frameSkipCounter = 0;
            }

            // Skip physics updates when paused (but still render)
            if (!isPaused) {
                const delta = 0.016 * timeSpeed;

                // Update elapsed simulation time
                elapsedSimulatedYears += (delta / 60) * YEARS_PER_SECOND; // Scaled to cosmic time

                // Update elapsed time display (throttled to avoid DOM thrashing)
                if (Math.random() < 0.05) { // Update ~3 times per second
                    const elapsedEl = document.getElementById('elapsed-time');
                    if (elapsedEl) {
                        const years = elapsedSimulatedYears;
                        let timeStr;
                        if (years < 1000) {
                            timeStr = Math.floor(years).toLocaleString() + ' years';
                        } else if (years < 1000000) {
                            timeStr = (years / 1000).toFixed(1) + 'K years';
                        } else if (years < 1000000000) {
                            timeStr = (years / 1000000).toFixed(2) + 'M years';
                        } else {
                            timeStr = (years / 1000000000).toFixed(2) + 'B years';
                        }
                        elapsedEl.textContent = 'Elapsed: ' + timeStr;
                    }
                }

                // Animate planets
                planets.forEach(p => {
                    p.angle += p.speed * timeSpeed;
                    p.mesh.position.x = Math.cos(p.angle) * p.dist;
                    p.mesh.position.z = Math.sin(p.angle) * p.dist;
                    p.mesh.rotation.y += 0.005 * timeSpeed;

                    // Animate moons
                    if (p.moons) {
                        p.moons.forEach(m => {
                            m.angle += m.speed * timeSpeed;
                            m.mesh.position.x = Math.cos(m.angle) * m.dist;
                            m.mesh.position.z = Math.sin(m.angle) * m.dist;
                            m.mesh.rotation.y += 0.01 * timeSpeed;
                        });
                    }
                });

                // Star pulsing
                if (star) {
                    const pulse = 1 + Math.sin(Date.now() * 0.002) * 0.02;
                    star.scale.set(pulse, pulse, pulse);
                }
            }

            // Camera transition with easing
            if (targetCameraPosition && targetLookAt) {
                // EaseOutCubic: t => 1 - Math.pow(1 - t, 3)
                transitionProgress = Math.min(transitionProgress + 0.015, 1);
                const eased = 1 - Math.pow(1 - transitionProgress, 3);
                const lerpFactor = 0.02 + eased * 0.08; // Smooth acceleration

                camera.position.lerp(targetCameraPosition, lerpFactor);
                controls.target.lerp(targetLookAt, lerpFactor);

                // Check if close enough
                if (camera.position.distanceTo(targetCameraPosition) < 1) {
                    // Store the offset from focused object when transition completes
                    if (focusedObject) {
                        const objectPos = new THREE.Vector3();
                        focusedObject.getWorldPosition(objectPos);
                        cameraOffset = camera.position.clone().sub(objectPos);
                    }
                    transitionProgress = 0;
                    targetCameraPosition = null;
                    targetLookAt = null;
                    isTransitioning = false;
                    document.body.classList.remove('transitioning');
                }
            }

            // If focused on a moving object, update camera to follow it
            if (focusedObject && currentView !== 'system' && !isTransitioning && cameraOffset) {
                const objectPos = new THREE.Vector3();
                focusedObject.getWorldPosition(objectPos);

                // Update camera position to maintain offset from object
                const targetCamPos = objectPos.clone().add(cameraOffset);
                camera.position.lerp(targetCamPos, 0.1);

                // Update controls target to look at object
                controls.target.lerp(objectPos, 0.1);
            }

            controls.update();
            renderer.render(scene, camera);

            // Update floating labels every few frames for performance
            if (typeof updateLabels === 'function' && Math.random() < 0.1) {
                updateLabels();
            }

            // Update minimap
            if (showMinimap && typeof drawMinimap === 'function') {
                drawMinimap();
            }
        }

        // ========================================
        // EVENT HANDLERS
        // ========================================
        function onMouseClick(event) {
            if (isTransitioning) return;

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(allClickableObjects, false);

            if (intersects.length > 0) {
                const clicked = intersects[0].object;
                const type = clicked.userData.type;

                if (type === 'planet') {
                    focusOnObject(clicked, 'planet');
                } else if (type === 'moon') {
                    focusOnObject(clicked, 'moon');
                } else if (type === 'star') {
                    focusOnObject(clicked, 'star');
                }
            }
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(allClickableObjects, false);

            document.body.style.cursor = intersects.length > 0 ? 'pointer' : 'grab';
        }

        // ========================================
        // INITIALIZATION
        // ========================================
        camera.position.set(0, 150, 300);
        camera.lookAt(0, 0, 0);
        generateSystem();
        animate();

        // Event Listeners
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Battery saver - reset idle timer on user interaction
        ['click', 'mousemove', 'touchstart', 'keydown', 'wheel'].forEach(event => {
            document.addEventListener(event, resetIdleTimer, { passive: true });
        });

        renderer.domElement.addEventListener('click', onMouseClick);
        renderer.domElement.addEventListener('mousemove', onMouseMove);

        document.getElementById('generate-btn').addEventListener('click', generateSystem);

        document.getElementById('toggle-orbits').addEventListener('click', () => {
            showOrbits = !showOrbits;
            planets.forEach(p => p.orbitLine.visible = showOrbits);
            const btn = document.getElementById('toggle-orbits');
            btn.classList.toggle('active', showOrbits);
            btn.setAttribute('aria-pressed', showOrbits);
        });

        document.getElementById('toggle-labels').addEventListener('click', () => {
            showLabels = !showLabels;
            const btn = document.getElementById('toggle-labels');
            btn.classList.toggle('active', showLabels);
            btn.setAttribute('aria-pressed', showLabels);
        });

        document.getElementById('speed-btn').addEventListener('click', () => {
            const currentIdx = SPEED_PRESETS.indexOf(timeSpeed);
            timeSpeed = SPEED_PRESETS[(currentIdx + 1) % SPEED_PRESETS.length];
            document.getElementById('speed-btn').textContent = `Speed: ${timeSpeed}x`;
        });

        document.getElementById('back-btn').addEventListener('click', returnToSystemView);

        // ========================================
        // PAUSE/PLAY CONTROL
        // ========================================
        const pauseBtn = document.getElementById('pause-btn');
        const pauseIndicator = document.getElementById('pause-indicator');

        function togglePause() {
            isPaused = !isPaused;
            pauseBtn.textContent = isPaused ? '⏵' : '⏸';
            pauseBtn.classList.toggle('paused', isPaused);
            pauseBtn.setAttribute('aria-pressed', isPaused);
            pauseBtn.setAttribute('aria-label', isPaused ? 'Resume simulation' : 'Pause simulation');
            pauseIndicator.classList.toggle('visible', isPaused);

            // Announce to screen readers
            pauseIndicator.textContent = isPaused ? '⏸ PAUSED' : '⏵ PLAYING';

            // ARIA announcement
            if (typeof announce === 'function') {
                announce(isPaused ? 'Simulation paused' : 'Simulation resumed');
            }
        }

        pauseBtn.addEventListener('click', togglePause);

        // ========================================
        // ARIA ANNOUNCER
        // ========================================
        const ariaAnnouncer = document.getElementById('aria-announcer');
        let announcementTimeout = null;

        function announce(message) {
            // Debounce announcements to avoid spam
            if (announcementTimeout) clearTimeout(announcementTimeout);
            announcementTimeout = setTimeout(() => {
                ariaAnnouncer.textContent = message;
                // Clear after announcement is read
                setTimeout(() => { ariaAnnouncer.textContent = ''; }, 1000);
            }, 200);
        }

        // ========================================
        // HAPTIC FEEDBACK
        // ========================================
        function hapticFeedback(type = 'light') {
            if (!navigator.vibrate) return;
            switch(type) {
                case 'light': navigator.vibrate(10); break;
                case 'medium': navigator.vibrate(25); break;
                case 'heavy': navigator.vibrate([50, 30, 50]); break;
                case 'success': navigator.vibrate([10, 50, 10]); break;
            }
        }

        // ========================================
        // FLOATING LABELS
        // ========================================
        const labelsContainer = document.getElementById('labels-container');
        const MAX_VISIBLE_LABELS = 5;
        let labelElements = [];

        function createLabel(name, type) {
            const label = document.createElement('div');
            label.className = `celestial-label ${type}`;
            label.textContent = name;
            labelsContainer.appendChild(label);
            return label;
        }

        function updateLabels() {
            if (!showLabels || currentView !== 'system') {
                labelsContainer.style.display = 'none';
                return;
            }
            labelsContainer.style.display = 'block';

            // Clear old labels
            labelsContainer.innerHTML = '';

            // Collect all celestial bodies with their screen positions and distances
            const bodies = [];

            // Add star
            if (star) {
                const pos = new THREE.Vector3();
                star.getWorldPosition(pos);
                const screenPos = pos.clone().project(camera);
                const dist = pos.distanceTo(camera.position);
                if (screenPos.z < 1) { // Only if in front of camera
                    bodies.push({
                        name: starData.systemName.split(' ')[0],
                        type: 'star',
                        x: (screenPos.x * 0.5 + 0.5) * window.innerWidth,
                        y: (-screenPos.y * 0.5 + 0.5) * window.innerHeight,
                        dist: dist
                    });
                }
            }

            // Add planets
            planets.forEach(p => {
                const pos = new THREE.Vector3();
                p.mesh.getWorldPosition(pos);
                const screenPos = pos.clone().project(camera);
                const dist = pos.distanceTo(camera.position);
                if (screenPos.z < 1) {
                    bodies.push({
                        name: p.data.name.split(' ')[0].split('-')[0],
                        type: 'planet',
                        x: (screenPos.x * 0.5 + 0.5) * window.innerWidth,
                        y: (-screenPos.y * 0.5 + 0.5) * window.innerHeight,
                        dist: dist
                    });
                }
            });

            // Sort by distance and show closest MAX_VISIBLE_LABELS
            bodies.sort((a, b) => a.dist - b.dist);
            const visibleBodies = bodies.slice(0, MAX_VISIBLE_LABELS);

            visibleBodies.forEach(body => {
                // Skip if off screen
                if (body.x < 0 || body.x > window.innerWidth || body.y < 0 || body.y > window.innerHeight) return;

                const label = createLabel(body.name, body.type);
                label.style.left = body.x + 'px';
                label.style.top = body.y + 'px';

                // Fade based on distance
                const opacity = Math.max(0.3, 1 - (body.dist / 500));
                label.style.opacity = opacity;
            });
        }

        // ========================================
        // TOUCH SUPPORT
        // ========================================
        let touchStartTime = 0;
        let touchStartPos = { x: 0, y: 0 };

        function onTouchStart(event) {
            if (event.touches.length === 1) {
                touchStartTime = Date.now();
                touchStartPos.x = event.touches[0].clientX;
                touchStartPos.y = event.touches[0].clientY;
            }
        }

        function onTouchEnd(event) {
            // Only handle tap if it was quick and didn't move much
            const touchDuration = Date.now() - touchStartTime;
            if (touchDuration < 300 && event.changedTouches.length === 1) {
                const touch = event.changedTouches[0];
                const moveDistance = Math.hypot(
                    touch.clientX - touchStartPos.x,
                    touch.clientY - touchStartPos.y
                );

                // If it's a tap (short duration, minimal movement)
                if (moveDistance < 20) {
                    handleTap(touch.clientX, touch.clientY);
                }
            }
        }

        function handleTap(clientX, clientY) {
            if (isTransitioning) return;

            mouse.x = (clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(allClickableObjects, false);

            if (intersects.length > 0) {
                const clicked = intersects[0].object;
                const type = clicked.userData.type;

                hapticFeedback('medium');

                if (type === 'planet') {
                    focusOnObject(clicked, 'planet');
                    announce(`Zooming to planet ${clicked.userData.data.name}`);
                } else if (type === 'moon') {
                    focusOnObject(clicked, 'moon');
                    announce(`Zooming to moon ${clicked.userData.data.name}`);
                } else if (type === 'star') {
                    focusOnObject(clicked, 'star');
                    announce(`Zooming to star`);
                }
            }
        }

        // Double-tap to pause on touch devices
        let lastTapTime = 0;
        function handleDoubleTap(event) {
            const now = Date.now();
            if (now - lastTapTime < 300) {
                togglePause();
                hapticFeedback('heavy');
                event.preventDefault();
            }
            lastTapTime = now;
        }

        if (isTouchDevice) {
            renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: true });
            renderer.domElement.addEventListener('touchend', onTouchEnd, { passive: true });
            // Double-tap for pause (on empty area)
            document.body.addEventListener('touchend', (e) => {
                if (e.target === document.body || e.target === renderer.domElement) {
                    handleDoubleTap(e);
                }
            }, { passive: false });
        }

        // ========================================
        // KEYBOARD NAVIGATION & SELECTION
        // ========================================
        let selectedPlanetIndex = -1; // -1 = none, 0 = star, 1-9 = planets
        const planetSelector = document.getElementById('planet-selector');
        const keyboardHelp = document.getElementById('keyboard-help');

        function updatePlanetSelector() {
            if (selectedPlanetIndex < 0 || isTransitioning) {
                planetSelector.classList.remove('visible');
                return;
            }

            let targetObject;
            if (selectedPlanetIndex === 0) {
                targetObject = star;
            } else if (selectedPlanetIndex <= planets.length) {
                targetObject = planets[selectedPlanetIndex - 1].mesh;
            } else {
                planetSelector.classList.remove('visible');
                return;
            }

            const pos = new THREE.Vector3();
            targetObject.getWorldPosition(pos);
            pos.project(camera);

            const x = (pos.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-pos.y * 0.5 + 0.5) * window.innerHeight;

            planetSelector.style.left = x + 'px';
            planetSelector.style.top = y + 'px';
            planetSelector.style.transform = 'translate(-50%, -50%)';
            planetSelector.classList.add('visible');
        }

        function selectAndZoom() {
            if (selectedPlanetIndex === 0 && star) {
                focusOnObject(star, 'star');
            } else if (selectedPlanetIndex > 0 && selectedPlanetIndex <= planets.length) {
                focusOnObject(planets[selectedPlanetIndex - 1].mesh, 'planet');
            }
        }

        // Enhanced keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Don't handle if typing in an input
            if (e.target.tagName === 'INPUT') return;

            const key = e.key.toLowerCase();

            // Escape - return to system view
            if (e.key === 'Escape') {
                if (currentView !== 'system') {
                    returnToSystemView();
                }
                selectedPlanetIndex = -1;
                updatePlanetSelector();
            }

            // G - generate new system
            if (key === 'g') {
                generateSystem();
                selectedPlanetIndex = -1;
                updatePlanetSelector();
            }

            // O - toggle orbits
            if (key === 'o') {
                showOrbits = !showOrbits;
                planets.forEach(p => p.orbitLine.visible = showOrbits);
                const btn = document.getElementById('toggle-orbits');
                btn.classList.toggle('active', showOrbits);
                btn.setAttribute('aria-pressed', showOrbits);
            }

            // L - toggle labels
            if (key === 'l') {
                showLabels = !showLabels;
                const btn = document.getElementById('toggle-labels');
                btn.classList.toggle('active', showLabels);
                btn.setAttribute('aria-pressed', showLabels);
            }

            // Space - pause/play
            if (e.key === ' ' && e.target === document.body) {
                e.preventDefault();
                togglePause();
            }

            // P - also pause/play
            if (key === 'p') {
                togglePause();
            }

            // S - save system
            if (key === 's' && !e.ctrlKey && !e.metaKey) {
                saveSystem();
            }

            // C - capture screenshot
            if (key === 'c' && !e.ctrlKey && !e.metaKey) {
                if (typeof captureScreenshot === 'function') {
                    captureScreenshot();
                }
            }

            // M - toggle audio mute
            if (key === 'm') {
                toggleAudio();
            }

            // T - toggle orbital trails
            if (key === 't') {
                showTrails = !showTrails;
                showNotification(`Orbital trails ${showTrails ? 'enabled' : 'disabled'}`);
                announce(`Orbital trails ${showTrails ? 'enabled' : 'disabled'}`);
            }

            // F - faster (increase speed)
            if (key === 'f') {
                const currentIdx = SPEED_PRESETS.indexOf(timeSpeed);
                if (currentIdx < SPEED_PRESETS.length - 1) {
                    timeSpeed = SPEED_PRESETS[currentIdx + 1];
                } else {
                    timeSpeed = SPEED_PRESETS[SPEED_PRESETS.length - 1];
                }
                document.getElementById('speed-btn').textContent = `Speed: ${timeSpeed}x`;
                announce(`Speed ${timeSpeed}x`);
            }

            // R - slower (reduce speed) / N - normal speed
            if (key === 'r') {
                const currentIdx = SPEED_PRESETS.indexOf(timeSpeed);
                if (currentIdx > 0) {
                    timeSpeed = SPEED_PRESETS[currentIdx - 1];
                } else {
                    timeSpeed = SPEED_PRESETS[0];
                }
                document.getElementById('speed-btn').textContent = `Speed: ${timeSpeed}x`;
                announce(`Speed ${timeSpeed}x`);
            }

            if (key === 'n') {
                timeSpeed = 1;
                document.getElementById('speed-btn').textContent = `Speed: 1x`;
                announce('Speed normal');
            }

            // V - toggle minimap
            if (key === 'v') {
                showMinimap = !showMinimap;
                const minimapEl = document.getElementById('minimap');
                if (minimapEl) {
                    minimapEl.style.opacity = showMinimap ? '1' : '0';
                }
                showNotification(`Minimap ${showMinimap ? 'enabled' : 'disabled'}`);
                announce(`Minimap ${showMinimap ? 'enabled' : 'disabled'}`);
            }

            // H - toggle habitable zone
            if (key === 'h') {
                showHabitableZone = !showHabitableZone;
                if (habitableZoneMesh) {
                    habitableZoneMesh.visible = showHabitableZone;
                }
                const legend = document.getElementById('hz-legend');
                if (legend) {
                    legend.classList.toggle('visible', showHabitableZone);
                    legend.setAttribute('aria-hidden', !showHabitableZone);
                }
                showNotification(`Habitable zone ${showHabitableZone ? 'visible' : 'hidden'}`);
                announce(`Habitable zone ${showHabitableZone ? 'visible - region where liquid water could exist' : 'hidden'}`);
            }

            // A - toggle asteroid belt
            if (key === 'a') {
                showAsteroids = !showAsteroids;
                if (asteroidBelt) {
                    asteroidBelt.visible = showAsteroids;
                }
                showNotification(`Asteroid belt ${showAsteroids ? 'visible' : 'hidden'}`);
                announce(`Asteroid belt ${showAsteroids ? 'visible' : 'hidden'}`);
            }

            // ? or / - toggle keyboard help
            if (e.key === '?' || (e.key === '/' && e.shiftKey)) {
                keyboardHelp.classList.toggle('visible');
            }

            // Number keys 0-9 for planet selection
            if (/^[0-9]$/.test(e.key) && currentView === 'system') {
                selectedPlanetIndex = parseInt(e.key);
                if (selectedPlanetIndex > planets.length) {
                    selectedPlanetIndex = planets.length;
                }
                updatePlanetSelector();
            }

            // Enter - zoom to selected planet
            if (e.key === 'Enter' && selectedPlanetIndex >= 0) {
                selectAndZoom();
            }

            // Arrow keys for planet navigation
            if (e.key === 'ArrowRight' && currentView === 'system') {
                selectedPlanetIndex = Math.min(selectedPlanetIndex + 1, planets.length);
                if (selectedPlanetIndex < 0) selectedPlanetIndex = 0;
                updatePlanetSelector();
            }
            if (e.key === 'ArrowLeft' && currentView === 'system') {
                selectedPlanetIndex = Math.max(selectedPlanetIndex - 1, 0);
                updatePlanetSelector();
            }

            // +/- for speed control (uses unified SPEED_PRESETS)
            if (e.key === '+' || e.key === '=') {
                const currentIdx = SPEED_PRESETS.indexOf(timeSpeed);
                timeSpeed = SPEED_PRESETS[Math.min(currentIdx + 1, SPEED_PRESETS.length - 1)];
                document.getElementById('speed-btn').textContent = `Speed: ${timeSpeed}x`;
            }
            if (e.key === '-' || e.key === '_') {
                const currentIdx = SPEED_PRESETS.indexOf(timeSpeed);
                timeSpeed = SPEED_PRESETS[Math.max(currentIdx - 1, 0)];
                document.getElementById('speed-btn').textContent = `Speed: ${timeSpeed}x`;
            }
        });

        // Update selector position during animation
        const originalAnimate = animate;
        function animateWithSelector() {
            originalAnimate();
            if (selectedPlanetIndex >= 0 && currentView === 'system') {
                updatePlanetSelector();
            }
        }

        // ========================================
        // DATA PERSISTENCE & IMPORT/EXPORT
        // ========================================
        const STORAGE_KEY = 'solarSystem_savedData';

        function getSystemData() {
            return {
                version: 1,
                timestamp: new Date().toISOString(),
                star: starData,
                planets: planets.map(p => ({
                    data: p.data,
                    angle: p.angle,
                    dist: p.dist,
                    speed: p.speed,
                    moons: p.moons.map(m => ({
                        data: m.data,
                        angle: m.angle,
                        dist: m.dist,
                        speed: m.speed
                    }))
                })),
                settings: {
                    showOrbits,
                    showLabels,
                    timeSpeed
                }
            };
        }

        function saveSystem() {
            try {
                const data = getSystemData();
                localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
                showNotification('System saved to browser storage');
            } catch (err) {
                console.error('Failed to save:', err);
                showNotification('Failed to save system', true);
            }
        }

        function loadSystem() {
            try {
                const saved = localStorage.getItem(STORAGE_KEY);
                if (saved) {
                    const data = JSON.parse(saved);
                    rebuildFromData(data);
                    showNotification('System loaded from browser storage');
                    return true;
                }
            } catch (err) {
                console.error('Failed to load:', err);
            }
            return false;
        }

        function exportSystem() {
            const data = getSystemData();
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `solar-system-${starData.systemName.replace(/\s+/g, '-')}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showNotification('System exported as JSON');
        }

        // Schema validation for imports
        const MAX_IMPORT_SIZE = 1024 * 1024; // 1MB limit
        const MAX_PLANETS = 20;
        const MAX_TOTAL_MOONS = 100;

        function validateSystemSchema(data) {
            // Required top-level fields
            if (!data.version || !data.star || !Array.isArray(data.planets)) {
                return { valid: false, error: 'Missing required fields (version, star, planets)' };
            }

            // Validate star data
            if (!data.star.scale || !data.star.systemName) {
                return { valid: false, error: 'Invalid star data' };
            }

            // Check planet count limit
            if (data.planets.length > MAX_PLANETS) {
                return { valid: false, error: `Too many planets (max ${MAX_PLANETS})` };
            }

            // Count total moons across all planets
            let totalMoons = 0;

            // Validate each planet
            for (let i = 0; i < data.planets.length; i++) {
                const planet = data.planets[i];
                if (!planet.data || !planet.data.name || !planet.data.type) {
                    return { valid: false, error: `Planet ${i + 1} missing required data` };
                }
                if (planet.data.type !== 'gas' && planet.data.type !== 'terran') {
                    return { valid: false, error: `Planet ${i + 1} has invalid type` };
                }
                if (typeof planet.dist !== 'number' || typeof planet.speed !== 'number') {
                    return { valid: false, error: `Planet ${i + 1} has invalid orbital data` };
                }

                // Validate moons if present
                if (planet.moons && !Array.isArray(planet.moons)) {
                    return { valid: false, error: `Planet ${i + 1} has invalid moons data` };
                }

                // Count moons
                if (planet.moons) {
                    totalMoons += planet.moons.length;
                }
            }

            // Check total moon count
            if (totalMoons > MAX_TOTAL_MOONS) {
                return { valid: false, error: `Too many moons (max ${MAX_TOTAL_MOONS})` };
            }

            return { valid: true };
        }

        // Sanitize all imported string fields
        function sanitizeImportedData(data) {
            data.star.systemName = escapeHTML(data.star.systemName);
            data.star.name = escapeHTML(data.star.name || '');
            data.star.temp = escapeHTML(data.star.temp || '');
            data.star.age = escapeHTML(data.star.age || '');

            data.planets.forEach(p => {
                if (p.data) {
                    p.data.name = escapeHTML(p.data.name || '');
                    p.data.description = escapeHTML(p.data.description || '');
                    p.data.orbitalPeriod = escapeHTML(p.data.orbitalPeriod || '');
                    p.data.temperature = escapeHTML(p.data.temperature || '');
                }
                if (p.moons) {
                    p.moons.forEach(m => {
                        if (m.data) {
                            m.data.name = escapeHTML(m.data.name || '');
                            m.data.description = escapeHTML(m.data.description || '');
                            m.data.orbitalPeriod = escapeHTML(m.data.orbitalPeriod || '');
                            m.data.parentPlanet = escapeHTML(m.data.parentPlanet || '');
                        }
                    });
                }
            });

            return data;
        }

        function importSystem(file) {
            // Check file size limit
            if (file.size > MAX_IMPORT_SIZE) {
                const sizeMB = (MAX_IMPORT_SIZE / 1024 / 1024).toFixed(1);
                showNotification(`File too large. Maximum size: ${sizeMB}MB`, true);
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    let data = JSON.parse(e.target.result);

                    // Validate schema
                    const validation = validateSystemSchema(data);
                    if (!validation.valid) {
                        throw new Error(validation.error);
                    }

                    // Sanitize all imported string fields to prevent XSS
                    data = sanitizeImportedData(data);

                    rebuildFromData(data);
                    showNotification('System imported successfully');
                    announce('Solar system imported successfully');

                } catch (err) {
                    console.error('Import failed:', err);
                    const errorMsg = err instanceof SyntaxError ?
                        'Invalid JSON file format' :
                        err.message || 'Unknown error';
                    showNotification(`Import failed: ${errorMsg}`, true);
                }
            };
            reader.onerror = () => {
                showNotification('Failed to read file', true);
            };
            reader.readAsText(file);
        }

        function rebuildFromData(data) {
            // Clear existing system
            if (star) {
                scene.remove(star);
                star.geometry.dispose();
                star.material.dispose();
            }
            planets.forEach(p => {
                scene.remove(p.mesh);
                scene.remove(p.orbitLine);
                p.mesh.geometry.dispose();
                p.mesh.material.dispose();
            });
            planets = [];
            allClickableObjects = [];

            // Rebuild star
            starData = data.star;
            const starGeo = new THREE.SphereGeometry(starData.scale, 64, 64);
            const starMat = new THREE.MeshBasicMaterial({
                color: starData.color,
                transparent: true,
                opacity: 0.95
            });
            star = new THREE.Mesh(starGeo, starMat);
            star.userData = { type: 'star', data: starData };
            scene.add(star);
            allClickableObjects.push(star);

            // Star glow
            const glowGeo = new THREE.SphereGeometry(starData.scale * 1.5, 32, 32);
            const glowMat = new THREE.MeshBasicMaterial({
                color: starData.color,
                transparent: true,
                opacity: 0.2,
                side: THREE.BackSide
            });
            star.add(new THREE.Mesh(glowGeo, glowMat));

            // Rebuild planets
            data.planets.forEach((pData, i) => {
                const type = pData.data.type;
                const size = pData.data.radius;
                const dist = pData.dist;
                const colorHex = Math.random() * 0xffffff;

                const planetGeo = new THREE.SphereGeometry(size, 64, 64);
                const planetMat = new THREE.MeshStandardMaterial({
                    map: createPlanetTexture(type, '#' + new THREE.Color(colorHex).getHexString()),
                    roughness: type === 'gas' ? 0.9 : 0.7,
                    metalness: type === 'gas' ? 0 : 0.1
                });
                const planet = new THREE.Mesh(planetGeo, planetMat);
                planet.userData = { type: 'planet', data: pData.data, index: i };
                allClickableObjects.push(planet);

                // Orbit line
                const orbitGeo = new THREE.RingGeometry(dist - 0.3, dist + 0.3, 128);
                const orbitMat = new THREE.MeshBasicMaterial({
                    color: 0x444466,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.3
                });
                const orbitLine = new THREE.Mesh(orbitGeo, orbitMat);
                orbitLine.rotation.x = Math.PI / 2;
                scene.add(orbitLine);

                // Moons
                const moons = [];
                if (pData.moons) {
                    pData.moons.forEach((mData, j) => {
                        const mGeo = new THREE.SphereGeometry(mData.data.radius, 32, 32);
                        const mMat = new THREE.MeshStandardMaterial({
                            map: createMoonTexture(),
                            roughness: 0.9
                        });
                        const moon = new THREE.Mesh(mGeo, mMat);
                        moon.userData = { type: 'moon', data: mData.data, parentIndex: i };
                        allClickableObjects.push(moon);
                        planet.add(moon);

                        moons.push({
                            mesh: moon,
                            dist: mData.dist,
                            speed: mData.speed,
                            angle: mData.angle,
                            data: mData.data
                        });
                    });
                }

                scene.add(planet);
                planets.push({
                    mesh: planet,
                    dist: dist,
                    speed: pData.speed,
                    angle: pData.angle,
                    orbitLine: orbitLine,
                    moons: moons,
                    data: pData.data
                });
            });

            // Restore settings
            if (data.settings) {
                showOrbits = data.settings.showOrbits;
                showLabels = data.settings.showLabels;
                timeSpeed = data.settings.timeSpeed;
                document.getElementById('speed-btn').textContent = `Speed: ${timeSpeed}x`;
                planets.forEach(p => p.orbitLine.visible = showOrbits);
            }

            // Update UI
            document.getElementById('system-stats').innerHTML = `
                <strong>System:</strong> ${starData.systemName}<br>
                <strong>Star:</strong> ${starData.name} (${starData.temp})<br>
                <strong>Planets:</strong> ${planets.length}
            `;

            // Reset view
            currentView = 'system';
            focusedObject = null;
            camera.position.set(0, 150, 300);
            controls.target.set(0, 0, 0);
        }

        function showNotification(message, isError = false) {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: ${isError ? 'rgba(255, 100, 100, 0.9)' : 'rgba(78, 205, 196, 0.9)'};
                color: ${isError ? 'white' : 'black'};
                padding: 12px 24px;
                border-radius: 8px;
                font-size: 14px;
                font-weight: 500;
                z-index: 10000;
                animation: fadeInOut 2s ease-in-out forwards;
            `;
            notification.textContent = message;
            document.body.appendChild(notification);
            setTimeout(() => notification.remove(), 2000);
        }

        // Add notification animation
        const style = document.createElement('style');
        style.textContent = `
            @keyframes fadeInOut {
                0% { opacity: 0; transform: translateX(-50%) translateY(-10px); }
                15% { opacity: 1; transform: translateX(-50%) translateY(0); }
                85% { opacity: 1; transform: translateX(-50%) translateY(0); }
                100% { opacity: 0; transform: translateX(-50%) translateY(-10px); }
            }
        `;
        document.head.appendChild(style);

        // Event listeners for data controls
        document.getElementById('save-btn').addEventListener('click', saveSystem);
        document.getElementById('export-btn').addEventListener('click', exportSystem);
        document.getElementById('import-btn').addEventListener('click', () => {
            document.getElementById('import-file').click();
        });
        document.getElementById('import-file').addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                importSystem(e.target.files[0]);
                e.target.value = ''; // Reset for next import
            }
        });

        // ========================================
        // SCREENSHOT CAPTURE
        // ========================================
        function captureScreenshot() {
            try {
                // Ensure frame is fully rendered
                renderer.render(scene, camera);

                const canvas = renderer.domElement;
                const dataURL = canvas.toDataURL('image/png');

                // Create download link
                const link = document.createElement('a');
                const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
                const systemName = starData ? starData.systemName.replace(/\s+/g, '-') : 'system';
                link.download = `solar-system-${systemName}-${timestamp}.png`;
                link.href = dataURL;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);

                showNotification('Screenshot saved!');
                announce('Screenshot captured and downloaded');
                hapticFeedback('success');

            } catch (err) {
                console.error('Screenshot failed:', err);
                showNotification('Failed to capture screenshot', true);
            }
        }

        // ========================================
        // AUTOSAVE SYSTEM
        // ========================================
        const AUTOSAVE_KEY = 'solarSystem_autosave';
        const AUTOSAVE_INTERVAL = 30000; // 30 seconds
        let autosaveEnabled = true;
        let autosaveTimer = null;
        let hasUnsavedChanges = false;

        function autosaveSystem() {
            if (!autosaveEnabled || !hasUnsavedChanges || !starData) return;

            try {
                const data = getSystemData();
                data.isAutosave = true;
                data.autosaveTimestamp = Date.now();
                localStorage.setItem(AUTOSAVE_KEY, JSON.stringify(data));
                console.log('Autosaved at', new Date().toLocaleTimeString());
            } catch (err) {
                console.error('Autosave failed:', err);
            }
        }

        function startAutosave() {
            if (autosaveTimer) clearInterval(autosaveTimer);
            autosaveTimer = setInterval(autosaveSystem, AUTOSAVE_INTERVAL);
        }

        function markChanged() {
            hasUnsavedChanges = true;
        }

        // Check for autosave on load
        function checkAutosave() {
            try {
                const autosaved = localStorage.getItem(AUTOSAVE_KEY);
                if (autosaved) {
                    const autoData = JSON.parse(autosaved);
                    const autoTime = new Date(autoData.autosaveTimestamp).toLocaleString();
                    if (confirm(`Autosaved system found from ${autoTime}.\n\nRestore autosave? Click Cancel to use last manual save instead.`)) {
                        rebuildFromData(autoData);
                        showNotification('Autosave restored');
                        return true;
                    }
                }
            } catch (err) {
                console.error('Autosave check failed:', err);
            }
            return false;
        }

        // Start autosave system
        startAutosave();

        // Mark changes on generation
        const originalGenerateBtnHandler = document.getElementById('generate-btn').onclick;
        document.getElementById('generate-btn').addEventListener('click', markChanged);

        // Warn before leaving with unsaved changes
        window.addEventListener('beforeunload', (e) => {
            if (hasUnsavedChanges && !autosaveEnabled) {
                e.preventDefault();
                e.returnValue = 'You have unsaved changes.';
                return e.returnValue;
            }
        });

        // Try to load saved system on startup
        if (!loadSystem()) {
            // If no saved system, generate new one (already done above)
        }

        // ========================================
        // BROADCAST TRANSMISSION EFFECTS
        // ========================================
        const transmissionStartTime = Date.now();

        // Update transmission timestamp
        function updateTimestamp() {
            const elapsed = Date.now() - transmissionStartTime;
            const hours = Math.floor(elapsed / 3600000).toString().padStart(2, '0');
            const mins = Math.floor((elapsed % 3600000) / 60000).toString().padStart(2, '0');
            const secs = Math.floor((elapsed % 60000) / 1000).toString().padStart(2, '0');
            document.getElementById('tx-time').textContent = `${hours}:${mins}:${secs}`;
        }
        setInterval(updateTimestamp, 1000);

        // Occasional interference line
        function triggerInterference() {
            const line = document.getElementById('interference-line');
            line.style.top = Math.random() * 100 + '%';
            line.classList.remove('active');
            void line.offsetWidth; // Force reflow
            line.classList.add('active');

            // Schedule next interference (rare: 8-25 seconds)
            setTimeout(triggerInterference, 8000 + Math.random() * 17000);
        }
        setTimeout(triggerInterference, 5000 + Math.random() * 10000);

        // Subtle signal strength fluctuation
        function fluctuateSignal() {
            const bars = document.querySelectorAll('#transmission-indicator .signal-bar');
            bars.forEach((bar, i) => {
                const baseHeight = [4, 7, 10, 6][i];
                const fluctuation = (Math.random() - 0.5) * 3;
                bar.style.height = Math.max(2, baseHeight + fluctuation) + 'px';
                bar.style.opacity = 0.4 + Math.random() * 0.6;
            });
        }
        setInterval(fluctuateSignal, 2000);

        // Very rare deep glitch effect on focused object name
        function triggerTextGlitch() {
            const viewTarget = document.getElementById('view-target');
            if (viewTarget && viewTarget.textContent) {
                viewTarget.setAttribute('data-text', viewTarget.textContent);
                viewTarget.classList.add('glitch-text', 'glitching');
                setTimeout(() => {
                    viewTarget.classList.remove('glitching');
                }, 300);
            }

            // Schedule next glitch (very rare: 20-60 seconds)
            setTimeout(triggerTextGlitch, 20000 + Math.random() * 40000);
        }
        setTimeout(triggerTextGlitch, 15000 + Math.random() * 20000);

    </script>
</body>
</html>
