<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Steam Deck Game Store</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0e1015;
            color: #ffffff;
            overflow-x: hidden;
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        /* Loading Screen */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #0e1015;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity 0.3s ease;
        }

        .loading-screen.hide {
            opacity: 0;
            pointer-events: none;
        }

        .loading-logo {
            font-size: 48px;
            margin-bottom: 30px;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.1); opacity: 1; }
        }

        .loading-text {
            font-size: 18px;
            color: #8b8b8b;
            margin-bottom: 20px;
        }

        .loading-bar {
            width: 200px;
            height: 4px;
            background: #1a1d23;
            border-radius: 2px;
            overflow: hidden;
        }

        .loading-bar-fill {
            height: 100%;
            background: #4fc3f7;
            width: 0%;
            animation: loadingFill 2s ease-in-out infinite;
        }

        @keyframes loadingFill {
            0% { width: 0%; }
            50% { width: 80%; }
            100% { width: 100%; }
        }

        /* Main Container */
        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            width: 100vw;
            background: linear-gradient(135deg, #0e1015 0%, #1a1d23 100%);
        }

        /* Header */
        .header {
            padding: 20px 40px;
            background: rgba(26, 29, 35, 0.8);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 100;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 15px;
            font-size: 24px;
            font-weight: 600;
        }

        .logo-icon {
            font-size: 32px;
        }

        .nav-buttons {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .nav-button {
            padding: 8px 20px;
            background: rgba(79, 195, 247, 0.1);
            border: 1px solid rgba(79, 195, 247, 0.3);
            border-radius: 20px;
            color: #4fc3f7;
            font-size: 14px;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .nav-button:hover,
        .nav-button.active {
            background: rgba(79, 195, 247, 0.2);
            border-color: #4fc3f7;
            transform: translateY(-2px);
        }

        /* Content Area */
        .content {
            flex: 1;
            overflow-y: auto;
            padding: 40px;
            position: relative;
        }

        /* Game Grid */
        .games-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 25px;
            padding-bottom: 100px;
        }

        .game-card {
            background: rgba(26, 29, 35, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .game-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle at var(--mouse-x, 50%) var(--mouse-y, 50%), 
                        rgba(79, 195, 247, 0.1) 0%, 
                        transparent 70%);
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        .game-card:hover::before,
        .game-card.selected::before {
            opacity: 1;
        }

        .game-card:hover,
        .game-card.selected {
            transform: translateY(-5px);
            border-color: #4fc3f7;
            box-shadow: 0 10px 30px rgba(79, 195, 247, 0.2);
        }

        .game-icon {
            font-size: 64px;
            margin-bottom: 15px;
            display: block;
            filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.3));
        }

        .game-title {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 8px;
            color: #ffffff;
        }

        .game-description {
            font-size: 14px;
            color: #8b8b8b;
            line-height: 1.5;
            margin-bottom: 15px;
        }

        .game-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .game-size {
            font-size: 12px;
            color: #666;
        }

        .play-button {
            padding: 8px 20px;
            background: #4fc3f7;
            border: none;
            border-radius: 20px;
            color: #0e1015;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .play-button:hover {
            background: #29b6f6;
            transform: scale(1.05);
        }

        /* Game Detail Modal */
        .game-detail {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(14, 16, 21, 0.95);
            backdrop-filter: blur(20px);
            display: none;
            z-index: 1000;
            overflow-y: auto;
        }

        .game-detail.show {
            display: block;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .detail-content {
            max-width: 1000px;
            margin: 40px auto;
            padding: 40px;
            background: rgba(26, 29, 35, 0.9);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .detail-header {
            display: flex;
            gap: 30px;
            margin-bottom: 30px;
            align-items: start;
        }

        .detail-icon {
            font-size: 120px;
            filter: drop-shadow(0 8px 16px rgba(0, 0, 0, 0.4));
        }

        .detail-info {
            flex: 1;
        }

        .detail-title {
            font-size: 36px;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .detail-description {
            font-size: 18px;
            color: #8b8b8b;
            line-height: 1.6;
            margin-bottom: 20px;
        }

        .detail-actions {
            display: flex;
            gap: 15px;
            margin-top: 30px;
        }

        .action-button {
            padding: 12px 30px;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .action-button.primary {
            background: #4fc3f7;
            color: #0e1015;
        }

        .action-button.primary:hover {
            background: #29b6f6;
            transform: translateY(-2px);
        }

        .action-button.secondary {
            background: transparent;
            color: #4fc3f7;
            border: 2px solid #4fc3f7;
        }

        .action-button.secondary:hover {
            background: rgba(79, 195, 247, 0.1);
            transform: translateY(-2px);
        }

        .close-detail {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            border-radius: 50%;
            color: #ffffff;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .close-detail:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: rotate(90deg);
        }

        /* Controls Footer */
        .controls-footer {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(26, 29, 35, 0.95);
            backdrop-filter: blur(10px);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding: 15px 40px;
            display: flex;
            justify-content: center;
            gap: 40px;
            z-index: 100;
        }

        .control-hint {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            color: #8b8b8b;
        }

        .button-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 28px;
            height: 28px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            font-weight: 600;
            color: #ffffff;
        }

        /* Category Tabs */
        .category-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            padding: 0 40px;
            overflow-x: auto;
            scrollbar-width: none;
        }

        .category-tabs::-webkit-scrollbar {
            display: none;
        }

        .category-tab {
            padding: 10px 25px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 25px;
            color: #8b8b8b;
            font-size: 14px;
            white-space: nowrap;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .category-tab:hover,
        .category-tab.active {
            background: rgba(79, 195, 247, 0.2);
            border-color: #4fc3f7;
            color: #4fc3f7;
        }

        /* Search Bar */
        .search-container {
            max-width: 600px;
            margin: 0 auto 30px;
            padding: 0 40px;
        }

        .search-box {
            width: 100%;
            padding: 15px 25px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 30px;
            color: #ffffff;
            font-size: 16px;
            transition: all 0.3s ease;
        }

        .search-box:focus {
            outline: none;
            border-color: #4fc3f7;
            background: rgba(255, 255, 255, 0.08);
        }

        .search-box::placeholder {
            color: #666;
        }

        /* Toast Notifications */
        .toast {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: rgba(26, 29, 35, 0.95);
            border: 1px solid rgba(79, 195, 247, 0.5);
            border-radius: 30px;
            padding: 15px 30px;
            color: #4fc3f7;
            font-size: 14px;
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 2000;
        }

        .toast.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        /* No games message */
        .no-games {
            text-align: center;
            padding: 100px 20px;
            color: #666;
        }

        .no-games-icon {
            font-size: 64px;
            margin-bottom: 20px;
            opacity: 0.5;
        }

        .no-games-text {
            font-size: 18px;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .header {
                padding: 15px 20px;
            }

            .logo {
                font-size: 20px;
            }

            .content {
                padding: 20px;
            }

            .games-grid {
                grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
                gap: 20px;
            }

            .controls-footer {
                padding: 10px 20px;
                gap: 20px;
            }

            .control-hint {
                font-size: 12px;
            }
        }

        /* iOS specific styles */
        @supports (-webkit-touch-callout: none) {
            /* iOS Safari specific styles */
            .game-card {
                -webkit-touch-callout: none;
                -webkit-user-select: none;
            }
            
            .action-button,
            .nav-button,
            .play-button {
                -webkit-appearance: none;
                -webkit-tap-highlight-color: transparent;
            }
        }

        /* Touch-friendly enhancements */
        @media (hover: none) and (pointer: coarse) {
            .game-card {
                min-height: 280px;
            }
            
            .play-button,
            .action-button {
                min-height: 44px; /* iOS touch target size */
                font-size: 16px; /* Prevent zoom on iOS */
            }
            
            .nav-button {
                padding: 12px 24px;
                font-size: 16px;
            }
            
            .search-box {
                font-size: 16px; /* Prevent zoom on iOS */
                padding: 18px 25px;
            }
            
            .category-tab {
                padding: 12px 28px;
                font-size: 16px;
            }
            
            .emulator-button {
                width: 60px;
                height: 60px;
                font-size: 24px;
            }
            
            .close-detail {
                width: 50px;
                height: 50px;
                font-size: 24px;
            }
        }

        /* Keyboard navigation focus styles */
        *:focus {
            outline: 3px solid #4fc3f7;
            outline-offset: 2px;
        }

        button:focus,
        input:focus {
            outline: 3px solid #4fc3f7;
            outline-offset: 2px;
        }

        /* Mouse hover states */
        @media (hover: hover) {
            .game-card {
                cursor: pointer;
            }
            
            .game-card:hover {
                transform: translateY(-5px);
                border-color: #4fc3f7;
                box-shadow: 0 10px 30px rgba(79, 195, 247, 0.2);
            }
            
            button:hover {
                cursor: pointer;
            }
            
            .nav-button:hover,
            .category-tab:hover {
                transform: translateY(-2px);
            }
            
            .play-button:hover,
            .action-button:hover {
                transform: scale(1.05);
            }
        }

        /* Touch-specific game card styles */
        .game-card.touched {
            transform: scale(0.98);
            transition: transform 0.1s ease;
        }

        /* iOS safe area padding */
        @supports (padding: max(0px)) {
            .header {
                padding-top: max(20px, env(safe-area-inset-top));
            }
            
            .controls-footer {
                padding-bottom: max(15px, env(safe-area-inset-bottom));
            }
        }

        /* Prevent text selection on interactive elements */
        .game-card,
        button,
        .category-tab {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        /* Smooth scrolling for iOS */
        .content {
            -webkit-overflow-scrolling: touch;
        }

        /* Desktop controls indicator */
        .input-mode-indicator {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.6);
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 12px;
            color: #8b8b8b;
            z-index: 50;
            transition: opacity 0.3s ease;
        }

        .input-mode-indicator.hide {
            opacity: 0;
        }

        /* Emulator iframe */
        .emulator-container {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #000;
            z-index: 2000;
            display: none;
        }

        .emulator-container.show {
            display: block;
        }

        .emulator-iframe {
            width: 100%;
            height: 100%;
            border: none;
        }

        .emulator-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 2001;
        }

        .emulator-button {
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            border-radius: 50%;
            color: #ffffff;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .emulator-button:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        .emulator-button.save {
            background: rgba(79, 195, 247, 0.3);
        }

        .emulator-button.save:hover {
            background: rgba(79, 195, 247, 0.5);
        }

        .emulator-button.load {
            background: rgba(76, 175, 80, 0.3);
        }

        .emulator-button.load:hover {
            background: rgba(76, 175, 80, 0.5);
        }

        /* Save State Modal */
        .save-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(26, 29, 35, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            z-index: 2002;
            display: none;
        }

        .save-modal.show {
            display: block;
            animation: fadeIn 0.3s ease;
        }

        .save-modal-header {
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 20px;
            color: #4fc3f7;
        }

        .save-modal-content {
            margin-bottom: 25px;
        }

        .save-slot {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .save-slot:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: #4fc3f7;
        }

        .save-slot.empty {
            opacity: 0.6;
            font-style: italic;
        }

        .save-info {
            flex: 1;
        }

        .save-name {
            font-weight: 600;
            margin-bottom: 5px;
        }

        .save-date {
            font-size: 12px;
            color: #666;
        }

        .save-actions {
            display: flex;
            gap: 10px;
        }

        .save-action-btn {
            padding: 6px 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            color: #ffffff;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .save-action-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .save-action-btn.delete {
            color: #f44336;
            border-color: rgba(244, 67, 54, 0.3);
        }

        .save-action-btn.delete:hover {
            background: rgba(244, 67, 54, 0.2);
        }

        .modal-actions {
            display: flex;
            gap: 15px;
            justify-content: flex-end;
        }

        .modal-button {
            padding: 10px 25px;
            border: none;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .modal-button.primary {
            background: #4fc3f7;
            color: #0e1015;
        }

        .modal-button.primary:hover {
            background: #29b6f6;
        }

        .modal-button.secondary {
            background: transparent;
            color: #8b8b8b;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .modal-button.secondary:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .file-input-wrapper {
            margin: 20px 0;
        }

        .file-input-label {
            display: inline-block;
            padding: 10px 25px;
            background: rgba(76, 175, 80, 0.2);
            border: 1px solid rgba(76, 175, 80, 0.5);
            border-radius: 20px;
            color: #4CAF50;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .file-input-label:hover {
            background: rgba(76, 175, 80, 0.3);
        }

        .file-input {
            display: none;
        }
    </style>
</head>
<body>
    <!-- Input Mode Indicator -->
    <div class="input-mode-indicator hide" id="inputModeIndicator">
        <span id="inputModeText">Gamepad Mode</span>
    </div>

    <!-- Loading Screen -->
    <div class="loading-screen" id="loadingScreen">
        <div class="loading-logo">üéÆ</div>
        <div class="loading-text">Loading Game Store...</div>
        <div class="loading-bar">
            <div class="loading-bar-fill"></div>
        </div>
    </div>

    <!-- Main Container -->
    <div class="container">
        <!-- Header -->
        <header class="header">
            <div class="logo">
                <span class="logo-icon">üéÆ</span>
                <span>Steam Deck Game Store</span>
            </div>
            <div class="nav-buttons">
                <button class="nav-button active" id="storeBtn">Store</button>
                <button class="nav-button" id="libraryBtn">My Library</button>
                <button class="nav-button" id="settingsBtn">Settings</button>
            </div>
        </header>

        <!-- Search -->
        <div class="search-container">
            <input type="text" class="search-box" id="searchBox" placeholder="Search games...">
        </div>

        <!-- Category Tabs -->
        <div class="category-tabs">
            <button class="category-tab active" data-category="all">All Games</button>
            <button class="category-tab" data-category="action">Action</button>
            <button class="category-tab" data-category="puzzle">Puzzle</button>
            <button class="category-tab" data-category="arcade">Arcade</button>
            <button class="category-tab" data-category="strategy">Strategy</button>
            <button class="category-tab" data-category="adventure">Adventure</button>
        </div>

        <!-- Content Area -->
        <main class="content" id="content">
            <div class="games-grid" id="gamesGrid">
                <!-- Games will be loaded here -->
            </div>
        </main>

        <!-- Controls Footer -->
        <footer class="controls-footer">
            <div class="control-hint">
                <span class="button-icon">A</span>
                <span>Select</span>
            </div>
            <div class="control-hint">
                <span class="button-icon">B</span>
                <span>Back</span>
            </div>
            <div class="control-hint">
                <span class="button-icon">X</span>
                <span>Details</span>
            </div>
            <div class="control-hint">
                <span class="button-icon">Y</span>
                <span>Favorite</span>
            </div>
        </footer>
    </div>

    <!-- Game Detail Modal -->
    <div class="game-detail" id="gameDetail">
        <div class="detail-content">
            <button class="close-detail" id="closeDetail">‚úï</button>
            <div id="detailContent">
                <!-- Game details will be loaded here -->
            </div>
        </div>
    </div>

    <!-- Emulator Container -->
    <div class="emulator-container" id="emulatorContainer">
        <div class="emulator-controls">
            <button class="emulator-button save" id="saveStateBtn" title="Save State">üíæ</button>
            <button class="emulator-button load" id="loadStateBtn" title="Load State">üìÇ</button>
            <button class="emulator-button" id="closeEmulator" title="Close Game">‚úï</button>
        </div>
        <iframe class="emulator-iframe" id="emulatorFrame"></iframe>
    </div>

    <!-- Save State Modal -->
    <div class="save-modal" id="saveModal">
        <h3 class="save-modal-header">Save States</h3>
        <div class="save-modal-content" id="saveModalContent">
            <!-- Save slots will be loaded here -->
        </div>
        <div class="modal-actions">
            <button class="modal-button secondary" id="closeSaveModal">Cancel</button>
            <button class="modal-button primary" id="exportSaves">Export All</button>
        </div>
    </div>

    <!-- Load State Modal -->
    <div class="save-modal" id="loadModal">
        <h3 class="save-modal-header">Load State</h3>
        <div class="save-modal-content">
            <div class="file-input-wrapper">
                <label class="file-input-label" for="loadStateFile">
                    üìÅ Choose Save File (.json)
                </label>
                <input type="file" id="loadStateFile" class="file-input" accept=".json">
            </div>
            <div id="loadModalSlots">
                <!-- Load slots will be shown here -->
            </div>
        </div>
        <div class="modal-actions">
            <button class="modal-button secondary" id="closeLoadModal">Cancel</button>
        </div>
    </div>

    <!-- Toast Notification -->
    <div class="toast" id="toast"></div>

    <script>
        // GitHub repository configuration
        const REPO_CONFIG = {
            owner: 'kody-w',
            name: 'localFirstTools',
            branch: 'main'
        };

        // Game Store Class
        class SteamDeckGameStore {
          constructor() {
    this.games = [];
    this.currentCategory = 'all';
    this.currentView = 'store';
    this.selectedIndex = 0;
    this.gamepadConnected = false;
    this.favorites = this.loadFavorites();
    this.installedGames = this.loadInstalledGames();
    this.currentGameId = null;
    this.saveStates = this.loadSaveStates();
    
    // Input detection
    this.inputMode = 'mouse'; // mouse, keyboard, touch, gamepad
    this.lastInputTime = 0;
    this.isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
    this.isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
    
    // MISSING: Add these initializations
    this.lastNavigationTime = 0;
    this.lastTapTime = 0;
    
    this.init();
}

            async init() {
                // Set up input detection
                this.detectInputMethod();
                
                // Set up event listeners
                this.setupEventListeners();
                
                // Set up gamepad support
                this.setupGamepadSupport();
                
                // Optimize for iOS if needed
                if (this.isIOS) {
                    this.optimizeForIOS();
                }
                
                // Load games from GitHub
                await this.loadGames();
                
                // Hide loading screen
                setTimeout(() => {
                    document.getElementById('loadingScreen').classList.add('hide');
                }, 500);
            }

            detectInputMethod() {
                // Mouse movement detection
                document.addEventListener('mousemove', () => {
                    if (this.inputMode !== 'mouse') {
                        this.setInputMode('mouse');
                    }
                });
                
                // Touch detection
                document.addEventListener('touchstart', () => {
                    if (this.inputMode !== 'touch') {
                        this.setInputMode('touch');
                    }
                }, { passive: true });
                
                // Keyboard detection
                document.addEventListener('keydown', (e) => {
                    // Ignore if it's from an input field
                    if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
                        if (this.inputMode !== 'keyboard' && !this.gamepadConnected) {
                            this.setInputMode('keyboard');
                        }
                    }
                });
                
                // Set initial input mode
                if (this.isTouchDevice) {
                    this.setInputMode('touch');
                } else {
                    this.setInputMode('mouse');
                }
            }

            setInputMode(mode) {
                this.inputMode = mode;
                const indicator = document.getElementById('inputModeIndicator');
                const text = document.getElementById('inputModeText');
                
                // Update controls footer based on input mode
                this.updateControlsFooter(mode);
                
                // Show indicator briefly
                switch(mode) {
                    case 'gamepad':
                        text.textContent = 'üéÆ Gamepad Mode';
                        break;
                    case 'keyboard':
                        text.textContent = '‚å®Ô∏è Keyboard Mode';
                        break;
                    case 'touch':
                        text.textContent = 'üëÜ Touch Mode';
                        break;
                    case 'mouse':
                        text.textContent = 'üñ±Ô∏è Mouse Mode';
                        break;
                }
                
                indicator.classList.remove('hide');
                clearTimeout(this.indicatorTimeout);
                this.indicatorTimeout = setTimeout(() => {
                    indicator.classList.add('hide');
                }, 2000);
            }

            updateControlsFooter(mode) {
    const footer = document.querySelector('.controls-footer');
    let controls = '';
    
    switch(mode) {
        case 'gamepad':
            controls = '<div class="control-hint">' +
                '<span class="button-icon">A</span>' +
                '<span>Select</span>' +
                '</div>' +
                '<div class="control-hint">' +
                '<span class="button-icon">B</span>' +
                '<span>Back</span>' +
                '</div>' +
                '<div class="control-hint">' +
                '<span class="button-icon">X</span>' +
                '<span>Details</span>' +
                '</div>' +
                '<div class="control-hint">' +
                '<span class="button-icon">Y</span>' +
                '<span>Favorite</span>' +
                '</div>';
            break;
        case 'keyboard':
            controls = '<div class="control-hint">' +
                '<span class="button-icon">‚Üµ</span>' +
                '<span>Select</span>' +
                '</div>' +
                '<div class="control-hint">' +
                '<span class="button-icon">ESC</span>' +
                '<span>Back</span>' +
                '</div>' +
                '<div class="control-hint">' +
                '<span class="button-icon">TAB</span>' +
                '<span>Navigate</span>' +
                '</div>' +
                '<div class="control-hint">' +
                '<span class="button-icon">F</span>' +
                '<span>Favorite</span>' +
                '</div>';
            break;
        case 'touch':
            controls = '<div class="control-hint">' +
                '<span class="button-icon">üëÜ</span>' +
                '<span>Tap to Select</span>' +
                '</div>' +
                '<div class="control-hint">' +
                '<span class="button-icon">üì±</span>' +
                '<span>Swipe to Scroll</span>' +
                '</div>' +
                '<div class="control-hint">' +
                '<span class="button-icon">üëÜüëÜ</span>' +
                '<span>Double Tap for Details</span>' +
                '</div>';
            break;
        case 'mouse':
            controls = '<div class="control-hint">' +
                '<span class="button-icon">üñ±Ô∏è</span>' +
                '<span>Click to Select</span>' +
                '</div>' +
                '<div class="control-hint">' +
                '<span class="button-icon">‚Üª</span>' +
                '<span>Scroll to Browse</span>' +
                '</div>' +
                '<div class="control-hint">' +
                '<span class="button-icon">‚öôÔ∏è</span>' +
                '<span>Right Click for Options</span>' +
                '</div>';
            break;
    }
    
    footer.innerHTML = controls;
}

            optimizeForIOS() {
                // Prevent bouncing/elastic scrolling
                document.body.addEventListener('touchmove', (e) => {
                    if (e.target.closest('.content')) {
                        // Allow scrolling in content area
                        return;
                    }
                    e.preventDefault();
                }, { passive: false });
                
                // Add iOS-specific meta tags
                const viewport = document.querySelector('meta[name="viewport"]');
                if (viewport) {
                    viewport.content = 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover';
                }
                
                // Handle iOS safe areas
                document.body.style.paddingTop = 'env(safe-area-inset-top)';
                document.body.style.paddingBottom = 'env(safe-area-inset-bottom)';
            }

            setupEventListeners() {
                // Navigation buttons
                document.getElementById('storeBtn').addEventListener('click', () => this.switchView('store'));
                document.getElementById('libraryBtn').addEventListener('click', () => this.switchView('library'));
                document.getElementById('settingsBtn').addEventListener('click', () => this.switchView('settings'));
                
                // Search with debouncing for better performance
                let searchTimeout;
                document.getElementById('searchBox').addEventListener('input', (e) => {
                    clearTimeout(searchTimeout);
                    searchTimeout = setTimeout(() => {
                        this.filterGames(e.target.value);
                    }, 300);
                });
                
                // Prevent iOS keyboard issues
                if (this.isIOS) {
                    document.getElementById('searchBox').addEventListener('focus', () => {
                        setTimeout(() => {
                            window.scrollTo(0, 0);
                        }, 100);
                    });
                }
                
                // Category tabs with touch support
                document.querySelectorAll('.category-tab').forEach(tab => {
                    const selectTab = () => {
                        document.querySelectorAll('.category-tab').forEach(t => t.classList.remove('active'));
                        tab.classList.add('active');
                        this.currentCategory = tab.dataset.category;
                        this.renderGames();
                    };
                    
                    tab.addEventListener('click', selectTab);
                    
                    // Better touch handling
                    if (this.isTouchDevice) {
                        tab.addEventListener('touchend', (e) => {
                            e.preventDefault();
                            selectTab();
                        });
                    }
                });
                
                // Close buttons
                document.getElementById('closeDetail').addEventListener('click', () => {
                    document.getElementById('gameDetail').classList.remove('show');
                });
                
                document.getElementById('closeEmulator').addEventListener('click', () => {
                    this.closeEmulator();
                });
                
                // Save/Load state buttons
                document.getElementById('saveStateBtn').addEventListener('click', () => {
                    this.showSaveModal();
                });
                
                document.getElementById('loadStateBtn').addEventListener('click', () => {
                    this.showLoadModal();
                });
                
                // Save modal buttons
                document.getElementById('closeSaveModal').addEventListener('click', () => {
                    document.getElementById('saveModal').classList.remove('show');
                });
                
                document.getElementById('exportSaves').addEventListener('click', () => {
                    this.exportAllSaves();
                });
                
                // Load modal buttons
                document.getElementById('closeLoadModal').addEventListener('click', () => {
                    document.getElementById('loadModal').classList.remove('show');
                });
                
                document.getElementById('loadStateFile').addEventListener('change', (e) => {
                    this.handleLoadFile(e);
                });
                
                // Keyboard navigation
                document.addEventListener('keydown', (e) => this.handleKeyboard(e));
                
                // Message listener for game state communication
                window.addEventListener('message', (e) => {
                    if (e.data.type === 'GAME_STATE_RESPONSE') {
                        this.handleGameStateResponse(e.data.state);
                    }
                });
                
                // Handle window resize
                window.addEventListener('resize', () => {
                    this.handleResize();
                });
                
                // Context menu for mouse users
                document.addEventListener('contextmenu', (e) => {
                    if (e.target.closest('.game-card')) {
                        e.preventDefault();
                        const card = e.target.closest('.game-card');
                        const gameId = card.dataset.gameId;
                        const game = this.games.find(g => g.id === gameId);
                        if (game) {
                            this.showGameDetails(game);
                        }
                    }
                });
            }

            handleResize() {
                // Adjust grid columns based on screen size
                const width = window.innerWidth;
                const grid = document.getElementById('gamesGrid');
                if (grid) {
                    if (width < 600) {
                        grid.style.gridTemplateColumns = '1fr';
                    } else if (width < 900) {
                        grid.style.gridTemplateColumns = 'repeat(2, 1fr)';
                    } else {
                        grid.style.gridTemplateColumns = 'repeat(auto-fill, minmax(300px, 1fr))';
                    }
                }
            }

            setupGamepadSupport() {
                let rafId = null;
                let lastButtonStates = {};
                
                const pollGamepad = () => {
                    const gamepads = navigator.getGamepads();
                    let activeGamepad = null;
                    
                    for (let i = 0; i < gamepads.length; i++) {
                        if (gamepads[i]) {
                            activeGamepad = gamepads[i];
                            break;
                        }
                    }
                    
                    if (activeGamepad) {
                        this.handleGamepadInput(activeGamepad, lastButtonStates);
                        this.gamepadConnected = true;
                        
                        // Store current button states for next frame
                        lastButtonStates = {};
                        activeGamepad.buttons.forEach((button, index) => {
                            lastButtonStates[index] = button.pressed;
                        });
                    } else {
                        this.gamepadConnected = false;
                        lastButtonStates = {};
                    }
                    
                    rafId = requestAnimationFrame(pollGamepad);
                };
                
                window.addEventListener('gamepadconnected', (e) => {
                    console.log('Gamepad connected:', e.gamepad.id);
                    this.showToast('Gamepad connected: ' + e.gamepad.id);
                    this.setInputMode('gamepad');
                    if (!rafId) {
                        pollGamepad();
                    }
                });
                
                window.addEventListener('gamepaddisconnected', (e) => {
                    console.log('Gamepad disconnected:', e.gamepad.id);
                    this.showToast('Gamepad disconnected');
                    this.setInputMode(this.isTouchDevice ? 'touch' : 'mouse');
                    if (rafId) {
                        cancelAnimationFrame(rafId);
                        rafId = null;
                    }
                });
                
                // Start polling if gamepad already connected
                if (navigator.getGamepads()[0]) {
                    this.setInputMode('gamepad');
                    pollGamepad();
                }
            }

            handleGamepadInput(gamepad, lastButtonStates) {
                // D-pad navigation
                const threshold = 0.5;
                const deadzone = 0.2;
                
                // Track if we should navigate this frame
                let shouldNavigate = false;
                const now = Date.now();
                if (now - this.lastNavigationTime > 200) { // Limit navigation speed
                    shouldNavigate = true;
                }
                
                // Left stick or D-pad for navigation
                if (shouldNavigate) {
                    if (Math.abs(gamepad.axes[0]) > threshold || gamepad.buttons[15]?.pressed) {
                        this.navigate('right');
                        this.lastNavigationTime = now;
                    } else if (Math.abs(gamepad.axes[0]) < -threshold || gamepad.buttons[14]?.pressed) {
                        this.navigate('left');
                        this.lastNavigationTime = now;
                    }
                    
                    if (Math.abs(gamepad.axes[1]) > threshold || gamepad.buttons[13]?.pressed) {
                        this.navigate('down');
                        this.lastNavigationTime = now;
                    } else if (Math.abs(gamepad.axes[1]) < -threshold || gamepad.buttons[12]?.pressed) {
                        this.navigate('up');
                        this.lastNavigationTime = now;
                    }
                }
                
                // Button presses (only on button down, not held)
                // A button (button 0) - Select
                if (gamepad.buttons[0]?.pressed && !lastButtonStates[0]) {
                    this.selectCurrentItem();
                }
                
                // B button (button 1) - Back
                if (gamepad.buttons[1]?.pressed && !lastButtonStates[1]) {
                    this.goBack();
                }
                
                // X button (button 2) - Details
                if (gamepad.buttons[2]?.pressed && !lastButtonStates[2]) {
                    this.showCurrentDetails();
                }
                
                // Y button (button 3) - Favorite
                if (gamepad.buttons[3]?.pressed && !lastButtonStates[3]) {
                    this.toggleCurrentFavorite();
                }
                
                // Start button (button 9) - Menu
                if (gamepad.buttons[9]?.pressed && !lastButtonStates[9]) {
                    // Toggle menu or perform menu action
                }
                
                // Select button (button 8) - Search
                if (gamepad.buttons[8]?.pressed && !lastButtonStates[8]) {
                    document.getElementById('searchBox').focus();
                }
            }

            handleKeyboard(e) {
                // Don't handle if typing in input
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                    return;
                }
                
                switch(e.key) {
                    case 'ArrowUp':
                        e.preventDefault();
                        this.navigate('up');
                        break;
                    case 'ArrowDown':
                        e.preventDefault();
                        this.navigate('down');
                        break;
                    case 'ArrowLeft':
                        e.preventDefault();
                        this.navigate('left');
                        break;
                    case 'ArrowRight':
                        e.preventDefault();
                        this.navigate('right');
                        break;
                    case 'Enter':
                    case ' ':
                        e.preventDefault();
                        this.selectCurrentItem();
                        break;
                    case 'Escape':
                        e.preventDefault();
                        this.goBack();
                        break;
                    case 'Tab':
                        // Allow tab navigation but update selected index
                        setTimeout(() => {
                            const focused = document.activeElement;
                            const cards = Array.from(document.querySelectorAll('.game-card'));
                            const index = cards.indexOf(focused);
                            if (index !== -1) {
                                this.selectedIndex = index;
                            }
                        }, 0);
                        break;
                    case 'f':
                    case 'F':
                        e.preventDefault();
                        this.toggleCurrentFavorite();
                        break;
                    case 'd':
                    case 'D':
                        e.preventDefault();
                        this.showCurrentDetails();
                        break;
                }
            }

            navigate(direction) {
                const cards = document.querySelectorAll('.game-card');
                if (cards.length === 0) return;
                
                const columns = Math.floor(window.innerWidth / 320); // Approximate card width
                
                switch(direction) {
                    case 'up':
                        this.selectedIndex = Math.max(0, this.selectedIndex - columns);
                        break;
                    case 'down':
                        this.selectedIndex = Math.min(cards.length - 1, this.selectedIndex + columns);
                        break;
                    case 'left':
                        this.selectedIndex = Math.max(0, this.selectedIndex - 1);
                        break;
                    case 'right':
                        this.selectedIndex = Math.min(cards.length - 1, this.selectedIndex + 1);
                        break;
                }
                
                this.updateSelection();
            }

            updateSelection() {
                const cards = document.querySelectorAll('.game-card');
                cards.forEach((card, index) => {
                    card.classList.toggle('selected', index === this.selectedIndex);
                });
                
                // Scroll selected card into view
                if (cards[this.selectedIndex]) {
                    cards[this.selectedIndex].scrollIntoView({ 
                        behavior: 'smooth', 
                        block: 'nearest' 
                    });
                }
            }

            selectCurrentItem() {
                const cards = document.querySelectorAll('.game-card');
                if (cards[this.selectedIndex]) {
                    const gameId = cards[this.selectedIndex].dataset.gameId;
                    const game = this.games.find(g => g.id === gameId);
                    if (game) {
                        this.launchGame(game);
                    }
                }
            }

            goBack() {
                if (document.getElementById('gameDetail').classList.contains('show')) {
                    document.getElementById('gameDetail').classList.remove('show');
                } else if (document.getElementById('emulatorContainer').classList.contains('show')) {
                    this.closeEmulator();
                }
            }

            showCurrentDetails() {
                const cards = document.querySelectorAll('.game-card');
                if (cards[this.selectedIndex]) {
                    const gameId = cards[this.selectedIndex].dataset.gameId;
                    const game = this.games.find(g => g.id === gameId);
                    if (game) {
                        this.showGameDetails(game);
                    }
                }
            }

            toggleCurrentFavorite() {
                const cards = document.querySelectorAll('.game-card');
                if (cards[this.selectedIndex]) {
                    const gameId = cards[this.selectedIndex].dataset.gameId;
                    this.toggleFavorite(gameId);
                }
            }

            async loadGames() {
                try {
                    // Fetch repository contents from GitHub API
                    const apiUrl = `https://api.github.com/repos/${REPO_CONFIG.owner}/${REPO_CONFIG.name}/contents?ref=${REPO_CONFIG.branch}`;
                    const response = await fetch(apiUrl);
                    
                    if (!response.ok) {
                        throw new Error(`GitHub API error: ${response.status}`);
                    }
                    
                    const contents = await response.json();
                    
                    // Filter for HTML files in root directory (games)
                    const gameFiles = contents.filter(item => 
                        item.type === 'file' && 
                        item.name.endsWith('.html') &&
                        !item.name.includes('index') &&
                        !item.name.includes('gallery') &&
                        !item.name.includes('template')
                    );
                    
                    // Map files to game objects
                    this.games = gameFiles.map(file => {
                        const baseName = file.name.replace('.html', '');
                        const formattedName = baseName
                            .replace(/[-_]/g, ' ')
                            .replace(/\b\w/g, l => l.toUpperCase());
                        
                        // Determine category and icon based on filename
                        const gameInfo = this.getGameInfo(baseName);
                        
                        return {
                            id: baseName,
                            name: formattedName,
                            description: gameInfo.description,
                            icon: gameInfo.icon,
                            category: gameInfo.category,
                            url: file.download_url || `https://raw.githubusercontent.com/${REPO_CONFIG.owner}/${REPO_CONFIG.name}/${REPO_CONFIG.branch}/${file.name}`,
                            size: this.formatFileSize(file.size),
                            path: file.path,
                            sha: file.sha
                        };
                    });
                    
                    // Also check for JSON game files (for the emulator-style games)
                    const jsonFiles = contents.filter(item => 
                        item.type === 'file' && 
                        item.name.endsWith('.json') &&
                        (item.name.includes('game') || item.name.includes('snake') || item.name.includes('tetris'))
                    );
                    
                    // Add JSON games that can be played via the emulator
                    for (const file of jsonFiles) {
                        const baseName = file.name.replace('.json', '');
                        const gameInfo = this.getGameInfo(baseName);
                        
                        this.games.push({
                            id: baseName + '-json',
                            name: gameInfo.name || baseName.replace(/[-_]/g, ' ').replace(/\b\w/g, l => l.toUpperCase()),
                            description: gameInfo.description + ' (Emulator Version)',
                            icon: gameInfo.icon,
                            category: gameInfo.category,
                            url: `data:text/html,${encodeURIComponent(this.getEmulatorHTML(file.download_url))}`,
                            size: this.formatFileSize(file.size),
                            isEmulated: true,
                            jsonUrl: file.download_url
                        });
                    }
                    
                    console.log(`Loaded ${this.games.length} games from repository`);
                    this.renderGames();
                    
                } catch (error) {
                    console.error('Error loading games:', error);
                    this.showToast('Failed to load games from GitHub. Using fallback list.');
                    
                    // Fallback to a predefined list if GitHub API fails
                    this.loadFallbackGames();
                }
            }
            
            getGameInfo(filename) {
                // Map common game names to metadata
                const gameDatabase = {
                    'snake': { 
                        icon: 'üêç', 
                        category: 'arcade', 
                        description: 'The classic snake game - eat food and grow longer!',
                        name: 'Snake Classic'
                    },
                    'tetris': { 
                        icon: 'üß±', 
                        category: 'puzzle', 
                        description: 'Stack blocks and clear lines in this timeless puzzle game',
                        name: 'Tetris'
                    },
                    'breakout': { 
                        icon: 'üéØ', 
                        category: 'arcade', 
                        description: 'Break all the bricks with your paddle and ball',
                        name: 'Breakout'
                    },
                    'pong': { 
                        icon: 'üèì', 
                        category: 'arcade', 
                        description: 'The original tennis-like arcade game',
                        name: 'Pong'
                    },
                    'space-invaders': { 
                        icon: 'üëæ', 
                        category: 'action', 
                        description: 'Defend Earth from waves of alien invaders',
                        name: 'Space Invaders'
                    },
                    'flappy': { 
                        icon: 'üê¶', 
                        category: 'arcade', 
                        description: 'Navigate through pipes in this addictive game',
                        name: 'Flappy Bird Clone'
                    },
                    'asteroids': { 
                        icon: '‚òÑÔ∏è', 
                        category: 'action', 
                        description: 'Destroy asteroids and survive in space',
                        name: 'Asteroids'
                    },
                    'pacman': { 
                        icon: 'üëª', 
                        category: 'arcade', 
                        description: 'Eat dots and avoid ghosts in the maze',
                        name: 'Pac-Man Clone'
                    },
                    'maze': { 
                        icon: 'üß©', 
                        category: 'puzzle', 
                        description: 'Find your way through challenging mazes',
                        name: 'Maze Runner'
                    },
                    'puzzle': { 
                        icon: 'üß©', 
                        category: 'puzzle', 
                        description: 'Solve challenging puzzles',
                        name: 'Puzzle Game'
                    },
                    'platform': { 
                        icon: 'üèÉ', 
                        category: 'action', 
                        description: 'Jump and run through platform levels',
                        name: 'Platform Adventure'
                    },
                    'shooter': { 
                        icon: 'üî´', 
                        category: 'action', 
                        description: 'Classic shooting action game',
                        name: 'Space Shooter'
                    }
                };
                
                // Check for matches in filename
                const lowerFilename = filename.toLowerCase();
                for (const [key, info] of Object.entries(gameDatabase)) {
                    if (lowerFilename.includes(key)) {
                        return info;
                    }
                }
                
                // Default values if no match
                return {
                    icon: 'üéÆ',
                    category: 'arcade',
                    description: 'A fun game to play on your Steam Deck',
                    name: null
                };
            }
            
            formatFileSize(bytes) {
                if (bytes < 1024) return bytes + ' B';
                if (bytes < 1024 * 1024) return Math.round(bytes / 1024) + ' KB';
                return Math.round(bytes / (1024 * 1024)) + ' MB';
            }
            
            getEmulatorHTML(jsonUrl) {
                // Create a simple HTML wrapper for JSON games
                return `
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game Emulator</title>
    <style>
        body { margin: 0; padding: 20px; background: #1a1d23; color: white; font-family: sans-serif; }
        #status { text-align: center; padding: 50px; }
        #gameContainer { display: none; }
        canvas { max-width: 100%; height: auto; display: block; margin: 0 auto; }
    </style>
</head>
<body>
    <div id="status">Loading game...</div>
    <div id="gameContainer"></div>
    <script>
        // Load and run JSON game
        fetch('${jsonUrl}')
            .then(res => res.json())
            .then(gameData => {
                document.getElementById('status').style.display = 'none';
                document.getElementById('gameContainer').style.display = 'block';
                
                // Initialize game from JSON data
                if (gameData.initializeCode) {
                    const initFunc = new Function('return ' + gameData.initializeCode)();
                    const game = {
                        gameData: gameData.gameData,
                        initialize: initFunc,
                        update: gameData.updateCode ? new Function('return ' + gameData.updateCode)() : null,
                        render: gameData.renderCode ? new Function('return ' + gameData.renderCode)() : null,
                        handleInput: gameData.handleInputCode ? new Function('return ' + gameData.handleInputCode)() : null
                    };
                    
                    // Set up save state support
                    window.addEventListener('message', (event) => {
                        if (event.data.type === 'REQUEST_GAME_STATE') {
                            window.parent.postMessage({
                                type: 'GAME_STATE_RESPONSE',
                                state: game.gameData
                            }, '*');
                        }
                        
                        if (event.data.type === 'LOAD_GAME_STATE') {
                            game.gameData = event.data.state;
                            if (game.render) game.render();
                        }
                    });
                    
                    // Initialize and run game
                    game.initialize(document.getElementById('gameContainer'));
                    
                    if (game.update && game.render) {
                        function gameLoop() {
                            game.update();
                            game.render();
                            requestAnimationFrame(gameLoop);
                        }
                        gameLoop();
                    }
                }
            })
            .catch(err => {
                document.getElementById('status').innerHTML = 'Error loading game: ' + err.message;
            });
    </script>
</body>
</html>`;
            }
            
            loadFallbackGames() {
                // Fallback game list if GitHub API is unavailable
                this.games = [
                    {
                        id: 'snake-game',
                        name: 'Snake Classic',
                        description: 'The classic snake game with modern controls',
                        icon: 'üêç',
                        category: 'arcade',
                        url: `https://raw.githubusercontent.com/${REPO_CONFIG.owner}/${REPO_CONFIG.name}/${REPO_CONFIG.branch}/snake.html`,
                        size: '24 KB'
                    },
                    {
                        id: 'tetris-game',
                        name: 'Tetris Clone',
                        description: 'Stack blocks and clear lines in this classic puzzle game',
                        icon: 'üß±',
                        category: 'puzzle',
                        url: `https://raw.githubusercontent.com/${REPO_CONFIG.owner}/${REPO_CONFIG.name}/${REPO_CONFIG.branch}/tetris.html`,
                        size: '32 KB'
                    },
                    {
                        id: 'breakout-game',
                        name: 'Breakout',
                        description: 'Break all the bricks with your paddle and ball',
                        icon: 'üéØ',
                        category: 'arcade',
                        url: `https://raw.githubusercontent.com/${REPO_CONFIG.owner}/${REPO_CONFIG.name}/${REPO_CONFIG.branch}/breakout.html`,
                        size: '28 KB'
                    }
                ];
                
                this.renderGames();
            }

            renderGames() {
                const gamesGrid = document.getElementById('gamesGrid');
                const filteredGames = this.getFilteredGames();
                
                if (filteredGames.length === 0) {
                    gamesGrid.innerHTML = `
                        <div class="no-games">
                            <div class="no-games-icon">üéÆ</div>
                            <div class="no-games-text">No games found</div>
                        </div>
                    `;
                    return;
                }
                
                gamesGrid.innerHTML = filteredGames.map((game, index) => `
                    <div class="game-card focusable" data-game-id="${game.id}" tabindex="${index}">
                        <div class="game-icon">${game.icon}</div>
                        <h3 class="game-title">${game.name}</h3>
                        <p class="game-description">${game.description}</p>
                        <div class="game-meta">
                            <span class="game-size">${game.size}</span>
                            <button class="play-button" onclick="gameStore.launchGame('${game.id}')">
                                ${this.installedGames.includes(game.id) ? 'Play' : 'Install'}
                            </button>
                        </div>
                    </div>
                `).join('');
                
                // Add event listeners
                document.querySelectorAll('.game-card').forEach((card, index) => {
                    // Click/tap handling
                    card.addEventListener('click', (e) => {
                        if (!e.target.classList.contains('play-button')) {
                            const gameId = card.dataset.gameId;
                            const game = this.games.find(g => g.id === gameId);
                            this.showGameDetails(game);
                        }
                    });
                    
                    // Touch handling for iOS
                    if (this.isTouchDevice) {
                        let touchStartTime = 0;
                        let touchStartX = 0;
                        let touchStartY = 0;
                        
                        card.addEventListener('touchstart', (e) => {
                            touchStartTime = Date.now();
                            touchStartX = e.touches[0].clientX;
                            touchStartY = e.touches[0].clientY;
                            card.classList.add('touched');
                        }, { passive: true });
                        
                        card.addEventListener('touchend', (e) => {
                            const touchEndTime = Date.now();
                            const touchEndX = e.changedTouches[0].clientX;
                            const touchEndY = e.changedTouches[0].clientY;
                            
                            card.classList.remove('touched');
                            
                            // Check if it's a tap (not a swipe)
                            const distance = Math.sqrt(
                                Math.pow(touchEndX - touchStartX, 2) + 
                                Math.pow(touchEndY - touchStartY, 2)
                            );
                            
                            if (distance < 10 && touchEndTime - touchStartTime < 500) {
                                // It's a tap
                                if (touchEndTime - this.lastTapTime < 300) {
                                    // Double tap - show details
                                    e.preventDefault();
                                    const gameId = card.dataset.gameId;
                                    const game = this.games.find(g => g.id === gameId);
                                    this.showGameDetails(game);
                                }
                                this.lastTapTime = touchEndTime;
                            }
                        }, { passive: true });
                        
                        card.addEventListener('touchcancel', () => {
                            card.classList.remove('touched');
                        });
                    }
                    
                    // Mouse hover updates selection
                    card.addEventListener('mouseenter', () => {
                        if (this.inputMode === 'mouse') {
                            this.selectedIndex = index;
                            this.updateSelection();
                        }
                    });
                    
                    // Keyboard focus
                    card.addEventListener('focus', () => {
                        this.selectedIndex = index;
                        this.updateSelection();
                    });
                });
                
                // Update mouse position for hover effect
                if (!this.isTouchDevice) {
                    document.querySelectorAll('.game-card').forEach(card => {
                        card.addEventListener('mousemove', (e) => {
                            const rect = card.getBoundingClientRect();
                            const x = ((e.clientX - rect.left) / rect.width) * 100;
                            const y = ((e.clientY - rect.top) / rect.height) * 100;
                            card.style.setProperty('--mouse-x', `${x}%`);
                            card.style.setProperty('--mouse-y', `${y}%`);
                        });
                    });
                }
                
                // Prevent default touch behaviors on buttons
                document.querySelectorAll('.play-button').forEach(button => {
                    button.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        const gameId = button.closest('.game-card').dataset.gameId;
                        this.launchGame(gameId);
                    });
                });
                
                // Reset selection
                this.selectedIndex = 0;
                this.updateSelection();
            }

            getFilteredGames() {
                let filtered = this.games;
                
                // Filter by view
                if (this.currentView === 'library') {
                    filtered = filtered.filter(game => this.installedGames.includes(game.id));
                }
                
                // Filter by category
                if (this.currentCategory !== 'all') {
                    filtered = filtered.filter(game => game.category === this.currentCategory);
                }
                
                // Filter by search
                const searchTerm = document.getElementById('searchBox').value.toLowerCase();
                if (searchTerm) {
                    filtered = filtered.filter(game => 
                        game.name.toLowerCase().includes(searchTerm) ||
                        game.description.toLowerCase().includes(searchTerm)
                    );
                }
                
                return filtered;
            }

            filterGames(searchTerm) {
                this.renderGames();
            }

            switchView(view) {
                this.currentView = view;
                
                // Update nav buttons
                document.querySelectorAll('.nav-button').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.getElementById(`${view}Btn`).classList.add('active');
                
                // Update content
                if (view === 'settings') {
                    this.renderSettings();
                } else {
                    this.renderGames();
                }
            }

            renderSettings() {
                const content = document.getElementById('content');
                content.innerHTML = `
                    <div style="max-width: 600px; margin: 0 auto;">
                        <h2 style="margin-bottom: 30px;">Settings</h2>
                        <div style="background: rgba(26, 29, 35, 0.6); padding: 30px; border-radius: 15px;">
                            <h3 style="margin-bottom: 20px;">Gamepad Configuration</h3>
                            <p style="color: #8b8b8b; line-height: 1.6;">
                                ${this.gamepadConnected ? 
                                    '‚úÖ Gamepad is connected and ready to use' : 
                                    '‚ùå No gamepad detected. Please connect a gamepad.'}
                            </p>
                            <br>
                            <h3 style="margin-bottom: 20px;">About</h3>
                            <p style="color: #8b8b8b; line-height: 1.6;">
                                Steam Deck Game Store v1.0<br>
                                Games sourced from: ${REPO_CONFIG.owner}/${REPO_CONFIG.name}
                            </p>
                        </div>
                    </div>
                `;
            }

            showGameDetails(game) {
                const detailContent = document.getElementById('detailContent');
                detailContent.innerHTML = `
                    <div class="detail-header">
                        <div class="detail-icon">${game.icon}</div>
                        <div class="detail-info">
                            <h1 class="detail-title">${game.name}</h1>
                            <p class="detail-description">${game.description}</p>
                            <div class="game-meta">
                                <span>Category: ${game.category}</span>
                                <span>Size: ${game.size}</span>
                            </div>
                        </div>
                    </div>
                    <div class="detail-actions">
                        <button class="action-button primary" onclick="gameStore.launchGame('${game.id}')">
                            ${this.installedGames.includes(game.id) ? 'Play Now' : 'Install & Play'}
                        </button>
                        <button class="action-button secondary" onclick="gameStore.toggleFavorite('${game.id}')">
                            ${this.favorites.includes(game.id) ? '‚òÖ Favorited' : '‚òÜ Add to Favorites'}
                        </button>
                    </div>
                `;
                
                document.getElementById('gameDetail').classList.add('show');
            }

            launchGame(gameId) {
                const game = typeof gameId === 'string' ? 
                    this.games.find(g => g.id === gameId) : gameId;
                
                if (!game) return;
                
                // Add to installed games
                if (!this.installedGames.includes(game.id)) {
                    this.installedGames.push(game.id);
                    this.saveInstalledGames();
                }
                
                // Set current game
                this.currentGameId = game.id;
                
                // Show loading
                this.showToast(`Launching ${game.name}...`);
                
                // Open game in emulator iframe
                const emulatorFrame = document.getElementById('emulatorFrame');
                emulatorFrame.src = game.url;
                document.getElementById('emulatorContainer').classList.add('show');
                
                // Close any open modals
                document.getElementById('gameDetail').classList.remove('show');
                
                // Set up communication with game iframe
                this.setupGameCommunication();
            }

            closeEmulator() {
                // Try to save current state before closing
                this.requestGameState('auto-save');
                
                const emulatorFrame = document.getElementById('emulatorFrame');
                emulatorFrame.src = '';
                document.getElementById('emulatorContainer').classList.remove('show');
                this.currentGameId = null;
            }

            setupGameCommunication() {
                // Give the game time to load
                setTimeout(() => {
                    // Check if game supports save states
                    this.sendMessageToGame({ type: 'CHECK_SAVE_SUPPORT' });
                }, 2000);
            }

            sendMessageToGame(message) {
                const iframe = document.getElementById('emulatorFrame');
                if (iframe && iframe.contentWindow) {
                    iframe.contentWindow.postMessage(message, '*');
                }
            }

            requestGameState(slotName = 'manual-save') {
                this.pendingSaveSlot = slotName;
                this.sendMessageToGame({ type: 'REQUEST_GAME_STATE' });
            }

            handleGameStateResponse(state) {
                if (!state || !this.currentGameId) return;
                
                const saveData = {
                    gameId: this.currentGameId,
                    gameName: this.games.find(g => g.id === this.currentGameId)?.name || 'Unknown Game',
                    timestamp: new Date().toISOString(),
                    state: state
                };
                
                // Save to specified slot
                this.saveSaveState(this.pendingSaveSlot || 'manual-save', saveData);
                this.showToast('Game saved successfully!');
                
                // If we're in save modal, refresh it
                if (document.getElementById('saveModal').classList.contains('show')) {
                    this.showSaveModal();
                }
            }

            showSaveModal() {
                const modal = document.getElementById('saveModal');
                const content = document.getElementById('saveModalContent');
                
                // Get saves for current game
                const gameSaves = this.saveStates[this.currentGameId] || {};
                const slots = ['slot-1', 'slot-2', 'slot-3', 'quick-save', 'auto-save'];
                
                content.innerHTML = slots.map(slot => {
                    const save = gameSaves[slot];
                    if (save) {
                        const date = new Date(save.timestamp);
                        return `
                            <div class="save-slot" data-slot="${slot}">
                                <div class="save-info">
                                    <div class="save-name">${this.getSlotName(slot)}</div>
                                    <div class="save-date">${date.toLocaleDateString()} ${date.toLocaleTimeString()}</div>
                                </div>
                                <div class="save-actions">
                                    <button class="save-action-btn" onclick="gameStore.saveToSlot('${slot}')">Overwrite</button>
                                    <button class="save-action-btn" onclick="gameStore.exportSave('${slot}')">Export</button>
                                    <button class="save-action-btn delete" onclick="gameStore.deleteSave('${slot}')">Delete</button>
                                </div>
                            </div>
                        `;
                    } else {
                        return `
                            <div class="save-slot empty" data-slot="${slot}" onclick="gameStore.saveToSlot('${slot}')">
                                <div class="save-info">
                                    <div class="save-name">${this.getSlotName(slot)}</div>
                                    <div class="save-date">Empty slot</div>
                                </div>
                            </div>
                        `;
                    }
                }).join('');
                
                modal.classList.add('show');
            }

            showLoadModal() {
                const modal = document.getElementById('loadModal');
                const slotsDiv = document.getElementById('loadModalSlots');
                
                // Show existing saves for current game
                const gameSaves = this.saveStates[this.currentGameId] || {};
                const hasSaves = Object.keys(gameSaves).length > 0;
                
                if (hasSaves) {
                    slotsDiv.innerHTML = '<h4 style="margin: 20px 0 10px;">Or load from existing saves:</h4>';
                    Object.entries(gameSaves).forEach(([slot, save]) => {
                        const date = new Date(save.timestamp);
                        const slotDiv = document.createElement('div');
                        slotDiv.className = 'save-slot';
                        slotDiv.innerHTML = `
                            <div class="save-info">
                                <div class="save-name">${this.getSlotName(slot)}</div>
                                <div class="save-date">${date.toLocaleDateString()} ${date.toLocaleTimeString()}</div>
                            </div>
                        `;
                        slotDiv.onclick = () => this.loadFromSlot(slot);
                        slotsDiv.appendChild(slotDiv);
                    });
                } else {
                    slotsDiv.innerHTML = '<p style="color: #666; margin-top: 20px;">No existing saves for this game.</p>';
                }
                
                modal.classList.add('show');
            }

            getSlotName(slot) {
                const names = {
                    'slot-1': 'Save Slot 1',
                    'slot-2': 'Save Slot 2',
                    'slot-3': 'Save Slot 3',
                    'quick-save': 'Quick Save',
                    'auto-save': 'Auto Save'
                };
                return names[slot] || slot;
            }

            saveToSlot(slot) {
                this.requestGameState(slot);
            }

            saveSaveState(slot, saveData) {
                if (!this.saveStates[this.currentGameId]) {
                    this.saveStates[this.currentGameId] = {};
                }
                this.saveStates[this.currentGameId][slot] = saveData;
                this.saveSaveStates();
            }

            loadFromSlot(slot) {
                const save = this.saveStates[this.currentGameId]?.[slot];
                if (save) {
                    this.sendMessageToGame({ 
                        type: 'LOAD_GAME_STATE', 
                        state: save.state 
                    });
                    document.getElementById('loadModal').classList.remove('show');
                    this.showToast('Game loaded successfully!');
                }
            }

            exportSave(slot) {
                const save = this.saveStates[this.currentGameId]?.[slot];
                if (!save) return;
                
                const exportData = {
                    version: '1.0',
                    game: save.gameName,
                    gameId: save.gameId,
                    slot: slot,
                    timestamp: save.timestamp,
                    state: save.state
                };
                
                const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${save.gameName}-${slot}-${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                this.showToast('Save exported successfully!');
            }

            exportAllSaves() {
                const allSaves = {};
                Object.entries(this.saveStates).forEach(([gameId, saves]) => {
                    const game = this.games.find(g => g.id === gameId);
                    if (game) {
                        allSaves[gameId] = {
                            gameName: game.name,
                            saves: saves
                        };
                    }
                });
                
                const exportData = {
                    version: '1.0',
                    exportDate: new Date().toISOString(),
                    saves: allSaves
                };
                
                const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `steam-deck-saves-${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                this.showToast('All saves exported successfully!');
                document.getElementById('saveModal').classList.remove('show');
            }

            deleteSave(slot) {
                if (confirm('Are you sure you want to delete this save?')) {
                    if (this.saveStates[this.currentGameId]) {
                        delete this.saveStates[this.currentGameId][slot];
                        this.saveSaveStates();
                        this.showSaveModal(); // Refresh modal
                        this.showToast('Save deleted');
                    }
                }
            }

            handleLoadFile(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        
                        // Check if it's a single save or bulk export
                        if (data.saves) {
                            // Bulk import
                            Object.entries(data.saves).forEach(([gameId, gameData]) => {
                                if (!this.saveStates[gameId]) {
                                    this.saveStates[gameId] = {};
                                }
                                Object.assign(this.saveStates[gameId], gameData.saves);
                            });
                            this.saveSaveStates();
                            this.showToast('All saves imported successfully!');
                            document.getElementById('loadModal').classList.remove('show');
                        } else if (data.state && data.gameId) {
                            // Single save
                            if (data.gameId !== this.currentGameId) {
                                this.showToast('This save is for a different game!');
                                return;
                            }
                            
                            // Load the state
                            this.sendMessageToGame({ 
                                type: 'LOAD_GAME_STATE', 
                                state: data.state 
                            });
                            
                            // Optionally save it to a slot
                            const slot = data.slot || 'imported-save';
                            this.saveSaveState(slot, {
                                gameId: data.gameId,
                                gameName: data.game,
                                timestamp: data.timestamp,
                                state: data.state
                            });
                            
                            document.getElementById('loadModal').classList.remove('show');
                            this.showToast('Save loaded successfully!');
                        } else {
                            throw new Error('Invalid save file format');
                        }
                    } catch (error) {
                        console.error('Error loading save file:', error);
                        this.showToast('Failed to load save file');
                    }
                };
                reader.readAsText(file);
                
                // Reset file input
                event.target.value = '';
            }

            toggleFavorite(gameId) {
                const index = this.favorites.indexOf(gameId);
                if (index > -1) {
                    this.favorites.splice(index, 1);
                    this.showToast('Removed from favorites');
                } else {
                    this.favorites.push(gameId);
                    this.showToast('Added to favorites');
                }
                this.saveFavorites();
                
                // Update UI if details are open
                const game = this.games.find(g => g.id === gameId);
                if (game && document.getElementById('gameDetail').classList.contains('show')) {
                    this.showGameDetails(game);
                }
            }

            showToast(message) {
                const toast = document.getElementById('toast');
                toast.textContent = message;
                toast.classList.add('show');
                
                setTimeout(() => {
                    toast.classList.remove('show');
                }, 3000);
            }

            // Local storage methods
            loadFavorites() {
                const saved = localStorage.getItem('steamDeckFavorites');
                return saved ? JSON.parse(saved) : [];
            }

            saveFavorites() {
                localStorage.setItem('steamDeckFavorites', JSON.stringify(this.favorites));
            }

            loadInstalledGames() {
                const saved = localStorage.getItem('steamDeckInstalled');
                return saved ? JSON.parse(saved) : [];
            }

            saveInstalledGames() {
                localStorage.setItem('steamDeckInstalled', JSON.stringify(this.installedGames));
            }

            loadSaveStates() {
                const saved = localStorage.getItem('steamDeckSaveStates');
                return saved ? JSON.parse(saved) : {};
            }

            saveSaveStates() {
                localStorage.setItem('steamDeckSaveStates', JSON.stringify(this.saveStates));
            }
        }

        // Game State Communication Protocol
        // Games need to implement this to support save states
        const GAME_STATE_PROTOCOL = `
            // Add this to your game to support save states:
            
            window.addEventListener('message', (event) => {
                if (event.data.type === 'REQUEST_GAME_STATE') {
                    // Collect your game state
                    const gameState = {
                        // Example for a snake game:
                        snake: snake.segments,
                        food: food.position,
                        score: game.score,
                        level: game.level,
                        // Add all necessary game data
                    };
                    
                    // Send state back to parent
                    window.parent.postMessage({
                        type: 'GAME_STATE_RESPONSE',
                        state: gameState
                    }, '*');
                }
                
                if (event.data.type === 'LOAD_GAME_STATE') {
                    const state = event.data.state;
                    // Restore your game state
                    // Example:
                    snake.segments = state.snake;
                    food.position = state.food;
                    game.score = state.score;
                    game.level = state.level;
                    // Update display
                    render();
                }
                
                if (event.data.type === 'CHECK_SAVE_SUPPORT') {
                    window.parent.postMessage({
                        type: 'SAVE_SUPPORT_RESPONSE',
                        supported: true
                    }, '*');
                }
            });
        `;

        // Initialize the game store
        let gameStore;
        document.addEventListener('DOMContentLoaded', () => {
            gameStore = new SteamDeckGameStore();
        });
    </script>
</body>
</html>