{
  "id": "breakout-game",
  "name": "Breakout",
  "description": "Classic brick-breaking arcade game",
  "icon": "ðŸ§±",
  "gameData": {
    "paddleWidth": 50,
    "paddleHeight": 10,
    "ballRadius": 5,
    "brickRowCount": 5,
    "brickColumnCount": 8,
    "brickWidth": 30,
    "brickHeight": 15,
    "brickPadding": 5,
    "brickOffsetTop": 40,
    "brickOffsetLeft": 15,
    "initialLives": 3,
    "initialSpeed": 3,
    "speedIncrement": 0.25,
    "maxSpeed": 8,
    "paddleSpeed": 6,
    "colors": {
      "background": "#000000",
      "paddle": "#AAAAFF",
      "ball": "#FFFFFF",
      "brickColors": ["#FF0000", "#FF7F00", "#FFFF00", "#00FF00", "#0000FF"],
      "text": "#FFFFFF"
    }
  },
  "initializeCode": "function(display) {\n  this.display = display;\n  this.canvas = document.createElement('canvas');\n  this.canvas.width = 280;\n  this.canvas.height = 248;\n  display.appendChild(this.canvas);\n  this.ctx = this.canvas.getContext('2d');\n  \n  this.resetGame();\n  \n  // Variables for handling smooth paddle movement\n  this.leftPressed = false;\n  this.rightPressed = false;\n  \n  // Animation frame tracking\n  this.lastFrameTime = Date.now();\n  \n  this.render();\n}",
  "handleInputCode": "function(button, isPressed) {\n  if (this.gameOver) {\n    if (isPressed && button === 'a') {\n      this.resetGame();\n    }\n    return;\n  }\n  \n  if (this.levelCompleted) {\n    if (isPressed && button === 'a') {\n      this.startNextLevel();\n    }\n    return;\n  }\n  \n  if (this.paused) {\n    if (isPressed && button === 'b') {\n      this.paused = false;\n    }\n    return;\n  }\n  \n  if (isPressed && button === 'b') {\n    this.paused = true;\n    return;\n  }\n  \n  if (button === 'left') {\n    this.leftPressed = isPressed;\n  }\n  else if (button === 'right') {\n    this.rightPressed = isPressed;\n  }\n  else if (isPressed && button === 'a' && !this.ballReleased) {\n    this.ballReleased = true;\n    this.ballDX = this.currentSpeed * (Math.random() - 0.5);\n    this.ballDY = -this.currentSpeed; // Start moving up\n  }\n}",
  "updateCode": "function(deltaTime) {\n  if (this.gameOver || this.levelCompleted || this.paused) {\n    return;\n  }\n  \n  const now = Date.now();\n  const dt = (now - this.lastFrameTime) / 16.67; // Normalize to ~60fps\n  this.lastFrameTime = now;\n  \n  // Move paddle based on input\n  if (this.rightPressed && this.paddleX < this.canvas.width - this.gameData.paddleWidth) {\n    this.paddleX += this.gameData.paddleSpeed * dt;\n  }\n  else if (this.leftPressed && this.paddleX > 0) {\n    this.paddleX -= this.gameData.paddleSpeed * dt;\n  }\n  \n  // If ball is not released, stick to paddle\n  if (!this.ballReleased) {\n    this.ballX = this.paddleX + this.gameData.paddleWidth / 2;\n    this.ballY = this.canvas.height - this.gameData.paddleHeight - this.gameData.ballRadius - 2;\n    return;\n  }\n  \n  // Move ball\n  this.ballX += this.ballDX * dt;\n  this.ballY += this.ballDY * dt;\n  \n  // Ball and wall collisions\n  this.checkWallCollisions();\n  \n  // Paddle collision\n  this.checkPaddleCollision();\n  \n  // Brick collision\n  this.checkBrickCollisions();\n  \n  // Check if ball is below the paddle (lose life)\n  if (this.ballY > this.canvas.height + this.gameData.ballRadius) {\n    this.lives--;\n    \n    if (this.lives <= 0) {\n      this.gameOver = true;\n    } else {\n      this.resetBall();\n    }\n  }\n  \n  // Check if all bricks are cleared\n  if (this.bricksRemaining === 0) {\n    this.levelCompleted = true;\n    this.level++;\n  }\n}",
  "renderCode": "function() {\n  // Clear canvas\n  this.ctx.fillStyle = this.gameData.colors.background;\n  this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n  \n  // Draw bricks\n  this.drawBricks();\n  \n  // Draw paddle\n  this.ctx.fillStyle = this.gameData.colors.paddle;\n  this.ctx.fillRect(this.paddleX, this.canvas.height - this.gameData.paddleHeight, this.gameData.paddleWidth, this.gameData.paddleHeight);\n  \n  // Draw ball\n  this.ctx.fillStyle = this.gameData.colors.ball;\n  this.ctx.beginPath();\n  this.ctx.arc(this.ballX, this.ballY, this.gameData.ballRadius, 0, Math.PI * 2);\n  this.ctx.fill();\n  \n  // Draw UI\n  this.drawUI();\n  \n  // Draw pause overlay\n  if (this.paused) {\n    this.drawPauseScreen();\n  }\n  \n  // Draw level completion screen\n  if (this.levelCompleted) {\n    this.drawLevelCompletedScreen();\n  }\n  \n  // Draw game over screen\n  if (this.gameOver) {\n    this.drawGameOverScreen();\n  }\n}",
  "cleanupCode": "function() {\n  if (this.canvas && this.canvas.parentNode) {\n    this.canvas.parentNode.removeChild(this.canvas);\n  }\n}",
  "additionalFunctions": {
    "resetGame": "function() {\n  // Reset game state\n  this.score = 0;\n  this.level = 1;\n  this.lives = this.gameData.initialLives;\n  this.currentSpeed = this.gameData.initialSpeed;\n  this.gameOver = false;\n  this.paused = false;\n  this.levelCompleted = false;\n  \n  // Initialize paddle position\n  this.paddleX = (this.canvas.width - this.gameData.paddleWidth) / 2;\n  \n  // Initialize ball\n  this.resetBall();\n  \n  // Initialize bricks\n  this.initBricks();\n}",
    "resetBall": "function() {\n  this.ballX = this.paddleX + this.gameData.paddleWidth / 2;\n  this.ballY = this.canvas.height - this.gameData.paddleHeight - this.gameData.ballRadius - 2;\n  this.ballDX = 0;\n  this.ballDY = 0;\n  this.ballReleased = false;\n}",
    "initBricks": "function() {\n  this.bricks = [];\n  this.bricksRemaining = 0;\n  \n  for (let c = 0; c < this.gameData.brickColumnCount; c++) {\n    this.bricks[c] = [];\n    for (let r = 0; r < this.gameData.brickRowCount; r++) {\n      // Determine the number of hits required for this brick\n      let hits = 1;\n      if (this.level > 1) {\n        // Add some stronger bricks in higher levels\n        if (r === 0 && this.level > 3) hits = 3;\n        else if (r < 2 && this.level > 2) hits = 2;\n      }\n      \n      this.bricks[c][r] = { \n        x: 0, \n        y: 0, \n        status: hits, // status: 0 = broken, 1+ = number of hits required\n        color: this.gameData.colors.brickColors[r % this.gameData.colors.brickColors.length]\n      };\n      \n      if (hits > 0) {\n        this.bricksRemaining++;\n      }\n    }\n  }\n}",
    "drawBricks": "function() {\n  for (let c = 0; c < this.gameData.brickColumnCount; c++) {\n    for (let r = 0; r < this.gameData.brickRowCount; r++) {\n      const brick = this.bricks[c][r];\n      if (brick.status > 0) {\n        const brickX = c * (this.gameData.brickWidth + this.gameData.brickPadding) + this.gameData.brickOffsetLeft;\n        const brickY = r * (this.gameData.brickHeight + this.gameData.brickPadding) + this.gameData.brickOffsetTop;\n        brick.x = brickX;\n        brick.y = brickY;\n        \n        // Determine color based on brick health\n        let color = brick.color;\n        if (brick.status > 1) {\n          // Darker shade for stronger bricks\n          const darkenFactor = 0.6 / brick.status;\n          color = this.darkenColor(color, darkenFactor);\n        }\n        \n        this.ctx.fillStyle = color;\n        this.ctx.fillRect(brickX, brickY, this.gameData.brickWidth, this.gameData.brickHeight);\n        \n        // Draw brick border\n        this.ctx.strokeStyle = this.gameData.colors.background;\n        this.ctx.lineWidth = 1;\n        this.ctx.strokeRect(brickX, brickY, this.gameData.brickWidth, this.gameData.brickHeight);\n      }\n    }\n  }\n}",
    "darkenColor": "function(color, factor) {\n  // Simple utility to darken a hex color\n  const r = parseInt(color.substr(1, 2), 16);\n  const g = parseInt(color.substr(3, 2), 16);\n  const b = parseInt(color.substr(5, 2), 16);\n  \n  const newR = Math.floor(r * factor);\n  const newG = Math.floor(g * factor);\n  const newB = Math.floor(b * factor);\n  \n  return `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;\n}",
    "checkWallCollisions": "function() {\n  // Left and right walls\n  if (this.ballX - this.gameData.ballRadius < 0 || \n      this.ballX + this.gameData.ballRadius > this.canvas.width) {\n    this.ballDX = -this.ballDX;\n    // Adjust position to prevent sticking to the wall\n    if (this.ballX - this.gameData.ballRadius < 0) {\n      this.ballX = this.gameData.ballRadius;\n    } else {\n      this.ballX = this.canvas.width - this.gameData.ballRadius;\n    }\n  }\n  \n  // Top wall\n  if (this.ballY - this.gameData.ballRadius < 0) {\n    this.ballDY = -this.ballDY;\n    this.ballY = this.gameData.ballRadius; // Adjust to prevent sticking\n  }\n}",
    "checkPaddleCollision": "function() {\n  if (this.ballY + this.gameData.ballRadius > this.canvas.height - this.gameData.paddleHeight && \n      this.ballX > this.paddleX && \n      this.ballX < this.paddleX + this.gameData.paddleWidth) {\n    \n    // Calculate bounce angle based on where the ball hit the paddle\n    const hitPos = (this.ballX - this.paddleX) / this.gameData.paddleWidth;\n    const angleRange = Math.PI / 3; // 60 degrees\n    const bounceAngle = angleRange * (hitPos - 0.5);\n    \n    // Set new velocity based on the bounce angle\n    const speed = Math.sqrt(this.ballDX * this.ballDX + this.ballDY * this.ballDY);\n    this.ballDX = speed * Math.sin(bounceAngle);\n    this.ballDY = -speed * Math.cos(bounceAngle);\n    \n    // Prevent ball from being trapped in the paddle\n    this.ballY = this.canvas.height - this.gameData.paddleHeight - this.gameData.ballRadius - 1;\n  }\n}",
    "checkBrickCollisions": "function() {\n  for (let c = 0; c < this.gameData.brickColumnCount; c++) {\n    for (let r = 0; r < this.gameData.brickRowCount; r++) {\n      const brick = this.bricks[c][r];\n      if (brick.status > 0) {\n        // Check if ball collides with this brick\n        if (this.ballX > brick.x && \n            this.ballX < brick.x + this.gameData.brickWidth && \n            this.ballY > brick.y && \n            this.ballY < brick.y + this.gameData.brickHeight) {\n          \n          // Determine which side of the brick was hit\n          const ballCenterX = this.ballX;\n          const ballCenterY = this.ballY;\n          const brickCenterX = brick.x + this.gameData.brickWidth / 2;\n          const brickCenterY = brick.y + this.gameData.brickHeight / 2;\n          \n          const dx = ballCenterX - brickCenterX;\n          const dy = ballCenterY - brickCenterY;\n          \n          // Check if hit is more horizontal or vertical\n          if (Math.abs(dx / this.gameData.brickWidth) > Math.abs(dy / this.gameData.brickHeight)) {\n            this.ballDX = -this.ballDX; // Left/right collision\n          } else {\n            this.ballDY = -this.ballDY; // Top/bottom collision\n          }\n          \n          // Reduce brick health or break it\n          brick.status--;\n          if (brick.status <= 0) {\n            this.bricksRemaining--;\n            this.score += 10 * this.level; // More points for higher levels\n          } else {\n            this.score += 1; // Small points for hitting but not breaking\n          }\n          \n          // Only process one brick hit per frame\n          return;\n        }\n      }\n    }\n  }\n}",
    "drawUI": "function() {\n  // Draw score, level, and lives\n  this.ctx.fillStyle = this.gameData.colors.text;\n  this.ctx.font = '10px \"Press Start 2P\"';\n  this.ctx.textAlign = 'left';\n  this.ctx.fillText(`SCORE: ${this.score}`, 10, 20);\n  \n  this.ctx.textAlign = 'center';\n  this.ctx.fillText(`LEVEL: ${this.level}`, this.canvas.width / 2, 20);\n  \n  this.ctx.textAlign = 'right';\n  this.ctx.fillText(`LIVES: ${this.lives}`, this.canvas.width - 10, 20);\n  \n  // Draw instructions if ball is not released\n  if (!this.ballReleased && !this.gameOver && !this.levelCompleted) {\n    this.ctx.textAlign = 'center';\n    this.ctx.font = '8px \"Press Start 2P\"';\n    this.ctx.fillText('PRESS A TO LAUNCH', this.canvas.width / 2, this.canvas.height - 40);\n  }\n}",
    "drawPauseScreen": "function() {\n  // Semi-transparent overlay\n  this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\n  this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n  \n  // Pause text\n  this.ctx.fillStyle = this.gameData.colors.text;\n  this.ctx.font = '16px \"Press Start 2P\"';\n  this.ctx.textAlign = 'center';\n  this.ctx.textBaseline = 'middle';\n  this.ctx.fillText('PAUSED', this.canvas.width / 2, this.canvas.height / 2);\n  \n  this.ctx.font = '8px \"Press Start 2P\"';\n  this.ctx.fillText('PRESS B TO RESUME', this.canvas.width / 2, this.canvas.height / 2 + 30);\n}",
    "drawLevelCompletedScreen": "function() {\n  // Semi-transparent overlay\n  this.ctx.fillStyle = 'rgba(0, 0, 100, 0.7)';\n  this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n  \n  // Level completed text\n  this.ctx.fillStyle = this.gameData.colors.text;\n  this.ctx.font = '14px \"Press Start 2P\"';\n  this.ctx.textAlign = 'center';\n  this.ctx.textBaseline = 'middle';\n  this.ctx.fillText('LEVEL COMPLETE!', this.canvas.width / 2, this.canvas.height / 2 - 20);\n  \n  this.ctx.font = '10px \"Press Start 2P\"';\n  this.ctx.fillText(`SCORE: ${this.score}`, this.canvas.width / 2, this.canvas.height / 2 + 10);\n  \n  this.ctx.font = '8px \"Press Start 2P\"';\n  this.ctx.fillText('PRESS A TO CONTINUE', this.canvas.width / 2, this.canvas.height / 2 + 40);\n}",
    "drawGameOverScreen": "function() {\n  // Semi-transparent overlay\n  this.ctx.fillStyle = 'rgba(100, 0, 0, 0.7)';\n  this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n  \n  // Game over text\n  this.ctx.fillStyle = this.gameData.colors.text;\n  this.ctx.font = '16px \"Press Start 2P\"';\n  this.ctx.textAlign = 'center';\n  this.ctx.textBaseline = 'middle';\n  this.ctx.fillText('GAME OVER', this.canvas.width / 2, this.canvas.height / 2 - 20);\n  \n  this.ctx.font = '10px \"Press Start 2P\"';\n  this.ctx.fillText(`FINAL SCORE: ${this.score}`, this.canvas.width / 2, this.canvas.height / 2 + 10);\n  \n  this.ctx.font = '8px \"Press Start 2P\"';\n  this.ctx.fillText('PRESS A TO RESTART', this.canvas.width / 2, this.canvas.height / 2 + 40);\n}",
    "startNextLevel": "function() {\n  this.levelCompleted = false;\n  \n  // Reset ball and paddle\n  this.resetBall();\n  this.paddleX = (this.canvas.width - this.gameData.paddleWidth) / 2;\n  \n  // Initialize bricks for the next level\n  this.initBricks();\n  \n  // Increase ball speed (up to max)\n  this.currentSpeed = Math.min(\n    this.gameData.initialSpeed + (this.level - 1) * this.gameData.speedIncrement,\n    this.gameData.maxSpeed\n  );\n}"
  }
}