<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <title>Holographic Camera Recorder</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #000;
      color: #fff;
      overflow: hidden;
      position: relative;
    }
    
    /* Three.js Canvas */
    #hologramCanvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }
    
    /* UI Overlay */
    .ui-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 10;
      pointer-events: none;
    }
    
    .ui-overlay > * {
      pointer-events: auto;
    }
    
    /* Header */
    .header {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      background: rgba(0, 0, 0, 0.8);
      padding: 15px 30px;
      border-radius: 12px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    h1 {
      font-size: 2em;
      margin-bottom: 5px;
      background: linear-gradient(45deg, #00ffff, #ff00ff);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    .subtitle {
      color: #888;
      font-size: 14px;
    }
    
    /* Hidden video elements for camera feeds */
    #frontCamera, #backCamera {
      position: absolute;
      top: -9999px;
      visibility: hidden;
    }
    
    /* Controls */
    .controls {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      border-radius: 12px;
      padding: 20px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      min-width: 300px;
      text-align: center;
    }
    
    .control-buttons {
      display: flex;
      gap: 10px;
      justify-content: center;
      margin-bottom: 15px;
      flex-wrap: wrap;
    }
    
    .btn {
      padding: 10px 20px;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s;
      display: flex;
      align-items: center;
      gap: 6px;
      background: rgba(255, 255, 255, 0.1);
      color: white;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    
    .btn:hover:not(:disabled) {
      background: rgba(255, 255, 255, 0.2);
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(0, 255, 255, 0.3);
    }
    
    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .btn-primary {
      background: linear-gradient(45deg, #ff0066, #ff3366);
      border: none;
    }
    
    .btn-primary:hover:not(:disabled) {
      background: linear-gradient(45deg, #ff3366, #ff6666);
      box-shadow: 0 5px 15px rgba(255, 0, 102, 0.5);
    }
    
    .btn-success {
      background: linear-gradient(45deg, #00ff88, #00ffcc);
      color: #000;
      border: none;
    }
    
    .btn-success:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(0, 255, 136, 0.5);
    }
    
    /* Status */
    .status {
      color: #888;
      font-size: 14px;
      margin-bottom: 10px;
    }
    
    .status.recording {
      color: #ff0066;
      font-weight: bold;
    }
    
    /* Recording indicator */
    .recording-dot {
      display: inline-block;
      width: 10px;
      height: 10px;
      background: #ff0066;
      border-radius: 50%;
      margin-right: 6px;
      animation: pulse 1.5s infinite;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.3; }
    }
    
    /* Effect Controls */
    .effect-controls {
      position: absolute;
      top: 100px;
      right: 20px;
      background: rgba(0, 0, 0, 0.8);
      border-radius: 12px;
      padding: 20px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .effect-title {
      font-size: 16px;
      margin-bottom: 15px;
      color: #00ffff;
    }
    
    .effect-slider {
      margin-bottom: 15px;
    }
    
    .effect-slider label {
      display: block;
      margin-bottom: 5px;
      font-size: 12px;
      color: #888;
    }
    
    .effect-slider input[type="range"] {
      width: 100%;
      height: 5px;
      background: rgba(255, 255, 255, 0.1);
      outline: none;
      -webkit-appearance: none;
      border-radius: 5px;
    }
    
    .effect-slider input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 15px;
      height: 15px;
      background: #00ffff;
      border-radius: 50%;
      cursor: pointer;
    }
    
    .effect-checkbox {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
      cursor: pointer;
    }
    
    .effect-checkbox input {
      margin-right: 8px;
    }
    
    .effect-checkbox label {
      font-size: 12px;
      color: #888;
      cursor: pointer;
    }
    
    /* Results */
    .results-section {
      display: none;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.9);
      border-radius: 12px;
      padding: 30px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      text-align: center;
      max-width: 600px;
      width: 90%;
    }
    
    .result-videos {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin: 20px 0;
    }
    
    .result-video {
      width: 100%;
      border-radius: 8px;
      max-height: 200px;
    }
    
    /* Mobile adjustments */
    @media (max-width: 768px) {
      .effect-controls {
        top: auto;
        bottom: 150px;
        right: 10px;
        left: 10px;
        max-width: 300px;
        margin: 0 auto;
      }
      
      .result-videos {
        grid-template-columns: 1fr;
      }
      
      h1 {
        font-size: 1.5em;
      }
    }
  </style>
</head>
<body>
  <!-- Hidden video elements for camera streams -->
  <video id="frontCamera" autoplay muted playsinline></video>
  <video id="backCamera" autoplay muted playsinline></video>
  
  <!-- Three.js Canvas -->
  <canvas id="hologramCanvas"></canvas>
  
  <!-- UI Overlay -->
  <div class="ui-overlay">
    <!-- Header -->
    <div class="header">
      <h1>Holographic Recorder</h1>
      <div class="subtitle">3D Visualization using Dual Cameras</div>
    </div>
    
    <!-- Effect Controls -->
    <div class="effect-controls">
      <div class="effect-title">Hologram Effects</div>
      
      <div class="effect-slider">
        <label>Depth Separation: <span id="depthValue">0.5</span></label>
        <input type="range" id="depthSlider" min="0" max="2" value="0.5" step="0.1">
      </div>
      
      <div class="effect-slider">
        <label>Rotation Speed: <span id="rotationValue">1</span></label>
        <input type="range" id="rotationSlider" min="0" max="3" value="1" step="0.1">
      </div>
      
      <div class="effect-slider">
        <label>Glow Intensity: <span id="glowValue">1</span></label>
        <input type="range" id="glowSlider" min="0" max="2" value="1" step="0.1">
      </div>
      
      <div class="effect-checkbox">
        <input type="checkbox" id="particlesToggle" checked>
        <label for="particlesToggle">Particle Effects</label>
      </div>
      
      <div class="effect-checkbox">
        <input type="checkbox" id="scanlineToggle" checked>
        <label for="scanlineToggle">Scanlines</label>
      </div>
      
      <div class="effect-checkbox">
        <input type="checkbox" id="wireframeToggle">
        <label for="wireframeToggle">Wireframe Mode</label>
      </div>
    </div>
    
    <!-- Controls -->
    <div class="controls">
      <div class="control-buttons">
        <button class="btn" onclick="setupCameras()">
          üìπ Setup Cameras
        </button>
        <button class="btn btn-primary" id="recordBtn" onclick="startRecording()" disabled>
          üî¥ Start Recording
        </button>
        <button class="btn" id="stopBtn" onclick="stopRecording()" disabled>
          ‚èπÔ∏è Stop Recording
        </button>
      </div>
      <div class="status" id="status">Click "Setup Cameras" to begin</div>
    </div>
    
    <!-- Results -->
    <div class="results-section" id="resultsSection">
      <h2>‚úÖ Recording Complete!</h2>
      <div class="result-videos">
        <div>
          <h3>Front Camera</h3>
          <video id="resultFront" class="result-video" controls></video>
        </div>
        <div>
          <h3>Back Camera</h3>
          <video id="resultBack" class="result-video" controls></video>
        </div>
      </div>
      <div class="control-buttons" style="margin-top: 20px;">
        <a id="downloadFront" download="front-hologram.webm" style="text-decoration: none;">
          <button class="btn btn-success">
            üíæ Download Front
          </button>
        </a>
        <a id="downloadBack" download="back-hologram.webm" style="text-decoration: none;">
          <button class="btn btn-success">
            üíæ Download Back
          </button>
        </a>
        <button class="btn" onclick="resetApp()">
          üîÑ Record Again
        </button>
      </div>
    </div>
  </div>
  
  <!-- Three.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  
  <script>
    // Global variables for camera recording
    let frontStream = null;
    let backStream = null;
    let frontRecorder = null;
    let backRecorder = null;
    let frontChunks = [];
    let backChunks = [];
    let isRecording = false;
    
    // Three.js variables
    let scene, camera, renderer;
    let frontTexture, backTexture;
    let hologramGroup;
    let particles;
    let scanlinesMaterial;
    let time = 0;
    
    // Effect parameters
    let depthSeparation = 0.5;
    let rotationSpeed = 1;
    let glowIntensity = 1;
    let particlesEnabled = true;
    let scanlinesEnabled = true;
    let wireframeMode = false;
    
    // Initialize Three.js scene
    function initThreeJS() {
      // Scene setup
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);
      
      // Camera setup
      camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.z = 5;
      
      // Renderer setup
      renderer = new THREE.WebGLRenderer({
        canvas: document.getElementById('hologramCanvas'),
        antialias: true,
        alpha: true
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      
      // Lighting
      const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
      scene.add(ambientLight);
      
      const pointLight1 = new THREE.PointLight(0x00ffff, 1, 100);
      pointLight1.position.set(5, 5, 5);
      scene.add(pointLight1);
      
      const pointLight2 = new THREE.PointLight(0xff00ff, 1, 100);
      pointLight2.position.set(-5, -5, 5);
      scene.add(pointLight2);
      
      // Create hologram group
      hologramGroup = new THREE.Group();
      scene.add(hologramGroup);
      
      // Create particle system
      createParticleSystem();
      
      // Add scanlines overlay
      createScanlines();
      
      // Start animation
      animate();
    }
    
    // Create the hologram geometry
    function createHologram() {
      // Clear existing hologram
      while(hologramGroup.children.length > 0) {
        hologramGroup.remove(hologramGroup.children[0]);
      }
      
      if (!frontTexture || !backTexture) return;
      
      // Create geometry
      const geometry = new THREE.PlaneGeometry(4, 3, 32, 32);
      
      // Create materials for front and back
      const frontMaterial = new THREE.MeshPhongMaterial({
        map: frontTexture,
        transparent: true,
        opacity: 0.8,
        emissive: new THREE.Color(0x00ffff),
        emissiveIntensity: glowIntensity * 0.3,
        side: THREE.DoubleSide,
        wireframe: wireframeMode
      });
      
      const backMaterial = new THREE.MeshPhongMaterial({
        map: backTexture,
        transparent: true,
        opacity: 0.8,
        emissive: new THREE.Color(0xff00ff),
        emissiveIntensity: glowIntensity * 0.3,
        side: THREE.DoubleSide,
        wireframe: wireframeMode
      });
      
      // Create meshes
      const frontMesh = new THREE.Mesh(geometry, frontMaterial);
      const backMesh = new THREE.Mesh(geometry, backMaterial);
      
      // Position meshes with depth separation
      frontMesh.position.z = depthSeparation;
      backMesh.position.z = -depthSeparation;
      
      // Add edge glow effect
      const edgeGeometry = new THREE.EdgesGeometry(geometry);
      const edgeMaterial = new THREE.LineBasicMaterial({
        color: 0x00ffff,
        linewidth: 2,
        transparent: true,
        opacity: glowIntensity * 0.5
      });
      const edgesFront = new THREE.LineSegments(edgeGeometry, edgeMaterial);
      const edgesBack = new THREE.LineSegments(edgeGeometry, edgeMaterial.clone());
      edgesBack.material.color = new THREE.Color(0xff00ff);
      
      edgesFront.position.z = depthSeparation;
      edgesBack.position.z = -depthSeparation;
      
      // Add to group
      hologramGroup.add(frontMesh);
      hologramGroup.add(backMesh);
      hologramGroup.add(edgesFront);
      hologramGroup.add(edgesBack);
      
      // Add distortion planes for depth effect
      for (let i = 0; i < 3; i++) {
        const distortionMaterial = new THREE.MeshBasicMaterial({
          map: i % 2 === 0 ? frontTexture : backTexture,
          transparent: true,
          opacity: 0.1,
          blending: THREE.AdditiveBlending
        });
        const distortionMesh = new THREE.Mesh(geometry, distortionMaterial);
        distortionMesh.position.z = (i - 1) * depthSeparation * 0.5;
        distortionMesh.scale.set(1 + i * 0.05, 1 + i * 0.05, 1);
        hologramGroup.add(distortionMesh);
      }
    }
    
    // Create particle system
    function createParticleSystem() {
      const particleCount = 1000;
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount * 3);
      const colors = new Float32Array(particleCount * 3);
      
      for (let i = 0; i < particleCount; i++) {
        positions[i * 3] = (Math.random() - 0.5) * 10;
        positions[i * 3 + 1] = (Math.random() - 0.5) * 10;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 10;
        
        const color = Math.random() > 0.5 ? 
          new THREE.Color(0x00ffff) : new THREE.Color(0xff00ff);
        colors[i * 3] = color.r;
        colors[i * 3 + 1] = color.g;
        colors[i * 3 + 2] = color.b;
      }
      
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      
      const material = new THREE.PointsMaterial({
        size: 0.05,
        vertexColors: true,
        transparent: true,
        opacity: 0.6,
        blending: THREE.AdditiveBlending
      });
      
      particles = new THREE.Points(geometry, material);
      scene.add(particles);
    }
    
    // Create scanlines effect
    function createScanlines() {
      const geometry = new THREE.PlaneGeometry(20, 20);
      scanlinesMaterial = new THREE.ShaderMaterial({
        uniforms: {
          time: { value: 0 },
          opacity: { value: 0.1 }
        },
        vertexShader: `
          varying vec2 vUv;
          void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform float time;
          uniform float opacity;
          varying vec2 vUv;
          void main() {
            float scanline = sin(vUv.y * 100.0 + time * 5.0) * 0.5 + 0.5;
            gl_FragColor = vec4(0.0, 1.0, 1.0, scanline * opacity);
          }
        `,
        transparent: true,
        blending: THREE.AdditiveBlending
      });
      
      const scanlines = new THREE.Mesh(geometry, scanlinesMaterial);
      scanlines.position.z = 4;
      scene.add(scanlines);
    }
    
    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      
      time += 0.01;
      
      // Rotate hologram
      if (hologramGroup) {
        hologramGroup.rotation.y += 0.01 * rotationSpeed;
        hologramGroup.rotation.x = Math.sin(time) * 0.1;
      }
      
      // Animate particles
      if (particles && particlesEnabled) {
        particles.rotation.y += 0.001;
        particles.visible = true;
      } else if (particles) {
        particles.visible = false;
      }
      
      // Update scanlines
      if (scanlinesMaterial) {
        scanlinesMaterial.uniforms.time.value = time;
        scanlinesMaterial.uniforms.opacity.value = scanlinesEnabled ? 0.1 : 0;
      }
      
      // Update video textures
      if (frontTexture && frontTexture.image.readyState >= 2) {
        frontTexture.needsUpdate = true;
      }
      if (backTexture && backTexture.image.readyState >= 2) {
        backTexture.needsUpdate = true;
      }
      
      renderer.render(scene, camera);
    }
    
    // Setup cameras
    async function setupCameras() {
      try {
        document.getElementById('status').textContent = 'Requesting camera access...';
        
        // Stop existing streams
        if (frontStream) {
          frontStream.getTracks().forEach(track => track.stop());
        }
        if (backStream) {
          backStream.getTracks().forEach(track => track.stop());
        }
        
        // Check browser support
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          throw new Error('Camera API not supported');
        }
        
        // Get available devices
        const devices = await navigator.mediaDevices.enumerateDevices();
        const videoDevices = devices.filter(device => device.kind === 'videoinput');
        
        if (videoDevices.length === 0) {
          throw new Error('No cameras found');
        }
        
        // Setup camera constraints
        const constraints = {
          video: {
            width: { ideal: 1280 },
            height: { ideal: 720 },
            facingMode: 'user'
          },
          audio: false
        };
        
        // Get front camera stream
        frontStream = await navigator.mediaDevices.getUserMedia(constraints);
        
        // Try to get back camera
        if (videoDevices.length > 1) {
          const backConstraints = {
            video: {
              width: { ideal: 1280 },
              height: { ideal: 720 },
              facingMode: 'environment'
            },
            audio: false
          };
          
          try {
            backStream = await navigator.mediaDevices.getUserMedia(backConstraints);
          } catch (e) {
            // If back camera fails, clone front stream
            backStream = frontStream.clone();
          }
        } else {
          // Single camera - clone for both
          backStream = frontStream.clone();
        }
        
        // Set video sources
        const frontVideo = document.getElementById('frontCamera');
        const backVideo = document.getElementById('backCamera');
        
        frontVideo.srcObject = frontStream;
        backVideo.srcObject = backStream;
        
        // Wait for videos to load
        await frontVideo.play();
        await backVideo.play();
        
        // Create Three.js textures from videos
        frontTexture = new THREE.VideoTexture(frontVideo);
        frontTexture.minFilter = THREE.LinearFilter;
        frontTexture.magFilter = THREE.LinearFilter;
        
        backTexture = new THREE.VideoTexture(backVideo);
        backTexture.minFilter = THREE.LinearFilter;
        backTexture.magFilter = THREE.LinearFilter;
        
        // Create hologram
        createHologram();
        
        // Enable record button
        document.getElementById('recordBtn').disabled = false;
        document.getElementById('status').textContent = 'Cameras ready - hologram active';
        
      } catch (error) {
        console.error('Setup error:', error);
        document.getElementById('status').textContent = 'Error: ' + error.message;
      }
    }
    
    // Start recording
    function startRecording() {
      if (!frontStream || !backStream) {
        alert('Please setup cameras first');
        return;
      }
      
      frontChunks = [];
      backChunks = [];
      
      const mimeTypes = [
        'video/webm;codecs=vp9',
        'video/webm;codecs=vp8',
        'video/webm',
        'video/mp4'
      ];
      
      let selectedMimeType = '';
      for (const mimeType of mimeTypes) {
        if (MediaRecorder.isTypeSupported(mimeType)) {
          selectedMimeType = mimeType;
          break;
        }
      }
      
      const options = { mimeType: selectedMimeType };
      
      try {
        // Create recorders
        frontRecorder = new MediaRecorder(frontStream, options);
        backRecorder = new MediaRecorder(backStream, options);
        
        frontRecorder.ondataavailable = (event) => {
          if (event.data.size > 0) {
            frontChunks.push(event.data);
          }
        };
        
        backRecorder.ondataavailable = (event) => {
          if (event.data.size > 0) {
            backChunks.push(event.data);
          }
        };
        
        frontRecorder.onstop = () => {
          const blob = new Blob(frontChunks, { type: selectedMimeType });
          const url = URL.createObjectURL(blob);
          document.getElementById('resultFront').src = url;
          document.getElementById('downloadFront').href = url;
        };
        
        backRecorder.onstop = () => {
          const blob = new Blob(backChunks, { type: selectedMimeType });
          const url = URL.createObjectURL(blob);
          document.getElementById('resultBack').src = url;
          document.getElementById('downloadBack').href = url;
          document.getElementById('resultsSection').style.display = 'block';
        };
        
        // Start recording
        frontRecorder.start(100);
        backRecorder.start(100);
        isRecording = true;
        
        // Update UI
        document.getElementById('recordBtn').disabled = true;
        document.getElementById('stopBtn').disabled = false;
        document.getElementById('status').innerHTML = '<span class="recording-dot"></span>Recording hologram...';
        document.getElementById('status').classList.add('recording');
        
      } catch (error) {
        alert('Error starting recording: ' + error.message);
      }
    }
    
    // Stop recording
    function stopRecording() {
      if (!isRecording) return;
      
      isRecording = false;
      
      if (frontRecorder && frontRecorder.state !== 'inactive') {
        frontRecorder.stop();
      }
      if (backRecorder && backRecorder.state !== 'inactive') {
        backRecorder.stop();
      }
      
      document.getElementById('recordBtn').disabled = false;
      document.getElementById('stopBtn').disabled = true;
      document.getElementById('status').textContent = 'Processing recordings...';
      document.getElementById('status').classList.remove('recording');
    }
    
    // Reset app
    function resetApp() {
      document.getElementById('resultsSection').style.display = 'none';
      document.getElementById('status').textContent = 'Cameras ready - hologram active';
      
      frontChunks = [];
      backChunks = [];
      
      document.getElementById('recordBtn').disabled = false;
    }
    
    // Effect control listeners
    document.getElementById('depthSlider').addEventListener('input', (e) => {
      depthSeparation = parseFloat(e.target.value);
      document.getElementById('depthValue').textContent = depthSeparation;
      createHologram();
    });
    
    document.getElementById('rotationSlider').addEventListener('input', (e) => {
      rotationSpeed = parseFloat(e.target.value);
      document.getElementById('rotationValue').textContent = rotationSpeed;
    });
    
    document.getElementById('glowSlider').addEventListener('input', (e) => {
      glowIntensity = parseFloat(e.target.value);
      document.getElementById('glowValue').textContent = glowIntensity;
      createHologram();
    });
    
    document.getElementById('particlesToggle').addEventListener('change', (e) => {
      particlesEnabled = e.target.checked;
    });
    
    document.getElementById('scanlineToggle').addEventListener('change', (e) => {
      scanlinesEnabled = e.target.checked;
    });
    
    document.getElementById('wireframeToggle').addEventListener('change', (e) => {
      wireframeMode = e.target.checked;
      createHologram();
    });
    
    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
    
    // Cleanup on page unload
    window.addEventListener('beforeunload', () => {
      if (frontStream) {
        frontStream.getTracks().forEach(track => track.stop());
      }
      if (backStream) {
        backStream.getTracks().forEach(track => track.stop());
      }
    });
    
    // Initialize Three.js on load
    window.addEventListener('load', () => {
      initThreeJS();
    });
  </script>
</body>
</html>