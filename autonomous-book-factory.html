<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Autonomous Book Factory — Visual Pipeline</title>
  <style>
    /* Reset and base */
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { height: 100%; }
    body {
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background: radial-gradient(1200px 800px at 20% 0%, #0c1220 0%, #0b0f1a 55%, #090d16 100%);
      color: #eaf2ff;
      overflow: hidden;
    }

    /* Header */
    .factory-header {
      position: fixed; inset: 0 0 auto 0; height: 72px; z-index: 1000;
      display: flex; align-items: center; justify-content: space-between;
      padding: 10px 16px;
      background: linear-gradient(180deg, rgba(0,0,0,0.7), rgba(0,0,0,0));
      border-bottom: 1px solid rgba(120,160,255,0.1);
      backdrop-filter: blur(6px);
    }
    .title-wrap { display: flex; align-items: center; gap: 12px; }
    .logo {
      width: 40px; height: 40px; border-radius: 12px;
      background: radial-gradient(100% 100% at 0% 0%, #1f6feb 0%, #00c896 100%);
      box-shadow: inset 0 0 18px rgba(255,255,255,0.2), 0 10px 28px rgba(0,0,0,0.35);
    }
    .title h1 {
      font-size: 20px; letter-spacing: .4px; margin: 0;
      background: linear-gradient(45deg, #9ad1ff, #77ffc4);
      -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent;
      text-shadow: 0 0 24px rgba(90, 169, 255, 0.25);
    }
    .subtitle { font-size: 12px; color: #9fb2cf; margin-top: 2px; }

    .toolbar { display: flex; align-items: center; gap: 8px; }
    .btn {
      background: linear-gradient(180deg, #1a2332, #101621);
      color: #eaf2ff; border: 1px solid #1f2a3a;
      border-radius: 12px; padding: 10px 14px; cursor: pointer;
      transition: .15s ease; display: inline-flex; align-items: center; gap: 8px;
      box-shadow: 0 8px 26px rgba(0,0,0,0.35);
      user-select: none;
    }
    .btn:hover { transform: translateY(-1px); border-color: #2b3950; }
    .btn.primary { background: linear-gradient(180deg, #1476ff, #0c4abf); border: 0; }
    .btn.ghost { background: transparent; border-color: #2b3950; }

    /* Left HUD: Overseer panel */
    .overseer-center {
      position: fixed; top: 88px; left: 16px; width: 360px; z-index: 900;
      background: linear-gradient(180deg, rgba(16,22,33,0.95), rgba(10,14,22,0.95));
      border: 1px solid #20314d; border-radius: 14px; padding: 14px;
      box-shadow: 0 15px 40px rgba(0,0,0,0.45);
      max-height: calc(100vh - 110px); overflow: auto;
    }
    .overseer-portrait {
      width: 88px; height: 88px; margin: 6px auto 10px; border-radius: 50%;
      background: radial-gradient(circle, #ffd36d 0%, #ff8c00 70%);
      display: flex; align-items: center; justify-content: center; font-size: 44px;
      animation: overseerGlow 3s ease-in-out infinite;
      box-shadow: 0 0 30px rgba(255, 180, 60, 0.6);
    }
    @keyframes overseerGlow { 0%,100% { filter: drop-shadow(0 0 8px #ffb74d) } 50% { filter: drop-shadow(0 0 16px #ffd36d) } }
    .tagline { text-align: center; font-weight: 700; color: #ffd36d; }
    .role { text-align: center; color: #ff9e4a; font-size: 12px; margin-top: 2px; }

    .overseer-thoughts {
      background: rgba(255, 211, 109, 0.06);
      border: 1px solid rgba(255, 211, 109, 0.3);
      border-radius: 10px; padding: 10px; margin-top: 12px; min-height: 80px;
      max-height: 160px; overflow: auto;
    }
    .overseer-thought {
      color: #ffd36d; margin-bottom: 8px; padding: 8px;
      background: rgba(0,0,0,0.35); border-radius: 8px; font-style: italic; animation: thoughtAppear .25s ease;
    }
    @keyframes thoughtAppear { from { opacity: 0; transform: translateY(6px) } to { opacity: 1; transform: translateY(0) } }

    .phase-box {
      background: rgba(255,140,0,0.10); border: 1px solid rgba(255,140,0,0.4);
      border-radius: 10px; padding: 10px; margin-top: 10px;
    }
    .phase-kicker { color: #ff9e4a; font-size: 11px; text-transform: uppercase; letter-spacing: .6px; margin-bottom: 6px; }
    .phase-value { font-weight: 700; }

    /* Right HUD: Memory and Book Status */
    .memory-indicator, .book-status {
      position: fixed; right: 16px; z-index: 900;
      background: linear-gradient(180deg, rgba(16,22,33,0.95), rgba(10,14,22,0.95));
      border: 1px solid #20314d; border-radius: 14px; padding: 12px;
      box-shadow: 0 15px 40px rgba(0,0,0,0.45);
    }
    .memory-indicator { top: 88px; width: 180px; border-color: #7b1fa2; }
    .mem-label { color: #d993ff; font-size: 11px; text-transform: uppercase; letter-spacing: .6px; }
    .mem-count { font-size: 28px; font-weight: 800; margin-top: 6px; }

    .book-status { top: 176px; width: 380px; border-color: #1db954; }
    .book-title-display { text-align: center; color: #77ffc4; font-size: 18px; font-weight: 800; margin-bottom: 10px; }
    .book-stats {
      display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 10px;
    }
    .stat-card { background: rgba(16, 190, 120, 0.08); border: 1px solid rgba(16, 190, 120, 0.3); border-radius: 8px; padding: 8px; }
    .stat-kicker { color: #9fb2cf; font-size: 11px; }
    .stat-value { color: #77ffc4; font-weight: 700; margin-top: 2px; }

    #chapter-progress { display: flex; flex-direction: column; gap: 8px; max-height: 52vh; overflow: auto; }
    .chapter-item {
      background: rgba(0,0,0,0.35); border: 1px solid rgba(16, 190, 120, 0.2); border-radius: 8px; padding: 8px;
    }
    .chapter-top { display: flex; justify-content: space-between; align-items: baseline; margin-bottom: 6px; }
    .chapter-title { color: #77ffc4; font-weight: 700; }
    .chapter-words { color: #9fb2cf; font-size: 12px; }
    .progress-rail { height: 6px; background: rgba(255,255,255,0.08); border-radius: 999px; overflow: hidden; }
    .progress-fill { height: 100%; width: 0%; background: linear-gradient(90deg, #16e08f, #00d9ff); transition: width .4s ease; }

    /* Bottom: Worker floor */
    .worker-floor {
      position: fixed; left: 0; right: 0; bottom: 0; height: 320px; z-index: 910;
      background: linear-gradient(180deg, rgba(0,0,0,0), rgba(0,0,0,0.85));
      padding: 14px 16px 18px; overflow-x: auto;
      border-top: 1px solid rgba(120,160,255,0.10);
    }
    .worker-container { display: flex; gap: 14px; min-width: 840px; height: 100%; }
    .station {
      min-width: 220px; height: 100%;
      background: linear-gradient(180deg, rgba(16,22,33,0.95), rgba(10,14,22,0.95));
      border: 1px solid #2a3d5d; border-radius: 12px; padding: 12px; position: relative; display: flex; flex-direction: column;
      box-shadow: 0 15px 40px rgba(0,0,0,0.45);
    }
    .station.planner    { border-color: #ff8c00; }
    .station.researcher { border-color: #00d9ff; }
    .station.outliner   { border-color: #6ecbff; }
    .station.writer     { border-color: #ff6347; }
    .station.editor     { border-color: #4ecdc4; }
    .station.fact       { border-color: #a78bfa; }
    .station.qa         { border-color: #a3e635; }
    .station.publisher  { border-color: #ffe66d; }

    .avatar {
      width: 64px; height: 64px; margin: 0 auto 8px; border-radius: 50%;
      display: grid; place-items: center; font-size: 30px;
    }
    .avatar.planner    { background: #ff8c00; }
    .avatar.researcher { background: #00d9ff; }
    .avatar.outliner   { background: #6ecbff; }
    .avatar.writer     { background: #ff6347; }
    .avatar.editor     { background: #4ecdc4; }
    .avatar.fact       { background: #a78bfa; }
    .avatar.qa         { background: #a3e635; }
    .avatar.publisher  { background: #ffe66d; }

    .name { text-align: center; font-weight: 800; }
    .role { text-align: center; color: #9fb2cf; font-size: 12px; margin-bottom: 8px; }

    .status-row { display: flex; align-items: center; gap: 6px; }
    .dot { width: 8px; height: 8px; border-radius: 999px; background: #64748b; }
    .dot.ok { background: #22c55e; } .dot.warn { background: #fbbf24; } .dot.err { background: #ef4444; }
    .status-text { color: #9fb2cf; font-size: 12px; }

    .bubble {
      position: absolute; bottom: calc(100% - 10px); left: 50%; transform: translateX(-50%);
      background: rgba(0,0,0,0.92); border: 1px solid #2a3d5d; border-radius: 10px; padding: 8px 10px;
      min-width: 180px; max-width: 240px; display: none; font-size: 12px;
    }
    .station.speaking .bubble { display: block; animation: speak .25s ease; }
    @keyframes speak { from { opacity: 0; transform: translateX(-50%) translateY(10px)} to { opacity:1; transform: translateX(-50%) translateY(0)} }

    .task {
      color: #00e5ff; font-size: 12px; background: rgba(0, 229, 255, 0.08); border: 1px solid rgba(0,229,255,0.25);
      border-radius: 8px; padding: 6px; margin-top: 10px; min-height: 42px;
    }

    /* Control fab buttons */
    .control-panel {
      position: fixed; right: 16px; bottom: 336px; display: grid; gap: 10px; z-index: 920;
    }
    .control-btn {
      width: 56px; height: 56px; border-radius: 999px; border: 2px solid #ffd36d; background: rgba(16,22,33,0.96);
      color: #ffd36d; font-size: 22px; cursor: pointer; display: grid; place-items: center; transition: transform .15s ease, box-shadow .15s ease;
    }
    .control-btn:hover { transform: scale(1.06); box-shadow: 0 0 22px rgba(255, 211, 109, 0.35); }
    .control-btn.active { background: #ffd36d; color: #101621; }

    /* Transcript and output modal */
    .transcript-panel, .output-panel {
      position: fixed; inset: 50% auto auto 50%; transform: translate(-50%, -50%); z-index: 2000;
      width: min(880px, calc(100vw - 40px)); max-height: min(80vh, 760px);
      background: rgba(10,14,22,0.98); border: 1px solid #2a3d5d; border-radius: 16px; padding: 18px; box-shadow: 0 30px 80px rgba(0,0,0,0.6);
      display: none; overflow: auto;
    }
    .transcript-panel.active, .output-panel.active { display: block; }
    .modal-title { text-align: center; font-weight: 800; margin-bottom: 10px; color: #d993ff; }
    .output-title { text-align: center; font-weight: 900; font-size: 26px; color: #ffd36d; margin-bottom: 6px; }
    .byline { text-align: center; color: #ff9e4a; font-style: italic; margin-bottom: 14px; }
    .output-body { background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.06); border-radius: 12px; padding: 16px; line-height: 1.7; }

    .output-close {
      position: absolute; right: 10px; top: 10px; width: 38px; height: 38px; border-radius: 999px; border: 0;
      background: #ef4444; color: #fff; cursor: pointer; font-size: 20px;
    }

    .transcript-entry {
      margin-bottom: 12px; padding: 10px;
      background: rgba(255, 255, 255, 0.04); border-radius: 8px; border-left: 3px solid #d993ff;
    }
    .transcript-entry.memory { border-left-color: #ef4444; background: rgba(239, 68, 68, 0.08); }

    /* Settings drawer */
    .settings-panel {
      position: fixed; top: 50%; right: -420px; transform: translateY(-50%);
      width: 400px; z-index: 2001; transition: right .25s ease;
      background: rgba(10,14,22,0.98); border: 1px solid #7b1fa2; border-right: 0; border-radius: 16px 0 0 16px;
      box-shadow: -20px 0 60px rgba(0,0,0,0.5);
      padding: 16px;
    }
    .settings-panel.active { right: 0; }
    .setting-group { margin-bottom: 12px; }
    .setting-label { color: #d993ff; font-size: 12px; margin-bottom: 6px; }
    .setting-input, .prompt-textarea {
      width: 100%; background: rgba(0,0,0,0.5); border: 1px solid #7b1fa2; color: #fff; border-radius: 10px; padding: 10px; font-size: 14px;
    }
    .prompt-textarea { min-height: 90px; resize: vertical; }

    /* Top input bar under header */
    .prompt-bar {
      position: fixed; top: 76px; left: 400px; right: 420px; z-index: 890; padding: 8px 10px;
      display: grid; grid-template-columns: 1fr auto; gap: 8px;
    }
    @media (max-width: 1180px) {
      .prompt-bar { left: 16px; right: 16px; grid-template-columns: 1fr; }
    }
    .prompt-input {
      width: 100%; border-radius: 12px; border: 1px solid #1f2a3a; background: rgba(12,17,25,0.95);
      padding: 12px 14px; color: #eaf2ff;
    }

    /* Loader and toast */
    .loading-overlay {
      position: fixed; inset: 0; background: rgba(5,8,14,0.92);
      display: none; align-items: center; justify-content: center; z-index: 4000;
    }
    .loading-spinner {
      width: 80px; height: 80px; border: 5px solid rgba(90, 169, 255, 0.25); border-top: 5px solid #5aa9ff;
      border-radius: 999px; animation: spin 1s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg) } }
    .toast {
      position: fixed; top: 14px; left: 50%; transform: translateX(-50%);
      background: rgba(0,0,0,0.95); border: 1px solid #1f2a3a; border-radius: 10px;
      color: #eaf2ff; padding: 10px 14px; z-index: 4500; display: none;
      box-shadow: 0 10px 30px rgba(0,0,0,0.45);
    }
  </style>
</head>
<body>
  <!-- Header -->
  <div class="factory-header">
    <div class="title-wrap">
      <div class="logo" aria-hidden="true"></div>
      <div class="title">
        <h1>Autonomous Book Factory</h1>
        <div class="subtitle">End to end production through your Azure Function URL</div>
      </div>
    </div>
    <div class="toolbar">
      <button class="btn ghost" id="open-transcript" title="Transcripts">💬</button>
      <button class="btn ghost" id="open-settings" title="Settings">⚙️</button>
      <button class="btn primary" id="run-full" title="Run">Run</button>
    </div>
  </div>

  <!-- Prompt quick bar -->
  <div class="prompt-bar">
    <input id="global-prompt" class="prompt-input" placeholder="Describe the book. Include title, audience, tone, constraints and required artifacts." />
    <div style="display:flex; gap:8px">
      <button class="btn" id="pause-run" disabled>Pause</button>
      <button class="btn" id="resume-run" disabled>Resume</button>
      <button class="btn" id="abort-run">Abort</button>
    </div>
  </div>

  <!-- Left HUD -->
  <aside class="overseer-center">
    <div class="overseer-portrait">👁️</div>
    <div class="tagline">OVERSEER</div>
    <div class="role">Production Coordinator</div>
    <div class="overseer-thoughts" id="overseer-thoughts"></div>
    <div class="phase-box" style="margin-top:12px">
      <div class="phase-kicker">Current phase</div>
      <div class="phase-value" id="current-phase">Idle</div>
    </div>
  </aside>

  <!-- Right HUD -->
  <aside class="memory-indicator">
    <div class="mem-label">Core memories</div>
    <div class="mem-count" id="core-memory-count">0</div>
  </aside>

  <aside class="book-status">
    <div class="book-title-display" id="book-title">Awaiting Project</div>
    <div class="book-stats">
      <div class="stat-card">
        <div class="stat-kicker">Genre</div>
        <div class="stat-value" id="book-genre">—</div>
      </div>
      <div class="stat-card">
        <div class="stat-kicker">Words</div>
        <div class="stat-value" id="word-count">0</div>
      </div>
    </div>
    <div id="chapter-progress"></div>
  </aside>

  <!-- Worker floor -->
  <section class="worker-floor">
    <div class="worker-container" id="worker-container"></div>
  </section>

  <!-- Floating controls -->
  <div class="control-panel">
    <button class="control-btn" id="open-output" title="Compiled Manuscript">📖</button>
    <button class="control-btn" id="export-bundle" title="Export Bundle">🗂️</button>
    <button class="control-btn" id="download-md" title="Download Markdown">⬇️</button>
  </div>

  <!-- Transcript modal -->
  <div class="transcript-panel" id="transcript-panel">
    <button class="output-close" id="close-transcript">×</button>
    <div class="modal-title">Worker Communications Log</div>
    <div id="transcript-content"></div>
  </div>

  <!-- Output modal -->
  <div class="output-panel" id="output-panel">
    <button class="output-close" id="close-output">×</button>
    <div class="output-title" id="output-title">Book Title</div>
    <div class="byline">By Factory Collective</div>
    <div class="output-body" id="output-body"></div>
  </div>

  <!-- Settings -->
  <div class="settings-panel" id="settings-panel">
    <div class="modal-title" style="color:#ffd36d">Production Settings</div>
    <div class="setting-group">
      <div class="setting-label">Azure Function URL</div>
      <input id="fn-url" class="setting-input" type="url" placeholder="https://<app>.azurewebsites.net/api/your_function" />
    </div>
    <div class="setting-group">
      <div class="setting-label">Function key (x-functions-key)</div>
      <input id="fn-key" class="setting-input" type="password" placeholder="Paste key if required" />
    </div>
    <div class="setting-group">
      <div class="setting-label">User GUID (optional)</div>
      <input id="user-guid" class="setting-input" type="text" placeholder="01234567-89ab-cdef-0123-456789abcdef" />
    </div>
    <div class="setting-group">
      <div class="setting-label">House style</div>
      <input id="house-style" class="setting-input" type="text" placeholder="Tight, active voice. Short paragraphs. Concrete examples." />
    </div>
    <div class="setting-group" style="display:grid; grid-template-columns:1fr 1fr; gap:8px">
      <div>
        <div class="setting-label">Target chapters</div>
        <input id="chapter-count" class="setting-input" type="number" min="1" max="50" value="8" />
      </div>
      <div>
        <div class="setting-label">Words per chapter</div>
        <input id="words-per-chapter" class="setting-input" type="number" min="300" max="8000" value="1200" />
      </div>
    </div>
    <div class="setting-group">
      <div class="setting-label">Max cycles</div>
      <input id="max-cycles" class="setting-input" type="number" min="1" max="10" value="3" />
    </div>
    <div style="display:flex; gap:8px; margin-top:10px">
      <button class="btn primary" id="save-settings">Save</button>
      <button class="btn" id="reset-settings">Reset</button>
    </div>
  </div>

  <!-- Loader + toast -->
  <div class="loading-overlay" id="loading-overlay" aria-live="assertive">
    <div style="display:flex;flex-direction:column;align-items:center;gap:12px">
      <div class="loading-spinner"></div>
      <div>Running production</div>
    </div>
  </div>
  <div class="toast" id="toast"></div>

  <script>
    class VisualBookFactory {
      constructor() {
        // Settings
        this.fnUrl    = localStorage.getItem('abf_fn_url')   || '';
        this.fnKey    = localStorage.getItem('abf_fn_key')   || '';
        this.userGuid = localStorage.getItem('abf_user_guid')|| '';

        // State
        this.conversationHistory = [];
        this.state = {
          cycle: 0,
          maxCycles: 3,
          targetChapters: 8,
          wordsPerChapter: 1200,
          houseStyle: '',
          plan: null,
          chapters: [],     // [{id,title}]
          research: {},     // id -> brief
          outlines: {},     // id -> bullets
          drafts: {},       // id -> md
          edits: {},        // id -> editor response
          factChecks: {},   // id -> fact report
          finals: {},       // id -> final md
          approvals: {},    // id -> {status,reasons,actions}
          manuscript: ''
        };

        // UI
        this.$ = id => document.getElementById(id);
        this.bindUI();
        this.mountWorkers();
        this.loadSettings();
        this.setPhase('Idle');
      }

      bindUI() {
        // top bar
        this.$('run-full').addEventListener('click', () => this.runFullProduction());
        this.$('open-settings').addEventListener('click', () => this.toggleSettings(true));
        this.$('open-transcript').addEventListener('click', () => this.toggleTranscript(true));

        // floating
        this.$('open-output').addEventListener('click', () => this.openOutput());
        this.$('export-bundle').addEventListener('click', () => this.exportBundle());
        this.$('download-md').addEventListener('click', () => this.downloadMarkdown());

        // modals
        this.$('close-transcript').addEventListener('click', () => this.toggleTranscript(false));
        this.$('close-output').addEventListener('click', () => this.toggleOutput(false));

        // settings
        this.$('save-settings').addEventListener('click', () => this.saveSettings());
        this.$('reset-settings').addEventListener('click', () => this.resetSettings());

        // controls
        this.$('pause-run').addEventListener('click', () => this.pause());
        this.$('resume-run').addEventListener('click', () => this.resume());
        this.$('abort-run').addEventListener('click', () => this.abort());

        // setting inputs to state
        this.$('max-cycles').addEventListener('change', e => this.state.maxCycles = Math.max(1, parseInt(e.target.value || '3', 10)));
        this.$('chapter-count').addEventListener('change', e => this.state.targetChapters = Math.max(1, parseInt(e.target.value || '8', 10)));
        this.$('words-per-chapter').addEventListener('change', e => this.state.wordsPerChapter = Math.max(300, parseInt(e.target.value || '1200', 10)));
        this.$('house-style').addEventListener('input', e => this.state.houseStyle = e.target.value);
      }

      loadSettings() {
        this.$('fn-url').value = this.fnUrl;
        this.$('fn-key').value = this.fnKey;
        this.$('user-guid').value = this.userGuid;
      }
      saveSettings() {
        const u = this.$('fn-url').value.trim();
        const k = this.$('fn-key').value.trim();
        const g = this.$('user-guid').value.trim();
        localStorage.setItem('abf_fn_url', u);
        localStorage.setItem('abf_fn_key', k);
        localStorage.setItem('abf_user_guid', g);
        this.fnUrl = u; this.fnKey = k; this.userGuid = g;
        this.toast('Settings saved');
        this.toggleSettings(false);
      }
      resetSettings() {
        if (!confirm('Reset all settings?')) return;
        ['abf_fn_url','abf_fn_key','abf_user_guid'].forEach(localStorage.removeItem.bind(localStorage));
        this.fnUrl = ''; this.fnKey = ''; this.userGuid = '';
        this.loadSettings();
        this.toast('Settings reset');
      }

      /* ---------- Visuals ---------- */
      mountWorkers() {
        const workers = [
          { key:'planner',    name:'PLANNER',    role:'Story Architect',  avatar:'📐' },
          { key:'researcher', name:'RESEARCH',   role:'Research Briefs',  avatar:'🔎' },
          { key:'outliner',   name:'OUTLINER',   role:'Chapter Beats',    avatar:'🗂️' },
          { key:'writer',     name:'WRITER',     role:'Content Creator',  avatar:'✍️' },
          { key:'editor',     name:'EDITOR',     role:'Quality Refiner',  avatar:'📝' },
          { key:'fact',       name:'FACTS',      role:'Fact Checker',     avatar:'📚' },
          { key:'qa',         name:'QA',         role:'Quality Gate',     avatar:'✅' },
          { key:'publisher',  name:'PUBLISH',    role:'Ship Decision',    avatar:'🚀' },
        ];
        const container = this.$('worker-container');
        container.innerHTML = '';
        for (const w of workers) {
          const div = document.createElement('div');
          div.className = `station ${w.key}`;
          div.id = `station-${w.key}`;
          div.innerHTML = `
            <div class="bubble" id="bubble-${w.key}"><span id="bubble-text-${w.key}"></span></div>
            <div class="avatar ${w.key}">${w.avatar}</div>
            <div class="name">${w.name}</div>
            <div class="role">${w.role}</div>
            <div class="status-row" style="margin-top:6px">
              <div class="dot" id="dot-${w.key}"></div>
              <div class="status-text" id="status-${w.key}">idle</div>
            </div>
            <div class="task" id="task-${w.key}" style="margin-top:10px">Ready</div>
          `;
          container.appendChild(div);
        }
      }

      setWorker(key, status, taskText, say) {
        const dot = this.$(`dot-${key}`); const txt = this.$(`status-${key}`);
        const task = this.$(`task-${key}`); const bubble = this.$(`bubble-${key}`); const btxt = this.$(`bubble-text-${key}`);
        ['ok','warn','err'].forEach(c => dot.classList.remove(c));
        if (status === 'ok') dot.classList.add('ok');
        if (status === 'warn') dot.classList.add('warn');
        if (status === 'err') dot.classList.add('err');
        txt.textContent = status || 'idle';
        if (taskText) task.textContent = taskText;
        const st = this.$(`station-${key}`);
        if (say) {
          btxt.textContent = say;
          st.classList.add('speaking');
          setTimeout(() => st.classList.remove('speaking'), 2200);
        }
      }

      overseerThink(text, memory=false) {
        const box = this.$('overseer-thoughts');
        const div = document.createElement('div');
        div.className = 'overseer-thought';
        div.textContent = text;
        box.appendChild(div);
        box.scrollTop = box.scrollHeight;
        if (memory) {
          const c = this.$('core-memory-count');
          c.textContent = String(parseInt(c.textContent || '0', 10) + 1);
        }
      }

      setPhase(phase) { this.$('current-phase').textContent = phase; }

      updateBookMeta(title, genre) {
        if (title) this.$('book-title').textContent = title;
        if (genre) this.$('book-genre').textContent = genre;
      }
      updateWordCount() {
        const total = Object.values(this.state.finals).join('\n').split(/\s+/).filter(Boolean).length
                    || Object.values(this.state.drafts).join('\n').split(/\s+/).filter(Boolean).length;
        this.$('word-count').textContent = (total || 0).toLocaleString();
      }
      drawChapterList() {
        const wrap = this.$('chapter-progress');
        wrap.innerHTML = '';
        for (let i = 0; i < this.state.chapters.length; i++) {
          const c = this.state.chapters[i];
          const item = document.createElement('div');
          item.className = 'chapter-item';
          item.id = `chapter-${c.id}`;
          item.innerHTML = `
            <div class="chapter-top">
              <div class="chapter-title">${i+1}. ${c.title}</div>
              <div class="chapter-words" id="cw-${c.id}">0 words</div>
            </div>
            <div class="progress-rail"><div class="progress-fill" id="pf-${c.id}" style="width:0%"></div></div>
          `;
          wrap.appendChild(item);
        }
      }
      setChapterProgress(id, pct, words) {
        const pf = this.$(`pf-${id}`); if (pf) pf.style.width = Math.max(0, Math.min(100, pct)) + '%';
        const cw = this.$(`cw-${id}`); if (cw && typeof words === 'number') cw.textContent = `${words.toLocaleString()} words`;
      }

      toast(text, ms=2500) {
        const t = this.$('toast'); t.textContent = text; t.style.display = 'block'; setTimeout(()=> t.style.display = 'none', ms);
      }

      toggleSettings(open) {
        const p = this.$('settings-panel');
        if (open) p.classList.add('active'); else p.classList.remove('active');
      }
      toggleTranscript(open) {
        const p = this.$('transcript-panel');
        if (open) p.classList.add('active'); else p.classList.remove('active');
        if (open) this.renderTranscripts();
      }
      toggleOutput(open) {
        const p = this.$('output-panel');
        if (open) p.classList.add('active'); else p.classList.remove('active');
      }
      openOutput() {
        this.$('output-title').textContent = this.$('book-title').textContent || 'Manuscript';
        this.$('output-body').textContent = this.state.manuscript || 'No manuscript yet';
        this.toggleOutput(true);
      }

      showLoader(show) { this.$('loading-overlay').style.display = show ? 'flex' : 'none'; }

      /* ---------- Transcript ---------- */
      transcripts = [];
      addTranscript(from, to, message, isMemory=false) {
        this.transcripts.push({ ts: new Date(), from, to, message, isMemory });
        if (isMemory) this.overseerThink('Core memory formed', true);
        const panel = this.$('transcript-panel');
        if (panel.classList.contains('active')) this.renderTranscripts();
      }
      renderTranscripts() {
        const box = this.$('transcript-content'); box.innerHTML = '';
        for (const t of this.transcripts.slice(-40)) {
          const div = document.createElement('div');
          div.className = 'transcript-entry' + (t.isMemory ? ' memory' : '');
          div.innerHTML = `
            <div style="color:#d993ff;font-weight:700;margin-bottom:4px">${t.from} → ${t.to}</div>
            <div style="white-space:pre-wrap">${t.message}</div>
            <div style="color:#9fb2cf;font-size:11px;margin-top:6px;text-align:right">${t.ts.toLocaleTimeString()}</div>
          `;
          box.appendChild(div);
        }
      }

      /* ---------- Azure Function ---------- */
      async callAI(worker, prompt) {
        if (!this.fnUrl) {
          this.toast('Set your Azure Function URL in Settings', 3500);
          return this.fallback(worker);
        }
        try {
          const body = {
            user_input: prompt,
            conversation_history: this.conversationHistory,
            ...(this.userGuid ? { user_guid: this.userGuid } : {})
          };
          const headers = { 'Content-Type': 'application/json' };
          if (this.fnKey) headers['x-functions-key'] = this.fnKey;

          const res = await fetch(this.fnUrl, { method: 'POST', headers, body: JSON.stringify(body) });
          if (!res.ok) throw new Error(`Function error ${res.status}: ${await res.text().catch(()=> '')}`);
          const data = await res.json();
          const text = String(data.assistant_response || '');
          if (data.user_guid && data.user_guid !== this.userGuid) {
            this.userGuid = data.user_guid; localStorage.setItem('abf_user_guid', this.userGuid);
          }
          this.conversationHistory.push({ role:'user', content: prompt });
          this.conversationHistory.push({ role:'assistant', content: text });
          return text;
        } catch(e) {
          console.error('AI call error:', e);
          this.toast(`Backend error: ${e.message}`, 4000);
          return this.fallback(worker);
        }
      }
      fallback(worker) {
        const samples = {
          overseer:`**Objectives**: finalize scope and JSON contract.\n**Risks**: ambiguity.\n**Next**: Planner outputs strict JSON with chapters.`,
          planner: JSON.stringify({
            milestones:[{id:"M1",title:"Complete Manuscript",owner:"Pipeline",definition_of_done:"All chapters QA approved"}],
            steps:[{id:"S1",depends_on:[],title:"Plan chapters",owner:"Planner",inputs:"prompt",outputs:"chapters"}],
            constraints:["Follow house style","Meet word targets"],
            chapters:Array.from({length:this.state.targetChapters},(_,i)=>({id:`C${i+1}`,title:`Chapter ${i+1}`})),
          }, null, 2)
        };
        return samples[worker] || '...';
      }

      parseJSON(text) {
        if (!text) return null;
        const obj = this.matchBalanced(text,'{','}'); const arr = this.matchBalanced(text,'[',']');
        const cand = (obj && obj.value) || (arr && arr.value);
        if (!cand) return null;
        try { return JSON.parse(cand); } catch { return null; }
      }
      matchBalanced(s, open, close) {
        let d=0, start=-1;
        for (let i=0;i<s.length;i++) {
          const ch = s[i];
          if (ch===open) { if (d===0) start = i; d++; }
          else if (ch===close) { d--; if (d===0 && start!==-1) return { start, end:i, value:s.slice(start, i+1) }; }
        }
        return null;
      }

      /* ---------- Prompts ---------- */
      pOverseer(user) {
        return `ROLE: Overseer
You orchestrate a full book-production pipeline.

USER GOAL:
${user}

Return:
- objectives
- constraints
- stakeholders
- risks
- required artifacts
- JSON contract the Planner must obey
End with one actionable next step for the Planner.`;
      }
      pPlanner(user) {
        const {targetChapters,wordsPerChapter,houseStyle} = this.state;
        return `ROLE: Planner
Given the Overseer context and USER GOAL below, output STRICT JSON only.

USER GOAL:
${user}

Rules:
- JSON only
- keys:
  "milestones": array of {id,title,owner,definition_of_done}
  "steps": array of {id,depends_on,title,owner,inputs,outputs}
  "constraints": array of strings
  "chapters": array of {id,title}
- Chapters length must be ${targetChapters}
- Include constraints to target ~${wordsPerChapter} words/chapter and house style "${houseStyle || 'clear, active, concrete'}"`;
      }
      pResearch(ch, user) {
        return `ROLE: Researcher
Book context:
${user}

Chapter: ${ch.title}
Provide a compact research brief with:
- key points
- small citations or sources (short)
- pitfalls to avoid
Under 350 words.`;
      }
      pOutline(ch, brief) {
        return `ROLE: Outliner
Chapter: ${ch.title}

Research brief:
${brief}

Create 6–12 markdown bullets that cover:
- Hook
- Key beats or arguments
- 1–2 concrete examples
- Closing beat and transition`;
      }
      pWrite(ch, outline, globalConstraints) {
        const {wordsPerChapter,houseStyle} = this.state;
        return `ROLE: Writer
Constraints: ${JSON.stringify(globalConstraints || [])}
Chapter: ${ch.title}

Outline:
${outline}

Write the full chapter in markdown, ${Math.round(wordsPerChapter*0.9)} to ${Math.round(wordsPerChapter*1.1)} words.
Style: ${houseStyle || 'clear, vivid, specific'}.
No placeholders.`;
      }
      pEdit(ch, draft) {
        return `ROLE: Editor
Return:
1) diff: unified diff of improvements
2) final: the full cleaned chapter in markdown

DRAFT:
${draft}`;
      }
      pFact(ch, text) {
        return `ROLE: Fact Checker
Flag questionable statements. Provide corrections if needed and include corrected "final" markdown when changes apply.

CHAPTER:
${text}`;
      }
      pQA(ch, text, constraints) {
        return `ROLE: QA
Evaluate against constraints:
${constraints}

Return STRICT JSON only:
{"status":"APPROVE"|"REVISE","reasons":[string],"actions":[string]}

CHAPTER:
${text}`;
      }
      pPublish(manuscript, constraints) {
        return `ROLE: Publisher
Decide if manuscript is ship-ready given constraints:
${constraints}

Return STRICT JSON only:
{"status":"APPROVE"|"REVISE","reasons":[string],"actions":[string]}

MANUSCRIPT:
${manuscript.slice(0,24000)}${manuscript.length>24000 ? '\n[truncated]' : ''}`;
      }

      extractFinalFromEditor(editorText) {
        const m1 = editorText.match(/final\s*:\s*([\s\S]*)$/i);
        const m2 = editorText.match(/final\s*[\r\n]+```(?:md|markdown)?\s*([\s\S]*?)```/i);
        return (m2 && m2[1].trim()) || (m1 && m1[1].trim()) || null;
      }
      extractCorrectedFinal(factText) {
        const m1 = factText.match(/final\s*:\s*([\s\S]*)$/i);
        const m2 = factText.match(/final\s*[\r\n]+```(?:md|markdown)?\s*([\s\S]*?)```/i);
        return (m2 && m2[1].trim()) || (m1 && m1[1].trim()) || null;
      }
      deriveTitleFromPrompt(p) {
        const t = (p.split('\n').find(s => /title\s*:/i.test(s))||'').split(':').slice(1).join(':').trim();
        return t || (p.split(/[.!?]\s+/)[0] || '').trim() || 'Untitled Book';
      }

      /* ---------- Controls ---------- */
      paused = false; aborted = false;

      pause()  { this.paused = true;  this.$('pause-run').disabled = true; this.$('resume-run').disabled = false; this.toast('Paused'); }
      resume() { this.paused = false; this.$('pause-run').disabled = false; this.$('resume-run').disabled = true; this.toast('Resumed'); }
      abort()  { this.aborted = true; this.toast('Aborted', 3000); }

      async waitIfPausedOrAborted() {
        while (this.paused) { await new Promise(r => setTimeout(r, 180)); }
        if (this.aborted) throw new Error('Run aborted');
      }

      /* ---------- Run pipeline with live visuals ---------- */
      async runFullProduction() {
        const userPrompt = this.$('global-prompt').value.trim();
        if (!userPrompt) { this.toast('Enter a project prompt'); return; }

        // Init UI
        this.showLoader(true);
        this.$('pause-run').disabled = false; this.$('resume-run').disabled = true;
        this.$('output-body').textContent = '';
        this.aborted = false; this.paused = false;
        this.overseerThink('Initializing production');
        this.setPhase('Initialize');

        // Reset state
        this.conversationHistory = [];
        this.state.cycle = 0;
        this.state.plan = null;
        this.state.chapters = [];
        this.state.research = {}; this.state.outlines = {}; this.state.drafts = {};
        this.state.edits = {}; this.state.factChecks = {}; this.state.finals = {};
        this.state.approvals = {}; this.state.manuscript = '';

        try {
          // Overseer
          this.setPhase('Overseer — Scope and Contract');
          this.setWorker('planner','warn','Awaiting plan', 'Waiting for contract');
          this.overseerThink('Scoping project');
          const overseerText = await this.callAI('overseer', this.pOverseer(userPrompt));
          this.addTranscript('Overseer', 'All', 'Overseer completed scope and contract.', true);
          const titleGuess = this.deriveTitleFromPrompt(userPrompt);
          this.updateBookMeta(titleGuess, null);

          await this.waitIfPausedOrAborted();

          // Planner
          this.setPhase('Planner — Plan and Chapters');
          this.setWorker('planner','warn','Planning chapters', 'Creating plan');
          const plannerText = await this.callAI('planner', this.pPlanner(userPrompt));
          const planJSON = this.parseJSON(plannerText);
          if (planJSON) {
            this.state.plan = planJSON;
            let chapters = Array.isArray(planJSON.chapters) ? planJSON.chapters : [];
            if (chapters.length < this.state.targetChapters) {
              const need = this.state.targetChapters - chapters.length;
              for (let i=0;i<need;i++) chapters.push({id:`C_auto_${i+1}`, title:`Chapter ${chapters.length+i+1}`});
            } else if (chapters.length > this.state.targetChapters) {
              chapters = chapters.slice(0, this.state.targetChapters);
            }
            this.state.chapters = chapters.map((c,idx)=>({id:c.id||`C${idx+1}`, title:c.title||`Chapter ${idx+1}`}));
            // Optional: pick title and genre from constraints text if present
            this.updateBookMeta(this.deriveTitleFromPrompt(userPrompt), null);
            this.drawChapterList();
            this.setWorker('planner','ok','Plan created', 'Plan ready');
            this.addTranscript('Planner','All',`Planned ${this.state.chapters.length} chapters.`, false);
          } else {
            this.setWorker('planner','warn','Fallback plan', 'Using fallback');
            this.state.chapters = Array.from({length:this.state.targetChapters},(_,i)=>({id:`C${i+1}`, title:`Chapter ${i+1}`}));
            this.drawChapterList();
          }

          await this.waitIfPausedOrAborted();

          // Cycles
          for (let cycle = 1; cycle <= this.state.maxCycles; cycle++) {
            this.state.cycle = cycle;
            this.setPhase(`Cycle ${cycle} — Chapter Production`);
            this.overseerThink(`Cycle ${cycle} started`);

            // Per chapter pipeline
            for (const ch of this.state.chapters) {
              await this.waitIfPausedOrAborted();

              // Research
              this.setWorker('researcher','warn',`Researching ${ch.title}`, 'Collecting sources');
              const research = await this.callAI('researcher', this.pResearch(ch, userPrompt));
              this.state.research[ch.id] = research;
              this.setWorker('researcher','ok',`Research ready`, null);
              this.addTranscript('Researcher','Outliner',`Brief for ${ch.title} prepared`, false);

              await this.waitIfPausedOrAborted();

              // Outline
              this.setWorker('outliner','warn',`Outlining ${ch.title}`, 'Structuring beats');
              const outline = await this.callAI('outliner', this.pOutline(ch, research));
              this.state.outlines[ch.id] = outline;
              this.setWorker('outliner','ok','Outline ready', null);
              this.addTranscript('Outliner','Writer',`Outline for ${ch.title} ready`, false);

              await this.waitIfPausedOrAborted();

              // Write
              this.setWorker('writer','warn',`Writing ${ch.title}`, 'Drafting prose');
              const writerText = await this.callAI('writer', this.pWrite(ch, outline, (this.state.plan && this.state.plan.constraints)||[]));
              this.state.drafts[ch.id] = writerText;
              const wordsDraft = (writerText || '').split(/\s+/).filter(Boolean).length;
              this.setChapterProgress(ch.id, 55, wordsDraft);
              this.setWorker('writer','ok','Draft complete', null);
              this.addTranscript('Writer','Editor',`${ch.title} draft complete (${wordsDraft} words)`, false);
              this.updateWordCount();

              await this.waitIfPausedOrAborted();

              // Edit
              this.setWorker('editor','warn',`Editing ${ch.title}`, 'Improving clarity');
              const editText = await this.callAI('editor', this.pEdit(ch, writerText));
              this.state.edits[ch.id] = editText;
              const cleaned = this.extractFinalFromEditor(editText) || writerText;
              const wordsClean = (cleaned || '').split(/\s+/).filter(Boolean).length;
              this.setChapterProgress(ch.id, 72, wordsClean);
              this.setWorker('editor','ok','Edited', null);
              this.addTranscript('Editor','Fact Checker',`${ch.title} edited`, false);
              this.updateWordCount();

              await this.waitIfPausedOrAborted();

              // Fact
              this.setWorker('fact','warn',`Fact-checking ${ch.title}`, 'Validating claims');
              const factText = await this.callAI('factchecker', this.pFact(ch, cleaned));
              this.state.factChecks[ch.id] = factText;
              const corrected = this.extractCorrectedFinal(factText) || cleaned;
              const wordsCorr = (corrected || '').split(/\s+/).filter(Boolean).length;
              this.setChapterProgress(ch.id, 82, wordsCorr);
              this.setWorker('fact','ok','Facts verified', null);
              this.addTranscript('Fact Checker','QA',`${ch.title} checked`, false);
              this.updateWordCount();

              await this.waitIfPausedOrAborted();

              // QA
              this.setWorker('qa','warn',`QA gating ${ch.title}`, 'Evaluating constraints');
              const qaText = await this.callAI('qa', this.pQA(ch, corrected, JSON.stringify((this.state.plan && this.state.plan.constraints)||[])));
              const qaJSON = this.parseJSON(qaText) || { status:'APPROVE', reasons:[], actions:[] };
              this.state.approvals[ch.id] = qaJSON;
              if (qaJSON.status === 'APPROVE') {
                this.state.finals[ch.id] = corrected;
                this.setChapterProgress(ch.id, 100, wordsCorr);
                this.setWorker('qa','ok','Approved', 'Pass');
              } else {
                // quick revision loop
                this.setWorker('editor','warn',`Revising ${ch.title}`, 'Applying QA fixes');
                const revision = await this.callAI('editor', `ROLE: Editor
Revise the chapter according to actions:
${JSON.stringify(qaJSON.actions||[], null, 2)}

Chapter:
${corrected}

Return only the revised markdown chapter.`);
                this.state.finals[ch.id] = revision || corrected;
                const w = (this.state.finals[ch.id] || '').split(/\s+/).filter(Boolean).length;
                this.setChapterProgress(ch.id, 100, w);
                this.setWorker('editor','ok','Revised', null);
                this.setWorker('qa','ok','Approved', 'Pass after fix');
              }
              this.addTranscript('QA','All',`${ch.title} ${this.state.approvals[ch.id].status}`, false);
              this.updateWordCount();
            }

            await this.waitIfPausedOrAborted();

            // Compile
            this.setPhase(`Cycle ${cycle} — Compile Manuscript`);
            const title = this.deriveTitleFromPrompt(userPrompt);
            this.updateBookMeta(title, this.$('book-genre').textContent);
            const body = this.state.chapters.map((c,i)=>`# Chapter ${i+1}: ${c.title}\n\n${this.state.finals[c.id] || this.state.drafts[c.id] || ''}`).join('\n\n---\n\n');
            const manuscript = `# ${title}\n\n## Table of Contents\n\n${this.state.chapters.map((c,i)=>`${i+1}. ${c.title}`).join('\n')}\n\n---\n\n${body}`;
            this.state.manuscript = manuscript;

            // Publisher
            this.setPhase(`Cycle ${cycle} — Publish Decision`);
            this.setWorker('publisher','warn','Evaluating manuscript', 'Checking ship readiness');
            const pubText = await this.callAI('publisher', this.pPublish(manuscript, JSON.stringify((this.state.plan && this.state.plan.constraints)||[])));
            const pubJSON = this.parseJSON(pubText) || { status:'APPROVE', reasons:[], actions:[] };
            this.addTranscript('Publisher','All',`Decision: ${pubJSON.status}`, true);
            if (pubJSON.status === 'APPROVE') {
              this.setWorker('publisher','ok','Ship-ready', 'Approved');
              this.setPhase(`Approved in cycle ${cycle}`);
              this.toast('Manuscript approved');
              break;
            } else {
              this.setWorker('publisher','warn','Revisions requested', 'See actions');
              if (cycle === this.state.maxCycles) {
                this.setPhase('Reached max cycles — needs revisions');
                this.toast('Max cycles reached. Revisions still requested.', 3500);
              } else {
                // apply global small revision pass
                const rev = await this.callAI('manuscript_editor', `ROLE: Editor
Apply these actions globally:
${JSON.stringify(pubJSON.actions||[], null, 2)}

Manuscript:
${manuscript}

Return only revised manuscript markdown.`);
                if (rev) this.state.manuscript = rev;
              }
            }
          }

          this.showLoader(false);
          this.openOutput();
          this.toast('Pipeline complete');

        } catch (e) {
          console.error('Pipeline failed', e);
          this.showLoader(false);
          this.toast('Pipeline failed. Check console.', 3500);
        }
      }

      /* ---------- Exports ---------- */
      downloadMarkdown() {
        const blob = new Blob([this.state.manuscript || ''], { type: 'text/markdown' });
        const url = URL.createObjectURL(blob); const a = document.createElement('a');
        a.href = url; a.download = 'manuscript.md'; document.body.appendChild(a); a.click(); a.remove();
        setTimeout(()=>URL.revokeObjectURL(url), 800);
      }
      exportBundle() {
        const bundle = {
          meta: {
            cycle: this.state.cycle,
            maxCycles: this.state.maxCycles,
            targetChapters: this.state.targetChapters,
            wordsPerChapter: this.state.wordsPerChapter,
            houseStyle: this.state.houseStyle
          },
          plan: this.state.plan,
          chapters: this.state.chapters,
          research: this.state.research,
          outlines: this.state.outlines,
          drafts: this.state.drafts,
          edits: this.state.edits,
          factChecks: this.state.factChecks,
          finals: this.state.finals,
          approvals: this.state.approvals,
          manuscript: this.state.manuscript
        };
        const blob = new Blob([JSON.stringify(bundle, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob); const a = document.createElement('a');
        a.href = url; a.download = 'abf-bundle.json'; document.body.appendChild(a); a.click(); a.remove();
        setTimeout(()=>URL.revokeObjectURL(url), 800);
      }
    }

    // Boot
    window.addEventListener('DOMContentLoaded', () => {
      window.bookFactory = new VisualBookFactory();
    });

    // Helpers to wire buttons to app methods
    document.addEventListener('click', (e) => {
      const id = e.target.id;
      if (!window.bookFactory) return;
      if (id === 'open-output') window.bookFactory.openOutput();
      if (id === 'close-output') window.bookFactory.toggleOutput(false);
      if (id === 'close-transcript') window.bookFactory.toggleTranscript(false);
      if (id === 'open-settings') window.bookFactory.toggleSettings(true);
    });
  </script>
</body>
</html>
