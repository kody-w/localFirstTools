<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="description" content="Enhanced Multi-User Chat Application with Voice Support, Gesture Controls and Show Mode">
    <meta name="theme-color" content="#742774">
    <title>Chat Application with Collab Mode</title>

    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/github-dark.min.css" rel="stylesheet">

    <style>
        :root {
            --primary: #742774;
            --primary-light: #9168b6;
            --primary-dark: #4f1c4f;
            --primary-rgb: 116, 39, 116;
            --secondary: #00BCD4;
            --secondary-light: #4DD0E1;
            --accent: #FF4081;
            --success: #4caf50;
            --error: #f44336;
            --warning: #ff9800;
            --info: #2196f3;
            --show-mode: #00ffff;
            --show-mode-rgb: 0, 255, 255;
            --collab-mode: #00ff88;
            --collab-mode-rgb: 0, 255, 136;

            --gray-10: #faf9f8;
            --gray-20: #f3f2f1;
            --gray-30: #edebe9;
            --gray-40: #e1dfdd;
            --gray-50: #d2d0ce;
            --gray-60: #c8c6c4;
            --gray-80: #605e5c;
            --gray-100: #323130;
            --gray-130: #242424;

            --space-xs: 4px;
            --space-s: 8px;
            --space-m: 16px;
            --space-l: 24px;
            --space-xl: 32px;
            --space-xxl: 48px;

            --radius: 8px;
            --radius-small: 4px;
            --radius-large: 16px;
            --radius-full: 9999px;

            --shadow-small: 0 2px 8px rgba(0, 0, 0, 0.08);
            --shadow-medium: 0 4px 16px rgba(0, 0, 0, 0.12);
            --shadow-large: 0 8px 32px rgba(0, 0, 0, 0.16);

            --header-height: 56px;
            --input-container-height: 80px;
            --safe-area-top: env(safe-area-inset-top);
            --safe-area-bottom: env(safe-area-inset-bottom);

            --transition: all 0.2s ease;
        }

        /* Dark mode variables */
        body.dark {
            --gray-10: #1a1a1a;
            --gray-20: #242424;
            --gray-30: #2d2d2d;
            --gray-40: #373737;
            --gray-50: #424242;
            --gray-60: #4d4d4d;
            --gray-80: #8a8a8a;
            --gray-100: #e0e0e0;
            --gray-130: #f5f5f5;
            --primary-light: #a47cc9;
            --shadow-small: 0 2px 8px rgba(0, 0, 0, 0.3);
            --shadow-medium: 0 4px 16px rgba(0, 0, 0, 0.4);
            --shadow-large: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            -webkit-tap-highlight-color: transparent;
        }

        /* Allow text selection globally */
        body, div, span, p, h1, h2, h3, h4, h5, h6, code, pre {
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
            user-select: text;
        }

        /* Only disable selection for interactive elements */
        button, .button, .fab, label, .clickable {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        html, body {
            height: 100%;
            overflow: hidden;
            position: fixed;
            width: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: var(--gray-10);
            color: var(--gray-100);
            line-height: 1.6;
            -webkit-font-smoothing: antialiased;
        }

        /* Gesture Camera Feed */
        .gesture-camera-container {
            position: fixed;
            bottom: calc(var(--input-container-height) + var(--safe-area-bottom) + 20px);
            left: 20px;
            width: 240px;
            height: 180px;
            background: #000;
            border-radius: var(--radius);
            overflow: hidden;
            box-shadow: var(--shadow-large);
            z-index: 45;
            display: none;
            border: 2px solid var(--collab-mode);
        }

        .gesture-camera-container.active {
            display: block;
        }

        .gesture-camera-container video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }

        .gesture-camera-container canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
        }

        .gesture-status {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 4px 8px;
            border-radius: var(--radius-small);
            font-size: 12px;
            font-weight: bold;
        }

        .gesture-hint {
            position: absolute;
            bottom: 10px;
            left: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: var(--collab-mode);
            padding: 8px;
            border-radius: var(--radius-small);
            font-size: 11px;
            text-align: center;
        }

        /* Collab Mode Indicator */
        .collab-mode-indicator {
            position: fixed;
            top: calc(var(--header-height) + var(--safe-area-top) + 10px);
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(45deg, var(--collab-mode), #00ffaa);
            color: #000;
            padding: 8px 20px;
            border-radius: var(--radius-full);
            display: none;
            align-items: center;
            gap: 8px;
            z-index: 95;
            font-weight: bold;
            font-size: 14px;
            animation: pulseCollab 2s infinite;
            box-shadow: 0 0 20px rgba(var(--collab-mode-rgb), 0.5);
        }

        .collab-mode-indicator.active {
            display: flex;
        }

        .collab-mode-indicator i {
            animation: spin 3s linear infinite;
        }

        @keyframes pulseCollab {
            0%, 100% { 
                opacity: 0.95; 
                transform: translateX(-50%) scale(1);
            }
            50% { 
                opacity: 1; 
                transform: translateX(-50%) scale(1.05);
            }
        }

        /* Collab Mode Button */
        .collab-mode-button {
            position: fixed;
            bottom: calc(var(--safe-area-bottom) + var(--input-container-height) + 200px);
            right: calc(var(--space-l));
            width: 56px;
            height: 56px;
            background: linear-gradient(45deg, var(--collab-mode), #00ffaa);
            border: none;
            border-radius: var(--radius-full);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: var(--transition);
            z-index: 45;
            box-shadow: 0 0 20px rgba(var(--collab-mode-rgb), 0.3);
        }

        .collab-mode-button:hover {
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(var(--collab-mode-rgb), 0.5);
        }

        .collab-mode-button.active {
            animation: rotateCollab 2s linear infinite;
            background: linear-gradient(45deg, #ff0088, #ff00ff);
        }

        @keyframes rotateCollab {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .collab-mode-button svg {
            width: 24px;
            height: 24px;
            color: white;
        }

        /* Gesture Feedback */
        .gesture-feedback {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: var(--collab-mode);
            padding: 20px 40px;
            border-radius: var(--radius-large);
            font-size: 24px;
            font-weight: bold;
            z-index: 2000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            border: 2px solid var(--collab-mode);
            text-align: center;
        }

        .gesture-feedback.show {
            opacity: 1;
        }

        .gesture-feedback i {
            display: block;
            font-size: 48px;
            margin-bottom: 10px;
        }

        /* Agent Output Styles */
        .agent-output-wrapper {
            margin: var(--space-m) 0;
            background: rgba(var(--primary-rgb), 0.05);
            border: 1px solid rgba(var(--primary-rgb), 0.15);
            border-radius: var(--radius);
            overflow: hidden;
            transition: var(--transition);
        }

        body.dark .agent-output-wrapper {
            background: rgba(var(--primary-rgb), 0.1);
            border-color: rgba(var(--primary-rgb), 0.2);
        }

        .agent-output-header {
            padding: var(--space-m);
            background: rgba(var(--primary-rgb), 0.08);
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            user-select: none;
            transition: var(--transition);
        }

        body.dark .agent-output-header {
            background: rgba(var(--primary-rgb), 0.15);
        }

        .agent-output-header:hover {
            background: rgba(var(--primary-rgb), 0.12);
        }

        body.dark .agent-output-header:hover {
            background: rgba(var(--primary-rgb), 0.2);
        }

        .agent-output-title {
            display: flex;
            align-items: center;
            gap: var(--space-s);
            font-size: 14px;
            font-weight: 600;
            color: var(--primary);
        }

        .agent-output-title i {
            font-size: 16px;
        }

        .agent-output-toggle {
            background: none;
            border: none;
            color: var(--gray-60);
            cursor: pointer;
            transition: var(--transition);
            padding: 4px;
        }

        .agent-output-toggle:hover {
            color: var(--primary);
        }

        .agent-output-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .agent-output-content.expanded {
            max-height: 1000px;
            overflow-y: auto;
        }

        .agent-output-text {
            padding: var(--space-m);
            font-family: monospace;
            font-size: 13px;
            color: var(--gray-80);
            white-space: pre-wrap;
            word-wrap: break-word;
            line-height: 1.5;
        }

        body.dark .agent-output-text {
            color: var(--gray-100);
        }

        /* Link Preview Styles */
        .link-preview-wrapper {
            margin: var(--space-m) 0;
            border: 1px solid var(--gray-30);
            border-radius: var(--radius);
            overflow: hidden;
            background: var(--gray-20);
        }

        body.dark .link-preview-wrapper {
            background: var(--gray-40);
            border-color: var(--gray-50);
        }

        .link-preview-header {
            padding: var(--space-s) var(--space-m);
            background: var(--gray-30);
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            user-select: none;
        }

        body.dark .link-preview-header {
            background: var(--gray-50);
        }

        .link-preview-header:hover {
            background: var(--gray-40);
        }

        body.dark .link-preview-header:hover {
            background: var(--gray-60);
        }

        .link-preview-url {
            display: flex;
            align-items: center;
            gap: var(--space-s);
            font-size: 14px;
            color: var(--primary);
            text-decoration: none;
            flex: 1;
        }

        .link-preview-url:hover {
            text-decoration: underline;
        }

        .link-preview-url i {
            font-size: 12px;
        }

        .link-preview-toggle {
            background: none;
            border: none;
            color: var(--gray-60);
            cursor: pointer;
            transition: var(--transition);
        }

        .link-preview-toggle:hover {
            color: var(--gray-100);
        }

        .link-preview-content {
            height: 0;
            overflow: hidden;
            transition: height 0.3s ease;
        }

        .link-preview-content.expanded {
            height: 400px;
        }

        .link-preview-iframe {
            width: 100%;
            height: 100%;
            border: none;
            background: white;
        }

        body.dark .link-preview-iframe {
            background: var(--gray-20);
        }

        .link-preview-error {
            padding: var(--space-xl);
            text-align: center;
            color: var(--gray-60);
        }

        .link-preview-error i {
            font-size: 48px;
            margin-bottom: var(--space-m);
            display: block;
            opacity: 0.5;
        }

        /* Show Mode Elements */
        .show-mode-button {
            position: fixed;
            bottom: calc(var(--safe-area-bottom) + var(--input-container-height) + 140px);
            right: calc(var(--space-l));
            width: 56px;
            height: 56px;
            background: rgba(var(--show-mode-rgb), 0.2);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(var(--show-mode-rgb), 0.5);
            border-radius: var(--radius-full);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: var(--transition);
            z-index: 45;
            box-shadow: 0 0 20px rgba(var(--show-mode-rgb), 0.3);
        }

        .show-mode-button:hover {
            background: rgba(var(--show-mode-rgb), 0.4);
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(var(--show-mode-rgb), 0.5);
        }

        .show-mode-button.active {
            background: rgba(0, 255, 0, 0.3);
            border-color: rgba(0, 255, 0, 0.5);
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
        }

        .show-mode-button svg {
            width: 24px;
            height: 24px;
            color: white;
        }

        /* Show Mode Status */
        .show-mode-status {
            position: fixed;
            top: calc(var(--header-height) + var(--safe-area-top) + 10px);
            right: var(--space-l);
            background: rgba(0, 0, 0, 0.8);
            padding: 8px 16px;
            border-radius: var(--radius-full);
            display: flex;
            align-items: center;
            gap: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            z-index: 95;
            opacity: 0;
            visibility: hidden;
            transition: var(--transition);
        }

        .show-mode-status.visible {
            opacity: 1;
            visibility: visible;
        }

        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #888;
            transition: var(--transition);
        }

        .status-indicator.connected {
            background: #00ff00;
            box-shadow: 0 0 10px #00ff00;
        }

        .status-indicator.hosting {
            background: #06ffa5;
            box-shadow: 0 0 10px #06ffa5;
        }

        .status-text {
            color: rgba(255, 255, 255, 0.8);
            font-size: 13px;
        }

        .viewer-count {
            color: #06ffa5;
            font-weight: bold;
            font-size: 13px;
        }

        /* Viewer Mode Indicator */
        .viewer-mode-indicator {
            position: fixed;
            top: calc(var(--header-height) + var(--safe-area-top) + 10px);
            left: var(--space-l);
            background: rgba(138, 43, 226, 0.9);
            color: white;
            padding: 8px 16px;
            border-radius: var(--radius-full);
            display: none;
            align-items: center;
            gap: 8px;
            z-index: 95;
            font-weight: 500;
            font-size: 13px;
            animation: pulse 2s infinite;
        }

        .viewer-mode-indicator.active {
            display: flex;
        }

        .viewer-mode-indicator svg {
            width: 16px;
            height: 16px;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.9; }
            50% { opacity: 0.6; }
        }

        /* Show Mode Modal */
        .show-mode-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 2000;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(5px);
        }

        .show-mode-modal.show {
            display: flex;
        }

        .show-mode-modal-content {
            background: rgba(20, 20, 40, 0.95);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: var(--radius-large);
            padding: 30px;
            max-width: 400px;
            width: 90%;
            text-align: center;
            position: relative;
            box-shadow: 0 0 50px rgba(var(--show-mode-rgb), 0.3);
        }

        .modal-close {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            font-size: 30px;
            cursor: pointer;
            color: #fff;
            transition: var(--transition);
        }

        .modal-close:hover {
            color: #ff006e;
            transform: rotate(90deg);
        }

        .show-mode-modal h3 {
            margin: 0 0 20px 0;
            font-size: 24px;
            background: linear-gradient(45deg, #00ffff, #0088ff, #06ffa5);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .show-mode-info {
            background: rgba(var(--show-mode-rgb), 0.1);
            border: 1px solid rgba(var(--show-mode-rgb), 0.3);
            border-radius: var(--radius);
            padding: 10px;
            margin: 15px 0;
            font-size: 14px;
            color: #06ffa5;
        }

        #qr-code-container {
            margin: 20px auto;
            display: flex;
            justify-content: center;
            padding: 20px;
            background: white;
            border-radius: 15px;
        }

        #qr-code-container canvas,
        #qr-code-container img {
            border-radius: 10px;
        }

        .qr-url {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            word-break: break-all;
            margin: 20px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            font-family: monospace;
        }

        .copy-url-btn {
            background: linear-gradient(45deg, #00ffff, #0088ff);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            font-weight: bold;
            cursor: pointer;
            transition: var(--transition);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .copy-url-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(var(--show-mode-rgb), 0.4);
        }

        .copy-url-btn.copied {
            background: linear-gradient(45deg, #06ffa5, #00ff88);
        }

        /* Show Mode Notifications */
        .show-mode-notification {
            position: fixed;
            top: 100px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 15px 25px;
            border-radius: var(--radius);
            border: 2px solid rgba(var(--show-mode-rgb), 0.5);
            animation: slideIn 0.3s ease;
            z-index: 1010;
            backdrop-filter: blur(10px);
        }

        /* Viewer Chat Label */
        .viewer-chat-label {
            background: rgba(var(--show-mode-rgb), 0.2);
            color: var(--show-mode);
            padding: 4px 12px;
            border-radius: var(--radius-full);
            font-size: 11px;
            margin-left: 10px;
            display: none;
        }

        .viewer-chat-label.active {
            display: inline-block;
        }

        /* Viewer Message Styling */
        .message-wrapper.viewer-message {
            border-left: 3px solid var(--show-mode);
            padding-left: var(--space-s);
            margin-left: var(--space-s);
        }

        .message-wrapper.viewer-message .message-label {
            color: var(--show-mode);
        }

        .message-wrapper.viewer-message::before {
            content: attr(data-viewer-name);
            display: block;
            font-size: 11px;
            color: var(--show-mode);
            margin-bottom: 4px;
            opacity: 0.8;
        }

        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes scaleIn {
            from {
                opacity: 0;
                transform: scale(0.9);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* Login Page */
        .login-container {
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            padding: var(--space-m);
            animation: fadeIn 0.5s ease-out;
        }

        .login-box {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            padding: var(--space-xl);
            border-radius: var(--radius-large);
            box-shadow: var(--shadow-large);
            width: 100%;
            max-width: 420px;
            animation: scaleIn 0.5s ease-out;
        }

        body.dark .login-box {
            background: rgba(36, 36, 36, 0.95);
        }

        .login-header {
            text-align: center;
            margin-bottom: var(--space-xl);
        }

        .login-header h1 {
            color: var(--primary);
            font-size: 32px;
            font-weight: 700;
            margin-bottom: var(--space-s);
        }

        .login-header p {
            color: var(--gray-80);
            opacity: 0.8;
            font-size: 16px;
        }

        .form-group {
            margin-bottom: var(--space-l);
        }

        .form-group label {
            display: block;
            font-size: 14px;
            font-weight: 600;
            color: var(--gray-80);
            margin-bottom: var(--space-s);
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 14px 18px;
            border: 2px solid var(--gray-30);
            border-radius: var(--radius);
            font-size: 16px;
            transition: var(--transition);
            background: var(--gray-20);
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: var(--primary);
            background: white;
            box-shadow: 0 0 0 3px rgba(var(--primary-rgb), 0.1);
        }

        body.dark .form-group input:focus,
        body.dark .form-group select:focus {
            background: var(--gray-30);
        }

        .login-button {
            width: 100%;
            background: var(--primary);
            color: white;
            border: none;
            padding: 14px 28px;
            border-radius: var(--radius);
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition);
            margin-top: var(--space-m);
        }

        .login-button:hover {
            background: var(--primary-dark);
            transform: translateY(-1px);
        }

        .user-list {
            margin-top: var(--space-xl);
            padding-top: var(--space-xl);
            border-top: 1px solid var(--gray-30);
        }

        .user-list h3 {
            font-size: 16px;
            color: var(--gray-80);
            margin-bottom: var(--space-m);
            font-weight: 600;
        }

        .user-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: var(--space-m);
            background: var(--gray-20);
            border-radius: var(--radius);
            margin-bottom: var(--space-s);
            cursor: pointer;
            transition: var(--transition);
        }

        .user-item:hover {
            background: var(--gray-30);
            transform: translateX(4px);
        }

        /* Main App Container */
        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            background: var(--gray-10);
            overflow: hidden;
        }

        /* Header */
        .header {
            background: white;
            color: var(--gray-100);
            padding: 0 var(--space-m);
            padding-top: var(--safe-area-top);
            height: calc(var(--header-height) + var(--safe-area-top));
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: var(--shadow-small);
            z-index: 100;
            flex-shrink: 0;
        }

        body.dark .header {
            background: var(--gray-20);
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: var(--space-m);
        }

        .header-title {
            font-size: 18px;
            font-weight: 600;
            display: flex;
            align-items: center;
        }

        .header-actions {
            display: flex;
            align-items: center;
            gap: var(--space-s);
        }

        .header-button {
            background: transparent;
            border: none;
            color: var(--gray-80);
            width: 40px;
            height: 40px;
            border-radius: var(--radius);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: var(--transition);
            font-size: 18px;
        }

        .header-button:hover {
            background: var(--gray-20);
            color: var(--primary);
        }

        /* Voice indicator in header */
        .voice-indicator {
            display: none;
            align-items: center;
            gap: var(--space-s);
            padding: 6px 12px;
            background: var(--primary);
            color: white;
            border-radius: var(--radius-full);
            font-size: 13px;
            font-weight: 500;
            animation: fadeIn 0.3s ease-out;
        }

        .voice-indicator.active {
            display: flex;
        }

        .voice-indicator i {
            font-size: 14px;
            animation: pulse 1.5s infinite;
        }

        /* Sidebar */
        .sidebar {
            position: fixed;
            left: 0;
            top: 0;
            bottom: 0;
            width: 85%;
            max-width: 340px;
            background: white;
            box-shadow: var(--shadow-large);
            transform: translateX(-100%);
            transition: transform 0.3s ease;
            z-index: 200;
            overflow-y: auto;
        }

        body.dark .sidebar {
            background: var(--gray-20);
        }

        .sidebar.open {
            transform: translateX(0);
        }

        .sidebar-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            opacity: 0;
            visibility: hidden;
            transition: var(--transition);
            z-index: 190;
        }

        .sidebar-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .sidebar-header {
            padding: var(--space-l);
            padding-top: calc(var(--space-l) + var(--safe-area-top));
            border-bottom: 1px solid var(--gray-30);
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: var(--primary);
            color: white;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .sidebar-header h2 {
            font-size: 20px;
            font-weight: 600;
        }

        .sidebar-tabs {
            display: flex;
            background: var(--gray-10);
            position: sticky;
            top: calc(80px + var(--safe-area-top));
            z-index: 9;
        }

        body.dark .sidebar-tabs {
            background: var(--gray-30);
        }

        .sidebar-tab {
            flex: 1;
            padding: var(--space-m);
            background: none;
            border: none;
            color: var(--gray-60);
            cursor: pointer;
            transition: var(--transition);
            border-bottom: 3px solid transparent;
            font-size: 15px;
            font-weight: 500;
        }

        .sidebar-tab:hover {
            color: var(--gray-100);
        }

        .sidebar-tab.active {
            color: var(--primary);
            border-bottom-color: var(--primary);
        }

        .chat-list {
            padding: var(--space-m);
            min-height: 300px;
        }

        .chat-list-empty {
            padding: var(--space-xl);
            text-align: center;
            color: var(--gray-60);
        }

        .chat-item {
            padding: var(--space-m);
            border-radius: var(--radius);
            margin-bottom: var(--space-s);
            cursor: pointer;
            transition: var(--transition);
            position: relative;
            background: var(--gray-10);
        }

        body.dark .chat-item {
            background: var(--gray-30);
        }

        .chat-item:hover {
            background: var(--gray-20);
            transform: translateX(4px);
        }

        body.dark .chat-item:hover {
            background: var(--gray-40);
        }

        .chat-item.active {
            background: rgba(var(--primary-rgb), 0.08);
            border-left: 3px solid var(--primary);
        }

        .chat-item-title {
            font-weight: 600;
            color: var(--gray-100);
            margin-bottom: var(--space-xs);
            padding-right: 60px;
        }

        .chat-item-preview {
            font-size: 14px;
            color: var(--gray-60);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .chat-item-date {
            font-size: 12px;
            color: var(--gray-60);
            margin-top: var(--space-xs);
        }

        .chat-item-actions {
            position: absolute;
            top: var(--space-m);
            right: var(--space-m);
            display: flex;
            gap: var(--space-xs);
            opacity: 0;
            transition: var(--transition);
        }

        .chat-item:hover .chat-item-actions {
            opacity: 1;
        }

        .chat-item-action {
            background: var(--gray-30);
            border: none;
            color: var(--gray-80);
            width: 32px;
            height: 32px;
            border-radius: var(--radius-small);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: var(--transition);
        }

        .chat-item-action:hover {
            background: var(--primary);
            color: white;
        }

        /* Chat Container */
        .chat-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            background: var(--gray-10);
        }

        body.dark .chat-container {
            background: var(--gray-10);
        }

        .chat-messages-wrapper {
            flex: 1;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: var(--space-l);
            padding-bottom: calc(var(--input-container-height) + var(--safe-area-bottom) + 100px);
            padding-right: calc(var(--space-l) + 80px);
            scroll-behavior: smooth;
        }

        /* Messages - Allow text selection */
        .message-wrapper {
            margin: var(--space-m) 0;
            animation: slideUp 0.3s ease-out;
            max-width: 85%;
        }

        .message-wrapper.user {
            margin-left: auto;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
        }

        .message-wrapper.assistant {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }

        .message-label {
            font-size: 13px;
            color: var(--gray-60);
            margin-bottom: var(--space-xs);
            font-weight: 500;
            padding: 0 var(--space-m);
        }

        .message-content {
            padding: 14px 20px;
            border-radius: var(--radius-large);
            word-wrap: break-word;
            overflow-wrap: break-word;
            font-size: 15px;
            line-height: 1.6;
            box-shadow: var(--shadow-small);
            transition: var(--transition);
            /* Enable text selection */
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
            user-select: text;
            cursor: text;
        }

        .user .message-content {
            background: var(--primary);
            color: white;
            border-bottom-right-radius: var(--space-xs);
        }

        .assistant .message-content {
            background: white;
            color: var(--gray-100);
            border-bottom-left-radius: var(--space-xs);
        }

        body.dark .assistant .message-content {
            background: var(--gray-30);
        }

        .system-message {
            background: rgba(var(--primary-rgb), 0.05);
            padding: var(--space-m);
            border-radius: var(--radius);
            margin: var(--space-l) auto;
            width: 90%;
            font-family: monospace;
            font-size: 13px;
            border: 1px solid rgba(var(--primary-rgb), 0.1);
            color: var(--gray-80);
            word-wrap: break-word;
            overflow-wrap: break-word;
            white-space: pre-wrap;
            /* Enable text selection */
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
            user-select: text;
            cursor: text;
        }

        body.dark .system-message {
            background: rgba(var(--primary-rgb), 0.1);
            color: var(--gray-100);
        }

        /* Voice message indicator */
        .voice-message {
            display: none;
            align-items: center;
            gap: var(--space-s);
            margin-top: var(--space-s);
            padding: 8px 12px;
            background: rgba(var(--primary-rgb), 0.1);
            border-radius: var(--radius);
            font-size: 13px;
            color: var(--primary);
        }

        .voice-message.active {
            display: flex;
        }

        .voice-message i {
            font-size: 14px;
        }

        .message-content pre {
            background: var(--gray-20);
            padding: var(--space-m);
            border-radius: var(--radius);
            overflow-x: auto;
            margin: var(--space-s) 0;
            font-size: 13px;
            /* Enable text selection */
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
            user-select: text;
        }

        body.dark .message-content pre {
            background: var(--gray-10);
        }

        .message-content code {
            background: rgba(var(--primary-rgb), 0.1);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 13px;
            /* Enable text selection */
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
            user-select: text;
        }

        .user .message-content pre,
        .user .message-content code {
            background: rgba(255, 255, 255, 0.15);
        }

        /* Loading Animation - Matching Copilot for Sales Voice */
        .loading {
            display: none !important;
            margin: var(--space-m) 0;
            margin-right: auto;
            max-width: 80px;
            background: var(--gray-20);
            padding: 14px 20px;
            border-radius: var(--radius-large);
            border-bottom-left-radius: var(--space-xs);
            box-shadow: var(--shadow-small);
        }

        body.dark .loading {
            background: var(--gray-30);
        }

        .loading.active {
            display: flex !important;
            align-items: center;
            justify-content: center;
            gap: var(--space-s);
            animation: slideUp 0.3s ease-out;
        }

        .loading span {
            width: 8px;
            height: 8px;
            background: var(--gray-60);
            border-radius: 50%;
            display: inline-block;
            animation: bounce 0.8s infinite;
        }

        body.dark .loading span {
            background: var(--gray-80);
        }

        .loading span:nth-child(2) {
            animation-delay: 0.2s;
        }

        .loading span:nth-child(3) {
            animation-delay: 0.4s;
        }

        /* Ensure only one loading indicator at a time */
        .chat-messages .loading + .loading {
            display: none !important;
        }

        @keyframes bounce {
            0%, 100% {
                transform: translateY(0);
            }
            50% {
                transform: translateY(-6px);
            }
        }

        /* Input Container */
        .input-container {
            background: white;
            border-top: 1px solid var(--gray-30);
            padding: var(--space-m);
            padding-bottom: calc(var(--space-m) + var(--safe-area-bottom));
            display: flex;
            gap: var(--space-s);
            align-items: flex-end;
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 50;
            min-height: var(--input-container-height);
        }

        body.dark .input-container {
            background: var(--gray-20);
        }

        /* Viewer mode input styling */
        .input-container.viewer-mode {
            border-top: 2px solid var(--show-mode);
        }

        .input-wrapper {
            flex: 1;
            position: relative;
        }

        .input-field {
            width: 100%;
            padding: 12px 18px;
            border: 2px solid var(--gray-30);
            border-radius: var(--radius-full);
            font-size: 16px;
            resize: none;
            outline: none;
            transition: var(--transition);
            background: var(--gray-10);
            min-height: 44px;
            max-height: 120px;
            font-family: inherit;
        }

        body.dark .input-field {
            background: var(--gray-30);
            color: var(--gray-100);
        }

        .input-field:focus {
            border-color: var(--primary);
            background: white;
            box-shadow: 0 0 0 3px rgba(var(--primary-rgb), 0.1);
        }

        body.dark .input-field:focus {
            background: var(--gray-40);
        }

        /* Viewer mode focus */
        .viewer-mode .input-field:focus {
            border-color: var(--show-mode);
            box-shadow: 0 0 0 3px rgba(var(--show-mode-rgb), 0.1);
        }

        .input-button {
            background: var(--primary);
            color: white;
            border: none;
            width: 44px;
            height: 44px;
            border-radius: var(--radius-full);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: var(--transition);
            font-size: 18px;
        }

        .input-button:hover {
            background: var(--primary-dark);
            transform: translateY(-1px);
        }

        .input-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .input-button.secondary {
            background: var(--gray-30);
            color: var(--gray-80);
        }

        body.dark .input-button.secondary {
            background: var(--gray-40);
            color: var(--gray-100);
        }

        /* Voice button */
        .voice-button {
            background: var(--accent);
            color: white;
        }

        .voice-button:hover {
            background: var(--accent);
            transform: scale(1.1);
        }

        .voice-button.active {
            background: var(--error);
            animation: pulse 1.5s infinite;
        }

        /* Image Preview */
        .image-preview-container {
            position: absolute;
            bottom: 100%;
            left: 0;
            right: 0;
            padding: var(--space-m);
            background: white;
            border: 2px solid var(--gray-30);
            border-radius: var(--radius);
            margin-bottom: var(--space-s);
            display: none;
            box-shadow: var(--shadow-medium);
        }

        body.dark .image-preview-container {
            background: var(--gray-30);
        }

        .image-preview-container.active {
            display: block;
            animation: slideUp 0.3s ease-out;
        }

        .image-preview {
            position: relative;
            width: 100px;
            height: 100px;
            border-radius: var(--radius);
            overflow: hidden;
        }

        .image-preview img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .image-preview-remove {
            position: absolute;
            top: 4px;
            right: 4px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border: none;
            border-radius: var(--radius-full);
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        /* Float buttons - Fixed positioning */
        .float-buttons {
            position: fixed;
            bottom: calc(var(--input-container-height) + var(--safe-area-bottom) + 20px);
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            z-index: 45;
        }

        .fab {
            background: var(--primary);
            color: white;
            border: none;
            width: 56px;
            height: 56px;
            border-radius: var(--radius-full);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: var(--transition);
            box-shadow: var(--shadow-medium);
            font-size: 22px;
        }

        .fab:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-large);
        }

        .fab.secondary {
            background: var(--error);
        }

        .fab.menu {
            background: var(--accent);
        }

        .fab.menu.active {
            transform: rotate(45deg);
        }

        /* Menu Items */
        .menu-items {
            position: fixed;
            bottom: calc(var(--input-container-height) + var(--safe-area-bottom) + 200px);
            right: 20px;
            background: white;
            border-radius: var(--radius);
            box-shadow: var(--shadow-large);
            padding: var(--space-s);
            opacity: 0;
            visibility: hidden;
            transform: translateY(10px) scale(0.9);
            transition: var(--transition);
            z-index: 45;
            min-width: 220px;
        }

        body.dark .menu-items {
            background: var(--gray-30);
        }

        .menu-items.open {
            opacity: 1;
            visibility: visible;
            transform: translateY(0) scale(1);
        }

        .menu-item {
            display: flex;
            align-items: center;
            gap: var(--space-m);
            padding: 12px 16px;
            border-radius: var(--radius);
            cursor: pointer;
            transition: var(--transition);
            color: var(--gray-100);
            font-size: 15px;
            font-weight: 500;
        }

        .menu-item:hover {
            background: rgba(var(--primary-rgb), 0.08);
        }

        .menu-item i {
            width: 24px;
            text-align: center;
            color: var(--primary);
        }

        /* Modal */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: var(--space-m);
        }

        .modal.active {
            display: flex;
            animation: fadeIn 0.2s ease-out;
        }

        .modal-content {
            background: white;
            border-radius: var(--radius-large);
            box-shadow: var(--shadow-large);
            max-width: 500px;
            width: 100%;
            max-height: 85vh;
            overflow-y: auto;
            animation: scaleIn 0.3s ease-out;
        }

        body.dark .modal-content {
            background: var(--gray-20);
        }

        .modal-header {
            padding: var(--space-l);
            border-bottom: 1px solid var(--gray-30);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .modal-header h2 {
            font-size: 20px;
            color: var(--gray-100);
            font-weight: 600;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 24px;
            color: var(--gray-60);
            cursor: pointer;
            transition: var(--transition);
            padding: 0;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: var(--radius-full);
        }

        .modal-close:hover {
            background: var(--gray-20);
            color: var(--gray-100);
        }

        .modal-body {
            padding: var(--space-l);
        }

        .modal-footer {
            padding: var(--space-l);
            border-top: 1px solid var(--gray-30);
            display: flex;
            justify-content: flex-end;
            gap: var(--space-m);
        }

        .button {
            padding: 10px 20px;
            border-radius: var(--radius);
            border: none;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition);
            display: inline-flex;
            align-items: center;
            gap: var(--space-s);
        }

        .button-primary {
            background: var(--primary);
            color: white;
        }

        .button-primary:hover {
            background: var(--primary-dark);
        }

        .button-secondary {
            background: var(--gray-20);
            color: var(--gray-100);
        }

        body.dark .button-secondary {
            background: var(--gray-40);
        }

        /* Settings */
        .settings-section {
            margin-bottom: var(--space-xl);
            padding-bottom: var(--space-xl);
            border-bottom: 1px solid var(--gray-30);
        }

        .settings-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }

        .settings-section h3 {
            font-size: 18px;
            margin-bottom: var(--space-l);
            color: var(--gray-100);
            font-weight: 600;
        }

        .settings-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: var(--space-m) 0;
        }

        .settings-item label {
            font-size: 15px;
            color: var(--gray-80);
            font-weight: 500;
        }

        .toggle-switch {
            position: relative;
            width: 48px;
            height: 28px;
            background: var(--gray-30);
            border-radius: var(--radius-full);
            cursor: pointer;
            transition: var(--transition);
        }

        .toggle-switch.active {
            background: var(--success);
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            top: 3px;
            left: 3px;
            width: 22px;
            height: 22px;
            background: white;
            border-radius: var(--radius-full);
            transition: var(--transition);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .toggle-switch.active::after {
            transform: translateX(20px);
        }

        /* Drop Zone */
        .drop-zone {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(var(--primary-rgb), 0.95);
            backdrop-filter: blur(10px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .drop-zone.active {
            display: flex;
            animation: fadeIn 0.2s ease-out;
        }

        .drop-zone-content {
            text-align: center;
            color: white;
        }

        .drop-zone-content i {
            font-size: 72px;
            margin-bottom: var(--space-l);
        }

        .drop-zone-content p {
            font-size: 24px;
            font-weight: 600;
        }

        /* Utility Classes */
        .hidden {
            display: none !important;
        }

        .text-center {
            text-align: center;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .message-wrapper {
                max-width: 85%;
            }

            .modal-content {
                margin: 20px;
            }

            .show-mode-button {
                bottom: calc(var(--safe-area-bottom) + var(--input-container-height) + 120px);
                right: var(--space-m);
            }
            
            .collab-mode-button {
                bottom: calc(var(--safe-area-bottom) + var(--input-container-height) + 180px);
                right: var(--space-m);
            }
            
            .chat-messages {
                padding-right: calc(var(--space-m) + 70px);
            }

            .gesture-camera-container {
                width: 160px;
                height: 120px;
            }
        }

        /* iOS specific fixes */
        @supports (-webkit-touch-callout: none) {
            .app-container {
                height: -webkit-fill-available;
            }
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--gray-20);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--gray-50);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--gray-60);
        }

        /* Focus styles */
        *:focus-visible {
            outline: 2px solid var(--primary);
            outline-offset: 2px;
        }

        /* Hidden file inputs */
        input[type="file"] {
            display: none;
        }
    </style>
</head>
<body>
    <!-- Login Page -->
    <div id="login-page" class="login-container">
        <div class="login-box">
            <div class="login-header">
                <h1>Welcome Back</h1>
                <p>Sign in to continue your conversations</p>
            </div>

            <form id="login-form">
                <div class="form-group">
                    <label for="username">Username</label>
                    <input type="text" id="username" placeholder="Enter your username" required autocomplete="username" autocapitalize="off">
                </div>

                <button type="submit" class="login-button">
                    Sign In
                </button>
            </form>

            <div class="user-list">
                <h3>Recent Users</h3>
                <div id="recent-users"></div>
            </div>
        </div>
    </div>

    <!-- Main App -->
    <div id="app" class="app-container hidden">
        <!-- Header -->
        <header class="header">
            <div class="header-left">
                <button class="header-button" id="sidebar-toggle">
                    <i class="fas fa-bars"></i>
                </button><h1 class="header-title">
                    <span id="current-username">Chat</span>
                    <span class="viewer-chat-label" id="viewer-chat-label">Viewer Mode</span>
                </h1>
                <div class="voice-indicator" id="voice-indicator">
                    <i class="fas fa-volume-up"></i>
                    <span>Speaking...</span>
                </div>
            </div>
            <div class="header-actions">
                <button class="header-button" id="archive-chat">
                    <i class="fas fa-archive"></i>
                </button>
                <button class="header-button" id="theme-toggle">
                    <i class="fas fa-moon"></i>
                </button>
                <button class="header-button" id="logout">
                    <i class="fas fa-sign-out-alt"></i>
                </button>
            </div>
        </header>

        <!-- Collab Mode Indicator -->
        <div class="collab-mode-indicator" id="collab-mode-indicator">
            <i class="fas fa-hands-helping"></i>
            <span>Collab Mode Active</span>
        </div>

        <!-- Show Mode Status -->
        <div class="show-mode-status" id="show-mode-status">
            <div class="status-indicator" id="status-indicator"></div>
            <span class="status-text" id="status-text">Connecting...</span>
            <div class="viewer-count">
                <span id="viewer-count">0</span> viewers
            </div>
        </div>

        <!-- Viewer Mode Indicator -->
        <div class="viewer-mode-indicator" id="viewer-mode-indicator">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                <circle cx="12" cy="12" r="3"></circle>
            </svg>
            <span>Viewing Mode</span>
        </div>

        <!-- Sidebar -->
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <h2>Chat Library</h2>
                <button class="input-button" id="new-chat">
                    <i class="fas fa-plus"></i>
                </button>
            </div>
            <div class="sidebar-tabs">
                <button class="sidebar-tab active" data-tab="active">Active</button>
                <button class="sidebar-tab" data-tab="archived">Archived</button>
            </div>
            <div class="chat-list" id="chat-list-active"></div>
            <div class="chat-list hidden" id="chat-list-archived"></div>
        </aside>
        <div class="sidebar-overlay" id="sidebar-overlay"></div>

        <!-- Chat Container -->
        <main class="chat-container">
            <div class="chat-messages-wrapper">
                <div class="chat-messages" id="chat-messages">
                    <!-- Loading Indicator will be appended here dynamically -->
                </div>
            </div>
        </main>

        <!-- Gesture Camera Container -->
        <div class="gesture-camera-container" id="gesture-camera-container">
            <video id="gesture-video" autoplay playsinline></video>
            <canvas id="gesture-canvas"></canvas>
            <div class="gesture-status" id="gesture-status">Ready</div>
            <div class="gesture-hint" id="gesture-hint"> Open Palm = Send |  Peace = Voice |  Thumbs Up = Clear</div>
        </div>

        <!-- Gesture Feedback -->
        <div class="gesture-feedback" id="gesture-feedback">
            <i class="fas fa-hand-paper"></i>
            <span id="gesture-feedback-text">Gesture Detected</span>
        </div>

        <!-- Input Container -->
        <div class="input-container" id="input-container">
            <button class="input-button secondary" id="upload-image">
                <i class="fas fa-image"></i>
            </button>
            <button class="input-button voice-button" id="voice-toggle">
                <i class="fas fa-microphone"></i>
            </button>
            <div class="input-wrapper">
                <div class="image-preview-container" id="image-preview-container"></div>
                <textarea
                    class="input-field"
                    id="user-input"
                    placeholder="Type a message..."
                    rows="1"
                ></textarea>
            </div>
            <button class="input-button" id="send-button">
                <i class="fas fa-paper-plane"></i>
            </button>
        </div>

        <!-- Float Buttons -->
        <div class="float-buttons">
            <button class="fab secondary" id="clear-chat">
                <i class="fas fa-trash"></i>
            </button>
            <button class="fab menu" id="menu-toggle">
                <i class="fas fa-plus"></i>
            </button>
        </div>

        <!-- Collab Mode Button -->
        <div class="collab-mode-button" id="collab-mode-button">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M21 8.5C21 5.5 19 3.5 16 3.5C14.5 3.5 13.5 4 12 5C10.5 4 9.5 3.5 8 3.5C5 3.5 3 5.5 3 8.5C3 11.5 12 20.5 12 20.5S21 11.5 21 8.5Z"/>
            </svg>
        </div>

        <!-- Show Mode Button -->
        <div class="show-mode-button" id="show-mode-button">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                <circle cx="12" cy="12" r="3"></circle>
            </svg>
        </div>

        <!-- Menu Items -->
        <div class="menu-items" id="menu-items">
            <div class="menu-item" id="export-chat">
                <i class="fas fa-download"></i>
                <span>Export Chat</span>
            </div>
            <div class="menu-item" id="import-chat">
                <i class="fas fa-upload"></i>
                <span>Import Chat</span>
            </div>
            <div class="menu-item" id="export-all">
                <i class="fas fa-file-archive"></i>
                <span>Export All Data</span>
            </div>
            <div class="menu-item" id="import-all">
                <i class="fas fa-file-import"></i>
                <span>Import Data</span>
            </div>
            <div class="menu-item" id="time-machine">
                <i class="fas fa-history"></i>
                <span>Time Machine</span>
            </div>
            <div class="menu-item" id="settings">
                <i class="fas fa-cog"></i>
                <span>Settings</span>
            </div>
        </div>

        <!-- Drop Zone -->
        <div class="drop-zone" id="drop-zone">
            <div class="drop-zone-content">
                <i class="fas fa-cloud-upload-alt"></i>
                <p>Drop files here to import</p>
            </div>
        </div>
    </div>

    <!-- Show Mode Modal -->
    <div class="show-mode-modal" id="show-mode-modal">
        <div class="show-mode-modal-content">
            <button class="modal-close" id="show-mode-close">&times;</button>
            <h3>Show Mode</h3>
            <p style="color: rgba(255, 255, 255, 0.7); margin-bottom: 20px;">
                Share your chat in real-time. Others can scan the QR code to follow your conversation.
            </p>
            <div class="show-mode-info" id="show-mode-info">
                 Show Mode Active - Viewers will see your chat in real-time!
            </div>
            <div id="qr-code-container"></div>
            <p class="qr-url" id="qr-url"></p>
           <button class="copy-url-btn" id="copy-url-btn">Copy URL</button>
       </div>
   </div>

   <!-- Settings Modal -->
   <div class="modal" id="settings-modal">
       <div class="modal-content">
           <div class="modal-header">
               <h2>Settings</h2>
               <button class="modal-close" id="settings-close">
                   <i class="fas fa-times"></i>
               </button>
           </div>
           <div class="modal-body">
               <div class="settings-section">
                   <h3>Appearance</h3>
                   <div class="settings-item">
                       <label for="dark-mode-toggle">Dark Mode</label>
                       <div class="toggle-switch" id="dark-mode-toggle"></div>
                   </div>
               </div>
               <div class="settings-section">
                   <h3>Sound & Voice</h3>
                   <div class="settings-item">
                       <label for="sound-toggle">Enable Sound Effects</label>
                       <div class="toggle-switch" id="sound-toggle"></div>
                   </div>
                   <div class="settings-item">
                       <label for="voice-enabled-toggle">Enable Voice Response</label>
                       <div class="toggle-switch" id="voice-enabled-toggle"></div>
                   </div>
                   <div class="settings-item">
                       <label for="auto-speak-toggle">Auto-speak Responses</label>
                       <div class="toggle-switch" id="auto-speak-toggle"></div>
                   </div>
                   <div class="form-group" style="margin-top: 16px;">
                       <label for="azure-tts-key">Azure TTS API Key</label>
                       <input type="password" id="azure-tts-key" placeholder="Enter your Azure TTS API key">
                   </div>
                   <div class="form-group">
                       <label for="tts-voice-select">TTS Voice</label>
                       <select id="tts-voice-select" style="width: 100%; padding: 8px; border: 1px solid var(--gray-40); border-radius: 4px;">
                           <option value="en-US-JennyNeural">Jenny (Female)</option>
                           <option value="en-US-GuyNeural">Guy (Male)</option>
                           <option value="en-US-AriaNeural">Aria (Female)</option>
                           <option value="en-US-DavisNeural">Davis (Male)</option>
                           <option value="en-US-AmberNeural">Amber (Female)</option>
                           <option value="en-US-JasonNeural">Jason (Male)</option>
                           <option value="en-GB-SoniaNeural">Sonia (British Female)</option>
                           <option value="en-GB-RyanNeural">Ryan (British Male)</option>
                       </select>
                   </div>
               </div>
               <div class="settings-section">
                   <h3>API Configuration</h3>
                   <div class="form-group">
                       <label for="api-endpoint">API Endpoint URL</label>
                       <input type="url" id="api-endpoint" placeholder="https://your-api-endpoint.com/api/function">
                   </div>
                   <div class="form-group">
                       <label for="user-guid">User GUID</label>
                       <input type="text" id="user-guid" placeholder="xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx">
                   </div>
                   <div class="form-group">
                       <label for="function-key-input">Function Key</label>
                       <input type="password" id="function-key-input" placeholder="Enter your Azure Function key">
                   </div>
                   <button class="button button-primary" id="save-api-config">
                       <i class="fas fa-save"></i>
                       Save Configuration
                   </button>
               </div>
               <div class="settings-section">
                   <h3>Collab Mode Settings</h3>
                   <div class="settings-item">
                       <label for="gesture-control-toggle">Enable Gesture Controls</label>
                       <div class="toggle-switch" id="gesture-control-toggle"></div>
                   </div>
                   <div class="settings-item">
                       <label for="collab-auto-voice-toggle">Auto Voice in Collab Mode</label>
                       <div class="toggle-switch active" id="collab-auto-voice-toggle"></div>
                   </div>
                   <div class="form-group" style="margin-top: 16px;">
                       <label>Gesture Guide</label>
                       <div style="background: var(--gray-20); padding: 12px; border-radius: var(--radius); font-size: 13px; line-height: 1.6;">
                           <div> Open Palm = Send Message</div>
                           <div> Peace Sign = Toggle Voice</div>
                           <div> Thumbs Up = Clear Chat</div>
                           <div> Thumbs Down = End Collab Mode</div>
                           <div> Rock Sign = Toggle Theme</div>
                       </div>
                   </div>
               </div>
               <div class="settings-section">
                   <h3>Data Management</h3>
                   <button class="button button-secondary" id="clear-all-data">
                       <i class="fas fa-trash-alt"></i>
                       Clear All Data
                   </button>
               </div>
           </div>
       </div>
   </div>

   <!-- Time Machine Modal -->
   <div class="modal" id="time-machine-modal">
       <div class="modal-content">
           <div class="modal-header">
               <h2>Time Machine</h2>
               <button class="modal-close" id="time-machine-close">
                   <i class="fas fa-times"></i>
               </button>
           </div>
           <div class="modal-body">
               <div class="text-center">
                   <p>Replay the current conversation</p>
               </div>
               <div class="text-center">
                   <button class="button button-primary" id="time-machine-start">
                       <i class="fas fa-play"></i> Start Replay
                   </button>
               </div>
               <div class="hidden" id="time-machine-controls">
                   <div class="text-center">
                       <span id="time-machine-progress">0 / 0</span>
                   </div>
                   <div class="text-center">
                       <button class="button button-secondary" id="time-machine-prev">
                           <i class="fas fa-step-backward"></i>
                       </button>
                       <button class="button button-primary" id="time-machine-play">
                           <i class="fas fa-play"></i>
                       </button>
                       <button class="button button-secondary" id="time-machine-next">
                           <i class="fas fa-step-forward"></i>
                       </button>
                       <button class="button button-secondary" id="time-machine-stop">
                           <i class="fas fa-stop"></i>
                       </button>
                   </div>
               </div>
           </div>
       </div>
   </div>

   <!-- Hidden file inputs -->
   <input type="file" id="image-upload-input" accept="image/*">
   <input type="file" id="chat-import-input" accept=".json">
   <input type="file" id="data-import-input" accept=".json">

   <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/highlight.min.js"></script>
   <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
   <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.min.js"></script>
   <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1640029074/camera_utils.min.js"></script>

   <script>
       // Gesture Manager Class
       class GestureManager {
           constructor(uiController) {
               this.ui = uiController;
               this.video = null;
               this.canvas = null;
               this.ctx = null;
               this.hands = null;
               this.camera = null;
               this.isActive = false;
               this.lastGesture = null;
               this.gestureTimeout = null;
               this.gestureHoldTime = 1500; // Hold gesture for 1.5 seconds to trigger
               this.gestureStartTime = null;
               this.currentGesture = null;
               this.cooldownActive = false;
               this.gestureEnabled = true;
           }

           async initialize() {
               try {
                   this.video = document.getElementById('gesture-video');
                   this.canvas = document.getElementById('gesture-canvas');
                   this.ctx = this.canvas.getContext('2d');

                   // Initialize MediaPipe Hands
                   this.hands = new Hands({
                       locateFile: (file) => {
                           return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/${file}`;
                       }
                   });

                   this.hands.setOptions({
                       maxNumHands: 1,
                       modelComplexity: 1,
                       minDetectionConfidence: 0.5,
                       minTrackingConfidence: 0.5
                   });

                   this.hands.onResults(this.onResults.bind(this));

                   // Setup camera
                   this.camera = new Camera(this.video, {
                       onFrame: async () => {
                           if (this.isActive && this.hands) {
                               await this.hands.send({ image: this.video });
                           }
                       },
                       width: 640,
                       height: 480
                   });

                   console.log('Gesture Manager initialized');
               } catch (error) {
                   console.error('Failed to initialize Gesture Manager:', error);
                   this.ui.showNotification('Gesture controls unavailable', 'warning');
               }
           }

           async start() {
               if (!this.camera) {
                   await this.initialize();
               }

               try {
                   await this.camera.start();
                   this.isActive = true;
                   document.getElementById('gesture-camera-container').classList.add('active');
                   document.getElementById('gesture-status').textContent = 'Active';
                   this.ui.showNotification('Gesture controls activated', 'success');
               } catch (error) {
                   console.error('Failed to start camera:', error);
                   this.ui.showNotification('Camera access denied', 'error');
               }
           }

           stop() {
               if (this.camera) {
                   this.camera.stop();
               }
               this.isActive = false;
               document.getElementById('gesture-camera-container').classList.remove('active');
               document.getElementById('gesture-status').textContent = 'Inactive';
           }

           onResults(results) {
               if (!this.isActive || !this.gestureEnabled || this.cooldownActive) return;

               // Clear canvas
               this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

               if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                   const landmarks = results.multiHandLandmarks[0];
                   
                   // Draw hand landmarks
                   this.drawHand(landmarks);
                   
                   // Detect gesture
                   const gesture = this.detectGesture(landmarks);
                   
                   if (gesture) {
                       if (gesture !== this.currentGesture) {
                           // New gesture detected
                           this.currentGesture = gesture;
                           this.gestureStartTime = Date.now();
                           document.getElementById('gesture-status').textContent = `Hold: ${gesture}`;
                       } else if (Date.now() - this.gestureStartTime >= this.gestureHoldTime) {
                           // Gesture held long enough
                           this.executeGesture(gesture);
                           this.currentGesture = null;
                           this.gestureStartTime = null;
                           this.startCooldown();
                       }
                   } else {
                       this.currentGesture = null;
                       this.gestureStartTime = null;
                       document.getElementById('gesture-status').textContent = 'Ready';
                   }
               } else {
                   this.currentGesture = null;
                   this.gestureStartTime = null;
                   document.getElementById('gesture-status').textContent = 'No hand detected';
               }
           }

           drawHand(landmarks) {
               // Draw connections
               const connections = [
                   [0, 1], [1, 2], [2, 3], [3, 4], // Thumb
                   [0, 5], [5, 6], [6, 7], [7, 8], // Index
                   [0, 9], [9, 10], [10, 11], [11, 12], // Middle
                   [0, 13], [13, 14], [14, 15], [15, 16], // Ring
                   [0, 17], [17, 18], [18, 19], [19, 20], // Pinky
                   [5, 9], [9, 13], [13, 17] // Palm
               ];

               this.ctx.strokeStyle = '#00ff88';
               this.ctx.lineWidth = 2;

               connections.forEach(([start, end]) => {
                   const startPoint = landmarks[start];
                   const endPoint = landmarks[end];
                   this.ctx.beginPath();
                   this.ctx.moveTo(startPoint.x * this.canvas.width, startPoint.y * this.canvas.height);
                   this.ctx.lineTo(endPoint.x * this.canvas.width, endPoint.y * this.canvas.height);
                   this.ctx.stroke();
               });

               // Draw landmarks
               this.ctx.fillStyle = '#ff0088';
               landmarks.forEach(landmark => {
                   this.ctx.beginPath();
                   this.ctx.arc(landmark.x * this.canvas.width, landmark.y * this.canvas.height, 5, 0, 2 * Math.PI);
                   this.ctx.fill();
               });
           }

           detectGesture(landmarks) {
               // Calculate finger states
               const fingers = {
                   thumb: this.isFingerExtended(landmarks, [1, 2, 3, 4]),
                   index: this.isFingerExtended(landmarks, [5, 6, 7, 8]),
                   middle: this.isFingerExtended(landmarks, [9, 10, 11, 12]),
                   ring: this.isFingerExtended(landmarks, [13, 14, 15, 16]),
                   pinky: this.isFingerExtended(landmarks, [17, 18, 19, 20])
               };

               // Detect specific gestures
               if (fingers.thumb && fingers.index && fingers.middle && fingers.ring && fingers.pinky) {
                   return 'Open Palm';
               } else if (fingers.index && fingers.middle && !fingers.thumb && !fingers.ring && !fingers.pinky) {
                   return 'Peace';
               } else if (fingers.thumb && !fingers.index && !fingers.middle && !fingers.ring && !fingers.pinky) {
                   // Check if thumb is up
                   if (landmarks[4].y < landmarks[3].y) {
                       return 'Thumbs Up';
                   } else if (landmarks[4].y > landmarks[3].y) {
                       return 'Thumbs Down';
                   }
               } else if (fingers.index && fingers.pinky && !fingers.middle && !fingers.ring) {
                   return 'Rock';
               }

               return null;
           }

           isFingerExtended(landmarks, indices) {
               // Simple heuristic: check if fingertip is higher than middle joint
               const tip = landmarks[indices[3]];
               const middle = landmarks[indices[2]];
               return tip.y < middle.y;
           }

           executeGesture(gesture) {
               console.log('Executing gesture:', gesture);
               
               // Show feedback
               this.showGestureFeedback(gesture);

               switch (gesture) {
                   case 'Open Palm':
                       // Send message
                       if (this.ui.userInput.value.trim()) {
                           this.ui.sendMessage();
                       } else {
                           this.ui.showNotification('No message to send', 'info');
                       }
                       break;
                   
                   case 'Peace':
                       // Toggle voice
                       document.getElementById('voice-toggle').click();
                       break;
                   
                   case 'Thumbs Up':
                       // Clear chat
                       this.ui.clearCurrentChat();
                       break;
                   
                   case 'Thumbs Down':
                       // End collab mode
                       if (this.ui.collabManager && this.ui.collabManager.isActive) {
                           this.ui.collabManager.toggle();
                       }
                       break;
                   
                   case 'Rock':
                       // Toggle theme
                       this.ui.toggleTheme();
                       break;
               }
           }

           showGestureFeedback(gesture) {
               const feedback = document.getElementById('gesture-feedback');
               const feedbackText = document.getElementById('gesture-feedback-text');
               const feedbackIcon = feedback.querySelector('i');

               // Set appropriate icon
               const icons = {
                   'Open Palm': 'fa-hand-paper',
                   'Peace': 'fa-hand-peace',
                   'Thumbs Up': 'fa-thumbs-up',
                   'Thumbs Down': 'fa-thumbs-down',
                   'Rock': 'fa-hand-rock'
               };

               feedbackIcon.className = `fas ${icons[gesture] || 'fa-hand-paper'}`;
               feedbackText.textContent = gesture;

               feedback.classList.add('show');
               setTimeout(() => {
                   feedback.classList.remove('show');
               }, 1500);
           }

           startCooldown() {
               this.cooldownActive = true;
               document.getElementById('gesture-status').textContent = 'Cooldown...';
               
               setTimeout(() => {
                   this.cooldownActive = false;
                   document.getElementById('gesture-status').textContent = 'Ready';
               }, 2000);
           }

           setEnabled(enabled) {
               this.gestureEnabled = enabled;
               if (!enabled && this.isActive) {
                   this.stop();
               }
           }
       }

       // Collab Mode Manager
       class CollabManager {
           constructor(uiController) {
               this.ui = uiController;
               this.gestureManager = new GestureManager(uiController);
               this.isActive = false;
               this.autoVoiceEnabled = true;
           }

           async toggle() {
               if (this.isActive) {
                   this.deactivate();
               } else {
                   await this.activate();
               }
           }

           async activate() {
               this.isActive = true;
               
               // Update UI
               document.getElementById('collab-mode-button').classList.add('active');
               document.getElementById('collab-mode-indicator').classList.add('active');
               
               // Enable auto-speak
               if (this.autoVoiceEnabled) {
                   appState.settings.autoSpeak = true;
                   voiceManager.setAutoSpeak(true);
               }
               
               // Start gesture controls
               if (appState.settings.gestureControlEnabled) {
                   await this.gestureManager.start();
               }
               
               // Show notification
               this.ui.showNotification('Collab Mode activated! Use gestures or voice for hands-free interaction.', 'success');
               
               // Speak activation message
               if (this.autoVoiceEnabled) {
                   voiceManager.speak('Collab mode activated. Ready for hands-free interaction.');
               }
           }

           deactivate() {
               this.isActive = false;
               
               // Update UI
               document.getElementById('collab-mode-button').classList.remove('active');
               document.getElementById('collab-mode-indicator').classList.remove('active');
               
               // Stop gesture controls
               this.gestureManager.stop();
               
               // Show notification
               this.ui.showNotification('Collab Mode deactivated', 'info');
               
               // Speak deactivation message
               if (voiceManager.enabled) {
                   voiceManager.speak('Collab mode deactivated.');
               }
           }

           setAutoVoice(enabled) {
               this.autoVoiceEnabled = enabled;
               if (this.isActive && enabled) {
                   appState.settings.autoSpeak = true;
                   voiceManager.setAutoSpeak(true);
               }
           }
       }

       // Show Mode Manager Class (continued from original)
       class ShowModeManager {
           constructor(uiController) {
               this.ui = uiController;
               this.peer = null;
               this.connections = new Map();
               this.isHost = false;
               this.roomId = null;
               this.isFollowing = false;
               this.viewerNames = new Map();
               this.syncInterval = null;
               this.lastSyncData = null;
               this.lastTypingState = null;
               this.typingIndicatorTimeout = null;

               this.initializePeer();
               this.setupEventListeners();
           }

           initializePeer() {
               const urlParams = new URLSearchParams(window.location.search);
               const hostId = urlParams.get('show');

               try {
                   if (hostId) {
                       // Joining a show as viewer
                       this.roomId = hostId;
                       this.peer = new Peer();
                       this.isFollowing = true;

                       this.peer.on('open', (id) => {
                           console.log('Viewer peer ID:', id);
                           console.log('Attempting to join show:', this.roomId);
                           
                           // Set viewer mode UI
                           this.setupViewerMode();
                           
                           setTimeout(() => {
                               this.connectToHost(this.roomId);
                           }, 1000);
                           
                           this.updateStatus('Connecting to presenter...', false);
                       });
                   } else {
                       // Normal mode - can become host
                       this.peer = new Peer();
                       
                       this.peer.on('open', (id) => {
                           console.log('Peer ID:', id);
                       });
                   }

                   // Handle incoming connections
                   this.peer.on('connection', (conn) => {
                       console.log('Incoming connection from:', conn.peer);
                       this.handleNewConnection(conn);
                   });

                   // Handle errors
                   this.peer.on('error', (err) => {
                       console.error('Peer error:', err);
                       
                       if (err.type === 'peer-unavailable') {
                           this.showError('Presenter not found. Make sure they are online.');
                       } else if (err.type === 'network') {
                           this.showError('Network error. Check your connection.');
                       } else {
                           this.showError('Connection error: ' + err.message);
                       }
                       
                       this.updateStatus('Error', false);
                   });

                   // Handle disconnection
                   this.peer.on('disconnected', () => {
                       console.log('Disconnected from peer server');
                       this.updateStatus('Disconnected', false);
                       
                       setTimeout(() => {
                           if (!this.peer.destroyed) {
                               console.log('Attempting to reconnect...');
                               this.peer.reconnect();
                           }
                       }, 3000);
                   });

               } catch (error) {
                   console.error('Failed to initialize peer:', error);
                   this.showError('Failed to initialize show mode');
               }
           }

           setupViewerMode() {
               console.log('Setting up viewer mode...');
               
               // Show viewer mode indicator
               document.getElementById('viewer-mode-indicator').classList.add('active');
               
               // Update chat UI for viewer mode
               document.getElementById('viewer-chat-label').classList.add('active');
               document.getElementById('input-container').classList.add('viewer-mode');
               
               // Hide show mode button for viewers
               document.getElementById('show-mode-button').style.display = 'none';
               document.getElementById('collab-mode-button').style.display = 'none';
               
               // Hide some presenter-only buttons
               document.getElementById('clear-chat').style.display = 'none';
               document.getElementById('archive-chat').style.display = 'none';
               
               // Update placeholder text
               document.getElementById('user-input').placeholder = 'Type a message to send to presenter...';
               
               // Clear any existing loading indicators
               const chatMessages = document.getElementById('chat-messages');
               chatMessages.innerHTML = '';
               
               // Show initial waiting message
               const waitingMessage = document.createElement('div');
               waitingMessage.id = 'viewer-waiting-message';
               waitingMessage.style.textAlign = 'center';
               waitingMessage.style.padding = '40px';
               waitingMessage.style.color = 'var(--gray-60)';
               waitingMessage.innerHTML = '<i class="fas fa-broadcast-tower" style="font-size: 48px; margin-bottom: 16px; display: block;"></i>Connecting to presenter...';
               chatMessages.appendChild(waitingMessage);
           }

           setupEventListeners() {
               // Show Mode button
               document.getElementById('show-mode-button').addEventListener('click', () => {
                   if (this.isHost) {
                       this.stopHosting();
                   } else {
                       this.startHosting();
                   }
               });

               // Modal close
               document.getElementById('show-mode-close').addEventListener('click', () => {
                   document.getElementById('show-mode-modal').classList.remove('show');
               });

               // Copy URL button
               document.getElementById('copy-url-btn').addEventListener('click', async () => {
                   const urlElement = document.getElementById('qr-url');
                   try {
                       await navigator.clipboard.writeText(urlElement.textContent);
                       const btn = document.getElementById('copy-url-btn');
                       btn.textContent = 'Copied!';
                       btn.classList.add('copied');
                       
                       setTimeout(() => {
                           btn.textContent = 'Copy URL';
                           btn.classList.remove('copied');
                       }, 2000);
                   } catch (err) {
                       console.error('Failed to copy:', err);
                   }
               });

               // Close modal on outside click
               document.getElementById('show-mode-modal').addEventListener('click', (e) => {
                   if (e.target.id === 'show-mode-modal') {
                       document.getElementById('show-mode-modal').classList.remove('show');
                   }
               });
           }

           startHosting() {
               this.isHost = true;
               this.roomId = this.peer.id;
               
               document.getElementById('show-mode-button').classList.add('active');
               document.getElementById('show-mode-modal').classList.add('show');
               document.getElementById('show-mode-status').classList.add('visible');
               
               this.updateStatus('Hosting Show', true);
               this.updateShareUrl();
               
               this.showNotification('Show Mode activated! Share the QR code for others to follow your chat.');
               
               // Start syncing state
               this.startSyncInterval();
           }

           stopHosting() {
               this.isHost = false;
               
               // Stop syncing
               if (this.syncInterval) {
                   clearInterval(this.syncInterval);
                   this.syncInterval = null;
               }
               
               // Disconnect all viewers
               this.connections.forEach((conn) => {
                   conn.close();
               });
               this.connections.clear();
               this.viewerNames.clear();
               
               document.getElementById('show-mode-button').classList.remove('active');
               document.getElementById('show-mode-modal').classList.remove('show');
               document.getElementById('show-mode-status').classList.remove('visible');
               
               this.showNotification('Show Mode deactivated');
               this.updateViewerCount();
           }

           connectToHost(hostId) {
               try {
                   console.log('Connecting to host:', hostId);
                   
                   const viewerUsername = this.generateUsername();
                   
                   const conn = this.peer.connect(hostId, {
                       reliable: true,
                       serialization: 'json',
                       metadata: {
                           type: 'viewer',
                           username: viewerUsername
                       }
                   });

                   // Set connection timeout
                   const connectionTimeout = setTimeout(() => {
                       if (conn.open === false) {
                           console.error('Connection timeout');
                           this.showError('Connection timeout. Presenter may be offline.');
                           conn.close();
                           document.getElementById('viewer-mode-indicator').classList.remove('active');
                       }
                   }, 10000);

                   conn.on('open', () => {
                       clearTimeout(connectionTimeout);
                       console.log('Connected to presenter successfully');
                       this.updateStatus('Following presenter', true);
                       this.showNotification('Connected to presenter! You are now following their chat.');
                       
                       // Store our username for later use
                       this.myUsername = viewerUsername;
                       
                       // Clear waiting message
                       const waitingMsg = document.getElementById('viewer-waiting-message');
                       if (waitingMsg) {
                           waitingMsg.remove();
                       }
                       
                       // Request initial state with a slight delay
                       setTimeout(() => {
                           console.log('Requesting initial state from presenter...');
                           conn.send({ type: 'requestState' });
                       }, 500);
                   });

                   this.handleNewConnection(conn);
               } catch (error) {
                   console.error('Failed to connect to host:', error);
                   this.showError('Failed to connect to presenter');
               }
           }

           handleNewConnection(conn) {
               const peerId = conn.peer;

               conn.on('open', () => {
                   console.log('Connection opened with peer:', peerId);
                   this.connections.set(peerId, conn);

                   if (this.isHost) {
                       // Store viewer name
                       const viewerName = conn.metadata?.username || 'Anonymous';
                       this.viewerNames.set(peerId, viewerName);
                       
                       // Show notification for new viewer
                       this.showNotification(`New viewer joined: ${viewerName}`);
                       this.updateViewerCount();
                       
                       // Send current state to new viewer
                       setTimeout(() => {
                           this.sendCurrentState(conn);
                       }, 100);
                   }
               });

               conn.on('data', (data) => {
                   try {
                       this.handlePeerData(peerId, data);
                   } catch (error) {
                       console.error('Error handling peer data:', error);
                   }
               });

               conn.on('close', () => {
                   console.log('Peer disconnected:', peerId);
                   
                   if (this.isHost) {
                       const viewerName = this.viewerNames.get(peerId) || 'Anonymous';
                       this.showNotification(`${viewerName} left the show`);
                       this.viewerNames.delete(peerId);
                   }
                   
                   this.connections.delete(peerId);
                   
                   if (this.isHost) {
                       this.updateViewerCount();
                   } else if (this.isFollowing) {
                       this.updateStatus('Disconnected from presenter', false);
                       this.showNotification('Disconnected from presenter');
                   }
               });

               conn.on('error', (err) => {
                   console.error('Connection error with peer', peerId, ':', err);
               });
           }

           handlePeerData(peerId, data) {
               console.log('Received data from peer:', peerId, data.type);
               
               switch (data.type) {
                   case 'stateSync':
                       if (this.isFollowing) {
                           this.applySyncedState(data.state);
                       }
                       break;
                   
                   case 'chatMessage':
                       if (this.isFollowing) {
                           this.showChatMessage(data);
                       }
                       break;
                   
                   case 'viewerMessage':
                       if (this.isHost) {
                           this.handleViewerMessage(peerId, data);
                       }
                       break;
                   
                   case 'typing':
                       if (this.isFollowing) {
                           this.showTypingIndicator(data.isTyping);
                       }
                       break;
                   
                   case 'voiceActivity':
                       if (this.isFollowing) {
                           this.showVoiceActivity(data);
                       }
                       break;
                   
                   case 'requestState':
                       if (this.isHost) {
                           const conn = this.connections.get(peerId);
                           if (conn) {
                               this.sendCurrentState(conn);
                           }
                       }
                       break;
                   
                   case 'currentState':
                       if (this.isFollowing) {
                           this.applyHostState(data.state);
                       }
                       break;
               }
           }

           handleViewerMessage(peerId, data) {
               const viewerName = this.viewerNames.get(peerId) || 'Anonymous Viewer';
               
               // Add the message to the chat as a viewer message
               const messageWrapper = this.ui.createMessageElement('user', data.message);
               messageWrapper.classList.add('viewer-message');
               messageWrapper.setAttribute('data-viewer-name', viewerName);
               
               const chatMessages = document.getElementById('chat-messages');
               chatMessages.appendChild(messageWrapper);
               this.ui.scrollToBottom();
               
               // Add to conversation history
               const chat = appState.chats[appState.currentUser.id][appState.currentChatId];
               if (chat) {
                   chat.messages.push({
                       role: 'user',
                       content: data.message,
                       timestamp: new Date().toISOString(),
                       isViewer: true,
                       viewerName: viewerName
                   });
                   appState.saveChats();
               }
               
               // Broadcast to all other viewers
               this.connections.forEach((conn, connPeerId) => {
                   if (conn && conn.open && connPeerId !== peerId) {
                       conn.send({
                           type: 'chatMessage',
                           sender: 'user',
                           content: data.message,
                           isViewer: true,
                           viewerName: viewerName,
                           timestamp: Date.now()
                       });
                   }
               });
               
               // Show notification
               this.showNotification(`${viewerName}: ${data.message.substring(0, 50)}...`);
           }

           sendCurrentState(conn) {
               const chat = appState.chats[appState.currentUser.id][appState.currentChatId];
               
               const state = {
                   type: 'currentState',
                   state: {
                       currentUser: appState.currentUser.username,
                       chatTitle: chat ? chat.title : 'New Chat',
                       messages: chat ? chat.messages : [],
                       theme: appState.settings.theme
                   }
               };
               
               console.log('Sending current state to viewer:', state);
               conn.send(state);
           }

           applyHostState(state) {
               console.log('Applying host state:', state);
               
               // Apply theme
               if (state.theme === 'dark' && !document.body.classList.contains('dark')) {
                   document.body.classList.add('dark');
               } else if (state.theme === 'light' && document.body.classList.contains('dark')) {
                   document.body.classList.remove('dark');
               }
               
               // Update header
               document.getElementById('current-username').textContent = state.currentUser;
               
               // Clear and rebuild chat messages
               const chatMessages = document.getElementById('chat-messages');
               chatMessages.innerHTML = '';
               
               // Remove any existing loading indicators
               const existingLoading = document.querySelectorAll('.loading');
               existingLoading.forEach(el => el.remove());
               
               if (state.messages && state.messages.length > 0) {
                   state.messages.forEach(msg => {
                       if (msg.isViewer) {
                           const messageWrapper = this.ui.createMessageElement(msg.role, msg.content);
                           messageWrapper.classList.add('viewer-message');
                           messageWrapper.setAttribute('data-viewer-name', msg.viewerName);
                           chatMessages.appendChild(messageWrapper);
                       } else {
                           this.ui.addMessageToUI(msg.role, msg.content, false, msg.voiceResponse);
                       }
                   });
               } else {
                   // Show welcome message if no messages
                   const welcomeMessage = document.createElement('div');
                   welcomeMessage.style.textAlign = 'center';
                   welcomeMessage.style.padding = '40px';
                   welcomeMessage.style.color = 'var(--gray-60)';
                   welcomeMessage.innerHTML = '<i class="fas fa-eye" style="font-size: 48px; margin-bottom: 16px; display: block;"></i>Waiting for presenter to start chatting...';
                   chatMessages.appendChild(welcomeMessage);
               }
               
               this.ui.scrollToBottom();
           }

           startSyncInterval() {
               // Sync state every 2 seconds
               this.syncInterval = setInterval(() => {
                   if (this.connections.size > 0) {
                       this.broadcastStateSync();
                   }
               }, 2000);
           }

           broadcastStateSync() {
               const chat = appState.chats[appState.currentUser.id][appState.currentChatId];
               if (!chat) return;

               const syncData = {
                   type: 'stateSync',
                   state: {
                       scrollPosition: document.getElementById('chat-messages').scrollTop,
                       messageCount: chat.messages.length,
                       lastMessageTime: chat.messages[chat.messages.length - 1]?.timestamp
                   }
               };

               this.connections.forEach((conn) => {
                   if (conn && conn.open) {
                       try {
                           conn.send(syncData);
                       } catch (error) {
                           console.error('Failed to send state sync:', error);
                       }
                   }
               });
           }

           applySyncedState(state) {
               // Smooth scroll to match presenter's position
               const chatMessages = document.getElementById('chat-messages');
               const currentScroll = chatMessages.scrollTop;
               const targetScroll = state.scrollPosition;
               
               if (Math.abs(currentScroll - targetScroll) > 100) {
                   chatMessages.scrollTo({
                       top: targetScroll,
                       behavior: 'smooth'
                   });
               }
           }

           broadcastChatMessage(sender, content, voiceResponse = null) {
               if (!this.isHost || this.connections.size === 0) return;

               const data = {
                   type: 'chatMessage',
                   sender: sender,
                   content: content,
                   voiceResponse: voiceResponse,
                   isViewer: false,
                   timestamp: Date.now()
               };

               this.connections.forEach((conn) => {
                   if (conn && conn.open) {
                       try {
                           conn.send(data);
                       } catch (error) {
                           console.error('Failed to send chat message:', error);
                       }
                   }
               });
           }

           sendViewerMessage(message) {
               if (!this.isFollowing) return;
               
               // Find the host connection
               const hostConn = Array.from(this.connections.values())[0];
               if (hostConn && hostConn.open) {
                   hostConn.send({
                       type: 'viewerMessage',
                       message: message,
                       timestamp: Date.now()
                   });
               }
           }

           broadcastTypingIndicator(isTyping) {
               if (!this.isHost || this.connections.size === 0) return;

               // Prevent duplicate broadcasts
               if (this.lastTypingState === isTyping) return;
               this.lastTypingState = isTyping;

               const data = {
                   type: 'typing',
                   isTyping: isTyping,
                   timestamp: Date.now()
               };

               this.connections.forEach((conn) => {
                   if (conn && conn.open) {
                       try {
                           conn.send(data);
                       } catch (error) {
                           console.error('Failed to send typing indicator:', error);
                       }
                   }
               });
           }

           broadcastVoiceActivity(activity) {
               if (!this.isHost || this.connections.size === 0) return;

               const data = {
                   type: 'voiceActivity',
                   activity: activity // 'speaking', 'listening', or 'idle'
               };

               this.connections.forEach((conn) => {
                   if (conn && conn.open) {
                       try {
                           conn.send(data);
                       } catch (error) {
                           console.error('Failed to send voice activity:', error);
                       }
                   }
               });
           }

           showChatMessage(data) {
               console.log('Showing chat message:', data);
               
               // Remove any loading indicators first
               this.ui.hideLoadingIndicator();
               
               if (data.isViewer) {
                   const messageWrapper = this.ui.createMessageElement('user', data.content);
                   messageWrapper.classList.add('viewer-message');
                   messageWrapper.setAttribute('data-viewer-name', data.viewerName);
                   document.getElementById('chat-messages').appendChild(messageWrapper);
               } else {
                   this.ui.addMessageToUI(data.sender, data.content, false, data.voiceResponse);
               }
               
               this.ui.scrollToBottom();
           }

           showTypingIndicator(isTyping) {
               console.log('Show typing indicator:', isTyping);
               
               // Clear any existing typing timeout
               if (this.typingIndicatorTimeout) {
                   clearTimeout(this.typingIndicatorTimeout);
                   this.typingIndicatorTimeout = null;
               }
               
               if (isTyping) {
                   // Check if loading indicator already exists
                   if (!document.getElementById('loading-indicator')) {
                       this.ui.showLoadingIndicator();
                   }
                   
                   // Set timeout to auto-hide after 3 seconds (in case we miss the stop signal)
                   this.typingIndicatorTimeout = setTimeout(() => {
                       this.ui.hideLoadingIndicator();
                   }, 3000);
               } else {
                   this.ui.hideLoadingIndicator();
               }
           }

           showVoiceActivity(data) {
               const voiceIndicator = document.getElementById('voice-indicator');
               if (data.activity === 'speaking' || data.activity === 'listening') {
                   voiceIndicator.classList.add('active');
                   voiceIndicator.querySelector('span').textContent = 
                       data.activity === 'speaking' ? 'Speaking...' : 'Listening...';
               } else {
                   voiceIndicator.classList.remove('active');
               }
           }

           updateShareUrl() {
               const currentFile = window.location.pathname.split('/').pop() || 'index.html';
               const params = new URLSearchParams({
                   show: this.roomId
               });
               const shareUrl = `${window.location.origin}${window.location.pathname.replace(/[^/]*$/, '')}${currentFile}?${params}`;

               // Update QR code
               const qrUrlElement = document.getElementById('qr-url');
               if (qrUrlElement) {
                   qrUrlElement.textContent = shareUrl;
               }

               // Generate QR code
               this.generateQRCode(shareUrl);

               // Update button appearance
               const showModeButton = document.getElementById('show-mode-button');
               if (showModeButton) {
                   showModeButton.classList.add('active');
               }
           }

           generateQRCode(url) {
               const container = document.getElementById('qr-code-container');
               container.innerHTML = '';

               const loadQRious = () => {
                   return new Promise((resolve, reject) => {
                       if (window.QRious) {
                           resolve();
                       } else {
                           const script = document.createElement('script');
                           script.src = 'https://cdnjs.cloudflare.com/ajax/libs/qrious/4.0.2/qrious.min.js';
                           script.onload = resolve;
                           script.onerror = reject;
                           document.head.appendChild(script);
                       }
                   });
               };

               loadQRious().then(() => {
                   const canvas = document.createElement('canvas');
                   container.appendChild(canvas);

                   new window.QRious({
                       element: canvas,
                       value: url,
                       size: 250,
                       background: 'white',
                       foreground: 'black',
                       level: 'H'
                   });
               }).catch(() => {
                   const img = document.createElement('img');
                   img.src = `https://api.qrserver.com/v1/create-qr-code/?size=250x250&data=${encodeURIComponent(url)}`;
                   img.alt = 'QR Code';
                   container.appendChild(img);
               });
           }

           updateStatus(status, connected) {
               const statusText = document.getElementById('status-text');
               const statusIndicator = document.getElementById('status-indicator');

               if (statusText) statusText.textContent = status;
               if (statusIndicator) {
                   statusIndicator.classList.toggle('connected', connected);
                   statusIndicator.classList.toggle('hosting', this.isHost);
               }
           }

           updateViewerCount() {
               const count = this.connections.size;
               const viewerCountEl = document.getElementById('viewer-count');
               if (viewerCountEl) viewerCountEl.textContent = count;
           }

           generateUsername() {
               const adjectives = ['Swift', 'Curious', 'Bright', 'Eager', 'Active'];
               const nouns = ['Viewer', 'Observer', 'Student', 'Attendee', 'Participant'];
               const adj = adjectives[Math.floor(Math.random() * adjectives.length)];
               const noun = nouns[Math.floor(Math.random() * nouns.length)];
               return `${adj}${noun}${Math.floor(Math.random() * 100)}`;
           }

           showNotification(message) {
               const notification = document.createElement('div');
               notification.className = 'show-mode-notification';
               notification.textContent = message;

               document.body.appendChild(notification);

               setTimeout(() => {
                   notification.style.animation = 'slideOut 0.3s ease';
                   setTimeout(() => notification.remove(), 300);
               }, 3000);
           }

           showError(message) {
               console.error(message);
               this.showNotification(' ' + message);
           }
       }

       // Global state management
       class AppState {
           constructor() {
               this.currentUser = null;
               this.currentChatId = null;
               this.users = this.loadUsers();
               this.chats = this.loadChats();
               this.settings = this.loadSettings();
               this.apiEndpoint = localStorage.getItem('apiEndpoint') || "http://localhost:7071/api/businessinsightbot_function";
               this.userGuid = localStorage.getItem('userGuid') || null;
               this.functionKey = localStorage.getItem('functionKey') || null;
           }

           loadUsers() {
               const users = localStorage.getItem('chatAppUsers');
               return users ? JSON.parse(users) : {};
           }

           loadChats() {
               const chats = localStorage.getItem('chatAppChats');
               return chats ? JSON.parse(chats) : {};
           }

           loadSettings() {
               const settings = localStorage.getItem('chatAppSettings');
               return settings ? JSON.parse(settings) : {
                   theme: 'light',
                   soundEnabled: false,
                   voiceEnabled: true,
                   autoSpeak: false,
                   azureTTSKey: '',
                   ttsVoiceName: 'en-US-JennyNeural',
                   gestureControlEnabled: true,
                   collabAutoVoice: true
               };
           }

           saveUsers() {
               localStorage.setItem('chatAppUsers', JSON.stringify(this.users));
           }

           saveChats() {
               localStorage.setItem('chatAppChats', JSON.stringify(this.chats));
           }

           saveSettings() {
               localStorage.setItem('chatAppSettings', JSON.stringify(this.settings));
           }

           saveApiConfig(endpoint, guid, key) {
               this.apiEndpoint = endpoint;
               this.userGuid = guid;
               this.functionKey = key;
               
               localStorage.setItem('apiEndpoint', endpoint);
               localStorage.setItem('userGuid', guid);
               localStorage.setItem('functionKey', key);
           }

           createUser(username) {
               const userId = this.userGuid || this.generateGuid();
               const user = {
                   id: userId,
                   username: username,
                   createdAt: new Date().toISOString(),
                   lastActive: new Date().toISOString(),
                   chats: []
               };
               this.users[userId] = user;
               this.saveUsers();
               
               // Save as user GUID if not set
               if (!this.userGuid) {
                   this.userGuid = userId;
                   localStorage.setItem('userGuid', userId);
               }
               
               return user;
           }

           createChat(userId, title = 'New Chat') {
               const chatId = this.generateGuid();
               const chat = {
                   id: chatId,
                   userId: userId,
                   title: title,
                   messages: [],
                   createdAt: new Date().toISOString(),
                   updatedAt: new Date().toISOString(),
                   archived: false
               };

               if (!this.chats[userId]) {
                   this.chats[userId] = {};
               }

               this.chats[userId][chatId] = chat;
               this.users[userId].chats.push(chatId);
               this.users[userId].lastActive = new Date().toISOString();

               this.saveChats();
               this.saveUsers();

               return chat;
           }

           updateChat(userId, chatId, updates) {
               if (this.chats[userId] && this.chats[userId][chatId]) {
                   Object.assign(this.chats[userId][chatId], updates);
                   this.chats[userId][chatId].updatedAt = new Date().toISOString();
                   this.saveChats();
               }
           }

           getActiveChats(userId) {
               if (!this.chats[userId]) return [];
               return Object.values(this.chats[userId])
                   .filter(chat => !chat.archived)
                   .sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt));
           }

           getArchivedChats(userId) {
               if (!this.chats[userId]) return [];
               return Object.values(this.chats[userId])
                   .filter(chat => chat.archived)
                   .sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt));
           }

           archiveChat(userId, chatId) {
               if (this.chats[userId] && this.chats[userId][chatId]) {
                   this.chats[userId][chatId].archived = true;
                   this.chats[userId][chatId].updatedAt = new Date().toISOString();
                   this.saveChats();
               }
           }

           unarchiveChat(userId, chatId) {
               if (this.chats[userId] && this.chats[userId][chatId]) {
                   this.chats[userId][chatId].archived = false;
                   this.chats[userId][chatId].updatedAt = new Date().toISOString();
                   this.saveChats();
               }
           }

           deleteChat(userId, chatId) {
               if (this.chats[userId] && this.chats[userId][chatId]) {
                   delete this.chats[userId][chatId];
                   const userChatIndex = this.users[userId].chats.indexOf(chatId);
                   if (userChatIndex > -1) {
                       this.users[userId].chats.splice(userChatIndex, 1);
                   }
                   this.saveChats();
                   this.saveUsers();
               }
           }

           exportAllData() {
               return {
                   users: this.users,
                   chats: this.chats,
                   settings: this.settings,
                   apiConfig: {
                       endpoint: this.apiEndpoint,
                       userGuid: this.userGuid
                   },
                   exportDate: new Date().toISOString(),
                   version: '2.0'
               };
           }

           importAllData(data) {
               if (data.users) this.users = data.users;
               if (data.chats) this.chats = data.chats;
               if (data.settings) this.settings = data.settings;
               if (data.apiConfig) {
                   this.saveApiConfig(
                       data.apiConfig.endpoint || this.apiEndpoint,
                       data.apiConfig.userGuid || this.userGuid,
                       this.functionKey // Keep existing key for security
                   );
               }

               this.saveUsers();
               this.saveChats();
               this.saveSettings();
           }

           clearAllData() {
               localStorage.removeItem('chatAppUsers');
               localStorage.removeItem('chatAppChats');
               localStorage.removeItem('chatAppSettings');
               localStorage.removeItem('lastUserId');
               localStorage.removeItem('functionKey');
               localStorage.removeItem('apiEndpoint');
               localStorage.removeItem('userGuid');

               this.users = {};
               this.chats = {};
               this.settings = {
                   theme: 'light',
                   soundEnabled: false,
                   voiceEnabled: true,
                   autoSpeak: false,
                   azureTTSKey: '',
                   ttsVoiceName: 'en-US-JennyNeural',
                   gestureControlEnabled: true,
                   collabAutoVoice: true
               };
               this.apiEndpoint = "http://localhost:7071/api/businessinsightbot_function";
               this.userGuid = null;
               this.functionKey = null;
           }

           generateGuid() {
               return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                   const r = Math.random() * 16 | 0;
                   const v = c === 'x' ? r : (r & 0x3 | 0x8);
                   return v.toString(16);
               });
           }
       }

       // Sound Manager
       class SoundManager {
           constructor() {
               this.audioContext = null;
               this.enabled = false;
           }

           init() {
               if (!this.audioContext) {
                   this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
               }
           }

           setEnabled(enabled) {
               this.enabled = enabled;
               if (enabled) this.init();
           }

           async playSound(frequency = 440, duration = 0.1, type = 'sine') {
               if (!this.enabled || !this.audioContext) return;

               const oscillator = this.audioContext.createOscillator();
               const gainNode = this.audioContext.createGain();

               oscillator.connect(gainNode);
               gainNode.connect(this.audioContext.destination);

               oscillator.frequency.value = frequency;
               oscillator.type = type;

               gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
               gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);

               oscillator.start(this.audioContext.currentTime);
               oscillator.stop(this.audioContext.currentTime + duration);
           }

           playSendSound() {
               this.playSound(523.25, 0.1); // C5
           }

           playReceiveSound() {
               this.playSound(659.25, 0.15); // E5
           }

           playNotificationSound() {
               this.playSound(880, 0.2); // A5
           }
       }

       // Voice Manager - Updated with Azure TTS
       class VoiceManager {
           constructor() {
               this.synthesis = window.speechSynthesis;
               this.recognition = null;
               this.enabled = true;
               this.autoSpeak = false;
               this.isListening = false;
               this.isSpeaking = false;
               this.azureKey = '';
               this.azureRegion = 'eastus2';
               this.voiceName = 'en-US-JennyNeural';
               this.isSdkLoaded = false;
               this.speechSynthesizer = null;
               this.maxCharacters = 5000;

               this.initSpeechRecognition();
               this.loadSpeechSdk();
           }

           loadSpeechSdk() {
               if (window.SpeechSDK) {
                   this.isSdkLoaded = true;
                   return;
               }

               const script = document.createElement("script");
               script.src = "https://aka.ms/csspeech/jsbrowserpackageraw";
               script.async = true;
               script.onload = () => {
                   console.log("Microsoft Speech SDK loaded");
                   this.isSdkLoaded = true;
               };
               script.onerror = () => {
                   console.error("Failed to load Microsoft Speech SDK");
               };

               document.body.appendChild(script);
           }

           initSpeechRecognition() {
               if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                   const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                   this.recognition = new SpeechRecognition();
                   this.recognition.continuous = false;
                   this.recognition.interimResults = true;
                   this.recognition.lang = 'en-US';

                   this.recognition.onstart = () => {
                       this.isListening = true;
                       document.getElementById('voice-toggle').classList.add('active');
                       
                       // Broadcast voice activity if in show mode
                       if (ui && ui.showModeManager && ui.showModeManager.isHost) {
                           ui.showModeManager.broadcastVoiceActivity('listening');
                       }
                   };

                   this.recognition.onend = () => {
                       this.isListening = false;
                       document.getElementById('voice-toggle').classList.remove('active');
                       
                       // Broadcast voice activity if in show mode
                       if (ui && ui.showModeManager && ui.showModeManager.isHost) {
                           ui.showModeManager.broadcastVoiceActivity('idle');
                       }
                   };

                   this.recognition.onerror = (event) => {
                       console.error('Speech recognition error:', event.error);
                       this.isListening = false;
                       document.getElementById('voice-toggle').classList.remove('active');
                   };
               }
           }

           setEnabled(enabled) {
               this.enabled = enabled;
           }

           setAutoSpeak(autoSpeak) {
               this.autoSpeak = autoSpeak;
           }

           setAzureKey(key) {
               this.azureKey = key;
           }

           setVoiceName(voiceName) {
               this.voiceName = voiceName;
           }

           async speak(text) {
               if (!this.enabled || !text || this.isSpeaking) return;

               // Cancel any ongoing speech
               this.stopSpeaking();

               // Clean text for speech
               const cleanText = this.cleanTextForSpeech(text);

               // Check if Azure TTS is configured and SDK is loaded
               if (this.azureKey && this.isSdkLoaded && window.SpeechSDK) {
                   await this.speakWithAzure(cleanText);
               } else {
                   await this.speakWithBrowser(cleanText);
               }
           }

           async speakWithAzure(text) {
               try {
                   const truncatedText = text.length > this.maxCharacters
                       ? text.substring(0, this.maxCharacters) + "... (text truncated for speech)"
                       : text;

                   const speechConfig = window.SpeechSDK.SpeechConfig.fromSubscription(
                       this.azureKey,
                       this.azureRegion
                   );
                   speechConfig.speechSynthesisVoiceName = this.voiceName;

                   const audioConfig = window.SpeechSDK.AudioConfig.fromDefaultSpeakerOutput();
                   this.speechSynthesizer = new window.SpeechSDK.SpeechSynthesizer(
                       speechConfig,
                       audioConfig
                   );

                   this.isSpeaking = true;
                   document.getElementById('voice-indicator').classList.add('active');
                   
                   // Broadcast voice activity if in show mode
                   if (ui && ui.showModeManager && ui.showModeManager.isHost) {
                       ui.showModeManager.broadcastVoiceActivity('speaking');
                   }

                   await new Promise((resolve, reject) => {
                       this.speechSynthesizer.speakTextAsync(
                           truncatedText,
                           (result) => {
                               if (
                                   result.reason ===
                                   window.SpeechSDK.ResultReason.SynthesizingAudioCompleted
                               ) {
                                   console.log("Azure TTS synthesis completed");
                                   this.isSpeaking = false;
                                   document.getElementById('voice-indicator').classList.remove('active');
                                   
                                   // Broadcast voice activity if in show mode
                                   if (ui && ui.showModeManager && ui.showModeManager.isHost) {
                                       ui.showModeManager.broadcastVoiceActivity('idle');
                                   }

                                   if (this.speechSynthesizer) {
                                       this.speechSynthesizer.close();
                                       this.speechSynthesizer = null;
                                   }
                                   resolve();
                               } else {
                                   console.error(
                                       `Speech synthesis canceled, reason: ${result.reason}`
                                   );
                                   let errorDetails = "";

                                   if (
                                       result.reason === window.SpeechSDK.ResultReason.Canceled
                                   ) {
                                       const cancellationDetails =
                                           window.SpeechSDK.CancellationDetails.fromResult(result);
                                       errorDetails = `Cancellation reason: ${cancellationDetails.reason}`;

                                       if (
                                           cancellationDetails.reason ===
                                           window.SpeechSDK.CancellationReason.Error
                                       ) {
                                           errorDetails += `, Error details: ${cancellationDetails.errorDetails}`;
                                       }
                                   }

                                   if (this.speechSynthesizer) {
                                       this.speechSynthesizer.close();
                                       this.speechSynthesizer = null;
                                   }

                                   this.isSpeaking = false;
                                   document.getElementById('voice-indicator').classList.remove('active');
                                   reject(
                                       new Error(`Speech synthesis failed. ${errorDetails}`)
                                   );
                               }
                           },
                           (error) => {
                               console.error("Azure TTS error:", error);

                               if (this.speechSynthesizer) {
                                   this.speechSynthesizer.close();
                                   this.speechSynthesizer = null;
                               }

                               this.isSpeaking = false;
                               document.getElementById('voice-indicator').classList.remove('active');
                               reject(error);
                           }
                       );
                   });
               } catch (error) {
                   console.error("Azure TTS error:", error);
                   this.isSpeaking = false;
                   document.getElementById('voice-indicator').classList.remove('active');
                   // Fallback to browser TTS
                   await this.speakWithBrowser(text);
               }
           }

           async speakWithBrowser(text) {
               return new Promise((resolve, reject) => {
                   try {
                       const utterance = new SpeechSynthesisUtterance(text);
                       utterance.rate = 1.0;
                       utterance.pitch = 1.0;
                       utterance.volume = 1.0;

                       // Select a natural voice if available
                       const voices = this.synthesis.getVoices();
                       const preferredVoice = voices.find(voice =>
                           voice.name.includes('Microsoft') ||
                           voice.name.includes('Google') ||
                           voice.name.includes('Natural')
                       ) || voices[0];

                       if (preferredVoice) {
                           utterance.voice = preferredVoice;
                       }

                       utterance.onstart = () => {
                           this.isSpeaking = true;
                           document.getElementById('voice-indicator').classList.add('active');
                       };

                       utterance.onend = () => {
                           this.isSpeaking = false;
                           document.getElementById('voice-indicator').classList.remove('active');
                           resolve();
                       };

                       utterance.onerror = (error) => {
                           this.isSpeaking = false;
                           document.getElementById('voice-indicator').classList.remove('active');
                           reject(error);
                       };

                       this.synthesis.speak(utterance);
                   } catch (error) {
                       this.isSpeaking = false;
                       document.getElementById('voice-indicator').classList.remove('active');
                       reject(error);
                   }
               });
           }

           stopSpeaking() {
               if (this.speechSynthesizer) {
                   try {
                       this.speechSynthesizer.close();
                   } catch (e) {
                       console.warn("Error closing speech synthesizer:", e);
                   }
                   this.speechSynthesizer = null;
               }

               if (window.speechSynthesis) {
                   try {
                       window.speechSynthesis.cancel();
                   } catch (e) {
                       console.warn("Error canceling speech synthesis:", e);
                   }
               }

               this.isSpeaking = false;
               document.getElementById('voice-indicator').classList.remove('active');
           }

           cleanTextForSpeech(text) {
               let cleanText = text.replace(/<[^>]*>/g, " ");

               cleanText = cleanText
                   .replace(/\*\*([^*]+)\*\*/g, "$1")
                   .replace(/\*([^*]+)\*/g, "$1")
                   .replace(/`([^`]+)`/g, "$1")
                   .replace(/\[([^\]]+)\]\([^)]+\)/g, "$1")
                   .replace(/#{1,6}\s+([^\n]+)/g, "$1")
                   .replace(/```[\s\S]*?```/g, "")
                   .replace(/\n/g, " ")
                   .replace(/\s+/g, " ")
                   .trim();

               return cleanText;
           }

           startListening(callback) {
               if (!this.recognition || this.isListening) return;

               this.recognition.onresult = (event) => {
                   const last = event.results.length - 1;
                   const transcript = event.results[last][0].transcript;

                   if (event.results[last].isFinal) {
                       callback(transcript);
                   }
               };

               this.recognition.start();
           }

           stopListening() {
               if (this.recognition && this.isListening) {
                   this.recognition.stop();
               }
           }

           toggleListening(callback) {
               if (this.isListening) {
                   this.stopListening();
               } else {
                   this.startListening(callback);
               }
           }
       }

       // Time Machine
       class TimeMachine {
           constructor() {
               this.messages = [];
               this.currentIndex = 0;
               this.isPlaying = false;
               this.playInterval = null;
           }

           init(messages) {
               this.messages = messages;
               this.currentIndex = 0;
               this.isPlaying = false;
               this.updateProgress();
           }

           play() {
               if (this.isPlaying) return;
               this.isPlaying = true;

               this.playInterval = setInterval(() => {
                   if (this.currentIndex >= this.messages.length - 1) {
                       this.pause();
                       return;
                   }
                   this.next();
               }, 1500);

               this.updatePlayButton();
           }

           pause() {
               this.isPlaying = false;
               if (this.playInterval) {
                   clearInterval(this.playInterval);
                   this.playInterval = null;
               }
               this.updatePlayButton();
           }

           next() {
               if (this.currentIndex < this.messages.length - 1) {
                   this.currentIndex++;
                   this.displayUpToIndex();
                   this.updateProgress();
               }
           }

           prev() {
               if (this.currentIndex > 0) {
                   this.currentIndex--;
                   this.displayUpToIndex();
                   this.updateProgress();
               }
           }

           stop() {
               this.pause();
               this.currentIndex = this.messages.length - 1;
               this.displayUpToIndex();
               this.updateProgress();
               document.getElementById('time-machine-modal').classList.remove('active');
           }

           displayUpToIndex() {
               const chatMessages = document.getElementById('chat-messages');
               chatMessages.innerHTML = '';

               for (let i = 0; i <= this.currentIndex; i++) {
                   const msg = this.messages[i];
                   if (msg.isViewer) {
                       const messageWrapper = ui.createMessageElement(msg.role, msg.content);
                       messageWrapper.classList.add('viewer-message');
                       messageWrapper.setAttribute('data-viewer-name', msg.viewerName);
                       chatMessages.appendChild(messageWrapper);
                   } else {
                       ui.addMessageToUI(msg.role, msg.content, false);
                   }
               }

               ui.scrollToBottom();
           }

           updateProgress() {
               const progress = document.getElementById('time-machine-progress');
               progress.textContent = `${this.currentIndex + 1} / ${this.messages.length}`;
           }

           updatePlayButton() {
               const playButton = document.getElementById('time-machine-play');
               const icon = playButton.querySelector('i');
               if (this.isPlaying) {
                   icon.className = 'fas fa-pause';
               } else {
                   icon.className = 'fas fa-play';
               }
           }
       }

       // Initialize global instances
       const appState = new AppState();
       const soundManager = new SoundManager();
       const voiceManager = new VoiceManager();
       const timeMachine = new TimeMachine();

       // UI Controller
       class UIController {
           constructor() {
               this.loginPage = document.getElementById('login-page');
               this.appPage = document.getElementById('app');
               this.sidebar = document.getElementById('sidebar');
               this.sidebarOverlay = document.getElementById('sidebar-overlay');
               this.chatMessages = document.getElementById('chat-messages');
               this.userInput = document.getElementById('user-input');
               this.sendButton = document.getElementById('send-button');
               this.imagePreviewContainer = document.getElementById('image-preview-container');
               this.pendingImage = null;
               this.showModeManager = null;
               this.collabManager = null;
               this.typingTimeout = null;

               this.initializeEventListeners();
               this.checkExistingSession();
               
               // Initialize show mode and collab mode after UI is ready
               setTimeout(() => {
                   this.showModeManager = new ShowModeManager(this);
                   this.collabManager = new CollabManager(this);
                   
                   // Clean up any stray loading indicators on startup
                   const loadingIndicators = document.querySelectorAll('.loading');
                   loadingIndicators.forEach(indicator => {
                       if (!indicator.classList.contains('active')) {
                           indicator.remove();
                       }
                   });
               }, 100);
           }

           initializeEventListeners() {
               // Login form
               document.getElementById('login-form').addEventListener('submit', (e) => {
                   e.preventDefault();
                   this.handleLogin();
               });

               // Header buttons
               document.getElementById('sidebar-toggle').addEventListener('click', () => {
                   this.toggleSidebar();
               });

               document.getElementById('archive-chat').addEventListener('click', () => {
                   this.archiveCurrentChat();
               });

               document.getElementById('theme-toggle').addEventListener('click', () => {
                   this.toggleTheme();
               });

               document.getElementById('logout').addEventListener('click', () => {
                   this.logout();
               });

               // Clear chat button (floating)
               document.getElementById('clear-chat').addEventListener('click', () => {
                   this.clearCurrentChat();
               });

               // Collab mode button
               document.getElementById('collab-mode-button').addEventListener('click', () => {
                   if (this.collabManager) {
                       this.collabManager.toggle();
                   }
               });

               // Voice toggle button
               document.getElementById('voice-toggle').addEventListener('click', () => {
                   // Check if voice is supported
                   if (!voiceManager.recognition) {
                       this.showNotification('Voice input is not supported in your browser. Please use Chrome or text input.', 'warning');
                       return;
                   }

                   // Check if voice is enabled in settings
                   if (!appState.settings.voiceEnabled) {
                       this.showNotification('Voice features are disabled. Enable them in settings.', 'info');
                       this.openSettings();
                       return;
                   }

                   voiceManager.toggleListening((transcript) => {
                       this.userInput.value = transcript;
                       // In collab mode, auto-send on voice input
                       if (this.collabManager && this.collabManager.isActive) {
                           this.sendMessage();
                       }
                   });
               });

               // Sidebar
               this.sidebarOverlay.addEventListener('click', () => {
                   this.toggleSidebar();
               });

               // Sidebar tabs
               document.querySelectorAll('.sidebar-tab').forEach(tab => {
                   tab.addEventListener('click', (e) => {
                       this.switchSidebarTab(e.target.dataset.tab);
                   });
               });

               // Chat controls
               document.getElementById('new-chat').addEventListener('click', () => {
                   this.createNewChat();
                   this.toggleSidebar();
               });

               document.getElementById('send-button').addEventListener('click', () => {
                   this.sendMessage();
               });

               this.userInput.addEventListener('keypress', (e) => {
                   if (e.key === 'Enter' && !e.shiftKey) {
                       e.preventDefault();
                       this.sendMessage();
                   }
               });

               // Typing indicator for show mode
               let isCurrentlyTyping = false;
               this.userInput.addEventListener('input', () => {
                   this.userInput.style.height = 'auto';
                   this.userInput.style.height = Math.min(this.userInput.scrollHeight, 120) + 'px';
                   
                   // Broadcast typing indicator
                   if (this.showModeManager && this.showModeManager.isHost) {
                       if (this.typingTimeout) clearTimeout(this.typingTimeout);
                       
                       // Only send typing indicator if not already typing
                       if (!isCurrentlyTyping && this.userInput.value.trim().length > 0) {
                           isCurrentlyTyping = true;
                           this.showModeManager.broadcastTypingIndicator(true);
                       }
                       
                       // Clear typing indicator after user stops typing
                       this.typingTimeout = setTimeout(() => {
                           isCurrentlyTyping = false;
                           this.showModeManager.broadcastTypingIndicator(false);
                       }, 1000);
                       
                       // If input is empty, immediately stop typing indicator
                       if (this.userInput.value.trim().length === 0) {
                           isCurrentlyTyping = false;
                           this.showModeManager.broadcastTypingIndicator(false);
                       }
                   }
               });

               // Image upload
               document.getElementById('upload-image').addEventListener('click', () => {
                   document.getElementById('image-upload-input').click();
               });

               document.getElementById('image-upload-input').addEventListener('change', (e) => {
                   if (e.target.files[0]) {
                       this.handleImageUpload(e.target.files[0]);
                   }
               });

               // Paste event for images
               this.userInput.addEventListener('paste', (e) => {
                   const items = e.clipboardData.items;
                   for (let item of items) {
                       if (item.type.indexOf('image') !== -1) {
                           const file = item.getAsFile();
                           this.handleImageUpload(file);
                           e.preventDefault();
                       }
                   }
               });

               // Menu
               const menuToggle = document.getElementById('menu-toggle');
               const menuItems = document.getElementById('menu-items');

               menuToggle.addEventListener('click', () => {
                   const isOpen = menuToggle.classList.toggle('active');
                   menuItems.classList.toggle('open');
               });

               // Close menu when clicking outside
               document.addEventListener('click', (e) => {
                   if (!menuToggle.contains(e.target) && !menuItems.contains(e.target)) {
                       menuToggle.classList.remove('active');
                       menuItems.classList.remove('open');
                   }
               });

               // Menu items
               document.getElementById('export-chat').addEventListener('click', () => {
                   this.exportCurrentChat();
                   this.closeMenu();
               });

               document.getElementById('import-chat').addEventListener('click', () => {
                   document.getElementById('chat-import-input').click();
                   this.closeMenu();
               });

               document.getElementById('export-all').addEventListener('click', () => {
                   this.exportAllData();
                   this.closeMenu();
               });

               document.getElementById('import-all').addEventListener('click', () => {
                   document.getElementById('data-import-input').click();
                   this.closeMenu();
               });

               document.getElementById('time-machine').addEventListener('click', () => {
                   this.openTimeMachine();
                   this.closeMenu();
               });

               document.getElementById('settings').addEventListener('click', () => {
                   this.openSettings();
                   this.closeMenu();
               });

               // File inputs
               document.getElementById('chat-import-input').addEventListener('change', (e) => {
                   if (e.target.files[0]) {
                       this.importChat(e.target.files[0]);
                   }
               });

               document.getElementById('data-import-input').addEventListener('change', (e) => {
                   if (e.target.files[0]) {
                       this.importAllData(e.target.files[0]);
                   }
               });

               // Drag and drop
               this.initializeDragAndDrop();

               // Settings modal
               document.getElementById('settings-close').addEventListener('click', () => {
                   document.getElementById('settings-modal').classList.remove('active');
               });

               document.getElementById('dark-mode-toggle').addEventListener('click', (e) => {
                   e.target.classList.toggle('active');
                   this.toggleTheme();
               });

               document.getElementById('sound-toggle').addEventListener('click', (e) => {
                   const isActive = e.target.classList.toggle('active');
                   appState.settings.soundEnabled = isActive;
                   appState.saveSettings();
                   soundManager.setEnabled(isActive);
               });

               document.getElementById('voice-enabled-toggle').addEventListener('click', (e) => {
                   const isActive = e.target.classList.toggle('active');
                   appState.settings.voiceEnabled = isActive;
                   appState.saveSettings();
                   voiceManager.setEnabled(isActive);
               });

               document.getElementById('auto-speak-toggle').addEventListener('click', (e) => {
                   const isActive = e.target.classList.toggle('active');
                   appState.settings.autoSpeak = isActive;
                   appState.saveSettings();
                   voiceManager.setAutoSpeak(isActive);
               });

               // Azure TTS settings
               document.getElementById('azure-tts-key').addEventListener('change', (e) => {
                   appState.settings.azureTTSKey = e.target.value.trim();
                   appState.saveSettings();
                   voiceManager.setAzureKey(appState.settings.azureTTSKey);
               });

               document.getElementById('tts-voice-select').addEventListener('change', (e) => {
                   appState.settings.ttsVoiceName = e.target.value;
                   appState.saveSettings();
                   voiceManager.setVoiceName(appState.settings.ttsVoiceName);
               });

               // API Configuration
               document.getElementById('save-api-config').addEventListener('click', () => {
                   const endpoint = document.getElementById('api-endpoint').value.trim();
                   const guid = document.getElementById('user-guid').value.trim();
                   const key = document.getElementById('function-key-input').value.trim();
                   
                   if (endpoint && guid && key) {
                       appState.saveApiConfig(endpoint, guid, key);
                       this.showNotification('API configuration saved successfully!', 'success');
                   } else {
                       this.showNotification('Please fill in all API configuration fields', 'warning');
                   }
               });

               // Collab Mode settings
               document.getElementById('gesture-control-toggle').addEventListener('click', (e) => {
                   const isActive = e.target.classList.toggle('active');
                   appState.settings.gestureControlEnabled = isActive;
                   appState.saveSettings();
                   
                   if (this.collabManager && this.collabManager.gestureManager) {
                       this.collabManager.gestureManager.setEnabled(isActive);
                   }
               });

               document.getElementById('collab-auto-voice-toggle').addEventListener('click', (e) => {
                   const isActive = e.target.classList.toggle('active');
                   appState.settings.collabAutoVoice = isActive;
                   appState.saveSettings();
                   
                   if (this.collabManager) {
                       this.collabManager.setAutoVoice(isActive);
                   }
               });

               document.getElementById('clear-all-data').addEventListener('click', () => {
                   if (confirm('Are you sure you want to clear all data? This cannot be undone.')) {
                       appState.clearAllData();
                       location.reload();
                   }
               });

               // Time Machine modal
               document.getElementById('time-machine-close').addEventListener('click', () => {
                   timeMachine.stop();
               });

               document.getElementById('time-machine-start').addEventListener('click', () => {
                   const chat = appState.chats[appState.currentUser.id][appState.currentChatId];
                   if (chat && chat.messages.length > 0) {
                       timeMachine.init(chat.messages);
                       document.getElementById('time-machine-controls').classList.remove('hidden');
                       timeMachine.displayUpToIndex();
                   }
               });

               document.getElementById('time-machine-prev').addEventListener('click', () => {
                   timeMachine.prev();
               });

               document.getElementById('time-machine-play').addEventListener('click', () => {
                   if (timeMachine.isPlaying) {
                       timeMachine.pause();
                   } else {
                       timeMachine.play();
                   }
               });

               document.getElementById('time-machine-next').addEventListener('click', () => {
                   timeMachine.next();
               });

               document.getElementById('time-machine-stop').addEventListener('click', () => {
                   timeMachine.stop();
               });
           }

           initializeDragAndDrop() {
               const dropZone = document.getElementById('drop-zone');
               let dragCounter = 0;

               document.addEventListener('dragenter', (e) => {
                   e.preventDefault();
                   dragCounter++;
                   dropZone.classList.add('active');
               });

               document.addEventListener('dragleave', (e) => {
                   e.preventDefault();
                   dragCounter--;
                   if (dragCounter === 0) {
                       dropZone.classList.remove('active');
                   }
               });

               document.addEventListener('dragover', (e) => {
                   e.preventDefault();
               });

               document.addEventListener('drop', (e) => {
                   e.preventDefault();
                   dragCounter = 0;
                   dropZone.classList.remove('active');

                   const files = Array.from(e.dataTransfer.files);
                   files.forEach(file => {
                       if (file.type.startsWith('image/')) {
                           this.handleImageUpload(file);
                       } else if (file.type === 'application/json') {
                           this.handleJsonImport(file);
                       }
                   });
               });
           }

           checkExistingSession() {
               const urlParams = new URLSearchParams(window.location.search);
               const showId = urlParams.get('show');
               
               // If we're joining as a viewer, skip normal login
               if (showId) {
                   // Set up temporary viewer session
                   appState.currentUser = {
                       id: 'viewer-' + Math.random().toString(36).substr(2, 9),
                       username: 'Viewer',
                       isViewer: true
                   };
                   this.showApp();
                   return;
               }
               
               // Normal login flow
               const lastUserId = localStorage.getItem('lastUserId');
               if (lastUserId && appState.users[lastUserId]) {
                   appState.currentUser = appState.users[lastUserId];
                   this.showApp();
               } else {
                   this.showLogin();
               }
           }

           showLogin() {
               this.loginPage.classList.remove('hidden');
               this.appPage.classList.add('hidden');
               this.loadRecentUsers();
           }

           showApp() {
               this.loginPage.classList.add('hidden');
               this.appPage.classList.remove('hidden');

               document.getElementById('current-username').textContent = appState.currentUser.username;

               // Skip normal chat loading for viewers
               if (appState.currentUser.isViewer) {
                   this.applyTheme();
                   this.applySettings();
                   
                   // Clear any default content
                   this.clearChatMessages();
                   return;
               }

               this.loadUserChats();
               this.applyTheme();
               this.applySettings();

               // Load last active chat or create new one
               const activeChats = appState.getActiveChats(appState.currentUser.id);
               if (activeChats.length > 0) {
                   this.loadChat(activeChats[0].id);
               } else {
                   this.createNewChat();
               }
           }

           loadRecentUsers() {
               const recentUsersContainer = document.getElementById('recent-users');
               recentUsersContainer.innerHTML = '';

               const users = Object.values(appState.users)
                   .sort((a, b) => new Date(b.lastActive) - new Date(a.lastActive))
                   .slice(0, 5);

               users.forEach(user => {
                   const userElement = document.createElement('div');
                   userElement.className = 'user-item';
                   userElement.innerHTML = `
                       <div class="user-info">
                           <div class="user-name">${user.username}</div>
                           <div class="user-last-active">Last active: ${this.formatDate(user.lastActive)}</div>
                       </div>
                       <i class="fas fa-chevron-right"></i>
                   `;
                   userElement.addEventListener('click', () => {
                       document.getElementById('username').value = user.username;
                       this.handleLogin();
                   });
                   recentUsersContainer.appendChild(userElement);
               });
           }

           handleLogin() {
               const username = document.getElementById('username').value.trim();
               if (!username) return;

               // Find or create user
               let user = Object.values(appState.users).find(u => u.username === username);
               if (!user) {
                   user = appState.createUser(username);
               }

               appState.currentUser = user;
               localStorage.setItem('lastUserId', user.id);

               this.showApp();
           }

           logout() {
               appState.currentUser = null;
               localStorage.removeItem('lastUserId');
               this.showLogin();
           }

           toggleSidebar() {
               this.sidebar.classList.toggle('open');
               this.sidebarOverlay.classList.toggle('active');
           }

           switchSidebarTab(tab) {
               document.querySelectorAll('.sidebar-tab').forEach(t => {
                   t.classList.toggle('active', t.dataset.tab === tab);
               });

               document.getElementById('chat-list-active').classList.toggle('hidden', tab !== 'active');
               document.getElementById('chat-list-archived').classList.toggle('hidden', tab !== 'archived');

               this.loadUserChats(tab);
           }

           loadUserChats(tab = 'active') {
               const containerId = tab === 'active' ? 'chat-list-active' : 'chat-list-archived';
               const chatList = document.getElementById(containerId);
               chatList.innerHTML = '';

               const chats = tab === 'active'
                   ? appState.getActiveChats(appState.currentUser.id)
                   : appState.getArchivedChats(appState.currentUser.id);

               if (chats.length === 0) {
                   chatList.innerHTML = `<div class="chat-list-empty">No ${tab} chats</div>`;
                   return;
               }

               chats.forEach(chat => {
                   const chatElement = document.createElement('div');
                   chatElement.className = 'chat-item';
                   if (chat.id === appState.currentChatId) {
                       chatElement.classList.add('active');
                   }

                   const lastMessage = chat.messages[chat.messages.length - 1];
                   const preview = lastMessage ? this.truncateText(lastMessage.content, 50) : 'New conversation';

                   chatElement.innerHTML = `
                       <div class="chat-item-title">${chat.title}</div>
                       <div class="chat-item-preview">${preview}</div>
                       <div class="chat-item-date">${this.formatDate(chat.updatedAt)}</div>
                       <div class="chat-item-actions">
                           ${tab === 'active'
                               ? '<button class="chat-item-action" title="Archive"><i class="fas fa-archive"></i></button>'
                               : '<button class="chat-item-action" title="Restore"><i class="fas fa-undo"></i></button>'
                           }
                           <button class="chat-item-action" title="Delete"><i class="fas fa-trash"></i></button>
                       </div>
                   `;

                   // Click to load chat
                   chatElement.addEventListener('click', (e) => {
                       if (!e.target.closest('.chat-item-action')) {
                           this.loadChat(chat.id);
                           this.toggleSidebar();
                       }
                   });

                   // Archive/Restore button
                   const archiveBtn = chatElement.querySelector('.chat-item-action:first-child');
                   archiveBtn.addEventListener('click', (e) => {
                       e.stopPropagation();
                       if (tab === 'active') {
                           appState.archiveChat(appState.currentUser.id, chat.id);
                           if (chat.id === appState.currentChatId) {
                               this.createNewChat();
                           }
                       } else {
                           appState.unarchiveChat(appState.currentUser.id, chat.id);
                       }
                       this.loadUserChats(tab);
                   });

                   // Delete button
                   const deleteBtn = chatElement.querySelector('.chat-item-action:last-child');
                   deleteBtn.addEventListener('click', (e) => {
                       e.stopPropagation();
                       if (confirm('Are you sure you want to permanently delete this chat?')) {
                           appState.deleteChat(appState.currentUser.id, chat.id);
                           if (chat.id === appState.currentChatId) {
                               this.createNewChat();
                           }
                           this.loadUserChats(tab);
                       }
                   });

                   chatList.appendChild(chatElement);
               });
           }

           createNewChat() {
               const chat = appState.createChat(appState.currentUser.id);
               appState.currentChatId = chat.id;
               this.loadUserChats('active');
               this.clearChatMessages();
           }

           loadChat(chatId) {
               const chat = appState.chats[appState.currentUser.id][chatId];
               if (!chat) return;

               appState.currentChatId = chatId;
               this.loadUserChats(chat.archived ? 'archived' : 'active');
               this.displayChatMessages(chat.messages);
           }

           clearCurrentChat() {
               if (!appState.currentChatId) return;

               const chat = appState.chats[appState.currentUser.id][appState.currentChatId];
               if (!chat || chat.messages.length === 0) {
                   this.createNewChat();
                   return;
               }

               // Move current chat to active (if it was archived) and create new
               if (chat.archived) {
                   appState.unarchiveChat(appState.currentUser.id, appState.currentChatId);
               }

               this.createNewChat();
               this.showNotification('Chat cleared', 'info');
           }

           archiveCurrentChat() {
               if (!appState.currentChatId) return;

               const chat = appState.chats[appState.currentUser.id][appState.currentChatId];
               if (!chat || chat.messages.length === 0) return;

               if (confirm('Archive this chat? You can restore it later from the archived tab.')) {
                   appState.archiveChat(appState.currentUser.id, appState.currentChatId);
                   this.createNewChat();
               }
           }

           displayChatMessages(messages) {
               this.chatMessages.innerHTML = '';
               messages.forEach(message => {
                   if (message.isViewer) {
                       const messageWrapper = this.createMessageElement(message.role, message.content);
                       messageWrapper.classList.add('viewer-message');
                       messageWrapper.setAttribute('data-viewer-name', message.viewerName);
                       this.chatMessages.appendChild(messageWrapper);
                   } else {
                       this.addMessageToUI(message.role, message.content, false, message.voiceResponse);
                   }
               });
               this.scrollToBottom();
           }

           clearChatMessages() {
               this.chatMessages.innerHTML = '';
           }

           createMessageElement(role, content) {
               const messageWrapper = document.createElement('div');
               messageWrapper.className = `message-wrapper ${role}`;

               if (role === 'system') {
                   const systemMessage = document.createElement('div');
                   systemMessage.className = 'system-message';
                   
                   // Extract agent information and create collapsible wrapper
                   const agentMatch = content.match(/Agent: ([^\n]+)/);
                   if (agentMatch) {
                       const agentName = agentMatch[1];
                       const uniqueId = 'agent-output-' + Math.random().toString(36).substr(2, 9);
                       
                       const agentWrapper = document.createElement('div');
                       agentWrapper.className = 'agent-output-wrapper';
                       agentWrapper.id = uniqueId;
                       
                       agentWrapper.innerHTML = `
                           <div class="agent-output-header" onclick="ui.toggleAgentOutput('${uniqueId}')">
                               <div class="agent-output-title">
                                   <i class="fas fa-robot"></i>
                                   <span>Agent: ${agentName}</span>
                               </div>
                               <button class="agent-output-toggle">
                                   <i class="fas fa-chevron-down"></i>
                               </button>
                           </div>
                           <div class="agent-output-content" id="${uniqueId}-content">
                               <div class="agent-output-text">${content}</div>
                           </div>
                       `;
                       
                       messageWrapper.appendChild(agentWrapper);
                   } else {
                       systemMessage.textContent = content;
                       messageWrapper.appendChild(systemMessage);
                   }
               } else {
                   const label = document.createElement('div');
                   label.className = 'message-label';
                   label.textContent = role === 'user' ? 'You' : appState.currentUser.username + "'s Assistant";

                   const messageContent = document.createElement('div');
                   messageContent.className = 'message-content';

                   if (role === 'user' && content.startsWith('data:image')) {
                       messageContent.innerHTML = `<img src="${content}" alt="Uploaded image" style="max-width: 100%; border-radius: 8px;">`;
                   } else {
                       messageContent.innerHTML = this.formatMessage(content);
                   }

                   messageWrapper.appendChild(label);
                   messageWrapper.appendChild(messageContent);
               }

               return messageWrapper;
           }

           toggleAgentOutput(id) {
               const content = document.getElementById(id + '-content');
               const header = document.querySelector(`#${id} .agent-output-header`);
               const toggleIcon = header.querySelector('.agent-output-toggle i');

               if (content.classList.contains('expanded')) {
                   content.classList.remove('expanded');
                   toggleIcon.className = 'fas fa-chevron-down';
               } else {
                   content.classList.add('expanded');
                   toggleIcon.className = 'fas fa-chevron-up';
               }
           }

           addMessageToUI(role, content, animate = true, voiceResponse = null) {
               const messageWrapper = this.createMessageElement(role, content);

               // Add voice indicator for assistant messages with voice response
               if (role === 'assistant' && voiceResponse) {
                   const voiceMessage = document.createElement('div');
                   voiceMessage.className = 'voice-message active';
                   voiceMessage.innerHTML = `
                       <i class="fas fa-volume-up"></i>
                       <span>Voice: "${voiceResponse}"</span>
                   `;
                   messageWrapper.appendChild(voiceMessage);
               }

               this.chatMessages.appendChild(messageWrapper);

               // Highlight code blocks
               if (role === 'assistant' || role === 'system') {
                   messageWrapper.querySelectorAll('pre code').forEach(block => {
                       hljs.highlightBlock(block);
                   });
               }

               if (animate) {
                   this.scrollToBottom();
               }
           }

           formatMessage(text) {
               // Handle code blocks with language specification
               text = text.replace(/```(\w+)?\n([\s\S]+?)```/g, (match, lang, code) => {
                   const language = lang || 'plaintext';
                   const escapedCode = this.escapeHtml(code.trim());
                   return `<pre><code class="${language}">${escapedCode}</code></pre>`;
               });

               // Handle inline code
               text = text.replace(/`([^`]+)`/g, '<code>$1</code>');

               // Handle bold text
               text = text.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');

               // Handle italic text
               text = text.replace(/\*([^*]+)\*/g, '<em>$1</em>');

               // Handle markdown images and links
               text = text.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, (match, altText, url) => {
                   return `<img src="${url}" alt="${altText || 'Image'}" style="max-width: 100%; border-radius: 8px; margin: 10px 0;">`;
               });

               text = text.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>');

               // Handle line breaks
               text = text.replace(/\n/g, '<br>');

               return text;
           }

           escapeHtml(text) {
               const div = document.createElement('div');
               div.textContent = text;
               return div.innerHTML;
           }

           async sendMessage() {
               const message = this.userInput.value.trim();
               if (!message && !this.pendingImage) return;

               // Clear typing indicator immediately when sending
               if (this.showModeManager && this.showModeManager.isHost) {
                   this.showModeManager.broadcastTypingIndicator(false);
               }

               // If we're a viewer, send to presenter instead
               if (this.showModeManager && this.showModeManager.isFollowing) {
                   this.showModeManager.sendViewerMessage(message);
                   this.userInput.value = '';
                   this.userInput.style.height = 'auto';
                   return;
               }

               // Check for API configuration
               if (!appState.functionKey || !appState.apiEndpoint) {
                   this.openSettings();
                   this.showNotification('Please configure your API settings', 'warning');
                   return;
               }

               // Disable send button
               this.sendButton.disabled = true;

               // Add message to UI and state
               const chat = appState.chats[appState.currentUser.id][appState.currentChatId];
               const userMessage = {
                   role: 'user',
                   content: this.pendingImage || message,
                   timestamp: new Date().toISOString()
               };

               chat.messages.push(userMessage);
               this.addMessageToUI('user', userMessage.content);

               // Clear input
               this.userInput.value = '';
               this.userInput.style.height = 'auto';
               this.clearImagePreview();

               // Play send sound
               soundManager.playSendSound();

               // Show loading indicator as a message bubble
               this.showLoadingIndicator();

               // Broadcast typing and message to viewers
               if (this.showModeManager && this.showModeManager.isHost) {
                   this.showModeManager.broadcastChatMessage('user', userMessage.content);
                   this.showModeManager.broadcastVoiceActivity('idle');
               }

               try {
                   // Send to API
                   const response = await fetch(appState.apiEndpoint, {
                       method: 'POST',
                       headers: {
                           'Content-Type': 'application/json',
                           'x-functions-key': appState.functionKey
                       },
                       body: JSON.stringify({
                           user_input: message || 'Please analyze this image',
                           conversation_history: chat.messages,
                           user_guid: appState.userGuid || appState.currentUser.id
                       })
                   });

                   if (!response.ok) {
                       if (response.status === 401) {
                           throw new Error('Invalid function key. Please check your settings.');
                       }
                       throw new Error(`HTTP error! status: ${response.status}`);
                   }

                   const data = await response.json();

                   // Hide loading indicator
                   this.hideLoadingIndicator();

                   // Add assistant response with voice response
                   const assistantMessage = {
                       role: 'assistant',
                       content: data.assistant_response || data.text || 'Sorry, I received an empty response.',
                       voiceResponse: data.voice_response || null,
                       timestamp: new Date().toISOString()
                   };

                   chat.messages.push(assistantMessage);
                   this.addMessageToUI('assistant', assistantMessage.content, true, assistantMessage.voiceResponse);

                   // Play receive sound
                   soundManager.playReceiveSound();

                   // Broadcast to viewers
                   if (this.showModeManager && this.showModeManager.isHost) {
                       this.showModeManager.broadcastChatMessage('assistant', assistantMessage.content, assistantMessage.voiceResponse);
                   }

                   // Speak the voice response if auto-speak is enabled or in collab mode
                   if ((appState.settings.autoSpeak || (this.collabManager && this.collabManager.isActive)) && assistantMessage.voiceResponse) {
                       if (this.showModeManager && this.showModeManager.isHost) {
                           this.showModeManager.broadcastVoiceActivity('speaking');
                       }
                       await voiceManager.speak(assistantMessage.voiceResponse);
                       if (this.showModeManager && this.showModeManager.isHost) {
                           this.showModeManager.broadcastVoiceActivity('idle');
                       }
                   }

                   // Add system message if present
                   if (data.agent_logs) {
                       const systemMessage = {
                           role: 'system',
                           content: data.agent_logs,
                           timestamp: new Date().toISOString()
                       };
                       chat.messages.push(systemMessage);
                       this.addMessageToUI('system', systemMessage.content);
                       
                       if (this.showModeManager && this.showModeManager.isHost) {
                           this.showModeManager.broadcastChatMessage('system', systemMessage.content);
                       }
                   }

                   // Update chat metadata
                   chat.updatedAt = new Date().toISOString();
                   if (chat.messages.length === 2) {
                       // Auto-generate title from first exchange
                       chat.title = this.generateChatTitle(message || 'Image analysis');
                   }

                   appState.saveChats();
                   this.loadUserChats('active');

               } catch (error) {
                   console.error('Error:', error);
                   this.hideLoadingIndicator();
                   this.addMessageToUI('system', `Error: ${error.message}`);
                   soundManager.playNotificationSound();
               } finally {
                   this.sendButton.disabled = false;
                   this.userInput.focus();
               }
           }

           showLoadingIndicator() {
               // Remove any existing loading indicators first
               const existingLoading = document.getElementById('loading-indicator');
               if (existingLoading) {
                   existingLoading.remove();
               }
               
               const loadingDiv = document.createElement('div');
               loadingDiv.className = 'loading active';
               loadingDiv.id = 'loading-indicator';
               loadingDiv.innerHTML = `
                   <span></span>
                   <span></span>
                   <span></span>
               `;
               this.chatMessages.appendChild(loadingDiv);
               this.scrollToBottom();
           }

           hideLoadingIndicator() {
               const loadingIndicators = document.querySelectorAll('.loading');
               loadingIndicators.forEach(indicator => {
                   indicator.remove();
               });
           }

           handleImageUpload(file) {
               if (!file || !file.type.startsWith('image/')) return;

               const reader = new FileReader();
               reader.onload = (e) => {
                   this.pendingImage = e.target.result;
                   this.showImagePreview(e.target.result);
               };
               reader.readAsDataURL(file);
           }

           showImagePreview(imageSrc) {
               this.imagePreviewContainer.innerHTML = `
                   <div class="image-preview">
                       <img src="${imageSrc}" alt="Preview">
                       <button class="image-preview-remove" onclick="ui.clearImagePreview()">
                           <i class="fas fa-times"></i>
                       </button>
                   </div>
               `;
               this.imagePreviewContainer.classList.add('active');
           }

           clearImagePreview() {
               this.pendingImage = null;
               this.imagePreviewContainer.innerHTML = '';
               this.imagePreviewContainer.classList.remove('active');
           }

           exportCurrentChat() {
               if (!appState.currentChatId) return;

               const chat = appState.chats[appState.currentUser.id][appState.currentChatId];
               
               const exportData = {
                   chat: chat,
                   user: {
                       id: appState.currentUser.id,
                       username: appState.currentUser.username
                   },
                   exportDate: new Date().toISOString(),
                   version: '2.0'
               };

               const filename = `chat-${chat.title.replace(/[^a-z0-9]/gi, '_')}-${Date.now()}.json`;
               this.downloadJson(exportData, filename);
           }

           exportAllData() {
               const exportData = appState.exportAllData();
               this.downloadJson(exportData, `chat-app-backup-${Date.now()}.json`);
           }

           downloadJson(data, filename) {
               const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
               const url = URL.createObjectURL(blob);
               const a = document.createElement('a');
               a.href = url;
               a.download = filename;
               document.body.appendChild(a);
               a.click();
               document.body.removeChild(a);
               URL.revokeObjectURL(url);
           }

           importChat(file) {
               const reader = new FileReader();
               reader.onload = (e) => {
                   try {
                       const data = JSON.parse(e.target.result);
                       
                       if (data.chat) {
                           // New format
                           const newChat = appState.createChat(appState.currentUser.id, data.chat.title || 'Imported Chat');
                           newChat.messages = data.chat.messages;
                           newChat.updatedAt = new Date().toISOString();

                           appState.saveChats();
                           this.loadChat(newChat.id);
                           this.loadUserChats('active');
                           this.showNotification('Chat imported successfully!', 'success');
                       } else {
                           throw new Error('Invalid chat format');
                       }
                   } catch (error) {
                       this.showNotification('Error importing chat: ' + error.message, 'error');
                   }
               };
               reader.readAsText(file);
           }

           importAllData(file) {
               const reader = new FileReader();
               reader.onload = (e) => {
                   try {
                       const data = JSON.parse(e.target.result);
                       if (!data.version || !data.users || !data.chats) {
                           throw new Error('Invalid backup format');
                       }

                       if (confirm('This will merge the imported data with your existing data. Continue?')) {
                           appState.importAllData(data);
                           this.showNotification('Data imported successfully! Please login again.', 'success');
                           this.logout();
                       }
                   } catch (error) {
                       this.showNotification('Error importing data: ' + error.message, 'error');
                   }
               };
               reader.readAsText(file);
           }

           handleJsonImport(file) {
               // Try to determine if it's a chat export or full backup
               const reader = new FileReader();
               reader.onload = (e) => {
                   try {
                       const data = JSON.parse(e.target.result);
                       if (data.chat) {
                           // Single chat export
                           this.importChat(file);
                       } else if (data.users && data.chats) {
                           // Full backup
                           this.importAllData(file);
                       } else {
                           this.showNotification('Unknown file format', 'error');
                       }
                   } catch (error) {
                       this.showNotification('Error reading file: ' + error.message, 'error');
                   }
               };
               reader.readAsText(file);
           }

           generateChatTitle(firstMessage) {
               // Generate a more intelligent title
               const cleanMessage = firstMessage.replace(/[^\w\s]/g, '').toLowerCase();
               const words = cleanMessage.split(' ').filter(w => w.length > 3);

               if (words.length > 3) {
                   return words.slice(0, 3).join(' ');
               } else if (firstMessage.length > 30) {
                   return firstMessage.substring(0, 30) + '...';
               } else {
                   return firstMessage;
               }
           }

           toggleTheme() {
               const isDark = document.body.classList.toggle('dark');
               appState.settings.theme = isDark ? 'dark' : 'light';
               appState.saveSettings();

               const themeIcon = document.querySelector('#theme-toggle i');
               themeIcon.className = isDark ? 'fas fa-sun' : 'fas fa-moon';

               const darkModeToggle = document.getElementById('dark-mode-toggle');
               if (darkModeToggle) {
                   darkModeToggle.classList.toggle('active', isDark);
               }
           }

           applyTheme() {
               if (appState.settings.theme === 'dark') {
                   document.body.classList.add('dark');
                   document.querySelector('#theme-toggle i').className = 'fas fa-sun';
               }
           }

           applySettings() {
               // Apply theme
               this.applyTheme();

               // Apply sound settings
               soundManager.setEnabled(appState.settings.soundEnabled);

               // Apply voice settings
               voiceManager.setEnabled(appState.settings.voiceEnabled);
               voiceManager.setAutoSpeak(appState.settings.autoSpeak);
               voiceManager.setAzureKey(appState.settings.azureTTSKey);
               voiceManager.setVoiceName(appState.settings.ttsVoiceName);

               // Update settings UI if modal is open
               const darkModeToggle = document.getElementById('dark-mode-toggle');
               if (darkModeToggle) {
                   darkModeToggle.classList.toggle('active', appState.settings.theme === 'dark');
               }

               const soundToggle = document.getElementById('sound-toggle');
               if (soundToggle) {
                   soundToggle.classList.toggle('active', appState.settings.soundEnabled);
               }

               const voiceEnabledToggle = document.getElementById('voice-enabled-toggle');
               if (voiceEnabledToggle) {
                   voiceEnabledToggle.classList.toggle('active', appState.settings.voiceEnabled);
               }

               const autoSpeakToggle = document.getElementById('auto-speak-toggle');
               if (autoSpeakToggle) {
                   autoSpeakToggle.classList.toggle('active', appState.settings.autoSpeak);
               }

               // Update Azure TTS settings
               const azureTTSKeyInput = document.getElementById('azure-tts-key');
               if (azureTTSKeyInput && appState.settings.azureTTSKey) {
                   azureTTSKeyInput.value = appState.settings.azureTTSKey;
               }

               const ttsVoiceSelect = document.getElementById('tts-voice-select');
               if (ttsVoiceSelect) {
                   ttsVoiceSelect.value = appState.settings.ttsVoiceName;
               }

               // Update API configuration
               const apiEndpointInput = document.getElementById('api-endpoint');
               if (apiEndpointInput && appState.apiEndpoint) {
                   apiEndpointInput.value = appState.apiEndpoint;
               }

               const userGuidInput = document.getElementById('user-guid');
               if (userGuidInput && appState.userGuid) {
                   userGuidInput.value = appState.userGuid;
               }

               const functionKeyInput = document.getElementById('function-key-input');
               if (functionKeyInput && appState.functionKey) {
                   functionKeyInput.value = appState.functionKey;
               }

               // Update gesture control settings
               const gestureControlToggle = document.getElementById('gesture-control-toggle');
               if (gestureControlToggle) {
                   gestureControlToggle.classList.toggle('active', appState.settings.gestureControlEnabled);
               }

               const collabAutoVoiceToggle = document.getElementById('collab-auto-voice-toggle');
               if (collabAutoVoiceToggle) {
                   collabAutoVoiceToggle.classList.toggle('active', appState.settings.collabAutoVoice);
               }
           }

           openSettings() {
               this.applySettings();
               document.getElementById('settings-modal').classList.add('active');
           }

           openTimeMachine() {
               const chat = appState.chats[appState.currentUser.id][appState.currentChatId];
               if (!chat || chat.messages.length === 0) {
                   this.showNotification('No messages to replay in the current chat.', 'info');
                   return;
               }

               document.getElementById('time-machine-modal').classList.add('active');
               document.getElementById('time-machine-controls').classList.add('hidden');
           }

           closeMenu() {
               document.getElementById('menu-toggle').classList.remove('active');
               document.getElementById('menu-items').classList.remove('open');
           }

           scrollToBottom() {
               this.chatMessages.scrollTop = this.chatMessages.scrollHeight;
           }

           truncateText(text, maxLength) {
               if (text.length <= maxLength) return text;
               return text.substring(0, maxLength) + '...';
           }

           formatDate(dateString) {
               const date = new Date(dateString);
               const now = new Date();
               const diff = now - date;

               if (diff < 60000) return 'Just now';
               if (diff < 3600000) return `${Math.floor(diff / 60000)}m ago`;
               if (diff < 86400000) return `${Math.floor(diff / 3600000)}h ago`;
               if (diff < 604800000) return `${Math.floor(diff / 86400000)}d ago`;

               return date.toLocaleDateString();
           }

           showNotification(message, type = 'info') {
               // Create notification element
               const notification = document.createElement('div');
               notification.className = `notification notification-${type}`;
               notification.style.cssText = `
                   position: fixed;
                   top: 20px;
                   right: 20px;
                   background: ${type === 'success' ? 'var(--success)' : type === 'error' ? 'var(--error)' : type === 'warning' ? 'var(--warning)' : 'var(--info)'};
                   color: white;
                   padding: 16px 24px;
                   border-radius: var(--radius);
                   box-shadow: var(--shadow-large);
                   z-index: 2000;
                   animation: slideUp 0.3s ease-out;
                   max-width: 320px;
               `;
               notification.textContent = message;

               document.body.appendChild(notification);

               // Remove after 3 seconds
               setTimeout(() => {
                   notification.style.animation = 'fadeOut 0.3s ease-out';
                   setTimeout(() => {
                       document.body.removeChild(notification);
                   }, 300);
               }, 3000);
           }
       }

       // Initialize UI Controller
       const ui = new UIController();

       // Make UI instance globally accessible for inline event handlers
       window.ui = ui;

       // Initialize sound manager with saved settings
       soundManager.setEnabled(appState.settings.soundEnabled);

       // Initialize voice manager with saved settings
       voiceManager.setEnabled(appState.settings.voiceEnabled);
       voiceManager.setAutoSpeak(appState.settings.autoSpeak);
       voiceManager.setAzureKey(appState.settings.azureTTSKey);
       voiceManager.setVoiceName(appState.settings.ttsVoiceName);

       // Add keyboard navigation support
       document.addEventListener('keydown', (e) => {
           // Escape key to close modals and menus
           if (e.key === 'Escape') {
               const modals = document.querySelectorAll('.modal.active');
               modals.forEach(modal => {
                   modal.classList.remove('active');
               });

               if (document.getElementById('menu-items').classList.contains('open')) {
                   ui.closeMenu();
               }

               if (document.getElementById('sidebar').classList.contains('open')) {
                   ui.toggleSidebar();
               }

               // Exit collab mode with Escape
               if (ui.collabManager && ui.collabManager.isActive) {
                   ui.collabManager.deactivate();
               }
           }

           // Cmd/Ctrl + K to focus search/input
           if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
               e.preventDefault();
               document.getElementById('user-input').focus();
           }

           // Cmd/Ctrl + N for new chat
           if ((e.metaKey || e.ctrlKey) && e.key === 'n') {
               e.preventDefault();
               ui.createNewChat();
           }

           // Cmd/Ctrl + L for collab mode
           if ((e.metaKey || e.ctrlKey) && e.key === 'l') {
               e.preventDefault();
               if (ui.collabManager) {
                   ui.collabManager.toggle();
               }
           }

           // Cmd/Ctrl + Shift + C to clear chat
           if ((e.metaKey || e.ctrlKey) && e.shiftKey && e.key === 'C') {
               e.preventDefault();
               ui.clearCurrentChat();
           }
       });

       // Add fade out animation
       const style = document.createElement('style');
       style.textContent = `
           @keyframes fadeOut {
               to {
                   opacity: 0;
                   transform: translateY(-20px);
               }
           }
       `;
       document.head.appendChild(style);

       // Force load voices for speech synthesis
       if ('speechSynthesis' in window) {
           speechSynthesis.getVoices();
           // Some browsers need a second call
           window.speechSynthesis.onvoiceschanged = () => {
               speechSynthesis.getVoices();
           };
       }

       // Initialize MediaPipe if available
       window.addEventListener('load', () => {
           // Check if MediaPipe is loaded
           if (window.Hands && window.Camera) {
               console.log('MediaPipe loaded successfully');
           } else {
               console.warn('MediaPipe not loaded - gesture controls will be unavailable');
           }
       });

       // Handle visibility change (for pausing camera when tab is hidden)
       document.addEventListener('visibilitychange', () => {
           if (document.hidden) {
               // Pause camera if in collab mode
               if (ui.collabManager && ui.collabManager.gestureManager && ui.collabManager.gestureManager.isActive) {
                   ui.collabManager.gestureManager.camera.stop();
               }
           } else {
               // Resume camera if in collab mode
               if (ui.collabManager && ui.collabManager.gestureManager && ui.collabManager.gestureManager.isActive) {
                   ui.collabManager.gestureManager.camera.start();
               }
           }
       });

       // Prevent accidental navigation
       window.addEventListener('beforeunload', (e) => {
           const chat = appState.chats[appState.currentUser?.id]?.[appState.currentChatId];
           if (chat && chat.messages.length > 0) {
               e.preventDefault();
               e.returnValue = '';
           }
       });

       // Service worker registration for PWA support (optional)
       if ('serviceWorker' in navigator) {
           window.addEventListener('load', () => {
               navigator.serviceWorker.register('/sw.js').then(registration => {
                   console.log('ServiceWorker registration successful');
               }).catch(err => {
                   console.log('ServiceWorker registration failed: ', err);
               });
           });
       }

       // Console message
       console.log(`
       %c Chat Application with Collab Mode Loaded! 
       %cVersion 2.0 - Featuring:
         Gesture Controls with MediaPipe
         Voice Input/Output with Azure TTS
         Real-time Show Mode
         Hands-free Collab Mode
         Dark/Light Theme
         Mobile Responsive
         Local Storage
         Import/Export
       
       Keyboard Shortcuts:
        Cmd/Ctrl + K: Focus input
        Cmd/Ctrl + N: New chat
        Cmd/Ctrl + L: Toggle Collab Mode
        Cmd/Ctrl + Shift + C: Clear chat
        Escape: Exit modes/close modals
       
       Gesture Controls (in Collab Mode):
         Open Palm: To Speak to the assistant through the microphone
         Peace Sign: Toggle on/off microphone auto speak voice mode
         Thumbs Up: Send message
         Thumbs Down: End Collab Mode
         Rock Sign: Ding windows with an alert to find the window quickly that is in the background
       `, 
       'color: #742774; font-size: 16px; font-weight: bold;',
       'color: #666; font-size: 12px;'
       );
   </script>
</body>
</html>