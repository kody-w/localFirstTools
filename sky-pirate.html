<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sky Pirate - Airship Combat</title>
    <meta name="description" content="Command a steampunk airship, battle enemies, and rule the skies.">
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Courier New', Courier, monospace; background-color: #87CEEB; user-select: none; }
        #game-ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        /* HUD Elements */
        .hud-panel { position: absolute; padding: 15px; background: rgba(40, 30, 20, 0.8); border: 2px solid #cda434; border-radius: 4px; color: #e0d0b0; pointer-events: auto; box-shadow: 0 0 10px rgba(0,0,0,0.5); }
        
        #ship-status { bottom: 20px; left: 20px; width: 200px; }
        #controls-help { top: 20px; right: 20px; text-align: right; }
        #crosshair { position: absolute; top: 50%; left: 50%; width: 40px; height: 40px; border: 2px solid rgba(255, 255, 255, 0.5); border-radius: 50%; transform: translate(-50%, -50%); box-sizing: border-box; pointer-events: none; }
        #crosshair::after { content: ''; position: absolute; top: 50%; left: 50%; width: 4px; height: 4px; background: white; transform: translate(-50%, -50%); border-radius: 50%; }
        
        .bar-container { width: 100%; height: 10px; background: #222; margin-top: 5px; border: 1px solid #555; }
        .bar { height: 100%; width: 100%; transition: width 0.2s; }
        .hp-bar { background: #d00; }
        .speed-bar { background: #da0; }
        
        #message-area { position: absolute; top: 20%; left: 50%; transform: translateX(-50%); text-align: center; font-size: 32px; font-weight: bold; color: #fff; text-shadow: 2px 2px 0 #000; opacity: 0; transition: opacity 0.5s; }
        
        #start-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100; pointer-events: auto; color: #e0d0b0; }
        h1 { font-size: 64px; margin-bottom: 10px; color: #cda434; text-shadow: 0 0 20px #8b4513; letter-spacing: 4px; font-family: 'Times New Roman', serif; }
        .btn { padding: 15px 40px; font-size: 24px; background: #8b4513; color: #e0d0b0; border: 2px solid #cda434; cursor: pointer; margin-top: 20px; font-family: 'Courier New', monospace; transition: all 0.2s; }
        .btn:hover { background: #a0522d; transform: scale(1.05); }
        
        #game-over-screen { display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(50, 0, 0, 0.9); flex-direction: column; align-items: center; justify-content: center; z-index: 100; pointer-events: auto; color: white; }

        .compass { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); width: 300px; height: 30px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); overflow: hidden; }
        .compass-strip { position: absolute; top: 0; left: 0; width: 1000px; height: 100%; display: flex; align-items: center; font-weight: bold; color: white; transition: transform 0.1s; }
        .compass-mark { width: 50px; text-align: center; display: inline-block; }
    </style>
</head>
<body>
    <div id="game-ui">
        <div class="compass">
            <div id="compass-strip" class="compass-strip">
                <!-- Generated by JS -->
            </div>
            <div style="position: absolute; top: 0; left: 50%; transform: translateX(-50%); color: #ffd700;">â–¼</div>
        </div>

        <div id="crosshair"></div>
        
        <div id="ship-status" class="hud-panel">
            <div>HULL INTEGRITY</div>
            <div class="bar-container"><div id="hp-bar" class="bar hp-bar"></div></div>
            <div style="margin-top: 10px;">ENGINE POWER</div>
            <div class="bar-container"><div id="speed-bar" class="bar speed-bar" style="width: 0%"></div></div>
            <div style="margin-top: 10px;">ALTITUDE: <span id="alt-val">100</span>m</div>
        </div>
        
        <div id="controls-help" class="hud-panel">
            <div>W / S - Engine Power</div>
            <div>A / D - Rudder (Turn)</div>
            <div>SPACE / SHIFT - Altitude</div>
            <div>MOUSE - Aim Cannons</div>
            <div>L-CLICK - Fire Cannons</div>
            <div>R-CLICK - Grappling Hook</div>
        </div>
        
        <div id="message-area">ENEMY SIGHTED!</div>
    </div>

    <div id="start-screen">
        <h1>SKY PIRATE</h1>
        <p style="font-size: 20px; max-width: 600px; text-align: center; line-height: 1.5;">
            Captain! The Royal Navy approaches.<br>
            Man the helm, fire the cannons, and rule the skies.
        </p>
        <button class="btn" id="start-btn">BOARD SHIP</button>
    </div>

    <div id="game-over-screen">
        <h1 style="color: #ff3333;">SHIP DESTROYED</h1>
        <p style="font-size: 24px; margin-bottom: 20px;">You sank <span id="score-val">0</span> enemy ships</p>
        <button class="btn" onclick="location.reload()">RESPAWN</button>
    </div>

    <!-- Three.js & Cannon.js (Physics) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    
    <script>
        // --- Game Constants ---
        const CONFIG = {
            GRAVITY: -9.81,
            SHIP_SPEED: 20,
            TURN_SPEED: 0.5,
            LIFT_FORCE: 15,
            CANNON_FORCE: 100,
            CANNON_COOLDOWN: 1.5,
            WORLD_SIZE: 2000
        };

        // --- Globals ---
        let scene, camera, renderer, world, clock;
        let playerShip, playerBody;
        let waterMesh;
        let enemies = [];
        let cannonballs = [];
        let clouds = [];
        let ropes = [];
        
        const state = {
            hp: 100,
            throttle: 0, // 0 to 1
            score: 0,
            isPlaying: false,
            lastFireTime: 0,
            mouse: new THREE.Vector2(),
            cameraAngle: { x: 0, y: 0 }
        };

        const keys = { w: false, a: false, s: false, d: false, space: false, shift: false };

        // --- Initialization ---
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.FogExp2(0x87CEEB, 0.0015);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // Physics World
            world = new CANNON.World();
            world.gravity.set(0, CONFIG.GRAVITY, 0);
            world.broadphase = new CANNON.NaiveBroadphase();
            world.solver.iterations = 10;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 1.2);
            scene.add(ambientLight);

            const sunLight = new THREE.DirectionalLight(0xffffff, 1.0);
            sunLight.position.set(100, 200, 100);
            sunLight.castShadow = true;
            sunLight.shadow.camera.left = -100;
            sunLight.shadow.camera.right = 100;
            sunLight.shadow.camera.top = 100;
            sunLight.shadow.camera.bottom = -100;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            scene.add(sunLight);

            clock = new THREE.Clock();

            // Environment
            createOcean();
            createClouds();
            createIslands();

            // Player
            createPlayerShip();

            // UI
            setupCompass();

            // Events
            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('keydown', onKeyDown, false);
            document.addEventListener('keyup', onKeyUp, false);
            document.addEventListener('mousedown', onMouseDown, false);
            document.addEventListener('mousemove', onMouseMove, false);
            document.getElementById('start-btn').addEventListener('click', startGame);

            animate();
        }

        // --- Object Creation ---

        function createPlayerShip() {
            // Visuals (Steampunk Airship)
            const shipGroup = new THREE.Group();

            // Hull
            const hullGeo = new THREE.CylinderGeometry(1, 2, 10, 8);
            hullGeo.rotateX(Math.PI / 2);
            const hullMat = new THREE.MeshStandardMaterial({ color: 0x8b4513 }); // Wood
            const hull = new THREE.Mesh(hullGeo, hullMat);
            hull.castShadow = true;
            shipGroup.add(hull);

            // Balloon
            const balloonGeo = new THREE.SphereGeometry(4, 16, 16);
            balloonGeo.scale(1, 0.6, 1.5);
            const balloonMat = new THREE.MeshStandardMaterial({ color: 0xe0d0b0, roughness: 0.9 }); // Canvas
            const balloon = new THREE.Mesh(balloonGeo, balloonMat);
            balloon.position.y = 5;
            balloon.castShadow = true;
            shipGroup.add(balloon);

            // Ropes (Visual)
            const ropeMat = new THREE.LineBasicMaterial({ color: 0x333333 });
            const ropeGeo = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 1, 3), new THREE.Vector3(0, 5, 3),
                new THREE.Vector3(0, 1, -3), new THREE.Vector3(0, 5, -3),
                new THREE.Vector3(1.5, 1, 0), new THREE.Vector3(3, 5, 0),
                new THREE.Vector3(-1.5, 1, 0), new THREE.Vector3(-3, 5, 0)
            ]);
            const ropes = new THREE.LineSegments(ropeGeo, ropeMat);
            shipGroup.add(ropes);

            // Propeller
            const propGeo = new THREE.BoxGeometry(4, 0.2, 0.5);
            const propMat = new THREE.MeshStandardMaterial({ color: 0xb8860b }); // Brass
            const prop = new THREE.Mesh(propGeo, propMat);
            prop.position.set(0, 0, -5.2);
            shipGroup.add(prop);
            shipGroup.userData.propeller = prop;

            // Cannons
            const cannonGeo = new THREE.CylinderGeometry(0.3, 0.3, 2);
            cannonGeo.rotateZ(Math.PI / 2);
            const cannonMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
            
            const leftCannon = new THREE.Mesh(cannonGeo, cannonMat);
            leftCannon.position.set(-1.5, 0.5, 2);
            shipGroup.add(leftCannon);
            
            const rightCannon = new THREE.Mesh(cannonGeo, cannonMat);
            rightCannon.position.set(1.5, 0.5, 2);
            shipGroup.add(rightCannon);

            scene.add(shipGroup);

            // Physics Body
            const shape = new CANNON.Box(new CANNON.Vec3(2, 2, 5));
            playerBody = new CANNON.Body({
                mass: 1000, // Heavy ship
                position: new CANNON.Vec3(0, 50, 0),
                shape: shape,
                linearDamping: 0.5,
                angularDamping: 0.8
            });
            world.addBody(playerBody);

            playerShip = {
                mesh: shipGroup,
                body: playerBody,
                propeller: prop
            };
        }

        function createEnemyShip(x, z) {
            // Simplified enemy ship (Red balloon)
            const shipGroup = new THREE.Group();
            
            const hullGeo = new THREE.CylinderGeometry(1, 2, 8, 8);
            hullGeo.rotateX(Math.PI / 2);
            const hullMat = new THREE.MeshStandardMaterial({ color: 0x552222 });
            const hull = new THREE.Mesh(hullGeo, hullMat);
            shipGroup.add(hull);

            const balloonGeo = new THREE.SphereGeometry(3.5, 16, 16);
            balloonGeo.scale(1, 0.6, 1.5);
            const balloonMat = new THREE.MeshStandardMaterial({ color: 0x880000 });
            const balloon = new THREE.Mesh(balloonGeo, balloonMat);
            balloon.position.y = 4;
            shipGroup.add(balloon);

            scene.add(shipGroup);

            const shape = new CANNON.Box(new CANNON.Vec3(2, 2, 4));
            const body = new CANNON.Body({
                mass: 800,
                position: new CANNON.Vec3(x, 50 + Math.random() * 20, z),
                shape: shape,
                linearDamping: 0.5,
                angularDamping: 0.5
            });
            world.addBody(body);

            enemies.push({
                mesh: shipGroup,
                body: body,
                hp: 50,
                lastFire: 0
            });
        }

        function createOcean() {
            const geometry = new THREE.PlaneGeometry(CONFIG.WORLD_SIZE * 2, CONFIG.WORLD_SIZE * 2, 50, 50);
            geometry.rotateX(-Math.PI / 2);
            
            // Simple wave shader material could go here, using standard for now
            const material = new THREE.MeshStandardMaterial({ 
                color: 0x004488, 
                transparent: true, 
                opacity: 0.8,
                roughness: 0.1
            });
            
            waterMesh = new THREE.Mesh(geometry, material);
            waterMesh.position.y = -50; // Sea level below airships
            scene.add(waterMesh);
        }

        function createClouds() {
            const geo = new THREE.DodecahedronGeometry(10, 0);
            const mat = new THREE.MeshStandardMaterial({ 
                color: 0xffffff, 
                transparent: true, 
                opacity: 0.6,
                flatShading: true
            });

            for (let i = 0; i < 100; i++) {
                const cloud = new THREE.Mesh(geo, mat);
                const x = (Math.random() - 0.5) * CONFIG.WORLD_SIZE;
                const y = 20 + Math.random() * 100;
                const z = (Math.random() - 0.5) * CONFIG.WORLD_SIZE;
                
                cloud.position.set(x, y, z);
                cloud.scale.setScalar(2 + Math.random() * 3);
                cloud.rotation.set(Math.random(), Math.random(), Math.random());
                
                scene.add(cloud);
                clouds.push(cloud);
            }
        }

        function createIslands() {
            // Floating islands
            const geo = new THREE.ConeGeometry(20, 40, 6);
            geo.rotateX(Math.PI); // Pointy bit down
            const mat = new THREE.MeshStandardMaterial({ color: 0x556655 });
            
            for (let i = 0; i < 10; i++) {
                const island = new THREE.Mesh(geo, mat);
                const x = (Math.random() - 0.5) * CONFIG.WORLD_SIZE * 0.8;
                const z = (Math.random() - 0.5) * CONFIG.WORLD_SIZE * 0.8;
                island.position.set(x, 0, z);
                
                // Add some trees/rocks on top
                const topGeo = new THREE.CylinderGeometry(20, 20, 2, 6);
                const top = new THREE.Mesh(topGeo, new THREE.MeshStandardMaterial({ color: 0x228822 }));
                top.position.y = 20;
                island.add(top);
                
                scene.add(island);
                
                // Physics for islands (Static)
                const shape = new CANNON.Cylinder(20, 0, 40, 6);
                // Cannon cylinder orientation is different, need to rotate
                const q = new CANNON.Quaternion();
                q.setFromAxisAngle(new CANNON.Vec3(1,0,0), -Math.PI/2);
                
                const body = new CANNON.Body({
                    mass: 0, // Static
                    position: new CANNON.Vec3(x, 0, z),
                    shape: shape,
                    quaternion: q
                });
                world.addBody(body);
            }
        }

        function fireCannon(sourceBody, direction, isPlayer) {
            const ballGeo = new THREE.SphereGeometry(0.5);
            const ballMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
            const mesh = new THREE.Mesh(ballGeo, ballMat);
            scene.add(mesh);

            const shape = new CANNON.Sphere(0.5);
            const body = new CANNON.Body({
                mass: 5,
                position: sourceBody.position.clone().vadd(direction.scale(5)), // Start slightly outside
                shape: shape
            });
            
            // Add velocity from ship + shot force
            const shootVel = direction.scale(100);
            body.velocity.copy(sourceBody.velocity.vadd(shootVel));
            
            world.addBody(body);

            cannonballs.push({
                mesh: mesh,
                body: body,
                life: 3, // Seconds
                isPlayer: isPlayer
            });

            // Recoil
            const recoilForce = direction.scale(-500);
            sourceBody.applyForce(recoilForce, sourceBody.position);
        }

        // --- Input ---
        function onKeyDown(e) {
            switch(e.key.toLowerCase()) {
                case 'w': keys.w = true; break;
                case 'a': keys.a = true; break;
                case 's': keys.s = true; break;
                case 'd': keys.d = true; break;
                case ' ': keys.space = true; break;
                case 'shift': keys.shift = true; break;
            }
        }

        function onKeyUp(e) {
            switch(e.key.toLowerCase()) {
                case 'w': keys.w = false; break;
                case 'a': keys.a = false; break;
                case 's': keys.s = false; break;
                case 'd': keys.d = false; break;
                case ' ': keys.space = false; break;
                case 'shift': keys.shift = false; break;
            }
        }

        function onMouseDown(e) {
            if (!state.isPlaying) return;
            if (document.pointerLockElement !== document.body) {
                document.body.requestPointerLock();
                return;
            }

            if (e.button === 0) { // Left Click - Fire
                const now = clock.getElapsedTime();
                if (now - state.lastFireTime > CONFIG.CANNON_COOLDOWN) {
                    // Fire from camera direction
                    const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                    const dir = new CANNON.Vec3(forward.x, forward.y, forward.z);
                    fireCannon(playerBody, dir, true);
                    state.lastFireTime = now;
                    
                    // Camera shake
                    state.cameraAngle.x += 0.05;
                }
            }
        }

        function onMouseMove(e) {
            if (document.pointerLockElement === document.body) {
                state.cameraAngle.y -= e.movementX * 0.002;
                state.cameraAngle.x -= e.movementY * 0.002;
                // Clamp pitch
                state.cameraAngle.x = Math.max(-Math.PI/3, Math.min(Math.PI/3, state.cameraAngle.x));
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function setupCompass() {
            const strip = document.getElementById('compass-strip');
            const dirs = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
            let html = '';
            // Repeat 3 times for seamless looping
            for (let k=0; k<3; k++) {
                for (let i=0; i<dirs.length; i++) {
                    html += `<div class="compass-mark">${dirs[i]}</div>`;
                    // Add ticks
                    for(let j=0; j<3; j++) html += `<div class="compass-mark" style="font-weight:normal; font-size:10px">|</div>`;
                }
            }
            strip.innerHTML = html;
        }

        function updateCompass() {
            // Get ship yaw
            const q = playerBody.quaternion;
            const euler = new CANNON.Vec3();
            q.toEuler(euler); // Yaw is y
            
            // Map -PI to PI -> 0 to 100%
            // Actually we want camera yaw
            let yaw = state.cameraAngle.y % (Math.PI * 2);
            if (yaw < 0) yaw += Math.PI * 2;
            
            const pct = yaw / (Math.PI * 2);
            const strip = document.getElementById('compass-strip');
            // Offset to center the middle set of directions
            const offset = -1000 - (pct * 1000); 
            strip.style.transform = `translateX(${offset}px)`;
        }

        function showMessage(msg) {
            const el = document.getElementById('message-area');
            el.innerText = msg;
            el.style.opacity = 1;
            setTimeout(() => el.style.opacity = 0, 2000);
        }

        function startGame() {
            document.getElementById('start-screen').style.display = 'none';
            document.body.requestPointerLock();
            state.isPlaying = true;
            state.hp = 100;
            state.score = 0;
            
            // Spawn initial enemies
            for(let i=0; i<3; i++) {
                createEnemyShip((Math.random()-0.5)*500, (Math.random()-0.5)*500);
            }
        }

        // --- Main Loop ---
        function animate() {
            requestAnimationFrame(animate);
            
            const dt = Math.min(clock.getDelta(), 0.1);

            if (state.isPlaying) {
                // --- Player Physics Control ---
                
                // Throttle
                if (keys.w) state.throttle = Math.min(state.throttle + dt * 0.5, 1);
                if (keys.s) state.throttle = Math.max(state.throttle - dt * 0.5, -0.5);
                
                // Apply Engine Force (Forward relative to ship)
                const forward = new CANNON.Vec3(0, 0, -1);
                playerBody.quaternion.vmult(forward, forward);
                const force = forward.scale(state.throttle * CONFIG.SHIP_SPEED * 1000);
                playerBody.applyForce(force, playerBody.position);
                
                // Turning (Torque)
                if (keys.a) playerBody.angularVelocity.y += CONFIG.TURN_SPEED * dt;
                if (keys.d) playerBody.angularVelocity.y -= CONFIG.TURN_SPEED * dt;
                
                // Altitude Control (Buoyancy)
                // Base anti-gravity to hover
                let lift = -CONFIG.GRAVITY * playerBody.mass; 
                
                // Manual altitude adjustment
                if (keys.space) lift += CONFIG.LIFT_FORCE * 500;
                if (keys.shift) lift -= CONFIG.LIFT_FORCE * 500;
                
                // Height stabilization (spring-like)
                // const targetHeight = 50;
                // const hDiff = targetHeight - playerBody.position.y;
                // lift += hDiff * 100;
                
                playerBody.applyForce(new CANNON.Vec3(0, lift, 0), playerBody.position);
                
                // Stabilization (keep upright)
                // Simple angular damping is handled by cannon, but we can force it upright slightly
                // This simulates the heavy keel
                const up = new CANNON.Vec3(0, 1, 0);
                const shipUp = new CANNON.Vec3(0, 1, 0);
                playerBody.quaternion.vmult(shipUp, shipUp);
                
                // Cross product to find axis to rotate back to up
                const axis = shipUp.cross(up);
                // Apply torque to right ship
                playerBody.torque.vadd(axis.scale(5000), playerBody.torque);

                // --- Enemy Logic ---
                enemies.forEach((enemy, i) => {
                    if (enemy.hp <= 0) return;
                    
                    // Move towards player
                    const toPlayer = playerBody.position.vsub(enemy.body.position);
                    toPlayer.normalize();
                    
                    // Turn towards player
                    // Simplified: just apply force towards player
                    const moveForce = toPlayer.scale(5000); // Slower than player
                    enemy.body.applyForce(moveForce, enemy.body.position);
                    
                    // Hover
                    const eLift = new CANNON.Vec3(0, -CONFIG.GRAVITY * enemy.body.mass, 0);
                    enemy.body.applyForce(eLift, enemy.body.position);
                    
                    // Fire at player
                    const now = clock.getElapsedTime();
                    if (now - enemy.lastFire > 3 && enemy.body.position.distanceTo(playerBody.position) < 300) {
                        fireCannon(enemy.body, toPlayer, false);
                        enemy.lastFire = now;
                    }
                    
                    // Sync Mesh
                    enemy.mesh.position.copy(enemy.body.position);
                    enemy.mesh.quaternion.copy(enemy.body.quaternion);
                });

                // --- Projectiles ---
                for (let i = cannonballs.length - 1; i >= 0; i--) {
                    const ball = cannonballs[i];
                    ball.life -= dt;
                    
                    // Sync mesh
                    ball.mesh.position.copy(ball.body.position);
                    
                    // Collision checks (Manual for simplicity)
                    if (ball.isPlayer) {
                        enemies.forEach(enemy => {
                            if (enemy.hp > 0 && ball.body.position.distanceTo(enemy.body.position) < 5) {
                                enemy.hp -= 20;
                                ball.life = 0; // Destroy ball
                                // Visual hit effect?
                                if (enemy.hp <= 0) {
                                    // Destroy enemy
                                    scene.remove(enemy.mesh);
                                    world.remove(enemy.body);
                                    state.score++;
                                    showMessage("ENEMY DESTROYED!");
                                    // Spawn new one
                                    setTimeout(() => createEnemyShip((Math.random()-0.5)*500, (Math.random()-0.5)*500), 5000);
                                }
                            }
                        });
                    } else {
                        if (ball.body.position.distanceTo(playerBody.position) < 5) {
                            state.hp -= 10;
                            ball.life = 0;
                            // Camera shake
                            state.cameraAngle.x += 0.1;
                            if (state.hp <= 0) {
                                state.isPlaying = false;
                                document.getElementById('score-val').innerText = state.score;
                                document.getElementById('game-over-screen').style.display = 'flex';
                                document.exitPointerLock();
                            }
                        }
                    }

                    if (ball.life <= 0) {
                        scene.remove(ball.mesh);
                        world.remove(ball.body);
                        cannonballs.splice(i, 1);
                    }
                }

                // --- Step Physics ---
                world.step(1 / 60, dt, 3);

                // --- Sync Player Mesh ---
                playerShip.mesh.position.copy(playerBody.position);
                playerShip.mesh.quaternion.copy(playerBody.quaternion);
                
                // Spin propeller
                playerShip.propeller.rotation.z += state.throttle * 10 * dt;

                // --- Camera Follow ---
                // Third person camera
                const camDist = 20;
                const camHeight = 10;
                
                // Calculate camera position based on mouse rotation (orbit)
                const cx = Math.sin(state.cameraAngle.y) * camDist * Math.cos(state.cameraAngle.x);
                const cz = Math.cos(state.cameraAngle.y) * camDist * Math.cos(state.cameraAngle.x);
                const cy = Math.sin(state.cameraAngle.x) * camDist;
                
                const camPos = playerBody.position.clone().vadd(new CANNON.Vec3(cx, camHeight + cy, cz));
                
                camera.position.set(camPos.x, camPos.y, camPos.z);
                camera.lookAt(playerShip.mesh.position.x, playerShip.mesh.position.y + 5, playerShip.mesh.position.z);

                // --- Update HUD ---
                document.getElementById('hp-bar').style.width = state.hp + '%';
                document.getElementById('speed-bar').style.width = Math.abs(state.throttle * 100) + '%';
                document.getElementById('alt-val').innerText = Math.round(playerBody.position.y);
                updateCompass();
            }

            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>