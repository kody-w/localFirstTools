<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sky Pirate: The Ghost Phase</title>
    <meta name="description" content="A puzzle-platformer where you shift between physical and ghost forms. Master the duality of existence to steal the treasure.">
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #1a1a2e;
            color: #e94560;
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            user-select: none;
        }

        #game-container {
            position: relative;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.5);
            border: 4px solid #16213e;
            background-color: #0f3460;
        }

        canvas {
            display: block;
            background-color: #0f3460;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000;
        }

        .energy-bar-container {
            width: 200px;
            height: 20px;
            background-color: #16213e;
            border: 2px solid #e94560;
            border-radius: 10px;
            overflow: hidden;
        }

        #energy-bar {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #4cc9f0, #4361ee);
            transition: width 0.1s;
        }

        #tutorial-text {
            position: absolute;
            bottom: 100px;
            width: 100%;
            text-align: center;
            font-size: 18px;
            color: #fff;
            text-shadow: 1px 1px 2px #000;
            opacity: 0.8;
        }

        #start-screen, #game-over-screen, #level-complete-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(26, 26, 46, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            z-index: 10;
        }

        h1 {
            font-size: 48px;
            margin-bottom: 10px;
            color: #4cc9f0;
            text-shadow: 0 0 10px #4cc9f0;
        }

        h2 {
            font-size: 32px;
            color: #e94560;
        }

        p {
            font-size: 18px;
            color: #fff;
            max-width: 600px;
            text-align: center;
            line-height: 1.6;
            margin-bottom: 30px;
        }

        button {
            padding: 15px 40px;
            font-size: 24px;
            font-family: inherit;
            background: #e94560;
            color: #fff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: transform 0.1s, background 0.1s;
            box-shadow: 0 5px 0 #a3162e;
        }

        button:hover {
            background: #ff6b81;
            transform: translateY(-2px);
        }

        button:active {
            transform: translateY(2px);
            box-shadow: 0 1px 0 #a3162e;
        }

        .hidden {
            display: none !important;
        }

        .key {
            display: inline-block;
            background: #333;
            color: #fff;
            padding: 2px 8px;
            border-radius: 4px;
            border-bottom: 2px solid #111;
            font-size: 0.9em;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    
    <div id="ui-layer">
        <div class="hud-top">
            <div id="score-display">GEMS: 0</div>
            <div class="energy-bar-container">
                <div id="energy-bar"></div>
            </div>
        </div>
        <div id="tutorial-text">Press <span class="key">SPACE</span> to Jump</div>
    </div>

    <div id="start-screen">
        <h1>SKY PIRATE</h1>
        <h2>THE GHOST PHASE</h2>
        <p>
            You are Captain "Phase" Walker, the only pirate who can turn into a ghost.<br><br>
            <b>PHYSICAL FORM:</b> You are solid. You can jump, collect gems, and land on platforms. But walls stop you.<br><br>
            <b>GHOST FORM (Hold <span class="key">SHIFT</span> or <span class="key">Z</span>):</b> You become a spirit. You can fly through walls and enemies. But you cannot touch treasure, and you will fall through solid ground!<br><br>
            Master the switch to survive.
        </p>
        <button id="start-btn">START HEIST</button>
    </div>

    <div id="game-over-screen" class="hidden">
        <h1 style="color: #e94560">CAUGHT!</h1>
        <p>You materialized inside a wall or fell into the abyss.</p>
        <button id="retry-btn">TRY AGAIN</button>
    </div>

    <div id="level-complete-screen" class="hidden">
        <h1 style="color: #4cc9f0">HEIST COMPLETE!</h1>
        <p id="level-stats">Gems Collected: 0/0</p>
        <button id="next-level-btn">NEXT LEVEL</button>
    </div>
</div>

<script>
/**
 * SKY PIRATE: THE GHOST PHASE
 * A game about Wave-Particle Duality without saying "Quantum".
 * 
 * Core Concept:
 * - Particle (Physical): Interaction, Position, Collision.
 * - Wave (Ghost): Propagation, Tunneling, Superposition.
 */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// Game State
const STATE = {
    MENU: 0,
    PLAYING: 1,
    GAME_OVER: 2,
    LEVEL_COMPLETE: 3
};

let currentState = STATE.MENU;
let currentLevelIdx = 0;
let score = 0;
let maxScore = 0;

// Input
const keys = {
    ArrowUp: false,
    ArrowDown: false,
    ArrowLeft: false,
    ArrowRight: false,
    Space: false,
    Shift: false,
    z: false,
    w: false,
    a: false,
    s: false,
    d: false
};

// Game Objects
const player = {
    x: 100,
    y: 300,
    width: 32,
    height: 48,
    vx: 0,
    vy: 0,
    speed: 5,
    jumpForce: 12,
    gravity: 0.6,
    isGrounded: false,
    isGhost: false,
    ghostEnergy: 100,
    maxGhostEnergy: 100,
    ghostDrain: 0.5,
    ghostRecharge: 1.0,
    facingRight: true,
    animTimer: 0
};

let platforms = [];
let walls = [];
let hazards = [];
let gems = [];
let goal = null;
let particles = [];

// Levels
const LEVELS = [
    // Level 1: The Basics - Jumping and Phasing
    {
        tutorial: "Hold <span class='key'>SHIFT</span> to turn GHOST and pass through the wall.",
        setup: () => {
            player.x = 50; player.y = 400;
            // Floor
            platforms.push({x: 0, y: 500, w: 800, h: 100, type: 'solid'});
            // A wall you must phase through
            walls.push({x: 300, y: 300, w: 50, h: 200, type: 'solid'});
            // Gems
            gems.push({x: 400, y: 450, collected: false});
            gems.push({x: 500, y: 450, collected: false});
            // Goal
            goal = {x: 700, y: 420, w: 40, h: 80};
        }
    },
    // Level 2: The Chasm - Ghost Flight
    {
        tutorial: "As a GHOST, gravity doesn't affect you. Fly across the gap!",
        setup: () => {
            player.x = 50; player.y = 400;
            // Starting platform
            platforms.push({x: 0, y: 500, w: 200, h: 100, type: 'solid'});
            // Landing platform
            platforms.push({x: 600, y: 500, w: 200, h: 100, type: 'solid'});
            // A high wall blocking the jump
            walls.push({x: 190, y: 200, w: 20, h: 300, type: 'solid'});
            // Gems in the air
            gems.push({x: 300, y: 300, collected: false});
            gems.push({x: 400, y: 250, collected: false});
            gems.push({x: 500, y: 300, collected: false});
            // Goal
            goal = {x: 700, y: 420, w: 40, h: 80};
        }
    },
    // Level 3: The Trap - Materializing
    {
        tutorial: "You can't collect treasure as a GHOST. Materialize to grab it!",
        setup: () => {
            player.x = 50; player.y = 400;
            // Floor
            platforms.push({x: 0, y: 500, w: 800, h: 100, type: 'solid'});
            // Cage around gem
            walls.push({x: 300, y: 400, w: 20, h: 100, type: 'solid'}); // Left
            walls.push({x: 400, y: 400, w: 20, h: 100, type: 'solid'}); // Right
            platforms.push({x: 300, y: 400, w: 120, h: 20, type: 'solid'}); // Top
            
            // Gem inside
            gems.push({x: 360, y: 450, collected: false});
            
            // Another wall
            walls.push({x: 550, y: 200, w: 50, h: 300, type: 'solid'});
            
            // Goal
            goal = {x: 700, y: 420, w: 40, h: 80};
        }
    },
    // Level 4: Ghost Floors
    {
        tutorial: "Blue platforms are SPIRIT MATTER. Only a GHOST can touch them.",
        setup: () => {
            player.x = 50; player.y = 400;
            // Start
            platforms.push({x: 0, y: 500, w: 150, h: 100, type: 'solid'});
            
            // Tunnel floor
            platforms.push({x: 150, y: 500, w: 500, h: 50, type: 'solid'});
            // Tunnel ceiling
            platforms.push({x: 150, y: 350, w: 500, h: 50, type: 'solid'});
            
            // Spikes on floor (Hazards)
            hazards.push({x: 200, y: 470, w: 400, h: 30});
            
            // Gems in tunnel
            gems.push({x: 300, y: 400, collected: false});
            gems.push({x: 450, y: 400, collected: false});
            
            // End
            platforms.push({x: 650, y: 500, w: 150, h: 100, type: 'solid'});
            goal = {x: 700, y: 420, w: 40, h: 80};
        }
    },
    // Level 5: The Vertical Climb
    {
        tutorial: "Combine jumps and phasing to climb.",
        setup: () => {
            player.x = 50; player.y = 500;
            // Floor
            platforms.push({x: 0, y: 550, w: 800, h: 50, type: 'solid'});
            
            // Floors you must phase through to go up
            platforms.push({x: 0, y: 400, w: 600, h: 20, type: 'solid'});
            platforms.push({x: 200, y: 250, w: 600, h: 20, type: 'solid'});
            platforms.push({x: 0, y: 100, w: 600, h: 20, type: 'solid'});
            
            gems.push({x: 100, y: 350, collected: false});
            gems.push({x: 700, y: 200, collected: false});
            gems.push({x: 100, y: 50, collected: false});
            
            goal = {x: 700, y: 20, w: 40, h: 80};
        }
    }
];

// Initialization
function init() {
    // Event Listeners
    window.addEventListener('keydown', e => {
        if(keys.hasOwnProperty(e.key) || keys.hasOwnProperty(e.code)) {
            keys[e.key] = true;
            if(e.code === 'Space') keys.Space = true;
        }
    });
    
    window.addEventListener('keyup', e => {
        if(keys.hasOwnProperty(e.key) || keys.hasOwnProperty(e.code)) {
            keys[e.key] = false;
            if(e.code === 'Space') keys.Space = false;
        }
    });

    document.getElementById('start-btn').addEventListener('click', () => loadLevel(0));
    document.getElementById('retry-btn').addEventListener('click', () => loadLevel(currentLevelIdx));
    document.getElementById('next-level-btn').addEventListener('click', () => {
        if (currentLevelIdx < LEVELS.length - 1) {
            loadLevel(currentLevelIdx + 1);
        } else {
            // Loop or end
            currentLevelIdx = 0;
            loadLevel(0);
        }
    });

    gameLoop();
}

function loadLevel(idx) {
    currentLevelIdx = idx;
    
    // Reset objects
    platforms = [];
    walls = [];
    hazards = [];
    gems = [];
    particles = [];
    
    // Reset player
    player.vx = 0;
    player.vy = 0;
    player.isGhost = false;
    player.ghostEnergy = player.maxGhostEnergy;
    
    // Load level data
    LEVELS[idx].setup();
    
    // Update UI
    document.getElementById('tutorial-text').innerHTML = LEVELS[idx].tutorial;
    document.getElementById('start-screen').classList.add('hidden');
    document.getElementById('game-over-screen').classList.add('hidden');
    document.getElementById('level-complete-screen').classList.add('hidden');
    
    score = 0;
    maxScore = gems.length;
    
    currentState = STATE.PLAYING;
}

function update() {
    if (currentState !== STATE.PLAYING) return;

    // Input Handling
    const left = keys.ArrowLeft || keys.a;
    const right = keys.ArrowRight || keys.d;
    const up = keys.ArrowUp || keys.w;
    const down = keys.ArrowDown || keys.s;
    const jump = keys.Space || keys.ArrowUp || keys.w;
    const phase = keys.Shift || keys.z;

    // Phase Shifting
    if (phase && player.ghostEnergy > 0) {
        player.isGhost = true;
        player.ghostEnergy -= player.ghostDrain;
    } else {
        player.isGhost = false;
        player.ghostEnergy = Math.min(player.ghostEnergy + player.ghostRecharge, player.maxGhostEnergy);
    }

    // Movement
    if (left) {
        player.vx = -player.speed;
        player.facingRight = false;
    } else if (right) {
        player.vx = player.speed;
        player.facingRight = true;
    } else {
        player.vx *= 0.8; // Friction
    }

    // Physics
    if (player.isGhost) {
        // Ghost Flight
        if (up) player.vy = -player.speed * 0.8;
        else if (down) player.vy = player.speed * 0.8;
        else player.vy *= 0.9; // Air friction
        
        // Ghost Particles
        if (Math.random() < 0.3) {
            particles.push({
                x: player.x + player.width/2 + (Math.random()-0.5)*20,
                y: player.y + player.height/2 + (Math.random()-0.5)*20,
                vx: (Math.random()-0.5)*2,
                vy: (Math.random()-0.5)*2,
                life: 30,
                color: '#4cc9f0'
            });
        }
    } else {
        // Normal Gravity
        player.vy += player.gravity;
        
        // Jump
        if (jump && player.isGrounded) {
            player.vy = -player.jumpForce;
            player.isGrounded = false;
            
            // Jump particles
            for(let i=0; i<5; i++) {
                particles.push({
                    x: player.x + player.width/2,
                    y: player.y + player.height,
                    vx: (Math.random()-0.5)*5,
                    vy: (Math.random())*2,
                    life: 20,
                    color: '#fff'
                });
            }
        }
    }

    // Apply Velocity
    player.x += player.vx;
    player.y += player.vy;

    // Collisions
    player.isGrounded = false;
    let inWall = false;

    // Platform Collisions
    for (let p of platforms) {
        if (checkRectCollide(player, p)) {
            if (player.isGhost) {
                // Ghosts pass through, but maybe we visualize it?
            } else {
                // Solid collision resolution
                resolveCollision(player, p);
            }
        }
    }

    // Wall Collisions
    for (let w of walls) {
        if (checkRectCollide(player, w)) {
            if (player.isGhost) {
                inWall = true;
            } else {
                resolveCollision(player, w);
            }
        }
    }

    // Hazard Collisions
    if (!player.isGhost) {
        for (let h of hazards) {
            if (checkRectCollide(player, h)) {
                die();
            }
        }
    }

    // Gem Collection (Only when solid)
    if (!player.isGhost) {
        for (let g of gems) {
            if (!g.collected && checkRectCollide(player, {x: g.x, y: g.y, w: 20, h: 20})) {
                g.collected = true;
                score++;
                // Sparkle
                for(let i=0; i<10; i++) {
                    particles.push({
                        x: g.x + 10,
                        y: g.y + 10,
                        vx: (Math.random()-0.5)*10,
                        vy: (Math.random()-0.5)*10,
                        life: 40,
                        color: '#ffd700'
                    });
                }
            }
        }
    }

    // Goal Reached (Must be solid to enter door?)
    if (checkRectCollide(player, goal)) {
        if (!player.isGhost) {
            levelComplete();
        }
    }

    // Screen Bounds
    if (player.y > canvas.height) {
        die();
    }
    if (player.x < 0) player.x = 0;
    if (player.x > canvas.width - player.width) player.x = canvas.width - player.width;

    // Materializing inside a wall check
    // If we were ghost, and we just let go of shift, check if we are inside a wall
    // Actually, the physics engine handles "isGhost" check every frame.
    // If we turn solid while inside a wall, resolveCollision will push us out violently
    // OR we should die. Let's make it dangerous: Die if solidifying in wall.
    if (!player.isGhost && inWall) {
        // Check if we are actually overlapping a wall right now
        let stuck = false;
        for (let w of walls) {
            if (checkRectCollide(player, w)) stuck = true;
        }
        for (let p of platforms) {
            if (checkRectCollide(player, p)) stuck = true;
        }
        
        // If resolveCollision didn't fix it (it might have pushed us out), 
        // but for gameplay "puzzle" feel, sometimes you want to prevent solidifying.
        // For this simple version, let's just let the physics push you out.
        // It feels more forgiving.
    }

    // Update Particles
    for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life--;
        if (p.life <= 0) particles.splice(i, 1);
    }

    // Update UI
    document.getElementById('energy-bar').style.width = player.ghostEnergy + '%';
    document.getElementById('score-display').innerText = `GEMS: ${score}/${maxScore}`;
}

function checkRectCollide(r1, r2) {
    // r2 might be a platform with w/h or just x/y/w/h
    let r2w = r2.w || r2.width;
    let r2h = r2.h || r2.height;
    return (r1.x < r2.x + r2w &&
            r1.x + r1.width > r2.x &&
            r1.y < r2.y + r2h &&
            r1.y + r1.height > r2.y);
}

function resolveCollision(entity, obstacle) {
    // Calculate overlap
    let dx = (entity.x + entity.width/2) - (obstacle.x + obstacle.w/2);
    let dy = (entity.y + entity.height/2) - (obstacle.y + obstacle.h/2);
    let width = (entity.width + obstacle.w) / 2;
    let height = (entity.height + obstacle.h) / 2;
    let crossWidth = width * dy;
    let crossHeight = height * dx;

    if (Math.abs(dx) <= width && Math.abs(dy) <= height) {
        if (crossWidth > crossHeight) {
            if (crossWidth > -crossHeight) {
                // Bottom collision (Head hits bottom of block)
                entity.y = obstacle.y + obstacle.h;
                entity.vy = 0;
            } else {
                // Left collision
                entity.x = obstacle.x - entity.width;
                entity.vx = 0;
            }
        } else {
            if (crossWidth > -crossHeight) {
                // Right collision
                entity.x = obstacle.x + obstacle.w;
                entity.vx = 0;
            } else {
                // Top collision (Feet hit top of block)
                entity.y = obstacle.y - entity.height;
                entity.vy = 0;
                entity.isGrounded = true;
            }
        }
    }
}

function die() {
    currentState = STATE.GAME_OVER;
    document.getElementById('game-over-screen').classList.remove('hidden');
}

function levelComplete() {
    currentState = STATE.LEVEL_COMPLETE;
    document.getElementById('level-stats').innerText = `Gems Collected: ${score}/${maxScore}`;
    document.getElementById('level-complete-screen').classList.remove('hidden');
}

function draw() {
    // Clear
    ctx.fillStyle = '#1a1a2e';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Draw Background Grid (Holographic feel)
    ctx.strokeStyle = 'rgba(76, 201, 240, 0.1)';
    ctx.lineWidth = 1;
    const gridSize = 40;
    for(let x=0; x<canvas.width; x+=gridSize) {
        ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); ctx.stroke();
    }
    for(let y=0; y<canvas.height; y+=gridSize) {
        ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); ctx.stroke();
    }

    // Draw Platforms
    ctx.fillStyle = '#16213e';
    ctx.strokeStyle = '#e94560';
    ctx.lineWidth = 2;
    for (let p of platforms) {
        ctx.fillRect(p.x, p.y, p.w, p.h);
        ctx.strokeRect(p.x, p.y, p.w, p.h);
        
        // Detail
        ctx.fillStyle = 'rgba(233, 69, 96, 0.1)';
        ctx.fillRect(p.x, p.y, p.w, 10);
        ctx.fillStyle = '#16213e';
    }

    // Draw Walls
    ctx.fillStyle = '#53354a';
    ctx.strokeStyle = '#903749';
    for (let w of walls) {
        ctx.fillRect(w.x, w.y, w.w, w.h);
        ctx.strokeRect(w.x, w.y, w.w, w.h);
    }

    // Draw Hazards
    ctx.fillStyle = '#ff2e63';
    for (let h of hazards) {
        // Draw spikes
        ctx.beginPath();
        for(let i=0; i<h.w; i+=20) {
            ctx.moveTo(h.x + i, h.y + h.h);
            ctx.lineTo(h.x + i + 10, h.y);
            ctx.lineTo(h.x + i + 20, h.y + h.h);
        }
        ctx.fill();
    }

    // Draw Gems
    for (let g of gems) {
        if (!g.collected) {
            ctx.fillStyle = '#ffd700';
            ctx.beginPath();
            ctx.arc(g.x + 10, g.y + 10 + Math.sin(Date.now()/200)*3, 8, 0, Math.PI*2);
            ctx.fill();
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#ffd700';
            ctx.stroke();
            ctx.shadowBlur = 0;
        }
    }

    // Draw Goal
    if (goal) {
        ctx.fillStyle = 'rgba(76, 201, 240, 0.3)';
        ctx.fillRect(goal.x, goal.y, goal.w, goal.h);
        ctx.strokeStyle = '#4cc9f0';
        ctx.strokeRect(goal.x, goal.y, goal.w, goal.h);
        // Door knob
        ctx.fillStyle = '#fff';
        ctx.beginPath(); ctx.arc(goal.x + 30, goal.y + 40, 3, 0, Math.PI*2); ctx.fill();
    }

    // Draw Particles
    for (let p of particles) {
        ctx.fillStyle = p.color;
        ctx.globalAlpha = p.life / 30;
        ctx.fillRect(p.x, p.y, 4, 4);
        ctx.globalAlpha = 1.0;
    }

    // Draw Player
    ctx.save();
    if (player.isGhost) {
        ctx.globalAlpha = 0.6;
        ctx.fillStyle = '#4cc9f0'; // Ghost Blue
        ctx.shadowBlur = 20;
        ctx.shadowColor = '#4cc9f0';
    } else {
        ctx.globalAlpha = 1.0;
        ctx.fillStyle = '#e94560'; // Solid Red
    }

    // Player Body
    ctx.translate(player.x + player.width/2, player.y + player.height/2);
    if (!player.facingRight) ctx.scale(-1, 1);
    
    // Sprite drawing (Simple shapes)
    // Head
    ctx.fillRect(-10, -20, 20, 20);
    // Body
    ctx.fillRect(-12, 0, 24, 24);
    // Hat (Pirate)
    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.moveTo(-20, -15);
    ctx.lineTo(20, -15);
    ctx.lineTo(0, -30);
    ctx.fill();
    
    // Eyes
    ctx.fillStyle = '#fff';
    if (player.isGhost) {
        ctx.beginPath(); ctx.arc(5, -10, 3, 0, Math.PI*2); ctx.fill();
    } else {
        ctx.fillRect(2, -12, 4, 4);
        // Eye patch
        ctx.fillStyle = '#000';
        ctx.fillRect(6, -12, 4, 4);
    }

    ctx.restore();
}

function gameLoop() {
    update();
    draw();
    requestAnimationFrame(gameLoop);
}

init();

</script>
</body>
</html>