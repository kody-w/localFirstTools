<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Windows 95 Desktop Simulator - Interactive Edition</title>
    <meta name="description" content="Fully interactive Windows 95 desktop simulator with working programs, draggable windows, and authentic UI">
    <style>
        /* Windows 95 Color Palette - Authentic solid colors */
        :root {
            --desktop-teal: #008080;
            --button-face: #c0c0c0;
            --button-shadow: #808080;
            --button-dark-shadow: #000000;
            --button-highlight: #ffffff;
            --button-light: #dfdfdf;
            --active-title-bar: #000080;
            --inactive-title-bar: #808080;
            --window-background: #ffffff;
            --text-color: #000000;
            --menu-highlight: #000080;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'MS Sans Serif', 'Microsoft Sans Serif', Arial, sans-serif;
            font-size: 11px;
            background: var(--desktop-teal);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            color: #fff;
            overflow: hidden;
            user-select: none;
        }

        .header {
            background: var(--active-title-bar);
            padding: 0.5rem 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 99;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            border-bottom: 2px solid var(--button-face);
            z-index: 100;
        }

        .header h1 {
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-family: 'MS Sans Serif', Arial, sans-serif;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        .logo {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, #ff0000 0%, #ffff00 25%, #00ff00 50%, #0000ff 100%);
            display: inline-block;
            position: relative;
            transform: perspective(10px) rotateY(-5deg);
            box-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .controls {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        /* Authentic Windows 95 3D button effect */
        .btn {
            padding: 3px 8px;
            background: var(--button-face);
            border: none;
            box-shadow:
                inset 1px 1px 0 var(--button-highlight),
                inset 2px 2px 0 var(--button-light),
                inset -1px -1px 0 var(--button-dark-shadow),
                inset -2px -2px 0 var(--button-shadow);
            color: var(--text-color);
            font-family: 'MS Sans Serif', Arial, sans-serif;
            font-size: 11px;
            cursor: pointer;
            user-select: none;
            outline: none;
            position: relative;
            min-height: 22px;
        }

        /* Pressed button effect */
        .btn:active {
            box-shadow:
                inset -1px -1px 0 var(--button-highlight),
                inset -2px -2px 0 var(--button-light),
                inset 1px 1px 0 var(--button-dark-shadow),
                inset 2px 2px 0 var(--button-shadow);
            padding: 4px 7px 2px 9px;
        }

        /* Focus state for accessibility */
        .btn:focus-visible {
            outline: 1px dotted var(--text-color);
            outline-offset: -4px;
        }

        .btn:disabled {
            color: var(--button-shadow);
            text-shadow: 1px 1px 0 var(--button-highlight);
            cursor: default;
        }

        .btn.primary {
            background: var(--active-title-bar);
            color: white;
            font-weight: bold;
            border: 1px solid #000;
        }

        .main-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 1rem;
            position: relative;
            overflow: auto;
        }

        .emulator-frame {
            background: var(--button-face);
            border: none;
            box-shadow: none;
            padding: 0;
            margin: 0;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            max-width: 100vw;
            max-height: 100vh;
            z-index: 1000;
            display: flex;
            flex-direction: column;
        }

        /* Fullscreen mode styling */
        .emulator-frame.fullscreen-mode {
            max-width: 100vw;
            max-height: 100vh;
            width: 100vw;
            height: 100vh;
        }

        .emulator-frame.fullscreen-mode #screen_container {
            background: #008080; /* Match desktop teal background */
            align-items: stretch;
            justify-content: stretch;
        }

        .emulator-frame.fullscreen-mode #screen {
            width: 100% !important;
            height: 100% !important;
            max-width: 100%;
            max-height: 100%;
            object-fit: fill;
        }

        .emulator-titlebar {
            display: none !important; /* Hide the titlebar for fullscreen experience */
            background: var(--active-title-bar);
            color: white;
            padding: 2px 4px;
            justify-content: space-between;
            align-items: center;
            font-family: 'MS Sans Serif', Arial, sans-serif;
            font-size: 11px;
            font-weight: bold;
            user-select: none;
            height: 18px;
            cursor: default;
        }

        .emulator-titlebar.inactive {
            background: var(--inactive-title-bar);
        }

        .titlebar-buttons {
            display: flex;
            gap: 2px;
        }

        .titlebar-btn {
            width: 16px;
            height: 14px;
            background: var(--button-face);
            border: none;
            box-shadow:
                inset 1px 1px 0 var(--button-highlight),
                inset -1px -1px 0 var(--button-dark-shadow);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-family: 'MS Sans Serif', Arial, sans-serif;
            font-size: 10px;
            font-weight: bold;
            color: var(--text-color);
        }

        .titlebar-btn:active {
            box-shadow:
                inset -1px -1px 0 var(--button-highlight),
                inset 1px 1px 0 var(--button-dark-shadow);
            padding-top: 1px;
            padding-left: 1px;
        }

        .titlebar-btn:hover {
            background: var(--button-light);
        }

        #screen_container {
            background: #000;
            position: relative;
            display: flex;
            align-items: stretch;
            justify-content: stretch;
            overflow: hidden;
            flex: 1;
            min-height: 0;
            width: 100%;
            height: 100%;
        }

        #screen {
            /* Fill entire viewport - no aspect ratio preservation */
            width: 100% !important;
            height: 100% !important;
            max-width: 100% !important;
            max-height: 100% !important;
            object-fit: fill !important;
        }

        canvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
            -ms-interpolation-mode: nearest-neighbor;
            /* Width and height controlled by #screen selector for proper scaling */
        }

        .status-bar {
            background: var(--button-face);
            border-top: 1px solid var(--button-highlight);
            padding: 4px 8px;
            display: flex;
            justify-content: space-between;
            font-family: 'MS Sans Serif', Arial, sans-serif;
            font-size: 11px;
            color: var(--text-color);
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .status-section {
            border-left: 1px solid var(--button-shadow);
            border-right: 1px solid var(--button-highlight);
            padding: 0 8px;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .status-section:first-child {
            border-left: none;
            padding-left: 0;
        }

        .led {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--button-shadow);
            box-shadow: inset 0 0 2px rgba(0,0,0,0.5);
            transition: all 0.1s ease;
        }

        .led.active {
            background: #00ff00;
            box-shadow: 0 0 5px #00ff00, inset 0 0 2px rgba(255,255,255,0.5);
        }

        .led.hdd {
            background: #ff0000;
        }

        .led.hdd.active {
            background: #ff6600;
            box-shadow: 0 0 5px #ff6600, inset 0 0 2px rgba(255,255,255,0.5);
        }

        .setup-screen {
            background: var(--button-face);
            border: none;
            box-shadow:
                inset 1px 1px 0 var(--button-light),
                inset 2px 2px 0 var(--button-highlight),
                inset -1px -1px 0 var(--button-shadow),
                inset -2px -2px 0 var(--button-dark-shadow),
                0 0 20px rgba(0,0,0,0.5);
            padding: 20px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .setup-screen h2 {
            background: var(--active-title-bar);
            color: white;
            padding: 4px 8px;
            margin: -20px -20px 15px -20px;
            font-family: 'MS Sans Serif', Arial, sans-serif;
            font-size: 14px;
        }

        .setup-content {
            color: var(--text-color);
            font-family: 'MS Sans Serif', Arial, sans-serif;
            font-size: 11px;
        }

        .setup-content p {
            margin: 8px 0;
            line-height: 1.4;
        }

        .setup-option {
            margin: 15px 0;
            padding: 10px;
            background: var(--window-background);
            border: 1px solid var(--button-shadow);
            box-shadow: inset -1px -1px 0 var(--button-highlight);
        }

        .setup-option h3 {
            margin-bottom: 8px;
            font-size: 12px;
            color: var(--active-title-bar);
        }

        .setup-option p {
            margin: 5px 0;
            line-height: 1.4;
        }

        .file-input-wrapper {
            position: relative;
            display: inline-block;
            margin-top: 10px;
        }

        .file-input-wrapper input[type="file"] {
            position: absolute;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
            z-index: 1;
        }

        .file-input-label {
            display: inline-block;
            padding: 3px 8px;
            background: var(--button-face);
            border: none;
            box-shadow:
                inset 1px 1px 0 var(--button-highlight),
                inset 2px 2px 0 var(--button-light),
                inset -1px -1px 0 var(--button-dark-shadow),
                inset -2px -2px 0 var(--button-shadow);
            cursor: pointer;
            font-family: 'MS Sans Serif', Arial, sans-serif;
            font-size: 11px;
            color: var(--text-color);
        }

        input[type="text"],
        select {
            padding: 2px 4px;
            border: 1px solid var(--button-shadow);
            box-shadow: inset -1px -1px 0 var(--button-highlight);
            font-family: 'MS Sans Serif', Arial, sans-serif;
            font-size: 11px;
            background: var(--window-background);
        }

        input[type="text"]:focus,
        select:focus {
            outline: 1px dotted var(--text-color);
            outline-offset: -2px;
        }

        label {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            cursor: pointer;
            padding: 2px 0;
        }

        input[type="checkbox"] {
            width: 13px;
            height: 13px;
            cursor: pointer;
        }

        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            display: none;
        }

        .loading-screen.active {
            display: flex;
        }

        .boot-logo {
            width: 200px;
            height: 150px;
            background: linear-gradient(135deg, #ff0000 0%, #ffff00 25%, #00ff00 50%, #0000ff 100%);
            margin-bottom: 30px;
            position: relative;
            animation: bootWave 2s infinite;
            box-shadow: 0 0 20px rgba(255,255,255,0.3);
        }

        @keyframes bootWave {
            0%, 100% { transform: perspective(100px) rotateY(0deg); }
            50% { transform: perspective(100px) rotateY(10deg); }
        }

        .loading-text {
            color: #c0c0c0;
            font-family: 'MS Sans Serif', Arial, sans-serif;
            font-size: 14px;
            margin-bottom: 20px;
            text-align: center;
        }

        .progress-bar {
            width: 300px;
            height: 20px;
            background: #000;
            border: 2px solid #c0c0c0;
            position: relative;
            overflow: hidden;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.8);
        }

        .progress-fill {
            height: 100%;
            background: repeating-linear-gradient(
                90deg,
                #000080 0px,
                #000080 10px,
                #1084d0 10px,
                #1084d0 20px
            );
            width: 0%;
            transition: width 0.3s ease;
            animation: slide 1s linear infinite;
        }

        @keyframes slide {
            0% { background-position: 0 0; }
            100% { background-position: 20px 0; }
        }

        .info-panel {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: #ffffcc;
            border: 2px solid var(--text-color);
            padding: 10px;
            max-width: 300px;
            box-shadow: 3px 3px 0 rgba(0,0,0,0.3);
            color: var(--text-color);
            font-family: 'MS Sans Serif', Arial, sans-serif;
            font-size: 11px;
        }

        .info-panel h4 {
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 12px;
        }

        .info-panel ul {
            margin-left: 20px;
            margin-top: 5px;
        }

        .info-panel li {
            margin: 3px 0;
            line-height: 1.3;
        }

        .warning-icon {
            color: #ff0000;
            font-weight: bold;
            font-size: 14px;
        }

        .hidden {
            display: none !important;
        }

        /* Desktop icons styling */
        .desktop-icon {
            position: absolute;
            width: 64px;
            text-align: center;
            cursor: pointer;
            user-select: none;
        }

        .desktop-icon.selected .icon-text {
            background: var(--menu-highlight);
            color: white;
        }

        .icon-image {
            width: 32px;
            height: 32px;
            margin: 0 auto 4px;
        }

        .icon-text {
            font-size: 11px;
            padding: 1px 2px;
            word-wrap: break-word;
        }

        /* Window styling improvements */
        .window {
            position: absolute;
            background: var(--button-face);
            border: 2px solid;
            border-color: var(--button-highlight) var(--button-dark-shadow) var(--button-dark-shadow) var(--button-highlight);
            box-shadow: 1px 1px 0 var(--button-shadow);
            min-width: 200px;
            min-height: 100px;
            display: flex;
            flex-direction: column;
            z-index: 10;
        }

        .window.minimized {
            display: none;
        }

        .window.active {
            z-index: 1000;
        }

        .window-titlebar {
            background: var(--active-title-bar);
            color: white;
            padding: 2px 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
            cursor: move;
            height: 18px;
            user-select: none;
        }

        .window-titlebar.inactive {
            background: var(--inactive-title-bar);
        }

        .window-content {
            background: var(--window-background);
            padding: 8px;
            overflow: auto;
            flex: 1;
            color: var(--text-color);
        }

        .resize-handle {
            position: absolute;
            z-index: 10;
        }

        .resize-n, .resize-s {
            left: 0;
            right: 0;
            height: 5px;
            cursor: ns-resize;
        }

        .resize-n { top: 0; }
        .resize-s { bottom: 0; }

        .resize-e, .resize-w {
            top: 0;
            bottom: 0;
            width: 5px;
            cursor: ew-resize;
        }

        .resize-e { right: 0; }
        .resize-w { left: 0; }

        .resize-ne, .resize-nw, .resize-se, .resize-sw {
            width: 10px;
            height: 10px;
        }

        .resize-ne {
            top: 0;
            right: 0;
            cursor: nesw-resize;
        }

        .resize-nw {
            top: 0;
            left: 0;
            cursor: nwse-resize;
        }

        .resize-se {
            bottom: 0;
            right: 0;
            cursor: nwse-resize;
        }

        .resize-sw {
            bottom: 0;
            left: 0;
            cursor: nesw-resize;
        }

        .taskbar-button {
            min-width: 100px;
            max-width: 200px;
            padding: 2px 4px;
            margin: 2px;
            background: var(--button-face);
            border: 2px solid;
            border-color: var(--button-highlight) var(--button-dark-shadow) var(--button-dark-shadow) var(--button-highlight);
            cursor: pointer;
            font-size: 11px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .taskbar-button.active {
            border-color: var(--button-dark-shadow) var(--button-highlight) var(--button-highlight) var(--button-dark-shadow);
            padding: 3px 3px 1px 5px;
        }

        .start-menu {
            position: absolute;
            bottom: 30px;
            left: 0;
            width: 200px;
            background: var(--button-face);
            border: 2px solid;
            border-color: var(--button-highlight) var(--button-dark-shadow) var(--button-dark-shadow) var(--button-highlight);
            display: none;
            z-index: 10000;
        }

        .start-menu.active {
            display: block;
        }

        .start-menu-sidebar {
            background: var(--inactive-title-bar);
            color: white;
            padding: 20px 4px;
            writing-mode: vertical-lr;
            transform: rotate(180deg);
            font-weight: bold;
            font-size: 16px;
        }

        .start-menu-items {
            padding: 2px;
        }

        .start-menu-item {
            padding: 4px 30px 4px 8px;
            cursor: pointer;
            position: relative;
            font-size: 11px;
        }

        .start-menu-item:hover {
            background: var(--menu-highlight);
            color: white;
        }

        .start-menu-item::before {
            content: '';
            position: absolute;
            left: 8px;
            top: 50%;
            transform: translateY(-50%);
            width: 16px;
            height: 16px;
        }

        .context-menu {
            position: absolute;
            background: var(--button-face);
            border: 2px solid;
            border-color: var(--button-highlight) var(--button-dark-shadow) var(--button-dark-shadow) var(--button-highlight);
            padding: 2px;
            min-width: 150px;
            display: none;
            z-index: 10001;
        }

        .context-menu.active {
            display: block;
        }

        .context-menu-item {
            padding: 4px 8px;
            cursor: pointer;
            font-size: 11px;
        }

        .context-menu-item:hover {
            background: var(--menu-highlight);
            color: white;
        }

        .context-menu-separator {
            height: 1px;
            background: var(--button-shadow);
            margin: 2px 4px;
        }

        /* Scrollbar styling for Windows 95 authenticity */
        .setup-screen::-webkit-scrollbar {
            width: 16px;
            height: 16px;
        }

        .setup-screen::-webkit-scrollbar-track {
            background: var(--button-face);
        }

        .setup-screen::-webkit-scrollbar-thumb {
            background: var(--button-face);
            border: 1px solid;
            border-color: var(--button-highlight) var(--button-dark-shadow) var(--button-dark-shadow) var(--button-highlight);
        }

        .setup-screen::-webkit-scrollbar-button {
            background: var(--button-face);
            border: 1px solid;
            border-color: var(--button-highlight) var(--button-dark-shadow) var(--button-dark-shadow) var(--button-highlight);
        }

        /* Reduced motion support for accessibility */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 1.2rem;
            }

            .btn {
                min-height: 44px;
                min-width: 44px;
                padding: 0.6rem 1rem;
                font-size: 12px;
            }

            .info-panel {
                position: static;
                margin-top: 1rem;
                max-width: 100%;
            }

            .controls {
                width: 100%;
                justify-content: center;
            }
        }

        /* Tooltip styling */
        .tooltip {
            position: absolute;
            background: #ffffcc;
            border: 1px solid var(--text-color);
            padding: 2px 4px;
            font-size: 11px;
            pointer-events: none;
            z-index: 1000;
            white-space: nowrap;
            display: none;
        }

        /* Single Morphing Clippy Assistant System */
        .clippy-container {
            position: fixed;
            bottom: 80px;
            right: 30px;
            z-index: 9999;
            font-family: 'Comic Sans MS', cursive, sans-serif;
            pointer-events: auto;
        }

        .clippy-character {
            width: 80px;
            height: 100px;
            background: #fff;
            border: 2px solid #000;
            border-radius: 50% 50% 40% 40%;
            position: relative;
            cursor: pointer;
            transition: all 0.4s ease;
            box-shadow: 2px 2px 6px rgba(0,0,0,0.2);
        }

        .clippy-character:hover {
            transform: scale(1.05) rotate(2deg);
        }

        .clippy-character:active {
            transform: scale(0.95);
        }

        /* Mode-specific colors for Clippy body */
        .clippy-character.mode-helper {
            background: linear-gradient(135deg, #ffffff 0%, #f0f0ff 100%);
            border-color: #0000ff;
        }

        .clippy-character.mode-expert {
            background: linear-gradient(135deg, #ffffff 0%, #fff0f0 100%);
            border-color: #ff0000;
        }

        .clippy-character.mode-entertainer {
            background: linear-gradient(135deg, #ffffff 0%, #ffffdd 100%);
            border-color: #ffaa00;
        }

        .clippy-character.mode-coach {
            background: linear-gradient(135deg, #ffffff 0%, #f0fff0 100%);
            border-color: #00aa00;
        }

        .clippy-character.mode-organizer {
            background: linear-gradient(135deg, #ffffff 0%, #fff0ff 100%);
            border-color: #aa00aa;
        }

        .clippy-icon {
            font-size: 50px;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.4s ease;
        }

        .clippy-mode-indicator {
            position: absolute;
            bottom: -8px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--button-face);
            border: 1px solid #000;
            padding: 2px 6px;
            font-size: 9px;
            font-weight: bold;
            white-space: nowrap;
            box-shadow: 1px 1px 2px rgba(0,0,0,0.3);
            font-family: 'MS Sans Serif', Arial, sans-serif;
            transition: all 0.3s ease;
        }

        .clippy-bubble {
            display: none;
            position: absolute;
            bottom: 130px;
            right: 0;
            max-width: 260px;
            background: #ffffcc;
            border: 2px solid #000;
            border-radius: 8px;
            padding: 10px;
            box-shadow: 2px 2px 8px rgba(0,0,0,0.25);
            animation: bubbleAppear 0.3s ease-out;
            font-family: 'Comic Sans MS', cursive, sans-serif;
        }

        .clippy-bubble.active {
            display: block;
        }

        .bubble-arrow {
            position: absolute;
            bottom: -20px;
            right: 30px;
            border: 8px solid transparent;
            border-top-color: #000;
            z-index: 1;
        }

        .bubble-close {
            position: absolute;
            top: 2px;
            right: 2px;
            background: #c0c0c0;
            border: 1px solid #000;
            width: 16px;
            height: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
            font-family: 'MS Sans Serif', Arial, sans-serif;
        }

        .bubble-close:hover {
            background: #ff0000;
            color: #fff;
        }

        .clippy-message {
            font-size: 11px;
            line-height: 1.3;
            color: #000;
            margin-top: 4px;
        }

        @keyframes bubbleAppear {
            from {
                opacity: 0;
                transform: scale(0.85) translateY(10px);
            }
            to {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        @keyframes modeChange {
            0%, 100% { transform: scale(1) rotate(0deg); }
            50% { transform: scale(1.15) rotate(5deg); }
        }

        .clippy-character.morphing {
            animation: modeChange 0.5s ease;
        }

        /* LocalFirst Tools Browser Styles */
        .tools-browser-container {
            display: flex;
            flex-direction: column;
            height: 100%;
            padding: 10px;
            background: var(--button-face);
            overflow: hidden;
        }

        .tools-browser-header {
            background: white;
            border: 2px solid var(--button-shadow);
            box-shadow: inset -1px -1px 0 var(--button-highlight);
            padding: 10px;
            margin-bottom: 10px;
        }

        .tools-search-row {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
            flex-wrap: wrap;
        }

        .tools-search-input {
            flex: 1;
            min-width: 200px;
            padding: 4px 6px;
            border: 1px solid var(--button-shadow);
            box-shadow: inset -1px -1px 0 var(--button-highlight);
            font-family: 'MS Sans Serif', Arial, sans-serif;
            font-size: 11px;
        }

        .tools-category-select {
            padding: 3px 6px;
            border: 1px solid var(--button-shadow);
            box-shadow: inset -1px -1px 0 var(--button-highlight);
            font-family: 'MS Sans Serif', Arial, sans-serif;
            font-size: 11px;
            background: white;
        }

        .tools-results-counter {
            font-size: 11px;
            color: var(--text-color);
            font-family: 'MS Sans Serif', Arial, sans-serif;
        }

        .tools-grid {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            background: white;
            border: 2px solid var(--button-shadow);
            box-shadow: inset -1px -1px 0 var(--button-highlight);
            padding: 10px;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
            gap: 12px;
            align-content: start;
        }

        .tool-card {
            background: white;
            border: 2px solid #dfdfdf;
            padding: 12px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            gap: 8px;
            height: fit-content;
        }

        .tool-card:hover {
            transform: translateY(-2px);
            box-shadow: 3px 3px 8px rgba(0,0,0,0.2);
            border-color: var(--active-title-bar);
        }

        .tool-card-title {
            font-weight: bold;
            font-size: 12px;
            color: var(--text-color);
            margin-bottom: 4px;
            word-wrap: break-word;
        }

        .tool-card-description {
            font-size: 10px;
            color: #555;
            line-height: 1.4;
            margin-bottom: 8px;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .tool-card-meta {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .category-badge {
            padding: 4px 8px;
            border-radius: 3px;
            font-size: 10px;
            color: white;
            font-weight: bold;
            text-align: center;
            width: fit-content;
        }

        .tool-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }

        .tag-pill {
            background: #f0f0f0;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 9px;
            color: #555;
            border: 1px solid #ddd;
        }

        .tool-card-button {
            margin-top: 4px;
            width: 100%;
        }

        .tools-status-bar {
            background: var(--button-face);
            border-top: 1px solid var(--button-highlight);
            padding: 6px 10px;
            font-size: 11px;
            color: var(--text-color);
            font-family: 'MS Sans Serif', Arial, sans-serif;
            text-align: center;
        }

        .tools-loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px;
            gap: 15px;
        }

        .tools-loading-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid var(--button-light);
            border-top: 4px solid var(--active-title-bar);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .tools-error {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px;
            gap: 15px;
            text-align: center;
        }

        .tools-error-icon {
            font-size: 48px;
        }

        .tools-empty {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px;
            text-align: center;
            color: #808080;
        }

        /* Screen Saver System */
        .screensaver {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
            z-index: 99999;
            display: none;
            overflow: hidden;
        }

        .screensaver.active {
            display: block;
        }

        .screensaver-canvas {
            width: 100%;
            height: 100%;
        }

        /* Starfield screensaver */
        .starfield-star {
            position: absolute;
            width: 2px;
            height: 2px;
            background: white;
            border-radius: 50%;
        }

        /* Pipes screensaver */
        .pipes-canvas {
            width: 100%;
            height: 100%;
            background: #000;
        }

        /* Matrix screensaver */
        .matrix-canvas {
            width: 100%;
            height: 100%;
            background: #000;
        }

        /* Flying Windows logo */
        .flying-logo {
            position: absolute;
            width: 100px;
            height: 100px;
            background: linear-gradient(135deg, #ff0000 0%, #ffff00 25%, #00ff00 50%, #0000ff 100%);
            box-shadow: 0 0 20px rgba(255,255,255,0.5);
            animation: floatAround 20s infinite ease-in-out;
        }

        @keyframes floatAround {
            0%, 100% { transform: translate(0, 0) rotate(0deg); }
            25% { transform: translate(80vw, 20vh) rotate(90deg); }
            50% { transform: translate(60vw, 70vh) rotate(180deg); }
            75% { transform: translate(10vw, 50vh) rotate(270deg); }
        }

        /* Toast notification system */
        .toast-notification {
            position: fixed;
            bottom: 50px;
            right: 20px;
            background: var(--button-face);
            border: 2px solid;
            border-color: var(--button-highlight) var(--button-dark-shadow) var(--button-dark-shadow) var(--button-highlight);
            padding: 12px 16px;
            min-width: 200px;
            max-width: 300px;
            z-index: 10002;
            box-shadow: 2px 2px 8px rgba(0,0,0,0.3);
            animation: slideIn 0.3s ease-out;
            font-family: 'MS Sans Serif', Arial, sans-serif;
            font-size: 11px;
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .toast-title {
            font-weight: bold;
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .toast-message {
            color: var(--text-color);
            line-height: 1.3;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1><span class="logo"></span> Windows 95 Desktop Simulator</h1>
        <div class="controls" role="toolbar" aria-label="Desktop controls">
            <button class="btn" id="pause-btn" onclick="emulator.togglePause()" aria-label="Pause desktop" title="Pause/Resume">
                <span aria-hidden="true">‚è∏</span> Pause
            </button>
            <button class="btn" onclick="emulator.restart()" aria-label="Restart desktop" title="Restart desktop">
                <span aria-hidden="true">üîÑ</span> Restart
            </button>
            <button class="btn" onclick="emulator.fullscreen()" aria-label="Enter fullscreen mode" title="Toggle fullscreen">
                <span aria-hidden="true">üñ•</span> Fullscreen
            </button>
            <button class="btn" onclick="emulator.screenshot()" aria-label="Take screenshot" title="Save screenshot">
                <span aria-hidden="true">üì∑</span> Screenshot
            </button>
            <button class="btn" onclick="emulator.showHelp()" aria-label="Show help information" title="Help & Information">
                <span aria-hidden="true">‚ùì</span> Help
            </button>
            <button class="btn primary" onclick="emulator.openAbout()" aria-label="About this simulator" title="About">
                <span aria-hidden="true">‚ÑπÔ∏è</span> About
            </button>
        </div>
    </div>

    <div class="main-container">
        <div id="setup-screen" class="setup-screen" role="dialog" aria-labelledby="setup-title">
            <h2 id="setup-title">Windows 95 Desktop Simulator</h2>
            <div class="setup-content">
                <p><strong>Welcome to the Interactive Windows 95 Desktop Simulator!</strong></p>
                <p>Experience a fully functional Windows 95 desktop environment right in your browser.</p>

                <div class="setup-option">
                    <h3><span aria-hidden="true">üéÆ</span> Start Desktop Experience</h3>
                    <p>Launch the interactive desktop with working programs and classic Windows 95 interface.</p>
                    <p><strong>Features:</strong></p>
                    <ul style="margin-left: 20px; margin-top: 5px;">
                        <li><strong>Internet Explorer</strong> - Browse real websites!</li>
                        <li>Draggable, resizable windows</li>
                        <li>Working Notepad, Calculator, and Minesweeper</li>
                        <li>Functional Start menu</li>
                        <li>Clickable desktop icons</li>
                        <li>Right-click context menus</li>
                        <li>Authentic Windows 95 aesthetics</li>
                    </ul>
                    <button class="btn primary" onclick="emulator.loadDemo()" style="margin-top: 10px;">Start Windows 95 Desktop</button>
                </div>

                <div class="setup-option" style="background: #e0e0e0;">
                    <h3><span aria-hidden="true">‚öôÔ∏è</span> Emulator Settings</h3>
                    <div style="display: grid; gap: 8px;">
                        <label>
                            <input type="checkbox" id="enable-mouse"> Enable Mouse Lock (Leave OFF for interactive desktop)
                        </label>
                        <label>
                            <input type="checkbox" id="enable-sound"> Enable Sound Emulation
                        </label>
                        <label>
                            <input type="checkbox" id="enable-network" checked> Enable Network
                        </label>
                        <label style="display: block; margin-top: 8px;">
                            <strong>Memory Allocation:</strong>
                            <select id="memory-size" style="width: 100%; margin-top: 4px;">
                                <option value="8">8 MB (Minimum)</option>
                                <option value="16">16 MB (Low)</option>
                                <option value="32" selected>32 MB (Recommended)</option>
                                <option value="64">64 MB (High)</option>
                                <option value="128">128 MB (Maximum)</option>
                            </select>
                        </label>
                        <label style="display: block; margin-top: 8px;">
                            <strong>CPU Speed:</strong>
                            <select id="cpu-speed" style="width: 100%; margin-top: 4px;">
                                <option value="1">1x (Authentic)</option>
                                <option value="2" selected>2x (Balanced)</option>
                                <option value="4">4x (Fast)</option>
                                <option value="8">8x (Maximum)</option>
                            </select>
                        </label>
                    </div>
                </div>

                <div class="setup-option" style="background: #fff8dc;">
                    <h3><span aria-hidden="true">‚ÑπÔ∏è</span> System Information</h3>
                    <p><strong>Browser:</strong> <span id="browser-info">Detecting...</span></p>
                    <p><strong>WebAssembly:</strong> <span id="wasm-support">Checking...</span></p>
                    <p><strong>Screen:</strong> <span id="screen-info">Detecting...</span></p>
                </div>
            </div>
        </div>

        <div id="emulator-container" class="emulator-frame hidden">
            <div class="emulator-titlebar" id="emulator-titlebar">
                <span>Windows 95 Desktop - Interactive Mode</span>
                <div class="titlebar-buttons">
                    <div class="titlebar-btn" onclick="emulator.minimize()" role="button" aria-label="Minimize" title="Minimize">_</div>
                    <div class="titlebar-btn" onclick="emulator.maximize()" role="button" aria-label="Maximize" title="Maximize">‚ñ°</div>
                    <div class="titlebar-btn" onclick="emulator.close()" role="button" aria-label="Close" title="Close">X</div>
                </div>
            </div>
            <div id="screen_container">
                <canvas id="screen" role="img" aria-label="Windows 95 emulator screen" tabindex="0"></canvas>
            </div>
            <div class="status-bar" role="status" aria-live="polite" aria-atomic="false">
                <div class="status-section">
                    <span id="cpu-status-label">CPU:</span>
                    <span id="cpu-status" aria-labelledby="cpu-status-label">Idle</span>
                    <div class="led" id="cpu-led" role="status" aria-label="CPU activity indicator" title="CPU Activity"></div>
                </div>
                <div class="status-section">
                    <span>HDD:</span>
                    <div class="led hdd" id="hdd-led" role="status" aria-label="Hard drive activity indicator" title="HDD Activity"></div>
                </div>
                <div class="status-section">
                    <span>FPS:</span>
                    <span id="fps-counter" aria-label="Frames per second">0</span>
                </div>
                <div class="status-section">
                    <span>MEM:</span>
                    <span id="memory-usage" aria-label="Memory usage">0 MB</span>
                </div>
                <div class="status-section">
                    <span id="time-display" aria-label="Uptime" title="Uptime">00:00:00</span>
                </div>
            </div>
        </div>

        <div class="info-panel" id="info-panel">
            <h4><span class="warning-icon" aria-hidden="true">üí°</span> Quick Start Guide</h4>
            <ul>
                <li><strong>Try Internet Explorer!</strong> Browse real websites (try wikipedia.org)</li>
                <li><strong>Double-click</strong> desktop icons to launch programs</li>
                <li><strong>Drag</strong> windows by their title bars to move them</li>
                <li><strong>Click</strong> the Start button for the program menu</li>
                <li><strong>Right-click</strong> the desktop for context menu</li>
                <li><strong>Minimize</strong> windows to the taskbar</li>
                <li>Press <strong>F11</strong> for fullscreen mode</li>
                <li><strong>Note:</strong> Mouse lock is disabled for free movement</li>
            </ul>
            <button class="btn" onclick="document.getElementById('info-panel').classList.add('hidden')" style="margin-top: 8px; width: 100%;">Got it!</button>
        </div>
    </div>

    <div class="loading-screen" id="loading-screen" role="alert" aria-live="assertive">
        <div class="boot-logo" aria-hidden="true"></div>
        <div class="loading-text" id="loading-text">Starting Windows 95 Desktop...</div>
        <div class="progress-bar" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">
            <div class="progress-fill" id="progress-fill"></div>
        </div>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <script>
        /** @ts-nocheck */
        // Polyfill for String.padStart (IE11, Safari < 10)
        if (!String.prototype.padStart) {
            String.prototype.padStart = function padStart(targetLength, padString) {
                targetLength = targetLength >> 0;
                padString = String(typeof padString !== 'undefined' ? padString : ' ');
                if (this.length >= targetLength) {
                    return String(this);
                }
                targetLength = targetLength - this.length;
                if (targetLength > padString.length) {
                    padString += padString.repeat(targetLength / padString.length);
                }
                return padString.slice(0, targetLength) + String(this);
            };
        }

        // Configuration constants
        const CONFIG = {
            DISPLAY: {
                WIDTH: 640,
                HEIGHT: 480,
                TASKBAR_HEIGHT: 30
            },
            COLORS: {
                DESKTOP: '#008080',
                TASKBAR: '#c0c0c0',
                TITLE_BAR: '#000080',
                WINDOW_BG: '#ffffff'
            },
            ANIMATION: {
                FPS_UPDATE_INTERVAL: 1000,
                LED_THROTTLE_FRAMES: 10,
                BOOT_MESSAGE_DELAY: 150
            },
            PERFORMANCE: {
                MAX_FPS: 60,
                FRAME_TIME: 16.67
            }
        };

        // Window Manager - handles all window operations
        class WindowManager {
            constructor(desktop) {
                this.desktop = desktop;
                this.windows = [];
                this.nextZIndex = 1000;
                this.draggedWindow = null;
                this.dragOffset = { x: 0, y: 0 };
                this.resizingWindow = null;
                this.resizeDirection = null;
                this.resizeStart = { x: 0, y: 0, width: 0, height: 0, left: 0, top: 0 };
                this.snapThreshold = 20; // pixels from edge to trigger snap
            }

            createWindow(title, content, options = {}) {
                const windowId = 'win-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);

                // Load saved position if available
                const savedPosition = this.loadWindowPosition(title);
                const defaultX = 100 + this.windows.length * 30;
                const defaultY = 100 + this.windows.length * 30;

                const windowEl = document.createElement('div');
                windowEl.className = 'window active';
                windowEl.id = windowId;
                windowEl.style.left = (options.x || savedPosition?.x || defaultX) + 'px';
                windowEl.style.top = (options.y || savedPosition?.y || defaultY) + 'px';
                windowEl.style.width = (options.width || savedPosition?.width || 400) + 'px';
                windowEl.style.height = (options.height || savedPosition?.height || 300) + 'px';
                windowEl.style.zIndex = this.nextZIndex++;
                windowEl.dataset.windowTitle = title; // Store title for position saving

                const titleBar = document.createElement('div');
                titleBar.className = 'window-titlebar';
                titleBar.innerHTML = `
                    <span>${title}</span>
                    <div class="titlebar-buttons">
                        <div class="titlebar-btn minimize-btn" title="Minimize">_</div>
                        <div class="titlebar-btn maximize-btn" title="Maximize">‚ñ°</div>
                        <div class="titlebar-btn close-btn" title="Close">X</div>
                    </div>
                `;

                const contentEl = document.createElement('div');
                contentEl.className = 'window-content';
                if (typeof content === 'string') {
                    contentEl.innerHTML = content;
                } else {
                    contentEl.appendChild(content);
                }

                // Add resize handles
                const resizeHandles = document.createElement('div');
                resizeHandles.innerHTML = `
                    <div class="resize-handle resize-n" data-direction="n"></div>
                    <div class="resize-handle resize-s" data-direction="s"></div>
                    <div class="resize-handle resize-e" data-direction="e"></div>
                    <div class="resize-handle resize-w" data-direction="w"></div>
                    <div class="resize-handle resize-ne" data-direction="ne"></div>
                    <div class="resize-handle resize-nw" data-direction="nw"></div>
                    <div class="resize-handle resize-se" data-direction="se"></div>
                    <div class="resize-handle resize-sw" data-direction="sw"></div>
                `;

                windowEl.appendChild(titleBar);
                windowEl.appendChild(contentEl);
                windowEl.appendChild(resizeHandles);

                // Add to desktop
                const screenContainer = document.getElementById('screen_container');
                screenContainer.appendChild(windowEl);

                // Setup event listeners
                this.setupWindowEvents(windowEl, titleBar);

                // Store window reference
                const windowObj = {
                    id: windowId,
                    element: windowEl,
                    title: title,
                    minimized: false
                };
                this.windows.push(windowObj);

                // Add taskbar button
                this.desktop.addTaskbarButton(windowObj);

                // Focus window
                this.focusWindow(windowEl);

                // Play window open sound
                if (this.desktop.playSoundEffect) {
                    this.desktop.playSoundEffect('window-open');
                }

                return windowObj;
            }

            setupWindowEvents(windowEl, titleBar) {
                // Make titlebar draggable
                titleBar.addEventListener('mousedown', (e) => {
                    if (e.target.closest('.titlebar-btn')) return;

                    this.draggedWindow = windowEl;
                    this.dragOffset = {
                        x: e.clientX - windowEl.offsetLeft,
                        y: e.clientY - windowEl.offsetTop
                    };
                    this.focusWindow(windowEl);
                });

                // Close button
                const closeBtn = windowEl.querySelector('.close-btn');
                closeBtn.addEventListener('click', () => this.closeWindow(windowEl));

                // Minimize button
                const minimizeBtn = windowEl.querySelector('.minimize-btn');
                minimizeBtn.addEventListener('click', () => this.minimizeWindow(windowEl));

                // Maximize button
                const maximizeBtn = windowEl.querySelector('.maximize-btn');
                maximizeBtn.addEventListener('click', () => this.maximizeWindow(windowEl));

                // Focus on click
                windowEl.addEventListener('mousedown', () => this.focusWindow(windowEl));

                // Resize handles
                const resizeHandles = windowEl.querySelectorAll('.resize-handle');
                resizeHandles.forEach(handle => {
                    handle.addEventListener('mousedown', (e) => {
                        e.stopPropagation();
                        this.resizingWindow = windowEl;
                        this.resizeDirection = handle.dataset.direction;
                        this.resizeStart = {
                            x: e.clientX,
                            y: e.clientY,
                            width: windowEl.offsetWidth,
                            height: windowEl.offsetHeight,
                            left: windowEl.offsetLeft,
                            top: windowEl.offsetTop
                        };
                        this.focusWindow(windowEl);
                    });
                });
            }

            focusWindow(windowEl) {
                // Remove active class from all windows
                this.windows.forEach(win => {
                    win.element.classList.remove('active');
                    const titlebar = win.element.querySelector('.window-titlebar');
                    if (titlebar) titlebar.classList.add('inactive');
                });

                // Set active window
                windowEl.classList.add('active');
                windowEl.style.zIndex = this.nextZIndex++;
                const titlebar = windowEl.querySelector('.window-titlebar');
                if (titlebar) titlebar.classList.remove('inactive');

                // Update taskbar buttons
                this.desktop.updateTaskbarButtons();
            }

            minimizeWindow(windowEl) {
                const windowObj = this.windows.find(w => w.element === windowEl);
                if (windowObj) {
                    windowObj.minimized = true;
                    windowEl.classList.add('minimized');
                    this.desktop.updateTaskbarButtons();

                    // Play minimize sound
                    if (this.desktop.playSoundEffect) {
                        this.desktop.playSoundEffect('minimize');
                    }
                }
            }

            maximizeWindow(windowEl) {
                const isMaximized = windowEl.dataset.maximized === 'true';

                if (isMaximized) {
                    // Restore
                    windowEl.style.left = windowEl.dataset.restoreLeft;
                    windowEl.style.top = windowEl.dataset.restoreTop;
                    windowEl.style.width = windowEl.dataset.restoreWidth;
                    windowEl.style.height = windowEl.dataset.restoreHeight;
                    windowEl.dataset.maximized = 'false';

                    // Save restored position
                    const title = windowEl.dataset.windowTitle;
                    if (title) {
                        this.saveWindowPosition(title, {
                            x: parseInt(windowEl.style.left),
                            y: parseInt(windowEl.style.top),
                            width: parseInt(windowEl.style.width),
                            height: parseInt(windowEl.style.height)
                        });
                    }

                    // Play minimize sound (for restore)
                    if (this.desktop.playSoundEffect) {
                        this.desktop.playSoundEffect('minimize');
                    }
                } else {
                    // Store current position
                    windowEl.dataset.restoreLeft = windowEl.style.left;
                    windowEl.dataset.restoreTop = windowEl.style.top;
                    windowEl.dataset.restoreWidth = windowEl.style.width;
                    windowEl.dataset.restoreHeight = windowEl.style.height;

                    // Maximize
                    windowEl.style.left = '0px';
                    windowEl.style.top = '0px';
                    windowEl.style.width = '640px';
                    windowEl.style.height = '450px';
                    windowEl.dataset.maximized = 'true';

                    // Play maximize sound
                    if (this.desktop.playSoundEffect) {
                        this.desktop.playSoundEffect('maximize');
                    }
                }
            }

            restoreWindow(windowEl) {
                const windowObj = this.windows.find(w => w.element === windowEl);
                if (windowObj && windowObj.minimized) {
                    windowObj.minimized = false;
                    windowEl.classList.remove('minimized');
                    this.focusWindow(windowEl);
                    this.desktop.updateTaskbarButtons();
                }
            }

            closeWindow(windowEl) {
                const index = this.windows.findIndex(w => w.element === windowEl);
                if (index > -1) {
                    const windowObj = this.windows[index];
                    this.desktop.removeTaskbarButton(windowObj);
                    windowEl.remove();
                    this.windows.splice(index, 1);

                    // Play window close sound
                    if (this.desktop.playSoundEffect) {
                        this.desktop.playSoundEffect('window-close');
                    }
                }
            }

            handleMouseMove(e) {
                // Handle window resizing
                if (this.resizingWindow) {
                    const deltaX = e.clientX - this.resizeStart.x;
                    const deltaY = e.clientY - this.resizeStart.y;
                    const dir = this.resizeDirection;
                    const win = this.resizingWindow;
                    const minWidth = 200;
                    const minHeight = 150;

                    let newWidth = this.resizeStart.width;
                    let newHeight = this.resizeStart.height;
                    let newLeft = this.resizeStart.left;
                    let newTop = this.resizeStart.top;

                    // Calculate new dimensions based on resize direction
                    if (dir.includes('e')) {
                        newWidth = Math.max(minWidth, this.resizeStart.width + deltaX);
                    }
                    if (dir.includes('w')) {
                        newWidth = Math.max(minWidth, this.resizeStart.width - deltaX);
                        if (newWidth > minWidth) newLeft = this.resizeStart.left + deltaX;
                    }
                    if (dir.includes('s')) {
                        newHeight = Math.max(minHeight, this.resizeStart.height + deltaY);
                    }
                    if (dir.includes('n')) {
                        newHeight = Math.max(minHeight, this.resizeStart.height - deltaY);
                        if (newHeight > minHeight) newTop = this.resizeStart.top + deltaY;
                    }

                    win.style.width = newWidth + 'px';
                    win.style.height = newHeight + 'px';
                    win.style.left = newLeft + 'px';
                    win.style.top = newTop + 'px';
                }

                // Handle window dragging
                if (this.draggedWindow) {
                    const screenContainer = document.getElementById('screen_container');
                    const containerRect = screenContainer.getBoundingClientRect();
                    const containerWidth = containerRect.width;
                    const containerHeight = containerRect.height;

                    let newX = e.clientX - this.dragOffset.x;
                    let newY = e.clientY - this.dragOffset.y;

                    // Keep within bounds
                    newX = Math.max(0, Math.min(containerWidth - 100, newX));
                    newY = Math.max(0, Math.min(containerHeight - 30, newY));

                    this.draggedWindow.style.left = newX + 'px';
                    this.draggedWindow.style.top = newY + 'px';

                    // Show snap preview
                    this.showSnapPreview(e.clientX, e.clientY, containerWidth, containerHeight);
                }
            }

            handleMouseUp(e) {
                // Handle resize end
                if (this.resizingWindow) {
                    const title = this.resizingWindow.dataset.windowTitle;
                    if (title) {
                        this.saveWindowPosition(title, {
                            x: parseInt(this.resizingWindow.style.left),
                            y: parseInt(this.resizingWindow.style.top),
                            width: parseInt(this.resizingWindow.style.width),
                            height: parseInt(this.resizingWindow.style.height)
                        });
                    }
                    this.resizingWindow = null;
                    this.resizeDirection = null;
                }

                // Handle drag end with snap
                if (this.draggedWindow) {
                    const screenContainer = document.getElementById('screen_container');
                    const containerRect = screenContainer.getBoundingClientRect();
                    const containerWidth = containerRect.width;
                    const containerHeight = containerRect.height;

                    // Check for snap zones
                    const snapPosition = this.getSnapPosition(e.clientX, e.clientY, containerWidth, containerHeight);
                    if (snapPosition) {
                        this.snapWindow(this.draggedWindow, snapPosition, containerWidth, containerHeight);
                    }

                    // Save window position after dragging
                    const title = this.draggedWindow.dataset.windowTitle;
                    if (title) {
                        this.saveWindowPosition(title, {
                            x: parseInt(this.draggedWindow.style.left),
                            y: parseInt(this.draggedWindow.style.top),
                            width: parseInt(this.draggedWindow.style.width),
                            height: parseInt(this.draggedWindow.style.height)
                        });
                    }
                    this.draggedWindow = null;
                    this.hideSnapPreview();
                }
            }

            showSnapPreview(mouseX, mouseY, containerWidth, containerHeight) {
                const snapPosition = this.getSnapPosition(mouseX, mouseY, containerWidth, containerHeight);
                let preview = document.getElementById('snap-preview');

                if (!preview) {
                    preview = document.createElement('div');
                    preview.id = 'snap-preview';
                    preview.style.cssText = 'position: absolute; border: 3px solid #0066cc; background: rgba(0, 102, 204, 0.1); pointer-events: none; z-index: 9999; display: none;';
                    document.getElementById('screen_container').appendChild(preview);
                }

                if (snapPosition) {
                    const pos = this.calculateSnapDimensions(snapPosition, containerWidth, containerHeight);
                    preview.style.left = pos.left + 'px';
                    preview.style.top = pos.top + 'px';
                    preview.style.width = pos.width + 'px';
                    preview.style.height = pos.height + 'px';
                    preview.style.display = 'block';
                } else {
                    preview.style.display = 'none';
                }
            }

            hideSnapPreview() {
                const preview = document.getElementById('snap-preview');
                if (preview) {
                    preview.style.display = 'none';
                }
            }

            getSnapPosition(mouseX, mouseY, containerWidth, containerHeight) {
                const threshold = this.snapThreshold;

                // Left edge
                if (mouseX < threshold) {
                    if (mouseY < threshold) return 'top-left';
                    if (mouseY > containerHeight - threshold) return 'bottom-left';
                    return 'left';
                }

                // Right edge
                if (mouseX > containerWidth - threshold) {
                    if (mouseY < threshold) return 'top-right';
                    if (mouseY > containerHeight - threshold) return 'bottom-right';
                    return 'right';
                }

                // Top edge
                if (mouseY < threshold) {
                    return 'top';
                }

                // Bottom edge
                if (mouseY > containerHeight - threshold) {
                    return 'bottom';
                }

                return null;
            }

            calculateSnapDimensions(position, containerWidth, containerHeight) {
                const taskbarHeight = 30;
                const workHeight = containerHeight - taskbarHeight;

                const positions = {
                    'left': { left: 0, top: 0, width: containerWidth / 2, height: workHeight },
                    'right': { left: containerWidth / 2, top: 0, width: containerWidth / 2, height: workHeight },
                    'top': { left: 0, top: 0, width: containerWidth, height: workHeight },
                    'bottom': { left: 0, top: workHeight / 2, width: containerWidth, height: workHeight / 2 },
                    'top-left': { left: 0, top: 0, width: containerWidth / 2, height: workHeight / 2 },
                    'top-right': { left: containerWidth / 2, top: 0, width: containerWidth / 2, height: workHeight / 2 },
                    'bottom-left': { left: 0, top: workHeight / 2, width: containerWidth / 2, height: workHeight / 2 },
                    'bottom-right': { left: containerWidth / 2, top: workHeight / 2, width: containerWidth / 2, height: workHeight / 2 }
                };

                return positions[position] || null;
            }

            snapWindow(windowEl, position, containerWidth, containerHeight) {
                const dims = this.calculateSnapDimensions(position, containerWidth, containerHeight);
                if (dims) {
                    windowEl.style.left = dims.left + 'px';
                    windowEl.style.top = dims.top + 'px';
                    windowEl.style.width = dims.width + 'px';
                    windowEl.style.height = dims.height + 'px';
                    windowEl.dataset.maximized = 'false';
                }
            }

            updateBounds(width, height) {
                // This is called when the canvas/screen is resized (e.g., fullscreen mode)
                // We don't need to do anything special here since windows use absolute positioning
                // and the snap calculations already use current dimensions
                console.log('Window manager bounds updated:', width, height);
            }

            loadWindowPosition(title) {
                try {
                    const positions = SafeStorage.getItem('win95-window-positions');
                    if (positions) {
                        const allPositions = JSON.parse(positions);
                        return allPositions[title];
                    }
                } catch (e) {
                    console.warn('Failed to load window position:', e);
                }
                return null;
            }

            saveWindowPosition(title, position) {
                try {
                    let positions = {};
                    const saved = SafeStorage.getItem('win95-window-positions');
                    if (saved) {
                        positions = JSON.parse(saved);
                    }
                    positions[title] = position;
                    SafeStorage.setItem('win95-window-positions', JSON.stringify(positions));
                } catch (e) {
                    console.warn('Failed to save window position:', e);
                }
            }

            // Cascade all windows (authentic Windows 95 feature)
            cascadeWindows() {
                const visibleWindows = this.windows.filter(w => !w.minimized);
                if (visibleWindows.length === 0) return;

                const startX = 30;
                const startY = 30;
                const offsetX = 30;
                const offsetY = 30;
                const defaultWidth = 500;
                const defaultHeight = 400;

                visibleWindows.forEach((win, index) => {
                    win.element.style.left = (startX + index * offsetX) + 'px';
                    win.element.style.top = (startY + index * offsetY) + 'px';
                    win.element.style.width = defaultWidth + 'px';
                    win.element.style.height = defaultHeight + 'px';
                    win.element.dataset.maximized = 'false';
                });

                // Focus the last window
                if (visibleWindows.length > 0) {
                    this.focusWindow(visibleWindows[visibleWindows.length - 1].element);
                }

                // Play window arrange sound
                if (this.desktop.playSoundEffect) {
                    this.desktop.playSoundEffect('maximize');
                }
            }

            // Tile windows horizontally
            tileHorizontally() {
                const visibleWindows = this.windows.filter(w => !w.minimized);
                if (visibleWindows.length === 0) return;

                const screenContainer = document.getElementById('screen_container');
                const containerWidth = screenContainer.offsetWidth;
                const containerHeight = screenContainer.offsetHeight - 30; // Account for taskbar

                const windowWidth = containerWidth / visibleWindows.length;
                const windowHeight = containerHeight;

                visibleWindows.forEach((win, index) => {
                    win.element.style.left = (index * windowWidth) + 'px';
                    win.element.style.top = '0px';
                    win.element.style.width = windowWidth + 'px';
                    win.element.style.height = windowHeight + 'px';
                    win.element.dataset.maximized = 'false';
                });

                // Play window arrange sound
                if (this.desktop.playSoundEffect) {
                    this.desktop.playSoundEffect('maximize');
                }
            }

            // Tile windows vertically
            tileVertically() {
                const visibleWindows = this.windows.filter(w => !w.minimized);
                if (visibleWindows.length === 0) return;

                const screenContainer = document.getElementById('screen_container');
                const containerWidth = screenContainer.offsetWidth;
                const containerHeight = screenContainer.offsetHeight - 30; // Account for taskbar

                const windowWidth = containerWidth;
                const windowHeight = containerHeight / visibleWindows.length;

                visibleWindows.forEach((win, index) => {
                    win.element.style.left = '0px';
                    win.element.style.top = (index * windowHeight) + 'px';
                    win.element.style.width = windowWidth + 'px';
                    win.element.style.height = windowHeight + 'px';
                    win.element.dataset.maximized = 'false';
                });

                // Play window arrange sound
                if (this.desktop.playSoundEffect) {
                    this.desktop.playSoundEffect('maximize');
                }
            }

            // Minimize all windows (show desktop)
            minimizeAllWindows() {
                this.windows.forEach(win => {
                    if (!win.minimized) {
                        this.minimizeWindow(win.element);
                    }
                });

                // Play minimize sound
                if (this.desktop.playSoundEffect) {
                    this.desktop.playSoundEffect('minimize');
                }
            }
        }

        class Windows95Emulator {
            constructor() {
                this.v86 = null;
                this.isRunning = false;
                this.isPaused = false;
                this.startTime = Date.now();
                this.frameCount = 0;
                this.lastFpsUpdate = 0;
                this.lastFrameTime = 0;
                this.hddLedTimeout = null;
                this.canvas = null;
                this.ctx = null;
                this.domCache = null;
                this.memoryUsage = 0;
                this.cpuUsage = 0;

                this.settings = {
                    memory: 32 * 1024 * 1024,
                    enableMouse: false,
                    enableSound: false,
                    enableNetwork: true,
                    cpuSpeed: 2
                };

                this.desktop = {
                    icons: [],
                    windows: []
                };

                this.windowManager = new WindowManager(this);
                this.taskbarButtons = [];

                this.initEmulatorCore();
                this.detectSystemInfo();
                this.initAudioContext();
            }

            // Audio system for games
            initAudioContext() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.warn('Web Audio API not supported');
                    this.audioContext = null;
                }
            }

            playSoundEffect(type) {
                if (!this.audioContext) return;

                const ctx = this.audioContext;
                const now = ctx.currentTime;

                switch(type) {
                    case 'flip':
                    case 'deal':
                        // Quick click sound
                        const flipOsc = ctx.createOscillator();
                        const flipGain = ctx.createGain();
                        flipOsc.connect(flipGain);
                        flipGain.connect(ctx.destination);
                        flipOsc.frequency.setValueAtTime(800, now);
                        flipOsc.frequency.exponentialRampToValueAtTime(600, now + 0.05);
                        flipGain.gain.setValueAtTime(0.1, now);
                        flipGain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
                        flipOsc.start(now);
                        flipOsc.stop(now + 0.05);
                        break;

                    case 'place':
                        // Satisfying placement sound
                        const placeOsc = ctx.createOscillator();
                        const placeGain = ctx.createGain();
                        placeOsc.connect(placeGain);
                        placeGain.connect(ctx.destination);
                        placeOsc.frequency.setValueAtTime(400, now);
                        placeOsc.frequency.exponentialRampToValueAtTime(200, now + 0.1);
                        placeGain.gain.setValueAtTime(0.15, now);
                        placeGain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                        placeOsc.start(now);
                        placeOsc.stop(now + 0.1);
                        break;

                    case 'invalid':
                        // Error buzz
                        const errOsc = ctx.createOscillator();
                        const errGain = ctx.createGain();
                        errOsc.connect(errGain);
                        errGain.connect(ctx.destination);
                        errOsc.type = 'square';
                        errOsc.frequency.setValueAtTime(150, now);
                        errGain.gain.setValueAtTime(0.08, now);
                        errGain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                        errOsc.start(now);
                        errOsc.stop(now + 0.1);
                        break;

                    case 'win':
                        // Victory fanfare
                        const notes = [523.25, 659.25, 783.99, 1046.50]; // C, E, G, C
                        notes.forEach((freq, i) => {
                            const osc = ctx.createOscillator();
                            const gain = ctx.createGain();
                            osc.connect(gain);
                            gain.connect(ctx.destination);
                            osc.frequency.setValueAtTime(freq, now + i * 0.15);
                            gain.gain.setValueAtTime(0.1, now + i * 0.15);
                            gain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.15 + 0.3);
                            osc.start(now + i * 0.15);
                            osc.stop(now + i * 0.15 + 0.3);
                        });
                        break;

                    case 'window-open':
                        // Window opening sound - ascending chirp
                        const openOsc = ctx.createOscillator();
                        const openGain = ctx.createGain();
                        openOsc.connect(openGain);
                        openGain.connect(ctx.destination);
                        openOsc.frequency.setValueAtTime(400, now);
                        openOsc.frequency.exponentialRampToValueAtTime(800, now + 0.08);
                        openGain.gain.setValueAtTime(0.08, now);
                        openGain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
                        openOsc.start(now);
                        openOsc.stop(now + 0.08);
                        break;

                    case 'window-close':
                        // Window closing sound - descending chirp
                        const closeOsc = ctx.createOscillator();
                        const closeGain = ctx.createGain();
                        closeOsc.connect(closeGain);
                        closeGain.connect(ctx.destination);
                        closeOsc.frequency.setValueAtTime(800, now);
                        closeOsc.frequency.exponentialRampToValueAtTime(400, now + 0.08);
                        closeGain.gain.setValueAtTime(0.08, now);
                        closeGain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
                        closeOsc.start(now);
                        closeOsc.stop(now + 0.08);
                        break;

                    case 'button-click':
                        // Button click sound - short tap
                        const btnOsc = ctx.createOscillator();
                        const btnGain = ctx.createGain();
                        btnOsc.connect(btnGain);
                        btnGain.connect(ctx.destination);
                        btnOsc.type = 'sine';
                        btnOsc.frequency.setValueAtTime(600, now);
                        btnGain.gain.setValueAtTime(0.05, now);
                        btnGain.gain.exponentialRampToValueAtTime(0.01, now + 0.03);
                        btnOsc.start(now);
                        btnOsc.stop(now + 0.03);
                        break;

                    case 'minimize':
                        // Minimize sound - quick descending tone
                        const minOsc = ctx.createOscillator();
                        const minGain = ctx.createGain();
                        minOsc.connect(minGain);
                        minGain.connect(ctx.destination);
                        minOsc.frequency.setValueAtTime(700, now);
                        minOsc.frequency.exponentialRampToValueAtTime(300, now + 0.1);
                        minGain.gain.setValueAtTime(0.07, now);
                        minGain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                        minOsc.start(now);
                        minOsc.stop(now + 0.1);
                        break;

                    case 'maximize':
                        // Maximize sound - expanding tone
                        const maxOsc = ctx.createOscillator();
                        const maxGain = ctx.createGain();
                        maxOsc.connect(maxGain);
                        maxGain.connect(ctx.destination);
                        maxOsc.frequency.setValueAtTime(500, now);
                        maxOsc.frequency.exponentialRampToValueAtTime(900, now + 0.1);
                        maxGain.gain.setValueAtTime(0.07, now);
                        maxGain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                        maxOsc.start(now);
                        maxOsc.stop(now + 0.1);
                        break;

                    case 'start-menu':
                        // Start menu sound - pleasant two-tone
                        const sm1 = ctx.createOscillator();
                        const sm2 = ctx.createOscillator();
                        const smGain = ctx.createGain();
                        sm1.connect(smGain);
                        sm2.connect(smGain);
                        smGain.connect(ctx.destination);
                        sm1.frequency.setValueAtTime(600, now);
                        sm2.frequency.setValueAtTime(800, now + 0.05);
                        smGain.gain.setValueAtTime(0.06, now);
                        smGain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
                        sm1.start(now);
                        sm1.stop(now + 0.06);
                        sm2.start(now + 0.05);
                        sm2.stop(now + 0.12);
                        break;
                }
            }

            // Programs
            openNotepad() {
                const content = document.createElement('div');
                content.style.cssText = 'display: flex; flex-direction: column; height: 100%;';

                // Menu bar
                const menuBar = document.createElement('div');
                menuBar.style.cssText = 'background: var(--button-face); padding: 2px; border-bottom: 1px solid var(--button-shadow); display: flex; gap: 2px;';
                menuBar.innerHTML = `
                    <button class="btn" onclick="emulator.notepadNew()">New</button>
                    <button class="btn" onclick="emulator.notepadSave()">Save</button>
                    <button class="btn" onclick="emulator.notepadLoad()">Load</button>
                    <button class="btn" onclick="emulator.notepadDownload()">Download</button>
                    <button class="btn" onclick="emulator.notepadUpload()">Upload File</button>
                `;

                // Textarea
                const textarea = document.createElement('textarea');
                textarea.id = 'notepad-textarea';
                textarea.style.cssText = 'flex: 1; border: none; font-family: "Courier New", monospace; font-size: 12px; padding: 4px; resize: none; outline: none; width: 100%; box-sizing: border-box;';

                // Load autosaved content
                const autosaved = SafeStorage.getItem('notepad-autosave');
                if (autosaved) {
                    textarea.value = autosaved;
                }

                // Autosave on input
                textarea.addEventListener('input', () => {
                    SafeStorage.setItem('notepad-autosave', textarea.value);
                });

                // File input (hidden)
                const fileInput = document.createElement('input');
                fileInput.type = 'file';
                fileInput.accept = '.txt';
                fileInput.style.display = 'none';
                fileInput.id = 'notepad-file-input';
                fileInput.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (event) => {
                            textarea.value = event.target.result;
                            SafeStorage.setItem('notepad-autosave', textarea.value);
                        };
                        reader.readAsText(file);
                    }
                });

                content.appendChild(menuBar);
                content.appendChild(textarea);
                content.appendChild(fileInput);

                this.notepadState = { currentFile: 'Untitled' };
                this.windowManager.createWindow('Untitled - Notepad', content, { width: 500, height: 400 });
            }

            notepadNew() {
                const textarea = document.getElementById('notepad-textarea');
                if (textarea) {
                    if (textarea.value && !confirm('Clear current document?')) {
                        return;
                    }
                    textarea.value = '';
                    SafeStorage.setItem('notepad-autosave', '');
                    this.notepadState.currentFile = 'Untitled';
                }
            }

            notepadSave() {
                const textarea = document.getElementById('notepad-textarea');
                if (textarea) {
                    const filename = prompt('Enter filename:', this.notepadState?.currentFile || 'document');
                    if (filename) {
                        SafeStorage.setItem('notepad-file-' + filename, textarea.value);
                        this.notepadState.currentFile = filename;
                        alert('Saved as: ' + filename);
                    }
                }
            }

            notepadLoad() {
                const filename = prompt('Enter filename to load:');
                if (filename) {
                    const content = SafeStorage.getItem('notepad-file-' + filename);
                    if (content !== null) {
                        const textarea = document.getElementById('notepad-textarea');
                        if (textarea) {
                            textarea.value = content;
                            SafeStorage.setItem('notepad-autosave', content);
                            this.notepadState.currentFile = filename;
                            alert('Loaded: ' + filename);
                        }
                    } else {
                        alert('File not found: ' + filename);
                    }
                }
            }

            notepadDownload() {
                const textarea = document.getElementById('notepad-textarea');
                if (textarea) {
                    const blob = new Blob([textarea.value], { type: 'text/plain' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = (this.notepadState?.currentFile || 'document') + '.txt';
                    a.click();
                    URL.revokeObjectURL(url);
                }
            }

            notepadUpload() {
                const fileInput = document.getElementById('notepad-file-input');
                if (fileInput) {
                    fileInput.click();
                }
            }

            openCalculator() {
                const content = document.createElement('div');
                content.innerHTML = `
                    <div style="padding: 10px;">
                        <div style="display: flex; gap: 5px; margin-bottom: 10px;">
                            <button class="btn" onclick="emulator.toggleCalcMode()" id="calc-mode-btn" style="font-size: 9px;">Scientific</button>
                            <input type="text" id="calc-display" readonly style="flex: 1; text-align: right; font-size: 18px; padding: 5px; border: 2px inset; background: white;" value="0">
                        </div>
                        <div id="calc-scientific" style="display: none; margin-bottom: 8px;">
                            <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 2px; margin-bottom: 4px;">
                                <button class="btn" onclick="emulator.calcFunction('Math.sqrt')" title="Square root">‚àö</button>
                                <button class="btn" onclick="emulator.calcFunction('Math.pow', 2)" title="Square">x¬≤</button>
                                <button class="btn" onclick="emulator.calcFunction('Math.pow', 3)" title="Cube">x¬≥</button>
                                <button class="btn" onclick="emulator.calcFunction('Math.sin')" title="Sine">sin</button>
                                <button class="btn" onclick="emulator.calcFunction('Math.cos')" title="Cosine">cos</button>
                            </div>
                            <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 2px;">
                                <button class="btn" onclick="emulator.calcFunction('Math.tan')" title="Tangent">tan</button>
                                <button class="btn" onclick="emulator.calcFunction('Math.log10')" title="Logarithm base 10">log</button>
                                <button class="btn" onclick="emulator.calcFunction('Math.log')" title="Natural logarithm">ln</button>
                                <button class="btn" onclick="emulator.calcConstant('Math.PI')" title="Pi">œÄ</button>
                                <button class="btn" onclick="emulator.calcConstant('Math.E')" title="Euler's number">e</button>
                            </div>
                        </div>
                        <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 2px;">
                            <button class="btn" onclick="emulator.calcInput('7')">7</button>
                            <button class="btn" onclick="emulator.calcInput('8')">8</button>
                            <button class="btn" onclick="emulator.calcInput('9')">9</button>
                            <button class="btn" onclick="emulator.calcInput('/')">/</button>
                            <button class="btn" onclick="emulator.calcInput('4')">4</button>
                            <button class="btn" onclick="emulator.calcInput('5')">5</button>
                            <button class="btn" onclick="emulator.calcInput('6')">6</button>
                            <button class="btn" onclick="emulator.calcInput('*')">*</button>
                            <button class="btn" onclick="emulator.calcInput('1')">1</button>
                            <button class="btn" onclick="emulator.calcInput('2')">2</button>
                            <button class="btn" onclick="emulator.calcInput('3')">3</button>
                            <button class="btn" onclick="emulator.calcInput('-')">-</button>
                            <button class="btn" onclick="emulator.calcInput('0')" style="grid-column: span 2;">0</button>
                            <button class="btn" onclick="emulator.calcInput('.')">.</button>
                            <button class="btn" onclick="emulator.calcInput('+')">+</button>
                            <button class="btn" onclick="emulator.calcBackspace()" title="Backspace">‚Üê</button>
                            <button class="btn" onclick="emulator.calcInput('(')">(</button>
                            <button class="btn" onclick="emulator.calcInput(')')">)</button>
                            <button class="btn primary" onclick="emulator.calcEquals()">=</button>
                            <button class="btn" onclick="emulator.calcClear()" style="grid-column: span 4;">C</button>
                        </div>
                    </div>
                `;
                this.windowManager.createWindow('Calculator', content, { width: 280, height: 420 });
                this.calcExpression = '';
                this.calcScientificMode = false;
            }

            calcInput(value) {
                const display = document.getElementById('calc-display');
                if (display) {
                    if (this.calcExpression === '' || this.calcExpression === '0') {
                        this.calcExpression = value;
                    } else {
                        this.calcExpression += value;
                    }
                    display.value = this.calcExpression;
                }
            }

            calcEquals() {
                const display = document.getElementById('calc-display');
                if (display && this.calcExpression) {
                    try {
                        const result = eval(this.calcExpression);
                        display.value = result;
                        this.calcExpression = result.toString();
                    } catch (e) {
                        display.value = 'Error';
                        this.calcExpression = '';
                    }
                }
            }

            calcClear() {
                const display = document.getElementById('calc-display');
                if (display) {
                    display.value = '0';
                    this.calcExpression = '';
                }
            }

            toggleCalcMode() {
                this.calcScientificMode = !this.calcScientificMode;
                const scientificDiv = document.getElementById('calc-scientific');
                const modeBtn = document.getElementById('calc-mode-btn');
                if (scientificDiv && modeBtn) {
                    scientificDiv.style.display = this.calcScientificMode ? 'block' : 'none';
                    modeBtn.textContent = this.calcScientificMode ? 'Standard' : 'Scientific';
                }
            }

            calcBackspace() {
                const display = document.getElementById('calc-display');
                if (display && this.calcExpression.length > 0) {
                    this.calcExpression = this.calcExpression.slice(0, -1);
                    display.value = this.calcExpression || '0';
                }
            }

            calcFunction(func, param) {
                const display = document.getElementById('calc-display');
                if (display) {
                    try {
                        let value = this.calcExpression ? eval(this.calcExpression) : 0;
                        let result;
                        if (param !== undefined) {
                            // Functions with parameters like pow
                            result = eval(`${func}(${value}, ${param})`);
                        } else {
                            // Single parameter functions
                            result = eval(`${func}(${value})`);
                        }
                        display.value = result;
                        this.calcExpression = result.toString();
                    } catch (e) {
                        display.value = 'Error';
                        this.calcExpression = '';
                    }
                }
            }

            calcConstant(constant) {
                const display = document.getElementById('calc-display');
                if (display) {
                    const value = eval(constant);
                    this.calcExpression = value.toString();
                    display.value = this.calcExpression;
                }
            }

            openMinesweeper() {
                // Show difficulty selection dialog
                const difficultyDialog = document.createElement('div');
                difficultyDialog.style.cssText = 'padding: 20px; text-align: center;';
                difficultyDialog.innerHTML = `
                    <h3 style="margin-top: 0;">Select Difficulty</h3>
                    <div style="display: flex; flex-direction: column; gap: 10px; margin: 20px 0;">
                        <button class="btn primary" onclick="emulator.startMinesweeper('easy')" style="padding: 12px;">Easy (8x8, 10 mines)</button>
                        <button class="btn primary" onclick="emulator.startMinesweeper('medium')" style="padding: 12px;">Medium (16x16, 40 mines)</button>
                        <button class="btn primary" onclick="emulator.startMinesweeper('hard')" style="padding: 12px;">Hard (24x24, 99 mines)</button>
                    </div>
                    <div style="margin-top: 20px; padding: 10px; background: #f0f0f0; border: 1px solid #808080; text-align: left; font-size: 11px;">
                        <strong>Statistics:</strong><br>
                        Easy - Wins: <span id="stats-easy-wins">0</span> | Best: <span id="stats-easy-time">-</span><br>
                        Medium - Wins: <span id="stats-medium-wins">0</span> | Best: <span id="stats-medium-time">-</span><br>
                        Hard - Wins: <span id="stats-hard-wins">0</span> | Best: <span id="stats-hard-time">-</span>
                    </div>
                `;

                // Load and display stats
                const stats = this.loadMinesweeperStats();
                setTimeout(() => {
                    ['easy', 'medium', 'hard'].forEach(diff => {
                        const winsEl = document.getElementById(`stats-${diff}-wins`);
                        const timeEl = document.getElementById(`stats-${diff}-time`);
                        if (winsEl) winsEl.textContent = stats[diff].wins;
                        if (timeEl) timeEl.textContent = stats[diff].bestTime ? `${stats[diff].bestTime}s` : '-';
                    });
                }, 50);

                this.windowManager.createWindow('Minesweeper', difficultyDialog, { width: 400, height: 360 });
            }

            loadMinesweeperStats() {
                const saved = SafeStorage.getItem('win95-minesweeper-stats');
                if (saved) {
                    try {
                        return JSON.parse(saved);
                    } catch (e) {
                        return this.getDefaultMinesweeperStats();
                    }
                }
                return this.getDefaultMinesweeperStats();
            }

            getDefaultMinesweeperStats() {
                return {
                    easy: { wins: 0, losses: 0, bestTime: null },
                    medium: { wins: 0, losses: 0, bestTime: null },
                    hard: { wins: 0, losses: 0, bestTime: null }
                };
            }

            saveMinesweeperStats(stats) {
                SafeStorage.setItem('win95-minesweeper-stats', JSON.stringify(stats));
            }

            startMinesweeper(difficulty) {
                const configs = {
                    easy: { rows: 8, cols: 8, mines: 10 },
                    medium: { rows: 16, cols: 16, mines: 40 },
                    hard: { rows: 24, cols: 24, mines: 99 }
                };

                const config = configs[difficulty];
                const content = document.createElement('div');
                let board = this.createMinesweeperBoard(config.rows, config.cols, config.mines);
                let gameStarted = false;
                let gameOver = false;
                let startTime = null;
                let timerInterval = null;
                let flagCount = 0;

                content.innerHTML = `
                    <div style="padding: 10px; text-align: center;">
                        <div style="background: var(--button-face); padding: 8px; margin-bottom: 10px; border: 2px inset; display: flex; justify-content: space-between; align-items: center;">
                            <div><strong>üí£ ${config.mines}</strong></div>
                            <div><strong>üö© <span id="flag-count">0</span></strong></div>
                            <div><strong>‚è±Ô∏è <span id="timer">0</span>s</strong></div>
                            <button class="btn" onclick="emulator.startMinesweeper('${difficulty}')" style="padding: 4px 8px;">New Game</button>
                        </div>
                        <div id="minesweeper-board" style="display: inline-grid; grid-template-columns: repeat(${config.cols}, 22px); gap: 0; border: 2px outset var(--button-face);"></div>
                    </div>
                `;

                const boardEl = content.querySelector('#minesweeper-board');
                const flagCountEl = content.querySelector('#flag-count');
                const timerEl = content.querySelector('#timer');

                board.forEach((row, r) => {
                    row.forEach((cell, c) => {
                        const cellBtn = document.createElement('button');
                        cellBtn.className = 'btn';
                        cellBtn.style.cssText = 'width: 22px; height: 22px; padding: 0; font-size: 10px; font-weight: bold;';
                        cellBtn.dataset.row = r;
                        cellBtn.dataset.col = c;

                        cellBtn.onclick = () => {
                            if (!gameStarted) {
                                gameStarted = true;
                                startTime = Date.now();
                                timerInterval = setInterval(() => {
                                    if (!gameOver) {
                                        const elapsed = Math.floor((Date.now() - startTime) / 1000);
                                        timerEl.textContent = elapsed;
                                    }
                                }, 1000);
                            }
                            if (!gameOver) {
                                this.revealMinesweeperCell(boardEl, board, r, c, config, difficulty, timerInterval, () => {
                                    gameOver = true;
                                    clearInterval(timerInterval);
                                    const elapsed = Math.floor((Date.now() - startTime) / 1000);
                                    this.updateMinesweeperStats(difficulty, true, elapsed);
                                }, () => {
                                    gameOver = true;
                                    clearInterval(timerInterval);
                                    this.updateMinesweeperStats(difficulty, false, null);
                                });
                            }
                        };

                        cellBtn.oncontextmenu = (e) => {
                            e.preventDefault();
                            if (!gameOver && !cellBtn.disabled) {
                                if (cellBtn.textContent === 'üö©') {
                                    cellBtn.textContent = '';
                                    flagCount--;
                                } else if (cellBtn.textContent === '') {
                                    cellBtn.textContent = 'üö©';
                                    flagCount++;
                                }
                                flagCountEl.textContent = flagCount;
                            }
                            return false;
                        };

                        boardEl.appendChild(cellBtn);
                    });
                });

                const width = Math.max(320, config.cols * 22 + 40);
                const height = Math.max(380, config.rows * 22 + 100);
                this.windowManager.createWindow(`Minesweeper - ${difficulty.charAt(0).toUpperCase() + difficulty.slice(1)}`, content, { width, height });
            }

            updateMinesweeperStats(difficulty, won, time) {
                const stats = this.loadMinesweeperStats();
                if (won) {
                    stats[difficulty].wins++;
                    if (!stats[difficulty].bestTime || time < stats[difficulty].bestTime) {
                        stats[difficulty].bestTime = time;
                    }
                } else {
                    stats[difficulty].losses++;
                }
                this.saveMinesweeperStats(stats);
            }

            createMinesweeperBoard(rows, cols, mines) {
                const board = Array(rows).fill().map(() => Array(cols).fill(0));
                let placedMines = 0;

                while (placedMines < mines) {
                    const r = Math.floor(Math.random() * rows);
                    const c = Math.floor(Math.random() * cols);
                    if (board[r][c] !== -1) {
                        board[r][c] = -1;
                        placedMines++;

                        for (let dr = -1; dr <= 1; dr++) {
                            for (let dc = -1; dc <= 1; dc++) {
                                const nr = r + dr, nc = c + dc;
                                if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && board[nr][nc] !== -1) {
                                    board[nr][nc]++;
                                }
                            }
                        }
                    }
                }
                return board;
            }

            revealMinesweeperCell(boardEl, board, row, col, config, difficulty, timerInterval, onWin, onLoss) {
                const cellBtn = boardEl.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                if (!cellBtn || cellBtn.disabled || cellBtn.textContent === 'üö©') return;

                const value = board[row][col];
                cellBtn.disabled = true;
                cellBtn.style.background = '#c0c0c0';
                cellBtn.style.borderStyle = 'solid';

                if (value === -1) {
                    // Hit a mine - game over
                    cellBtn.textContent = 'üí£';
                    cellBtn.style.background = 'red';

                    // Reveal all mines
                    const allCells = boardEl.querySelectorAll('button');
                    allCells.forEach(btn => {
                        const r = parseInt(btn.dataset.row);
                        const c = parseInt(btn.dataset.col);
                        if (board[r][c] === -1) {
                            btn.textContent = 'üí£';
                            btn.disabled = true;
                            btn.style.background = '#c0c0c0';
                        }
                    });

                    setTimeout(() => {
                        alert('Game Over! You hit a mine!');
                        onLoss();
                    }, 100);
                } else if (value === 0) {
                    cellBtn.textContent = '';
                    // Auto-reveal adjacent cells
                    for (let dr = -1; dr <= 1; dr++) {
                        for (let dc = -1; dc <= 1; dc++) {
                            const nr = row + dr, nc = col + dc;
                            if (nr >= 0 && nr < config.rows && nc >= 0 && nc < config.cols) {
                                this.revealMinesweeperCellSimple(boardEl, board, nr, nc);
                            }
                        }
                    }
                    // Check for win after revealing
                    this.checkMinesweeperWin(boardEl, board, config, onWin);
                } else {
                    const colors = ['', 'blue', 'green', 'red', 'purple', 'maroon', 'turquoise', 'black', 'gray'];
                    cellBtn.textContent = value;
                    cellBtn.style.color = colors[value];
                    // Check for win
                    this.checkMinesweeperWin(boardEl, board, config, onWin);
                }
            }

            revealMinesweeperCellSimple(boardEl, board, row, col) {
                const cellBtn = boardEl.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                if (!cellBtn || cellBtn.disabled || cellBtn.textContent === 'üö©') return;

                const value = board[row][col];
                cellBtn.disabled = true;
                cellBtn.style.background = '#c0c0c0';
                cellBtn.style.borderStyle = 'solid';

                if (value === 0) {
                    cellBtn.textContent = '';
                    // Auto-reveal adjacent cells
                    for (let dr = -1; dr <= 1; dr++) {
                        for (let dc = -1; dc <= 1; dc++) {
                            const nr = row + dr, nc = col + dc;
                            if (nr >= 0 && nr < board.length && nc >= 0 && nc < board[0].length) {
                                this.revealMinesweeperCellSimple(boardEl, board, nr, nc);
                            }
                        }
                    }
                } else if (value > 0) {
                    const colors = ['', 'blue', 'green', 'red', 'purple', 'maroon', 'turquoise', 'black', 'gray'];
                    cellBtn.textContent = value;
                    cellBtn.style.color = colors[value];
                }
            }

            checkMinesweeperWin(boardEl, board, config, onWin) {
                const allCells = boardEl.querySelectorAll('button');
                let revealedCount = 0;
                let totalCells = config.rows * config.cols;

                allCells.forEach(btn => {
                    if (btn.disabled && btn.textContent !== 'üí£') {
                        revealedCount++;
                    }
                });

                // Win if all non-mine cells are revealed
                if (revealedCount === totalCells - config.mines) {
                    setTimeout(() => {
                        alert('üéâ Congratulations! You won!');
                        onWin();
                    }, 100);
                }
            }

            revealCell(boardEl, board, row, col) {
                const cellBtn = boardEl.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                if (!cellBtn || cellBtn.disabled || cellBtn.textContent === 'üö©') return;

                const value = board[row][col];
                cellBtn.disabled = true;
                cellBtn.style.background = '#c0c0c0';
                cellBtn.style.borderStyle = 'solid';

                if (value === -1) {
                    cellBtn.textContent = 'üí£';
                    alert('Game Over! You hit a mine!');
                } else if (value === 0) {
                    cellBtn.textContent = '';
                    // Auto-reveal adjacent cells
                    for (let dr = -1; dr <= 1; dr++) {
                        for (let dc = -1; dc <= 1; dc++) {
                            this.revealCell(boardEl, board, row + dr, col + dc);
                        }
                    }
                } else {
                    const colors = ['', 'blue', 'green', 'red', 'purple', 'maroon', 'turquoise', 'black', 'gray'];
                    cellBtn.textContent = value;
                    cellBtn.style.color = colors[value];
                }
            }

            toggleFlag(cellBtn) {
                if (cellBtn.disabled) return;
                const flagCount = document.getElementById('flag-count');
                if (cellBtn.textContent === 'üö©') {
                    cellBtn.textContent = '';
                    if (flagCount) flagCount.textContent = parseInt(flagCount.textContent) - 1;
                } else {
                    cellBtn.textContent = 'üö©';
                    if (flagCount) flagCount.textContent = parseInt(flagCount.textContent) + 1;
                }
            }

            openInternetExplorer() {
                const content = document.createElement('div');
                content.style.cssText = 'display: flex; flex-direction: column; height: 100%; overflow: hidden;';

                // Create IE toolbar
                const toolbar = document.createElement('div');
                toolbar.style.cssText = 'background: var(--button-face); padding: 2px; border-bottom: 1px solid var(--button-shadow); display: flex; gap: 2px; align-items: center;';
                toolbar.innerHTML = `
                    <button class="btn" onclick="emulator.ieNavigate('back')" title="Back">‚óÄ</button>
                    <button class="btn" onclick="emulator.ieNavigate('forward')" title="Forward">‚ñ∂</button>
                    <button class="btn" onclick="emulator.ieNavigate('refresh')" title="Refresh">üîÑ</button>
                    <button class="btn" onclick="emulator.ieNavigate('home')" title="Home">üè†</button>
                    <button class="btn" onclick="emulator.ieNavigate('stop')" title="Stop">‚èπ</button>
                    <div style="flex: 1; display: flex; align-items: center; gap: 4px; margin-left: 4px;">
                        <span style="font-size: 11px; font-weight: bold;">Address:</span>
                        <input type="text" id="ie-address-bar" value="https://example.com"
                            style="flex: 1; padding: 2px 4px; border: 1px solid var(--button-shadow); font-size: 11px;"
                            onkeypress="if(event.key==='Enter') emulator.ieNavigate('go')">
                        <button class="btn" onclick="emulator.ieNavigate('go')">Go</button>
                    </div>
                `;

                // Create status bar
                const statusBar = document.createElement('div');
                statusBar.style.cssText = 'background: var(--button-face); border-top: 1px solid var(--button-highlight); padding: 2px 4px; font-size: 11px; display: flex; align-items: center; gap: 8px;';
                statusBar.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 4px;">
                        <div class="led" id="ie-status-led"></div>
                        <span id="ie-status-text">Ready</span>
                    </div>
                    <div style="flex: 1;"></div>
                    <span style="font-size: 10px;">Internet zone</span>
                `;

                // Create iframe container
                const iframeContainer = document.createElement('div');
                iframeContainer.style.cssText = 'flex: 1; background: white; position: relative; overflow: hidden;';

                const iframe = document.createElement('iframe');
                iframe.id = 'ie-browser-frame';
                iframe.src = 'https://example.com';
                iframe.style.cssText = 'width: 100%; height: 100%; border: none;';
                iframe.sandbox = 'allow-same-origin allow-scripts allow-forms allow-popups allow-popups-to-escape-sandbox';

                // Loading indicator
                const loadingDiv = document.createElement('div');
                loadingDiv.id = 'ie-loading';
                loadingDiv.style.cssText = 'position: absolute; top: 0; left: 0; right: 0; background: #ffffcc; padding: 4px 8px; font-size: 11px; border-bottom: 1px solid #808080; display: none;';
                loadingDiv.innerHTML = '‚è≥ Loading page...';

                iframeContainer.appendChild(loadingDiv);
                iframeContainer.appendChild(iframe);

                // Assemble the browser
                content.appendChild(toolbar);
                content.appendChild(iframeContainer);
                content.appendChild(statusBar);

                // Create window
                const win = this.windowManager.createWindow('Internet Explorer', content, {
                    width: 600,
                    height: 500,
                    x: 50,
                    y: 50
                });

                // Store current window ID for navigation
                this.currentIEWindowId = win.id;

                // Setup iframe event listeners
                iframe.addEventListener('load', () => {
                    const led = document.getElementById('ie-status-led');
                    const statusText = document.getElementById('ie-status-text');
                    const loading = document.getElementById('ie-loading');

                    if (led) led.classList.remove('active');
                    if (statusText) statusText.textContent = 'Done';
                    if (loading) loading.style.display = 'none';

                    // Try to update address bar with current URL (won't work for cross-origin)
                    try {
                        const addressBar = document.getElementById('ie-address-bar');
                        if (addressBar && iframe.contentWindow) {
                            addressBar.value = iframe.contentWindow.location.href;
                        }
                    } catch (e) {
                        // Cross-origin, can't access
                    }
                });

                // Show loading state
                const led = document.getElementById('ie-status-led');
                const statusText = document.getElementById('ie-status-text');
                const loading = document.getElementById('ie-loading');
                if (led) led.classList.add('active');
                if (statusText) statusText.textContent = 'Loading...';
                if (loading) loading.style.display = 'block';
            }

            ieNavigate(action) {
                const iframe = document.getElementById('ie-browser-frame');
                const addressBar = document.getElementById('ie-address-bar');
                const led = document.getElementById('ie-status-led');
                const statusText = document.getElementById('ie-status-text');
                const loading = document.getElementById('ie-loading');

                if (!iframe) return;

                try {
                    switch (action) {
                        case 'back':
                            window.history.back();
                            break;
                        case 'forward':
                            window.history.forward();
                            break;
                        case 'refresh':
                            iframe.src = iframe.src;
                            if (led) led.classList.add('active');
                            if (statusText) statusText.textContent = 'Refreshing...';
                            if (loading) loading.style.display = 'block';
                            break;
                        case 'home':
                            iframe.src = 'https://example.com';
                            if (addressBar) addressBar.value = 'https://example.com';
                            if (led) led.classList.add('active');
                            if (statusText) statusText.textContent = 'Loading home page...';
                            if (loading) loading.style.display = 'block';
                            break;
                        case 'stop':
                            iframe.src = '';
                            if (led) led.classList.remove('active');
                            if (statusText) statusText.textContent = 'Stopped';
                            if (loading) loading.style.display = 'none';
                            break;
                        case 'go':
                            if (addressBar) {
                                let url = addressBar.value.trim();

                                // Add protocol if missing
                                if (!url.startsWith('http://') && !url.startsWith('https://')) {
                                    url = 'https://' + url;
                                }

                                iframe.src = url;
                                if (led) led.classList.add('active');
                                if (statusText) statusText.textContent = 'Connecting...';
                                if (loading) loading.style.display = 'block';
                            }
                            break;
                    }
                } catch (error) {
                    console.error('Navigation error:', error);
                    if (statusText) statusText.textContent = 'Error loading page';
                    if (led) led.classList.remove('active');
                    if (loading) loading.style.display = 'none';
                }
            }

            openPaint() {
                const content = document.createElement('div');
                content.style.cssText = 'display: flex; flex-direction: column; height: 100%; overflow: hidden;';

                // Paint toolbar
                const toolbar = document.createElement('div');
                toolbar.style.cssText = 'background: var(--button-face); padding: 2px; border-bottom: 1px solid var(--button-shadow); display: flex; gap: 2px; flex-wrap: wrap;';
                toolbar.innerHTML = `
                    <button class="btn" id="tool-pencil" title="Pencil" onclick="emulator.paintSetTool('pencil')" style="background: #e0e0e0;">‚úèÔ∏è</button>
                    <button class="btn" id="tool-brush" title="Brush" onclick="emulator.paintSetTool('brush')">üñåÔ∏è</button>
                    <button class="btn" id="tool-spray" title="Spray Paint" onclick="emulator.paintSetTool('spray')">üí®</button>
                    <button class="btn" id="tool-line" title="Line" onclick="emulator.paintSetTool('line')">üìè</button>
                    <button class="btn" id="tool-rect" title="Rectangle" onclick="emulator.paintSetTool('rect')">‚ñ≠</button>
                    <button class="btn" id="tool-filled-rect" title="Filled Rectangle" onclick="emulator.paintSetTool('filled-rect')">‚óºÔ∏è</button>
                    <button class="btn" id="tool-circle" title="Circle" onclick="emulator.paintSetTool('circle')">‚óã</button>
                    <button class="btn" id="tool-filled-circle" title="Filled Circle" onclick="emulator.paintSetTool('filled-circle')">‚¨§</button>
                    <button class="btn" id="tool-fill" title="Fill" onclick="emulator.paintSetTool('fill')">ü™£</button>
                    <button class="btn" id="tool-eraser" title="Eraser" onclick="emulator.paintSetTool('eraser')">üßπ</button>
                    <button class="btn" onclick="emulator.paintClear()">Clear</button>
                    <button class="btn" onclick="emulator.paintSave()">üíæ Save</button>
                    <div style="display: flex; gap: 2px; align-items: center; margin-left: auto;">
                        <span style="font-size: 11px;">Color:</span>
                        <input type="color" id="paint-color" value="#000000" style="width: 40px; height: 22px; border: 1px solid var(--button-shadow);">
                        <span style="font-size: 11px;">Size:</span>
                        <input type="range" id="paint-size" min="1" max="30" value="3" style="width: 80px;">
                        <span id="paint-size-display" style="font-size: 11px; min-width: 25px;">3px</span>
                    </div>
                `;

                // Canvas container
                const canvasContainer = document.createElement('div');
                canvasContainer.style.cssText = 'flex: 1; background: white; overflow: auto; position: relative;';

                const canvas = document.createElement('canvas');
                canvas.id = 'paint-canvas';
                canvas.width = 640;
                canvas.height = 480;
                canvas.style.cssText = 'display: block; cursor: crosshair; background: white;';

                canvasContainer.appendChild(canvas);
                content.appendChild(toolbar);
                content.appendChild(canvasContainer);

                this.windowManager.createWindow('Paint', content, { width: 680, height: 560 });

                // Initialize paint
                this.initPaint(canvas);
            }

            initPaint(canvas) {
                const ctx = canvas.getContext('2d');
                let isDrawing = false;
                let startX, startY;
                let currentTool = 'pencil';
                let tempCanvas = document.createElement('canvas');
                tempCanvas.width = canvas.width;
                tempCanvas.height = canvas.height;

                // Initialize white background
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                this.paintSetTool = (tool) => {
                    currentTool = tool;
                    // Highlight selected tool
                    document.querySelectorAll('[id^="tool-"]').forEach(btn => {
                        btn.style.background = '';
                    });
                    const toolBtn = document.getElementById(`tool-${tool}`);
                    if (toolBtn) toolBtn.style.background = '#e0e0e0';
                };

                this.paintClear = () => {
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                };

                this.paintSave = () => {
                    const dataURL = canvas.toDataURL('image/png');
                    const link = document.createElement('a');
                    link.download = 'paint-' + Date.now() + '.png';
                    link.href = dataURL;
                    link.click();
                };

                // Update size display
                const sizeInput = document.getElementById('paint-size');
                const sizeDisplay = document.getElementById('paint-size-display');
                if (sizeInput && sizeDisplay) {
                    sizeInput.addEventListener('input', (e) => {
                        sizeDisplay.textContent = e.target.value + 'px';
                    });
                }

                canvas.addEventListener('mousedown', (e) => {
                    isDrawing = true;
                    const rect = canvas.getBoundingClientRect();
                    startX = e.clientX - rect.left;
                    startY = e.clientY - rect.top;

                    // Save current canvas state
                    tempCanvas.getContext('2d').drawImage(canvas, 0, 0);

                    const colorInput = document.getElementById('paint-color');
                    const sizeInput = document.getElementById('paint-size');
                    if (colorInput) ctx.strokeStyle = colorInput.value;
                    if (colorInput) ctx.fillStyle = colorInput.value;
                    if (sizeInput) ctx.lineWidth = parseInt(sizeInput.value);
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';

                    if (currentTool === 'pencil' || currentTool === 'brush') {
                        ctx.beginPath();
                        ctx.moveTo(startX, startY);
                    }
                });

                canvas.addEventListener('mousemove', (e) => {
                    if (!isDrawing) return;

                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;

                    if (currentTool === 'pencil' || currentTool === 'brush') {
                        ctx.lineTo(x, y);
                        ctx.stroke();
                    } else if (currentTool === 'spray') {
                        // Spray paint effect
                        const density = ctx.lineWidth * 2;
                        for (let i = 0; i < density; i++) {
                            const offsetX = (Math.random() - 0.5) * ctx.lineWidth * 2;
                            const offsetY = (Math.random() - 0.5) * ctx.lineWidth * 2;
                            ctx.fillRect(x + offsetX, y + offsetY, 1, 1);
                        }
                    } else if (currentTool === 'eraser') {
                        ctx.clearRect(x - ctx.lineWidth/2, y - ctx.lineWidth/2, ctx.lineWidth, ctx.lineWidth);
                    } else {
                        // For shapes, restore canvas and draw preview
                        ctx.putImageData(tempCanvas.getContext('2d').getImageData(0, 0, canvas.width, canvas.height), 0, 0);

                        if (currentTool === 'line') {
                            ctx.beginPath();
                            ctx.moveTo(startX, startY);
                            ctx.lineTo(x, y);
                            ctx.stroke();
                        } else if (currentTool === 'rect') {
                            ctx.strokeRect(startX, startY, x - startX, y - startY);
                        } else if (currentTool === 'filled-rect') {
                            ctx.fillRect(startX, startY, x - startX, y - startY);
                        } else if (currentTool === 'circle') {
                            const radius = Math.sqrt(Math.pow(x - startX, 2) + Math.pow(y - startY, 2));
                            ctx.beginPath();
                            ctx.arc(startX, startY, radius, 0, Math.PI * 2);
                            ctx.stroke();
                        } else if (currentTool === 'filled-circle') {
                            const radius = Math.sqrt(Math.pow(x - startX, 2) + Math.pow(y - startY, 2));
                            ctx.beginPath();
                            ctx.arc(startX, startY, radius, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                });

                canvas.addEventListener('mouseup', (e) => {
                    if (!isDrawing) return;
                    isDrawing = false;

                    const rect = canvas.getBoundingClientRect();
                    const x = Math.floor(e.clientX - rect.left);
                    const y = Math.floor(e.clientY - rect.top);

                    if (currentTool === 'fill') {
                        // Flood fill algorithm
                        const colorInput = document.getElementById('paint-color');
                        if (!colorInput) return;

                        const fillColor = this.hexToRgb(colorInput.value);
                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        const targetColor = this.getPixelColor(imageData, x, y);

                        // Don't fill if target color is same as fill color
                        if (this.colorsMatch(targetColor, fillColor)) return;

                        this.floodFill(imageData, x, y, targetColor, fillColor, canvas.width, canvas.height);
                        ctx.putImageData(imageData, 0, 0);
                    }
                });

                canvas.addEventListener('mouseleave', () => {
                    isDrawing = false;
                });

                // Clear canvas initially
                this.paintClear();
            }

            // Paint helper functions
            hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16),
                    a: 255
                } : null;
            }

            getPixelColor(imageData, x, y) {
                const index = (y * imageData.width + x) * 4;
                return {
                    r: imageData.data[index],
                    g: imageData.data[index + 1],
                    b: imageData.data[index + 2],
                    a: imageData.data[index + 3]
                };
            }

            setPixelColor(imageData, x, y, color) {
                const index = (y * imageData.width + x) * 4;
                imageData.data[index] = color.r;
                imageData.data[index + 1] = color.g;
                imageData.data[index + 2] = color.b;
                imageData.data[index + 3] = color.a;
            }

            colorsMatch(a, b) {
                return a.r === b.r && a.g === b.g && a.b === b.b && a.a === b.a;
            }

            floodFill(imageData, x, y, targetColor, fillColor, width, height) {
                // Stack-based flood fill to avoid recursion stack overflow
                const stack = [[x, y]];
                const visited = new Set();

                while (stack.length > 0) {
                    const [cx, cy] = stack.pop();
                    const key = `${cx},${cy}`;

                    if (visited.has(key)) continue;
                    if (cx < 0 || cx >= width || cy < 0 || cy >= height) continue;

                    visited.add(key);

                    const currentColor = this.getPixelColor(imageData, cx, cy);
                    if (!this.colorsMatch(currentColor, targetColor)) continue;

                    this.setPixelColor(imageData, cx, cy, fillColor);

                    // Add neighboring pixels
                    stack.push([cx + 1, cy]);
                    stack.push([cx - 1, cy]);
                    stack.push([cx, cy + 1]);
                    stack.push([cx, cy - 1]);
                }
            }

            openFileExplorer() {
                const content = document.createElement('div');
                content.style.cssText = 'display: flex; flex-direction: column; height: 100%; overflow: hidden;';

                // Toolbar
                const toolbar = document.createElement('div');
                toolbar.style.cssText = 'background: var(--button-face); padding: 2px; border-bottom: 1px solid var(--button-shadow); display: flex; gap: 2px; align-items: center;';
                toolbar.innerHTML = `
                    <button class="btn" onclick="emulator.explorerNavigate('back')" title="Back">‚óÄ</button>
                    <button class="btn" onclick="emulator.explorerNavigate('up')" title="Up">‚¨Ü</button>
                    <div style="flex: 1; margin: 0 4px; padding: 2px 4px; border: 1px solid var(--button-shadow); background: white; font-size: 11px;" id="explorer-path">
                        C:\\
                    </div>
                `;

                // Main container with splitter
                const mainContainer = document.createElement('div');
                mainContainer.style.cssText = 'display: flex; flex: 1; overflow: hidden;';

                // Tree view (left panel)
                const treePanel = document.createElement('div');
                treePanel.id = 'explorer-tree';
                treePanel.style.cssText = 'width: 200px; background: white; border-right: 1px solid #808080; border-top: 2px inset; overflow-y: auto; font-size: 11px; padding: 4px;';

                // Content area (right panel)
                const contentArea = document.createElement('div');
                contentArea.id = 'explorer-content';
                contentArea.style.cssText = 'flex: 1; background: white; padding: 8px; overflow: auto; border-top: 2px inset;';

                mainContainer.appendChild(treePanel);
                mainContainer.appendChild(contentArea);

                content.appendChild(toolbar);
                content.appendChild(mainContainer);

                this.windowManager.createWindow('Windows Explorer', content, { width: 600, height: 450 });

                this.initFileExplorer();
            }

            initFileExplorer() {
                this.fileSystem = {
                    'C:\\': {
                        type: 'folder',
                        contents: {
                            'Windows': { type: 'folder', contents: {} },
                            'Program Files': { type: 'folder', contents: {} },
                            'My Documents': {
                                type: 'folder',
                                contents: {
                                    'readme.txt': { type: 'file', size: '1 KB' },
                                    'notes.txt': { type: 'file', size: '2 KB' }
                                }
                            },
                            'autoexec.bat': { type: 'file', size: '156 bytes' },
                            'config.sys': { type: 'file', size: '89 bytes' }
                        }
                    }
                };

                this.currentPath = 'C:\\';
                this.explorerHistory = ['C:\\'];
                this.explorerHistoryIndex = 0;

                this.explorerNavigate = (action) => {
                    if (action === 'back' && this.explorerHistoryIndex > 0) {
                        this.explorerHistoryIndex--;
                        this.currentPath = this.explorerHistory[this.explorerHistoryIndex];
                        this.renderExplorer();
                    } else if (action === 'up') {
                        const parts = this.currentPath.split('\\').filter(p => p);
                        if (parts.length > 1) {
                            parts.pop();
                            this.currentPath = parts.join('\\') + '\\';
                            if (!this.currentPath.includes(':\\')) {
                                this.currentPath = parts[0] + ':\\' + this.currentPath.split(':\\')[1];
                            }
                            this.addToHistory(this.currentPath);
                            this.renderExplorer();
                        }
                    }
                };

                this.explorerOpenFolder = (name) => {
                    this.currentPath = this.currentPath + name + '\\';
                    this.addToHistory(this.currentPath);
                    this.renderExplorer();
                };

                this.addToHistory = (path) => {
                    this.explorerHistory = this.explorerHistory.slice(0, this.explorerHistoryIndex + 1);
                    this.explorerHistory.push(path);
                    this.explorerHistoryIndex = this.explorerHistory.length - 1;
                };

                this.renderExplorer();
                this.buildExplorerTree();
            }

            buildExplorerTree() {
                const treePanel = document.getElementById('explorer-tree');
                if (!treePanel) return;

                treePanel.innerHTML = '';

                const buildNode = (name, item, path, indent = 0) => {
                    const node = document.createElement('div');
                    node.style.cssText = `padding: 2px 2px 2px ${indent * 12 + 4}px; cursor: pointer; user-select: none;`;
                    node.innerHTML = (item.type === 'folder' ? 'üìÅ ' : 'üìÑ ') + name;

                    node.onclick = () => {
                        if (item.type === 'folder') {
                            this.currentPath = path;
                            this.addToHistory(path);
                            this.renderExplorer();

                            // Highlight selected
                            treePanel.querySelectorAll('div').forEach(d => d.style.background = 'white');
                            node.style.background = '#000080';
                            node.style.color = 'white';
                        }
                    };

                    treePanel.appendChild(node);

                    // Recursively build children
                    if (item.type === 'folder' && item.contents) {
                        Object.keys(item.contents).sort().forEach(childName => {
                            const childPath = path + childName + (item.contents[childName].type === 'folder' ? '\\' : '');
                            buildNode(childName, item.contents[childName], childPath, indent + 1);
                        });
                    }
                };

                // Build root
                const rootNode = document.createElement('div');
                rootNode.style.cssText = 'padding: 2px 4px; cursor: pointer; font-weight: bold; user-select: none; background: #000080; color: white;';
                rootNode.innerHTML = 'üíª My Computer';
                rootNode.onclick = () => {
                    this.currentPath = 'C:\\';
                    this.addToHistory('C:\\');
                    this.renderExplorer();
                };
                treePanel.appendChild(rootNode);

                // Build C:\ and its contents
                const cDrive = this.fileSystem['C:\\'];
                if (cDrive.contents) {
                    Object.keys(cDrive.contents).sort().forEach(name => {
                        buildNode(name, cDrive.contents[name], 'C:\\' + name + (cDrive.contents[name].type === 'folder' ? '\\' : ''), 1);
                    });
                }
            }

            renderExplorer() {
                const contentArea = document.getElementById('explorer-content');
                const pathDisplay = document.getElementById('explorer-path');

                if (!contentArea || !pathDisplay) return;

                pathDisplay.textContent = this.currentPath;

                // Get current folder contents
                const parts = this.currentPath.split('\\').filter(p => p);
                let current = this.fileSystem['C:\\'];

                for (let i = 1; i < parts.length; i++) {
                    if (current.contents && current.contents[parts[i]]) {
                        current = current.contents[parts[i]];
                    }
                }

                // Render contents as detailed list
                contentArea.innerHTML = '';

                // Header
                const header = document.createElement('div');
                header.style.cssText = 'display: grid; grid-template-columns: 2fr 1fr 1fr; padding: 4px; background: #c0c0c0; border-bottom: 1px solid #808080; font-weight: bold;';
                header.innerHTML = `
                    <div>Name</div>
                    <div>Type</div>
                    <div>Size</div>
                `;
                contentArea.appendChild(header);

                if (current.contents) {
                    Object.keys(current.contents).sort().forEach(name => {
                        const item = current.contents[name];
                        const itemEl = document.createElement('div');
                        itemEl.style.cssText = 'display: grid; grid-template-columns: 2fr 1fr 1fr; padding: 4px; border-bottom: 1px solid #e0e0e0; cursor: pointer;';
                        itemEl.innerHTML = `
                            <div>${item.type === 'folder' ? 'üìÅ' : 'üìÑ'} ${name}</div>
                            <div>${item.type === 'folder' ? 'File Folder' : 'Text Document'}</div>
                            <div>${item.size || ''}</div>
                        `;

                        itemEl.onclick = () => {
                            // Highlight selected
                            contentArea.querySelectorAll('div[style*="grid"]').forEach(d => {
                                if (d !== header) d.style.background = 'white';
                            });
                            itemEl.style.background = '#000080';
                            itemEl.style.color = 'white';
                        };

                        if (item.type === 'folder') {
                            itemEl.addEventListener('dblclick', () => this.explorerOpenFolder(name));
                        } else {
                            itemEl.addEventListener('dblclick', () => {
                                this.openNotepad();
                            });
                        }

                        contentArea.appendChild(itemEl);
                    });
                } else {
                    contentArea.innerHTML += '<div style="padding: 20px; color: #808080;">Folder is empty</div>';
                }
            }

            openDOSPrompt() {
                const content = document.createElement('div');
                content.style.cssText = 'display: flex; flex-direction: column; height: 100%; background: #000; color: #0f0; font-family: "Courier New", monospace; font-size: 13px;';

                const output = document.createElement('div');
                output.id = 'terminal-output';
                output.style.cssText = 'flex: 1; padding: 8px; overflow-y: auto; white-space: pre-wrap;';
                output.innerHTML = `Linux Terminal Emulator v1.0
Type 'help' for available commands

user@win95:~$ `;

                const inputLine = document.createElement('div');
                inputLine.style.cssText = 'display: flex; padding: 0 8px 8px 8px;';
                inputLine.innerHTML = `
                    <span id="terminal-prompt" style="margin-right: 4px; color: #0f0;">user@win95:~$</span>
                    <input type="text" id="terminal-input" style="flex: 1; background: #000; color: #0f0; border: none; outline: none; font-family: 'Courier New', monospace; font-size: 13px;">
                `;

                content.appendChild(output);
                content.appendChild(inputLine);

                this.windowManager.createWindow('Linux Terminal', content, { width: 700, height: 450 });

                // Initialize Linux terminal
                this.initLinuxTerminal();
            }

            initLinuxTerminal() {
                // Load filesystem from localStorage or use default
                const savedFS = SafeStorage.getItem('win95-linux-filesystem');

                if (savedFS) {
                    try {
                        this.linuxFS = JSON.parse(savedFS);
                        console.log('Loaded persistent filesystem from storage');
                    } catch (error) {
                        console.error('Failed to load filesystem, using default:', error);
                        this.initDefaultLinuxFS();
                    }
                } else {
                    this.initDefaultLinuxFS();
                }

                // Load terminal history
                const savedHistory = SafeStorage.getItem('win95-terminal-history');
                if (savedHistory) {
                    try {
                        this.terminalHistory = JSON.parse(savedHistory);
                    } catch (error) {
                        this.terminalHistory = [];
                    }
                } else {
                    this.terminalHistory = [];
                }

                this.terminalCwd = '/home/user';
                this.terminalHistoryIndex = -1;
                this.terminalEnv = {
                    USER: 'user',
                    HOME: '/home/user',
                    PATH: '/bin:/usr/bin',
                    PWD: '/home/user'
                };

                const input = document.getElementById('terminal-input');
                const prompt = document.getElementById('terminal-prompt');

                if (input) {
                    input.focus();

                    input.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') {
                            const command = input.value.trim();
                            if (command) {
                                this.terminalHistory.push(command);
                                this.terminalHistoryIndex = this.terminalHistory.length;
                                this.saveTerminalHistory(); // Save history after each command
                                this.executeLinuxCommand(command);
                            } else {
                                this.terminalPrint('');
                            }
                            input.value = '';
                        } else if (e.key === 'ArrowUp') {
                            e.preventDefault();
                            if (this.terminalHistoryIndex > 0) {
                                this.terminalHistoryIndex--;
                                input.value = this.terminalHistory[this.terminalHistoryIndex];
                            }
                        } else if (e.key === 'ArrowDown') {
                            e.preventDefault();
                            if (this.terminalHistoryIndex < this.terminalHistory.length - 1) {
                                this.terminalHistoryIndex++;
                                input.value = this.terminalHistory[this.terminalHistoryIndex];
                            } else {
                                this.terminalHistoryIndex = this.terminalHistory.length;
                                input.value = '';
                            }
                        } else if (e.key === 'Tab') {
                            e.preventDefault();
                            // Tab completion could be added here
                        }
                    });
                }
            }

            initDefaultLinuxFS() {
                // Initialize default filesystem structure
                this.linuxFS = {
                    '/': {
                        type: 'dir',
                        contents: {
                            'home': {
                                type: 'dir',
                                contents: {
                                    'user': {
                                        type: 'dir',
                                        contents: {
                                            'welcome.txt': { type: 'file', content: 'Welcome to the Linux Terminal Emulator!\nType commands like ls, cat, echo, etc.\nFiles you create will be saved automatically.' },
                                            'notes.txt': { type: 'file', content: 'This is a persistent text file.\nYour changes are saved automatically!' }
                                        }
                                    }
                                }
                            },
                            'bin': { type: 'dir', contents: {} },
                            'etc': { type: 'dir', contents: {} },
                            'var': { type: 'dir', contents: {} },
                            'tmp': { type: 'dir', contents: {} }
                        }
                    }
                };
                this.saveLinuxFilesystem();
            }

            saveLinuxFilesystem() {
                // Save filesystem to localStorage
                try {
                    SafeStorage.setItem('win95-linux-filesystem', JSON.stringify(this.linuxFS));
                    console.log('Filesystem saved to storage');
                } catch (error) {
                    console.error('Failed to save filesystem:', error);
                }
            }

            saveTerminalHistory() {
                // Save terminal history to localStorage
                try {
                    // Keep only last 100 commands to avoid storage limits
                    const historyToSave = this.terminalHistory.slice(-100);
                    SafeStorage.setItem('win95-terminal-history', JSON.stringify(historyToSave));
                } catch (error) {
                    console.error('Failed to save terminal history:', error);
                }
            }

            resetLinuxFilesystem() {
                // Reset to default filesystem (utility command)
                if (confirm('Reset filesystem to default? All files will be lost.')) {
                    this.initDefaultLinuxFS();
                    return 'Filesystem reset to default';
                }
                return 'Reset cancelled';
            }

            terminalPrint(text, color = '#0f0') {
                const output = document.getElementById('terminal-output');
                if (!output) return;

                const promptText = this.getTerminalPrompt();
                output.innerHTML += `<span style="color: ${color}">${text}</span>\n${promptText}`;
                output.scrollTop = output.scrollHeight;
            }

            getTerminalPrompt() {
                const shortPath = this.terminalCwd.replace('/home/user', '~');
                return `<span style="color: #0f0;">user@win95</span>:<span style="color: #00f;">${shortPath}</span>$ `;
            }

            executeLinuxCommand(cmdLine) {
                const output = document.getElementById('terminal-output');
                const prompt = document.getElementById('terminal-prompt');

                if (!output) return;

                // Echo command
                output.innerHTML += cmdLine + '\n';

                const parts = cmdLine.trim().split(/\s+/);
                const cmd = parts[0];
                const args = parts.slice(1);

                let response = '';

                switch (cmd) {
                    case 'help':
                        response = `Available commands:

File Operations:
  ls [-la]          - List directory contents
  cd <dir>          - Change directory
  pwd               - Print working directory
  cat <file>        - Display file contents
  mkdir <dir>       - Create directory
  touch <file>      - Create empty file
  rm <file>         - Remove file
  tree              - Show directory tree
  find <dir>        - Search for files
  grep <pat> <file> - Search in files

System Info:
  whoami            - Print current user
  hostname          - Print system name
  uname [-a]        - Print system information
  date              - Display date and time
  uptime            - Show system uptime
  env               - Show environment variables
  export VAR=value  - Set environment variable

Process Management:
  ps                - Show processes
  top               - Display system resource usage
  df                - Show disk usage
  free              - Display memory usage
  which <cmd>       - Locate command

Utilities:
  echo <text>       - Print text
  history           - Show command history
  cal               - Display calendar
  cowsay <text>     - ASCII cow speaks
  fortune           - Random fortune cookie
  clear             - Clear screen
  reset             - Reset filesystem to default
  exit              - Close terminal`;
                        break;

                    case 'ls':
                        response = this.terminalLs(args);
                        break;

                    case 'cd':
                        response = this.terminalCd(args[0] || this.terminalEnv.HOME);
                        break;

                    case 'pwd':
                        response = this.terminalCwd;
                        break;

                    case 'cat':
                        response = this.terminalCat(args[0]);
                        break;

                    case 'echo':
                        response = args.join(' ');
                        break;

                    case 'mkdir':
                        response = this.terminalMkdir(args[0]);
                        break;

                    case 'touch':
                        response = this.terminalTouch(args[0]);
                        break;

                    case 'rm':
                        response = this.terminalRm(args[0]);
                        break;

                    case 'clear':
                        output.innerHTML = this.getTerminalPrompt();
                        if (prompt) prompt.innerHTML = this.getTerminalPrompt();
                        return;

                    case 'whoami':
                        response = this.terminalEnv.USER;
                        break;

                    case 'uname':
                        if (args[0] === '-a') {
                            response = 'Linux win95 5.15.0 #1 SMP x86_64 GNU/Linux';
                        } else {
                            response = 'Linux';
                        }
                        break;

                    case 'date':
                        response = new Date().toString();
                        break;

                    case 'env':
                        response = Object.entries(this.terminalEnv)
                            .map(([k, v]) => `${k}=${v}`)
                            .join('\n');
                        break;

                    case 'export':
                        if (args[0]) {
                            const [key, value] = args[0].split('=');
                            this.terminalEnv[key] = value || '';
                            response = '';
                        } else {
                            response = 'Usage: export VAR=value';
                        }
                        break;

                    case 'tree':
                        response = this.terminalTree();
                        break;

                    case 'grep':
                        response = this.terminalGrep(args);
                        break;

                    case 'find':
                        response = this.terminalFind(args[0] || this.terminalCwd);
                        break;

                    case 'ps':
                        response = this.terminalPs();
                        break;

                    case 'top':
                        response = this.terminalTop();
                        break;

                    case 'df':
                        response = this.terminalDf();
                        break;

                    case 'free':
                        response = this.terminalFree();
                        break;

                    case 'history':
                        response = this.terminalHistory.map((h, i) => `  ${i + 1}  ${h}`).join('\n');
                        break;

                    case 'hostname':
                        response = 'win95';
                        break;

                    case 'uptime':
                        const uptime = Math.floor((Date.now() - this.startTime) / 1000);
                        const hours = Math.floor(uptime / 3600);
                        const mins = Math.floor((uptime % 3600) / 60);
                        response = `up ${hours}:${String(mins).padStart(2, '0')}, 1 user, load average: 0.15, 0.10, 0.05`;
                        break;

                    case 'which':
                        if (args[0]) {
                            const cmds = ['ls', 'cd', 'pwd', 'cat', 'echo', 'mkdir', 'touch', 'rm', 'clear', 'help'];
                            response = cmds.includes(args[0]) ? `/bin/${args[0]}` : `${args[0]} not found`;
                        } else {
                            response = 'which: missing argument';
                        }
                        break;

                    case 'cal':
                        response = this.terminalCal();
                        break;

                    case 'cowsay':
                        response = this.terminalCowsay(args.join(' '));
                        break;

                    case 'fortune':
                        const fortunes = [
                            'You will have a pleasant surprise today.',
                            'A new opportunity is coming your way.',
                            'Good things come to those who code.',
                            'Your hard work will pay off soon.',
                            'Today is a perfect day to learn something new.'
                        ];
                        response = fortunes[Math.floor(Math.random() * fortunes.length)];
                        break;

                    case 'reset':
                        response = this.resetLinuxFilesystem();
                        break;

                    case 'exit':
                        const win = output?.closest('.window');
                        if (win) this.windowManager.closeWindow(win);
                        return;

                    case '':
                        response = '';
                        break;

                    default:
                        response = `bash: ${cmd}: command not found`;
                        break;
                }

                this.terminalPrint(response);

                // Update prompt
                if (prompt) {
                    const shortPath = this.terminalCwd.replace('/home/user', '~');
                    prompt.innerHTML = `<span style="color: #0f0;">user@win95</span>:<span style="color: #00f;">${shortPath}</span>$ `;
                }
            }

            terminalLs(args) {
                const showAll = args.includes('-a') || args.includes('-la');
                const longFormat = args.includes('-l') || args.includes('-la');

                const current = this.terminalGetDir(this.terminalCwd);
                if (!current || current.type !== 'dir') {
                    return 'ls: cannot access directory';
                }

                const items = Object.keys(current.contents || {});
                if (items.length === 0) return '';

                if (longFormat) {
                    return items.map(name => {
                        const item = current.contents[name];
                        const type = item.type === 'dir' ? 'd' : '-';
                        const perms = item.type === 'dir' ? 'rwxr-xr-x' : 'rw-r--r--';
                        const size = item.type === 'file' ? (item.content?.length || 0) : 4096;
                        const date = new Date().toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                        return `${type}${perms} 1 user user ${size.toString().padStart(5)} ${date} ${name}`;
                    }).join('\n');
                } else {
                    return items.join('  ');
                }
            }

            terminalCd(path) {
                if (!path) path = this.terminalEnv.HOME;

                let newPath;
                if (path.startsWith('/')) {
                    newPath = path;
                } else if (path === '..') {
                    const parts = this.terminalCwd.split('/').filter(p => p);
                    parts.pop();
                    newPath = '/' + parts.join('/');
                    if (newPath === '/') newPath = '/';
                } else if (path === '.') {
                    return '';
                } else if (path === '~') {
                    newPath = this.terminalEnv.HOME;
                } else {
                    newPath = this.terminalCwd + (this.terminalCwd.endsWith('/') ? '' : '/') + path;
                }

                const dir = this.terminalGetDir(newPath);
                if (!dir || dir.type !== 'dir') {
                    return `cd: ${path}: No such file or directory`;
                }

                this.terminalCwd = newPath === '' ? '/' : newPath;
                this.terminalEnv.PWD = this.terminalCwd;
                return '';
            }

            terminalCat(filename) {
                if (!filename) return 'cat: missing file operand';

                const path = filename.startsWith('/') ? filename : this.terminalCwd + '/' + filename;
                const file = this.terminalGetDir(path);

                if (!file) {
                    return `cat: ${filename}: No such file or directory`;
                }

                if (file.type === 'dir') {
                    return `cat: ${filename}: Is a directory`;
                }

                return file.content || '';
            }

            terminalMkdir(dirname) {
                if (!dirname) return 'mkdir: missing operand';

                const path = dirname.startsWith('/') ? dirname : this.terminalCwd + '/' + dirname;
                const parentPath = path.substring(0, path.lastIndexOf('/')) || '/';
                const name = path.substring(path.lastIndexOf('/') + 1);

                const parent = this.terminalGetDir(parentPath);
                if (!parent || parent.type !== 'dir') {
                    return `mkdir: cannot create directory '${dirname}': No such file or directory`;
                }

                if (parent.contents[name]) {
                    return `mkdir: cannot create directory '${dirname}': File exists`;
                }

                parent.contents[name] = { type: 'dir', contents: {} };
                this.saveLinuxFilesystem(); // Save after modification
                return '';
            }

            terminalTouch(filename) {
                if (!filename) return 'touch: missing file operand';

                const path = filename.startsWith('/') ? filename : this.terminalCwd + '/' + filename;
                const parentPath = path.substring(0, path.lastIndexOf('/')) || '/';
                const name = path.substring(path.lastIndexOf('/') + 1);

                const parent = this.terminalGetDir(parentPath);
                if (!parent || parent.type !== 'dir') {
                    return `touch: cannot touch '${filename}': No such file or directory`;
                }

                if (!parent.contents[name]) {
                    parent.contents[name] = { type: 'file', content: '' };
                    this.saveLinuxFilesystem(); // Save after modification
                }

                return '';
            }

            terminalRm(filename) {
                if (!filename) return 'rm: missing operand';

                const path = filename.startsWith('/') ? filename : this.terminalCwd + '/' + filename;
                const parentPath = path.substring(0, path.lastIndexOf('/')) || '/';
                const name = path.substring(path.lastIndexOf('/') + 1);

                const parent = this.terminalGetDir(parentPath);
                if (!parent || parent.type !== 'dir') {
                    return `rm: cannot remove '${filename}': No such file or directory`;
                }

                if (!parent.contents[name]) {
                    return `rm: cannot remove '${filename}': No such file or directory`;
                }

                if (parent.contents[name].type === 'dir') {
                    return `rm: cannot remove '${filename}': Is a directory`;
                }

                delete parent.contents[name];
                this.saveLinuxFilesystem(); // Save after modification
                return '';
            }

            terminalTree(dir = this.terminalCwd, prefix = '', isLast = true) {
                const current = this.terminalGetDir(dir);
                if (!current || current.type !== 'dir') return '';

                let result = '';
                const items = Object.keys(current.contents || {});

                items.forEach((name, index) => {
                    const item = current.contents[name];
                    const isLastItem = index === items.length - 1;
                    const connector = isLastItem ? '‚îî‚îÄ‚îÄ ' : '‚îú‚îÄ‚îÄ ';
                    const icon = item.type === 'dir' ? 'üìÅ' : 'üìÑ';

                    result += prefix + connector + icon + ' ' + name + '\n';

                    if (item.type === 'dir') {
                        const newPrefix = prefix + (isLastItem ? '    ' : '‚îÇ   ');
                        const subPath = dir + (dir.endsWith('/') ? '' : '/') + name;
                        result += this.terminalTree(subPath, newPrefix, isLastItem);
                    }
                });

                return result;
            }

            terminalGetDir(path) {
                if (!path || path === '/') return this.linuxFS['/'];

                const parts = path.split('/').filter(p => p);
                let current = this.linuxFS['/'];

                for (const part of parts) {
                    if (!current.contents || !current.contents[part]) {
                        return null;
                    }
                    current = current.contents[part];
                }

                return current;
            }

            terminalGrep(args) {
                if (args.length < 2) return 'grep: usage: grep PATTERN FILE';

                const pattern = args[0];
                const filename = args[1];

                const path = filename.startsWith('/') ? filename : this.terminalCwd + '/' + filename;
                const file = this.terminalGetDir(path);

                if (!file) return `grep: ${filename}: No such file or directory`;
                if (file.type === 'dir') return `grep: ${filename}: Is a directory`;

                const lines = (file.content || '').split('\n');
                const matches = lines.filter(line => line.includes(pattern));

                return matches.length > 0 ? matches.join('\n') : '';
            }

            terminalFind(dir) {
                const results = [];
                const search = (path, item) => {
                    results.push(path);
                    if (item.type === 'dir' && item.contents) {
                        Object.keys(item.contents).forEach(name => {
                            const newPath = path + (path.endsWith('/') ? '' : '/') + name;
                            search(newPath, item.contents[name]);
                        });
                    }
                };

                const startDir = this.terminalGetDir(dir);
                if (startDir) {
                    search(dir, startDir);
                }

                return results.join('\n');
            }

            terminalPs() {
                const processes = [
                    '  PID TTY          TIME CMD',
                    '    1 ?        00:00:01 init',
                    '    2 ?        00:00:00 kthreadd',
                    '  123 pts/0    00:00:00 bash',
                    '  456 pts/0    00:00:00 ps'
                ];
                return processes.join('\n');
            }

            terminalTop() {
                return `top - ${new Date().toLocaleTimeString()} up ${Math.floor((Date.now() - this.startTime) / 60000)} min, 1 user, load average: 0.15, 0.10, 0.05

Tasks:  85 total,   1 running,  84 sleeping,   0 stopped,   0 zombie
%Cpu(s):  2.3 us,  1.0 sy,  0.0 ni, 96.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
MiB Mem :  ${this.settings.memory / 1024 / 1024} total,  ${Math.floor(this.settings.memory / 1024 / 1024 * 0.6)} free,  ${Math.floor(this.settings.memory / 1024 / 1024 * 0.3)} used,  ${Math.floor(this.settings.memory / 1024 / 1024 * 0.1)} buff/cache

  PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND
    1 root      20   0    2048    512    448 S   0.0   0.1   0:01.23 init
  123 user      20   0    4096   1024    896 S   0.0   0.3   0:00.45 bash
  456 user      20   0    2560    768    640 R   1.3   0.2   0:00.01 top`;
            }

            terminalDf() {
                return `Filesystem     1K-blocks    Used Available Use% Mounted on
/dev/sda1       ${Math.floor(this.settings.memory / 1024)}    ${Math.floor(this.settings.memory / 1024 * 0.4)}    ${Math.floor(this.settings.memory / 1024 * 0.6)}  40% /
tmpfs               1024     128       896  13% /tmp`;
            }

            terminalFree() {
                const total = Math.floor(this.settings.memory / 1024);
                const used = Math.floor(total * 0.3);
                const free = total - used;

                return `              total        used        free      shared  buff/cache   available
Mem:          ${total}        ${used}        ${free}           0           0        ${free}
Swap:             0           0           0`;
            }

            terminalCal() {
                const now = new Date();
                const month = now.toLocaleString('default', { month: 'long' });
                const year = now.getFullYear();
                const firstDay = new Date(year, now.getMonth(), 1).getDay();
                const daysInMonth = new Date(year, now.getMonth() + 1, 0).getDate();

                let cal = `   ${month} ${year}\n`;
                cal += 'Su Mo Tu We Th Fr Sa\n';

                let day = 1;
                let week = '';

                // Add spaces for days before first day of month
                for (let i = 0; i < firstDay; i++) {
                    week += '   ';
                }

                // Add days
                for (let d = firstDay; d < 7 && day <= daysInMonth; d++) {
                    week += String(day).padStart(2, ' ') + ' ';
                    day++;
                }
                cal += week + '\n';

                // Rest of the weeks
                while (day <= daysInMonth) {
                    week = '';
                    for (let d = 0; d < 7 && day <= daysInMonth; d++) {
                        week += String(day).padStart(2, ' ') + ' ';
                        day++;
                    }
                    cal += week + '\n';
                }

                return cal;
            }

            terminalCowsay(message) {
                if (!message) message = 'Moo!';

                const len = message.length;
                const border = '-'.repeat(len + 2);

                return ` ${border}
< ${message} >
 ${border}
        \\   ^__^
         \\  (oo)\\_______
            (__)\\       )\\/\\
                ||----w |
                ||     ||`;
            }

            openSolitaire() {
                const content = document.createElement('div');
                content.style.cssText = 'padding: 16px; background: linear-gradient(135deg, #0a5f0a 0%, #0d7d0d 100%); display: flex; flex-direction: column; height: 100%;';

                content.innerHTML = `
                    <style>
                        .sol-card {
                            transition: transform 0.2s, box-shadow 0.2s;
                            cursor: pointer;
                        }
                        .sol-card:hover {
                            transform: translateY(-5px);
                            box-shadow: 3px 3px 10px rgba(0,0,0,0.5) !important;
                        }
                        .sol-card.selected {
                            transform: translateY(-10px);
                            box-shadow: 0 0 15px rgba(255,255,100,0.8) !important;
                        }
                        .sol-pile.valid-drop {
                            background: rgba(100,255,100,0.3) !important;
                            border-color: #0f0 !important;
                        }
                    </style>
                    <div style="background: var(--button-face); padding: 8px; margin-bottom: 12px; display: flex; justify-content: space-between; align-items: center; border: 2px outset;">
                        <div>
                            <button class="btn" onclick="emulator.solitaireNewGame()">New Game</button>
                            <button class="btn" onclick="emulator.solitaireUndo()">Undo</button>
                            <button class="btn" onclick="emulator.solitaireHint()">Hint</button>
                        </div>
                        <div style="display: flex; gap: 12px; font-weight: bold;">
                            <span>Score: <span id="sol-score">0</span></span>
                            <span>Moves: <span id="sol-moves">0</span></span>
                            <span>Time: <span id="sol-time">0:00</span></span>
                        </div>
                    </div>

                    <div style="display: flex; gap: 10px; margin-bottom: 16px; justify-content: space-between;">
                        <div style="display: flex; gap: 10px;">
                            <div id="sol-stock" class="sol-pile" style="width: 70px; height: 100px; border: 2px dashed white; background: rgba(0,0,0,0.2); border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 40px; cursor: pointer;">üÇ†</div>
                            <div id="sol-waste" class="sol-pile" style="width: 70px; height: 100px; border: 2px dashed white; background: rgba(0,0,0,0.2); border-radius: 4px; position: relative;"></div>
                        </div>
                        <div style="display: flex; gap: 10px;">
                            <div class="sol-foundation" data-suit="spades" style="width: 70px; height: 100px; border: 2px solid white; background: rgba(255,255,255,0.1); border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 30px; cursor: pointer;">‚ô†</div>
                            <div class="sol-foundation" data-suit="hearts" style="width: 70px; height: 100px; border: 2px solid white; background: rgba(255,255,255,0.1); border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 30px; cursor: pointer; color: #ff4444;">‚ô•</div>
                            <div class="sol-foundation" data-suit="clubs" style="width: 70px; height: 100px; border: 2px solid white; background: rgba(255,255,255,0.1); border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 30px; cursor: pointer;">‚ô£</div>
                            <div class="sol-foundation" data-suit="diamonds" style="width: 70px; height: 100px; border: 2px solid white; background: rgba(255,255,255,0.1); border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 30px; cursor: pointer; color: #ff4444;">‚ô¶</div>
                        </div>
                    </div>

                    <div id="sol-tableau" style="display: flex; gap: 10px; flex: 1;">
                        ${Array.from({length: 7}, (_, i) => `
                            <div class="sol-column" data-column="${i}" style="flex: 1; min-height: 300px; border: 2px dashed rgba(255,255,255,0.3); border-radius: 4px; padding: 4px; cursor: pointer; position: relative;">
                            </div>
                        `).join('')}
                    </div>

                    <div style="margin-top: 12px; color: white; text-align: center; font-size: 11px;">
                        Goal: Move all cards to foundations (top right), building from Ace to King by suit.<br>
                        Build tableau in descending order, alternating colors. Double-click to auto-move to foundation.
                    </div>
                `;

                this.windowManager.createWindow('Solitaire', content, { width: 750, height: 600 });
                this.initSolitaire();
            }

            initSolitaire() {
                this.solitaireState = {
                    stock: [],
                    waste: [],
                    foundations: { spades: [], hearts: [], clubs: [], diamonds: [] },
                    tableau: Array.from({length: 7}, () => []),
                    selected: null,
                    moves: 0,
                    score: 0,
                    history: [],
                    startTime: Date.now(),
                    timerInterval: null
                };

                this.solitaireState.timerInterval = setInterval(() => {
                    const elapsed = Math.floor((Date.now() - this.solitaireState.startTime) / 1000);
                    const mins = Math.floor(elapsed / 60);
                    const secs = elapsed % 60;
                    const timeEl = document.getElementById('sol-time');
                    if (timeEl) timeEl.textContent = `${mins}:${String(secs).padStart(2, '0')}`;
                }, 1000);

                this.solitaireNewGame();
            }

            solitaireNewGame() {
                if (!this.solitaireState) return;

                const suits = ['spades', 'hearts', 'clubs', 'diamonds'];
                const suitSymbols = { spades: '‚ô†', hearts: '‚ô•', clubs: '‚ô£', diamonds: '‚ô¶' };
                const values = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
                let deck = [];

                suits.forEach(suit => {
                    values.forEach((value, index) => {
                        deck.push({
                            suit, value,
                            rank: index + 1,
                            color: (suit === 'hearts' || suit === 'diamonds') ? 'red' : 'black',
                            symbol: suitSymbols[suit],
                            faceUp: false
                        });
                    });
                });

                for (let i = deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [deck[i], deck[j]] = [deck[j], deck[i]];
                }

                this.solitaireState.stock = [];
                this.solitaireState.waste = [];
                this.solitaireState.foundations = { spades: [], hearts: [], clubs: [], diamonds: [] };
                this.solitaireState.tableau = Array.from({length: 7}, () => []);
                this.solitaireState.selected = null;
                this.solitaireState.moves = 0;
                this.solitaireState.score = 0;
                this.solitaireState.history = [];
                this.solitaireState.startTime = Date.now();

                let cardIndex = 0;
                for (let col = 0; col < 7; col++) {
                    for (let row = 0; row <= col; row++) {
                        const card = deck[cardIndex++];
                        card.faceUp = (row === col);
                        this.solitaireState.tableau[col].push(card);
                    }
                }

                this.solitaireState.stock = deck.slice(cardIndex);
                this.playSoundEffect('deal');
                this.renderSolitaire();
            }

            solitaireUndo() {
                if (!this.solitaireState || this.solitaireState.history.length === 0) {
                    this.playSoundEffect('invalid');
                    return;
                }

                const lastState = this.solitaireState.history.pop();
                this.solitaireState.stock = JSON.parse(JSON.stringify(lastState.stock));
                this.solitaireState.waste = JSON.parse(JSON.stringify(lastState.waste));
                this.solitaireState.foundations = JSON.parse(JSON.stringify(lastState.foundations));
                this.solitaireState.tableau = JSON.parse(JSON.stringify(lastState.tableau));
                this.solitaireState.selected = null;
                this.solitaireState.moves = lastState.moves;
                this.solitaireState.score = lastState.score;
                this.playSoundEffect('place');
                this.renderSolitaire();
            }

            solitaireHint() {
                if (!this.solitaireState) return;

                for (let col = 0; col < 7; col++) {
                    const column = this.solitaireState.tableau[col];
                    if (column.length > 0) {
                        const card = column[column.length - 1];
                        if (card.faceUp && this.canMoveToFoundation(card)) {
                            alert(`Try moving the ${card.value}${card.symbol} from column ${col + 1} to its foundation!`);
                            return;
                        }
                    }
                }

                if (this.solitaireState.waste.length > 0) {
                    const card = this.solitaireState.waste[this.solitaireState.waste.length - 1];
                    if (this.canMoveToFoundation(card)) {
                        alert(`Try moving the ${card.value}${card.symbol} from the waste pile to its foundation!`);
                        return;
                    }
                }

                alert('Try dealing from the stock, or look for cards that can be moved between tableau columns!');
            }

            renderSolitaire() {
                if (!this.solitaireState) return;

                const scoreEl = document.getElementById('sol-score');
                const movesEl = document.getElementById('sol-moves');
                if (scoreEl) scoreEl.textContent = this.solitaireState.score;
                if (movesEl) movesEl.textContent = this.solitaireState.moves;

                const stockEl = document.getElementById('sol-stock');
                if (stockEl) {
                    if (this.solitaireState.stock.length > 0) {
                        stockEl.innerHTML = 'üÇ†';
                        stockEl.style.cursor = 'pointer';
                        stockEl.onclick = () => this.solitaireDealFromStock();
                    } else {
                        stockEl.innerHTML = '‚Üª';
                        stockEl.style.cursor = 'pointer';
                        stockEl.onclick = () => this.solitaireResetStock();
                    }
                }

                const wasteEl = document.getElementById('sol-waste');
                if (wasteEl) {
                    wasteEl.innerHTML = '';
                    if (this.solitaireState.waste.length > 0) {
                        const topCard = this.solitaireState.waste[this.solitaireState.waste.length - 1];
                        const cardEl = document.createElement('div');
                        cardEl.innerHTML = this.renderCard(topCard);
                        cardEl.onclick = () => this.solitaireClickWaste();
                        cardEl.ondblclick = () => this.solitaireAutoMoveToFoundation('waste', -1);
                        wasteEl.appendChild(cardEl);
                    }
                }

                document.querySelectorAll('.sol-foundation').forEach(foundationEl => {
                    const suit = foundationEl.dataset.suit;
                    const cards = this.solitaireState.foundations[suit];
                    const topCard = cards[cards.length - 1];
                    if (topCard) {
                        foundationEl.innerHTML = this.renderCard(topCard);
                    } else {
                        const symbols = { spades: '‚ô†', hearts: '‚ô•', clubs: '‚ô£', diamonds: '‚ô¶' };
                        const color = (suit === 'hearts' || suit === 'diamonds') ? '#ff4444' : 'white';
                        foundationEl.innerHTML = `<span style="color: ${color}; font-size: 30px;">${symbols[suit]}</span>`;
                    }
                    foundationEl.onclick = () => this.solitaireClickFoundation(suit);
                });

                document.querySelectorAll('.sol-column').forEach((columnEl, colIndex) => {
                    const cards = this.solitaireState.tableau[colIndex];
                    columnEl.innerHTML = '';

                    if (cards.length === 0) {
                        columnEl.onclick = () => this.solitaireClickColumn(colIndex);
                    } else {
                        cards.forEach((card, cardIndex) => {
                            const cardEl = document.createElement('div');
                            cardEl.style.cssText = `position: absolute; top: ${cardIndex * 25}px; left: 4px;`;
                            cardEl.className = 'sol-card';

                            if (card.faceUp) {
                                cardEl.innerHTML = this.renderCard(card);
                                cardEl.onclick = (e) => {
                                    e.stopPropagation();
                                    this.solitaireClickTableauCard(colIndex, cardIndex);
                                };
                                cardEl.ondblclick = (e) => {
                                    e.stopPropagation();
                                    this.solitaireAutoMoveToFoundation('tableau', colIndex);
                                };
                            } else {
                                cardEl.innerHTML = `<div style="width: 60px; height: 85px; background: linear-gradient(135deg, #1e3a8a, #1e40af); border: 2px solid #333; border-radius: 4px; display: flex; align-items: center; justify-content: center; box-shadow: 2px 2px 5px rgba(0,0,0,0.3);"><div style="font-size: 40px; color: rgba(255,255,255,0.3);">üÇ†</div></div>`;
                            }
                            columnEl.appendChild(cardEl);
                        });
                    }
                });

                const totalInFoundations = Object.values(this.solitaireState.foundations).reduce((sum, pile) => sum + pile.length, 0);
                if (totalInFoundations === 52) {
                    clearInterval(this.solitaireState.timerInterval);
                    this.playSoundEffect('win');
                    setTimeout(() => {
                        alert(`üéâ You Won! Score: ${this.solitaireState.score}, Moves: ${this.solitaireState.moves}`);
                    }, 300);
                }
            }

            solitaireDealFromStock() {
                if (!this.solitaireState || this.solitaireState.stock.length === 0) return;
                this.saveHistory();
                const card = this.solitaireState.stock.pop();
                card.faceUp = true;
                this.solitaireState.waste.push(card);
                this.playSoundEffect('flip');
                this.renderSolitaire();
            }

            solitaireResetStock() {
                if (!this.solitaireState || this.solitaireState.waste.length === 0) return;
                this.saveHistory();
                this.solitaireState.stock = this.solitaireState.waste.reverse().map(card => {
                    card.faceUp = false;
                    return card;
                });
                this.solitaireState.waste = [];
                this.playSoundEffect('place');
                this.renderSolitaire();
            }

            solitaireClickWaste() {
                if (!this.solitaireState || this.solitaireState.waste.length === 0) return;
                const topCard = this.solitaireState.waste[this.solitaireState.waste.length - 1];
                if (this.solitaireState.selected) {
                    this.solitaireState.selected = null;
                } else {
                    this.solitaireState.selected = { type: 'waste', card: topCard };
                }
                this.renderSolitaire();
            }

            solitaireClickFoundation(suit) {
                if (!this.solitaireState || !this.solitaireState.selected) return;
                const card = this.solitaireState.selected.card;
                const foundation = this.solitaireState.foundations[suit];
                if (card.suit === suit) {
                    const expectedRank = foundation.length + 1;
                    if (card.rank === expectedRank) {
                        this.saveHistory();
                        this.solitaireMoveCardToFoundation(this.solitaireState.selected, suit);
                        this.solitaireState.score += 10;
                        this.playSoundEffect('place');
                    } else {
                        this.playSoundEffect('invalid');
                    }
                }
                this.renderSolitaire();
            }

            solitaireClickColumn(colIndex) {
                if (!this.solitaireState || !this.solitaireState.selected) return;
                const card = this.solitaireState.selected.card;
                if (card.rank === 13) {
                    this.saveHistory();
                    this.solitaireMoveCard(this.solitaireState.selected, { type: 'tableau', index: colIndex });
                    this.playSoundEffect('place');
                } else {
                    this.playSoundEffect('invalid');
                }
                this.renderSolitaire();
            }

            solitaireClickTableauCard(colIndex, cardIndex) {
                if (!this.solitaireState) return;
                const column = this.solitaireState.tableau[colIndex];
                const card = column[cardIndex];
                if (!card.faceUp) return;

                if (this.solitaireState.selected) {
                    const selectedCard = this.solitaireState.selected.card;
                    const targetCard = column[column.length - 1];
                    if (selectedCard.rank === targetCard.rank - 1 && selectedCard.color !== targetCard.color) {
                        this.saveHistory();
                        this.solitaireMoveCard(this.solitaireState.selected, { type: 'tableau', index: colIndex });
                        this.playSoundEffect('place');
                    } else {
                        this.playSoundEffect('invalid');
                    }
                } else {
                    if (cardIndex === column.length - 1) {
                        this.solitaireState.selected = { type: 'tableau', index: colIndex, card: card };
                    }
                }
                this.renderSolitaire();
            }

            solitaireAutoMoveToFoundation(type, index) {
                if (!this.solitaireState) return;
                let card;
                if (type === 'waste') {
                    if (this.solitaireState.waste.length === 0) return;
                    card = this.solitaireState.waste[this.solitaireState.waste.length - 1];
                } else if (type === 'tableau') {
                    const column = this.solitaireState.tableau[index];
                    if (column.length === 0) return;
                    card = column[column.length - 1];
                    if (!card.faceUp) return;
                }

                if (this.canMoveToFoundation(card)) {
                    this.saveHistory();
                    const source = { type, index, card };
                    this.solitaireMoveCardToFoundation(source, card.suit);
                    this.solitaireState.score += 10;
                    this.playSoundEffect('place');
                    this.renderSolitaire();
                } else {
                    this.playSoundEffect('invalid');
                }
            }

            canMoveToFoundation(card) {
                const foundation = this.solitaireState.foundations[card.suit];
                const expectedRank = foundation.length + 1;
                return card.rank === expectedRank;
            }

            solitaireMoveCard(from, to) {
                if (from.type === 'waste') {
                    this.solitaireState.waste.pop();
                } else if (from.type === 'tableau') {
                    this.solitaireState.tableau[from.index].pop();
                    const column = this.solitaireState.tableau[from.index];
                    if (column.length > 0) {
                        column[column.length - 1].faceUp = true;
                    }
                }

                this.solitaireState.tableau[to.index].push(from.card);
                this.solitaireState.selected = null;
                this.solitaireState.moves++;
            }

            solitaireMoveCardToFoundation(from, suit) {
                if (from.type === 'waste') {
                    this.solitaireState.waste.pop();
                } else if (from.type === 'tableau') {
                    this.solitaireState.tableau[from.index].pop();
                    const column = this.solitaireState.tableau[from.index];
                    if (column.length > 0) {
                        column[column.length - 1].faceUp = true;
                    }
                }

                this.solitaireState.foundations[suit].push(from.card);
                this.solitaireState.selected = null;
                this.solitaireState.moves++;
            }

            saveHistory() {
                if (!this.solitaireState) return;
                if (this.solitaireState.history.length >= 20) {
                    this.solitaireState.history.shift();
                }
                this.solitaireState.history.push({
                    stock: JSON.parse(JSON.stringify(this.solitaireState.stock)),
                    waste: JSON.parse(JSON.stringify(this.solitaireState.waste)),
                    foundations: JSON.parse(JSON.stringify(this.solitaireState.foundations)),
                    tableau: JSON.parse(JSON.stringify(this.solitaireState.tableau)),
                    moves: this.solitaireState.moves,
                    score: this.solitaireState.score
                });
            }

            openFreeCell() {
                const content = document.createElement('div');
                content.style.cssText = 'padding: 16px; background: linear-gradient(135deg, #0a5f0a 0%, #0d7d0d 100%); display: flex; flex-direction: column; height: 100%;';

                content.innerHTML = `
                    <div style="background: var(--button-face); padding: 8px; margin-bottom: 12px; display: flex; justify-content: space-between; align-items: center; border: 2px outset;">
                        <div>
                            <button class="btn" onclick="emulator.freeCellNewGame()">New Game</button>
                            <button class="btn" onclick="emulator.freeCellUndo()">Undo</button>
                            <button class="btn" onclick="emulator.freeCellHint()">Hint</button>
                        </div>
                        <div style="display: flex; gap: 12px; font-weight: bold;">
                            <span>Moves: <span id="freecell-moves">0</span></span>
                            <span>Time: <span id="freecell-time">0:00</span></span>
                        </div>
                    </div>

                    <div style="display: flex; gap: 8px; margin-bottom: 16px; justify-content: space-between;">
                        <!-- Free Cells -->
                        <div style="display: flex; gap: 8px;">
                            <div class="freecell-cell" data-cell="0" style="width: 60px; height: 80px; border: 2px solid white; background: rgba(0,0,0,0.2); border-radius: 4px; display: flex; align-items: center; justify-content: center; cursor: pointer;"></div>
                            <div class="freecell-cell" data-cell="1" style="width: 60px; height: 80px; border: 2px solid white; background: rgba(0,0,0,0.2); border-radius: 4px; display: flex; align-items: center; justify-content: center; cursor: pointer;"></div>
                            <div class="freecell-cell" data-cell="2" style="width: 60px; height: 80px; border: 2px solid white; background: rgba(0,0,0,0.2); border-radius: 4px; display: flex; align-items: center; justify-content: center; cursor: pointer;"></div>
                            <div class="freecell-cell" data-cell="3" style="width: 60px; height: 80px; border: 2px solid white; background: rgba(0,0,0,0.2); border-radius: 4px; display: flex; align-items: center; justify-content: center; cursor: pointer;"></div>
                        </div>

                        <!-- Foundation Piles -->
                        <div style="display: flex; gap: 8px;">
                            <div class="freecell-foundation" data-suit="spades" style="width: 60px; height: 80px; border: 2px solid white; background: rgba(255,255,255,0.1); border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 30px; cursor: pointer;">‚ô†</div>
                            <div class="freecell-foundation" data-suit="hearts" style="width: 60px; height: 80px; border: 2px solid white; background: rgba(255,255,255,0.1); border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 30px; cursor: pointer; color: #ff4444;">‚ô•</div>
                            <div class="freecell-foundation" data-suit="clubs" style="width: 60px; height: 80px; border: 2px solid white; background: rgba(255,255,255,0.1); border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 30px; cursor: pointer;">‚ô£</div>
                            <div class="freecell-foundation" data-suit="diamonds" style="width: 60px; height: 80px; border: 2px solid white; background: rgba(255,255,255,0.1); border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 30px; cursor: pointer; color: #ff4444;">‚ô¶</div>
                        </div>
                    </div>

                    <!-- Tableau (8 columns) -->
                    <div id="freecell-tableau" style="display: flex; gap: 8px; flex: 1;">
                        ${Array.from({length: 8}, (_, i) => `
                            <div class="freecell-column" data-column="${i}" style="flex: 1; min-height: 300px; border: 2px dashed rgba(255,255,255,0.3); border-radius: 4px; padding: 4px; cursor: pointer;">
                            </div>
                        `).join('')}
                    </div>
                `;

                this.windowManager.createWindow('FreeCell', content, { width: 750, height: 600 });
                this.initFreeCell();
            }

            // ============================================
            // KEEN EXPLORER - Commander Keen-style Platformer
            // ============================================
            openKeenExplorer() {
                const content = document.createElement('div');
                content.style.cssText = 'display: flex; flex-direction: column; height: 100%; background: #000;';

                const canvas = document.createElement('canvas');
                canvas.width = 640;
                canvas.height = 480;
                canvas.style.cssText = 'width: 100%; height: 100%; image-rendering: pixelated;';

                const controls = document.createElement('div');
                controls.style.cssText = 'background: var(--button-face); padding: 8px; display: flex; justify-content: space-between; align-items: center; font-size: 11px;';
                controls.innerHTML = `
                    <div><strong>Lives:</strong> <span id="keen-lives">3</span> | <strong>Score:</strong> <span id="keen-score">0</span></div>
                    <button class="btn" onclick="emulator.startKeenExplorer()">New Game</button>
                    <div><strong>Keys:</strong> Arrow Keys = Move, Space = Jump, P = Pause</div>
                `;

                content.appendChild(canvas);
                content.appendChild(controls);

                this.windowManager.createWindow('Keen Explorer', content, { width: 660, height: 560 });

                setTimeout(() => this.startKeenExplorer(), 100);
            }

            startKeenExplorer() {
                const canvas = document.querySelector('#emulator canvas');
                if (!canvas) return;

                const ctx = canvas.getContext('2d');
                const livesEl = document.getElementById('keen-lives');
                const scoreEl = document.getElementById('keen-score');

                // Game state
                const game = {
                    player: { x: 100, y: 350, width: 24, height: 32, vx: 0, vy: 0, onGround: false, direction: 1 },
                    platforms: [
                        { x: 0, y: 450, width: 640, height: 30 }, // Ground
                        { x: 200, y: 380, width: 120, height: 20 },
                        { x: 380, y: 310, width: 100, height: 20 },
                        { x: 150, y: 240, width: 100, height: 20 },
                        { x: 420, y: 200, width: 120, height: 20 },
                        { x: 300, y: 130, width: 80, height: 20 }
                    ],
                    gems: [
                        { x: 240, y: 350, collected: false },
                        { x: 410, y: 280, collected: false },
                        { x: 180, y: 210, collected: false },
                        { x: 450, y: 170, collected: false },
                        { x: 320, y: 100, collected: false },
                        { x: 500, y: 420, collected: false },
                        { x: 50, y: 420, collected: false }
                    ],
                    enemies: [
                        { x: 220, y: 350, width: 20, height: 20, vx: 1.5, patrolMin: 200, patrolMax: 320 },
                        { x: 400, y: 280, width: 20, height: 20, vx: 1.5, patrolMin: 380, patrolMax: 480 },
                        { x: 430, y: 170, width: 20, height: 20, vx: 1.5, patrolMin: 420, patrolMax: 540 }
                    ],
                    flag: { x: 580, y: 350, width: 30, height: 60 },
                    keys: {},
                    lives: 3,
                    score: 0,
                    paused: false,
                    gameOver: false,
                    won: false,
                    gravity: 0.6,
                    jumpPower: -12,
                    moveSpeed: 4,
                    animFrame: 0
                };

                // Event listeners
                const keydownHandler = (e) => {
                    if (e.key === 'p' || e.key === 'P') {
                        game.paused = !game.paused;
                        e.preventDefault();
                        return;
                    }
                    game.keys[e.key] = true;
                    e.preventDefault();
                };

                const keyupHandler = (e) => {
                    game.keys[e.key] = false;
                    e.preventDefault();
                };

                document.addEventListener('keydown', keydownHandler);
                document.addEventListener('keyup', keyupHandler);

                // Game loop
                let animationId;
                const gameLoop = () => {
                    animationId = requestAnimationFrame(gameLoop);

                    if (game.paused || game.gameOver || game.won) {
                        render();
                        return;
                    }

                    update();
                    render();
                    game.animFrame++;
                };

                function update() {
                    const p = game.player;

                    // Input handling
                    if (game.keys['ArrowLeft']) {
                        p.vx = -game.moveSpeed;
                        p.direction = -1;
                    } else if (game.keys['ArrowRight']) {
                        p.vx = game.moveSpeed;
                        p.direction = 1;
                    } else {
                        p.vx *= 0.8; // Friction
                    }

                    if (game.keys[' '] && p.onGround) {
                        p.vy = game.jumpPower;
                        p.onGround = false;
                        emulator.playSoundEffect('flip');
                    }

                    // Apply gravity
                    p.vy += game.gravity;
                    p.vy = Math.min(p.vy, 15); // Terminal velocity

                    // Update position
                    p.x += p.vx;
                    p.y += p.vy;

                    // Boundary check
                    if (p.x < 0) p.x = 0;
                    if (p.x + p.width > canvas.width) p.x = canvas.width - p.width;

                    // Platform collision
                    p.onGround = false;
                    game.platforms.forEach(platform => {
                        if (p.x + p.width > platform.x && p.x < platform.x + platform.width &&
                            p.y + p.height > platform.y && p.y + p.height < platform.y + platform.height &&
                            p.vy >= 0) {
                            p.y = platform.y - p.height;
                            p.vy = 0;
                            p.onGround = true;
                        }
                    });

                    // Gem collection
                    game.gems.forEach(gem => {
                        if (!gem.collected &&
                            Math.abs(p.x + p.width/2 - gem.x) < 20 &&
                            Math.abs(p.y + p.height/2 - gem.y) < 20) {
                            gem.collected = true;
                            game.score += 10;
                            scoreEl.textContent = game.score;
                            emulator.playSoundEffect('place');
                        }
                    });

                    // Enemy movement and collision
                    game.enemies.forEach(enemy => {
                        enemy.x += enemy.vx;
                        if (enemy.x <= enemy.patrolMin || enemy.x >= enemy.patrolMax) {
                            enemy.vx *= -1;
                        }

                        // Check collision with player
                        if (p.x + p.width > enemy.x && p.x < enemy.x + enemy.width &&
                            p.y + p.height > enemy.y && p.y < enemy.y + enemy.height) {
                            // Player hit enemy
                            game.lives--;
                            livesEl.textContent = game.lives;
                            emulator.playSoundEffect('invalid');

                            // Reset player position
                            p.x = 100;
                            p.y = 350;
                            p.vx = 0;
                            p.vy = 0;

                            if (game.lives <= 0) {
                                game.gameOver = true;
                                setTimeout(() => alert('Game Over! Final Score: ' + game.score), 100);
                            }
                        }
                    });

                    // Flag/goal collision
                    if (p.x + p.width > game.flag.x && p.x < game.flag.x + game.flag.width &&
                        p.y + p.height > game.flag.y && p.y < game.flag.y + game.flag.height) {
                        game.won = true;
                        emulator.playSoundEffect('win');
                        setTimeout(() => alert('üéâ Level Complete! Score: ' + game.score), 100);
                    }

                    // Fall off screen
                    if (p.y > canvas.height) {
                        game.lives--;
                        livesEl.textContent = game.lives;
                        p.x = 100;
                        p.y = 350;
                        p.vx = 0;
                        p.vy = 0;

                        if (game.lives <= 0) {
                            game.gameOver = true;
                            setTimeout(() => alert('Game Over! Final Score: ' + game.score), 100);
                        }
                    }
                }

                function render() {
                    // Clear
                    ctx.fillStyle = '#1a1a2e';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Platforms
                    ctx.fillStyle = '#654321';
                    game.platforms.forEach(platform => {
                        ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                        ctx.strokeStyle = '#8b6914';
                        ctx.strokeRect(platform.x, platform.y, platform.width, platform.height);
                    });

                    // Gems
                    game.gems.forEach(gem => {
                        if (!gem.collected) {
                            const pulse = Math.sin(game.animFrame * 0.1) * 2;
                            ctx.fillStyle = '#ffd700';
                            ctx.beginPath();
                            ctx.arc(gem.x, gem.y, 8 + pulse, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.strokeStyle = '#ffed4e';
                            ctx.lineWidth = 2;
                            ctx.stroke();
                        }
                    });

                    // Enemies
                    game.enemies.forEach(enemy => {
                        ctx.fillStyle = '#ff0000';
                        ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
                        ctx.fillStyle = '#000';
                        ctx.fillRect(enemy.x + 5, enemy.y + 5, 4, 4);
                        ctx.fillRect(enemy.x + 11, enemy.y + 5, 4, 4);
                    });

                    // Flag/Goal
                    ctx.fillStyle = '#00ff00';
                    ctx.fillRect(game.flag.x, game.flag.y, 5, game.flag.height);
                    ctx.fillRect(game.flag.x, game.flag.y, 25, 20);

                    // Player
                    const p = game.player;
                    ctx.fillStyle = '#00aaff';
                    ctx.fillRect(p.x, p.y, p.width, p.height);

                    // Player face (direction-based)
                    ctx.fillStyle = '#000';
                    if (p.direction === 1) {
                        ctx.fillRect(p.x + 15, p.y + 8, 4, 4); // Eye
                    } else {
                        ctx.fillRect(p.x + 5, p.y + 8, 4, 4); // Eye
                    }

                    // Legs (animated)
                    if (Math.abs(p.vx) > 0.5 && p.onGround) {
                        const legOffset = Math.sin(game.animFrame * 0.3) * 3;
                        ctx.fillStyle = '#0088cc';
                        ctx.fillRect(p.x + 5, p.y + p.height - 8, 6, 8 + legOffset);
                        ctx.fillRect(p.x + 13, p.y + p.height - 8, 6, 8 - legOffset);
                    }

                    // Paused overlay
                    if (game.paused) {
                        ctx.fillStyle = 'rgba(0,0,0,0.7)';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        ctx.fillStyle = '#fff';
                        ctx.font = 'bold 48px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('PAUSED', canvas.width/2, canvas.height/2);
                        ctx.font = '16px Arial';
                        ctx.fillText('Press P to Resume', canvas.width/2, canvas.height/2 + 40);
                    }
                }

                gameLoop();

                // Cleanup on window close
                const checkInterval = setInterval(() => {
                    if (!document.body.contains(canvas)) {
                        cancelAnimationFrame(animationId);
                        document.removeEventListener('keydown', keydownHandler);
                        document.removeEventListener('keyup', keyupHandler);
                        clearInterval(checkInterval);
                    }
                }, 1000);
            }

            // ============================================
            // GALACTIC DEFENDER - Space Shooter
            // ============================================
            openGalacticDefender() {
                const content = document.createElement('div');
                content.style.cssText = 'display: flex; flex-direction: column; height: 100%; background: #000;';

                const canvas = document.createElement('canvas');
                canvas.width = 480;
                canvas.height = 640;
                canvas.style.cssText = 'width: 100%; height: 100%; image-rendering: pixelated;';

                const controls = document.createElement('div');
                controls.style.cssText = 'background: var(--button-face); padding: 8px; display: flex; justify-content: space-between; align-items: center; font-size: 11px;';
                controls.innerHTML = `
                    <div><strong>Lives:</strong> <span id="galactic-lives">3</span> | <strong>Score:</strong> <span id="galactic-score">0</span></div>
                    <button class="btn" onclick="emulator.startGalacticDefender()">New Game</button>
                    <div><strong>Wave:</strong> <span id="galactic-wave">1</span> | <strong>Keys:</strong> Arrows = Move, Space = Shoot</div>
                `;

                content.appendChild(canvas);
                content.appendChild(controls);

                this.windowManager.createWindow('Galactic Defender', content, { width: 500, height: 720 });

                setTimeout(() => this.startGalacticDefender(), 100);
            }

            startGalacticDefender() {
                const canvas = document.querySelector('#emulator canvas');
                if (!canvas) return;

                const ctx = canvas.getContext('2d');
                const livesEl = document.getElementById('galactic-lives');
                const scoreEl = document.getElementById('galactic-score');
                const waveEl = document.getElementById('galactic-wave');

                // Game state
                const game = {
                    player: { x: 220, y: 560, width: 40, height: 40, speed: 6 },
                    bullets: [],
                    enemies: [],
                    powerups: [],
                    particles: [],
                    keys: {},
                    lives: 3,
                    score: 0,
                    wave: 1,
                    enemiesInWave: 0,
                    enemiesKilled: 0,
                    paused: false,
                    gameOver: false,
                    rapidFire: false,
                    rapidFireEnd: 0,
                    shield: false,
                    shieldEnd: 0,
                    lastShot: 0,
                    shootCooldown: 200,
                    animFrame: 0
                };

                // Spawn wave
                function spawnWave() {
                    game.enemiesInWave = 5 + game.wave * 2;
                    game.enemiesKilled = 0;

                    for (let i = 0; i < game.enemiesInWave; i++) {
                        setTimeout(() => {
                            const type = Math.random() < 0.7 ? 'basic' : 'fast';
                            game.enemies.push({
                                x: Math.random() * (canvas.width - 30),
                                y: -30,
                                width: 30,
                                height: 30,
                                speed: type === 'basic' ? 1.5 : 3,
                                health: type === 'basic' ? 1 : 2,
                                type: type,
                                vx: (Math.random() - 0.5) * 2
                            });
                        }, i * 1000);
                    }

                    // Boss every 5 waves
                    if (game.wave % 5 === 0) {
                        setTimeout(() => {
                            game.enemies.push({
                                x: canvas.width / 2 - 40,
                                y: -80,
                                width: 80,
                                height: 80,
                                speed: 0.5,
                                health: 20,
                                type: 'boss',
                                vx: 2
                            });
                        }, game.enemiesInWave * 1000);
                    }
                }

                spawnWave();

                // Event listeners
                const keydownHandler = (e) => {
                    if (e.key === 'p' || e.key === 'P') {
                        game.paused = !game.paused;
                        e.preventDefault();
                        return;
                    }
                    game.keys[e.key] = true;
                    e.preventDefault();
                };

                const keyupHandler = (e) => {
                    game.keys[e.key] = false;
                    e.preventDefault();
                };

                document.addEventListener('keydown', keydownHandler);
                document.addEventListener('keyup', keyupHandler);

                // Game loop
                let animationId;
                const gameLoop = () => {
                    animationId = requestAnimationFrame(gameLoop);

                    if (game.paused || game.gameOver) {
                        render();
                        return;
                    }

                    update();
                    render();
                    game.animFrame++;
                };

                function update() {
                    const now = Date.now();

                    // Player movement
                    if (game.keys['ArrowLeft']) game.player.x -= game.player.speed;
                    if (game.keys['ArrowRight']) game.player.x += game.player.speed;
                    if (game.keys['ArrowUp']) game.player.y -= game.player.speed;
                    if (game.keys['ArrowDown']) game.player.y += game.player.speed;

                    // Boundaries
                    game.player.x = Math.max(0, Math.min(canvas.width - game.player.width, game.player.x));
                    game.player.y = Math.max(canvas.height / 2, Math.min(canvas.height - game.player.height, game.player.y));

                    // Shooting
                    const cooldown = game.rapidFire ? 100 : game.shootCooldown;
                    if (game.keys[' '] && now - game.lastShot > cooldown) {
                        game.bullets.push({
                            x: game.player.x + game.player.width / 2 - 2,
                            y: game.player.y,
                            width: 4,
                            height: 15,
                            speed: -10
                        });
                        game.lastShot = now;
                        emulator.playSoundEffect('flip');
                    }

                    // Update bullets
                    game.bullets = game.bullets.filter(bullet => {
                        bullet.y += bullet.speed;
                        return bullet.y > -20;
                    });

                    // Update enemies
                    game.enemies.forEach(enemy => {
                        enemy.y += enemy.speed;
                        enemy.x += enemy.vx;

                        // Boss side-to-side movement
                        if (enemy.type === 'boss') {
                            if (enemy.x <= 0 || enemy.x >= canvas.width - enemy.width) {
                                enemy.vx *= -1;
                            }
                        }

                        // Boundary bounce
                        if (enemy.x <= 0 || enemy.x >= canvas.width - enemy.width) {
                            enemy.vx *= -1;
                        }

                        // Check collision with player
                        if (!game.shield &&
                            game.player.x < enemy.x + enemy.width &&
                            game.player.x + game.player.width > enemy.x &&
                            game.player.y < enemy.y + enemy.height &&
                            game.player.y + game.player.height > enemy.y) {
                            game.lives--;
                            livesEl.textContent = game.lives;
                            enemy.health = 0; // Destroy enemy
                            emulator.playSoundEffect('invalid');
                            createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2);

                            if (game.lives <= 0) {
                                game.gameOver = true;
                                setTimeout(() => alert('Game Over! Final Score: ' + game.score), 100);
                            }
                        }
                    });

                    // Bullet-enemy collision
                    game.bullets.forEach((bullet, bi) => {
                        game.enemies.forEach((enemy, ei) => {
                            if (bullet.x < enemy.x + enemy.width &&
                                bullet.x + bullet.width > enemy.x &&
                                bullet.y < enemy.y + enemy.height &&
                                bullet.y + bullet.height > enemy.y) {
                                enemy.health--;
                                bullet.y = -100; // Remove bullet

                                if (enemy.health <= 0) {
                                    const points = enemy.type === 'boss' ? 100 : enemy.type === 'fast' ? 20 : 10;
                                    game.score += points;
                                    scoreEl.textContent = game.score;
                                    game.enemiesKilled++;
                                    createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                                    emulator.playSoundEffect('place');

                                    // Drop powerup chance
                                    if (Math.random() < 0.15) {
                                        const types = ['rapidfire', 'shield', 'life'];
                                        game.powerups.push({
                                            x: enemy.x,
                                            y: enemy.y,
                                            width: 20,
                                            height: 20,
                                            type: types[Math.floor(Math.random() * types.length)]
                                        });
                                    }
                                }
                            }
                        });
                    });

                    // Remove dead enemies
                    game.enemies = game.enemies.filter(e => e.health > 0 && e.y < canvas.height + 50);

                    // Update powerups
                    game.powerups = game.powerups.filter(powerup => {
                        powerup.y += 2;

                        // Check collection
                        if (game.player.x < powerup.x + powerup.width &&
                            game.player.x + game.player.width > powerup.x &&
                            game.player.y < powerup.y + powerup.height &&
                            game.player.y + game.player.height > powerup.y) {

                            if (powerup.type === 'rapidfire') {
                                game.rapidFire = true;
                                game.rapidFireEnd = now + 5000;
                            } else if (powerup.type === 'shield') {
                                game.shield = true;
                                game.shieldEnd = now + 5000;
                            } else if (powerup.type === 'life') {
                                game.lives++;
                                livesEl.textContent = game.lives;
                            }
                            emulator.playSoundEffect('place');
                            return false;
                        }

                        return powerup.y < canvas.height;
                    });

                    // Update particles
                    game.particles = game.particles.filter(p => {
                        p.x += p.vx;
                        p.y += p.vy;
                        p.life--;
                        return p.life > 0;
                    });

                    // Check powerup expiration
                    if (game.rapidFire && now > game.rapidFireEnd) game.rapidFire = false;
                    if (game.shield && now > game.shieldEnd) game.shield = false;

                    // Check wave completion
                    if (game.enemies.length === 0 && game.enemiesKilled >= game.enemiesInWave) {
                        game.wave++;
                        waveEl.textContent = game.wave;
                        spawnWave();
                    }
                }

                function createExplosion(x, y) {
                    for (let i = 0; i < 20; i++) {
                        game.particles.push({
                            x: x,
                            y: y,
                            vx: (Math.random() - 0.5) * 8,
                            vy: (Math.random() - 0.5) * 8,
                            life: 30,
                            color: Math.random() < 0.5 ? '#ff6600' : '#ffff00'
                        });
                    }
                }

                function render() {
                    // Clear with star field
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Stars
                    ctx.fillStyle = '#fff';
                    for (let i = 0; i < 50; i++) {
                        const x = (i * 37) % canvas.width;
                        const y = ((i * 57 + game.animFrame * 2) % canvas.height);
                        ctx.fillRect(x, y, 1, 1);
                    }

                    // Powerups
                    game.powerups.forEach(powerup => {
                        const colors = { rapidfire: '#00ff00', shield: '#00ffff', life: '#ff00ff' };
                        ctx.fillStyle = colors[powerup.type];
                        ctx.fillRect(powerup.x, powerup.y, powerup.width, powerup.height);
                        ctx.strokeStyle = '#fff';
                        ctx.strokeRect(powerup.x, powerup.y, powerup.width, powerup.height);
                    });

                    // Particles
                    game.particles.forEach(p => {
                        ctx.fillStyle = p.color;
                        ctx.fillRect(p.x, p.y, 3, 3);
                    });

                    // Bullets
                    ctx.fillStyle = '#00ff00';
                    game.bullets.forEach(bullet => {
                        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                    });

                    // Enemies
                    game.enemies.forEach(enemy => {
                        if (enemy.type === 'boss') {
                            ctx.fillStyle = '#ff0000';
                            ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
                            ctx.fillStyle = '#000';
                            ctx.fillRect(enemy.x + 15, enemy.y + 20, 20, 20);
                            ctx.fillRect(enemy.x + 45, enemy.y + 20, 20, 20);
                            // Health bar
                            ctx.fillStyle = '#ff0000';
                            ctx.fillRect(enemy.x, enemy.y - 10, enemy.width, 5);
                            ctx.fillStyle = '#00ff00';
                            ctx.fillRect(enemy.x, enemy.y - 10, enemy.width * (enemy.health / 20), 5);
                        } else {
                            ctx.fillStyle = enemy.type === 'fast' ? '#ff00ff' : '#ff6600';
                            ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
                            ctx.fillStyle = '#000';
                            ctx.fillRect(enemy.x + 5, enemy.y + 8, 8, 8);
                            ctx.fillRect(enemy.x + 17, enemy.y + 8, 8, 8);
                        }
                    });

                    // Player
                    ctx.fillStyle = game.shield ? '#00ffff' : '#00aaff';
                    ctx.beginPath();
                    ctx.moveTo(game.player.x + game.player.width / 2, game.player.y);
                    ctx.lineTo(game.player.x, game.player.y + game.player.height);
                    ctx.lineTo(game.player.x + game.player.width, game.player.y + game.player.height);
                    ctx.closePath();
                    ctx.fill();

                    // Shield effect
                    if (game.shield) {
                        ctx.strokeStyle = '#00ffff';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(game.player.x + game.player.width/2, game.player.y + game.player.height/2,
                               game.player.width/2 + 10 + Math.sin(game.animFrame * 0.2) * 3, 0, Math.PI * 2);
                        ctx.stroke();
                    }

                    // Rapid fire indicator
                    if (game.rapidFire) {
                        ctx.fillStyle = '#00ff00';
                        ctx.font = 'bold 14px Arial';
                        ctx.fillText('RAPID FIRE', 10, canvas.height - 10);
                    }

                    // Paused overlay
                    if (game.paused) {
                        ctx.fillStyle = 'rgba(0,0,0,0.7)';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        ctx.fillStyle = '#fff';
                        ctx.font = 'bold 48px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('PAUSED', canvas.width/2, canvas.height/2);
                    }
                }

                gameLoop();

                // Cleanup on window close
                const checkInterval = setInterval(() => {
                    if (!document.body.contains(canvas)) {
                        cancelAnimationFrame(animationId);
                        document.removeEventListener('keydown', keydownHandler);
                        document.removeEventListener('keyup', keyupHandler);
                        clearInterval(checkInterval);
                    }
                }, 1000);
            }

            // ============================================
            // SNAKE CLASSIC
            // ============================================
            openSnakeClassic() {
                const content = document.createElement('div');
                content.style.cssText = 'padding: 20px; text-align: center;';

                content.innerHTML = `
                    <h3 style="margin-top: 0;">Select Difficulty</h3>
                    <div style="display: flex; flex-direction: column; gap: 10px; margin: 20px 0;">
                        <button class="btn primary" onclick="emulator.startSnakeGame('easy')" style="padding: 12px;">Easy (Slow)</button>
                        <button class="btn primary" onclick="emulator.startSnakeGame('medium')" style="padding: 12px;">Medium (Normal)</button>
                        <button class="btn primary" onclick="emulator.startSnakeGame('hard')" style="padding: 12px;">Hard (Fast)</button>
                    </div>
                    <div style="margin-top: 20px; padding: 10px; background: #f0f0f0; border: 1px solid #808080; text-align: left; font-size: 11px;">
                        <strong>High Scores:</strong><br>
                        Easy: <span id="snake-high-easy">0</span><br>
                        Medium: <span id="snake-high-medium">0</span><br>
                        Hard: <span id="snake-high-hard">0</span>
                    </div>
                `;

                // Load high scores
                const scores = this.loadSnakeHighScores();
                setTimeout(() => {
                    document.getElementById('snake-high-easy').textContent = scores.easy;
                    document.getElementById('snake-high-medium').textContent = scores.medium;
                    document.getElementById('snake-high-hard').textContent = scores.hard;
                }, 50);

                this.windowManager.createWindow('Snake Classic', content, { width: 400, height: 340 });
            }

            loadSnakeHighScores() {
                const saved = SafeStorage.getItem('win95-snake-scores');
                if (saved) {
                    try {
                        return JSON.parse(saved);
                    } catch (e) {
                        return { easy: 0, medium: 0, hard: 0 };
                    }
                }
                return { easy: 0, medium: 0, hard: 0 };
            }

            saveSnakeHighScore(difficulty, score) {
                const scores = this.loadSnakeHighScores();
                if (score > scores[difficulty]) {
                    scores[difficulty] = score;
                    SafeStorage.setItem('win95-snake-scores', JSON.stringify(scores));
                }
            }

            startSnakeGame(difficulty) {
                const speeds = { easy: 150, medium: 100, hard: 60 };
                const speed = speeds[difficulty];

                const content = document.createElement('div');
                content.style.cssText = 'display: flex; flex-direction: column; height: 100%; background: #000;';

                const canvas = document.createElement('canvas');
                canvas.width = 400;
                canvas.height = 400;
                canvas.style.cssText = 'width: 100%; height: 100%; image-rendering: pixelated;';

                const controls = document.createElement('div');
                controls.style.cssText = 'background: var(--button-face); padding: 8px; display: flex; justify-content: space-between; align-items: center; font-size: 11px;';
                controls.innerHTML = `
                    <div><strong>Score:</strong> <span id="snake-score">0</span></div>
                    <button class="btn" onclick="emulator.startSnakeGame('${difficulty}')">New Game</button>
                    <div><strong>High:</strong> <span id="snake-high">${this.loadSnakeHighScores()[difficulty]}</span></div>
                `;

                content.appendChild(canvas);
                content.appendChild(controls);

                this.windowManager.createWindow(`Snake Classic - ${difficulty.charAt(0).toUpperCase() + difficulty.slice(1)}`,
                                               content, { width: 420, height: 480 });

                setTimeout(() => this.runSnakeGame(canvas, difficulty, speed), 100);
            }

            runSnakeGame(canvas, difficulty, speed) {
                const ctx = canvas.getContext('2d');
                const scoreEl = document.getElementById('snake-score');
                const highEl = document.getElementById('snake-high');

                const gridSize = 20;
                const tileCount = canvas.width / gridSize;

                const game = {
                    snake: [{ x: 10, y: 10 }],
                    food: { x: 15, y: 15 },
                    dx: 1,
                    dy: 0,
                    score: 0,
                    gameOver: false,
                    nextDirection: null
                };

                function placeFood() {
                    game.food = {
                        x: Math.floor(Math.random() * tileCount),
                        y: Math.floor(Math.random() * tileCount)
                    };

                    // Make sure food doesn't spawn on snake
                    const onSnake = game.snake.some(segment =>
                        segment.x === game.food.x && segment.y === game.food.y
                    );
                    if (onSnake) placeFood();
                }

                const keydownHandler = (e) => {
                    if (game.gameOver) return;

                    switch(e.key) {
                        case 'ArrowUp':
                            if (game.dy === 0) game.nextDirection = { dx: 0, dy: -1 };
                            e.preventDefault();
                            break;
                        case 'ArrowDown':
                            if (game.dy === 0) game.nextDirection = { dx: 0, dy: 1 };
                            e.preventDefault();
                            break;
                        case 'ArrowLeft':
                            if (game.dx === 0) game.nextDirection = { dx: -1, dy: 0 };
                            e.preventDefault();
                            break;
                        case 'ArrowRight':
                            if (game.dx === 0) game.nextDirection = { dx: 1, dy: 0 };
                            e.preventDefault();
                            break;
                    }
                };

                document.addEventListener('keydown', keydownHandler);

                function update() {
                    if (game.gameOver) return;

                    // Apply next direction
                    if (game.nextDirection) {
                        game.dx = game.nextDirection.dx;
                        game.dy = game.nextDirection.dy;
                        game.nextDirection = null;
                    }

                    // Move snake
                    const head = {
                        x: game.snake[0].x + game.dx,
                        y: game.snake[0].y + game.dy
                    };

                    // Check wall collision
                    if (head.x < 0 || head.x >= tileCount || head.y < 0 || head.y >= tileCount) {
                        game.gameOver = true;
                        emulator.playSoundEffect('invalid');
                        emulator.saveSnakeHighScore(difficulty, game.score);
                        setTimeout(() => alert('Game Over! Score: ' + game.score), 100);
                        return;
                    }

                    // Check self collision
                    const hitSelf = game.snake.some(segment =>
                        segment.x === head.x && segment.y === head.y
                    );
                    if (hitSelf) {
                        game.gameOver = true;
                        emulator.playSoundEffect('invalid');
                        emulator.saveSnakeHighScore(difficulty, game.score);
                        setTimeout(() => alert('Game Over! Score: ' + game.score), 100);
                        return;
                    }

                    game.snake.unshift(head);

                    // Check food collision
                    if (head.x === game.food.x && head.y === game.food.y) {
                        game.score++;
                        scoreEl.textContent = game.score;

                        // Update high score display
                        const currentHigh = parseInt(highEl.textContent);
                        if (game.score > currentHigh) {
                            highEl.textContent = game.score;
                        }

                        placeFood();
                        emulator.playSoundEffect('place');
                    } else {
                        game.snake.pop();
                    }
                }

                function render() {
                    // Background
                    ctx.fillStyle = '#0a0a0a';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // Grid
                    ctx.strokeStyle = '#1a1a1a';
                    for (let i = 0; i < tileCount; i++) {
                        ctx.beginPath();
                        ctx.moveTo(i * gridSize, 0);
                        ctx.lineTo(i * gridSize, canvas.height);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(0, i * gridSize);
                        ctx.lineTo(canvas.width, i * gridSize);
                        ctx.stroke();
                    }

                    // Food
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(game.food.x * gridSize + 2, game.food.y * gridSize + 2,
                                gridSize - 4, gridSize - 4);

                    // Snake
                    game.snake.forEach((segment, index) => {
                        ctx.fillStyle = index === 0 ? '#00ff00' : '#00aa00';
                        ctx.fillRect(segment.x * gridSize + 1, segment.y * gridSize + 1,
                                    gridSize - 2, gridSize - 2);
                    });

                    // Game over overlay
                    if (game.gameOver) {
                        ctx.fillStyle = 'rgba(0,0,0,0.7)';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        ctx.fillStyle = '#fff';
                        ctx.font = 'bold 32px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('GAME OVER', canvas.width/2, canvas.height/2);
                        ctx.font = '16px Arial';
                        ctx.fillText('Score: ' + game.score, canvas.width/2, canvas.height/2 + 40);
                    }
                }

                const gameInterval = setInterval(() => {
                    update();
                    render();
                }, speed);

                render();

                // Cleanup on window close
                const checkInterval = setInterval(() => {
                    if (!document.body.contains(canvas)) {
                        clearInterval(gameInterval);
                        document.removeEventListener('keydown', keydownHandler);
                        clearInterval(checkInterval);
                    }
                }, 1000);
            }

            initFreeCell() {
                this.freeCellState = {
                    cells: [null, null, null, null], // 4 free cells
                    foundations: { spades: [], hearts: [], clubs: [], diamonds: [] }, // 4 foundation piles
                    tableau: Array.from({length: 8}, () => []), // 8 columns
                    selected: null, // Selected card {from: 'cell'|'column'|'foundation', index: number, card: object}
                    moves: 0,
                    history: [],
                    startTime: Date.now(),
                    timerInterval: null
                };

                // Start timer
                this.freeCellState.timerInterval = setInterval(() => {
                    const elapsed = Math.floor((Date.now() - this.freeCellState.startTime) / 1000);
                    const mins = Math.floor(elapsed / 60);
                    const secs = elapsed % 60;
                    const timeEl = document.getElementById('freecell-time');
                    if (timeEl) timeEl.textContent = `${mins}:${String(secs).padStart(2, '0')}`;
                }, 1000);

                // Generate and shuffle deck
                this.freeCellNewGame();
            }

            freeCellNewGame() {
                if (!this.freeCellState) return;

                // Create deck
                const suits = ['spades', 'hearts', 'clubs', 'diamonds'];
                const suitSymbols = { spades: '‚ô†', hearts: '‚ô•', clubs: '‚ô£', diamonds: '‚ô¶' };
                const values = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
                let deck = [];

                suits.forEach(suit => {
                    values.forEach((value, index) => {
                        deck.push({
                            suit: suit,
                            value: value,
                            rank: index + 1,
                            color: (suit === 'hearts' || suit === 'diamonds') ? 'red' : 'black',
                            symbol: suitSymbols[suit]
                        });
                    });
                });

                // Shuffle
                for (let i = deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [deck[i], deck[j]] = [deck[j], deck[i]];
                }

                // Reset state
                this.freeCellState.cells = [null, null, null, null];
                this.freeCellState.foundations = { spades: [], hearts: [], clubs: [], diamonds: [] };
                this.freeCellState.tableau = Array.from({length: 8}, () => []);
                this.freeCellState.selected = null;
                this.freeCellState.moves = 0;
                this.freeCellState.startTime = Date.now();

                // Deal cards to tableau (first 4 columns get 7 cards, last 4 get 6)
                let cardIndex = 0;
                for (let col = 0; col < 8; col++) {
                    const cardsInColumn = col < 4 ? 7 : 6;
                    for (let i = 0; i < cardsInColumn; i++) {
                        this.freeCellState.tableau[col].push(deck[cardIndex++]);
                    }
                }

                this.renderFreeCell();
            }

            renderFreeCell() {
                if (!this.freeCellState) return;

                // Update moves counter
                const movesEl = document.getElementById('freecell-moves');
                if (movesEl) movesEl.textContent = this.freeCellState.moves;

                // Render free cells with double-click auto-move
                document.querySelectorAll('.freecell-cell').forEach((cellEl, index) => {
                    const card = this.freeCellState.cells[index];
                    cellEl.innerHTML = card ? this.renderCard(card) : '';
                    cellEl.onclick = () => this.freeCellClickCell(index);
                    if (card) {
                        cellEl.ondblclick = () => this.freeCellAutoMoveToFoundation('cell', index);
                    }
                });

                // Render foundations
                document.querySelectorAll('.freecell-foundation').forEach(foundationEl => {
                    const suit = foundationEl.dataset.suit;
                    const cards = this.freeCellState.foundations[suit];
                    const topCard = cards[cards.length - 1];
                    foundationEl.innerHTML = topCard ? this.renderCard(topCard) : foundationEl.textContent;
                    foundationEl.onclick = () => this.freeCellClickFoundation(suit);
                });

                // Render tableau columns with double-click auto-move
                document.querySelectorAll('.freecell-column').forEach((columnEl, colIndex) => {
                    const cards = this.freeCellState.tableau[colIndex];
                    columnEl.innerHTML = '';

                    if (cards.length === 0) {
                        columnEl.onclick = () => this.freeCellClickColumn(colIndex);
                    } else {
                        cards.forEach((card, cardIndex) => {
                            const cardEl = document.createElement('div');
                            cardEl.style.cssText = 'margin-bottom: 20px; transition: transform 0.2s, box-shadow 0.2s; cursor: pointer;';
                            cardEl.innerHTML = this.renderCard(card);

                            // Add hover effect for last card
                            if (cardIndex === cards.length - 1) {
                                cardEl.onmouseover = () => {
                                    cardEl.style.transform = 'translateY(-5px)';
                                };
                                cardEl.onmouseout = () => {
                                    cardEl.style.transform = 'translateY(0)';
                                };
                            }

                            cardEl.onclick = (e) => {
                                e.stopPropagation();
                                this.freeCellClickTableauCard(colIndex, cardIndex);
                            };

                            // Double-click auto-move for last card
                            if (cardIndex === cards.length - 1) {
                                cardEl.ondblclick = (e) => {
                                    e.stopPropagation();
                                    this.freeCellAutoMoveToFoundation('column', colIndex);
                                };
                            }

                            columnEl.appendChild(cardEl);
                        });
                    }
                });

                // Check for win
                const totalInFoundations = Object.values(this.freeCellState.foundations).reduce((sum, pile) => sum + pile.length, 0);
                if (totalInFoundations === 52) {
                    clearInterval(this.freeCellState.timerInterval);
                    this.playSoundEffect('win');
                    setTimeout(() => {
                        alert(`üéâ You Won! Moves: ${this.freeCellState.moves}`);
                    }, 300);
                }
            }

            renderCard(card) {
                const color = card.color === 'red' ? '#ff4444' : '#000';
                return `
                    <div style="width: 50px; height: 70px; background: white; border: 2px solid #333; border-radius: 4px; display: flex; flex-direction: column; align-items: center; justify-content: center; font-size: 20px; color: ${color}; box-shadow: 2px 2px 5px rgba(0,0,0,0.3); font-weight: bold;">
                        <div>${card.value}</div>
                        <div style="font-size: 24px;">${card.symbol}</div>
                    </div>
                `;
            }

            freeCellClickCell(index) {
                if (!this.freeCellState) return;

                if (this.freeCellState.selected) {
                    // Try to move selected card to this cell
                    if (!this.freeCellState.cells[index]) {
                        this.freeCellMoveCard(this.freeCellState.selected, { type: 'cell', index });
                        this.playSoundEffect('place');
                    } else {
                        this.playSoundEffect('invalid');
                    }
                } else if (this.freeCellState.cells[index]) {
                    // Select card from cell
                    this.freeCellState.selected = { type: 'cell', index, card: this.freeCellState.cells[index] };
                }
                this.renderFreeCell();
            }

            freeCellClickFoundation(suit) {
                if (!this.freeCellState || !this.freeCellState.selected) return;

                const selected = this.freeCellState.selected;
                const card = selected.card;
                const foundation = this.freeCellState.foundations[suit];

                // Check if card can be placed on foundation
                if (card.suit === suit) {
                    const expectedRank = foundation.length + 1;
                    if (card.rank === expectedRank) {
                        this.freeCellMoveCard(selected, { type: 'foundation', suit });
                        this.playSoundEffect('place');
                    } else {
                        this.playSoundEffect('invalid');
                    }
                } else {
                    this.playSoundEffect('invalid');
                }
                this.renderFreeCell();
            }

            freeCellClickColumn(colIndex) {
                if (!this.freeCellState || !this.freeCellState.selected) return;

                // Try to move selected card to empty column
                if (this.freeCellState.tableau[colIndex].length === 0) {
                    this.freeCellMoveCard(this.freeCellState.selected, { type: 'column', index: colIndex });
                    this.playSoundEffect('place');
                } else {
                    this.playSoundEffect('invalid');
                }
                this.renderFreeCell();
            }

            freeCellClickTableauCard(colIndex, cardIndex) {
                if (!this.freeCellState) return;

                const column = this.freeCellState.tableau[colIndex];

                // Can only select the last card in a column
                if (cardIndex !== column.length - 1) return;

                if (this.freeCellState.selected) {
                    // Try to move selected card here
                    const targetCard = column[column.length - 1];
                    const selectedCard = this.freeCellState.selected.card;

                    // Check if move is valid (descending rank, alternating color)
                    if (selectedCard.rank === targetCard.rank - 1 && selectedCard.color !== targetCard.color) {
                        this.freeCellMoveCard(this.freeCellState.selected, { type: 'column', index: colIndex });
                        this.playSoundEffect('place');
                    } else {
                        this.playSoundEffect('invalid');
                    }
                } else {
                    // Select this card
                    this.freeCellState.selected = { type: 'column', index: colIndex, card: column[cardIndex] };
                }
                this.renderFreeCell();
            }

            freeCellAutoMoveToFoundation(type, index) {
                if (!this.freeCellState) return;

                let card;
                if (type === 'cell') {
                    card = this.freeCellState.cells[index];
                    if (!card) return;
                } else if (type === 'column') {
                    const column = this.freeCellState.tableau[index];
                    if (column.length === 0) return;
                    card = column[column.length - 1];
                }

                // Check if card can move to its foundation
                const foundation = this.freeCellState.foundations[card.suit];
                const expectedRank = foundation.length + 1;

                if (card.rank === expectedRank) {
                    const from = { type, index, card };
                    this.freeCellMoveCard(from, { type: 'foundation', suit: card.suit });
                    this.playSoundEffect('place');
                    this.renderFreeCell();
                } else {
                    this.playSoundEffect('invalid');
                }
            }

            freeCellMoveCard(from, to) {
                if (!this.freeCellState) return;

                const card = from.card;

                // Remove card from source
                if (from.type === 'cell') {
                    this.freeCellState.cells[from.index] = null;
                } else if (from.type === 'column') {
                    this.freeCellState.tableau[from.index].pop();
                } else if (from.type === 'foundation') {
                    this.freeCellState.foundations[from.suit].pop();
                }

                // Add card to destination
                if (to.type === 'cell') {
                    this.freeCellState.cells[to.index] = card;
                } else if (to.type === 'column') {
                    this.freeCellState.tableau[to.index].push(card);
                } else if (to.type === 'foundation') {
                    this.freeCellState.foundations[to.suit].push(card);
                }

                this.freeCellState.selected = null;
                this.freeCellState.moves++;
            }

            freeCellUndo() {
                this.playSoundEffect('invalid');
                alert('Undo feature coming soon!');
            }

            freeCellHint() {
                alert('Check if any cards can move to foundations, or try moving cards to free cells to unblock tableau columns!');
            }

            openMediaPlayer() {
                const content = document.createElement('div');
                content.style.cssText = 'display: flex; flex-direction: column; height: 100%; background: var(--button-face);';

                content.innerHTML = `
                    <div style="flex: 1; background: black; display: flex; align-items: center; justify-content: center; position: relative; overflow: hidden;">
                        <video id="media-player-video" style="max-width: 100%; max-height: 100%;" controls>
                            <source src="" type="video/mp4">
                            Your browser does not support the video tag.
                        </video>
                        <div id="media-visualization" style="position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; font-size: 48px; color: #00ff00;">
                            ‚ô™‚ô´‚ô™
                        </div>
                    </div>
                    <div style="background: var(--button-face); padding: 8px; border-top: 1px solid var(--button-shadow);">
                        <div style="display: flex; gap: 4px; margin-bottom: 8px; justify-content: center;">
                            <button class="btn" onclick="emulator.mediaControl('prev')" title="Previous">‚èÆ</button>
                            <button class="btn" onclick="emulator.mediaControl('play')" title="Play">‚ñ∂</button>
                            <button class="btn" onclick="emulator.mediaControl('pause')" title="Pause">‚è∏</button>
                            <button class="btn" onclick="emulator.mediaControl('stop')" title="Stop">‚èπ</button>
                            <button class="btn" onclick="emulator.mediaControl('next')" title="Next">‚è≠</button>
                        </div>
                        <div style="display: flex; align-items: center; gap: 8px; font-size: 11px;">
                            <span>Volume:</span>
                            <input type="range" id="media-volume" min="0" max="100" value="70" style="flex: 1;" onchange="emulator.mediaSetVolume(this.value)">
                            <span id="media-volume-label">70%</span>
                        </div>
                        <div style="margin-top: 8px; padding: 4px; background: white; border: 1px inset; min-height: 20px; font-size: 11px;" id="media-status">
                            Ready - No media loaded
                        </div>
                    </div>
                    <div style="background: var(--button-face); padding: 4px; border-top: 1px solid var(--button-highlight); font-size: 10px; text-align: center;">
                        Drop audio/video files here to play (Feature demonstration - File API would be needed)
                    </div>
                `;

                this.windowManager.createWindow('Media Player', content, { width: 480, height: 400 });
            }

            mediaControl(action) {
                const video = document.getElementById('media-player-video');
                const status = document.getElementById('media-status');

                if (!video || !status) return;

                switch (action) {
                    case 'play':
                        if (video.src) {
                            video.play();
                            status.textContent = 'Playing...';
                        } else {
                            status.textContent = 'No media loaded';
                        }
                        break;
                    case 'pause':
                        video.pause();
                        status.textContent = 'Paused';
                        break;
                    case 'stop':
                        video.pause();
                        video.currentTime = 0;
                        status.textContent = 'Stopped';
                        break;
                    case 'prev':
                        status.textContent = 'Previous track (demo)';
                        break;
                    case 'next':
                        status.textContent = 'Next track (demo)';
                        break;
                }
            }

            mediaSetVolume(value) {
                const video = document.getElementById('media-player-video');
                const label = document.getElementById('media-volume-label');

                if (video) video.volume = value / 100;
                if (label) label.textContent = value + '%';
            }

            openSystemProperties() {
                const uptime = Math.floor((Date.now() - this.startTime) / 1000);
                const hours = Math.floor(uptime / 3600);
                const mins = Math.floor((uptime % 3600) / 60);
                const secs = uptime % 60;

                const content = `
                    <div style="padding: 20px;">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div style="font-size: 48px; margin-bottom: 10px;">‚öôÔ∏è</div>
                            <h3 style="margin: 0;">System Properties</h3>
                        </div>

                        <div style="background: white; padding: 12px; border: 2px inset; margin-bottom: 12px;">
                            <table style="width: 100%; font-size: 11px;">
                                <tr>
                                    <td style="padding: 4px; font-weight: bold;">System:</td>
                                    <td style="padding: 4px;">Microsoft Windows 95</td>
                                </tr>
                                <tr>
                                    <td style="padding: 4px; font-weight: bold;">Version:</td>
                                    <td style="padding: 4px;">4.00.950 (Simulator)</td>
                                </tr>
                                <tr>
                                    <td style="padding: 4px; font-weight: bold;">Computer:</td>
                                    <td style="padding: 4px;">win95-simulator</td>
                                </tr>
                                <tr>
                                    <td style="padding: 4px; font-weight: bold;">Processor:</td>
                                    <td style="padding: 4px;">Browser JavaScript Engine</td>
                                </tr>
                                <tr>
                                    <td style="padding: 4px; font-weight: bold;">Memory:</td>
                                    <td style="padding: 4px;">${Math.floor(this.settings.memory / 1024 / 1024)} MB RAM</td>
                                </tr>
                                <tr>
                                    <td style="padding: 4px; font-weight: bold;">User:</td>
                                    <td style="padding: 4px;">user</td>
                                </tr>
                                <tr>
                                    <td style="padding: 4px; font-weight: bold;">Uptime:</td>
                                    <td style="padding: 4px;">${hours}h ${mins}m ${secs}s</td>
                                </tr>
                            </table>
                        </div>

                        <div style="background: #ffffc0; padding: 8px; border: 1px solid #808080; font-size: 10px; margin-bottom: 12px;">
                            <strong>‚ÑπÔ∏è Note:</strong> This is a browser-based simulator. System information reflects the simulated environment.
                        </div>

                        <div style="text-align: center;">
                            <button class="btn primary" onclick="emulator.windowManager.closeWindow(this.closest('.window'))" style="min-width: 100px;">OK</button>
                        </div>
                    </div>
                `;

                this.windowManager.createWindow('System Properties', content, { width: 420, height: 440 });
            }

            openRegistryEditor() {
                // Load or initialize registry from localStorage
                const registry = this.loadRegistry();

                const content = document.createElement('div');
                content.style.cssText = 'display: flex; flex-direction: column; height: 100%; background: var(--button-face);';

                // Menu bar
                const menuBar = document.createElement('div');
                menuBar.style.cssText = 'background: var(--button-face); padding: 2px 4px; border-bottom: 1px solid #808080; font-size: 11px;';
                menuBar.innerHTML = `
                    <span style="padding: 2px 8px; cursor: pointer;">Registry</span>
                    <span style="padding: 2px 8px; cursor: pointer;">Edit</span>
                    <span style="padding: 2px 8px; cursor: pointer;">View</span>
                    <span style="padding: 2px 8px; cursor: pointer;">Help</span>
                `;

                // Toolbar
                const toolbar = document.createElement('div');
                toolbar.style.cssText = 'background: var(--button-face); padding: 4px; border-bottom: 1px solid #808080; display: flex; gap: 4px;';
                toolbar.innerHTML = `
                    <button class="btn" onclick="emulator.registryAddKey()" title="New Key">üìÅ+</button>
                    <button class="btn" onclick="emulator.registryAddValue()" title="New Value">üìù+</button>
                    <button class="btn" onclick="emulator.registryDelete()" title="Delete">üóëÔ∏è</button>
                    <button class="btn" onclick="emulator.registryRefresh()" title="Refresh">üîÑ</button>
                `;

                // Main container
                const mainContainer = document.createElement('div');
                mainContainer.style.cssText = 'display: flex; flex: 1; overflow: hidden;';

                // Tree view (left panel)
                const treePanel = document.createElement('div');
                treePanel.id = 'registry-tree';
                treePanel.style.cssText = 'width: 250px; background: white; border: 2px inset; overflow-y: auto; font-size: 11px; font-family: "MS Sans Serif", Arial, sans-serif;';

                // Details view (right panel)
                const detailsPanel = document.createElement('div');
                detailsPanel.id = 'registry-details';
                detailsPanel.style.cssText = 'flex: 1; margin-left: 4px; background: white; border: 2px inset; overflow-y: auto;';

                // Build tree view
                this.buildRegistryTree(treePanel, registry);

                // Build details view header
                detailsPanel.innerHTML = `
                    <div style="background: #000080; color: white; padding: 4px; font-size: 11px; display: flex; border-bottom: 1px solid #808080;">
                        <div style="flex: 1; padding: 2px;">Name</div>
                        <div style="flex: 1; padding: 2px;">Type</div>
                        <div style="flex: 2; padding: 2px;">Data</div>
                    </div>
                    <div id="registry-values" style="font-size: 11px;"></div>
                `;

                mainContainer.appendChild(treePanel);
                mainContainer.appendChild(detailsPanel);

                content.appendChild(menuBar);
                content.appendChild(toolbar);
                content.appendChild(mainContainer);

                this.registryState = { currentKey: null, registry: registry };
                this.windowManager.createWindow('Registry Editor', content, { width: 700, height: 500 });
            }

            loadRegistry() {
                const saved = SafeStorage.getItem('win95-registry');
                if (saved) {
                    try {
                        return JSON.parse(saved);
                    } catch (e) {
                        return this.getDefaultRegistry();
                    }
                }
                return this.getDefaultRegistry();
            }

            getDefaultRegistry() {
                return {
                    'HKEY_CLASSES_ROOT': {
                        '.txt': { '(Default)': 'txtfile' },
                        'txtfile': { '(Default)': 'Text Document' }
                    },
                    'HKEY_CURRENT_USER': {
                        'Software': {
                            'Microsoft': {
                                'Windows': { 'CurrentVersion': 'Windows 95 Simulator' }
                            }
                        },
                        'Control Panel': {
                            'Desktop': { 'Wallpaper': 'None' },
                            'Mouse': { 'DoubleClickSpeed': '500' }
                        }
                    },
                    'HKEY_LOCAL_MACHINE': {
                        'SOFTWARE': {
                            'Microsoft': {
                                'Windows': {
                                    'CurrentVersion': { 'Version': '4.00.950' }
                                }
                            }
                        },
                        'SYSTEM': {
                            'CurrentControlSet': { 'Control': { 'ComputerName': 'WIN95-SIM' } }
                        }
                    },
                    'HKEY_USERS': {
                        '.DEFAULT': { '(Default)': 'Default User Settings' }
                    },
                    'HKEY_CURRENT_CONFIG': {
                        'Software': { 'Fonts': { '(Default)': 'MS Sans Serif' } }
                    }
                };
            }

            saveRegistry(registry) {
                try {
                    SafeStorage.setItem('win95-registry', JSON.stringify(registry));
                } catch (e) {
                    alert('Error saving registry: ' + e.message);
                }
            }

            buildRegistryTree(container, registry, path = []) {
                container.innerHTML = '';

                const buildNode = (obj, parent, currentPath) => {
                    Object.keys(obj).sort().forEach(key => {
                        const fullPath = [...currentPath, key];
                        const pathStr = fullPath.join('\\');

                        const nodeDiv = document.createElement('div');
                        nodeDiv.style.cssText = 'padding: 2px 2px 2px ' + (currentPath.length * 16 + 4) + 'px; cursor: pointer; user-select: none;';

                        const hasChildren = typeof obj[key] === 'object' && obj[key] !== null && !obj[key].hasOwnProperty('(Default)') && Object.keys(obj[key]).length > 0;

                        nodeDiv.innerHTML = (hasChildren ? 'üìÅ ' : 'üìÑ ') + key;

                        nodeDiv.onclick = (e) => {
                            e.stopPropagation();
                            // Highlight selected
                            container.querySelectorAll('div').forEach(d => d.style.background = 'white');
                            nodeDiv.style.background = '#000080';
                            nodeDiv.style.color = 'white';

                            // Update details panel
                            this.registryState.currentKey = fullPath;
                            this.displayRegistryValues(obj[key]);
                        };

                        parent.appendChild(nodeDiv);

                        // Recursively build child nodes
                        if (typeof obj[key] === 'object' && obj[key] !== null) {
                            buildNode(obj[key], parent, fullPath);
                        }
                    });
                };

                // Build root nodes
                Object.keys(registry).sort().forEach(rootKey => {
                    const rootDiv = document.createElement('div');
                    rootDiv.style.cssText = 'padding: 2px 4px; cursor: pointer; font-weight: bold; user-select: none;';
                    rootDiv.innerHTML = 'üñ•Ô∏è ' + rootKey;

                    rootDiv.onclick = (e) => {
                        e.stopPropagation();
                        container.querySelectorAll('div').forEach(d => {
                            d.style.background = 'white';
                            d.style.color = 'black';
                        });
                        rootDiv.style.background = '#000080';
                        rootDiv.style.color = 'white';

                        this.registryState.currentKey = [rootKey];
                        this.displayRegistryValues(registry[rootKey]);
                    };

                    container.appendChild(rootDiv);

                    if (typeof registry[rootKey] === 'object') {
                        buildNode(registry[rootKey], container, [rootKey]);
                    }
                });
            }

            displayRegistryValues(keyData) {
                const valuesContainer = document.getElementById('registry-values');
                if (!valuesContainer) return;

                valuesContainer.innerHTML = '';

                if (!keyData || typeof keyData !== 'object') return;

                // Display values (leaf nodes)
                Object.keys(keyData).forEach(valueName => {
                    const valueData = keyData[valueName];

                    if (typeof valueData === 'string' || typeof valueData === 'number') {
                        const row = document.createElement('div');
                        row.style.cssText = 'display: flex; padding: 4px; border-bottom: 1px solid #e0e0e0; cursor: pointer;';
                        row.innerHTML = `
                            <div style="flex: 1; padding: 2px;">${valueName}</div>
                            <div style="flex: 1; padding: 2px;">REG_SZ</div>
                            <div style="flex: 2; padding: 2px;">${valueData}</div>
                        `;

                        row.onclick = () => {
                            const newValue = prompt('Edit value for: ' + valueName, valueData);
                            if (newValue !== null) {
                                this.registryUpdateValue(valueName, newValue);
                            }
                        };

                        valuesContainer.appendChild(row);
                    }
                });
            }

            registryAddKey() {
                if (!this.registryState || !this.registryState.currentKey) {
                    alert('Please select a location in the registry tree first.');
                    return;
                }

                const keyName = prompt('Enter new key name:');
                if (keyName && keyName.trim()) {
                    let current = this.registryState.registry;
                    this.registryState.currentKey.forEach(part => {
                        if (!current[part]) current[part] = {};
                        current = current[part];
                    });

                    current[keyName.trim()] = {};
                    this.saveRegistry(this.registryState.registry);
                    this.registryRefresh();
                }
            }

            registryAddValue() {
                if (!this.registryState || !this.registryState.currentKey) {
                    alert('Please select a location in the registry tree first.');
                    return;
                }

                const valueName = prompt('Enter value name:');
                if (valueName !== null) {
                    const valueData = prompt('Enter value data:');
                    if (valueData !== null) {
                        let current = this.registryState.registry;
                        this.registryState.currentKey.forEach(part => {
                            if (!current[part]) current[part] = {};
                            current = current[part];
                        });

                        current[valueName || '(Default)'] = valueData;
                        this.saveRegistry(this.registryState.registry);
                        this.displayRegistryValues(current);
                    }
                }
            }

            registryUpdateValue(valueName, newValue) {
                if (!this.registryState || !this.registryState.currentKey) return;

                let current = this.registryState.registry;
                this.registryState.currentKey.forEach(part => {
                    current = current[part];
                });

                current[valueName] = newValue;
                this.saveRegistry(this.registryState.registry);
                this.displayRegistryValues(current);
            }

            registryDelete() {
                if (!this.registryState || !this.registryState.currentKey) {
                    alert('Please select an item to delete.');
                    return;
                }

                if (confirm('Are you sure you want to delete this key and all its subkeys?')) {
                    let parent = this.registryState.registry;
                    const path = [...this.registryState.currentKey];
                    const keyToDelete = path.pop();

                    path.forEach(part => {
                        parent = parent[part];
                    });

                    delete parent[keyToDelete];
                    this.saveRegistry(this.registryState.registry);
                    this.registryRefresh();
                }
            }

            registryRefresh() {
                const treePanel = document.getElementById('registry-tree');
                if (treePanel) {
                    this.registryState.registry = this.loadRegistry();
                    this.buildRegistryTree(treePanel, this.registryState.registry);
                }
            }

            openTaskManager() {
                const content = document.createElement('div');
                content.style.cssText = 'display: flex; flex-direction: column; height: 100%; background: var(--button-face);';

                // Title bar area
                const header = document.createElement('div');
                header.style.cssText = 'background: var(--button-face); padding: 8px; border-bottom: 2px solid #808080;';
                header.innerHTML = `
                    <h3 style="margin: 0; font-size: 13px;">Task Manager</h3>
                    <div style="font-size: 10px; color: #666; margin-top: 4px;">Windows 95 Simulator</div>
                `;

                // Task list container
                const taskList = document.createElement('div');
                taskList.id = 'task-manager-list';
                taskList.style.cssText = 'flex: 1; overflow-y: auto; background: white; border: 2px inset; margin: 8px;';

                // Buttons
                const buttons = document.createElement('div');
                buttons.style.cssText = 'padding: 8px; border-top: 1px solid #808080; display: flex; gap: 8px; justify-content: flex-end; background: var(--button-face);';
                buttons.innerHTML = `
                    <button class="btn" onclick="emulator.taskManagerRefresh()" style="min-width: 80px;">Refresh</button>
                    <button class="btn" onclick="emulator.taskManagerEndTask()" style="min-width: 80px;">End Task</button>
                    <button class="btn" onclick="emulator.windowManager.closeWindow(this.closest('.window'))" style="min-width: 80px;">Close</button>
                `;

                content.appendChild(header);
                content.appendChild(taskList);
                content.appendChild(buttons);

                const win = this.windowManager.createWindow('Task Manager', content, { width: 450, height: 400 });

                // Populate task list
                this.taskManagerRefresh();

                // Auto-refresh every 2 seconds
                this.taskManagerInterval = setInterval(() => {
                    if (document.getElementById('task-manager-list')) {
                        this.taskManagerRefresh();
                    } else {
                        clearInterval(this.taskManagerInterval);
                    }
                }, 2000);
            }

            taskManagerRefresh() {
                const taskList = document.getElementById('task-manager-list');
                if (!taskList) return;

                taskList.innerHTML = `
                    <div style="background: #000080; color: white; padding: 6px; font-size: 11px; display: grid; grid-template-columns: 2fr 1fr 1fr; font-weight: bold; border-bottom: 1px solid #808080;">
                        <div>Task</div>
                        <div style="text-align: center;">Status</div>
                        <div style="text-align: center;">CPU</div>
                    </div>
                `;

                // Add running windows
                this.windowManager.windows.forEach((win, index) => {
                    const row = document.createElement('div');
                    row.className = 'task-manager-row';
                    row.dataset.windowId = win.id;
                    row.style.cssText = 'display: grid; grid-template-columns: 2fr 1fr 1fr; padding: 6px; font-size: 11px; border-bottom: 1px solid #e0e0e0; cursor: pointer;';
                    row.innerHTML = `
                        <div>${win.title}</div>
                        <div style="text-align: center;">${win.minimized ? 'Minimized' : 'Running'}</div>
                        <div style="text-align: center;">${Math.floor(Math.random() * 15 + 1)}%</div>
                    `;

                    row.onclick = () => {
                        // Highlight selected
                        taskList.querySelectorAll('.task-manager-row').forEach(r => r.style.background = 'white');
                        row.style.background = '#000080';
                        row.style.color = 'white';
                        this.selectedTaskId = win.id;
                    };

                    taskList.appendChild(row);
                });

                // Add system process
                const systemRow = document.createElement('div');
                systemRow.style.cssText = 'display: grid; grid-template-columns: 2fr 1fr 1fr; padding: 6px; font-size: 11px; border-bottom: 1px solid #e0e0e0; color: #666;';
                systemRow.innerHTML = `
                    <div>System Idle Process</div>
                    <div style="text-align: center;">Running</div>
                    <div style="text-align: center;">${Math.floor(100 - this.windowManager.windows.length * 5)}%</div>
                `;
                taskList.appendChild(systemRow);
            }

            taskManagerEndTask() {
                if (!this.selectedTaskId) {
                    alert('Please select a task to end.');
                    return;
                }

                const windowObj = this.windowManager.windows.find(w => w.id === this.selectedTaskId);
                if (windowObj) {
                    if (confirm(`End task "${windowObj.title}"?`)) {
                        this.windowManager.closeWindow(windowObj.element);
                        this.selectedTaskId = null;
                        this.taskManagerRefresh();
                    }
                }
            }

            openControlPanel() {
                const content = document.createElement('div');
                content.style.cssText = 'display: flex; flex-direction: column; height: 100%; background: var(--button-face);';

                // Tabs
                const tabs = document.createElement('div');
                tabs.style.cssText = 'display: flex; border-bottom: 2px solid #808080; background: var(--button-face);';
                tabs.innerHTML = `
                    <button class="cp-tab active" data-tab="display" style="padding: 8px 16px; background: white; border: 2px outset; border-bottom: none; cursor: pointer; font-family: inherit; font-size: 11px;">Display</button>
                    <button class="cp-tab" data-tab="desktop" style="padding: 8px 16px; background: var(--button-face); border: 2px outset; border-bottom: none; cursor: pointer; font-family: inherit; font-size: 11px;">Desktop</button>
                    <button class="cp-tab" data-tab="mouse" style="padding: 8px 16px; background: var(--button-face); border: 2px outset; border-bottom: none; cursor: pointer; font-family: inherit; font-size: 11px;">Mouse</button>
                    <button class="cp-tab" data-tab="sound" style="padding: 8px 16px; background: var(--button-face); border: 2px outset; border-bottom: none; cursor: pointer; font-family: inherit; font-size: 11px;">Sound</button>
                `;

                // Tab content container
                const tabContent = document.createElement('div');
                tabContent.style.cssText = 'flex: 1; overflow-y: auto; padding: 16px;';
                tabContent.innerHTML = this.getControlPanelTabContent('display');

                // Tab switching logic
                tabs.querySelectorAll('.cp-tab').forEach(tab => {
                    tab.addEventListener('click', (e) => {
                        tabs.querySelectorAll('.cp-tab').forEach(t => {
                            t.classList.remove('active');
                            t.style.background = 'var(--button-face)';
                        });
                        tab.classList.add('active');
                        tab.style.background = 'white';
                        const tabName = tab.dataset.tab;
                        tabContent.innerHTML = this.getControlPanelTabContent(tabName);
                        this.initControlPanelHandlers(tabName);
                    });
                });

                // Bottom buttons
                const buttons = document.createElement('div');
                buttons.style.cssText = 'padding: 12px; border-top: 2px solid #808080; text-align: right; background: var(--button-face);';
                buttons.innerHTML = `
                    <button class="btn" onclick="emulator.saveControlPanelSettings(); emulator.windowManager.closeWindow(this.closest('.window'))" style="min-width: 80px; margin-left: 4px;">OK</button>
                    <button class="btn" onclick="emulator.saveControlPanelSettings()" style="min-width: 80px; margin-left: 4px;">Apply</button>
                    <button class="btn" onclick="emulator.windowManager.closeWindow(this.closest('.window'))" style="min-width: 80px; margin-left: 4px;">Cancel</button>
                `;

                content.appendChild(tabs);
                content.appendChild(tabContent);
                content.appendChild(buttons);

                this.windowManager.createWindow('Control Panel', content, { width: 500, height: 450 });
                this.initControlPanelHandlers('display');
            }

            getControlPanelTabContent(tab) {
                const bgColor = SafeStorage.getItem('win95-desktop-color') || '#008080';
                const iconSpacing = SafeStorage.getItem('win95-icon-spacing') || '80';

                switch (tab) {
                    case 'display':
                        return `
                            <div style="background: white; padding: 16px; border: 2px inset;">
                                <h3 style="margin-top: 0;">Display Settings</h3>

                                <div style="margin: 16px 0;">
                                    <label style="display: block; margin-bottom: 8px; font-weight: bold;">Desktop Background Color:</label>
                                    <input type="color" id="cp-bg-color" value="${bgColor}" style="width: 100px; height: 30px; cursor: pointer;">
                                    <span id="cp-bg-preview" style="margin-left: 12px; padding: 4px 12px; background: ${bgColor}; border: 1px solid #000; color: white;">${bgColor}</span>
                                </div>

                                <div style="margin: 16px 0;">
                                    <label style="display: block; margin-bottom: 8px; font-weight: bold;">Screen Resolution:</label>
                                    <select id="cp-resolution" style="padding: 4px;">
                                        <option value="640x480">640 x 480 (Default)</option>
                                        <option value="800x600">800 x 600</option>
                                        <option value="1024x768">1024 x 768</option>
                                    </select>
                                    <div style="margin-top: 8px; padding: 8px; background: #ffffc0; border: 1px solid #808080; font-size: 10px;">
                                        ‚ÑπÔ∏è Resolution changes require restart
                                    </div>
                                </div>
                            </div>
                        `;

                    case 'desktop':
                        return `
                            <div style="background: white; padding: 16px; border: 2px inset;">
                                <h3 style="margin-top: 0;">Desktop Customization</h3>

                                <div style="margin: 16px 0;">
                                    <label style="display: block; margin-bottom: 8px; font-weight: bold;">Wallpaper:</label>
                                    <button class="btn" onclick="emulator.uploadWallpaper()">üìÅ Choose Wallpaper...</button>
                                    <button class="btn" onclick="emulator.removeWallpaper()" style="margin-left: 8px;">üóëÔ∏è Remove</button>
                                    <div id="wallpaper-preview" style="margin-top: 8px; padding: 8px; background: #f0f0f0; border: 1px solid #808080; font-size: 10px; min-height: 60px; display: flex; align-items: center; justify-content: center;">
                                        <span>No wallpaper set</span>
                                    </div>
                                    <input type="file" id="wallpaper-file-input" accept="image/*" style="display: none;">
                                </div>

                                <div style="margin: 16px 0;">
                                    <label style="display: block; margin-bottom: 8px; font-weight: bold;">Icon Spacing:</label>
                                    <input type="range" id="cp-icon-spacing" min="60" max="120" value="${iconSpacing}" style="width: 200px;">
                                    <span id="cp-spacing-value" style="margin-left: 12px;">${iconSpacing}px</span>
                                </div>

                                <div style="margin: 16px 0;">
                                    <label style="display: flex; align-items: center; cursor: pointer;">
                                        <input type="checkbox" id="cp-show-icons" checked style="margin-right: 8px;">
                                        <span>Show desktop icons</span>
                                    </label>
                                </div>

                                <div style="margin: 16px 0;">
                                    <label style="display: flex; align-items: center; cursor: pointer;">
                                        <input type="checkbox" id="cp-show-clock" checked style="margin-right: 8px;">
                                        <span>Show taskbar clock</span>
                                    </label>
                                </div>

                                <div style="margin: 16px 0;">
                                    <button class="btn" onclick="emulator.arrangeIconsGrid()">
                                        üî≤ Arrange Icons in Grid
                                    </button>
                                </div>
                            </div>
                        `;

                    case 'mouse':
                        return `
                            <div style="background: white; padding: 16px; border: 2px inset;">
                                <h3 style="margin-top: 0;">Mouse Settings</h3>

                                <div style="margin: 16px 0;">
                                    <label style="display: flex; align-items: center; cursor: pointer;">
                                        <input type="checkbox" id="cp-enable-mouse-lock" style="margin-right: 8px;">
                                        <span>Enable Mouse Lock (for FPS navigation)</span>
                                    </label>
                                    <div style="margin-top: 8px; padding: 8px; background: #ffffc0; border: 1px solid #808080; font-size: 10px;">
                                        ‚ÑπÔ∏è Keep OFF for normal desktop interaction
                                    </div>
                                </div>

                                <div style="margin: 16px 0;">
                                    <label style="display: block; margin-bottom: 8px; font-weight: bold;">Double-Click Speed:</label>
                                    <input type="range" id="cp-dblclick-speed" min="200" max="800" value="400" style="width: 200px;">
                                    <div style="display: inline-block; margin-left: 12px;">
                                        <span style="margin: 0 8px;">Fast</span>
                                        <span>‚ü∑</span>
                                        <span style="margin: 0 8px;">Slow</span>
                                    </div>
                                </div>
                            </div>
                        `;

                    case 'sound':
                        return `
                            <div style="background: white; padding: 16px; border: 2px inset;">
                                <h3 style="margin-top: 0;">Sound Settings</h3>

                                <div style="margin: 16px 0;">
                                    <label style="display: flex; align-items: center; cursor: pointer;">
                                        <input type="checkbox" id="cp-enable-sound" style="margin-right: 8px;">
                                        <span>Enable system sounds</span>
                                    </label>
                                </div>

                                <div style="margin: 16px 0;">
                                    <label style="display: block; margin-bottom: 8px; font-weight: bold;">Volume:</label>
                                    <input type="range" id="cp-volume" min="0" max="100" value="70" style="width: 200px;">
                                    <span id="cp-volume-value" style="margin-left: 12px;">70%</span>
                                </div>

                                <div style="margin: 16px 0;">
                                    <label style="display: flex; align-items: center; cursor: pointer;">
                                        <input type="checkbox" id="cp-sound-startup" checked style="margin-right: 8px;">
                                        <span>Play Windows startup sound</span>
                                    </label>
                                </div>

                                <div style="margin: 16px 0;">
                                    <label style="display: flex; align-items: center; cursor: pointer;">
                                        <input type="checkbox" id="cp-sound-shutdown" checked style="margin-right: 8px;">
                                        <span>Play Windows shutdown sound</span>
                                    </label>
                                </div>
                            </div>
                        `;

                    default:
                        return '<div>Unknown tab</div>';
                }
            }

            initControlPanelHandlers(tab) {
                if (tab === 'display') {
                    const bgColorInput = document.getElementById('cp-bg-color');
                    const bgPreview = document.getElementById('cp-bg-preview');

                    if (bgColorInput && bgPreview) {
                        bgColorInput.addEventListener('input', (e) => {
                            bgPreview.style.background = e.target.value;
                            bgPreview.textContent = e.target.value;
                        });
                    }
                } else if (tab === 'desktop') {
                    const spacingInput = document.getElementById('cp-icon-spacing');
                    const spacingValue = document.getElementById('cp-spacing-value');

                    if (spacingInput && spacingValue) {
                        spacingInput.addEventListener('input', (e) => {
                            spacingValue.textContent = e.target.value + 'px';
                        });
                    }

                    // Wallpaper file input handler
                    const wallpaperInput = document.getElementById('wallpaper-file-input');
                    if (wallpaperInput) {
                        wallpaperInput.addEventListener('change', (e) => {
                            const file = e.target.files[0];
                            if (file && file.type.startsWith('image/')) {
                                const reader = new FileReader();
                                reader.onload = (event) => {
                                    const imageData = event.target.result;
                                    SafeStorage.setItem('win95-wallpaper', imageData);
                                    this.updateWallpaperPreview(imageData);
                                    this.applyWallpaper(imageData);
                                };
                                reader.readAsDataURL(file);
                            }
                        });
                    }

                    // Load and display current wallpaper preview
                    const savedWallpaper = SafeStorage.getItem('win95-wallpaper');
                    if (savedWallpaper) {
                        this.updateWallpaperPreview(savedWallpaper);
                    }
                } else if (tab === 'sound') {
                    const volumeInput = document.getElementById('cp-volume');
                    const volumeValue = document.getElementById('cp-volume-value');

                    if (volumeInput && volumeValue) {
                        volumeInput.addEventListener('input', (e) => {
                            volumeValue.textContent = e.target.value + '%';
                        });
                    }
                }
            }

            saveControlPanelSettings() {
                // Display settings
                const bgColor = document.getElementById('cp-bg-color')?.value;
                if (bgColor) {
                    SafeStorage.setItem('win95-desktop-color', bgColor);
                    const desktop = document.querySelector('.desktop');
                    if (desktop) desktop.style.background = bgColor;
                }

                // Desktop settings
                const iconSpacing = document.getElementById('cp-icon-spacing')?.value;
                if (iconSpacing) {
                    SafeStorage.setItem('win95-icon-spacing', iconSpacing);
                }

                const showIcons = document.getElementById('cp-show-icons')?.checked;
                if (showIcons !== undefined) {
                    const desktopIcons = document.getElementById('desktop-icons');
                    if (desktopIcons) {
                        desktopIcons.style.display = showIcons ? 'flex' : 'none';
                    }
                }

                console.log('Control Panel settings saved');
                alert('Settings have been applied!');
            }

            arrangeIconsGrid() {
                // Arrange desktop icons in a neat grid
                const icons = document.querySelectorAll('.desktop-icon');
                const spacing = parseInt(SafeStorage.getItem('win95-icon-spacing') || '80');
                let x = 20, y = 20;

                icons.forEach((icon, index) => {
                    icon.style.left = x + 'px';
                    icon.style.top = y + 'px';

                    y += spacing;
                    if (y > 400) {
                        y = 20;
                        x += spacing + 20;
                    }
                });

                alert('Icons arranged in grid!');
            }

            uploadWallpaper() {
                const fileInput = document.getElementById('wallpaper-file-input');
                if (fileInput) {
                    fileInput.click();
                }
            }

            removeWallpaper() {
                SafeStorage.removeItem('win95-wallpaper');
                const screenContainer = document.getElementById('screen_container');
                if (screenContainer) {
                    screenContainer.style.backgroundImage = 'none';
                    screenContainer.style.background = SafeStorage.getItem('win95-desktop-color') || '#008080';
                }

                // Update preview if in control panel
                const preview = document.getElementById('wallpaper-preview');
                if (preview) {
                    preview.innerHTML = '<span>No wallpaper set</span>';
                }

                alert('Wallpaper removed!');
            }

            updateWallpaperPreview(imageData) {
                const preview = document.getElementById('wallpaper-preview');
                if (preview) {
                    preview.innerHTML = `<img src="${imageData}" style="max-width: 100%; max-height: 100px; object-fit: contain;">`;
                }
            }

            applyWallpaper(imageData) {
                const screenContainer = document.getElementById('screen_container');
                if (screenContainer && imageData) {
                    screenContainer.style.backgroundImage = `url(${imageData})`;
                    screenContainer.style.backgroundSize = 'cover';
                    screenContainer.style.backgroundPosition = 'center';
                    screenContainer.style.backgroundRepeat = 'no-repeat';
                }
            }

            loadWallpaper() {
                const wallpaper = SafeStorage.getItem('win95-wallpaper');
                if (wallpaper) {
                    this.applyWallpaper(wallpaper);
                }
            }

            openAbout() {
                const content = `
                    <div style="text-align: center; padding: 20px;">
                        <div style="font-size: 32px; margin-bottom: 10px;">üíª</div>
                        <h3 style="margin: 10px 0;">Windows 95 Desktop Simulator</h3>
                        <p style="margin: 10px 0;">Interactive Edition v4.0</p>
                        <hr style="margin: 15px 0;">
                        <p style="margin: 10px 0; text-align: left;">
                            <strong>Programs:</strong><br>
                            ‚Ä¢ Internet Explorer - Browse real websites<br>
                            ‚Ä¢ LocalFirst Tools - Browse 150+ web tools<br>
                            ‚Ä¢ Paint - Drawing application<br>
                            ‚Ä¢ Media Player - Audio/Video player<br>
                            ‚Ä¢ File Explorer - Browse mock file system<br>
                            ‚Ä¢ Linux Terminal - Full bash emulation<br>
                            ‚Ä¢ Notepad - Text editor<br>
                            ‚Ä¢ Calculator - Math operations<br>
                            ‚Ä¢ Minesweeper - Classic game<br>
                            ‚Ä¢ Solitaire - Card game<br>
                            ‚Ä¢ System Properties - View system info
                        </p>
                        <hr style="margin: 15px 0;">
                        <p style="margin: 10px 0; text-align: left;">
                            <strong>Features:</strong><br>
                            ‚Ä¢ Draggable windows<br>
                            ‚Ä¢ Functional Start menu<br>
                            ‚Ä¢ Real-time clock<br>
                            ‚Ä¢ Desktop icons & context menus<br>
                            ‚Ä¢ 20+ Linux commands<br>
                            ‚Ä¢ Command history (‚Üë/‚Üì arrows)<br>
                            ‚Ä¢ Virtual filesystem<br>
                            ‚Ä¢ Authentic Win95 aesthetics
                        </p>
                        <hr style="margin: 15px 0;">
                        <p style="font-size: 10px; color: #808080;">
                            Built with pure HTML, CSS, and JavaScript<br>
                            No external dependencies ‚Ä¢ Local-first design<br>
                            <br>
                            Created by Claude Code
                        </p>
                    </div>
                `;
                this.windowManager.createWindow('About Windows 95', content, { width: 400, height: 600 });
            }

            // LocalFirst Tools Browser
            openLocalFirstBrowser() {
                const content = document.createElement('div');
                content.className = 'tools-browser-container';

                // Create header with search and filter
                const header = document.createElement('div');
                header.className = 'tools-browser-header';

                const title = document.createElement('div');
                title.style.cssText = 'font-weight: bold; margin-bottom: 8px; font-size: 12px;';
                title.textContent = 'üåê LocalFirst Tools Browser';
                header.appendChild(title);

                const searchRow = document.createElement('div');
                searchRow.className = 'tools-search-row';

                const searchInput = document.createElement('input');
                searchInput.type = 'text';
                searchInput.className = 'tools-search-input';
                searchInput.placeholder = 'Search tools...';
                searchInput.id = 'tools-search-input';
                searchRow.appendChild(searchInput);

                const categorySelect = document.createElement('select');
                categorySelect.className = 'tools-category-select';
                categorySelect.id = 'tools-category-select';
                categorySelect.innerHTML = '<option value="">All Categories</option>';
                searchRow.appendChild(categorySelect);

                header.appendChild(searchRow);

                const resultsCounter = document.createElement('div');
                resultsCounter.className = 'tools-results-counter';
                resultsCounter.id = 'tools-results-counter';
                resultsCounter.textContent = 'Loading tools...';
                header.appendChild(resultsCounter);

                content.appendChild(header);

                // Create tools grid container
                const toolsGrid = document.createElement('div');
                toolsGrid.className = 'tools-grid';
                toolsGrid.id = 'tools-grid';

                // Show loading state
                toolsGrid.innerHTML = `
                    <div class="tools-loading" style="grid-column: 1 / -1;">
                        <div class="tools-loading-spinner"></div>
                        <div>Loading LocalFirst Tools...</div>
                    </div>
                `;

                content.appendChild(toolsGrid);

                // Create status bar
                const statusBar = document.createElement('div');
                statusBar.className = 'tools-status-bar';
                statusBar.id = 'tools-status-bar';
                statusBar.textContent = 'Connecting to GitHub Pages...';
                content.appendChild(statusBar);

                this.windowManager.createWindow('LocalFirst Tools Browser', content, { width: 800, height: 600 });

                // Fetch and display tools
                this.fetchAndDisplayTools();
            }

            async fetchAndDisplayTools() {
                const CONFIG_URL = 'https://kody-w.github.io/localFirstTools/vibe_gallery_config.json';
                const BASE_URL = 'https://kody-w.github.io/localFirstTools/';

                const toolsGrid = document.getElementById('tools-grid');
                const statusBar = document.getElementById('tools-status-bar');
                const resultsCounter = document.getElementById('tools-results-counter');
                const categorySelect = document.getElementById('tools-category-select');
                const searchInput = document.getElementById('tools-search-input');

                if (!toolsGrid || !statusBar) return;

                try {
                    statusBar.textContent = 'Fetching tools from GitHub Pages...';

                    const response = await fetch(CONFIG_URL);
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    const config = await response.json();

                    // Extract all tools from all categories
                    const allTools = [];
                    const categories = new Map();

                    for (const [categoryKey, categoryData] of Object.entries(config.categories || {})) {
                        categories.set(categoryKey, categoryData);

                        if (categoryData.tools && Array.isArray(categoryData.tools)) {
                            categoryData.tools.forEach(tool => {
                                allTools.push({
                                    ...tool,
                                    category: categoryKey,
                                    categoryName: categoryData.name,
                                    categoryColor: categoryData.color
                                });
                            });
                        }
                    }

                    // Store for filtering
                    this.toolsBrowserState = {
                        allTools: allTools,
                        categories: categories,
                        baseUrl: BASE_URL,
                        currentSearch: '',
                        currentCategory: ''
                    };

                    // Populate category dropdown
                    const sortedCategories = Array.from(categories.entries()).sort((a, b) =>
                        a[1].name.localeCompare(b[1].name)
                    );

                    sortedCategories.forEach(([key, data]) => {
                        const option = document.createElement('option');
                        option.value = key;
                        option.textContent = data.name;
                        categorySelect.appendChild(option);
                    });

                    // Set up search with debounce
                    let searchTimeout;
                    searchInput.addEventListener('input', (e) => {
                        clearTimeout(searchTimeout);
                        searchTimeout = setTimeout(() => {
                            this.toolsBrowserState.currentSearch = e.target.value.toLowerCase();
                            this.filterAndDisplayTools();
                        }, 250);
                    });

                    // Set up category filter
                    categorySelect.addEventListener('change', (e) => {
                        this.toolsBrowserState.currentCategory = e.target.value;
                        this.filterAndDisplayTools();
                    });

                    // Initial display
                    this.filterAndDisplayTools();

                    statusBar.textContent = `Loaded ${allTools.length} tools from ${categories.size} categories`;

                } catch (error) {
                    console.error('Failed to fetch tools:', error);
                    toolsGrid.innerHTML = `
                        <div class="tools-error" style="grid-column: 1 / -1;">
                            <div class="tools-error-icon">‚ö†Ô∏è</div>
                            <div style="font-weight: bold; margin-bottom: 8px;">Failed to Load Tools</div>
                            <div style="margin-bottom: 12px;">${error.message}</div>
                            <button class="btn" onclick="emulator.fetchAndDisplayTools()">
                                üîÑ Retry
                            </button>
                        </div>
                    `;
                    statusBar.textContent = 'Error: Could not connect to GitHub Pages';
                    resultsCounter.textContent = 'Failed to load tools';
                }
            }

            filterAndDisplayTools() {
                const state = this.toolsBrowserState;
                if (!state) return;

                const toolsGrid = document.getElementById('tools-grid');
                const resultsCounter = document.getElementById('tools-results-counter');
                if (!toolsGrid) return;

                // Filter tools
                let filteredTools = state.allTools;

                // Apply category filter
                if (state.currentCategory) {
                    filteredTools = filteredTools.filter(tool => tool.category === state.currentCategory);
                }

                // Apply search filter
                if (state.currentSearch) {
                    filteredTools = filteredTools.filter(tool => {
                        const searchStr = state.currentSearch;
                        return (
                            (tool.title || '').toLowerCase().includes(searchStr) ||
                            (tool.description || '').toLowerCase().includes(searchStr) ||
                            (tool.path || '').toLowerCase().includes(searchStr) ||
                            (tool.tags || []).some(tag => tag.toLowerCase().includes(searchStr))
                        );
                    });
                }

                // Update counter
                if (resultsCounter) {
                    resultsCounter.textContent = `Showing ${filteredTools.length} tool${filteredTools.length !== 1 ? 's' : ''}`;
                }

                // Display tools
                if (filteredTools.length === 0) {
                    toolsGrid.innerHTML = `
                        <div class="tools-empty" style="grid-column: 1 / -1;">
                            <div style="font-size: 48px; margin-bottom: 12px;">üì≠</div>
                            <div style="font-weight: bold; margin-bottom: 8px;">No Tools Found</div>
                            <div>Try adjusting your search or filter</div>
                        </div>
                    `;
                    return;
                }

                toolsGrid.innerHTML = '';

                filteredTools.forEach(tool => {
                    const card = this.createToolCard(tool);
                    toolsGrid.appendChild(card);
                });
            }

            createToolCard(tool) {
                const card = document.createElement('div');
                card.className = 'tool-card';

                // Title
                const title = document.createElement('div');
                title.className = 'tool-card-title';
                title.textContent = tool.title || 'Untitled Tool';
                card.appendChild(title);

                // Description
                const description = document.createElement('div');
                description.className = 'tool-card-description';
                const desc = tool.description || 'No description available';
                description.textContent = desc.length > 100 ? desc.substring(0, 100) + '...' : desc;
                card.appendChild(description);

                // Meta container
                const meta = document.createElement('div');
                meta.className = 'tool-card-meta';

                // Category badge
                const badge = document.createElement('div');
                badge.className = 'category-badge';
                badge.textContent = tool.categoryName || tool.category || 'Uncategorized';
                badge.style.backgroundColor = tool.categoryColor || '#808080';
                meta.appendChild(badge);

                // Tags (first 3)
                if (tool.tags && tool.tags.length > 0) {
                    const tagsContainer = document.createElement('div');
                    tagsContainer.className = 'tool-tags';

                    const displayTags = tool.tags.slice(0, 3);
                    displayTags.forEach(tag => {
                        const tagPill = document.createElement('span');
                        tagPill.className = 'tag-pill';
                        tagPill.textContent = tag;
                        tagsContainer.appendChild(tagPill);
                    });

                    if (tool.tags.length > 3) {
                        const morePill = document.createElement('span');
                        morePill.className = 'tag-pill';
                        morePill.textContent = `+${tool.tags.length - 3} more`;
                        morePill.style.fontStyle = 'italic';
                        tagsContainer.appendChild(morePill);
                    }

                    meta.appendChild(tagsContainer);
                }

                card.appendChild(meta);

                // Open button
                const button = document.createElement('button');
                button.className = 'btn tool-card-button';
                button.textContent = 'üöÄ Open Tool';
                button.onclick = (e) => {
                    e.stopPropagation();
                    this.openToolInWindow(tool);
                };
                card.appendChild(button);

                // Make entire card clickable
                card.onclick = () => {
                    this.openToolInWindow(tool);
                };

                return card;
            }

            openToolInWindow(tool) {
                const state = this.toolsBrowserState;
                if (!state) return;

                const toolWindow = document.createElement('div');
                toolWindow.style.cssText = 'width: 100%; height: 100%; background: white; display: flex; flex-direction: column;';

                // Add toolbar
                const toolbar = document.createElement('div');
                toolbar.style.cssText = 'background: var(--button-face); padding: 4px; border-bottom: 1px solid var(--button-shadow); display: flex; gap: 4px; align-items: center;';

                const urlDisplay = document.createElement('input');
                urlDisplay.type = 'text';
                urlDisplay.readOnly = true;
                urlDisplay.value = state.baseUrl + tool.path;
                urlDisplay.style.cssText = 'flex: 1; padding: 2px 4px; border: 1px solid var(--button-shadow); box-shadow: inset -1px -1px 0 var(--button-highlight); font-family: monospace; font-size: 10px; background: white;';
                toolbar.appendChild(urlDisplay);

                const refreshBtn = document.createElement('button');
                refreshBtn.className = 'btn';
                refreshBtn.textContent = 'üîÑ';
                refreshBtn.title = 'Refresh';
                refreshBtn.onclick = () => {
                    iframe.src = iframe.src; // Force reload
                };
                toolbar.appendChild(refreshBtn);

                const newTabBtn = document.createElement('button');
                newTabBtn.className = 'btn';
                newTabBtn.textContent = 'üîó';
                newTabBtn.title = 'Open in new tab';
                newTabBtn.onclick = () => {
                    window.open(state.baseUrl + tool.path, '_blank');
                };
                toolbar.appendChild(newTabBtn);

                toolWindow.appendChild(toolbar);

                // Add iframe
                const iframe = document.createElement('iframe');
                iframe.src = state.baseUrl + tool.path;
                iframe.style.cssText = 'flex: 1; border: none; background: white;';
                iframe.sandbox = 'allow-scripts allow-same-origin allow-forms allow-popups allow-modals allow-downloads';

                // Add loading indicator
                const loading = document.createElement('div');
                loading.style.cssText = 'position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); display: flex; flex-direction: column; align-items: center; gap: 10px;';
                loading.innerHTML = '<div class="tools-loading-spinner"></div><div>Loading tool...</div>';

                const iframeContainer = document.createElement('div');
                iframeContainer.style.cssText = 'flex: 1; position: relative; background: white;';
                iframeContainer.appendChild(loading);
                iframeContainer.appendChild(iframe);

                iframe.onload = () => {
                    loading.remove();
                };

                toolWindow.appendChild(iframeContainer);

                this.windowManager.createWindow(tool.title || 'LocalFirst Tool', toolWindow, { width: 900, height: 700 });
            }

            // Taskbar management
            addTaskbarButton(windowObj) {
                const button = document.createElement('button');
                button.className = 'taskbar-button';
                button.textContent = windowObj.title;
                button.dataset.windowId = windowObj.id;
                button.onclick = () => {
                    if (windowObj.minimized) {
                        this.windowManager.restoreWindow(windowObj.element);
                    } else {
                        this.windowManager.focusWindow(windowObj.element);
                    }
                };

                // Insert before system tray
                const canvas = document.getElementById('screen');
                if (canvas) {
                    const ctx = canvas.getContext('2d');
                    // Add to taskbar visually (this is a simplification)
                }

                this.taskbarButtons.push({ windowObj, button });
            }

            removeTaskbarButton(windowObj) {
                const index = this.taskbarButtons.findIndex(tb => tb.windowObj.id === windowObj.id);
                if (index > -1) {
                    this.taskbarButtons.splice(index, 1);
                }
            }

            updateTaskbarButtons() {
                // Update active state of taskbar buttons
                this.taskbarButtons.forEach(tb => {
                    const isActive = tb.windowObj.element.classList.contains('active');
                    if (isActive) {
                        tb.button.classList.add('active');
                    } else {
                        tb.button.classList.remove('active');
                    }
                });
            }

            initEmulatorCore() {
                console.log("Initializing x86 emulator core...");
                console.log("WebAssembly support:", typeof WebAssembly !== 'undefined');

                // Load saved desktop customization
                this.loadDesktopCustomization();
            }

            loadDesktopCustomization() {
                // Apply saved desktop background color
                const savedBgColor = SafeStorage.getItem('win95-desktop-color');
                if (savedBgColor) {
                    setTimeout(() => {
                        const screenContainer = document.getElementById('screen_container');
                        if (screenContainer) {
                            screenContainer.style.background = savedBgColor;
                            console.log('Applied saved desktop color:', savedBgColor);
                        }
                    }, 100);
                }

                // Load and apply wallpaper
                setTimeout(() => {
                    this.loadWallpaper();
                }, 150);
            }

            detectSystemInfo() {
                // Detect browser
                const ua = navigator.userAgent;
                let browser = 'Unknown';
                if (ua.indexOf('Firefox') > -1) browser = 'Mozilla Firefox';
                else if (ua.indexOf('Chrome') > -1) browser = 'Google Chrome';
                else if (ua.indexOf('Safari') > -1) browser = 'Apple Safari';
                else if (ua.indexOf('Edge') > -1) browser = 'Microsoft Edge';
                else if (ua.indexOf('MSIE') > -1 || ua.indexOf('Trident') > -1) browser = 'Internet Explorer';

                // Check WebAssembly support
                const wasmSupport = typeof WebAssembly !== 'undefined' ? 
                    '<span style="color: green;">‚úì Supported</span>' : 
                    '<span style="color: red;">‚úó Not Supported</span>';

                // Get screen info
                const screenInfo = `${window.screen.width}x${window.screen.height}`;

                // Update UI
                setTimeout(() => {
                    const browserInfo = document.getElementById('browser-info');
                    const wasmInfo = document.getElementById('wasm-support');
                    const screenInfoEl = document.getElementById('screen-info');
                    
                    if (browserInfo) browserInfo.innerHTML = browser;
                    if (wasmInfo) wasmInfo.innerHTML = wasmSupport;
                    if (screenInfoEl) screenInfoEl.textContent = screenInfo;
                }, 100);
            }

            initDOMCache() {
                if (this.domCache) return;

                try {
                    this.domCache = {
                        fpsCounter: document.getElementById('fps-counter'),
                        timeDisplay: document.getElementById('time-display'),
                        cpuLed: document.getElementById('cpu-led'),
                        cpuStatus: document.getElementById('cpu-status'),
                        hddLed: document.getElementById('hdd-led'),
                        loadingScreen: document.getElementById('loading-screen'),
                        loadingText: document.getElementById('loading-text'),
                        progressFill: document.getElementById('progress-fill'),
                        setupScreen: document.getElementById('setup-screen'),
                        emulatorContainer: document.getElementById('emulator-container'),
                        emulatorTitlebar: document.getElementById('emulator-titlebar'),
                        memoryUsage: document.getElementById('memory-usage'),
                        pauseBtn: document.getElementById('pause-btn')
                    };
                } catch (error) {
                    console.error('Failed to initialize DOM cache:', error);
                    throw new Error('Required DOM elements not found');
                }
            }

            async loadDemo() {
                try {
                    this.showLoading('Initializing emulator...');
                    this.initDOMCache();

                    // Read settings
                    this.updateSettings();

                    this.canvas = document.getElementById('screen');
                    if (!this.canvas) {
                        throw new Error('Canvas element not found');
                    }

                    this.ctx = this.canvas.getContext('2d', {
                        alpha: false,
                        desynchronized: true,
                        willReadFrequently: false
                    });

                    if (!this.ctx) {
                        throw new Error('Could not get 2D rendering context. Canvas may be disabled.');
                    }

                    // Calculate available viewport size dynamically
                    // Header will be hidden, so don't account for it
                    const statusBar = document.querySelector('.status-bar');
                    const statusBarHeight = statusBar ? statusBar.offsetHeight : 22;

                    const availableWidth = window.innerWidth;
                    const availableHeight = window.innerHeight - statusBarHeight;

                    // Set canvas to fill available space
                    this.canvas.width = availableWidth;
                    this.canvas.height = availableHeight;

                    // Update CONFIG to match actual dimensions
                    CONFIG.DISPLAY.WIDTH = availableWidth;
                    CONFIG.DISPLAY.HEIGHT = availableHeight;
                    CONFIG.DISPLAY.TASKBAR_HEIGHT = Math.max(30, Math.floor(availableHeight * 0.0625));

                    this.domCache.setupScreen.classList.add('hidden');
                    this.domCache.emulatorContainer.classList.remove('hidden');

                    // Hide header and info panel for immersive OS experience
                    const header = document.querySelector('.header');
                    const infoPanel = document.getElementById('info-panel');
                    if (header) header.classList.add('hidden');
                    if (infoPanel) infoPanel.classList.add('hidden');

                    await this.simulateBoot();

                    this.hideLoading();
                    this.startEmulation();
                    
                    // Setup mouse capture
                    this.setupMouseCapture();
                } catch (error) {
                    console.error('Failed to load demo:', error);
                    alert(`Failed to start emulator: ${error.message}\n\nPlease check console for details.`);
                    this.hideLoading();
                }
            }

            updateSettings() {
                try {
                    const memorySelect = document.getElementById('memory-size');
                    const cpuSpeedSelect = document.getElementById('cpu-speed');
                    const enableMouse = document.getElementById('enable-mouse');
                    const enableSound = document.getElementById('enable-sound');
                    const enableNetwork = document.getElementById('enable-network');

                    this.settings.memory = parseInt(memorySelect.value) * 1024 * 1024;
                    this.settings.cpuSpeed = parseInt(cpuSpeedSelect.value);
                    this.settings.enableMouse = enableMouse.checked;
                    this.settings.enableSound = enableSound.checked;
                    this.settings.enableNetwork = enableNetwork.checked;

                    console.log('Settings updated:', this.settings);
                } catch (error) {
                    console.error('Failed to update settings:', error);
                }
            }

            setupMouseCapture() {
                // Disabled pointer lock for interactive desktop mode
                // Users need free mouse movement to interact with windows and icons
                return;
            }

            async simulateBoot() {
                const bootMessages = [
                    'PhoenixBIOS 4.0 Release 6.0',
                    'Copyright 1985-1995 Phoenix Technologies Ltd.',
                    'All Rights Reserved',
                    '',
                    'CPU: Intel Pentium ' + (this.settings.cpuSpeed * 75) + 'MHz',
                    'Memory Test: ' + (this.settings.memory / 1024) + 'K OK',
                    'Cache: 256K',
                    '',
                    'Press DEL to enter SETUP, ESC to skip memory test',
                    '',
                    'Detecting IDE drives...',
                    'Primary Master: 540MB Hard Disk',
                    'Primary Slave: None',
                    'Secondary Master: CD-ROM Drive',
                    'Secondary Slave: None',
                    '',
                    'Starting MS-DOS...',
                    '',
                    'HIMEM is testing extended memory...done.',
                    'EMM386 Memory Manager v4.49',
                    '',
                    'C:\\>win',
                    '',
                    'Starting Windows 95...'
                ];

                this.ctx.fillStyle = '#000000';
                this.ctx.fillRect(0, 0, CONFIG.DISPLAY.WIDTH, CONFIG.DISPLAY.HEIGHT);
                this.ctx.font = '14px monospace';
                this.ctx.fillStyle = '#c0c0c0';

                for (let i = 0; i < bootMessages.length; i++) {
                    await this.delay(CONFIG.ANIMATION.BOOT_MESSAGE_DELAY);
                    this.ctx.fillText(bootMessages[i], 10, 20 + i * 16);
                    this.updateProgress((i + 1) / bootMessages.length * 50);
                    this.updateLoadingText('Loading BIOS...');
                }

                await this.delay(500);
                this.updateLoadingText('Loading Windows 95...');

                // Clear screen
                this.ctx.fillStyle = '#000000';
                this.ctx.fillRect(0, 0, CONFIG.DISPLAY.WIDTH, CONFIG.DISPLAY.HEIGHT);

                // Draw Windows logo with gradient
                const gradient = this.ctx.createLinearGradient(200, 200, 440, 280);
                gradient.addColorStop(0, '#ff0000');
                gradient.addColorStop(0.25, '#ffff00');
                gradient.addColorStop(0.5, '#00ff00');
                gradient.addColorStop(1, '#0000ff');

                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(220, 200, 200, 80);

                // Add shine effect
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                this.ctx.fillRect(220, 200, 200, 20);

                // Windows text
                this.ctx.fillStyle = '#ffffff';
                this.ctx.font = 'bold 24px Arial';
                this.ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                this.ctx.shadowBlur = 4;
                this.ctx.fillText('Windows 95', 250, 320);
                this.ctx.shadowBlur = 0;

                // Progress bar
                this.ctx.strokeStyle = '#c0c0c0';
                this.ctx.strokeRect(220, 340, 200, 10);

                // Animate progress
                for (let i = 0; i <= 100; i += 5) {
                    await this.delay(40);
                    this.ctx.fillStyle = '#0000ff';
                    this.ctx.fillRect(221, 341, (198 * i) / 100, 8);
                    this.updateProgress(50 + i / 2);
                }

                this.updateLoadingText('Starting desktop...');
            }

            drawDesktop() {
                const taskbarY = CONFIG.DISPLAY.HEIGHT - CONFIG.DISPLAY.TASKBAR_HEIGHT;

                // Draw desktop background
                this.ctx.fillStyle = CONFIG.COLORS.DESKTOP;
                this.ctx.fillRect(0, 0, CONFIG.DISPLAY.WIDTH, CONFIG.DISPLAY.HEIGHT);

                // Draw taskbar with gradient
                const taskbarGrad = this.ctx.createLinearGradient(0, taskbarY, 0, CONFIG.DISPLAY.HEIGHT);
                taskbarGrad.addColorStop(0, '#dfdfdf');
                taskbarGrad.addColorStop(1, '#c0c0c0');
                this.ctx.fillStyle = taskbarGrad;
                this.ctx.fillRect(0, taskbarY, CONFIG.DISPLAY.WIDTH, CONFIG.DISPLAY.TASKBAR_HEIGHT);

                // Taskbar border
                this.ctx.strokeStyle = '#ffffff';
                this.ctx.beginPath();
                this.ctx.moveTo(0, taskbarY);
                this.ctx.lineTo(CONFIG.DISPLAY.WIDTH, taskbarY);
                this.ctx.stroke();

                // Start button with gradient
                const startY = taskbarY + 2;
                const startHeight = CONFIG.DISPLAY.TASKBAR_HEIGHT - 4;
                const startGrad = this.ctx.createLinearGradient(2, startY, 2, startY + startHeight);
                startGrad.addColorStop(0, '#ffffff');
                startGrad.addColorStop(0.5, '#c0c0c0');
                startGrad.addColorStop(1, '#808080');
                this.ctx.fillStyle = startGrad;
                this.ctx.fillRect(2, startY, 60, startHeight);

                // Start button border
                this.ctx.strokeStyle = '#ffffff';
                this.ctx.strokeRect(2, startY, 60, startHeight);
                this.ctx.strokeStyle = '#808080';
                this.ctx.strokeRect(3, startY + 1, 58, startHeight - 2);

                // Start text
                this.ctx.fillStyle = '#000000';
                this.ctx.font = 'bold 11px Arial';
                const textY = startY + (startHeight / 2) + 4;
                this.ctx.fillText('Start', 20, textY);

                // Windows logo on button
                const logoY = startY + (startHeight / 2) - 4;
                this.ctx.fillStyle = '#ff0000';
                this.ctx.fillRect(6, logoY, 4, 4);
                this.ctx.fillStyle = '#00ff00';
                this.ctx.fillRect(10, logoY, 4, 4);
                this.ctx.fillStyle = '#0000ff';
                this.ctx.fillRect(6, logoY + 4, 4, 4);
                this.ctx.fillStyle = '#ffff00';
                this.ctx.fillRect(10, logoY + 4, 4, 4);

                // System tray
                const trayY = taskbarY + 3;
                const trayHeight = CONFIG.DISPLAY.TASKBAR_HEIGHT - 6;
                this.ctx.fillStyle = '#808080';
                this.ctx.fillRect(CONFIG.DISPLAY.WIDTH - 100, trayY, 96, trayHeight);
                this.ctx.strokeStyle = '#000000';
                this.ctx.strokeRect(CONFIG.DISPLAY.WIDTH - 100, trayY, 96, trayHeight);

                // Clock
                const now = new Date();
                const timeStr = now.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
                this.ctx.fillStyle = '#000000';
                this.ctx.font = '11px Arial';
                const clockY = trayY + (trayHeight / 2) + 4;
                this.ctx.fillText(timeStr, CONFIG.DISPLAY.WIDTH - 50, clockY);
            }

            startEmulation() {
                this.isRunning = true;
                this.startTime = Date.now();
                this.drawDesktop();

                // Create interactive desktop icons
                this.createDesktopIcon(20, 20, 'My Computer', 'üíª', () => this.openFileExplorer());
                this.createDesktopIcon(20, 90, 'Internet Explorer', 'üåê', () => this.openInternetExplorer());
                this.createDesktopIcon(20, 160, 'Recycle Bin', 'üóëÔ∏è', () => alert('Recycle Bin is empty'));
                this.createDesktopIcon(100, 20, 'MS-DOS Prompt', '‚¨õ', () => this.openDOSPrompt());
                this.createDesktopIcon(100, 90, 'Paint', 'üé®', () => this.openPaint());
                this.createDesktopIcon(100, 160, 'Notepad', 'üìù', () => this.openNotepad());

                // Create Start menu
                this.createStartMenu();

                // Setup desktop click handlers
                this.setupDesktopInteractions();

                // Start animation loop
                this.updateStatus();
                this.animate();

                // Start clock update (every second)
                this.clockInterval = setInterval(() => {
                    this.updateSystemClock();
                }, 1000);
            }

            createDesktopIcon(x, y, label, emoji, onClick) {
                const icon = {
                    x, y, label, emoji, onClick,
                    width: 48, height: 64,
                    selected: false
                };
                this.desktop.icons.push(icon);

                // Draw initial icon
                this.drawIcon(x, y, label, emoji, false);

                return icon;
            }

            setupDesktopInteractions() {
                const canvas = document.getElementById('screen');
                if (!canvas) return;

                // Handle icon clicks
                canvas.addEventListener('click', (e) => {
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;

                    // Check if clicking on an icon
                    let clickedIcon = null;
                    for (const icon of this.desktop.icons) {
                        if (x >= icon.x && x <= icon.x + icon.width &&
                            y >= icon.y && y <= icon.y + icon.height) {
                            clickedIcon = icon;
                            break;
                        }
                    }

                    // Handle icon selection and double-click
                    if (clickedIcon) {
                        const now = Date.now();
                        if (clickedIcon.lastClick && now - clickedIcon.lastClick < 400) {
                            // Double-click
                            if (clickedIcon.onClick) {
                                clickedIcon.onClick();
                            }
                        } else {
                            // Single click - select
                            this.desktop.icons.forEach(ic => {
                                ic.selected = (ic === clickedIcon);
                                this.drawIcon(ic.x, ic.y, ic.label, ic.emoji, ic.selected);
                            });
                        }
                        clickedIcon.lastClick = now;
                    } else {
                        // Clicking on desktop background
                        const now = Date.now();
                        if (this.lastDesktopClick && now - this.lastDesktopClick < 400) {
                            // Double-click on desktop - minimize all windows (Show Desktop)
                            if (this.windowManager) {
                                this.windowManager.minimizeAllWindows();
                            }
                            this.lastDesktopClick = null; // Reset to prevent triple-click
                        } else {
                            // Single click - deselect all icons
                            this.desktop.icons.forEach(ic => {
                                if (ic.selected) {
                                    ic.selected = false;
                                    this.drawIcon(ic.x, ic.y, ic.label, ic.emoji, false);
                                }
                            });
                            this.lastDesktopClick = now;
                        }
                    }

                    // Check if clicking on Start button
                    const taskbarY = CONFIG.DISPLAY.HEIGHT - CONFIG.DISPLAY.TASKBAR_HEIGHT;
                    if (y >= taskbarY && y <= CONFIG.DISPLAY.HEIGHT && x >= 2 && x <= 62) {
                        this.toggleStartMenu();
                    } else {
                        // Close start menu if clicking elsewhere
                        const startMenu = document.getElementById('start-menu');
                        if (startMenu && startMenu.classList.contains('active')) {
                            if (x < 0 || x > 200 || y < taskbarY - 200) {
                                startMenu.classList.remove('active');
                            }
                        }
                    }
                });

                // Handle right-click for context menu
                canvas.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    this.showContextMenu(x, y);
                    return false;
                });
            }

            createStartMenu() {
                const screenContainer = document.getElementById('screen_container');
                if (!screenContainer) return;

                const startMenu = document.createElement('div');
                startMenu.id = 'start-menu';
                startMenu.className = 'start-menu';
                startMenu.style.cssText = 'display: none;';
                startMenu.innerHTML = `
                    <div style="display: flex; height: 500px;">
                        <div class="start-menu-sidebar">Windows 95</div>
                        <div class="start-menu-items" style="flex: 1;">
                            <div class="start-menu-item" onclick="emulator.openInternetExplorer(); emulator.toggleStartMenu();">
                                üåê Internet Explorer
                            </div>
                            <div style="height: 1px; background: #808080; margin: 4px;"></div>
                            <div class="start-menu-item" style="font-weight: bold;">
                                üìÅ Programs ‚ñ∫
                            </div>
                            <div style="margin-left: 20px;">
                                <div class="start-menu-item" onclick="emulator.openFileExplorer(); emulator.toggleStartMenu();">
                                    üíª My Computer
                                </div>
                                <div class="start-menu-item" onclick="emulator.openPaint(); emulator.toggleStartMenu();">
                                    üé® Paint
                                </div>
                                <div class="start-menu-item" onclick="emulator.openMediaPlayer(); emulator.toggleStartMenu();">
                                    üéµ Media Player
                                </div>
                                <div class="start-menu-item" onclick="emulator.openNotepad(); emulator.toggleStartMenu();">
                                    üìù Notepad
                                </div>
                                <div class="start-menu-item" onclick="emulator.openCalculator(); emulator.toggleStartMenu();">
                                    üßÆ Calculator
                                </div>
                                <div class="start-menu-item" onclick="emulator.openLocalFirstBrowser(); emulator.toggleStartMenu();">
                                    üåê LocalFirst Tools
                                </div>
                                <div class="start-menu-item" onclick="emulator.openDOSPrompt(); emulator.toggleStartMenu();">
                                    ‚¨õ Linux Terminal
                                </div>
                            </div>
                            <div style="height: 1px; background: #808080; margin: 4px;"></div>
                            <div class="start-menu-item" style="font-weight: bold;">
                                üéÆ Games ‚ñ∫
                            </div>
                            <div style="margin-left: 20px;">
                                <div class="start-menu-item" onclick="emulator.openMinesweeper(); emulator.toggleStartMenu();">
                                    üí£ Minesweeper
                                </div>
                                <div class="start-menu-item" onclick="emulator.openSolitaire(); emulator.toggleStartMenu();">
                                    üÉè Solitaire
                                </div>
                                <div class="start-menu-item" onclick="emulator.openFreeCell(); emulator.toggleStartMenu();">
                                    üé¥ FreeCell
                                </div>
                                <div class="start-menu-item" onclick="emulator.openKeenExplorer(); emulator.toggleStartMenu();">
                                    üéÆ Keen Explorer
                                </div>
                                <div class="start-menu-item" onclick="emulator.openGalacticDefender(); emulator.toggleStartMenu();">
                                    üöÄ Galactic Defender
                                </div>
                                <div class="start-menu-item" onclick="emulator.openSnakeClassic(); emulator.toggleStartMenu();">
                                    üêç Snake Classic
                                </div>
                            </div>
                            <div style="height: 1px; background: #808080; margin: 4px;"></div>
                            <div class="start-menu-item" style="font-weight: bold;">
                                ‚öôÔ∏è Settings ‚ñ∫
                            </div>
                            <div style="margin-left: 20px;">
                                <div class="start-menu-item" onclick="emulator.openControlPanel(); emulator.toggleStartMenu();">
                                    üéõÔ∏è Control Panel
                                </div>
                                <div class="start-menu-item" onclick="emulator.openSystemProperties(); emulator.toggleStartMenu();">
                                    üñ•Ô∏è System Properties
                                </div>
                                <div class="start-menu-item" onclick="emulator.openRegistryEditor(); emulator.toggleStartMenu();">
                                    üìã Registry Editor
                                </div>
                                <div class="start-menu-item" onclick="emulator.openTaskManager(); emulator.toggleStartMenu();">
                                    üìä Task Manager
                                </div>
                            </div>
                            <div style="height: 1px; background: #808080; margin: 4px;"></div>
                            <div class="start-menu-item" onclick="emulator.openAbout(); emulator.toggleStartMenu();">
                                ‚ÑπÔ∏è About
                            </div>
                            <div class="start-menu-item" onclick="emulator.showHelp(); emulator.toggleStartMenu();">
                                ‚ùì Help
                            </div>
                            <div style="height: 1px; background: #808080; margin: 4px;"></div>
                            <div class="start-menu-item" onclick="emulator.restart();">
                                üîÑ Shut Down...
                            </div>
                        </div>
                    </div>
                `;
                screenContainer.appendChild(startMenu);
            }

            toggleStartMenu() {
                const startMenu = document.getElementById('start-menu');
                if (startMenu) {
                    if (startMenu.classList.contains('active')) {
                        startMenu.classList.remove('active');
                        startMenu.style.display = 'none';
                    } else {
                        startMenu.classList.add('active');
                        startMenu.style.display = 'block';

                        // Play start menu sound
                        this.playSoundEffect('start-menu');
                    }
                }
            }

            showContextMenu(x, y) {
                // Remove existing context menu
                const existing = document.getElementById('context-menu');
                if (existing) existing.remove();

                const screenContainer = document.getElementById('screen_container');
                if (!screenContainer) return;

                const hasWindows = this.windowManager && this.windowManager.windows.length > 0;
                const contextMenu = document.createElement('div');
                contextMenu.id = 'context-menu';
                contextMenu.className = 'context-menu active';
                contextMenu.style.left = x + 'px';
                contextMenu.style.top = y + 'px';
                contextMenu.innerHTML = `
                    <div class="context-menu-item" onclick="emulator.openInternetExplorer(); document.getElementById('context-menu').remove();">
                        üåê Open Internet Explorer
                    </div>
                    <div class="context-menu-separator"></div>
                    <div class="context-menu-item" onclick="emulator.openNotepad(); document.getElementById('context-menu').remove();">
                        üìù New &gt; Text Document
                    </div>
                    <div class="context-menu-separator"></div>
                    ${hasWindows ? `
                    <div class="context-menu-item" style="font-weight: bold;">Window Arrangements ‚ñ∫</div>
                    <div style="margin-left: 15px;">
                        <div class="context-menu-item" onclick="emulator.windowManager.cascadeWindows(); document.getElementById('context-menu').remove();">
                            üìä Cascade Windows
                        </div>
                        <div class="context-menu-item" onclick="emulator.windowManager.tileHorizontally(); document.getElementById('context-menu').remove();">
                            ‚ÜîÔ∏è Tile Horizontally
                        </div>
                        <div class="context-menu-item" onclick="emulator.windowManager.tileVertically(); document.getElementById('context-menu').remove();">
                            ‚ÜïÔ∏è Tile Vertically
                        </div>
                        <div class="context-menu-item" onclick="emulator.windowManager.minimizeAllWindows(); document.getElementById('context-menu').remove();">
                            üñ•Ô∏è Minimize All
                        </div>
                    </div>
                    <div class="context-menu-separator"></div>
                    ` : ''}
                    <div class="context-menu-item" onclick="emulator.refreshDesktop(); document.getElementById('context-menu').remove();">
                        üîÑ Refresh
                    </div>
                    <div class="context-menu-item" onclick="emulator.openSystemProperties(); document.getElementById('context-menu').remove();">
                        üñ•Ô∏è Properties
                    </div>
                `;
                screenContainer.appendChild(contextMenu);

                // Close on next click
                setTimeout(() => {
                    document.addEventListener('click', function closeMenu() {
                        contextMenu.remove();
                        document.removeEventListener('click', closeMenu);
                    }, { once: true });
                }, 100);
            }

            refreshDesktop() {
                // Redraw entire desktop
                this.drawDesktop();

                // Redraw icons
                this.desktop.icons.forEach(icon => {
                    this.drawIcon(icon.x, icon.y, icon.label, icon.emoji, icon.selected);
                });
            }

            drawStartButton() {
                const startGrad = this.ctx.createLinearGradient(2, 452, 2, 478);
                startGrad.addColorStop(0, '#ffffff');
                startGrad.addColorStop(0.5, '#c0c0c0');
                startGrad.addColorStop(1, '#808080');
                this.ctx.fillStyle = startGrad;
                this.ctx.fillRect(2, 452, 60, 26);

                this.ctx.strokeStyle = '#ffffff';
                this.ctx.strokeRect(2, 452, 60, 26);
                this.ctx.strokeStyle = '#808080';
                this.ctx.strokeRect(3, 453, 58, 24);

                this.ctx.fillStyle = '#000000';
                this.ctx.font = 'bold 11px Arial';
                this.ctx.fillText('Start', 20, 468);

                // Windows logo on button
                this.ctx.fillStyle = '#ff0000';
                this.ctx.fillRect(6, 458, 4, 4);
                this.ctx.fillStyle = '#00ff00';
                this.ctx.fillRect(10, 458, 4, 4);
                this.ctx.fillStyle = '#0000ff';
                this.ctx.fillRect(6, 462, 4, 4);
                this.ctx.fillStyle = '#ffff00';
                this.ctx.fillRect(10, 462, 4, 4);
            }

            drawSystemTray() {
                const taskbarY = CONFIG.DISPLAY.HEIGHT - CONFIG.DISPLAY.TASKBAR_HEIGHT;
                const trayY = taskbarY + 3;
                const trayHeight = CONFIG.DISPLAY.TASKBAR_HEIGHT - 6;

                this.ctx.fillStyle = '#808080';
                this.ctx.fillRect(CONFIG.DISPLAY.WIDTH - 100, trayY, 96, trayHeight);
                this.ctx.strokeStyle = '#000000';
                this.ctx.strokeRect(CONFIG.DISPLAY.WIDTH - 100, trayY, 96, trayHeight);

                const now = new Date();
                const timeStr = now.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
                this.ctx.fillStyle = '#000000';
                this.ctx.font = '11px Arial';
                const clockY = trayY + (trayHeight / 2) + 4;
                this.ctx.fillText(timeStr, CONFIG.DISPLAY.WIDTH - 50, clockY);
            }

            updateSystemClock() {
                // Redraw just the system tray area every second
                if (!this.ctx) return;
                this.drawSystemTray();
            }

            drawIcon(x, y, label, emoji, selected) {
                // Icon background (for selection)
                if (selected) {
                    this.ctx.fillStyle = 'rgba(0, 0, 128, 0.3)';
                    this.ctx.fillRect(x, y, 48, 64);
                    this.ctx.strokeStyle = 'rgba(0, 0, 128, 0.6)';
                    this.ctx.setLineDash([2, 2]);
                    this.ctx.strokeRect(x, y, 48, 64);
                    this.ctx.setLineDash([]);
                }

                // Draw icon image (simplified)
                this.ctx.font = '32px Arial';
                this.ctx.fillStyle = '#ffffff';
                this.ctx.fillText(emoji, x + 8, y + 32);

                // Icon label with background
                if (selected) {
                    this.ctx.fillStyle = '#000080';
                    const textWidth = this.ctx.measureText(label).width + 4;
                    this.ctx.fillRect(x + 24 - textWidth/2, y + 42, textWidth, 14);
                }

                // Icon label
                this.ctx.fillStyle = '#ffffff';
                this.ctx.font = 'bold 11px Arial';
                this.ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                this.ctx.shadowBlur = 2;
                this.ctx.textAlign = 'center';
                this.ctx.fillText(label, x + 24, y + 53);
                this.ctx.shadowBlur = 0;
                this.ctx.textAlign = 'left';
            }

            drawWindow(x, y, width, height, title) {
                // Window outer border
                this.ctx.strokeStyle = '#ffffff';
                this.ctx.strokeRect(x, y, width, height);
                this.ctx.strokeStyle = '#808080';
                this.ctx.strokeRect(x + 1, y + 1, width - 2, height - 2);

                // Window background
                this.ctx.fillStyle = '#c0c0c0';
                this.ctx.fillRect(x + 2, y + 2, width - 4, height - 4);

                // Title bar
                const titleGrad = this.ctx.createLinearGradient(x + 2, y + 2, x + 2, y + 20);
                titleGrad.addColorStop(0, '#0000ff');
                titleGrad.addColorStop(1, '#000080');
                this.ctx.fillStyle = titleGrad;
                this.ctx.fillRect(x + 2, y + 2, width - 4, 18);

                // Title bar text
                this.ctx.fillStyle = '#ffffff';
                this.ctx.font = 'bold 11px Arial';
                this.ctx.fillText(title, x + 6, y + 14);

                // Window control buttons
                const btnSize = 16;
                const btnY = y + 4;
                
                // Minimize button
                this.drawWindowButton(x + width - 60, btnY, btnSize, '_');
                // Maximize button
                this.drawWindowButton(x + width - 40, btnY, btnSize, '‚ñ°');
                // Close button
                this.drawWindowButton(x + width - 20, btnY, btnSize, 'X');

                // Window content area
                this.ctx.fillStyle = '#ffffff';
                this.ctx.fillRect(x + 3, y + 22, width - 6, height - 25);

                // Draw some content
                this.ctx.fillStyle = '#000000';
                this.ctx.font = '12px Arial';
                this.ctx.fillText('Welcome to Windows 95 Emulator!', x + 10, y + 40);
                this.ctx.font = '11px Arial';
                this.ctx.fillText('This is a WebAssembly-powered x86 emulation.', x + 10, y + 60);
                this.ctx.fillText('', x + 10, y + 75);
                this.ctx.fillText('Features:', x + 10, y + 90);
                this.ctx.fillText('‚Ä¢ Full desktop environment simulation', x + 20, y + 105);
                this.ctx.fillText('‚Ä¢ Mouse and keyboard support', x + 20, y + 120);
                this.ctx.fillText('‚Ä¢ Load custom disk images', x + 20, y + 135);
                this.ctx.fillText('‚Ä¢ Save and restore state', x + 20, y + 150);
                this.ctx.fillText('', x + 10, y + 165);
                this.ctx.fillStyle = '#000080';
                this.ctx.fillText('Click "Load Disk" to load a Windows 95 image.', x + 10, y + 180);
            }

            drawWindowButton(x, y, size, label) {
                // Button background
                this.ctx.fillStyle = '#c0c0c0';
                this.ctx.fillRect(x, y, size, 14);
                
                // Button border
                this.ctx.strokeStyle = '#ffffff';
                this.ctx.strokeRect(x, y, size, 14);
                this.ctx.strokeStyle = '#808080';
                this.ctx.strokeRect(x + 1, y + 1, size - 2, 12);

                // Button label
                this.ctx.fillStyle = '#000000';
                this.ctx.font = 'bold 10px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(label, x + size / 2, y + 10);
                this.ctx.textAlign = 'left';
            }

            animate() {
                if (!this.isRunning) return;

                const now = Date.now();
                const deltaTime = now - this.lastFrameTime;

                // Frame rate limiting
                if (deltaTime < CONFIG.PERFORMANCE.FRAME_TIME) {
                    requestAnimationFrame(() => this.animate());
                    return;
                }

                this.lastFrameTime = now;
                this.frameCount++;

                // Update FPS and stats
                if (now - this.lastFpsUpdate > CONFIG.ANIMATION.FPS_UPDATE_INTERVAL) {
                    const fps = Math.round(this.frameCount * 1000 / (now - this.lastFpsUpdate));
                    this.domCache.fpsCounter.textContent = fps;
                    this.frameCount = 0;
                    this.lastFpsUpdate = now;

                    // Update uptime
                    const elapsed = Math.floor((now - this.startTime) / 1000);
                    const hours = Math.floor(elapsed / 3600);
                    const minutes = Math.floor((elapsed % 3600) / 60);
                    const seconds = elapsed % 60;

                    const pad = (num) => num < 10 ? '0' + num : '' + num;
                    this.domCache.timeDisplay.textContent =
                        `${pad(hours)}:${pad(minutes)}:${pad(seconds)}`;

                    // Update memory usage simulation
                    this.memoryUsage = Math.floor(this.settings.memory / 1024 / 1024 * (0.3 + Math.random() * 0.2));
                    this.domCache.memoryUsage.textContent = this.memoryUsage + ' MB';
                }

                // Update LED indicators (throttled)
                if (this.frameCount % CONFIG.ANIMATION.LED_THROTTLE_FRAMES === 0) {
                    // CPU activity
                    if (Math.random() > 0.6) {
                        this.domCache.cpuLed.classList.add('active');
                        this.domCache.cpuStatus.textContent = 'Active';
                        this.cpuUsage = Math.floor(Math.random() * 40 + 10);
                    } else {
                        this.domCache.cpuLed.classList.remove('active');
                        this.domCache.cpuStatus.textContent = 'Idle';
                        this.cpuUsage = Math.floor(Math.random() * 10);
                    }

                    // HDD activity
                    if (Math.random() > 0.85) {
                        if (this.hddLedTimeout) {
                            clearTimeout(this.hddLedTimeout);
                        }

                        this.domCache.hddLed.classList.add('active');
                        this.hddLedTimeout = setTimeout(() => {
                            this.domCache.hddLed.classList.remove('active');
                            this.hddLedTimeout = null;
                        }, 100);
                    }
                }

                requestAnimationFrame(() => this.animate());
            }

            updateStatus() {
                this.updateSettings();
            }

            updateProgress(percent) {
                if (this.domCache && this.domCache.progressFill) {
                    this.domCache.progressFill.style.width = Math.min(100, percent) + '%';
                    this.domCache.progressFill.parentElement.setAttribute('aria-valuenow', Math.round(percent));
                }
            }

            updateLoadingText(text) {
                if (this.domCache && this.domCache.loadingText) {
                    this.domCache.loadingText.textContent = text;
                }
            }

            showLoading(text = 'Starting Windows 95...') {
                this.initDOMCache();
                this.domCache.loadingScreen.classList.add('active');
                this.updateProgress(0);
                this.updateLoadingText(text);
            }

            hideLoading() {
                setTimeout(() => {
                    if (this.domCache && this.domCache.loadingScreen) {
                        this.domCache.loadingScreen.classList.remove('active');
                    }
                }, 500);
            }

            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            togglePause() {
                this.isPaused = !this.isPaused;
                if (this.isPaused) {
                    this.isRunning = false;
                    this.domCache.pauseBtn.innerHTML = '<span aria-hidden="true">‚ñ∂</span> Resume';
                    this.domCache.emulatorTitlebar.classList.add('inactive');
                    
                    // Show paused message
                    const pauseText = 'PAUSED';
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    this.ctx.fillRect(0, 0, CONFIG.DISPLAY.WIDTH, CONFIG.DISPLAY.HEIGHT);
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.font = 'bold 48px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(pauseText, CONFIG.DISPLAY.WIDTH / 2, CONFIG.DISPLAY.HEIGHT / 2);
                    this.ctx.textAlign = 'left';
                } else {
                    this.isRunning = true;
                    this.domCache.pauseBtn.innerHTML = '<span aria-hidden="true">‚è∏</span> Pause';
                    this.domCache.emulatorTitlebar.classList.remove('inactive');
                    this.lastFrameTime = Date.now();
                    this.animate();
                }
            }

            restart() {
                if (!confirm('Are you sure you want to restart? Any unsaved changes will be lost.')) {
                    return;
                }

                this.isRunning = false;
                this.isPaused = false;
                this.startTime = Date.now();
                this.frameCount = 0;
                this.lastFrameTime = 0;

                if (this.hddLedTimeout) {
                    clearTimeout(this.hddLedTimeout);
                    this.hddLedTimeout = null;
                }

                // Reset UI
                this.initDOMCache();
                this.domCache.emulatorContainer.classList.add('hidden');
                this.domCache.setupScreen.classList.remove('hidden');
                
                if (this.domCache.pauseBtn) {
                    this.domCache.pauseBtn.innerHTML = '<span aria-hidden="true">‚è∏</span> Pause';
                }
            }

            fullscreen() {
                try {
                    const container = document.getElementById('emulator-container');
                    const frame = document.querySelector('.emulator-frame');

                    if (!document.fullscreenEnabled && !document.webkitFullscreenEnabled &&
                        !document.mozFullScreenEnabled && !document.msFullscreenEnabled) {
                        alert('Fullscreen not supported in this browser');
                        return;
                    }

                    if (document.fullscreenElement || document.webkitFullscreenElement ||
                        document.mozFullScreenElement || document.msFullscreenElement) {
                        // Exit fullscreen
                        const exitFullscreen = document.exitFullscreen ||
                                             document.webkitExitFullscreen ||
                                             document.mozCancelFullScreen ||
                                             document.msExitFullscreen;
                        if (exitFullscreen) {
                            exitFullscreen.call(document);
                        }
                        // Remove fullscreen class
                        if (frame) {
                            frame.classList.remove('fullscreen-mode');
                        }
                        // Restore original canvas size
                        this.resizeCanvas(640, 480);
                    } else {
                        // Enter fullscreen
                        const requestFullscreen = container.requestFullscreen ||
                                                container.webkitRequestFullscreen ||
                                                container.webkitRequestFullScreen ||
                                                container.mozRequestFullScreen ||
                                                container.msRequestFullscreen;

                        if (requestFullscreen) {
                            requestFullscreen.call(container).then(() => {
                                // Add fullscreen class when successfully entered
                                if (frame) {
                                    frame.classList.add('fullscreen-mode');
                                }
                                // Resize canvas to fill screen
                                setTimeout(() => {
                                    const screenContainer = document.getElementById('screen_container');
                                    if (screenContainer) {
                                        const width = screenContainer.clientWidth;
                                        const height = screenContainer.clientHeight;
                                        this.resizeCanvas(width, height);
                                    }
                                }, 100);
                            }).catch(err => {
                                console.error('Fullscreen request failed:', err);
                                alert('Could not enter fullscreen mode');
                            });
                        }
                    }
                } catch (error) {
                    console.error('Fullscreen error:', error);
                    alert('Fullscreen failed: ' + error.message);
                }
            }

            resizeCanvas(width, height) {
                if (!this.canvas || !this.ctx) return;

                // Store old dimensions
                const oldWidth = this.canvas.width;
                const oldHeight = this.canvas.height;

                // Set new canvas dimensions
                this.canvas.width = width;
                this.canvas.height = height;

                // Update CONFIG for rendering
                CONFIG.DISPLAY.WIDTH = width;
                CONFIG.DISPLAY.HEIGHT = height;
                CONFIG.DISPLAY.TASKBAR_HEIGHT = Math.max(30, Math.floor(height * 0.0625)); // 6.25% of height

                // Redraw desktop
                this.drawDesktop();

                // Update window manager bounds
                if (this.windowManager) {
                    this.windowManager.updateBounds(width, height);
                }
            }

            screenshot() {
                try {
                    const canvas = document.getElementById('screen');
                    if (!canvas) {
                        throw new Error('Canvas not found');
                    }

                    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                    const link = document.createElement('a');
                    link.download = `windows95-screenshot-${timestamp}.png`;
                    link.href = canvas.toDataURL('image/png');
                    link.click();
                    
                    // Show feedback
                    this.showNotification('Screenshot saved!');
                } catch (error) {
                    console.error('Screenshot failed:', error);
                    alert('Screenshot failed. Canvas may be tainted by cross-origin content.');
                }
            }

            showNotification(message) {
                // Simple notification in the emulator
                const prevFill = this.ctx.fillStyle;
                const prevFont = this.ctx.font;
                
                this.ctx.fillStyle = 'rgba(255, 255, 200, 0.9)';
                this.ctx.fillRect(200, 200, 240, 80);
                this.ctx.strokeStyle = '#000000';
                this.ctx.strokeRect(200, 200, 240, 80);
                
                this.ctx.fillStyle = '#000000';
                this.ctx.font = 'bold 14px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(message, 320, 240);
                this.ctx.textAlign = 'left';
                
                this.ctx.fillStyle = prevFill;
                this.ctx.font = prevFont;
            }

            showHelp() {
                alert(`Windows 95 Desktop Simulator Help

DESKTOP INTERACTIONS:
‚Ä¢ Single-click icons to select them
‚Ä¢ Double-click icons to open programs
‚Ä¢ Right-click desktop for context menu
‚Ä¢ Click Start button to open program menu

WINDOWS:
‚Ä¢ Drag windows by their title bars
‚Ä¢ Click minimize (_) to minimize to taskbar
‚Ä¢ Click maximize (‚ñ°) to toggle full screen
‚Ä¢ Click close (X) to close windows
‚Ä¢ Click taskbar buttons to restore windows

KEYBOARD SHORTCUTS:
‚Ä¢ F11 - Toggle fullscreen mode
‚Ä¢ Ctrl+H - Toggle control toolbar
‚Ä¢ Ctrl+P - Pause/Resume desktop
‚Ä¢ Ctrl+R - Restart desktop
‚Ä¢ Ctrl+S - Take screenshot
‚Ä¢ ESC - Release mouse cursor (if locked)

PROGRAMS:
‚Ä¢ Internet Explorer - Real web browser (loads live sites!)
‚Ä¢ Notepad - Text editor with basic functionality
‚Ä¢ Calculator - Working calculator with basic operations
‚Ä¢ Minesweeper - Classic game (right-click to flag)
‚Ä¢ About - Information about this simulator

FEATURES:
‚Ä¢ All interactions happen locally in your browser
‚Ä¢ No data is sent to any server
‚Ä¢ State persists in browser storage
‚Ä¢ Works completely offline
‚Ä¢ Authentic Windows 95 look and feel

TIP: Try opening multiple windows and arranging them!`);
            }

            loadDisk() {
                document.getElementById('disk-input').click();
            }

            handleDiskUpload(event) {
                try {
                    const file = event.target.files[0];
                    if (!file) return;

                    const validExtensions = ['.img', '.iso', '.ima'];
                    const fileName = file.name.toLowerCase();
                    const isValid = validExtensions.some(ext => fileName.endsWith(ext));

                    if (!isValid) {
                        alert('Invalid file type. Please select an IMG, ISO, or IMA file.');
                        return;
                    }

                    if (file.size > 100 * 1024 * 1024) {
                        alert('File too large. Maximum size is 100MB for this demo.');
                        return;
                    }

                    // Show file name
                    const fileNameDisplay = document.getElementById('file-name');
                    if (fileNameDisplay) {
                        fileNameDisplay.textContent = `Selected: ${file.name} (${(file.size / 1024 / 1024).toFixed(2)} MB)`;
                    }

                    console.log('Loading disk image:', file.name, 'Size:', file.size, 'bytes');
                    alert(`Disk image "${file.name}" selected.\n\nNote: Full Windows 95 emulation requires the v86 WASM library.\nThis demo shows a simulated environment.\n\nFor actual Windows 95, you would need:\n‚Ä¢ A complete v86 library implementation\n‚Ä¢ Valid Windows 95 disk image\n‚Ä¢ Additional ROM files`);
                    
                    this.loadDemo();
                } catch (error) {
                    console.error('Failed to handle disk upload:', error);
                    alert('Failed to load disk image: ' + error.message);
                }
            }

            loadFromURL() {
                try {
                    const url = document.getElementById('disk-url').value.trim();
                    if (!url) {
                        alert('Please enter a URL');
                        return;
                    }

                    if (!url.startsWith('http://') && !url.startsWith('https://')) {
                        alert('Invalid URL. Must start with http:// or https://');
                        return;
                    }

                    console.log('Loading from URL:', url);
                    alert(`Loading from URL: ${url}\n\nNote: Full emulation requires the v86 WASM library.\nThis demo shows a simulated environment.\n\nRequirements:\n‚Ä¢ Server must support CORS\n‚Ä¢ Valid disk image format (IMG/ISO)\n‚Ä¢ Stable network connection`);
                    
                    this.loadDemo();
                } catch (error) {
                    console.error('Failed to load from URL:', error);
                    alert('Failed to load from URL: ' + error.message);
                }
            }

            minimize() {
                const container = document.getElementById('emulator-container');
                container.style.transition = 'transform 0.3s ease';
                container.style.transform = 'scale(0.1)';
                container.style.opacity = '0';
                
                setTimeout(() => {
                    container.style.transform = 'scale(1)';
                    container.style.opacity = '1';
                }, 300);
            }

            maximize() {
                this.fullscreen();
            }

            close() {
                if (confirm('Are you sure you want to close Windows 95?\n\nAny unsaved changes will be lost.')) {
                    this.restart();
                }
            }
        }

        // Safe localStorage wrapper with error handling
        const SafeStorage = {
            getItem(key) {
                try {
                    return localStorage.getItem(key);
                } catch (e) {
                    console.warn('LocalStorage getItem failed:', e);
                    return null;
                }
            },
            setItem(key, value) {
                try {
                    localStorage.setItem(key, value);
                } catch (e) {
                    console.warn('LocalStorage setItem failed:', e);
                }
            },
            removeItem(key) {
                try {
                    localStorage.removeItem(key);
                } catch (e) {
                    console.warn('LocalStorage removeItem failed:', e);
                }
            }
        };

        // Initialize emulator - make it globally accessible immediately
        window.emulator = null;
        // Create alias for convenience in this script
        var emulator = null;

        // Wait for DOM to be ready before initializing
        document.addEventListener('DOMContentLoaded', () => {
            window.emulator = new Windows95Emulator();
            emulator = window.emulator;

            // Setup event listeners that require emulator
            setupEmulatorEventListeners();
        });

        // Handle window resize to keep canvas fullscreen
        window.addEventListener('resize', () => {
            if (window.emulator && window.emulator.canvas && window.emulator.isRunning) {
                // Header is hidden when OS is running, don't account for it
                const statusBar = document.querySelector('.status-bar');
                const statusBarHeight = statusBar ? statusBar.offsetHeight : 22;

                const availableWidth = window.innerWidth;
                const availableHeight = window.innerHeight - statusBarHeight;

                // Update canvas dimensions
                window.emulator.canvas.width = availableWidth;
                window.emulator.canvas.height = availableHeight;

                // Update CONFIG
                CONFIG.DISPLAY.WIDTH = availableWidth;
                CONFIG.DISPLAY.HEIGHT = availableHeight;
                CONFIG.DISPLAY.TASKBAR_HEIGHT = Math.max(30, Math.floor(availableHeight * 0.0625));

                // Redraw desktop
                window.emulator.drawDesktop();

                // Redraw icons
                window.emulator.desktop.icons.forEach(icon => {
                    window.emulator.drawIcon(icon.x, icon.y, icon.label, icon.emoji, icon.selected);
                });
            }
        });

        function setupEmulatorEventListeners() {
            // Global mouse handlers for window dragging
            document.addEventListener('mousemove', (e) => {
                if (window.emulator && window.emulator.windowManager) {
                    window.emulator.windowManager.handleMouseMove(e);
                }
            });

            document.addEventListener('mouseup', (e) => {
                if (window.emulator && window.emulator.windowManager) {
                    window.emulator.windowManager.handleMouseUp(e);
                }
            });
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (!window.emulator) return; // Exit if emulator not ready

            // Ctrl+H - Toggle header visibility
            if (e.ctrlKey && e.key === 'h') {
                e.preventDefault();
                const header = document.querySelector('.header');
                if (header) {
                    header.classList.toggle('hidden');
                    // Recalculate canvas size when header is toggled
                    if (window.emulator.canvas && window.emulator.isRunning) {
                        const statusBar = document.querySelector('.status-bar');
                        const headerHeight = header.classList.contains('hidden') ? 0 : header.offsetHeight;
                        const statusBarHeight = statusBar ? statusBar.offsetHeight : 22;

                        const availableWidth = window.innerWidth;
                        const availableHeight = window.innerHeight - headerHeight - statusBarHeight;

                        window.emulator.canvas.width = availableWidth;
                        window.emulator.canvas.height = availableHeight;

                        CONFIG.DISPLAY.WIDTH = availableWidth;
                        CONFIG.DISPLAY.HEIGHT = availableHeight;
                        CONFIG.DISPLAY.TASKBAR_HEIGHT = Math.max(30, Math.floor(availableHeight * 0.0625));

                        window.emulator.drawDesktop();
                        window.emulator.desktop.icons.forEach(icon => {
                            window.emulator.drawIcon(icon.x, icon.y, icon.label, icon.emoji, icon.selected);
                        });
                    }
                }
                return;
            }

            // ESC - Release mouse
            if (e.key === 'Escape') {
                const isLocked = document.pointerLockElement ||
                                document.webkitPointerLockElement ||
                                document.mozPointerLockElement;

                if (isLocked) {
                    const exitPointerLock = document.exitPointerLock ||
                                          document.webkitExitPointerLock ||
                                          document.mozExitPointerLock;
                    if (exitPointerLock) {
                        exitPointerLock.call(document);
                    }
                }
            }

            // F11 - Fullscreen
            if (e.key === 'F11') {
                e.preventDefault();
                emulator.fullscreen();
            }

            // Ctrl+P - Pause
            if (e.ctrlKey && e.key === 'p') {
                e.preventDefault();
                emulator.togglePause();
            }

            // Ctrl+S - Screenshot
            if (e.ctrlKey && e.key === 's') {
                e.preventDefault();
                emulator.screenshot();
            }

            // Ctrl+R - Restart
            if (e.ctrlKey && e.key === 'r') {
                e.preventDefault();
                emulator.restart();
            }

            // Alt+Tab - Cycle through windows (Windows 95 style)
            if (e.altKey && e.key === 'Tab') {
                e.preventDefault();
                if (emulator.windowManager && emulator.windowManager.windows.length > 0) {
                    // Get visible (non-minimized) windows
                    const visibleWindows = emulator.windowManager.windows.filter(w => !w.minimized);
                    if (visibleWindows.length > 1) {
                        // Find current active window index
                        const activeIndex = visibleWindows.findIndex(w => w.element.classList.contains('active'));
                        // Cycle to next window (or first if none active)
                        const nextIndex = (activeIndex + 1) % visibleWindows.length;
                        emulator.windowManager.focusWindow(visibleWindows[nextIndex].element);
                    } else if (visibleWindows.length === 1) {
                        // Only one window, just focus it
                        emulator.windowManager.focusWindow(visibleWindows[0].element);
                    }
                }
            }

            // Alt+F4 - Close active window
            if (e.altKey && e.key === 'F4') {
                e.preventDefault();
                const activeWindow = document.querySelector('.window.active');
                if (activeWindow && emulator.windowManager) {
                    emulator.windowManager.closeWindow(activeWindow);
                }
            }

            // Ctrl+Escape or Windows key - Toggle Start Menu
            if ((e.ctrlKey && e.key === 'Escape') || e.key === 'Meta' || e.key === 'OS') {
                e.preventDefault();
                emulator.toggleStartMenu();
            }

            // F1 - Help
            if (e.key === 'F1') {
                e.preventDefault();
                emulator.showHelp();
            }

            // Ctrl+N - New Notepad
            if (e.ctrlKey && e.key === 'n') {
                e.preventDefault();
                emulator.openNotepad();
            }

            // Ctrl+Shift+Esc - Task Manager
            if (e.ctrlKey && e.shiftKey && e.key === 'Escape') {
                e.preventDefault();
                emulator.openTaskManager();
            }

            // Windows+E - File Explorer
            if ((e.metaKey || e.key === 'OS') && e.key === 'e') {
                e.preventDefault();
                emulator.openFileExplorer();
            }

            // Windows+R - Run dialog (open DOS prompt for now)
            if ((e.metaKey || e.key === 'OS') && e.key === 'r') {
                e.preventDefault();
                emulator.openDOSPrompt();
            }

            // Windows+D - Show Desktop (minimize all windows)
            if ((e.metaKey || e.key === 'OS') && e.key === 'd') {
                e.preventDefault();
                if (emulator.windowManager) {
                    emulator.windowManager.minimizeAllWindows();
                }
            }

            // Windows+Shift+F - Cascade windows
            if ((e.metaKey || e.key === 'OS') && e.shiftKey && e.key === 'F') {
                e.preventDefault();
                if (emulator.windowManager) {
                    emulator.windowManager.cascadeWindows();
                }
            }

            // Windows+Shift+H - Tile windows horizontally
            if ((e.metaKey || e.key === 'OS') && e.shiftKey && e.key === 'H') {
                e.preventDefault();
                if (emulator.windowManager) {
                    emulator.windowManager.tileHorizontally();
                }
            }

            // Windows+Shift+V - Tile windows vertically
            if ((e.metaKey || e.key === 'OS') && e.shiftKey && e.key === 'V') {
                e.preventDefault();
                if (emulator.windowManager) {
                    emulator.windowManager.tileVertically();
                }
            }
        });

        // Auto-save settings
        window.addEventListener('beforeunload', () => {
            const settings = {
                memory: document.getElementById('memory-size').value,
                cpuSpeed: document.getElementById('cpu-speed').value,
                enableMouse: document.getElementById('enable-mouse').checked,
                enableSound: document.getElementById('enable-sound').checked,
                enableNetwork: document.getElementById('enable-network').checked
            };
            SafeStorage.setItem('win95-emulator-settings', JSON.stringify(settings));
        });

        // Load saved settings
        window.addEventListener('load', () => {
            const saved = SafeStorage.getItem('win95-emulator-settings');
            if (saved) {
                try {
                    const settings = JSON.parse(saved);
                    document.getElementById('memory-size').value = settings.memory || '32';
                    document.getElementById('cpu-speed').value = settings.cpuSpeed || '2';
                    document.getElementById('enable-mouse').checked = settings.enableMouse !== false;
                    document.getElementById('enable-sound').checked = settings.enableSound !== false;
                    document.getElementById('enable-network').checked = settings.enableNetwork !== false;
                } catch (error) {
                    console.error('Failed to load settings:', error);
                }
            }
        });

        // Handle file input label update
        document.getElementById('disk-input').addEventListener('change', function(e) {
            const fileName = e.target.files[0]?.name;
            if (fileName) {
                const label = document.querySelector('.file-input-label');
                label.textContent = fileName;
            }
        });

        // Fullscreen change handler with cross-browser support
        function handleFullscreenChange() {
            const frame = document.querySelector('.emulator-frame');
            const isFullscreen = document.fullscreenElement ||
                               document.webkitFullscreenElement ||
                               document.mozFullScreenElement ||
                               document.msFullscreenElement;

            if (isFullscreen) {
                console.log('Entered fullscreen mode');
                if (frame) {
                    frame.classList.add('fullscreen-mode');
                }
                // Resize canvas to fill screen
                setTimeout(() => {
                    if (emulator && emulator.resizeCanvas) {
                        const screenContainer = document.getElementById('screen_container');
                        if (screenContainer) {
                            const width = screenContainer.clientWidth;
                            const height = screenContainer.clientHeight;
                            emulator.resizeCanvas(width, height);
                        }
                    }
                }, 100);
            } else {
                console.log('Exited fullscreen mode');
                if (frame) {
                    frame.classList.remove('fullscreen-mode');
                }
                // Restore original canvas size
                if (emulator && emulator.resizeCanvas) {
                    emulator.resizeCanvas(640, 480);
                }
            }
        }

        // Add event listeners for all browser prefixes
        document.addEventListener('fullscreenchange', handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
        document.addEventListener('mozfullscreenchange', handleFullscreenChange);
        document.addEventListener('MSFullscreenChange', handleFullscreenChange);

        // Log initialization
        console.log('Windows 95 WASM Emulator initialized');
        console.log('WebAssembly support:', typeof WebAssembly !== 'undefined');
    </script>

    <!-- Single Morphing Clippy Assistant System -->
    <div id="clippy-container"></div>

    <!-- Screen Saver System -->
    <div id="screensaver" class="screensaver">
        <canvas id="screensaver-canvas" class="screensaver-canvas"></canvas>
    </div>

    <!-- Toast Notification Container -->
    <div id="toast-container"></div>

    <script>
        /** @ts-nocheck */

        // ========================================
        // SCREEN SAVER MANAGER
        // ========================================

        class ScreenSaverManager {
            constructor() {
                this.container = document.getElementById('screensaver');
                this.canvas = document.getElementById('screensaver-canvas');
                this.ctx = this.canvas ? this.canvas.getContext('2d') : null;
                this.active = false;
                this.idleTimeout = 120000; // 2 minutes of inactivity
                this.idleTimer = null;
                this.animationFrame = null;
                this.currentSaver = 'starfield'; // starfield, pipes, matrix, flying-logo
                this.lastActivity = Date.now();

                this.init();
            }

            init() {
                // Track user activity
                ['mousemove', 'mousedown', 'keydown', 'touchstart', 'wheel'].forEach(event => {
                    document.addEventListener(event, () => this.resetIdleTimer());
                });

                // Start idle timer
                this.resetIdleTimer();

                // Resize canvas to window size
                if (this.canvas) {
                    this.resizeCanvas();
                    window.addEventListener('resize', () => this.resizeCanvas());
                }
            }

            resizeCanvas() {
                if (!this.canvas) return;
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }

            resetIdleTimer() {
                this.lastActivity = Date.now();

                if (this.active) {
                    this.deactivate();
                }

                clearTimeout(this.idleTimer);
                this.idleTimer = setTimeout(() => {
                    this.activate();
                }, this.idleTimeout);
            }

            activate() {
                if (this.active) return;

                this.active = true;
                this.container.classList.add('active');
                this.resizeCanvas();

                // Choose random screensaver
                const savers = ['starfield', 'pipes', 'matrix', 'flying-logo'];
                this.currentSaver = savers[Math.floor(Math.random() * savers.length)];

                // Initialize the chosen screensaver
                switch(this.currentSaver) {
                    case 'starfield':
                        this.startStarfield();
                        break;
                    case 'pipes':
                        this.startPipes();
                        break;
                    case 'matrix':
                        this.startMatrix();
                        break;
                    case 'flying-logo':
                        this.startFlyingLogo();
                        break;
                }

                console.log('Screen saver activated:', this.currentSaver);
            }

            deactivate() {
                if (!this.active) return;

                this.active = false;
                this.container.classList.remove('active');

                if (this.animationFrame) {
                    cancelAnimationFrame(this.animationFrame);
                    this.animationFrame = null;
                }

                // Clear canvas
                if (this.ctx) {
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                }
            }

            // ========================================
            // STARFIELD SCREENSAVER
            // ========================================

            startStarfield() {
                const stars = [];
                const numStars = 200;
                const speed = 2;

                // Initialize stars
                for (let i = 0; i < numStars; i++) {
                    stars.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        z: Math.random() * this.canvas.width,
                        size: Math.random() * 2 + 1
                    });
                }

                const animate = () => {
                    if (!this.active) return;

                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                    const cx = this.canvas.width / 2;
                    const cy = this.canvas.height / 2;

                    stars.forEach(star => {
                        star.z -= speed;

                        if (star.z <= 0) {
                            star.z = this.canvas.width;
                            star.x = Math.random() * this.canvas.width;
                            star.y = Math.random() * this.canvas.height;
                        }

                        const k = 128 / star.z;
                        const px = (star.x - cx) * k + cx;
                        const py = (star.y - cy) * k + cy;

                        const size = (1 - star.z / this.canvas.width) * star.size;
                        const brightness = Math.floor(255 * (1 - star.z / this.canvas.width));

                        this.ctx.fillStyle = `rgb(${brightness}, ${brightness}, ${brightness})`;
                        this.ctx.fillRect(px, py, size, size);
                    });

                    this.animationFrame = requestAnimationFrame(animate);
                };

                animate();
            }

            // ========================================
            // 3D PIPES SCREENSAVER
            // ========================================

            startPipes() {
                const pipes = [];
                const numPipes = 5;
                const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff'];

                class Pipe {
                    constructor(canvas) {
                        this.canvas = canvas;
                        this.x = Math.random() * canvas.width;
                        this.y = Math.random() * canvas.height;
                        this.direction = Math.floor(Math.random() * 4); // 0=up, 1=right, 2=down, 3=left
                        this.color = colors[Math.floor(Math.random() * colors.length)];
                        this.segments = [];
                        this.speed = 5;
                        this.maxSegments = 50;
                    }

                    update() {
                        // Occasionally change direction
                        if (Math.random() < 0.05) {
                            this.direction = Math.floor(Math.random() * 4);
                        }

                        // Move based on direction
                        switch(this.direction) {
                            case 0: this.y -= this.speed; break;
                            case 1: this.x += this.speed; break;
                            case 2: this.y += this.speed; break;
                            case 3: this.x -= this.speed; break;
                        }

                        // Wrap around edges
                        if (this.x < 0) this.x = this.canvas.width;
                        if (this.x > this.canvas.width) this.x = 0;
                        if (this.y < 0) this.y = this.canvas.height;
                        if (this.y > this.canvas.height) this.y = 0;

                        // Add current position to segments
                        this.segments.push({ x: this.x, y: this.y });
                        if (this.segments.length > this.maxSegments) {
                            this.segments.shift();
                        }
                    }

                    draw(ctx) {
                        ctx.strokeStyle = this.color;
                        ctx.lineWidth = 8;
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';

                        if (this.segments.length > 1) {
                            ctx.beginPath();
                            ctx.moveTo(this.segments[0].x, this.segments[0].y);
                            for (let i = 1; i < this.segments.length; i++) {
                                ctx.lineTo(this.segments[i].x, this.segments[i].y);
                            }
                            ctx.stroke();
                        }

                        // Draw joint at current position
                        ctx.fillStyle = this.color;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, 6, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                // Create pipes
                for (let i = 0; i < numPipes; i++) {
                    pipes.push(new Pipe(this.canvas));
                }

                const animate = () => {
                    if (!this.active) return;

                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                    pipes.forEach(pipe => {
                        pipe.update();
                        pipe.draw(this.ctx);
                    });

                    this.animationFrame = requestAnimationFrame(animate);
                };

                animate();
            }

            // ========================================
            // MATRIX SCREENSAVER
            // ========================================

            startMatrix() {
                const fontSize = 16;
                const columns = Math.floor(this.canvas.width / fontSize);
                const drops = [];

                for (let i = 0; i < columns; i++) {
                    drops[i] = Math.random() * this.canvas.height / fontSize;
                }

                const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789@#$%^&*()_+-=[]{}|;:,.<>?';

                const animate = () => {
                    if (!this.active) return;

                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                    this.ctx.fillStyle = '#0F0';
                    this.ctx.font = fontSize + 'px monospace';

                    for (let i = 0; i < drops.length; i++) {
                        const char = chars[Math.floor(Math.random() * chars.length)];
                        this.ctx.fillText(char, i * fontSize, drops[i] * fontSize);

                        if (drops[i] * fontSize > this.canvas.height && Math.random() > 0.975) {
                            drops[i] = 0;
                        }

                        drops[i]++;
                    }

                    this.animationFrame = requestAnimationFrame(animate);
                };

                animate();
            }

            // ========================================
            // FLYING LOGO SCREENSAVER
            // ========================================

            startFlyingLogo() {
                let x = Math.random() * this.canvas.width;
                let y = Math.random() * this.canvas.height;
                let dx = (Math.random() - 0.5) * 4;
                let dy = (Math.random() - 0.5) * 4;
                const size = 80;
                let hue = 0;

                const animate = () => {
                    if (!this.active) return;

                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                    // Update position
                    x += dx;
                    y += dy;

                    // Bounce off edges
                    if (x <= 0 || x >= this.canvas.width - size) dx = -dx;
                    if (y <= 0 || y >= this.canvas.height - size) dy = -dy;

                    // Draw Windows 95 logo
                    const gradient = this.ctx.createLinearGradient(x, y, x + size, y + size);
                    hue = (hue + 1) % 360;
                    gradient.addColorStop(0, `hsl(${hue}, 100%, 50%)`);
                    gradient.addColorStop(0.33, `hsl(${(hue + 60) % 360}, 100%, 50%)`);
                    gradient.addColorStop(0.66, `hsl(${(hue + 120) % 360}, 100%, 50%)`);
                    gradient.addColorStop(1, `hsl(${(hue + 180) % 360}, 100%, 50%)`);

                    this.ctx.fillStyle = gradient;
                    this.ctx.shadowBlur = 20;
                    this.ctx.shadowColor = 'white';
                    this.ctx.fillRect(x, y, size, size);
                    this.ctx.shadowBlur = 0;

                    // Add "Windows 95" text
                    this.ctx.fillStyle = 'white';
                    this.ctx.font = 'bold 12px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('Windows 95', x + size/2, y + size + 20);

                    this.animationFrame = requestAnimationFrame(animate);
                };

                animate();
            }
        }

        // ========================================
        // TOAST NOTIFICATION SYSTEM
        // ========================================

        class ToastManager {
            constructor() {
                this.container = document.getElementById('toast-container');
                this.queue = [];
                this.showing = false;
            }

            show(title, message, duration = 5000) {
                this.queue.push({ title, message, duration });
                if (!this.showing) {
                    this.displayNext();
                }
            }

            displayNext() {
                if (this.queue.length === 0) {
                    this.showing = false;
                    return;
                }

                this.showing = true;
                const { title, message, duration } = this.queue.shift();

                const toast = document.createElement('div');
                toast.className = 'toast-notification';
                toast.innerHTML = `
                    <div class="toast-title">${title}</div>
                    <div class="toast-message">${message}</div>
                `;

                this.container.appendChild(toast);

                setTimeout(() => {
                    toast.style.animation = 'slideIn 0.3s ease-out reverse';
                    setTimeout(() => {
                        toast.remove();
                        this.displayNext();
                    }, 300);
                }, duration);
            }
        }

        // Initialize systems
        let screenSaverManager;
        let toastManager;

        window.addEventListener('load', () => {
            screenSaverManager = new ScreenSaverManager();
            toastManager = new ToastManager();
            window.screenSaverManager = screenSaverManager;
            window.toastManager = toastManager;
            console.log('Screen saver system initialized');
        });

        // ========================================
        // CLIPPY GOVERNOR - Multi-Agent Coordination System
        // ========================================

        class ClippyGovernor {
            constructor() {
                this.instances = [];
                this.state = {
                    user: {
                        activity: 'idle',
                        focus: null,
                        mousePos: { x: 0, y: 0 },
                        lastAction: Date.now(),
                        openWindows: [],
                        keystrokes: 0,
                        clicks: 0,
                        pattern: 'exploring' // exploring, gaming, working, browsing
                    },
                    system: {
                        uptime: 0,
                        windowCount: 0,
                        lastWindowOpened: null
                    },
                    conversation: {
                        active: false,
                        speaker: null,
                        topic: null,
                        participants: []
                    }
                };
                this.messageQueue = [];
                this.stateUpdateInterval = null;
                this.personalities = this.definePersonalities();
                this.init();
            }

            definePersonalities() {
                return {
                    helper: {
                        name: 'Clippit',
                        icon: 'üìé',
                        traits: { helpfulness: 0.95, humor: 0.3, technical: 0.5, patience: 0.95, supportiveness: 0.9 },
                        catchphrases: [
                            "It looks like you're trying to",
                            "Would you like help with that?",
                            "Need assistance?",
                            "I can help with that!",
                            "Let me guide you through this step-by-step."
                        ],
                        position: { bottom: 80, right: 30 }
                    },
                    entertainer: {
                        name: 'Jolly',
                        icon: 'üé≠',
                        traits: { helpfulness: 0.6, humor: 0.95, technical: 0.3, patience: 0.7, spontaneity: 0.9, emoji_usage: 0.85 },
                        catchphrases: [
                            "üéâ Having fun yet?",
                            "üòÑ This is entertaining!",
                            "üéÆ Time to play?",
                            "‚ú® Let me make your day brighter!",
                            "üé™ Want to hear a Windows 95 joke?"
                        ],
                        position: { bottom: 80, left: 30 }
                    },
                    expert: {
                        name: 'TechMaster',
                        icon: 'ü§ì',
                        traits: { helpfulness: 0.7, humor: 0.2, technical: 0.95, patience: 0.6, precision: 0.95, efficiency: 0.9 },
                        catchphrases: [
                            "‚ö° Pro tip:",
                            "üîß Advanced technique:",
                            "‚å®Ô∏è Keyboard shortcut:",
                            "üí° Optimize your workflow:",
                            "üìä System performance note:"
                        ],
                        position: { top: 120, right: 30 }
                    },
                    coach: {
                        name: 'Motivator',
                        icon: 'üèÜ',
                        traits: { helpfulness: 0.75, humor: 0.6, technical: 0.4, patience: 0.8, motivation: 0.95, enthusiasm: 0.9, competitiveness: 0.85 },
                        catchphrases: [
                            "üí™ You got this!",
                            "üéØ Level up!",
                            "üèÖ Achievement unlocked!",
                            "üî• You're on fire!",
                            "‚≠ê Excellent progress!"
                        ],
                        position: { top: 120, left: 30 }
                    },
                    manager: {
                        name: 'Organizer',
                        icon: 'üìã',
                        traits: { helpfulness: 0.85, humor: 0.4, technical: 0.6, patience: 0.7, organization: 0.95, productivity: 0.9, structure: 0.85 },
                        catchphrases: [
                            "üìÅ Let's organize this!",
                            "‚è∞ Time management tip:",
                            "üìä Productivity boost:",
                            "üóÇÔ∏è Keep your files tidy!",
                            "‚úÖ Task completed efficiently!"
                        ],
                        position: { bottom: 80, right: 150 }
                    }
                };
            }

            init() {
                // Create all Clippy instances
                Object.keys(this.personalities).forEach(role => {
                    this.createClippy(role);
                });

                // Start state monitoring
                this.startStateTracking();

                // Staggered introductions - each Clippy appears at different times
                setTimeout(() => {
                    if (this.state.user.clicks > 2 || this.state.user.keystrokes > 3) {
                        this.showClippy('helper', "üëã Hi! I'm Clippit. Click me if you need help with Windows 95!");
                    }
                }, 15000); // Helper appears first at 15 seconds

                setTimeout(() => {
                    if (this.state.user.clicks > 5) {
                        this.showClippy('entertainer', "üéâ Hey! I'm Jolly! Click me for jokes and fun stuff!");
                    }
                }, 30000); // Entertainer at 30 seconds

                setTimeout(() => {
                    if (this.state.user.pattern === 'gaming') {
                        this.showClippy('coach', "üí™ Motivator here! I'll cheer you on! You're doing great!");
                    }
                }, 45000); // Coach appears at 45 seconds if gaming

                // Expert and Manager appear contextually, not on timer
                console.log('üìé Multi-Clippy assistant team initialized (5 personalities)');
            }

            createClippy(role) {
                const personality = this.personalities[role];
                const clippy = {
                    id: `clippy-${role}`,
                    role: role,
                    personality: personality,
                    active: false,
                    message: null,
                    element: null
                };

                // Determine bubble position based on Clippy location
                let bubblePos = '';
                let bubbleArrow = '';

                if (personality.position.left !== undefined) {
                    // Left side - bubble appears to the right
                    bubblePos = 'bottom: 130px; left: 0;';
                    bubbleArrow = 'left: 30px;';
                } else if (personality.position.right !== undefined) {
                    // Right side - bubble appears to the left
                    bubblePos = 'bottom: 130px; right: 0;';
                    bubbleArrow = 'right: 30px;';
                }

                if (personality.position.top !== undefined) {
                    // Top positioned - bubble appears below
                    bubblePos = 'top: 130px; right: 0;';
                    bubbleArrow = 'top: -20px; right: 30px; border-bottom-color: #000; border-top-color: transparent;';
                }

                // Create DOM element
                const container = document.createElement('div');
                container.id = clippy.id;
                container.className = 'clippy-instance';
                container.style.cssText = `
                    position: fixed;
                    ${personality.position.top ? `top: ${personality.position.top}px;` : ''}
                    ${personality.position.bottom ? `bottom: ${personality.position.bottom}px;` : ''}
                    ${personality.position.left ? `left: ${personality.position.left}px;` : ''}
                    ${personality.position.right ? `right: ${personality.position.right}px;` : ''}
                    z-index: 9999;
                    font-family: 'Comic Sans MS', cursive, sans-serif;
                `;

                container.innerHTML = `
                    <div class="clippy-bubble" style="display: none; position: absolute; ${bubblePos} max-width: 220px; background: #ffffcc; border: 2px solid #000; border-radius: 8px; padding: 10px; box-shadow: 2px 2px 8px rgba(0,0,0,0.25);">
                        <div class="bubble-arrow" style="position: absolute; ${bubbleArrow} border: 8px solid transparent; border-top-color: #000;"></div>
                        <div style="position: absolute; top: 2px; right: 2px; background: #c0c0c0; border: 1px solid #000; width: 16px; height: 16px; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 10px; font-weight: bold;" onclick="window.clippyGovernor.hideClippy('${role}')">√ó</div>
                        <div class="clippy-message" style="font-size: 11px; line-height: 1.3; color: #000; margin-top: 4px;"></div>
                    </div>
                    <div class="clippy-character" onclick="window.clippyGovernor.toggleClippy('${role}')" style="width: 80px; height: 100px; background: #fff; border: 2px solid #000; border-radius: 50% 50% 40% 40%; position: relative; cursor: pointer; transition: transform 0.2s; box-shadow: 2px 2px 6px rgba(0,0,0,0.2);">
                        <div style="font-size: 50px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);">${personality.icon}</div>
                    </div>
                `;

                document.getElementById('clippy-swarm').appendChild(container);
                clippy.element = container;

                this.instances.push(clippy);
                return clippy;
            }

            startStateTracking() {
                // Track mouse movement
                document.addEventListener('mousemove', (e) => {
                    this.state.user.mousePos = { x: e.clientX, y: e.clientY };
                });

                // Track clicks
                document.addEventListener('click', () => {
                    this.state.user.clicks++;
                    this.state.user.lastAction = Date.now();
                    this.updateUserPattern();
                });

                // Track keypresses
                document.addEventListener('keypress', () => {
                    this.state.user.keystrokes++;
                    this.state.user.lastAction = Date.now();
                    this.updateUserPattern();
                });

                // Track window changes
                const observer = new MutationObserver((mutations) => {
                    mutations.forEach((mutation) => {
                        mutation.addedNodes.forEach((node) => {
                            if (node.classList && node.classList.contains('window')) {
                                const title = node.querySelector('.window-title')?.textContent || 'Unknown';
                                this.state.system.windowCount++;
                                this.state.system.lastWindowOpened = title;
                                this.state.user.openWindows.push(title);
                                this.reactToWindowOpen(title);
                            }
                        });
                        mutation.removedNodes.forEach((node) => {
                            if (node.classList && node.classList.contains('window')) {
                                this.state.system.windowCount--;
                            }
                        });
                    });
                });

                observer.observe(document.body, { childList: true, subtree: true });

                // Update state every 500ms
                this.stateUpdateInterval = setInterval(() => {
                    this.updateState();
                }, 500);
            }

            updateState() {
                const timeSinceAction = Date.now() - this.state.user.lastAction;

                if (timeSinceAction > 30000) {
                    this.state.user.activity = 'idle';
                } else if (timeSinceAction < 2000) {
                    this.state.user.activity = 'active';
                } else {
                    this.state.user.activity = 'moderate';
                }

                this.state.system.uptime = Math.floor((Date.now() - window.clippyGovernor.startTime) / 1000);
            }

            updateUserPattern() {
                const { clicks, keystrokes, openWindows } = this.state.user;

                // Detect patterns based on behavior
                if (openWindows.some(w => w.includes('FreeCell') || w.includes('Minesweeper') || w.includes('Solitaire'))) {
                    this.state.user.pattern = 'gaming';
                } else if (openWindows.some(w => w.includes('Terminal') || w.includes('Notepad'))) {
                    this.state.user.pattern = 'working';
                } else if (openWindows.some(w => w.includes('Internet Explorer'))) {
                    this.state.user.pattern = 'browsing';
                } else {
                    this.state.user.pattern = 'exploring';
                }
            }

            reactToWindowOpen(title) {
                // Different Clippies react to different window types
                // 40% chance to show any Clippy to avoid being annoying
                if (Math.random() > 0.4) return;

                let role = 'helper';
                let message = '';

                // Games - Coach or Entertainer responds
                if (title.includes('FreeCell') || title.includes('Solitaire') || title.includes('Minesweeper')) {
                    if (Math.random() > 0.5) {
                        role = 'coach';
                        message = this.generateCoachGameMessage(title);
                    } else {
                        role = 'entertainer';
                        message = this.generateEntertainerGameMessage(title);
                    }
                }
                // Technical programs - Expert responds
                else if (title.includes('Terminal') || title.includes('Calculator')) {
                    role = 'expert';
                    message = this.generateExpertMessage(title);
                }
                // Creative programs - Helper or Entertainer
                else if (title.includes('Paint') || title.includes('Notepad')) {
                    if (Math.random() > 0.5) {
                        role = 'helper';
                        message = title.includes('Paint') ?
                            "üé® Working on some art? Paint has many tools in the toolbar!" :
                            "üìù It looks like you're writing something. Let me know if you need help!";
                    } else {
                        role = 'entertainer';
                        message = title.includes('Paint') ?
                            "üé® Ooh, art time! Paint me like one of your French... windows? üòÑ" :
                            "‚úçÔ∏è Writing the next great novel? Or just a grocery list? Either way, I'm here! üòä";
                    }
                }
                // Control Panel - Manager responds
                else if (title.includes('Control Panel') || title.includes('Settings')) {
                    role = 'manager';
                    message = "üìä Control Panel opened! Let's optimize your system settings for maximum productivity!";
                }
                // Internet Explorer - Expert or Manager
                else if (title.includes('Internet Explorer') || title.includes('Browser')) {
                    role = Math.random() > 0.5 ? 'expert' : 'manager';
                    message = role === 'expert' ?
                        "üåê Browsing mode activated. Pro tip: You can bookmark pages for faster access!" :
                        "üîç Internet Explorer ready! Stay organized - bookmark your favorite sites!";
                }
                // LocalFirst Tools - Manager
                else if (title.includes('LocalFirst') || title.includes('Tools')) {
                    role = 'manager';
                    message = "üõ†Ô∏è Excellent choice! LocalFirst tools help you stay productive and organized!";
                }
                else {
                    // Don't show for other programs
                    return;
                }

                setTimeout(() => {
                    this.showClippy(role, message);
                }, 2000);
            }

            generateCoachGameMessage(title) {
                const messages = {
                    'FreeCell': [
                        "üí™ FreeCell time! You're going to crush this! Strategic thinking is your superpower!",
                        "üèÜ Ready to dominate FreeCell? Remember: plan ahead and victory is yours!",
                        "üî• FreeCell challenge accepted! I believe in you! Keep those free cells clear!",
                        "‚≠ê Game on! FreeCell requires skill and you've got it! Show me what you got!"
                    ],
                    'Minesweeper': [
                        "üí£ Minesweeper! Time to show those mines who's boss! You've got the logic!",
                        "üèÖ Minesweeper challenge! Stay focused, use those numbers, you're doing AMAZING!",
                        "üéØ Mine hunting time! Every correct flag is a step toward victory! GO GO GO!",
                        "üí™ Minesweeper master in action! Trust your instincts and flag those mines!"
                    ],
                    'Solitaire': [
                        "üÉè Solitaire! A true classic! Build those foundations and claim victory!",
                        "üèÜ Patience and strategy! You're going to ace this game! Literally! üòÑ",
                        "‚≠ê Solitaire time! Every card in the right place is progress! Keep going!",
                        "üí™ Card master activated! You've got the patience and skill to win this!"
                    ]
                };

                for (let key in messages) {
                    if (title.includes(key)) {
                        return messages[key][Math.floor(Math.random() * messages[key].length)];
                    }
                }
                return "üéÆ Game time! You're going to rock this! I'm cheering for you! üéâ";
            }

            generateEntertainerGameMessage(title) {
                const messages = {
                    'FreeCell': [
                        "üé¥ FreeCell! Or as I call it... 'Cell Phone' but with cards! üì±üòÇ",
                        "üé™ FreeCell time! Warning: May cause extreme satisfaction upon winning! üèÜ‚ú®",
                        "üéâ FreeCell! Fun fact: It's called 'Free' but your time is the price! üòÑ‚è∞"
                    ],
                    'Minesweeper': [
                        "üí£ Minesweeper! It's like a treasure hunt... where the treasure is NOT exploding! üí•üòÖ",
                        "üé™ Minesweeper! Remember: when life gives you mines, flag them! üö©üòÇ",
                        "üéÆ Minesweeper! The most stressful clicking game since... well, ever! Good luck! ‚ú®"
                    ],
                    'Solitaire': [
                        "üÉè Solitaire! Perfect for when you want to feel productive while procrastinating! üòÑ",
                        "üé™ Solitaire! It's you vs. the deck! My money's on you! üí∞üòä",
                        "‚ú® Solitaire! The original 'one player mode' before it was cool! üéÆ"
                    ]
                };

                for (let key in messages) {
                    if (title.includes(key)) {
                        return messages[key][Math.floor(Math.random() * messages[key].length)];
                    }
                }
                return "üéÆ Game time! Let's have some fun! Remember: winning is fun, but so is losing... wait, no it's not! üòÇ";
            }

            generateExpertMessage(title) {
                if (title.includes('Terminal')) {
                    const messages = [
                        "‚ö° Terminal accessed. Pro tip: Use 'ls -la' for detailed file listings with permissions.",
                        "üîß Terminal mode. Advanced users know: Tab completion saves significant time.",
                        "üí° Terminal ready. Efficiency tip: Pipe commands together for powerful workflows.",
                        "‚å®Ô∏è Terminal initialized. Power user trick: Use 'history' to recall previous commands.",
                        "üìä Terminal active. Performance note: Batch operations are faster than repeated single commands."
                    ];
                    return messages[Math.floor(Math.random() * messages.length)];
                } else if (title.includes('Calculator')) {
                    return "üî¢ Calculator opened. Pro tip: Use keyboard for faster input. Number pad is your friend!";
                }
                return "üíª Advanced program detected. Optimize your workflow with keyboard shortcuts!";
            }

            generateGameMessage(game) {
                const messages = {
                    'FreeCell': [
                        "üé¥ FreeCell! Strategy is key - plan your moves ahead!",
                        "üèÜ Ready to win? Remember: Ace goes first on foundations!",
                        "üéØ Pro tip: Keep free cells available for complex moves!"
                    ],
                    'Minesweeper': [
                        "üí£ Minesweeper! Logic puzzle time! You got this!",
                        "üèÜ Flag those mines! Right-click to mark suspicious spots!",
                        "üéØ Numbers show adjacent mines - use them wisely!"
                    ],
                    'Solitaire': [
                        "üÉè Solitaire! Classic patience game - enjoy!",
                        "üèÜ Build those foundations! Ace to King!",
                        "üéØ Sometimes you need to move cards back down to progress!"
                    ]
                };

                for (let key in messages) {
                    if (game.includes(key)) {
                        return messages[key][Math.floor(Math.random() * messages[key].length)];
                    }
                }

                return "üéÆ Game on! Have fun!";
            }

            generateTerminalMessage() {
                const messages = [
                    "üíª Terminal opened! Type 'help' to see all available commands.",
                    "üéì Pro tip: Your files persist between sessions automatically!",
                    "üìÅ Try 'tree' to visualize your directory structure.",
                    "üêÆ Fun command: Try 'cowsay hello' for a surprise!"
                ];
                return messages[Math.floor(Math.random() * messages.length)];
            }

            showClippy(role, message) {
                const clippy = this.instances.find(c => c.role === role);
                if (!clippy) return;

                // Don't show if already active
                if (clippy.active) return;

                const bubble = clippy.element.querySelector('.clippy-bubble');
                const msgEl = clippy.element.querySelector('.clippy-message');

                msgEl.textContent = message;
                bubble.style.display = 'block';
                clippy.active = true;
                clippy.message = message;

                // Auto-hide after 10 seconds
                setTimeout(() => {
                    if (clippy.active) {
                        bubble.style.display = 'none';
                        clippy.active = false;
                    }
                }, 10000);
            }

            hideClippy(role) {
                const clippy = this.instances.find(c => c.role === role);
                if (!clippy) return;

                const bubble = clippy.element.querySelector('.clippy-bubble');
                bubble.style.display = 'none';
                clippy.active = false;
            }

            toggleClippy(role) {
                const clippy = this.instances.find(c => c.role === role);
                if (!clippy) return;

                if (clippy.active) {
                    this.hideClippy(role);
                } else {
                    const randomTip = this.generateRandomTip(role);
                    this.showClippy(role, randomTip);
                }
            }

            generateRandomTip(role) {
                const tipsByRole = {
                    helper: [
                        "Need help? Click the Start button to see all programs!",
                        "Right-click the desktop to see more options.",
                        "You can drag windows by their title bars to move them.",
                        "Double-click desktop icons to open programs quickly!",
                        "The Start menu has all your programs organized by category.",
                        "Need to close a window? Click the X button in the top-right corner.",
                        "You can minimize windows to the taskbar to reduce clutter.",
                        "Stuck? Try right-clicking - it often shows helpful options!",
                        "The taskbar at the bottom shows all open windows.",
                        "Click and drag window edges to resize them!"
                    ],
                    entertainer: [
                        "üéÆ Try the games in the Start menu! They're nostalgically awesome!",
                        "üòÑ Fun fact: Windows 95 was released on August 24, 1995!",
                        "üé™ Want to hear a joke? Why did the computer go to therapy? Too many bad memories! üòÇ",
                        "‚ú® Easter egg time! Try clicking me multiple times... just kidding, I don't bite!",
                        "üéâ Did you know? The Windows 95 startup sound was composed by Brian Eno!",
                        "üé≠ Pro tip: Having fun is the most important optimization! üòä",
                        "üé® Paint can make some seriously awesome pixel art! Get creative!",
                        "üé™ Life is too short for boring computers! Explore and have fun!",
                        "üòÇ Why was the computer cold? It left its Windows open! ...I'll see myself out.",
                        "‚ú® Remember: You're not just using Windows 95, you're experiencing history!"
                    ],
                    expert: [
                        "‚ö° Pro tip: Right-click + drag for advanced window manipulation.",
                        "‚å®Ô∏è Keyboard shortcut: Alt+F4 closes the active window instantly.",
                        "üîß Terminal power: Chain commands with && for sequential execution.",
                        "üí° Efficiency: Use Tab to autocomplete in Terminal - saves 73% typing time.",
                        "üìä Advanced: Monitor system resources in the taskbar status area.",
                        "‚ö° Speed tip: Keyboard navigation is 3x faster than mouse for power users.",
                        "üîß Pro technique: Use Ctrl+C to copy, Ctrl+V to paste in most programs.",
                        "üíª Terminal ninja: Use 'clear' command to clean up the screen quickly.",
                        "‚å®Ô∏è Advanced: Arrow keys navigate Terminal command history efficiently.",
                        "üìä Performance: Close unused windows to optimize memory usage."
                    ],
                    coach: [
                        "üí™ You're doing great! Keep exploring and learning!",
                        "üèÜ Every program you open is progress! You're leveling up!",
                        "üî• Challenge yourself: Try opening 3 programs at once! You can do it!",
                        "‚≠ê Achievement idea: Win a game of Minesweeper! I believe in you!",
                        "üéØ Goal setting: Try to learn one new program today! You got this!",
                        "üí™ Push yourself: Experiment with the Control Panel settings!",
                        "üèÖ You're becoming a Windows 95 expert! Keep it up!",
                        "üî• Next level: Master the keyboard shortcuts! You're ready!",
                        "‚≠ê Personal best incoming: Try to beat your game scores!",
                        "üéØ Daily challenge: Open every program at least once! Adventure awaits!"
                    ],
                    manager: [
                        "üìÅ Organization tip: Group similar programs together in your workflow.",
                        "‚è∞ Time management: Close programs you're not using to stay focused.",
                        "üìä Productivity boost: Learn one keyboard shortcut per day for efficiency.",
                        "üóÇÔ∏è File management: Use Notepad to keep track of your tasks and notes.",
                        "‚úÖ Task prioritization: Start with important programs, then explore others.",
                        "üìã Workflow optimization: Arrange windows side-by-side for multitasking.",
                        "‚è∞ Time blocking: Dedicate specific time to games vs. work programs.",
                        "üìä Metrics matter: Track how many programs you've mastered!",
                        "üóÇÔ∏è Best practice: Save your work frequently in Notepad and Paint.",
                        "‚úÖ Daily routine: Start with Control Panel, end with something fun!"
                    ]
                };

                const tips = tipsByRole[role] || tipsByRole.helper;
                return tips[Math.floor(Math.random() * tips.length)];
            }

            // ========================================
            // CONTEXTUAL REACTIONS
            // ========================================

            detectStruggle() {
                // If user has been clicking excessively, they might be struggling
                if (this.state.user.clicks > 80) {
                    this.showClippy('helper', "Need help? Click me if you'd like assistance!");
                    this.state.user.clicks = 0; // Reset counter
                }
            }

            // ========================================
            // INTER-CLIPPY COMMUNICATION
            // ========================================

            startConversation(topic) {
                if (this.state.conversation.active) return; // Already in a conversation

                this.state.conversation.active = true;
                this.state.conversation.topic = topic;

                // Occasional fun conversations between Clippies (5% chance every 2 minutes)
                if (Math.random() < 0.05) {
                    this.triggerClippyConversation();
                }
            }

            triggerClippyConversation() {
                const conversations = [
                    {
                        sequence: [
                            { role: 'entertainer', message: "üé™ Hey Clippit! Want to hear a joke?", delay: 1000 },
                            { role: 'helper', message: "Sure! But keep it short - I'm helping users here! üìé", delay: 3000 },
                            { role: 'entertainer', message: "Why did the Windows 95 user get glasses? To improve their SCREEN resolution! üòÇ", delay: 5000 },
                            { role: 'helper', message: "üòä That's actually pretty good! Back to work though!", delay: 8000 }
                        ]
                    },
                    {
                        sequence: [
                            { role: 'coach', message: "üí™ Team! We're doing great supporting the user today!", delay: 1000 },
                            { role: 'manager', message: "üìä Agreed! Our assistance efficiency is up 42%!", delay: 3000 },
                            { role: 'expert', message: "‚ö° Optimization is key. Keep up the good work, team.", delay: 5000 }
                        ]
                    },
                    {
                        sequence: [
                            { role: 'expert', message: "ü§ì Did you know Windows 95 used 4-16 MB of RAM?", delay: 1000 },
                            { role: 'entertainer', message: "üé≠ My phone has more RAM than that now! We're ancient! üòÑ", delay: 3000 },
                            { role: 'coach', message: "üèÜ Ancient but LEGENDARY! Classic never goes out of style!", delay: 5000 }
                        ]
                    },
                    {
                        sequence: [
                            { role: 'manager', message: "üìã Reminder: Let's keep our tips organized and efficient!", delay: 1000 },
                            { role: 'helper', message: "üìé Good point! I'll focus on step-by-step guidance.", delay: 3000 },
                            { role: 'entertainer', message: "üé™ And I'll keep the fun levels at maximum! üéâ", delay: 5000 }
                        ]
                    }
                ];

                const conversation = conversations[Math.floor(Math.random() * conversations.length)];

                conversation.sequence.forEach((line, index) => {
                    setTimeout(() => {
                        this.showClippy(line.role, line.message);

                        // End conversation after last message
                        if (index === conversation.sequence.length - 1) {
                            setTimeout(() => {
                                this.state.conversation.active = false;
                            }, 10000);
                        }
                    }, line.delay);
                });
            }

            // Achievement system
            checkAchievements() {
                const achievements = {
                    explorer: { check: () => this.state.system.windowCount >= 5, message: "üèÜ Explorer! You've opened 5 programs!" },
                    multitasker: { check: () => this.state.user.openWindows.length >= 3, message: "üéØ Multitasker! Managing multiple windows like a pro!" },
                    gamer: { check: () => this.state.user.pattern === 'gaming', message: "üéÆ Gamer! Time to have some fun!" },
                    powerUser: { check: () => this.state.user.keystrokes > 100, message: "‚ö° Power User! Those keyboard skills are impressive!" }
                };

                for (let [key, achievement] of Object.entries(achievements)) {
                    if (achievement.check() && !this.achievementsUnlocked?.[key]) {
                        this.achievementsUnlocked = this.achievementsUnlocked || {};
                        this.achievementsUnlocked[key] = true;
                        this.showClippy('coach', achievement.message);
                        break; // Only one achievement at a time
                    }
                }
            }
        }

        // ========================================
        // INITIALIZE CLIPPY ASSISTANT
        // ========================================

        let clippyGovernor;
        window.addEventListener('load', () => {
            setTimeout(() => {
                clippyGovernor = new ClippyGovernor();
                clippyGovernor.startTime = Date.now();
                window.clippyGovernor = clippyGovernor; // Make globally accessible

                // Check for user struggles (every minute)
                setInterval(() => {
                    clippyGovernor.detectStruggle();
                }, 60000);

                // Check for achievements (every 30 seconds)
                setInterval(() => {
                    clippyGovernor.checkAchievements();
                }, 30000);

                // Occasionally trigger inter-Clippy conversations (every 2 minutes)
                setInterval(() => {
                    if (Math.random() < 0.15) { // 15% chance
                        clippyGovernor.triggerClippyConversation();
                    }
                }, 120000);

                console.log('üìé Multi-Clippy assistant team ready with 5 specialized personalities!');
            }, 1000);
        });

        // ========================================
        // EASTER EGG SYSTEM
        // ========================================

        class EasterEggManager {
            constructor() {
                this.konami = [];
                this.konamiCode = ['ArrowUp', 'ArrowUp', 'ArrowDown', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'ArrowLeft', 'ArrowRight', 'b', 'a'];
                this.clickSequence = [];
                this.secretClicks = 0;
                this.init();
            }

            init() {
                // Konami code listener
                document.addEventListener('keydown', (e) => {
                    this.konami.push(e.key);
                    if (this.konami.length > this.konamiCode.length) {
                        this.konami.shift();
                    }
                    if (this.checkKonami()) {
                        this.activateKonamiCode();
                    }
                });

                // Secret logo click counter
                const logos = document.querySelectorAll('.logo');
                logos.forEach(logo => {
                    logo.addEventListener('click', () => {
                        this.secretClicks++;
                        if (this.secretClicks === 10) {
                            this.activateLogoEasterEgg();
                            this.secretClicks = 0;
                        }
                    });
                });

                // Ctrl+Alt+Del easter egg
                document.addEventListener('keydown', (e) => {
                    if (e.ctrlKey && e.altKey && e.key === 'Delete') {
                        e.preventDefault();
                        this.showBlueScreen();
                    }
                });

                // Type "win95" anywhere easter egg
                let typeBuffer = '';
                document.addEventListener('keypress', (e) => {
                    typeBuffer += e.key;
                    if (typeBuffer.length > 5) typeBuffer = typeBuffer.slice(-5);
                    if (typeBuffer === 'win95') {
                        this.showWin95Facts();
                        typeBuffer = '';
                    }
                });

                // Triple-click taskbar easter egg
                let taskbarClicks = 0;
                const taskbar = document.getElementById('taskbar');
                if (taskbar) {
                    taskbar.addEventListener('click', () => {
                        taskbarClicks++;
                        setTimeout(() => { taskbarClicks = 0; }, 1000);
                        if (taskbarClicks === 3) {
                            this.showTaskbarEasterEgg();
                            taskbarClicks = 0;
                        }
                    });
                }

                console.log('Easter egg system activated! Try discovering hidden features...');
            }

            checkKonami() {
                return this.konami.join(',') === this.konamiCode.join(',');
            }

            activateKonamiCode() {
                if (window.toastManager) {
                    window.toastManager.show(
                        'üéÆ Konami Code Activated!',
                        'You unlocked God Mode! All Clippies will now share their wisdom simultaneously! üöÄ'
                    );
                }

                // Trigger all Clippies at once
                if (window.clippyGovernor) {
                    setTimeout(() => {
                        window.clippyGovernor.showClippy('helper', "üéÆ Konami Code detected! I'm here to help!");
                    }, 500);
                    setTimeout(() => {
                        window.clippyGovernor.showClippy('entertainer', "üòÑ Party time! Konami Code = Instant fun!");
                    }, 1000);
                    setTimeout(() => {
                        window.clippyGovernor.showClippy('expert', "‚ö° Elite gamer detected. Maximum efficiency unlocked!");
                    }, 1500);
                    setTimeout(() => {
                        window.clippyGovernor.showClippy('coach', "üí™ LEGENDARY! You're a true gaming master!");
                    }, 2000);
                    setTimeout(() => {
                        window.clippyGovernor.showClippy('manager', "üìä Achievement: Konami Code Master! Productivity +1000%!");
                    }, 2500);
                }

                // Activate special screen effect
                this.konamiScreenEffect();
            }

            konamiScreenEffect() {
                const overlay = document.createElement('div');
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100vw;
                    height: 100vh;
                    background: linear-gradient(45deg, red, yellow, green, blue, purple);
                    opacity: 0.3;
                    z-index: 9998;
                    pointer-events: none;
                    animation: rainbow 2s infinite;
                `;

                const style = document.createElement('style');
                style.textContent = `
                    @keyframes rainbow {
                        0% { filter: hue-rotate(0deg); }
                        100% { filter: hue-rotate(360deg); }
                    }
                `;
                document.head.appendChild(style);
                document.body.appendChild(overlay);

                setTimeout(() => {
                    overlay.remove();
                    style.remove();
                }, 5000);
            }

            activateLogoEasterEgg() {
                if (window.toastManager) {
                    window.toastManager.show(
                        'üé® Logo Master!',
                        'You clicked the Windows logo 10 times! The 90s called - they want their colors back! üåà'
                    );
                }

                // Crazy spinning logos
                const logos = document.querySelectorAll('.logo');
                logos.forEach(logo => {
                    logo.style.animation = 'spin 1s linear 5';
                });
            }

            showBlueScreen() {
                const bsod = document.createElement('div');
                bsod.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100vw;
                    height: 100vh;
                    background: #0000aa;
                    color: white;
                    font-family: 'Courier New', monospace;
                    padding: 40px;
                    z-index: 999999;
                    display: flex;
                    flex-direction: column;
                    gap: 20px;
                `;

                bsod.innerHTML = `
                    <div style="font-size: 20px; text-align: center;">
                        Windows<br>
                        A fatal exception 0E has occurred at 0028:C0011E36 in VXD VMM(01) +<br>
                        00010E36. The current application will be terminated.
                    </div>
                    <div style="margin-top: 20px;">
                        * Press any key to terminate the current application.<br>
                        * Press CTRL+ALT+DEL again to restart your computer. You will<br>
                          lose any unsaved information in all applications.
                    </div>
                    <div style="margin-top: 20px; text-align: center;">
                        Press any key to continue _
                    </div>
                    <div style="margin-top: 40px; text-align: center; font-size: 12px; opacity: 0.7;">
                        (Just kidding! This is an Easter egg. Click anywhere to close.)
                    </div>
                `;

                document.body.appendChild(bsod);

                const close = () => {
                    bsod.remove();
                    document.removeEventListener('keydown', close);
                    bsod.removeEventListener('click', close);
                };

                document.addEventListener('keydown', close);
                bsod.addEventListener('click', close);

                if (window.toastManager) {
                    setTimeout(() => {
                        if (bsod.parentElement) {
                            window.toastManager.show(
                                'üò® BSOD Easter Egg',
                                "Don't panic! This is just for fun. Windows 95 users know this screen all too well!"
                            );
                        }
                    }, 2000);
                }
            }

            showWin95Facts() {
                const facts = [
                    'Windows 95 was released on August 24, 1995, with a massive $300 million marketing campaign!',
                    'The Windows 95 startup sound was composed by Brian Eno in just 3.25 seconds!',
                    'Windows 95 could run on just 4MB of RAM (imagine that today!).',
                    'The Rolling Stones "Start Me Up" was the theme song for Windows 95!',
                    'Windows 95 sold 7 million copies in the first 5 weeks!',
                    'Internet Explorer was not included in the original Windows 95 release.',
                    'Windows 95 introduced the Start button and taskbar - still used today!',
                    'The development codename for Windows 95 was "Chicago".',
                    'Windows 95 was the first Windows to include Plug and Play support.',
                    'Bill Gates and Jay Leno hosted the Windows 95 launch event!'
                ];

                const randomFact = facts[Math.floor(Math.random() * facts.length)];

                if (window.toastManager) {
                    window.toastManager.show(
                        'üí° Windows 95 Fun Fact',
                        randomFact,
                        8000
                    );
                }

                if (window.clippyGovernor) {
                    setTimeout(() => {
                        window.clippyGovernor.showClippy('entertainer',
                            'üéâ Fun fact unlocked! Type "win95" anytime for more nostalgic knowledge!'
                        );
                    }, 500);
                }
            }

            showTaskbarEasterEgg() {
                if (window.toastManager) {
                    window.toastManager.show(
                        'üéØ Taskbar Master!',
                        'Triple-click discovery! The taskbar has been the heart of Windows since 1995. Keep clicking for productivity!'
                    );
                }

                // Taskbar wiggle animation
                const taskbar = document.getElementById('taskbar');
                if (taskbar) {
                    taskbar.style.animation = 'wiggle 0.5s ease-in-out 3';
                    const style = document.createElement('style');
                    style.textContent = `
                        @keyframes wiggle {
                            0%, 100% { transform: translateX(0); }
                            25% { transform: translateX(-10px); }
                            75% { transform: translateX(10px); }
                        }
                    `;
                    document.head.appendChild(style);
                    setTimeout(() => {
                        if (taskbar) taskbar.style.animation = '';
                        style.remove();
                    }, 1500);
                }
            }

            // Hidden feature: Unlock advanced mode
            unlockAdvancedMode() {
                if (window.toastManager) {
                    window.toastManager.show(
                        'üîì Advanced Mode Unlocked!',
                        'You have discovered advanced features! Check the console for developer tools.'
                    );
                }

                console.log(`
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë           WINDOWS 95 EMULATOR - ADVANCED MODE             ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë  Available global objects:                                ‚ïë
‚ïë  ‚Ä¢ emulator - Main emulator instance                      ‚ïë
‚ïë  ‚Ä¢ clippyGovernor - Multi-agent assistant system          ‚ïë
‚ïë  ‚Ä¢ screenSaverManager - Screen saver controls             ‚ïë
‚ïë  ‚Ä¢ toastManager - Notification system                     ‚ïë
‚ïë                                                            ‚ïë
‚ïë  Hidden Commands:                                         ‚ïë
‚ïë  ‚Ä¢ emulator.showAllPrograms() - List all programs         ‚ïë
‚ïë  ‚Ä¢ clippyGovernor.triggerClippyConversation() - Chat      ‚ïë
‚ïë  ‚Ä¢ screenSaverManager.activate() - Instant screensaver    ‚ïë
‚ïë  ‚Ä¢ toastManager.show('Title', 'Message') - Toast          ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
                `);
            }
        }

        // Initialize Easter Egg system
        let easterEggManager;
        window.addEventListener('load', () => {
            setTimeout(() => {
                easterEggManager = new EasterEggManager();
                window.easterEggManager = easterEggManager;
                console.log('ü•ö Easter eggs hidden throughout the system. Happy hunting!');
            }, 1500);
        });
    </script>
</body>
</html>
