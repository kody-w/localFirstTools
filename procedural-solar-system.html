<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Solar System Builder</title>
    <meta name="description" content="Procedural 3D solar system generator with interactive zoom into planets and moons.">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            overflow: hidden;
            background-color: #000;
            color: white;
            font-family: 'Segoe UI', system-ui, sans-serif;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 10px;
            pointer-events: none;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            max-width: 300px;
        }

        #info h2 {
            background: linear-gradient(90deg, #ff6b6b, #4ecdc4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }

        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            padding: 15px 25px;
            border-radius: 30px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            display: flex;
            gap: 10px;
        }

        button {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 10px 20px;
            cursor: pointer;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button.secondary {
            background: rgba(255,255,255,0.1);
        }

        button.secondary:hover {
            background: rgba(255,255,255,0.2);
        }

        /* Object Detail Panel */
        #detail-panel {
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(0,0,0,0.85);
            padding: 25px;
            border-radius: 15px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255,255,255,0.15);
            width: 320px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.4s ease, transform 0.4s ease;
        }

        #detail-panel.visible {
            opacity: 1;
            pointer-events: all;
        }

        #detail-panel h3 {
            font-size: 1.5em;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        #detail-panel .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }

        #detail-panel .stat-label {
            color: rgba(255,255,255,0.6);
        }

        #detail-panel .stat-value {
            color: #4ecdc4;
            font-weight: 500;
        }

        #detail-panel .description {
            margin-top: 15px;
            color: rgba(255,255,255,0.7);
            line-height: 1.6;
            font-size: 0.9em;
        }

        #detail-panel .moons-section {
            margin-top: 20px;
        }

        #detail-panel .moons-section h4 {
            color: #ff6b6b;
            margin-bottom: 10px;
        }

        #detail-panel .moon-item {
            background: rgba(255,255,255,0.05);
            padding: 10px 15px;
            border-radius: 8px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #detail-panel .moon-item:hover {
            background: rgba(255,255,255,0.1);
            transform: translateX(5px);
        }

        #detail-panel .moon-item .zoom-hint {
            font-size: 0.8em;
            color: rgba(255,255,255,0.4);
        }

        #back-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            background: rgba(255,100,100,0.8);
        }

        #back-btn.visible {
            opacity: 1;
            pointer-events: all;
        }

        /* Clickable indicator */
        #click-hint {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.6);
            padding: 8px 20px;
            border-radius: 20px;
            font-size: 0.9em;
            color: rgba(255,255,255,0.7);
            pointer-events: none;
        }

        /* Loading indicator */
        .transitioning::after {
            content: '';
            position: fixed;
            top: 50%;
            left: 50%;
            width: 40px;
            height: 40px;
            margin: -20px 0 0 -20px;
            border: 3px solid rgba(255,255,255,0.1);
            border-top-color: #4ecdc4;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Star glow effect */
        .star-glow {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 200px;
            height: 200px;
            margin: -100px 0 0 -100px;
            background: radial-gradient(circle, rgba(255,200,100,0.3) 0%, transparent 70%);
            pointer-events: none;
            opacity: 0.5;
        }

        /* View mode indicator */
        #view-mode {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.8), rgba(118, 75, 162, 0.8));
            padding: 8px 25px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: 500;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        #view-mode.visible {
            opacity: 1;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
    <div id="info">
        <h2>Procedural Solar System</h2>
        <p>Click on any planet or moon to zoom in for an orbital view.</p>
        <div id="system-stats"></div>
    </div>

    <div id="view-mode">Orbiting: <span id="view-target"></span></div>

    <button id="back-btn">Back to System View</button>

    <div id="detail-panel">
        <h3 id="detail-name">Planet Name</h3>
        <div id="detail-stats"></div>
        <div class="description" id="detail-description"></div>
        <div class="moons-section" id="moons-section" style="display: none;">
            <h4>Moons</h4>
            <div id="moons-list"></div>
        </div>
    </div>

    <div id="controls">
        <button id="generate-btn">Generate New System</button>
        <button id="toggle-orbits" class="secondary">Toggle Orbits</button>
        <button id="toggle-labels" class="secondary">Toggle Labels</button>
        <button id="speed-btn" class="secondary">Speed: 1x</button>
    </div>

    <div id="click-hint">Click on any celestial body to explore</div>

    <script>
        // ========================================
        // SCENE SETUP
        // ========================================
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 10000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // Orbit Controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 5;
        controls.maxDistance = 2000;
        controls.autoRotate = false;
        controls.autoRotateSpeed = 0.5;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x222222);
        scene.add(ambientLight);

        const pointLight = new THREE.PointLight(0xffffff, 2, 3000);
        scene.add(pointLight);

        // Raycaster for click detection
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // ========================================
        // STATE MANAGEMENT
        // ========================================
        let star = null;
        let planets = [];
        let allClickableObjects = [];
        let showOrbits = true;
        let showLabels = true;
        let timeSpeed = 1;
        let currentView = 'system'; // 'system', 'planet', 'moon'
        let focusedObject = null;
        let targetCameraPosition = null;
        let targetLookAt = null;
        let isTransitioning = false;
        let starData = null;
        let cameraOffset = null; // Store offset from focused object

        // Planet name generators
        const prefixes = ['Kepler', 'Proxima', 'Tau', 'Epsilon', 'Zeta', 'Omicron', 'Sigma', 'Delta', 'Gamma', 'Nova'];
        const suffixes = ['Prime', 'Major', 'Minor', 'Alpha', 'Beta', 'Centauri', 'Reticuli', 'Eridani', 'Cygni', 'Draconis'];
        const moonPrefixes = ['Io', 'Europa', 'Titan', 'Phobos', 'Deimos', 'Triton', 'Charon', 'Ganymede', 'Callisto', 'Enceladus'];

        function generateName() {
            return prefixes[Math.floor(Math.random() * prefixes.length)] + '-' +
                   Math.floor(Math.random() * 999) +
                   (Math.random() > 0.5 ? ' ' + suffixes[Math.floor(Math.random() * suffixes.length)] : '');
        }

        function generateMoonName() {
            return moonPrefixes[Math.floor(Math.random() * moonPrefixes.length)] + '-' +
                   String.fromCharCode(65 + Math.floor(Math.random() * 26));
        }

        // Planet type descriptions
        const planetDescriptions = {
            gas: [
                "A massive gas giant with swirling storms visible from orbit. Hydrogen and helium dominate its atmosphere.",
                "This jovian world features colorful bands of ammonia clouds racing around its equator at tremendous speeds.",
                "A frigid ice giant with a distinctive blue-green hue from methane in its upper atmosphere.",
                "Storm systems larger than terrestrial worlds rage across this gas giant's turbulent surface."
            ],
            terran: [
                "A rocky terrestrial world with potential for surface water and geological activity.",
                "This small rocky planet shows signs of ancient volcanic activity and impact craters.",
                "A dense iron-core world with a thin atmosphere of carbon dioxide and nitrogen.",
                "Surface scans reveal mountain ranges and vast plains of silicate rock."
            ]
        };

        const moonDescriptions = [
            "A small rocky satellite with a heavily cratered surface from billions of years of impacts.",
            "This moon shows signs of cryovolcanic activity, potentially harboring a subsurface ocean.",
            "Tidal forces from the parent planet keep this moon geologically active.",
            "A captured asteroid now locked in orbit around its host planet."
        ];

        // ========================================
        // TEXTURE GENERATION
        // ========================================
        function createPlanetTexture(type, colorHex) {
            const canvas = document.createElement('canvas');
            canvas.width = 1024;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            // Parse color
            const color = new THREE.Color(colorHex);
            const r = Math.floor(color.r * 255);
            const g = Math.floor(color.g * 255);
            const b = Math.floor(color.b * 255);

            // Base gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, 512);
            gradient.addColorStop(0, `rgba(${r},${g},${b},1)`);
            gradient.addColorStop(0.5, `rgba(${Math.floor(r*0.8)},${Math.floor(g*0.8)},${Math.floor(b*0.8)},1)`);
            gradient.addColorStop(1, `rgba(${r},${g},${b},1)`);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 1024, 512);

            // Add noise texture
            for (let i = 0; i < 5000; i++) {
                const x = Math.random() * 1024;
                const y = Math.random() * 512;
                const w = Math.random() * 30 + 5;
                const h = Math.random() * 15 + 3;
                const alpha = Math.random() * 0.15;
                ctx.fillStyle = Math.random() > 0.5 ?
                    `rgba(255,255,255,${alpha})` :
                    `rgba(0,0,0,${alpha})`;
                ctx.fillRect(x, y, w, h);
            }

            // Bands for gas giants
            if (type === 'gas') {
                for (let i = 0; i < 15; i++) {
                    const y = Math.random() * 512;
                    const h = Math.random() * 30 + 10;
                    ctx.fillStyle = `rgba(${Math.random() > 0.5 ? 255 : 0},${Math.random() > 0.5 ? 255 : 0},${Math.random() > 0.5 ? 255 : 0},${Math.random() * 0.2})`;
                    ctx.fillRect(0, y, 1024, h);
                }

                // Add storm spots
                for (let i = 0; i < 3; i++) {
                    const x = Math.random() * 1024;
                    const y = 150 + Math.random() * 200;
                    const radius = 20 + Math.random() * 40;
                    const grd = ctx.createRadialGradient(x, y, 0, x, y, radius);
                    grd.addColorStop(0, `rgba(255,200,150,0.5)`);
                    grd.addColorStop(1, 'transparent');
                    ctx.fillStyle = grd;
                    ctx.beginPath();
                    ctx.ellipse(x, y, radius * 1.5, radius, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
            } else {
                // Terran features - continents and oceans
                for (let i = 0; i < 8; i++) {
                    const x = Math.random() * 1024;
                    const y = Math.random() * 512;
                    const radius = 50 + Math.random() * 100;
                    const grd = ctx.createRadialGradient(x, y, 0, x, y, radius);
                    grd.addColorStop(0, `rgba(${100+Math.random()*50},${150+Math.random()*50},${100+Math.random()*50},0.6)`);
                    grd.addColorStop(1, 'transparent');
                    ctx.fillStyle = grd;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Ice caps
                ctx.fillStyle = 'rgba(255,255,255,0.4)';
                ctx.fillRect(0, 0, 1024, 30);
                ctx.fillRect(0, 482, 1024, 30);
            }

            return new THREE.CanvasTexture(canvas);
        }

        function createMoonTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');

            // Gray base
            ctx.fillStyle = '#666';
            ctx.fillRect(0, 0, 256, 128);

            // Craters
            for (let i = 0; i < 50; i++) {
                const x = Math.random() * 256;
                const y = Math.random() * 128;
                const radius = 2 + Math.random() * 8;
                const grd = ctx.createRadialGradient(x, y, 0, x, y, radius);
                grd.addColorStop(0, 'rgba(40,40,40,0.8)');
                grd.addColorStop(0.7, 'rgba(80,80,80,0.5)');
                grd.addColorStop(1, 'transparent');
                ctx.fillStyle = grd;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }

            return new THREE.CanvasTexture(canvas);
        }

        function createStarTexture(color) {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');

            const c = new THREE.Color(color);
            const gradient = ctx.createRadialGradient(128, 128, 0, 128, 128, 128);
            gradient.addColorStop(0, 'white');
            gradient.addColorStop(0.1, `rgb(${Math.floor(c.r*255)},${Math.floor(c.g*255)},${Math.floor(c.b*255)})`);
            gradient.addColorStop(0.4, `rgba(${Math.floor(c.r*200)},${Math.floor(c.g*150)},${Math.floor(c.b*100)},0.5)`);
            gradient.addColorStop(1, 'transparent');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 256, 256);

            return new THREE.CanvasTexture(canvas);
        }

        // ========================================
        // STARFIELD BACKGROUND
        // ========================================
        function createStarfield() {
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const colors = [];

            for (let i = 0; i < 10000; i++) {
                const x = (Math.random() - 0.5) * 8000;
                const y = (Math.random() - 0.5) * 8000;
                const z = (Math.random() - 0.5) * 8000;
                vertices.push(x, y, z);

                const brightness = 0.5 + Math.random() * 0.5;
                colors.push(brightness, brightness, brightness);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 2,
                vertexColors: true,
                transparent: true,
                opacity: 0.8
            });

            return new THREE.Points(geometry, material);
        }

        const starfield = createStarfield();
        scene.add(starfield);

        // ========================================
        // SOLAR SYSTEM GENERATION
        // ========================================
        function generateSystem() {
            // Clear old system
            if (star) {
                scene.remove(star);
                star.geometry.dispose();
                star.material.dispose();
            }

            planets.forEach(p => {
                scene.remove(p.mesh);
                scene.remove(p.orbitLine);
                if (p.label) scene.remove(p.label);
                p.mesh.geometry.dispose();
                p.mesh.material.dispose();
                if (p.moons) {
                    p.moons.forEach(m => {
                        p.mesh.remove(m.mesh);
                        if (m.label) p.mesh.remove(m.label);
                        m.mesh.geometry.dispose();
                        m.mesh.material.dispose();
                    });
                }
            });

            planets = [];
            allClickableObjects = [];

            // Reset view
            currentView = 'system';
            focusedObject = null;
            cameraOffset = null;
            document.getElementById('detail-panel').classList.remove('visible');
            document.getElementById('back-btn').classList.remove('visible');
            document.getElementById('view-mode').classList.remove('visible');
            controls.autoRotate = false;

            // Generate Star
            const starTypes = [
                { color: 0xffcc33, scale: 12, name: "Yellow Dwarf", temp: "5,500K", age: "4.6 billion years" },
                { color: 0xff5533, scale: 8, name: "Red Dwarf", temp: "3,000K", age: "10 billion years" },
                { color: 0x6699ff, scale: 18, name: "Blue Giant", temp: "20,000K", age: "10 million years" },
                { color: 0xffffff, scale: 14, name: "White Star", temp: "8,000K", age: "1 billion years" },
                { color: 0xffaa66, scale: 25, name: "Orange Giant", temp: "4,500K", age: "8 billion years" }
            ];

            const starType = starTypes[Math.floor(Math.random() * starTypes.length)];
            starData = { ...starType, systemName: generateName().split('-')[0] + ' System' };

            const starGeo = new THREE.SphereGeometry(starType.scale, 64, 64);
            const starMat = new THREE.MeshBasicMaterial({
                color: starType.color,
                transparent: true,
                opacity: 0.95
            });
            star = new THREE.Mesh(starGeo, starMat);
            star.userData = { type: 'star', data: starData };
            scene.add(star);
            allClickableObjects.push(star);

            // Star glow
            const glowGeo = new THREE.SphereGeometry(starType.scale * 1.5, 32, 32);
            const glowMat = new THREE.MeshBasicMaterial({
                color: starType.color,
                transparent: true,
                opacity: 0.2,
                side: THREE.BackSide
            });
            const glow = new THREE.Mesh(glowGeo, glowMat);
            star.add(glow);

            pointLight.color.setHex(starType.color);
            pointLight.intensity = starType.scale / 5;

            // Generate Planets
            const numPlanets = Math.floor(Math.random() * 7) + 4;
            let currentDist = starType.scale * 2.5 + 30;

            for (let i = 0; i < numPlanets; i++) {
                const type = Math.random() > 0.5 ? 'gas' : 'terran';
                const size = type === 'gas' ? (Math.random() * 5 + 4) : (Math.random() * 2 + 1);
                const dist = currentDist + Math.random() * 40 + 25;
                currentDist = dist;

                const speed = 0.008 / Math.sqrt(dist * 0.1);
                const colorHex = Math.random() * 0xffffff;
                const name = generateName();

                const planetGeo = new THREE.SphereGeometry(size, 64, 64);
                const planetMat = new THREE.MeshStandardMaterial({
                    map: createPlanetTexture(type, '#' + new THREE.Color(colorHex).getHexString()),
                    roughness: type === 'gas' ? 0.9 : 0.7,
                    metalness: type === 'gas' ? 0 : 0.1
                });
                const planet = new THREE.Mesh(planetGeo, planetMat);

                // Planet data
                const planetData = {
                    name: name,
                    type: type,
                    radius: size,
                    distance: dist,
                    orbitalPeriod: Math.floor(dist * 2) + ' Earth days',
                    temperature: type === 'gas' ? '-150C (cloud tops)' : (dist < 100 ? '+' + Math.floor(300 - dist * 2) + 'C' : Math.floor(dist * -1) + 'C'),
                    description: planetDescriptions[type][Math.floor(Math.random() * planetDescriptions[type].length)],
                    moons: []
                };

                planet.userData = { type: 'planet', data: planetData, index: i };
                allClickableObjects.push(planet);

                // Orbit Line
                const orbitGeo = new THREE.RingGeometry(dist - 0.3, dist + 0.3, 128);
                const orbitMat = new THREE.MeshBasicMaterial({
                    color: 0x444466,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.3
                });
                const orbitLine = new THREE.Mesh(orbitGeo, orbitMat);
                orbitLine.rotation.x = Math.PI / 2;
                scene.add(orbitLine);
                if (!showOrbits) orbitLine.visible = false;

                // Moons
                const moons = [];
                const numMoons = type === 'gas' ? Math.floor(Math.random() * 5) + 1 : (Math.random() > 0.6 ? Math.floor(Math.random() * 2) + 1 : 0);

                for (let j = 0; j < numMoons; j++) {
                    const mSize = size * (0.1 + Math.random() * 0.15);
                    const mDist = size * 2.5 + j * (size * 1.5) + Math.random() * 3;
                    const mSpeed = 0.03 + Math.random() * 0.03;
                    const moonName = generateMoonName();

                    const mGeo = new THREE.SphereGeometry(mSize, 32, 32);
                    const mMat = new THREE.MeshStandardMaterial({
                        map: createMoonTexture(),
                        roughness: 0.9
                    });
                    const moon = new THREE.Mesh(mGeo, mMat);

                    const moonData = {
                        name: moonName,
                        radius: mSize,
                        distance: mDist,
                        orbitalPeriod: Math.floor(mDist * 5) + ' hours',
                        description: moonDescriptions[Math.floor(Math.random() * moonDescriptions.length)],
                        parentPlanet: planetData.name
                    };

                    moon.userData = { type: 'moon', data: moonData, parentIndex: i };
                    allClickableObjects.push(moon);

                    planet.add(moon);
                    moons.push({
                        mesh: moon,
                        dist: mDist,
                        speed: mSpeed,
                        angle: Math.random() * Math.PI * 2,
                        data: moonData
                    });

                    planetData.moons.push(moonData);
                }

                // Rings for some gas giants
                if (type === 'gas' && Math.random() > 0.6) {
                    const ringGeo = new THREE.RingGeometry(size * 1.4, size * 2.2, 64);
                    const ringMat = new THREE.MeshBasicMaterial({
                        color: 0xccbbaa,
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 0.5
                    });
                    const ring = new THREE.Mesh(ringGeo, ringMat);
                    ring.rotation.x = Math.PI / 2 + (Math.random() - 0.5) * 0.3;
                    planet.add(ring);
                    planetData.hasRings = true;
                }

                scene.add(planet);
                planets.push({
                    mesh: planet,
                    dist: dist,
                    speed: speed,
                    angle: Math.random() * Math.PI * 2,
                    orbitLine: orbitLine,
                    moons: moons,
                    data: planetData
                });
            }

            // Update UI
            document.getElementById('system-stats').innerHTML = `
                <strong>System:</strong> ${starData.systemName}<br>
                <strong>Star:</strong> ${starType.name} (${starType.temp})<br>
                <strong>Planets:</strong> ${numPlanets}
            `;

            // Reset camera
            camera.position.set(0, 150, 300);
            camera.lookAt(0, 0, 0);
            controls.target.set(0, 0, 0);
        }

        // ========================================
        // CAMERA TRANSITIONS
        // ========================================
        function focusOnObject(object, viewType) {
            if (isTransitioning) return;

            isTransitioning = true;
            document.body.classList.add('transitioning');

            const data = object.userData.data;
            currentView = viewType;
            focusedObject = object;

            // Calculate target position based on object type
            let targetPos, targetLook;

            if (viewType === 'planet') {
                const planetPos = new THREE.Vector3();
                object.getWorldPosition(planetPos);
                const distance = data.radius * 6;

                targetPos = new THREE.Vector3(
                    planetPos.x + distance,
                    planetPos.y + distance * 0.5,
                    planetPos.z + distance
                );
                targetLook = planetPos;

                // Show detail panel
                showDetailPanel(data, 'planet');

            } else if (viewType === 'moon') {
                const moonPos = new THREE.Vector3();
                object.getWorldPosition(moonPos);
                const distance = data.radius * 15;

                targetPos = new THREE.Vector3(
                    moonPos.x + distance,
                    moonPos.y + distance * 0.3,
                    moonPos.z + distance
                );
                targetLook = moonPos;

                // Show detail panel for moon
                showDetailPanel(data, 'moon');

            } else if (viewType === 'star') {
                const distance = starData.scale * 5;
                targetPos = new THREE.Vector3(distance, distance * 0.5, distance);
                targetLook = new THREE.Vector3(0, 0, 0);

                showDetailPanel(starData, 'star');
            }

            targetCameraPosition = targetPos;
            targetLookAt = targetLook;

            // Update UI
            document.getElementById('view-mode').classList.add('visible');
            document.getElementById('view-target').textContent = data.name;
            document.getElementById('back-btn').classList.add('visible');

            // Enable auto-rotate for nice orbit view
            setTimeout(() => {
                controls.autoRotate = true;
                controls.autoRotateSpeed = 0.5;
            }, 1500);
        }

        function returnToSystemView() {
            if (isTransitioning) return;

            isTransitioning = true;
            document.body.classList.add('transitioning');

            currentView = 'system';
            focusedObject = null;
            cameraOffset = null; // Reset offset
            controls.autoRotate = false;

            targetCameraPosition = new THREE.Vector3(0, 150, 300);
            targetLookAt = new THREE.Vector3(0, 0, 0);

            document.getElementById('detail-panel').classList.remove('visible');
            document.getElementById('view-mode').classList.remove('visible');
            document.getElementById('back-btn').classList.remove('visible');
        }

        function showDetailPanel(data, type) {
            const panel = document.getElementById('detail-panel');
            const nameEl = document.getElementById('detail-name');
            const statsEl = document.getElementById('detail-stats');
            const descEl = document.getElementById('detail-description');
            const moonsSection = document.getElementById('moons-section');
            const moonsList = document.getElementById('moons-list');

            nameEl.textContent = data.name;

            if (type === 'star') {
                statsEl.innerHTML = `
                    <div class="stat-row"><span class="stat-label">Type</span><span class="stat-value">${data.name}</span></div>
                    <div class="stat-row"><span class="stat-label">Temperature</span><span class="stat-value">${data.temp}</span></div>
                    <div class="stat-row"><span class="stat-label">Age</span><span class="stat-value">${data.age}</span></div>
                    <div class="stat-row"><span class="stat-label">Radius</span><span class="stat-value">${data.scale} solar units</span></div>
                `;
                descEl.textContent = "The central star of this system, providing light and warmth to all orbiting bodies.";
                moonsSection.style.display = 'none';

            } else if (type === 'planet') {
                statsEl.innerHTML = `
                    <div class="stat-row"><span class="stat-label">Type</span><span class="stat-value">${data.type === 'gas' ? 'Gas Giant' : 'Terrestrial'}</span></div>
                    <div class="stat-row"><span class="stat-label">Radius</span><span class="stat-value">${data.radius.toFixed(1)} Earth radii</span></div>
                    <div class="stat-row"><span class="stat-label">Orbital Distance</span><span class="stat-value">${data.distance.toFixed(0)} AU</span></div>
                    <div class="stat-row"><span class="stat-label">Orbital Period</span><span class="stat-value">${data.orbitalPeriod}</span></div>
                    <div class="stat-row"><span class="stat-label">Temperature</span><span class="stat-value">${data.temperature}</span></div>
                    ${data.hasRings ? '<div class="stat-row"><span class="stat-label">Features</span><span class="stat-value">Ring System</span></div>' : ''}
                `;
                descEl.textContent = data.description;

                // Show moons if any
                if (data.moons && data.moons.length > 0) {
                    moonsSection.style.display = 'block';
                    moonsList.innerHTML = data.moons.map((moon, idx) => `
                        <div class="moon-item" data-moon-index="${idx}">
                            <span>${moon.name}</span>
                            <span class="zoom-hint">Click to zoom</span>
                        </div>
                    `).join('');

                    // Add click handlers for moons
                    moonsList.querySelectorAll('.moon-item').forEach((item, idx) => {
                        item.addEventListener('click', () => {
                            const planet = planets.find(p => p.data.name === data.name);
                            if (planet && planet.moons[idx]) {
                                focusOnObject(planet.moons[idx].mesh, 'moon');
                            }
                        });
                    });
                } else {
                    moonsSection.style.display = 'none';
                }

            } else if (type === 'moon') {
                statsEl.innerHTML = `
                    <div class="stat-row"><span class="stat-label">Parent</span><span class="stat-value">${data.parentPlanet}</span></div>
                    <div class="stat-row"><span class="stat-label">Radius</span><span class="stat-value">${data.radius.toFixed(2)} Earth radii</span></div>
                    <div class="stat-row"><span class="stat-label">Orbital Distance</span><span class="stat-value">${data.distance.toFixed(1)} planet radii</span></div>
                    <div class="stat-row"><span class="stat-label">Orbital Period</span><span class="stat-value">${data.orbitalPeriod}</span></div>
                `;
                descEl.textContent = data.description;
                moonsSection.style.display = 'none';
            }

            panel.classList.add('visible');
        }

        // ========================================
        // ANIMATION LOOP
        // ========================================
        function animate() {
            requestAnimationFrame(animate);

            const delta = 0.016 * timeSpeed;

            // Animate planets
            planets.forEach(p => {
                p.angle += p.speed * timeSpeed;
                p.mesh.position.x = Math.cos(p.angle) * p.dist;
                p.mesh.position.z = Math.sin(p.angle) * p.dist;
                p.mesh.rotation.y += 0.005 * timeSpeed;

                // Animate moons
                if (p.moons) {
                    p.moons.forEach(m => {
                        m.angle += m.speed * timeSpeed;
                        m.mesh.position.x = Math.cos(m.angle) * m.dist;
                        m.mesh.position.z = Math.sin(m.angle) * m.dist;
                        m.mesh.rotation.y += 0.01 * timeSpeed;
                    });
                }
            });

            // Star pulsing
            if (star) {
                const pulse = 1 + Math.sin(Date.now() * 0.002) * 0.02;
                star.scale.set(pulse, pulse, pulse);
            }

            // Camera transition
            if (targetCameraPosition && targetLookAt) {
                const lerpFactor = 0.03;

                camera.position.lerp(targetCameraPosition, lerpFactor);
                controls.target.lerp(targetLookAt, lerpFactor);

                // Check if close enough
                if (camera.position.distanceTo(targetCameraPosition) < 1) {
                    // Store the offset from focused object when transition completes
                    if (focusedObject) {
                        const objectPos = new THREE.Vector3();
                        focusedObject.getWorldPosition(objectPos);
                        cameraOffset = camera.position.clone().sub(objectPos);
                    }
                    targetCameraPosition = null;
                    targetLookAt = null;
                    isTransitioning = false;
                    document.body.classList.remove('transitioning');
                }
            }

            // If focused on a moving object, update camera to follow it
            if (focusedObject && currentView !== 'system' && !isTransitioning && cameraOffset) {
                const objectPos = new THREE.Vector3();
                focusedObject.getWorldPosition(objectPos);

                // Update camera position to maintain offset from object
                const targetCamPos = objectPos.clone().add(cameraOffset);
                camera.position.lerp(targetCamPos, 0.1);

                // Update controls target to look at object
                controls.target.lerp(objectPos, 0.1);
            }

            controls.update();
            renderer.render(scene, camera);
        }

        // ========================================
        // EVENT HANDLERS
        // ========================================
        function onMouseClick(event) {
            if (isTransitioning) return;

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(allClickableObjects, false);

            if (intersects.length > 0) {
                const clicked = intersects[0].object;
                const type = clicked.userData.type;

                if (type === 'planet') {
                    focusOnObject(clicked, 'planet');
                } else if (type === 'moon') {
                    focusOnObject(clicked, 'moon');
                } else if (type === 'star') {
                    focusOnObject(clicked, 'star');
                }
            }
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(allClickableObjects, false);

            document.body.style.cursor = intersects.length > 0 ? 'pointer' : 'grab';
        }

        // ========================================
        // INITIALIZATION
        // ========================================
        camera.position.set(0, 150, 300);
        camera.lookAt(0, 0, 0);
        generateSystem();
        animate();

        // Event Listeners
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        renderer.domElement.addEventListener('click', onMouseClick);
        renderer.domElement.addEventListener('mousemove', onMouseMove);

        document.getElementById('generate-btn').addEventListener('click', generateSystem);

        document.getElementById('toggle-orbits').addEventListener('click', () => {
            showOrbits = !showOrbits;
            planets.forEach(p => p.orbitLine.visible = showOrbits);
        });

        document.getElementById('toggle-labels').addEventListener('click', () => {
            showLabels = !showLabels;
            // Labels would be implemented here
        });

        document.getElementById('speed-btn').addEventListener('click', () => {
            const speeds = [0.25, 0.5, 1, 2, 5];
            const currentIdx = speeds.indexOf(timeSpeed);
            timeSpeed = speeds[(currentIdx + 1) % speeds.length];
            document.getElementById('speed-btn').textContent = `Speed: ${timeSpeed}x`;
        });

        document.getElementById('back-btn').addEventListener('click', returnToSystemView);

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && currentView !== 'system') {
                returnToSystemView();
            }
            if (e.key === 'g') {
                generateSystem();
            }
            if (e.key === 'o') {
                showOrbits = !showOrbits;
                planets.forEach(p => p.orbitLine.visible = showOrbits);
            }
        });

    </script>
</body>
</html>
