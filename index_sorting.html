<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Vibe Coding Gallery</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #000;
            color: #fff;
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }

        /* Animated background */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 50%, rgba(120, 30, 255, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(255, 30, 120, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 40% 10%, rgba(30, 255, 120, 0.3) 0%, transparent 50%);
            animation: drift 20s ease-in-out infinite;
            z-index: -1;
        }

        @keyframes drift {
            0%, 100% { transform: scale(1) rotate(0deg); }
            33% { transform: scale(1.1) rotate(120deg); }
            66% { transform: scale(0.95) rotate(240deg); }
        }
        
        .header {
            padding: 60px 20px 40px;
            text-align: center;
            position: relative;
            background: linear-gradient(180deg, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0) 100%);
        }

        @media (max-width: 768px) {
            .header {
                padding: 40px 20px 30px;
            }
        }

        .gallery-title {
            font-size: 5em;
            font-weight: 100;
            letter-spacing: 0.2em;
            margin-bottom: 20px;
            text-transform: uppercase;
            position: relative;
            display: inline-block;
        }

        @media (max-width: 768px) {
            .gallery-title {
                font-size: 3em;
                letter-spacing: 0.1em;
            }
        }

        .gallery-title::before {
            content: 'VIBE CODING';
            position: absolute;
            left: 0;
            top: 0;
            background: linear-gradient(45deg, #ff006e, #8338ec, #3a86ff, #06ffa5);
            background-size: 400% 100%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: shimmer 8s ease-in-out infinite;
        }

        @keyframes shimmer {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .gallery-subtitle {
            font-size: 1.5em;
            font-weight: 200;
            color: rgba(255, 255, 255, 0.6);
            letter-spacing: 0.5em;
            text-transform: uppercase;
        }

        @media (max-width: 768px) {
            .gallery-subtitle {
                font-size: 1.2em;
                letter-spacing: 0.3em;
            }
        }

        .gallery-description {
            max-width: 600px;
            margin: 30px auto 0;
            color: rgba(255, 255, 255, 0.5);
            line-height: 1.6;
            font-weight: 300;
        }

        @media (max-width: 768px) {
            .gallery-description {
                margin: 20px auto 0;
                font-size: 0.95em;
            }
        }

        /* Enhanced Filter Controls */
        .filter-controls {
            max-width: 1600px;
            margin: 0 auto;
            padding: 0 20px 40px;
        }

        .search-container {
            max-width: 800px;
            margin: 30px auto;
            position: relative;
        }

        .search-box {
            width: 100%;
            padding: 20px 60px 20px 25px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 30px;
            color: white;
            font-size: 1.2em;
            outline: none;
            transition: all 0.3s ease;
        }

        .search-box:focus {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.1);
        }

        .search-box::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .search-icon {
            position: absolute;
            right: 25px;
            top: 50%;
            transform: translateY(-50%);
            color: rgba(255, 255, 255, 0.5);
            pointer-events: none;
            font-size: 1.3em;
        }

        /* Filter Tags */
        .filter-section {
            margin-bottom: 30px;
        }

        .filter-label {
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: rgba(255, 255, 255, 0.5);
            margin-bottom: 15px;
        }

        .filter-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
        }

        .filter-tag {
            padding: 8px 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            color: rgba(255, 255, 255, 0.8);
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.3s ease;
            -webkit-appearance: none;
            appearance: none;
            position: relative;
        }

        .filter-tag:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }

        .filter-tag.active {
            background: linear-gradient(135deg, #ff006e, #8338ec);
            border: none;
            color: white;
        }

        .filter-tag .count {
            margin-left: 5px;
            opacity: 0.7;
            font-size: 0.85em;
        }

        /* Sort Controls */
        .sort-controls {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }

        .sort-dropdown {
            padding: 12px 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 25px;
            color: white;
            font-size: 1em;
            outline: none;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .sort-dropdown:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .sort-dropdown option {
            background: #222;
            color: white;
        }

        /* View Mode Toggle */
        .view-modes {
            display: flex;
            gap: 10px;
            margin-left: auto;
        }

        .view-mode-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 0.6);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2em;
            transition: all 0.3s ease;
        }

        .view-mode-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            color: white;
        }

        .view-mode-btn.active {
            background: linear-gradient(135deg, #ff006e, #8338ec);
            border: none;
            color: white;
        }

        /* Gallery Modes */
        .gallery-modes {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        @media (max-width: 768px) {
            .gallery-modes {
                gap: 15px;
            }
        }

        .mode-button {
            padding: 15px 40px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 30px;
            color: white;
            cursor: pointer;
            font-size: 1.1em;
            letter-spacing: 0.1em;
            transition: all 0.3s ease;
            text-transform: uppercase;
            -webkit-appearance: none;
            appearance: none;
            touch-action: manipulation;
        }

        @media (max-width: 768px) {
            .mode-button {
                padding: 12px 30px;
                font-size: 1em;
            }
        }

        .mode-button:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(255, 255, 255, 0.1);
        }

        .mode-button:active {
            transform: scale(0.98);
        }

        .mode-button.active {
            background: linear-gradient(135deg, #ff006e, #8338ec);
            border: none;
        }

        .mode-button.vr-mode {
            background: linear-gradient(135deg, #ff006e, #8338ec);
            border: none;
        }

        .mode-button.vr-mode:hover {
            box-shadow: 0 10px 30px rgba(138, 43, 226, 0.5);
        }
        
        /* Stats Bar */
        .stats-bar {
            max-width: 1600px;
            margin: 0 auto 30px;
            padding: 0 20px;
            display: flex;
            gap: 30px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 10px;
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.95em;
        }

        .stat-value {
            color: #06ffa5;
            font-weight: 500;
        }

        /* Content Area */
        .content {
            padding: 40px 20px 80px;
            max-width: 1600px;
            margin: 0 auto;
        }

        .content.hidden {
            display: none;
        }
        
        .loading {
            text-align: center;
            padding: 100px;
            font-size: 1.2em;
            color: rgba(255, 255, 255, 0.4);
            font-weight: 200;
            letter-spacing: 0.1em;
        }

        .loading::after {
            content: '';
            display: block;
            width: 60px;
            height: 1px;
            background: linear-gradient(90deg, transparent, #fff, transparent);
            margin: 30px auto;
            animation: scan 2s linear infinite;
        }

        @keyframes scan {
            0% { transform: translateX(-100px); }
            100% { transform: translateX(100px); }
        }
        
        .error {
            color: #ff006e;
            padding: 30px;
            background: rgba(255, 0, 110, 0.1);
            border-radius: 20px;
            margin: 20px auto;
            border: 1px solid rgba(255, 0, 110, 0.2);
            max-width: 600px;
            text-align: center;
        }
        
        /* Grid View */
        .artwork-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 30px;
            transition: all 0.3s ease;
        }

        .artwork-grid.compact {
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 20px;
        }

        .artwork-grid.list {
            grid-template-columns: 1fr;
            gap: 15px;
        }

        @media (max-width: 768px) {
            .artwork-grid {
                grid-template-columns: 1fr;
                gap: 20px;
            }
        }
        
        /* Artwork Frame */
        .artwork-frame {
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 20px;
            transition: all 0.5s ease;
            position: relative;
            overflow: hidden;
            cursor: pointer;
            min-height: 300px;
            display: flex;
            flex-direction: column;
            opacity: 1;
            transform: translateY(0);
        }

        .artwork-frame.hidden {
            opacity: 0;
            transform: translateY(20px);
            pointer-events: none;
            position: absolute;
        }

        .artwork-grid.list .artwork-frame {
            min-height: auto;
            flex-direction: row;
            align-items: center;
            gap: 20px;
        }

        .artwork-frame.pinned {
            border-color: #ff006e;
            background: rgba(255, 0, 110, 0.05);
        }

        .artwork-frame::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle at var(--mouse-x, 50%) var(--mouse-y, 50%), rgba(255, 255, 255, 0.1), transparent 40%);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        @media (hover: hover) {
            .artwork-frame:hover::before {
                opacity: 1;
            }

            .artwork-frame:hover {
                transform: translateY(-10px);
                background: rgba(255, 255, 255, 0.05);
                border-color: rgba(255, 255, 255, 0.2);
                box-shadow: 
                    0 20px 40px rgba(0, 0, 0, 0.5),
                    0 0 60px rgba(138, 43, 226, 0.2);
            }
        }

        @media (hover: none) {
            .artwork-frame:active {
                transform: scale(0.98);
                background: rgba(255, 255, 255, 0.05);
            }
        }

        .pin-button {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 0.6);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2em;
            transition: all 0.3s ease;
            z-index: 10;
        }

        .pin-button:hover {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            transform: scale(1.1);
        }

        .pin-button.pinned {
            background: #ff006e;
            border-color: #ff006e;
            color: white;
        }
        
        .artwork-preview {
            width: 100%;
            height: 200px;
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.1), rgba(0, 255, 255, 0.1));
            border-radius: 10px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 4em;
            position: relative;
            overflow: hidden;
        }

        .artwork-grid.list .artwork-preview {
            width: 80px;
            height: 80px;
            margin-bottom: 0;
            font-size: 2em;
            flex-shrink: 0;
        }

        .artwork-preview::after {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent 30%, rgba(255, 255, 255, 0.1) 50%, transparent 70%);
            animation: shine 3s ease-in-out infinite;
        }

        @keyframes shine {
            0% { transform: rotate(0deg) translateX(-100%); }
            100% { transform: rotate(0deg) translateX(100%); }
        }
        
        .artwork-info {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }

        .artwork-grid.list .artwork-info {
            flex-direction: row;
            justify-content: space-between;
            align-items: center;
        }
        
        .artwork-title {
            font-size: 1.8em;
            font-weight: 200;
            margin-bottom: 10px;
            letter-spacing: 0.05em;
        }

        .artwork-grid.list .artwork-title {
            font-size: 1.5em;
            margin-bottom: 0;
        }

        @media (max-width: 768px) {
            .artwork-title {
                font-size: 1.5em;
            }
        }
        
        .artwork-description {
            color: rgba(255, 255, 255, 0.6);
            line-height: 1.6;
            margin-bottom: 20px;
            flex-grow: 1;
            font-weight: 300;
        }

        .artwork-grid.list .artwork-description {
            display: none;
        }

        .artwork-meta {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .artwork-grid.list .artwork-meta {
            margin-bottom: 0;
        }

        .meta-tag {
            padding: 4px 12px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            font-size: 0.8em;
            color: rgba(255, 255, 255, 0.7);
        }

        .artwork-stats {
            display: flex;
            gap: 20px;
            margin-bottom: 15px;
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.5);
        }

        .artwork-grid.list .artwork-stats {
            margin-bottom: 0;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .vote-count {
            color: #06ffa5;
        }
        
        .artwork-actions {
            display: flex;
            gap: 15px;
            margin-top: auto;
        }

        .artwork-grid.list .artwork-actions {
            margin-top: 0;
            margin-left: auto;
            flex-shrink: 0;
        }

        .view-button, .download-button, .vote-button {
            flex: 1;
            padding: 15px 25px;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 400;
            letter-spacing: 0.05em;
            transition: all 0.3s ease;
            text-transform: uppercase;
            -webkit-appearance: none;
            appearance: none;
            touch-action: manipulation;
        }

        .artwork-grid.list .view-button,
        .artwork-grid.list .download-button,
        .artwork-grid.list .vote-button {
            flex: initial;
            padding: 10px 20px;
            font-size: 0.9em;
        }

        .view-button {
            background: linear-gradient(135deg, #ff006e, #8338ec);
            color: white;
        }

        .view-button:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 30px rgba(138, 43, 226, 0.5);
        }

        .view-button:active {
            transform: scale(0.98);
        }

        .vote-button {
            background: transparent;
            color: #06ffa5;
            border: 1px solid #06ffa5;
            position: relative;
            overflow: hidden;
        }

        .vote-button:hover {
            background: rgba(6, 255, 165, 0.1);
            transform: scale(1.05);
        }

        .vote-button.voted {
            background: #06ffa5;
            color: #000;
        }

        .download-button {
            background: transparent;
            color: rgba(255, 255, 255, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .download-button:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .download-button:active {
            transform: scale(0.98);
        }

        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 100px 20px;
            color: rgba(255, 255, 255, 0.5);
        }

        .empty-state-icon {
            font-size: 4em;
            margin-bottom: 20px;
            opacity: 0.3;
        }

        .empty-state-text {
            font-size: 1.2em;
            font-weight: 300;
        }

        /* Vote popup */
        .vote-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            z-index: 1000;
            display: none;
            backdrop-filter: blur(10px);
        }

        .vote-popup.show {
            display: block;
        }

        .vote-popup h3 {
            font-size: 1.8em;
            font-weight: 300;
            margin-bottom: 20px;
            color: #06ffa5;
        }

        .vote-form {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .vote-textarea {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 15px;
            color: white;
            font-family: inherit;
            font-size: 1em;
            resize: vertical;
            min-height: 100px;
            outline: none;
        }

        .vote-textarea:focus {
            border-color: #06ffa5;
        }

        .vote-textarea::placeholder {
            color: rgba(255, 255, 255, 0.4);
        }

        .vote-actions {
            display: flex;
            gap: 10px;
        }

        .submit-vote, .cancel-vote {
            flex: 1;
            padding: 12px 20px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s ease;
        }

        .submit-vote {
            background: #06ffa5;
            color: #000;
        }

        .submit-vote:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 30px rgba(6, 255, 165, 0.3);
        }

        .cancel-vote {
            background: transparent;
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .cancel-vote:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .vote-popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 999;
            display: none;
        }

        .vote-popup-overlay.show {
            display: block;
        }

        /* 3D Gallery Styles */
        #three-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            z-index: 1000;
            touch-action: none;
        }

        #three-container.active {
            display: block;
        }

        .three-ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 1001;
        }

        .back-button {
            padding: 12px 30px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 25px;
            color: white;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s ease;
            -webkit-appearance: none;
            appearance: none;
            touch-action: manipulation;
        }

        .back-button:hover {
            background: rgba(0, 0, 0, 0.9);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .back-button:active {
            transform: scale(0.95);
        }

        .controls-hint {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.8);
            z-index: 1001;
            text-align: center;
        }

        /* Mobile controls UI */
        .mobile-controls {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            z-index: 1001;
            gap: 20px;
        }

        .mobile-controls.show {
            display: flex;
        }

        .joystick-container {
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            position: relative;
            touch-action: none;
        }

        .joystick-handle {
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: none;
        }

        .artwork-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            padding: 25px;
            max-width: 400px;
            display: none;
            z-index: 1002;
            pointer-events: none;
            backdrop-filter: blur(10px);
        }

        @media (max-width: 768px) {
            .artwork-tooltip {
                padding: 20px;
                max-width: 300px;
            }
        }

        .artwork-tooltip.visible {
            display: block;
        }

        .tooltip-title {
            font-size: 1.4em;
            font-weight: 300;
            margin-bottom: 10px;
            color: #fff;
        }

        @media (max-width: 768px) {
            .tooltip-title {
                font-size: 1.2em;
            }
        }

        .tooltip-description {
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.7);
            line-height: 1.5;
            margin-bottom: 10px;
        }

        .tooltip-instruction {
            font-size: 0.85em;
            color: #ff006e;
            text-align: center;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* Custom scrollbar */
        @media (hover: hover) {
            ::-webkit-scrollbar {
                width: 8px;
            }

            ::-webkit-scrollbar-track {
                background: rgba(255, 255, 255, 0.05);
            }

            ::-webkit-scrollbar-thumb {
                background: rgba(255, 255, 255, 0.2);
                border-radius: 4px;
            }

            ::-webkit-scrollbar-thumb:hover {
                background: rgba(255, 255, 255, 0.3);
            }
        }

        /* Toast notification */
        .toast {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 25px;
            padding: 15px 30px;
            color: white;
            font-size: 1em;
            z-index: 2000;
            opacity: 0;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .toast.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        .toast.success {
            border-color: #06ffa5;
            color: #06ffa5;
        }

        .toast.error {
            border-color: #ff006e;
            color: #ff006e;
        }

        /* Fade in animation */
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .artwork-frame {
            animation: fadeInUp 0.5s ease-out forwards;
        }

        .artwork-frame:nth-child(n) {
            animation-delay: calc(n * 0.05s);
        }
    </style>
</head>
<body>
    <div class="header">
        <h1 class="gallery-title">VIBE CODING</h1>
        <div class="gallery-subtitle">Kody's Creative Playground</div>
        <p class="gallery-description">
            Welcome to Kody Wildfeuer's vibe coding showcase - a collection of experimental web art, creative coding projects, and digital explorations.<br>
            These are personal creative experiments that represent the intersection of code and art.<br>
            <span style="font-size: 0.85em; opacity: 0.6;">Note: This is Kody's personal creative content and opinions, unrelated to any employer.</span>
        </p>
        <div class="gallery-modes">
            <button class="mode-button active" id="main-gallery">Main Gallery</button>
            <button class="mode-button" id="archive-mode">Archive</button>
            <button class="mode-button vr-mode" id="3d-mode">3D Experience</button>
        </div>
    </div>
    
    <div class="filter-controls">
        <div class="search-container">
            <input type="text" class="search-box" id="search-input" placeholder="Search tools by name, description, or tags...">
            <span class="search-icon">🔍</span>
        </div>

        <div class="filter-section">
            <div class="filter-label">Categories</div>
            <div class="filter-tags" id="category-filters">
                <button class="filter-tag active" data-category="all">All <span class="count"></span></button>
                <button class="filter-tag" data-category="interactive">Interactive <span class="count"></span></button>
                <button class="filter-tag" data-category="generative">Generative <span class="count"></span></button>
                <button class="filter-tag" data-category="3D">3D <span class="count"></span></button>
                <button class="filter-tag" data-category="animation">Animation <span class="count"></span></button>
                <button class="filter-tag" data-category="experimental">Experimental <span class="count"></span></button>
                <button class="filter-tag" data-category="particles">Particles <span class="count"></span></button>
                <button class="filter-tag" data-category="audio-reactive">Audio <span class="count"></span></button>
            </div>
        </div>

        <div class="filter-section">
            <div class="filter-label">Quick Filters</div>
            <div class="filter-tags" id="quick-filters">
                <button class="filter-tag" data-filter="pinned">📌 Pinned</button>
                <button class="filter-tag" data-filter="popular">🔥 Most Voted</button>
                <button class="filter-tag" data-filter="recent">✨ Recently Added</button>
                <button class="filter-tag" data-filter="unvoted">🆕 Not Yet Voted</button>
            </div>
        </div>

        <div class="sort-controls">
            <select class="sort-dropdown" id="sort-select">
                <option value="alphabetical">Sort: A-Z</option>
                <option value="votes">Sort: Most Votes</option>
                <option value="random">Sort: Random</option>
                <option value="recent">Sort: Recently Added</option>
            </select>
            
            <div class="view-modes">
                <button class="view-mode-btn active" data-view="grid" title="Grid View">⊞</button>
                <button class="view-mode-btn" data-view="compact" title="Compact View">⊟</button>
                <button class="view-mode-btn" data-view="list" title="List View">☰</button>
            </div>
        </div>

        <div class="stats-bar">
            <div class="stat-item">
                <span>Total Tools:</span>
                <span class="stat-value" id="total-count">0</span>
            </div>
            <div class="stat-item">
                <span>Showing:</span>
                <span class="stat-value" id="showing-count">0</span>
            </div>
            <div class="stat-item">
                <span>Total Votes:</span>
                <span class="stat-value" id="total-votes">0</span>
            </div>
        </div>
    </div>
    
    <div class="content" id="main-content">
        <div class="loading">Loading gallery...</div>
    </div>

    <div id="three-container">
        <div class="three-ui">
            <button class="back-button" id="back-to-gallery">← Back to Gallery</button>
        </div>
        <div class="controls-hint" id="controls-hint">Use WASD to move, Mouse to look around, Click on artworks to view</div>
        <div class="mobile-controls" id="mobile-controls">
            <div class="joystick-container" id="movement-joystick">
                <div class="joystick-handle" id="movement-handle"></div>
            </div>
        </div>
        <div class="artwork-tooltip" id="artwork-tooltip">
            <h3 class="tooltip-title"></h3>
            <p class="tooltip-description"></p>
            <p class="tooltip-instruction">Click to view in new tab</p>
        </div>
    </div>

    <!-- Vote popup -->
    <div class="vote-popup-overlay" id="vote-overlay"></div>
    <div class="vote-popup" id="vote-popup">
        <h3>Vote for Feature Request</h3>
        <form class="vote-form" id="vote-form">
            <textarea class="vote-textarea" id="vote-message" placeholder="What features or improvements would you like to see in this tool?"></textarea>
            <div class="vote-actions">
                <button type="submit" class="submit-vote">Submit Vote</button>
                <button type="button" class="cancel-vote" id="cancel-vote">Cancel</button>
            </div>
        </form>
    </div>

    <!-- Toast notification -->
    <div class="toast" id="toast"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Target repository
        const REPO_OWNER = 'kody-w';
        const REPO_NAME = 'localFirstTools';
        const BRANCH = 'main';
        
        // Detect if running locally
        const isLocal = window.location.protocol === 'file:' || 
                       window.location.hostname === 'localhost' || 
                       window.location.hostname === '127.0.0.1' ||
                       window.location.hostname === '';
        
        // GitHub Pages URL pattern
        const GITHUB_PAGES_BASE = `https://${REPO_OWNER}.github.io/${REPO_NAME}/`;
        
        // Store gallery data globally
        let galleryData = null;
        let threeScene = null;
        let currentView = 'main'; // 'main' or 'archive'
        let currentFilters = {
            search: '',
            categories: new Set(['all']),
            quickFilter: null,
            sort: 'alphabetical',
            viewMode: 'grid'
        };
        
        // Local storage keys
        const PINNED_TOOLS_KEY = 'vibe_gallery_pinned_tools';
        const VOTES_KEY = 'vibe_gallery_votes';
        const USER_VOTES_KEY = 'vibe_gallery_user_votes';
        const FILE_DATES_KEY = 'vibe_gallery_file_dates';
        
        // Main content container
        const mainContent = document.getElementById('main-content');
        const threeContainer = document.getElementById('three-container');
        
        // Icons for display
        const artworkIcons = ['🎨', '✨', '🌟', '💫', '🔮', '🎭', '🌈', '🎪', '🎯', '🎲', '🎸', '🎹'];
        
        // Check if device is mobile
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                        (window.matchMedia && window.matchMedia('(max-width: 768px)').matches);
        
        // Get appropriate URL for file based on environment
        function getFileUrl(path) {
            if (isLocal) {
                return path;
            } else {
                return `${GITHUB_PAGES_BASE}${path}`;
            }
        }
        
        // Local storage helpers
        function getPinnedTools() {
            const pinned = localStorage.getItem(PINNED_TOOLS_KEY);
            return pinned ? JSON.parse(pinned) : [];
        }
        
        function setPinnedTools(pinned) {
            localStorage.setItem(PINNED_TOOLS_KEY, JSON.stringify(pinned));
        }
        
        function getVotes() {
            const votes = localStorage.getItem(VOTES_KEY);
            return votes ? JSON.parse(votes) : {};
        }
        
        function setVotes(votes) {
            localStorage.setItem(VOTES_KEY, JSON.stringify(votes));
        }
        
        function getUserVotes() {
            const userVotes = localStorage.getItem(USER_VOTES_KEY);
            return userVotes ? JSON.parse(userVotes) : {};
        }
        
        function setUserVotes(userVotes) {
            localStorage.setItem(USER_VOTES_KEY, JSON.stringify(userVotes));
        }

        function getFileDates() {
            const dates = localStorage.getItem(FILE_DATES_KEY);
            return dates ? JSON.parse(dates) : {};
        }

        function setFileDates(dates) {
            localStorage.setItem(FILE_DATES_KEY, JSON.stringify(dates));
        }

        // Initialize file dates for existing files
        function initializeFileDates(files) {
            const dates = getFileDates();
            let hasChanges = false;
            
            files.forEach(file => {
                if (!dates[file.path]) {
                    // Assign a random date within the last 30 days for demo purposes
                    const daysAgo = Math.floor(Math.random() * 30);
                    dates[file.path] = new Date(Date.now() - daysAgo * 24 * 60 * 60 * 1000).toISOString();
                    hasChanges = true;
                }
            });
            
            if (hasChanges) {
                setFileDates(dates);
            }
        }
        
        // Toast notification
        function showToast(message, type = 'success') {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = `toast ${type}`;
            toast.classList.add('show');
            
            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }
        
        // Generate consistent artwork metadata
        function generateArtworkMetadata(file) {
            const filename = file.path.split('/').pop();
            const nameWithoutExt = filename.replace('.html', '').replace('.htm', '');
            const formattedName = nameWithoutExt
                .replace(/[-_]/g, ' ')
                .replace(/\b\w/g, l => l.toUpperCase());
            
            // Use a hash of the filename to generate consistent metadata
            const hash = filename.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
            
            const descriptions = [
                "An experimental dive into the creative possibilities of web technology",
                "Interactive art piece exploring the boundaries between code and creativity",
                "A digital meditation on algorithms, aesthetics, and human expression",
                "Pushing browser limits to create unexpected visual experiences",
                "Real-time generative art that evolves with each interaction",
                "Creative coding experiment blending mathematics and imagination",
                "A playful exploration of what happens when code becomes art",
                "Digital canvas where logic meets creativity in unexpected ways",
                "Vibe coding at its finest - where inspiration meets implementation"
            ];
            
            return {
                title: formattedName,
                description: descriptions[hash % descriptions.length],
                icon: artworkIcons[hash % artworkIcons.length],
                tags: generateConsistentTags(filename, hash)
            };
        }
        
        // Generate consistent tags based on filename
        function generateConsistentTags(filename, hash) {
            const allTags = [
                'interactive', 'generative', 'particles', 'animation', 
                'experimental', '3D', 'audio-reactive', 'kinetic',
                'abstract', 'geometric', 'organic', 'minimal',
                'colorful', 'monochrome', 'dynamic', 'static'
            ];
            
            // Use hash to select 2-3 tags consistently
            const numTags = 2 + (hash % 2);
            const tags = [];
            
            for (let i = 0; i < numTags; i++) {
                const tagIndex = (hash + i * 7) % allTags.length;
                tags.push(allTags[tagIndex]);
            }
            
            return tags;
        }
        
        // Track mouse position for interactive effects (desktop only)
        if (!isMobile) {
            document.addEventListener('mousemove', (e) => {
                const frames = document.querySelectorAll('.artwork-frame');
                frames.forEach(frame => {
                    const rect = frame.getBoundingClientRect();
                    const x = ((e.clientX - rect.left) / rect.width) * 100;
                    const y = ((e.clientY - rect.top) / rect.height) * 100;
                    frame.style.setProperty('--mouse-x', `${x}%`);
                    frame.style.setProperty('--mouse-y', `${y}%`);
                });
            });
        }
        
        // Enhanced search and filter functionality
        const searchInput = document.getElementById('search-input');
        searchInput.addEventListener('input', (e) => {
            currentFilters.search = e.target.value.toLowerCase();
            applyFilters();
        });

        // Category filters
        document.getElementById('category-filters').addEventListener('click', (e) => {
            if (e.target.classList.contains('filter-tag')) {
                const category = e.target.dataset.category;
                
                if (category === 'all') {
                    // Clear all other categories and select only 'all'
                    currentFilters.categories.clear();
                    currentFilters.categories.add('all');
                    document.querySelectorAll('#category-filters .filter-tag').forEach(tag => {
                        tag.classList.toggle('active', tag.dataset.category === 'all');
                    });
                } else {
                    // Toggle specific category
                    if (currentFilters.categories.has('all')) {
                        currentFilters.categories.clear();
                    }
                    
                    if (currentFilters.categories.has(category)) {
                        currentFilters.categories.delete(category);
                    } else {
                        currentFilters.categories.add(category);
                    }
                    
                    // If no categories selected, select 'all'
                    if (currentFilters.categories.size === 0) {
                        currentFilters.categories.add('all');
                    }
                    
                    // Update UI
                    document.querySelectorAll('#category-filters .filter-tag').forEach(tag => {
                        tag.classList.toggle('active', currentFilters.categories.has(tag.dataset.category));
                    });
                }
                
                applyFilters();
            }
        });

        // Quick filters
        document.getElementById('quick-filters').addEventListener('click', (e) => {
            if (e.target.classList.contains('filter-tag')) {
                const filter = e.target.dataset.filter;
                
                // Toggle filter
                if (currentFilters.quickFilter === filter) {
                    currentFilters.quickFilter = null;
                    e.target.classList.remove('active');
                } else {
                    // Remove active from all quick filters
                    document.querySelectorAll('#quick-filters .filter-tag').forEach(tag => {
                        tag.classList.remove('active');
                    });
                    currentFilters.quickFilter = filter;
                    e.target.classList.add('active');
                }
                
                applyFilters();
            }
        });

        // Sort control
        document.getElementById('sort-select').addEventListener('change', (e) => {
            currentFilters.sort = e.target.value;
            applyFilters();
        });

        // View mode controls
        document.querySelectorAll('.view-mode-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                currentFilters.viewMode = btn.dataset.view;
                document.querySelectorAll('.view-mode-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                
                const grid = document.querySelector('.artwork-grid');
                if (grid) {
                    grid.className = `artwork-grid ${currentFilters.viewMode}`;
                }
            });
        });

        // Apply all filters
        function applyFilters() {
            if (!galleryData) return;
            
            const files = currentView === 'main' ? galleryData.mainFiles : galleryData.archiveFiles;
            const pinned = getPinnedTools();
            const votes = getVotes();
            const userVotes = getUserVotes();
            const dates = getFileDates();
            
            // Filter files
            let filteredFiles = files.filter(file => {
                const metadata = generateArtworkMetadata(file);
                
                // Search filter
                if (currentFilters.search) {
                    const searchLower = currentFilters.search.toLowerCase();
                    const matchesSearch = 
                        metadata.title.toLowerCase().includes(searchLower) ||
                        metadata.description.toLowerCase().includes(searchLower) ||
                        metadata.tags.some(tag => tag.toLowerCase().includes(searchLower));
                    
                    if (!matchesSearch) return false;
                }
                
                // Category filter
                if (!currentFilters.categories.has('all')) {
                    const hasMatchingTag = metadata.tags.some(tag => 
                        Array.from(currentFilters.categories).some(cat => 
                            tag.toLowerCase().includes(cat.toLowerCase())
                        )
                    );
                    if (!hasMatchingTag) return false;
                }
                
                // Quick filters
                if (currentFilters.quickFilter) {
                    switch (currentFilters.quickFilter) {
                        case 'pinned':
                            if (!pinned.includes(file.path)) return false;
                            break;
                        case 'popular':
                            if ((votes[file.path]?.count || 0) < 5) return false;
                            break;
                        case 'recent':
                            const fileDate = new Date(dates[file.path] || 0);
                            const daysAgo = (Date.now() - fileDate) / (1000 * 60 * 60 * 24);
                            if (daysAgo > 7) return false;
                            break;
                        case 'unvoted':
                            if (userVotes[file.path]) return false;
                            break;
                    }
                }
                
                return true;
            });
            
            // Sort files
            filteredFiles = sortFiles(filteredFiles, currentFilters.sort);
            
            // Display results
            displayFilteredGallery(filteredFiles);
            
            // Update stats
            updateStats(files.length, filteredFiles.length);
        }

        // Sort files based on sort option
        function sortFiles(files, sortOption) {
            const pinned = getPinnedTools();
            const votes = getVotes();
            const dates = getFileDates();
            
            const sorted = [...files].sort((a, b) => {
                // Always keep pinned items at top unless sorting by random
                if (sortOption !== 'random') {
                    const aPinned = pinned.includes(a.path);
                    const bPinned = pinned.includes(b.path);
                    if (aPinned && !bPinned) return -1;
                    if (!aPinned && bPinned) return 1;
                }
                
                switch (sortOption) {
                    case 'votes':
                        const aVotes = votes[a.path]?.count || 0;
                        const bVotes = votes[b.path]?.count || 0;
                        return bVotes - aVotes;
                    
                    case 'recent':
                        const aDate = new Date(dates[a.path] || 0);
                        const bDate = new Date(dates[b.path] || 0);
                        return bDate - aDate;
                    
                    case 'random':
                        return Math.random() - 0.5;
                    
                    case 'alphabetical':
                    default:
                        const aTitle = generateArtworkMetadata(a).title;
                        const bTitle = generateArtworkMetadata(b).title;
                        return aTitle.localeCompare(bTitle);
                }
            });
            
            return sorted;
        }

        // Update category counts
        function updateCategoryCounts() {
            if (!galleryData) return;
            
            const files = currentView === 'main' ? galleryData.mainFiles : galleryData.archiveFiles;
            const categoryCounts = {
                all: files.length,
                interactive: 0,
                generative: 0,
                '3D': 0,
                animation: 0,
                experimental: 0,
                particles: 0,
                'audio-reactive': 0
            };
            
            files.forEach(file => {
                const metadata = generateArtworkMetadata(file);
                metadata.tags.forEach(tag => {
                    const tagLower = tag.toLowerCase();
                    Object.keys(categoryCounts).forEach(cat => {
                        if (cat !== 'all' && tagLower.includes(cat.toLowerCase())) {
                            categoryCounts[cat]++;
                        }
                    });
                });
            });
            
            // Update UI
            document.querySelectorAll('#category-filters .filter-tag').forEach(tag => {
                const category = tag.dataset.category;
                const count = tag.querySelector('.count');
                if (count && categoryCounts[category] !== undefined) {
                    count.textContent = `(${categoryCounts[category]})`;
                }
            });
        }

        // Update stats
        function updateStats(total, showing) {
            document.getElementById('total-count').textContent = total;
            document.getElementById('showing-count').textContent = showing;
            
            const votes = getVotes();
            const totalVotes = Object.values(votes).reduce((sum, v) => sum + (v.count || 0), 0);
            document.getElementById('total-votes').textContent = totalVotes;
        }
        
        // Mode switching
        document.getElementById('main-gallery').addEventListener('click', () => {
            currentView = 'main';
            document.getElementById('main-gallery').classList.add('active');
            document.getElementById('archive-mode').classList.remove('active');
            threeContainer.classList.remove('active');
            mainContent.classList.remove('hidden');
            if (threeScene) {
                threeScene.cleanup();
                threeScene = null;
            }
            if (galleryData) {
                updateCategoryCounts();
                applyFilters();
            }
        });
        
        document.getElementById('archive-mode').addEventListener('click', () => {
            currentView = 'archive';
            document.getElementById('archive-mode').classList.add('active');
            document.getElementById('main-gallery').classList.remove('active');
            threeContainer.classList.remove('active');
            mainContent.classList.remove('hidden');
            if (threeScene) {
                threeScene.cleanup();
                threeScene = null;
            }
            if (galleryData) {
                updateCategoryCounts();
                applyFilters();
            }
        });
        
        document.getElementById('3d-mode').addEventListener('click', () => {
            if (galleryData) {
                mainContent.classList.add('hidden');
                threeContainer.classList.add('active');
                init3DGallery(galleryData);
            }
        });
        
        document.getElementById('back-to-gallery').addEventListener('click', () => {
            document.getElementById('main-gallery').click();
        });
        
        // Vote popup handling
        const voteOverlay = document.getElementById('vote-overlay');
        const votePopup = document.getElementById('vote-popup');
        const voteForm = document.getElementById('vote-form');
        const cancelVote = document.getElementById('cancel-vote');
        let currentVoteFile = null;
        
        voteOverlay.addEventListener('click', closeVotePopup);
        cancelVote.addEventListener('click', closeVotePopup);
        
        function openVotePopup(file) {
            currentVoteFile = file;
            voteOverlay.classList.add('show');
            votePopup.classList.add('show');
            document.getElementById('vote-message').value = '';
        }
        
        function closeVotePopup() {
            voteOverlay.classList.remove('show');
            votePopup.classList.remove('show');
            currentVoteFile = null;
        }
        
        voteForm.addEventListener('submit', (e) => {
            e.preventDefault();
            if (!currentVoteFile) return;
            
            const message = document.getElementById('vote-message').value.trim();
            if (!message) {
                showToast('Please enter a feature request', 'error');
                return;
            }
            
            // Update votes
            const votes = getVotes();
            const userVotes = getUserVotes();
            const fileId = currentVoteFile.path;
            
            // Initialize vote count if not exists
            if (!votes[fileId]) {
                votes[fileId] = { count: 0, requests: [] };
            }
            
            // Add vote
            votes[fileId].count++;
            votes[fileId].requests.push({
                message: message,
                timestamp: new Date().toISOString()
            });
            
            // Mark user as voted for this file
            userVotes[fileId] = true;
            
            // Save to local storage
            setVotes(votes);
            setUserVotes(userVotes);
            
            // Update UI
            updateVoteUI(fileId);
            
            closeVotePopup();
            showToast('Vote submitted! Thank you for your feedback.');
            
            // Log vote for developer (in console)
            console.log('New vote for:', currentVoteFile.path);
            console.log('Feature request:', message);
            
            // Refresh filters if needed
            if (currentFilters.quickFilter === 'popular' || currentFilters.quickFilter === 'unvoted') {
                applyFilters();
            }
        });
        
        function updateVoteUI(fileId) {
            const voteButtons = document.querySelectorAll(`.vote-button[data-file="${fileId}"]`);
            const voteCounts = document.querySelectorAll(`.vote-count[data-file="${fileId}"]`);
            const userVotes = getUserVotes();
            const votes = getVotes();
            
            voteButtons.forEach(btn => {
                if (userVotes[fileId]) {
                    btn.classList.add('voted');
                    btn.textContent = 'Voted';
                }
            });
            
            voteCounts.forEach(count => {
                count.textContent = votes[fileId] ? votes[fileId].count : 0;
            });
            
            // Update total votes stat
            const totalVotes = Object.values(votes).reduce((sum, v) => sum + (v.count || 0), 0);
            document.getElementById('total-votes').textContent = totalVotes;
        }
        
        // Pin functionality
        function togglePin(file) {
            const pinned = getPinnedTools();
            const fileId = file.path;
            const index = pinned.indexOf(fileId);
            
            if (index > -1) {
                pinned.splice(index, 1);
                showToast('Tool unpinned');
            } else {
                pinned.push(fileId);
                showToast('Tool pinned to top');
            }
            
            setPinnedTools(pinned);
            
            // Refresh display
            applyFilters();
        }
        
        // Fetch GitHub repository files
        async function fetchRepoFiles() {
            try {
                // If running locally, try to use local data first
                if (isLocal) {
                    console.log('Running locally - attempting to load apps from local filesystem');
                    
                    // Try to fetch the config file
                    try {
                        const configResponse = await fetch('data/config/utility_apps_config.json');
                        if (configResponse.ok) {
                            const configData = await configResponse.json();
                            console.log('Loaded local config:', configData);
                            
                            // Convert config format to gallery format
                            const files = configData.apps.map(app => ({
                                path: app.path.replace('./', ''),
                                url: '#',
                                raw_url: app.path.replace('./', ''),
                                pages_url: app.path.replace('./', '')
                            }));
                            
                            galleryData = {
                                repo: {
                                    owner: REPO_OWNER,
                                    name: REPO_NAME,
                                    branch: BRANCH,
                                    url: `https://github.com/${REPO_OWNER}/${REPO_NAME}`
                                },
                                mainFiles: files.filter(f => !f.path.includes('archive/')),
                                archiveFiles: files.filter(f => f.path.includes('archive/'))
                            };
                            
                            initializeFileDates([...galleryData.mainFiles, ...galleryData.archiveFiles]);
                            updateCategoryCounts();
                            applyFilters();
                            return;
                        }
                    } catch (e) {
                        console.log('Local config not found, falling back to GitHub API');
                    }
                }
                
                const apiUrl = `https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/git/trees/${BRANCH}?recursive=1`;
                
                const response = await fetch(apiUrl);
                
                if (!response.ok) {
                    throw new Error(`GitHub API error: ${response.status}`);
                }
                
                const data = await response.json();
                
                // Separate main files and archive files
                const mainFiles = [];
                const archiveFiles = [];
                
                data.tree.forEach(item => {
                    if (item.type === 'blob' && 
                        (item.path.endsWith('.html') || item.path.endsWith('.htm'))) {
                        
                        const file = {
                            path: item.path,
                            url: `https://github.com/${REPO_OWNER}/${REPO_NAME}/blob/${BRANCH}/${item.path}`,
                            raw_url: `https://raw.githubusercontent.com/${REPO_OWNER}/${REPO_NAME}/${BRANCH}/${item.path}`,
                            // Add appropriate URL based on environment
                            pages_url: getFileUrl(item.path)
                        };
                        
                        // Check if file is in archive
                        if (item.path.includes('archive/')) {
                            archiveFiles.push(file);
                        } else {
                            // Exclude gallery-related files
                            const filename = item.path.split('/').pop().toLowerCase();
                            const excludeFiles = ['index.html', 'template.html', 'example.html', 'test.html', 'gallery.html'];
                            if (!excludeFiles.includes(filename)) {
                                mainFiles.push(file);
                            }
                        }
                    }
                });
                
                // Store gallery data globally
                galleryData = {
                    repo: {
                        owner: REPO_OWNER,
                        name: REPO_NAME,
                        branch: BRANCH,
                        url: `https://github.com/${REPO_OWNER}/${REPO_NAME}`
                    },
                    mainFiles: mainFiles,
                    archiveFiles: archiveFiles
                };
                
                // Initialize file dates
                initializeFileDates([...mainFiles, ...archiveFiles]);
                
                // Update category counts
                updateCategoryCounts();
                
                // Display gallery
                applyFilters();
                
            } catch (error) {
                console.error("Error fetching repository:", error);
                mainContent.innerHTML = `
                    <div class="error">
                        <strong>Exhibition Temporarily Closed</strong><br>
                        ${error.message}
                    </div>
                `;
            }
        }
        
        // Display filtered gallery
        function displayFilteredGallery(files) {
            mainContent.innerHTML = '';
            
            if (!files || files.length === 0) {
                mainContent.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">🔍</div>
                        <div class="empty-state-text">No tools match your current filters</div>
                    </div>
                `;
                return;
            }
            
            const artworkGrid = document.createElement('div');
            artworkGrid.className = `artwork-grid ${currentFilters.viewMode}`;
            
            const pinned = getPinnedTools();
            const votes = getVotes();
            const userVotes = getUserVotes();
            const dates = getFileDates();
            
            files.forEach((file, index) => {
                const metadata = generateArtworkMetadata(file);
                const filename = file.path.split('/').pop();
                const fileVotes = votes[file.path]?.count || 0;
                const hasVoted = userVotes[file.path] || false;
                const isPinned = pinned.includes(file.path);
                const fileDate = new Date(dates[file.path] || 0);
                const daysAgo = Math.floor((Date.now() - fileDate) / (1000 * 60 * 60 * 24));
                
                const artworkFrame = document.createElement('div');
                artworkFrame.className = 'artwork-frame' + (isPinned ? ' pinned' : '');
                artworkFrame.style.animationDelay = `${index * 0.05}s`;
                
                // Different layouts for different view modes
                if (currentFilters.viewMode === 'list') {
                    artworkFrame.innerHTML = `
                        <div class="artwork-preview">
                            ${metadata.icon}
                        </div>
                        <div class="artwork-info">
                            <div>
                                <h3 class="artwork-title">${metadata.title}</h3>
                                <div class="artwork-meta">
                                    ${metadata.tags.map(tag => `<span class="meta-tag">${tag}</span>`).join('')}
                                </div>
                            </div>
                            <div class="artwork-stats">
                                <div class="stat-item">
                                    <span>👍</span>
                                    <span class="vote-count" data-file="${file.path}">${fileVotes}</span>
                                </div>
                                ${daysAgo <= 7 ? `<div class="stat-item"><span>✨ ${daysAgo}d ago</span></div>` : ''}
                            </div>
                        </div>
                        <div class="artwork-actions">
                            <button class="view-button" data-url="${file.pages_url}" data-title="${metadata.title}" data-filename="${filename}">View</button>
                            <button class="vote-button ${hasVoted ? 'voted' : ''}" data-file="${file.path}">${hasVoted ? 'Voted' : 'Vote'}</button>
                        </div>
                        <button class="pin-button ${isPinned ? 'pinned' : ''}" data-file="${file.path}" title="${isPinned ? 'Unpin' : 'Pin to top'}">
                            📌
                        </button>
                    `;
                } else {
                    artworkFrame.innerHTML = `
                        <button class="pin-button ${isPinned ? 'pinned' : ''}" data-file="${file.path}" title="${isPinned ? 'Unpin' : 'Pin to top'}">
                            📌
                        </button>
                        <div class="artwork-preview">
                            ${metadata.icon}
                        </div>
                        <h3 class="artwork-title">${metadata.title}</h3>
                        <p class="artwork-description">${metadata.description}</p>
                        <div class="artwork-meta">
                            ${metadata.tags.map(tag => `<span class="meta-tag">${tag}</span>`).join('')}
                        </div>
                        <div class="artwork-stats">
                            <div class="stat-item">
                                <span>👍</span>
                                <span class="vote-count" data-file="${file.path}">${fileVotes}</span>
                                <span>votes</span>
                            </div>
                            ${daysAgo <= 7 ? `<div class="stat-item"><span>✨ New</span></div>` : ''}
                        </div>
                        <div class="artwork-actions">
                            <button class="view-button" data-url="${file.pages_url}" data-title="${metadata.title}" data-filename="${filename}">View</button>
                            <button class="vote-button ${hasVoted ? 'voted' : ''}" data-file="${file.path}">${hasVoted ? 'Voted' : 'Vote'}</button>
                            <button class="download-button" data-url="${file.raw_url}" data-filename="${filename}">Save</button>
                        </div>
                    `;
                }
                
                artworkGrid.appendChild(artworkFrame);
            });
            
            mainContent.appendChild(artworkGrid);
            
            // Add event listeners
            addEventListeners();
        }
        
        // Add event listeners for buttons
        function addEventListeners() {
            // Pin buttons
            const pinButtons = document.querySelectorAll('.pin-button');
            pinButtons.forEach(button => {
                button.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const fileId = button.dataset.file;
                    const file = [...galleryData.mainFiles, ...galleryData.archiveFiles]
                        .find(f => f.path === fileId);
                    if (file) {
                        togglePin(file);
                    }
                });
            });
            
            // Vote buttons
            const voteButtons = document.querySelectorAll('.vote-button');
            voteButtons.forEach(button => {
                button.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const fileId = button.dataset.file;
                    const userVotes = getUserVotes();
                    
                    if (userVotes[fileId]) {
                        showToast('You have already voted for this tool', 'error');
                        return;
                    }
                    
                    const file = [...galleryData.mainFiles, ...galleryData.archiveFiles]
                        .find(f => f.path === fileId);
                    if (file) {
                        openVotePopup(file);
                    }
                });
            });
            
            // View buttons
            const viewButtons = document.querySelectorAll('.view-button');
            viewButtons.forEach(button => {
                button.addEventListener('click', (e) => {
                    e.stopPropagation();
                    // Open GitHub Pages URL directly
                    window.open(button.dataset.url, '_blank');
                });
            });
            
            // Download buttons
            const downloadButtons = document.querySelectorAll('.download-button');
            downloadButtons.forEach(button => {
                button.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    try {
                        await downloadHtmlFile(button.dataset.url, button.dataset.filename);
                    } catch (error) {
                        showToast(`Error downloading: ${error.message}`, 'error');
                    }
                });
            });
            
            // Artwork frame clicks (except in list view)
            if (currentFilters.viewMode !== 'list') {
                const artworkFrames = document.querySelectorAll('.artwork-frame');
                artworkFrames.forEach(frame => {
                    frame.addEventListener('click', (e) => {
                        // Don't trigger if clicking on a button
                        if (e.target.tagName !== 'BUTTON' && !e.target.closest('button')) {
                            const viewButton = frame.querySelector('.view-button');
                            if (viewButton) {
                                // Open GitHub Pages URL directly
                                window.open(viewButton.dataset.url, '_blank');
                            }
                        }
                    });
                });
            }
        }
        
        // Download HTML file
        async function downloadHtmlFile(url, filename) {
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`Failed to fetch (${response.status})`);
                }
                
                const htmlContent = await response.text();
                
                const blob = new Blob([htmlContent], { type: 'text/html' });
                const blobUrl = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = blobUrl;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                
                window.URL.revokeObjectURL(blobUrl);
                document.body.removeChild(a);
                
                showToast('File downloaded successfully');
            } catch (error) {
                console.error('Error downloading:', error);
                throw error;
            }
        }
        
        // Initialize 3D Gallery
        function init3DGallery(data) {
            if (threeScene) {
                threeScene.cleanup();
            }
            
            // Use only main files for 3D gallery
            const galleryDataFor3D = {
                ...data,
                files: data.mainFiles
            };
            
            threeScene = new MinecraftGallery(galleryDataFor3D);
            threeScene.init();
        }
        
        // Minecraft-style 3D Gallery Class
        class MinecraftGallery {
            constructor(data) {
                this.data = data;
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.artworks = [];
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                this.moveSpeed = 0.2;
                this.lookSpeed = 0.002;
                
                // Movement state
                this.keys = {
                    w: false,
                    a: false,
                    s: false,
                    d: false
                };
                
                // Camera rotation
                this.rotation = {
                    x: 0,
                    y: 0
                };
                
                // Mobile controls
                this.isMobile = isMobile;
                this.touches = {
                    start: null,
                    current: null,
                    joystick: null
                };
                this.joystickActive = false;
                this.joystickVector = new THREE.Vector2();
                
                this.isPointerLocked = false;
                this.hoveredArtwork = null;
                this.tooltip = document.getElementById('artwork-tooltip');
                this.tooltipTitle = this.tooltip.querySelector('.tooltip-title');
                this.tooltipDescription = this.tooltip.querySelector('.tooltip-description');
            }
            
            init() {
                // Scene setup
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.Fog(0x000000, 10, 100);
                
                // Camera
                this.camera = new THREE.PerspectiveCamera(
                    75, 
                    window.innerWidth / window.innerHeight, 
                    0.1, 
                    1000
                );
                this.camera.position.set(0, 2, 10);
                
                // Renderer
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                threeContainer.appendChild(this.renderer.domElement);
                
                // Lighting
                this.setupLighting();
                
                // Create gallery
                this.createGallery();
                
                // Event listeners
                this.setupEventListeners();
                
                // Update controls hint
                const controlsHint = document.getElementById('controls-hint');
                if (this.isMobile) {
                    controlsHint.textContent = 'Swipe to look around, Use joystick to move, Tap on artworks to view';
                    document.getElementById('mobile-controls').classList.add('show');
                }
                
                // Start animation
                this.animate();
            }
            
            setupLighting() {
                // Ambient light
                const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
                this.scene.add(ambientLight);
                
                // Directional light (sun)
                const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
                dirLight.position.set(10, 20, 10);
                dirLight.castShadow = true;
                dirLight.shadow.camera.near = 0.1;
                dirLight.shadow.camera.far = 50;
                dirLight.shadow.camera.left = -50;
                dirLight.shadow.camera.right = 50;
                dirLight.shadow.camera.top = 50;
                dirLight.shadow.camera.bottom = -50;
                this.scene.add(dirLight);
                
                // Point lights for artwork
                const colors = [0xff00ff, 0x00ffff, 0xffff00];
                colors.forEach((color, i) => {
                    const light = new THREE.PointLight(color, 0.5, 10);
                    light.position.set(i * 10 - 10, 3, 0);
                    this.scene.add(light);
                });
            }
            
            createGallery() {
                // Create floor
                const floorGeometry = new THREE.BoxGeometry(100, 1, 100);
                const floorMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x333333,
                    emissive: 0x111111
                });
                const floor = new THREE.Mesh(floorGeometry, floorMaterial);
                floor.position.y = -0.5;
                floor.receiveShadow = true;
                this.scene.add(floor);
                
                // Create walls
                this.createWalls();
                
                // Create artworks
                this.createArtworks();
                
                // Add some decorative cubes
                this.addDecorations();
            }
            
            createWalls() {
                const wallMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x666666,
                    emissive: 0x222222
                });
                
                // Back wall
                const backWall = new THREE.Mesh(
                    new THREE.BoxGeometry(100, 20, 1),
                    wallMaterial
                );
                backWall.position.set(0, 10, -50);
                backWall.castShadow = true;
                backWall.receiveShadow = true;
                this.scene.add(backWall);
                
                // Side walls
                const leftWall = new THREE.Mesh(
                    new THREE.BoxGeometry(1, 20, 100),
                    wallMaterial
                );
                leftWall.position.set(-50, 10, 0);
                leftWall.castShadow = true;
                leftWall.receiveShadow = true;
                this.scene.add(leftWall);
                
                const rightWall = new THREE.Mesh(
                    new THREE.BoxGeometry(1, 20, 100),
                    wallMaterial
                );
                rightWall.position.set(50, 10, 0);
                rightWall.castShadow = true;
                rightWall.receiveShadow = true;
                this.scene.add(rightWall);
            }
            
            createTextSprite(text, fontSize = 0.5) {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 256;
                
                context.fillStyle = 'rgba(0, 0, 0, 0)';
                context.fillRect(0, 0, canvas.width, canvas.height);
                
                context.font = `${canvas.width * fontSize}px Arial`;
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillStyle = 'white';
                
                // For emoji, we need to handle them differently
                if (text.length <= 2 && /\p{Emoji}/u.test(text)) {
                    context.font = `${canvas.width * fontSize * 0.8}px Arial`;
                }
                
                context.fillText(text, canvas.width / 2, canvas.height / 2);
                
                const texture = new THREE.CanvasTexture(canvas);
                texture.needsUpdate = true;
                
                const spriteMaterial = new THREE.SpriteMaterial({ 
                    map: texture,
                    transparent: true
                });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.scale.set(2, 2, 1);
                
                return sprite;
            }
            
            createArtworks() {
                const files = this.data.files || this.data.mainFiles || [];
                const numArtworks = Math.min(files.length, 20);
                
                for (let i = 0; i < numArtworks; i++) {
                    const file = files[i];
                    const metadata = generateArtworkMetadata(file);
                    
                    // Create artwork group
                    const artworkGroup = new THREE.Group();
                    
                    // Frame
                    const frameGeometry = new THREE.BoxGeometry(4, 3, 0.2);
                    const frameMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0x888888,
                        emissive: 0x444444
                    });
                    const frame = new THREE.Mesh(frameGeometry, frameMaterial);
                    
                    // Canvas (artwork) with random color
                    const canvasGeometry = new THREE.BoxGeometry(3.6, 2.6, 0.1);
                    const hue = Math.random();
                    const canvasMaterial = new THREE.MeshLambertMaterial({ 
                        color: new THREE.Color().setHSL(hue, 0.7, 0.5),
                        emissive: new THREE.Color().setHSL(hue, 0.7, 0.3),
                        emissiveIntensity: 0.5
                    });
                    const canvas = new THREE.Mesh(canvasGeometry, canvasMaterial);
                    canvas.position.z = 0.1;
                    frame.add(canvas);
                    
                    // Add emoji sprite to canvas
                    const emojiSprite = this.createTextSprite(metadata.icon, 0.4);
                    emojiSprite.position.z = 0.2;
                    canvas.add(emojiSprite);
                    
                    // Add title below frame
                    const titleSprite = this.createTextSprite(metadata.title.substring(0, 15) + (metadata.title.length > 15 ? '...' : ''), 0.15);
                    titleSprite.position.y = -2;
                    titleSprite.position.z = 0.5;
                    frame.add(titleSprite);
                    
                    artworkGroup.add(frame);
                    
                    // Position artwork
                    const angle = (i / numArtworks) * Math.PI * 2;
                    const radius = 20;
                    artworkGroup.position.x = Math.cos(angle) * radius;
                    artworkGroup.position.z = Math.sin(angle) * radius;
                    artworkGroup.position.y = 3;
                    artworkGroup.rotation.y = -angle + Math.PI;
                    
                    frame.castShadow = true;
                    frame.receiveShadow = true;
                    
                    // Store data for interaction - use GitHub Pages URL
                    frame.userData = {
                        url: file.pages_url,
                        title: metadata.title,
                        description: metadata.description,
                        filename: file.path.split('/').pop(),
                        icon: metadata.icon
                    };
                    
                    this.artworks.push(frame);
                    this.scene.add(artworkGroup);
                }
            }
            
            addDecorations() {
                const decorationMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x444444,
                    emissive: 0x222222
                });
                
                // Add some pillars
                for (let i = 0; i < 8; i++) {
                    const pillar = new THREE.Mesh(
                        new THREE.BoxGeometry(2, 10, 2),
                        decorationMaterial
                    );
                    
                    const angle = (i / 8) * Math.PI * 2;
                    pillar.position.x = Math.cos(angle) * 30;
                    pillar.position.z = Math.sin(angle) * 30;
                    pillar.position.y = 5;
                    
                    pillar.castShadow = true;
                    pillar.receiveShadow = true;
                    
                    this.scene.add(pillar);
                }
                
                // Add floating cubes
                for (let i = 0; i < 20; i++) {
                    const size = Math.random() * 0.5 + 0.5;
                    const cube = new THREE.Mesh(
                        new THREE.BoxGeometry(size, size, size),
                        new THREE.MeshLambertMaterial({ 
                            color: new THREE.Color().setHSL(Math.random(), 0.7, 0.5),
                            emissive: new THREE.Color().setHSL(Math.random(), 0.7, 0.3),
                            emissiveIntensity: 0.3
                        })
                    );
                    
                    cube.position.x = (Math.random() - 0.5) * 40;
                    cube.position.y = Math.random() * 10 + 10;
                    cube.position.z = (Math.random() - 0.5) * 40;
                    
                    cube.rotation.x = Math.random() * Math.PI * 2;
                    cube.rotation.y = Math.random() * Math.PI * 2;
                    
                    cube.userData.floatSpeed = Math.random() * 0.02 + 0.01;
                    cube.userData.rotateSpeed = Math.random() * 0.02 + 0.01;
                    
                    cube.castShadow = true;
                    
                    this.scene.add(cube);
                }
            }
            
            setupEventListeners() {
                if (this.isMobile) {
                    this.setupMobileControls();
                } else {
                    this.setupDesktopControls();
                }
                
                // Window resize
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }
            
            setupDesktopControls() {
                // Keyboard controls
                window.addEventListener('keydown', (e) => {
                    if (e.key.toLowerCase() in this.keys) {
                        this.keys[e.key.toLowerCase()] = true;
                    }
                });
                
                window.addEventListener('keyup', (e) => {
                    if (e.key.toLowerCase() in this.keys) {
                        this.keys[e.key.toLowerCase()] = false;
                    }
                });
                
                // Mouse controls
                this.renderer.domElement.addEventListener('click', () => {
                    if (!this.isPointerLocked) {
                        this.renderer.domElement.requestPointerLock();
                    }
                });
                
                document.addEventListener('pointerlockchange', () => {
                    this.isPointerLocked = document.pointerLockElement === this.renderer.domElement;
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (this.isPointerLocked) {
                        this.rotation.y -= e.movementX * this.lookSpeed;
                        this.rotation.x -= e.movementY * this.lookSpeed;
                        this.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.rotation.x));
                    }
                });
                
                // Click on artwork
                this.renderer.domElement.addEventListener('click', (e) => {
                    if (!this.isPointerLocked) return;
                    
                    this.raycaster.setFromCamera(new THREE.Vector2(0, 0), this.camera);
                    const intersects = this.raycaster.intersectObjects(this.artworks, true);
                    
                    if (intersects.length > 0) {
                        const artwork = intersects[0].object.parent || intersects[0].object;
                        if (artwork.userData && artwork.userData.url) {
                            // Open GitHub Pages URL directly
                            window.open(artwork.userData.url, '_blank');
                        }
                    }
                });
            }
            
            setupMobileControls() {
                const canvas = this.renderer.domElement;
                
                // Touch start
                canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    this.touches.start = {
                        x: touch.clientX,
                        y: touch.clientY
                    };
                    this.touches.current = {...this.touches.start};
                });
                
                // Touch move - camera rotation
                canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (!this.touches.start) return;
                    
                    const touch = e.touches[0];
                    const deltaX = touch.clientX - this.touches.current.x;
                    const deltaY = touch.clientY - this.touches.current.y;
                    
                    this.rotation.y -= deltaX * this.lookSpeed * 2;
                    this.rotation.x -= deltaY * this.lookSpeed * 2;
                    this.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.rotation.x));
                    
                    this.touches.current = {
                        x: touch.clientX,
                        y: touch.clientY
                    };
                });
                
                // Touch end
                canvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    
                    // Check if it was a tap
                    if (this.touches.start && this.touches.current) {
                        const dx = this.touches.current.x - this.touches.start.x;
                        const dy = this.touches.current.y - this.touches.start.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < 10) {
                            // It's a tap - check for artwork
                            // Convert touch coordinates to normalized device coordinates
                            const rect = canvas.getBoundingClientRect();
                            const x = ((this.touches.start.x - rect.left) / rect.width) * 2 - 1;
                            const y = -((this.touches.start.y - rect.top) / rect.height) * 2 + 1;
                            
                            this.raycaster.setFromCamera(new THREE.Vector2(x, y), this.camera);
                            const intersects = this.raycaster.intersectObjects(this.artworks, true);
                            
                            if (intersects.length > 0) {
                                const artwork = intersects[0].object.parent || intersects[0].object;
                                if (artwork.userData && artwork.userData.url) {
                                    // Open GitHub Pages URL directly
                                    window.open(artwork.userData.url, '_blank');
                                }
                            }
                        }
                    }
                    
                    this.touches.start = null;
                    this.touches.current = null;
                });
                
                // Joystick controls
                const joystick = document.getElementById('movement-joystick');
                const handle = document.getElementById('movement-handle');
                
                joystick.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.joystickActive = true;
                    this.updateJoystick(e.touches[0], joystick, handle);
                });
                
                joystick.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (this.joystickActive) {
                        this.updateJoystick(e.touches[0], joystick, handle);
                    }
                });
                
                joystick.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.joystickActive = false;
                    this.joystickVector.set(0, 0);
                    handle.style.transform = 'translate(-50%, -50%)';
                });
            }
            
            updateJoystick(touch, joystick, handle) {
                const rect = joystick.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                let deltaX = touch.clientX - centerX;
                let deltaY = touch.clientY - centerY;
                
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                const maxDistance = rect.width / 2 - 25; // handle radius
                
                if (distance > maxDistance) {
                    deltaX = (deltaX / distance) * maxDistance;
                    deltaY = (deltaY / distance) * maxDistance;
                }
                
                handle.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;
                
                this.joystickVector.x = deltaX / maxDistance;
                this.joystickVector.y = -deltaY / maxDistance;
            }
            
            updateHover() {
                // Cast ray from camera center
                this.raycaster.setFromCamera(new THREE.Vector2(0, 0), this.camera);
                const intersects = this.raycaster.intersectObjects(this.artworks, true);
                
                if (intersects.length > 0) {
                    const artwork = intersects[0].object.parent || intersects[0].object;
                    
                    if (artwork.userData && artwork.userData.title && artwork !== this.hoveredArtwork) {
                        this.hoveredArtwork = artwork;
                        
                        // Show tooltip
                        this.tooltipTitle.textContent = `${artwork.userData.icon} ${artwork.userData.title}`;
                        this.tooltipDescription.textContent = artwork.userData.description;
                        this.tooltip.classList.add('visible');
                        
                        // Position tooltip
                        const vector = new THREE.Vector3();
                        artwork.getWorldPosition(vector);
                        vector.project(this.camera);
                        
                        const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                        const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
                        
                        this.tooltip.style.left = `${Math.min(x + 20, window.innerWidth - 420)}px`;
                        this.tooltip.style.top = `${Math.min(y - 50, window.innerHeight - 250)}px`;
                    }
                } else {
                    if (this.hoveredArtwork) {
                        this.hoveredArtwork = null;
                        this.tooltip.classList.remove('visible');
                    }
                }
            }
            
            updateMovement() {
                const forward = new THREE.Vector3();
                const right = new THREE.Vector3();
                
                this.camera.getWorldDirection(forward);
                forward.y = 0;
                forward.normalize();
                
                right.crossVectors(forward, new THREE.Vector3(0, 1, 0));
                
                if (this.isMobile) {
                    // Mobile joystick movement
                    if (this.joystickActive) {
                        const moveForward = forward.multiplyScalar(this.joystickVector.y * this.moveSpeed);
                        const moveRight = right.multiplyScalar(this.joystickVector.x * this.moveSpeed);
                        this.camera.position.add(moveForward);
                        this.camera.position.add(moveRight);
                    }
                } else {
                    // Desktop keyboard movement
                    if (this.keys.w) this.camera.position.add(forward.multiplyScalar(this.moveSpeed));
                    if (this.keys.s) this.camera.position.add(forward.multiplyScalar(-this.moveSpeed));
                    if (this.keys.a) this.camera.position.add(right.multiplyScalar(-this.moveSpeed));
                    if (this.keys.d) this.camera.position.add(right.multiplyScalar(this.moveSpeed));
                }
                
                // Update camera rotation
                this.camera.rotation.order = 'YXZ';
                this.camera.rotation.y = this.rotation.y;
                this.camera.rotation.x = this.rotation.x;
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                // Update movement
                this.updateMovement();
                
                // Update hover detection
                this.updateHover();
                
                // Animate floating cubes
                this.scene.children.forEach(child => {
                    if (child.userData.floatSpeed) {
                        child.position.y += Math.sin(Date.now() * child.userData.floatSpeed) * 0.01;
                        child.rotation.x += child.userData.rotateSpeed;
                        child.rotation.y += child.userData.rotateSpeed * 0.7;
                    }
                });
                
                this.renderer.render(this.scene, this.camera);
            }
            
            cleanup() {
                if (this.renderer) {
                    threeContainer.removeChild(this.renderer.domElement);
                    this.renderer.dispose();
                }
                
                // Hide tooltip
                this.tooltip.classList.remove('visible');
                
                // Hide mobile controls
                document.getElementById('mobile-controls').classList.remove('show');
                
                // Exit pointer lock
                if (document.pointerLockElement) {
                    document.exitPointerLock();
                }
                
                // Remove event listeners
                window.removeEventListener('keydown', this.handleKeyDown);
                window.removeEventListener('keyup', this.handleKeyUp);
            }
        }
        
        // Initialize gallery
        window.addEventListener('DOMContentLoaded', () => {
            // Show environment info
            if (isLocal) {
                console.log('🏠 Running in LOCAL mode - will use local file paths');
                showToast('Running locally - using local file paths', 'success');
            } else {
                console.log('🌐 Running in PRODUCTION mode - will use GitHub Pages URLs');
            }
            
            fetchRepoFiles();
        });
    </script>
</body>
</html>