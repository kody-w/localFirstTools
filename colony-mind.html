<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Colony Mind</title>
    <meta name="description" content="Watch ants collectively excavate tunnel networks through soil using simple rules that create emergent complexity">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #1a1510; min-height: 100vh; font-family: 'Georgia', serif; color: #a09070; overflow: hidden; }
        #canvas { position: fixed; top: 0; left: 0; cursor: crosshair; }
        #controls {
            position: fixed; top: 20px; left: 20px; background: rgba(26,21,16,0.95);
            padding: 20px; border-radius: 10px; border: 1px solid rgba(160,120,80,0.3);
            z-index: 100;
        }
        h3 { margin-bottom: 15px; color: #c0a070; font-weight: normal; }
        .control-row { margin: 10px 0; }
        label { display: block; font-size: 11px; margin-bottom: 5px; opacity: 0.8; }
        input[type="range"] { width: 140px; }
        .value { float: right; color: #d0b080; font-size: 12px; }
        button {
            display: block; width: 100%; padding: 10px; margin: 6px 0;
            background: rgba(100,80,50,0.4); border: 1px solid rgba(160,120,80,0.4);
            color: #a09060; cursor: pointer; border-radius: 6px; font-family: inherit;
        }
        button:hover { background: rgba(120,100,70,0.5); }
        .btn-group { display: flex; gap: 6px; }
        .btn-group button { flex: 1; }
        .btn-export { background: rgba(80,100,60,0.4); border-color: rgba(120,160,80,0.4); }
        .btn-import { background: rgba(60,80,100,0.4); border-color: rgba(80,120,160,0.4); }
        #file-input { display: none; }
        .save-info { font-size: 10px; opacity: 0.6; text-align: center; margin-top: 8px; }
        #stats { position: fixed; top: 20px; right: 20px; font-size: 12px; color: #806050; z-index: 100; text-align: right; }
        #info { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); font-size: 12px; opacity: 0.5; z-index: 100; }
        #weather-indicator {
            position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(26,21,16,0.9); padding: 8px 16px; border-radius: 20px;
            border: 1px solid rgba(160,120,80,0.3); z-index: 100;
            font-size: 13px; display: flex; align-items: center; gap: 8px;
        }
        #weather-icon { font-size: 18px; }
        #weather-name { color: #c0a070; }
        #weather-timer { color: #806050; font-size: 11px; }
        .speed-controls { display: flex; gap: 4px; margin: 6px 0; }
        .speed-btn {
            flex: 1; padding: 6px 4px; font-size: 10px;
            background: rgba(60,50,40,0.4); border: 1px solid rgba(120,100,80,0.3);
        }
        .speed-btn.active { background: rgba(120,100,60,0.6); border-color: rgba(180,140,80,0.5); }
        .btn-pause { background: rgba(120,80,60,0.4); border-color: rgba(180,120,80,0.4); }
        .btn-pause.paused { background: rgba(80,120,60,0.5); border-color: rgba(120,180,80,0.5); }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="controls">
        <h3>Colony Mind</h3>
        <div class="control-row">
            <label>Colony Size <span class="value" id="size-val">150</span></label>
            <input type="range" id="size" min="50" max="300" value="150">
        </div>
        <div class="control-row">
            <label>Dig Speed <span class="value" id="speed-val">50</span></label>
            <input type="range" id="speed" min="20" max="100" value="50">
        </div>
        <button id="food-btn">Place Food Source</button>
        <button id="reset-btn">New Colony</button>
        <div class="btn-group">
            <button id="export-btn" class="btn-export">Export</button>
            <button id="import-btn" class="btn-import">Import</button>
        </div>
        <button id="pause-btn" class="btn-pause">Pause</button>
        <div class="speed-controls">
            <button class="speed-btn" data-speed="0.5">0.5x</button>
            <button class="speed-btn active" data-speed="1">1x</button>
            <button class="speed-btn" data-speed="2">2x</button>
            <button class="speed-btn" data-speed="4">4x</button>
        </div>
        <button id="sound-btn" style="background: rgba(80,60,100,0.4); border-color: rgba(140,100,180,0.4);">Sound Off</button>
        <input type="file" id="file-input" accept=".json">
        <div class="save-info">Space=pause | 1-4=speed | W=weather</div>
    </div>
    <div id="weather-indicator">
        <span id="weather-icon">‚òÄÔ∏è</span>
        <span id="weather-name">Clear</span>
        <span id="weather-timer"></span>
    </div>
    <div id="stats">
        <div>Ants: <span id="ant-count">0</span></div>
        <div>Tunnels: <span id="tunnel-length">0</span>m</div>
        <div>Chambers: <span id="chamber-count">0</span></div>
        <div>Depth: <span id="world-depth">1</span>x</div>
        <div>Explored: <span id="explored-pct">0</span>%</div>
        <div>Queen Fed: <span id="queen-fed">0</span></div>
        <div>Births: <span id="birth-count">0</span> | Deaths: <span id="death-count">0</span></div>
        <div>Generation: <span id="generation-count">0</span></div>
        <div style="margin-top: 8px; border-top: 1px solid rgba(128,96,80,0.3); padding-top: 6px;">
            <div id="role-bar" style="
                width: 100%; height: 10px; background: rgba(0,0,0,0.3);
                border-radius: 5px; overflow: hidden; display: flex; margin-bottom: 6px;
            ">
                <div id="bar-workers" style="height: 100%; background: #3a2a1a; transition: width 0.3s;"></div>
                <div id="bar-excavators" style="height: 100%; background: #5a3a2a; transition: width 0.3s;"></div>
                <div id="bar-gatherers" style="height: 100%; background: #4a6a3a; transition: width 0.3s;"></div>
                <div id="bar-nurses" style="height: 100%; background: #6a5a4a; transition: width 0.3s;"></div>
            </div>
            <span style="color: #3a2a1a;">Workers:</span> <span id="worker-count">0</span>
        </div>
        <div><span style="color: #5a3a2a;">Excavators:</span> <span id="excavator-count">0</span></div>
        <div><span style="color: #4a6a3a;">Gatherers:</span> <span id="gatherer-count">0</span></div>
        <div><span style="color: #6a5a4a;">Nurses:</span> <span id="nurse-count">0</span></div>
    </div>
    <div id="info">Starter food provided | 2 min clear weather grace period | Click to add more food | Space=pause W=weather</div>
    <div id="milestone-toast" style="
        position: fixed; bottom: 60px; left: 50%; transform: translateX(-50%);
        background: rgba(180, 140, 80, 0.9); color: #fff; padding: 12px 24px;
        border-radius: 8px; font-size: 14px; opacity: 0; transition: opacity 0.5s;
        pointer-events: none; text-align: center; max-width: 300px;
        border: 1px solid rgba(255, 200, 100, 0.5); box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    "></div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let W, H;

        // Constants must be declared before resize() which uses them
        const SOIL_RESOLUTION = 4;
        let soilGrid = [];
        let pheromoneGrid = [];          // Food trail pheromones (amber)
        let explorationPheromoneGrid = []; // Dig site pheromones (blue)
        let alarmPheromoneGrid = [];     // Danger/death pheromones (red) - ants avoid
        const ants = [];
        const foodSources = [];
        const chambers = [];

        let colonySize = 150; // Start with more ants for better survival
        let digSpeed = 0.5;
        let time = 0;
        let placingFood = false;

        // ============ PERPETUAL EXPANSION SYSTEM ============
        let worldScale = 1.0;           // Current zoom level (1.0 = starting view)
        let targetScale = 1.0;          // Target scale for smooth transitions
        let totalExpansions = 0;        // Number of times world has expanded
        const EXPANSION_THRESHOLD = 0.25; // Expand when 25% of soil is excavated
        const EXPANSION_FACTOR = 1.5;   // How much to grow on each expansion
        let lastExpansionCheck = 0;     // Throttle expansion checks
        let exploredPercentage = 0;     // Current excavation percentage

        const SOIL_COLORS = [
            { depth: 0, color: [60, 45, 30] },
            { depth: 0.3, color: [80, 55, 35] },
            { depth: 0.6, color: [100, 70, 45] },
            { depth: 1, color: [70, 50, 35] }
        ];

        // ============ SIMULATION CONTROL ============
        let isPaused = false;
        let simulationSpeed = 1.0;

        // ============ SPATIAL PARTITIONING FOR O(1) LOOKUPS ============
        class SpatialGrid {
            constructor(cellSize = 40) {
                this.cellSize = cellSize;
                this.cells = new Map();
            }

            getKey(x, y) {
                const cx = Math.floor(x / this.cellSize);
                const cy = Math.floor(y / this.cellSize);
                return `${cx},${cy}`;
            }

            insert(entity) {
                const key = this.getKey(entity.x, entity.y);
                if (!this.cells.has(key)) {
                    this.cells.set(key, []);
                }
                this.cells.get(key).push(entity);
                entity._spatialKey = key;
            }

            remove(entity) {
                if (entity._spatialKey) {
                    const cell = this.cells.get(entity._spatialKey);
                    if (cell) {
                        const idx = cell.indexOf(entity);
                        if (idx !== -1) cell.splice(idx, 1);
                    }
                }
            }

            update(entity) {
                const newKey = this.getKey(entity.x, entity.y);
                if (newKey !== entity._spatialKey) {
                    this.remove(entity);
                    this.insert(entity);
                }
            }

            getNearby(x, y, radius) {
                const results = [];
                const cellRadius = Math.ceil(radius / this.cellSize);
                const cx = Math.floor(x / this.cellSize);
                const cy = Math.floor(y / this.cellSize);

                for (let dy = -cellRadius; dy <= cellRadius; dy++) {
                    for (let dx = -cellRadius; dx <= cellRadius; dx++) {
                        const key = `${cx + dx},${cy + dy}`;
                        const cell = this.cells.get(key);
                        if (cell) {
                            for (const entity of cell) {
                                const dist = Math.hypot(entity.x - x, entity.y - y);
                                if (dist <= radius) {
                                    results.push(entity);
                                }
                            }
                        }
                    }
                }
                return results;
            }

            clear() {
                this.cells.clear();
            }
        }

        const antSpatialGrid = new SpatialGrid(40);

        // ============ WEATHER SYSTEM ============
        const WEATHER_STATES = {
            CLEAR: { name: 'Clear', icon: '‚òÄÔ∏è', duration: [45, 75], color: [135, 180, 220] },
            RAIN: { name: 'Rain', icon: 'üåßÔ∏è', duration: [30, 60], color: [80, 100, 130] },
            DROUGHT: { name: 'Drought', icon: 'üî•', duration: [40, 70], color: [180, 140, 100] },
            COLD: { name: 'Cold', icon: '‚ùÑÔ∏è', duration: [35, 55], color: [150, 170, 200] },
            STORM: { name: 'Storm', icon: '‚õàÔ∏è', duration: [20, 35], color: [50, 60, 80] }
        };

        class WeatherSystem {
            constructor() {
                this.state = 'CLEAR';
                this.stateTime = 0;
                this.cycleDuration = 120; // Start with long clear period (grace period)
                this.transitionProgress = 1; // 1 = fully in current state
                this.previousState = 'CLEAR';
                this.particles = [];
                this.maxParticles = 200;
                this.floodLevel = 0; // 0-1, how flooded deep tunnels are
                this.lightningFlash = 0;
                this.windStrength = 0;
                this.gracePeriod = true; // First weather cycle is guaranteed clear
            }

            getRandomDuration(state) {
                const [min, max] = WEATHER_STATES[state].duration;
                return min + Math.random() * (max - min);
            }

            getNextState() {
                // After grace period, still favor clear/mild weather
                // Grace period guarantees first transition stays clear-ish
                if (this.gracePeriod) {
                    this.gracePeriod = false;
                    // 70% chance of another clear period, 30% chance of mild rain
                    return Math.random() < 0.7 ? 'CLEAR' : 'RAIN';
                }

                const states = Object.keys(WEATHER_STATES);
                // Weight heavily toward clear weather, storms are very rare
                const weights = { CLEAR: 5, RAIN: 2, DROUGHT: 1.5, COLD: 1.5, STORM: 0.5 };
                const totalWeight = Object.values(weights).reduce((a, b) => a + b, 0);
                let r = Math.random() * totalWeight;
                for (const state of states) {
                    r -= weights[state];
                    if (r <= 0) return state;
                }
                return 'CLEAR';
            }

            update(dt) {
                this.stateTime += dt;

                // Transition effect
                if (this.transitionProgress < 1) {
                    this.transitionProgress = Math.min(1, this.transitionProgress + dt * 0.2);
                }

                // Check for state change
                if (this.stateTime >= this.cycleDuration) {
                    this.previousState = this.state;
                    this.state = this.getNextState();
                    this.cycleDuration = this.getRandomDuration(this.state);
                    this.stateTime = 0;
                    this.transitionProgress = 0;
                    this.updateUI();
                }

                // Update weather-specific effects
                this.updateEffects(dt);
                this.updateParticles(dt);
                this.updateUI();
            }

            updateEffects(dt) {
                // Lightning in storms
                if (this.state === 'STORM') {
                    if (Math.random() < 0.005) {
                        this.lightningFlash = 1;
                    }
                    this.windStrength = 0.8 + Math.sin(time * 2) * 0.2;
                } else {
                    this.windStrength = this.state === 'RAIN' ? 0.3 : 0;
                }
                this.lightningFlash *= 0.85;

                // Flood level during rain/storm
                if (this.state === 'RAIN' || this.state === 'STORM') {
                    this.floodLevel = Math.min(1, this.floodLevel + dt * 0.02);
                } else {
                    this.floodLevel = Math.max(0, this.floodLevel - dt * 0.03);
                }
            }

            updateParticles(dt) {
                // Spawn weather particles
                const spawnRates = { CLEAR: 0, RAIN: 3, DROUGHT: 0.3, COLD: 1.5, STORM: 5 };
                const rate = spawnRates[this.state] || 0;

                for (let i = 0; i < rate; i++) {
                    if (this.particles.length < this.maxParticles && Math.random() < 0.5) {
                        this.spawnParticle();
                    }
                }

                // Update existing particles
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];
                    p.x += p.vx * dt * 60;
                    p.y += p.vy * dt * 60;
                    p.life -= p.decay * dt * 60;

                    if (p.life <= 0 || p.y > H || p.x < 0 || p.x > W) {
                        this.particles.splice(i, 1);
                    }
                }
            }

            spawnParticle() {
                const types = {
                    RAIN: { vy: 8, vx: 2, size: 2, color: [150, 180, 220], decay: 0.01 },
                    STORM: { vy: 12, vx: 4, size: 3, color: [120, 150, 200], decay: 0.015 },
                    COLD: { vy: 1.5, vx: 0.5, size: 3, color: [220, 230, 255], decay: 0.008 },
                    DROUGHT: { vy: -0.5, vx: 1, size: 2, color: [200, 160, 100], decay: 0.02 }
                };

                const config = types[this.state];
                if (!config) return;

                this.particles.push({
                    x: Math.random() * W,
                    y: this.state === 'DROUGHT' ? H * 0.3 + Math.random() * H * 0.5 : -10,
                    vx: (Math.random() - 0.5) * config.vx + this.windStrength * 2,
                    vy: config.vy + Math.random() * 2,
                    size: config.size * (0.5 + Math.random() * 0.5),
                    color: config.color,
                    life: 1,
                    decay: config.decay
                });
            }

            draw() {
                // Draw weather particles
                for (const p of this.particles) {
                    ctx.beginPath();
                    if (this.state === 'RAIN' || this.state === 'STORM') {
                        // Rain streaks
                        ctx.moveTo(p.x, p.y);
                        ctx.lineTo(p.x - p.vx * 0.3, p.y - p.vy * 0.5);
                        ctx.strokeStyle = `rgba(${p.color.join(',')}, ${p.life * 0.6})`;
                        ctx.lineWidth = p.size * 0.5;
                        ctx.stroke();
                    } else if (this.state === 'COLD') {
                        // Snowflakes
                        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(${p.color.join(',')}, ${p.life * 0.8})`;
                        ctx.fill();
                    } else if (this.state === 'DROUGHT') {
                        // Heat shimmer / dust
                        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(${p.color.join(',')}, ${p.life * 0.4})`;
                        ctx.fill();
                    }
                }

                // Lightning flash overlay
                if (this.lightningFlash > 0.1) {
                    ctx.fillStyle = `rgba(255, 255, 255, ${this.lightningFlash * 0.3})`;
                    ctx.fillRect(0, 0, W, H);
                }

                // Flood water in deep tunnels
                if (this.floodLevel > 0) {
                    this.drawFloodWater();
                }
            }

            drawFloodWater() {
                const floodStartY = H * (0.6 - this.floodLevel * 0.2);
                const cols = soilGrid[0]?.length || 0;
                const rows = soilGrid.length || 0;

                ctx.globalAlpha = this.floodLevel * 0.4;
                for (let gy = Math.floor(floodStartY / SOIL_RESOLUTION); gy < rows; gy++) {
                    for (let gx = 0; gx < cols; gx++) {
                        if (soilGrid[gy] && soilGrid[gy][gx] < 0.5) {
                            const sx = gx * (W / cols);
                            const sy = gy * (H / rows);
                            const waterDepth = (gy / rows - 0.5) * 2;
                            ctx.fillStyle = `rgba(60, 100, 150, ${0.3 + waterDepth * 0.3})`;
                            ctx.fillRect(sx, sy, W / cols + 1, H / rows + 1);
                        }
                    }
                }
                ctx.globalAlpha = 1;
            }

            getSpeedModifier() {
                // Less harsh speed penalties to help colony survive
                const mods = { CLEAR: 1.0, RAIN: 0.9, DROUGHT: 0.9, COLD: 0.75, STORM: 0.8 };
                return mods[this.state] || 1.0;
            }

            getDeathRiskMultiplier() {
                // Elders have slightly higher death risk in cold (reduced from 2.0)
                return this.state === 'COLD' ? 1.5 : 1.0;
            }

            getFoodDepletionMultiplier() {
                // Drought depletes food faster but not as extreme
                return this.state === 'DROUGHT' ? 2.0 : 1.0;
            }

            isFlooded(y) {
                // Only deep tunnels flood (below 70% instead of 60%)
                if (this.floodLevel < 0.2) return false;
                const floodStartY = H * (0.7 - this.floodLevel * 0.15);
                return y > floodStartY;
            }

            updateUI() {
                const stateInfo = WEATHER_STATES[this.state];
                document.getElementById('weather-icon').textContent = stateInfo.icon;
                document.getElementById('weather-name').textContent = stateInfo.name;
                const remaining = Math.ceil(this.cycleDuration - this.stateTime);
                document.getElementById('weather-timer').textContent = `${remaining}s`;
            }

            getSkyColor() {
                const current = WEATHER_STATES[this.state].color;
                const prev = WEATHER_STATES[this.previousState].color;
                const t = this.transitionProgress;
                return [
                    Math.round(prev[0] * (1 - t) + current[0] * t),
                    Math.round(prev[1] * (1 - t) + current[1] * t),
                    Math.round(prev[2] * (1 - t) + current[2] * t)
                ];
            }
        }

        const weather = new WeatherSystem();

        // ============ QUEEN ANT REPRODUCTION SYSTEM ============
        let queen = null;
        let totalBirths = 0;
        const QUEEN_SPAWN_INTERVAL = 6; // seconds between spawn attempts (faster reproduction)
        const FOOD_PER_BIRTH = 1; // food deliveries needed per new ant (easier to grow colony)

        class QueenAnt {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.foodReceived = 0;
                this.lastSpawnTime = 0;
                this.pulsePhase = 0;
                this.eggProgress = 0; // Visual indicator of egg development
            }

            feedQueen() {
                this.foodReceived++;
                this.eggProgress = Math.min(1, this.eggProgress + (1 / FOOD_PER_BIRTH));
            }

            update(currentTime) {
                this.pulsePhase += 0.02;

                // Check if ready to spawn new ants
                if (currentTime - this.lastSpawnTime >= QUEEN_SPAWN_INTERVAL) {
                    if (this.foodReceived >= FOOD_PER_BIRTH) {
                        const antsToSpawn = Math.min(2, Math.floor(this.foodReceived / FOOD_PER_BIRTH));
                        for (let i = 0; i < antsToSpawn; i++) {
                            this.spawnWorker();
                        }
                        this.foodReceived -= antsToSpawn * FOOD_PER_BIRTH;
                        this.eggProgress = this.foodReceived / FOOD_PER_BIRTH;
                        this.lastSpawnTime = currentTime;
                    }
                }
            }

            spawnWorker() {
                const ant = new Ant();
                // Spawn near queen
                ant.x = this.x + (Math.random() - 0.5) * 25;
                ant.y = this.y + (Math.random() - 0.5) * 25;
                ant.angle = Math.random() * Math.PI * 2;

                // Apply genetic memory - inherited behaviors from successful ancestors
                applyGeneticMemory(ant);

                ants.push(ant);
                antSpatialGrid.insert(ant); // Register in spatial grid
                totalBirths++;

                // Visual birth effect - brief glow
                this.pulsePhase = 0;
            }

            draw() {
                const pulse = 1 + Math.sin(this.pulsePhase) * 0.1;

                ctx.save();
                ctx.translate(this.x, this.y);

                // Glow effect based on egg progress
                if (this.eggProgress > 0) {
                    const glowRadius = 20 + this.eggProgress * 15;
                    const gradient = ctx.createRadialGradient(0, 0, 5, 0, 0, glowRadius);
                    gradient.addColorStop(0, `rgba(255, 220, 150, ${this.eggProgress * 0.3})`);
                    gradient.addColorStop(1, 'transparent');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(-glowRadius, -glowRadius, glowRadius * 2, glowRadius * 2);
                }

                // Queen abdomen (larger, golden)
                ctx.beginPath();
                ctx.ellipse(0, 0, 8 * pulse, 5 * pulse, 0, 0, Math.PI * 2);
                ctx.fillStyle = '#c4a040'; // Golden color
                ctx.fill();
                ctx.strokeStyle = '#8a7030';
                ctx.lineWidth = 1;
                ctx.stroke();

                // Thorax
                ctx.beginPath();
                ctx.ellipse(-7, 0, 4 * pulse, 3 * pulse, 0, 0, Math.PI * 2);
                ctx.fillStyle = '#a08030';
                ctx.fill();

                // Head
                ctx.beginPath();
                ctx.ellipse(-11, 0, 3 * pulse, 2.5 * pulse, 0, 0, Math.PI * 2);
                ctx.fillStyle = '#8a6020';
                ctx.fill();

                // Antennae
                ctx.beginPath();
                ctx.moveTo(-13, -2);
                ctx.lineTo(-17, -5);
                ctx.moveTo(-13, 2);
                ctx.lineTo(-17, 5);
                ctx.strokeStyle = '#6a5020';
                ctx.lineWidth = 0.8;
                ctx.stroke();

                // Crown indicator (simple dots)
                ctx.beginPath();
                ctx.arc(-11, -4, 1.5, 0, Math.PI * 2);
                ctx.fillStyle = '#ffd700';
                ctx.fill();

                // Egg progress indicator (small eggs around queen)
                const numEggs = Math.floor(this.eggProgress * 3);
                for (let i = 0; i < numEggs; i++) {
                    const eggAngle = (i / 3) * Math.PI - Math.PI / 2;
                    const eggX = Math.cos(eggAngle) * 12;
                    const eggY = Math.sin(eggAngle) * 12;
                    ctx.beginPath();
                    ctx.ellipse(eggX, eggY, 2, 3, eggAngle + Math.PI / 2, 0, Math.PI * 2);
                    ctx.fillStyle = '#fffde0';
                    ctx.fill();
                    ctx.strokeStyle = '#e0d8a0';
                    ctx.lineWidth = 0.5;
                    ctx.stroke();
                }

                ctx.restore();

                // "QUEEN" label
                ctx.font = '9px Georgia';
                ctx.fillStyle = '#c4a040';
                ctx.textAlign = 'center';
                ctx.fillText('‚ôï', this.x, this.y - 18);
            }
        }

        function resize() {
            W = canvas.width = innerWidth;
            H = canvas.height = innerHeight;
            // Only init soil if grids are empty (first load)
            if (soilGrid.length === 0) {
                initSoil();
            }
            // Otherwise just redraw - grids maintain their own size
        }
        window.onresize = resize;

        function initSoil() {
            const cols = Math.ceil(W / SOIL_RESOLUTION);
            const rows = Math.ceil(H / SOIL_RESOLUTION);
            soilGrid = [];
            pheromoneGrid = [];
            explorationPheromoneGrid = [];
            alarmPheromoneGrid = [];

            for (let y = 0; y < rows; y++) {
                soilGrid[y] = [];
                pheromoneGrid[y] = [];
                explorationPheromoneGrid[y] = [];
                alarmPheromoneGrid[y] = [];
                for (let x = 0; x < cols; x++) {
                    const surfaceY = H * 0.15;
                    const worldY = y * SOIL_RESOLUTION;
                    soilGrid[y][x] = worldY > surfaceY ? 1 : 0;
                    pheromoneGrid[y][x] = 0;
                    explorationPheromoneGrid[y][x] = 0;
                    alarmPheromoneGrid[y][x] = 0;
                }
            }
            
            const nestX = Math.floor(W / 2 / SOIL_RESOLUTION);
            const nestY = Math.floor(H * 0.2 / SOIL_RESOLUTION);
            const surfaceGridY = Math.floor(H * 0.15 / SOIL_RESOLUTION);

            // Create nest chamber
            for (let dy = -3; dy <= 3; dy++) {
                for (let dx = -4; dx <= 4; dx++) {
                    const gx = nestX + dx;
                    const gy = nestY + dy;
                    if (gx >= 0 && gx < cols && gy >= 0 && gy < rows) {
                        if (Math.sqrt(dx*dx + dy*dy) < 4) {
                            soilGrid[gy][gx] = 0;
                        }
                    }
                }
            }

            // Create a simple vertical tunnel from nest to surface
            for (let y = surfaceGridY; y <= nestY + 2; y++) {
                for (let dx = -2; dx <= 2; dx++) {
                    if (soilGrid[y] && nestX + dx >= 0 && nestX + dx < cols) {
                        soilGrid[y][nestX + dx] = 0;
                    }
                }
            }

            chambers.push({ x: W/2, y: H * 0.2, radius: 15 });

            // Create the queen at the nest center
            queen = new QueenAnt(W / 2, H * 0.2);

            // Initialize AO cache
            initAOCache();

            // Generate organic root tendrils
            generateRoots();
        }
        
        // ============ ROLE SPECIALIZATION SYSTEM ============
        const ROLE_THRESHOLD = 50; // Experience needed to specialize
        const ANT_ROLES = {
            WORKER: 'worker',      // Generalist, can do anything
            EXCAVATOR: 'excavator', // Specializes in digging
            GATHERER: 'gatherer',   // Specializes in food collection
            NURSE: 'nurse'          // Stays near queen, helps with larvae
        };

        // ============ TUNNEL ROOT TENDRIL SYSTEM ============
        // Organic roots that grow down from surface, visible when tunnels are dug
        let rootTendrils = [];

        function generateRoots() {
            rootTendrils = [];
            const numRoots = 8 + Math.floor(Math.random() * 6); // 8-13 major roots

            for (let i = 0; i < numRoots; i++) {
                const startX = 0.1 + Math.random() * 0.8; // Normalized x (10%-90%)
                const root = {
                    segments: [],
                    color: Math.random() > 0.5 ? 'warm' : 'cool'
                };

                // Generate root path using random walk
                let x = startX;
                let y = 0.15; // Start at surface
                let angle = Math.PI / 2 + (Math.random() - 0.5) * 0.3; // Mostly downward
                const maxDepth = 0.4 + Math.random() * 0.4; // Grow 40-80% down

                while (y < maxDepth) {
                    const thickness = Math.max(0.5, 3 * (1 - (y - 0.15) / (maxDepth - 0.15)));
                    root.segments.push({ x, y, thickness });

                    // Continue path with slight wandering
                    const stepSize = 0.01 + Math.random() * 0.015;
                    x += Math.cos(angle) * stepSize;
                    y += Math.sin(angle) * stepSize;

                    // Random angle changes (organic feel)
                    angle += (Math.random() - 0.5) * 0.4;
                    angle = Math.max(Math.PI * 0.3, Math.min(Math.PI * 0.7, angle)); // Keep mostly downward

                    // Occasionally branch
                    if (Math.random() < 0.1 && root.segments.length > 5) {
                        const branchRoot = {
                            segments: [],
                            color: root.color
                        };
                        let bx = x, by = y;
                        let bAngle = angle + (Math.random() > 0.5 ? 0.5 : -0.5);
                        const branchLength = 3 + Math.floor(Math.random() * 8);

                        for (let j = 0; j < branchLength && by < maxDepth + 0.1; j++) {
                            const bThick = Math.max(0.3, thickness * 0.5 * (1 - j / branchLength));
                            branchRoot.segments.push({ x: bx, y: by, thickness: bThick });
                            bx += Math.cos(bAngle) * 0.008;
                            by += Math.sin(bAngle) * 0.008;
                            bAngle += (Math.random() - 0.5) * 0.3;
                        }

                        if (branchRoot.segments.length > 2) {
                            rootTendrils.push(branchRoot);
                        }
                    }
                }

                rootTendrils.push(root);
            }
        }

        function drawRoots() {
            const gridCols = soilGrid[0]?.length || 0;
            const gridRows = soilGrid.length || 0;
            if (gridCols === 0 || gridRows === 0) return;

            ctx.save();

            for (const root of rootTendrils) {
                if (root.segments.length < 2) continue;

                ctx.beginPath();

                let hasVisibleSegment = false;

                for (let i = 0; i < root.segments.length; i++) {
                    const seg = root.segments[i];
                    const screenX = seg.x * W;
                    const screenY = seg.y * H;

                    // Check if this segment is in excavated soil
                    const gx = Math.floor(seg.x * gridCols);
                    const gy = Math.floor(seg.y * gridRows);

                    // Only draw if in a dug area OR near surface
                    const inTunnel = soilGrid[gy]?.[gx] !== undefined && soilGrid[gy][gx] < 0.5;
                    const nearSurface = seg.y < 0.18;

                    if (inTunnel || nearSurface) {
                        if (!hasVisibleSegment) {
                            ctx.moveTo(screenX, screenY);
                            hasVisibleSegment = true;
                        } else {
                            ctx.lineTo(screenX, screenY);
                        }
                    } else if (hasVisibleSegment) {
                        // End this stroke, potentially start new one later
                        hasVisibleSegment = false;
                    }
                }

                if (hasVisibleSegment) {
                    // Root color
                    if (root.color === 'warm') {
                        ctx.strokeStyle = 'rgba(90, 60, 40, 0.7)';
                    } else {
                        ctx.strokeStyle = 'rgba(70, 55, 45, 0.6)';
                    }
                    ctx.lineWidth = root.segments[0]?.thickness || 2;
                    ctx.lineCap = 'round';
                    ctx.stroke();
                }
            }

            // Draw fine root hairs at tips
            ctx.globalAlpha = 0.4;
            for (const root of rootTendrils) {
                if (root.segments.length < 3) continue;

                const tipSeg = root.segments[root.segments.length - 1];
                const screenX = tipSeg.x * W;
                const screenY = tipSeg.y * H;

                const gx = Math.floor(tipSeg.x * gridCols);
                const gy = Math.floor(tipSeg.y * gridRows);
                const inTunnel = soilGrid[gy]?.[gx] !== undefined && soilGrid[gy][gx] < 0.5;

                if (inTunnel) {
                    // Draw tiny root hairs
                    for (let h = 0; h < 4; h++) {
                        const hairAngle = Math.PI * 0.3 + Math.random() * Math.PI * 0.4;
                        const hairLen = 3 + Math.random() * 6;
                        ctx.beginPath();
                        ctx.moveTo(screenX, screenY);
                        ctx.lineTo(
                            screenX + Math.cos(hairAngle) * hairLen * (h % 2 === 0 ? 1 : -1),
                            screenY + Math.sin(hairAngle) * hairLen
                        );
                        ctx.strokeStyle = 'rgba(80, 50, 35, 0.5)';
                        ctx.lineWidth = 0.5;
                        ctx.stroke();
                    }
                }
            }

            ctx.restore();
        }

        // ============ DIGGING DUST PARTICLE SYSTEM ============
        const dustParticles = [];
        const MAX_DUST_PARTICLES = 100;

        class DustParticle {
            constructor(x, y, depth) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2 - 1; // Slight upward bias
                this.life = 1.0;
                this.decay = 0.02 + Math.random() * 0.02;
                this.size = 1 + Math.random() * 2;
                // Color based on soil depth
                const color = getSoilColor(depth);
                this.r = color[0];
                this.g = color[1];
                this.b = color[2];
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += 0.1; // Gravity
                this.vx *= 0.95; // Air resistance
                this.life -= this.decay;
                return this.life > 0;
            }

            draw(ctx) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * this.life, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(${this.r}, ${this.g}, ${this.b}, ${this.life * 0.7})`;
                ctx.fill();
            }
        }

        function spawnDustParticle(x, y, depth) {
            if (dustParticles.length >= MAX_DUST_PARTICLES) {
                dustParticles.shift(); // Remove oldest
            }
            dustParticles.push(new DustParticle(x, y, depth));
        }

        function updateAndDrawDust() {
            for (let i = dustParticles.length - 1; i >= 0; i--) {
                if (!dustParticles[i].update()) {
                    dustParticles.splice(i, 1);
                } else {
                    dustParticles[i].draw(ctx);
                }
            }
        }

        // ============ ANT DEATH SPIRIT SYSTEM ============
        const deadAntSpirits = [];
        const MAX_SPIRITS = 30;

        class DeadAntSpirit {
            constructor(x, y, role) {
                this.x = x;
                this.y = y;
                this.startY = y;
                this.life = 1.0;
                this.decay = 0.008; // ~2 seconds at 60fps
                this.role = role;
                this.driftX = (Math.random() - 0.5) * 0.3;
                this.wobble = Math.random() * Math.PI * 2;
            }

            update() {
                this.y -= 0.4; // Gentle upward drift
                this.x += this.driftX + Math.sin(this.wobble) * 0.15;
                this.wobble += 0.08;
                this.life -= this.decay;
                return this.life > 0;
            }

            draw(ctx) {
                const alpha = this.life * 0.6;

                // Outer glow - warm golden light
                const glowRadius = 12 * this.life + 4;
                const gradient = ctx.createRadialGradient(
                    this.x, this.y, 0,
                    this.x, this.y, glowRadius
                );
                gradient.addColorStop(0, `rgba(255, 240, 200, ${alpha * 0.5})`);
                gradient.addColorStop(0.5, `rgba(255, 200, 120, ${alpha * 0.2})`);
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.fillRect(this.x - glowRadius, this.y - glowRadius, glowRadius * 2, glowRadius * 2);

                // Faint ant shape rising
                ctx.save();
                ctx.globalAlpha = alpha * 0.7;
                ctx.translate(this.x, this.y);

                // Spirit body
                ctx.beginPath();
                ctx.ellipse(0, 0, 2.5 * this.life, 1.5 * this.life, 0, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 250, 230, 0.8)';
                ctx.fill();

                // Spirit head
                ctx.beginPath();
                ctx.ellipse(-3 * this.life, 0, 1.5 * this.life, 1 * this.life, 0, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }
        }

        function spawnDeadAntSpirit(x, y, role) {
            if (deadAntSpirits.length >= MAX_SPIRITS) {
                deadAntSpirits.shift(); // Remove oldest
            }
            deadAntSpirits.push(new DeadAntSpirit(x, y, role));
        }

        function updateAndDrawSpirits() {
            for (let i = deadAntSpirits.length - 1; i >= 0; i--) {
                if (!deadAntSpirits[i].update()) {
                    deadAntSpirits.splice(i, 1);
                } else {
                    deadAntSpirits[i].draw(ctx);
                }
            }
        }

        // ============ MILESTONE EVENTS SYSTEM ============
        const milestones = {
            firstExcavator: false,
            firstGatherer: false,
            firstNurse: false,
            population50: false,
            population100: false,
            population200: false,
            births25: false,
            births50: false,
            births100: false,
            firstExpansion: false,
            secondExpansion: false,
            elderAnt: false, // Ant survives to 90% of max age
            queenFed25: false,
            queenFed50: false,
            balanced: false, // All roles have at least 5 ants
            agePolyethism: false, // All three age stages working together
        };
        let milestoneToastTimeout = null;
        let peakPopulation = 0;

        function showMilestone(title, description) {
            const toast = document.getElementById('milestone-toast');
            toast.innerHTML = `<strong>${title}</strong><br><span style="font-size: 12px; opacity: 0.9;">${description}</span>`;
            toast.style.opacity = '1';

            if (milestoneToastTimeout) clearTimeout(milestoneToastTimeout);
            milestoneToastTimeout = setTimeout(() => {
                toast.style.opacity = '0';
            }, 4000);
        }

        function checkMilestones() {
            // Count roles
            let workers = 0, excavators = 0, gatherers = 0, nurses = 0;
            let hasElder = false;
            ants.forEach(ant => {
                switch(ant.role) {
                    case ANT_ROLES.WORKER: workers++; break;
                    case ANT_ROLES.EXCAVATOR: excavators++; break;
                    case ANT_ROLES.GATHERER: gatherers++; break;
                    case ANT_ROLES.NURSE: nurses++; break;
                }
                if (ant.getAgeRatio() >= 0.9) hasElder = true;
            });

            // Track peak population
            if (ants.length > peakPopulation) peakPopulation = ants.length;

            // First specialists
            if (!milestones.firstExcavator && excavators > 0) {
                milestones.firstExcavator = true;
                showMilestone('First Excavator!', 'A worker has specialized in digging');
            }
            if (!milestones.firstGatherer && gatherers > 0) {
                milestones.firstGatherer = true;
                showMilestone('First Gatherer!', 'A worker has specialized in food collection');
            }
            if (!milestones.firstNurse && nurses > 0) {
                milestones.firstNurse = true;
                showMilestone('First Nurse!', 'A worker has devoted itself to the queen');
            }

            // Population milestones
            if (!milestones.population50 && ants.length >= 50) {
                milestones.population50 = true;
                showMilestone('Growing Colony', '50 ants strong!');
            }
            if (!milestones.population100 && ants.length >= 100) {
                milestones.population100 = true;
                showMilestone('Thriving Colony', '100 ants in the colony!');
            }
            if (!milestones.population200 && ants.length >= 200) {
                milestones.population200 = true;
                showMilestone('Supercolony!', '200 ants working as one');
            }

            // Birth milestones
            if (!milestones.births25 && totalBirths >= 25) {
                milestones.births25 = true;
                showMilestone('25 Births', 'The queen has raised a generation');
            }
            if (!milestones.births50 && totalBirths >= 50) {
                milestones.births50 = true;
                showMilestone('50 Births', 'A prolific queen!');
            }
            if (!milestones.births100 && totalBirths >= 100) {
                milestones.births100 = true;
                showMilestone('100 Births', 'Dynasty established');
            }

            // Expansion milestones
            if (!milestones.firstExpansion && totalExpansions >= 1) {
                milestones.firstExpansion = true;
                showMilestone('World Expanded!', 'New territory unlocked');
            }
            if (!milestones.secondExpansion && totalExpansions >= 2) {
                milestones.secondExpansion = true;
                showMilestone('Deep Colony', 'The empire grows deeper');
            }

            // Elder ant
            if (!milestones.elderAnt && hasElder) {
                milestones.elderAnt = true;
                showMilestone('Elder Ant', 'One ant has lived to old age');
            }

            // Queen milestones
            if (!milestones.queenFed25 && queen && queen.foodReceived >= 25) {
                milestones.queenFed25 = true;
                showMilestone('Well-Fed Queen', '25 food deliveries');
            }
            if (!milestones.queenFed50 && queen && queen.foodReceived >= 50) {
                milestones.queenFed50 = true;
                showMilestone('Pampered Royalty', '50 food deliveries');
            }

            // Balanced colony
            if (!milestones.balanced && excavators >= 5 && gatherers >= 5 && nurses >= 5) {
                milestones.balanced = true;
                showMilestone('Balanced Society', 'All specialist roles represented');
            }

            // Age Polyethism - all three age stages working together
            if (!milestones.agePolyethism && ants.length >= 30) {
                let hasYoung = false, hasMature = false, hasElder = false;
                ants.forEach(ant => {
                    const stage = ant.getAgeStage();
                    if (stage === 'young') hasYoung = true;
                    if (stage === 'mature') hasMature = true;
                    if (stage === 'elder') hasElder = true;
                });
                if (hasYoung && hasMature && hasElder) {
                    milestones.agePolyethism = true;
                    showMilestone('Age Polyethism', 'Young, mature, and elder ants unite');
                }
            }
        }

        // ============ PROCEDURAL AMBIENT AUDIO SYSTEM ============
        let audioCtx = null;
        let audioEnabled = false;
        let audioNodes = {};

        function initAudio() {
            if (audioCtx) return;
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();

            // Master gain
            const masterGain = audioCtx.createGain();
            masterGain.gain.value = 0.15;
            masterGain.connect(audioCtx.destination);

            // Deep earth drone (fundamental)
            const droneOsc = audioCtx.createOscillator();
            droneOsc.type = 'sine';
            droneOsc.frequency.value = 55; // Low A

            const droneGain = audioCtx.createGain();
            droneGain.gain.value = 0.3;
            droneOsc.connect(droneGain);
            droneGain.connect(masterGain);
            droneOsc.start();

            // Harmonic layer 1 (fifth)
            const harmonic1 = audioCtx.createOscillator();
            harmonic1.type = 'sine';
            harmonic1.frequency.value = 82.5; // E

            const harmonic1Gain = audioCtx.createGain();
            harmonic1Gain.gain.value = 0.15;
            harmonic1.connect(harmonic1Gain);
            harmonic1Gain.connect(masterGain);
            harmonic1.start();

            // Harmonic layer 2 (octave)
            const harmonic2 = audioCtx.createOscillator();
            harmonic2.type = 'triangle';
            harmonic2.frequency.value = 110; // High A

            const harmonic2Gain = audioCtx.createGain();
            harmonic2Gain.gain.value = 0.08;
            harmonic2.connect(harmonic2Gain);
            harmonic2Gain.connect(masterGain);
            harmonic2.start();

            // Activity-modulated filtered noise (digging sounds)
            const noiseBuffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 2, audioCtx.sampleRate);
            const noiseData = noiseBuffer.getChannelData(0);
            for (let i = 0; i < noiseData.length; i++) {
                noiseData[i] = Math.random() * 2 - 1;
            }

            const noiseSource = audioCtx.createBufferSource();
            noiseSource.buffer = noiseBuffer;
            noiseSource.loop = true;

            const noiseFilter = audioCtx.createBiquadFilter();
            noiseFilter.type = 'bandpass';
            noiseFilter.frequency.value = 400;
            noiseFilter.Q.value = 2;

            const noiseGain = audioCtx.createGain();
            noiseGain.gain.value = 0;

            noiseSource.connect(noiseFilter);
            noiseFilter.connect(noiseGain);
            noiseGain.connect(masterGain);
            noiseSource.start();

            // Movement swoosh (filtered noise)
            const swooshFilter = audioCtx.createBiquadFilter();
            swooshFilter.type = 'lowpass';
            swooshFilter.frequency.value = 200;
            swooshFilter.Q.value = 1;

            const swooshGain = audioCtx.createGain();
            swooshGain.gain.value = 0;

            const swooshSource = audioCtx.createBufferSource();
            swooshSource.buffer = noiseBuffer;
            swooshSource.loop = true;
            swooshSource.connect(swooshFilter);
            swooshFilter.connect(swooshGain);
            swooshGain.connect(masterGain);
            swooshSource.start();

            // Store references
            audioNodes = {
                masterGain,
                droneOsc, droneGain,
                harmonic1, harmonic1Gain,
                harmonic2, harmonic2Gain,
                noiseGain, noiseFilter,
                swooshGain, swooshFilter
            };
        }

        function updateAudio() {
            if (!audioEnabled || !audioCtx || !audioNodes.masterGain) return;

            // Count activity metrics
            let diggingCount = 0;
            let movementSpeed = 0;
            let gatheringCount = 0;

            ants.forEach(ant => {
                if (ant.digging) diggingCount++;
                movementSpeed += ant.speed;
                if (ant.hasFood) gatheringCount++;
            });

            const antCount = ants.length || 1;
            const diggingRatio = diggingCount / antCount;
            const avgSpeed = movementSpeed / antCount;
            const gatheringRatio = gatheringCount / antCount;

            // Modulate digging noise
            const targetNoiseGain = diggingRatio * 0.15;
            audioNodes.noiseGain.gain.linearRampToValueAtTime(
                targetNoiseGain, audioCtx.currentTime + 0.1
            );
            audioNodes.noiseFilter.frequency.linearRampToValueAtTime(
                300 + diggingRatio * 600, audioCtx.currentTime + 0.1
            );

            // Modulate movement swoosh
            const targetSwooshGain = avgSpeed * 0.02;
            audioNodes.swooshGain.gain.linearRampToValueAtTime(
                targetSwooshGain, audioCtx.currentTime + 0.1
            );

            // Modulate drone pitch slightly based on colony depth
            const depthFactor = 1 + (worldScale - 1) * 0.02;
            audioNodes.droneOsc.frequency.linearRampToValueAtTime(
                55 * depthFactor, audioCtx.currentTime + 0.5
            );

            // Food gathering adds brightness
            audioNodes.harmonic2Gain.gain.linearRampToValueAtTime(
                0.08 + gatheringRatio * 0.1, audioCtx.currentTime + 0.2
            );
        }

        function toggleAudio() {
            if (!audioCtx) {
                initAudio();
            }

            audioEnabled = !audioEnabled;

            if (audioEnabled) {
                audioCtx.resume();
                document.getElementById('sound-btn').textContent = 'Sound On';
                document.getElementById('sound-btn').style.background = 'rgba(100,80,140,0.5)';
            } else {
                audioNodes.masterGain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.3);
                setTimeout(() => {
                    if (!audioEnabled) audioCtx.suspend();
                }, 400);
                document.getElementById('sound-btn').textContent = 'Sound Off';
                document.getElementById('sound-btn').style.background = 'rgba(80,60,100,0.4)';
            }

            // Restore master gain when re-enabling
            if (audioEnabled) {
                audioNodes.masterGain.gain.linearRampToValueAtTime(0.15, audioCtx.currentTime + 0.3);
            }
        }

        // ============ GENETIC MEMORY SYSTEM ============
        // Colony learns across generations - successful behaviors are inherited
        const colonyMemory = {
            // Track which roles have been most successful
            roleSuccess: {
                excavator: { totalLifespan: 0, count: 0 },
                gatherer: { totalLifespan: 0, count: 0 },
                nurse: { totalLifespan: 0, count: 0 }
            },
            // Danger zones where many ants died young
            dangerZones: new Map(),
            // Preferred depth for foraging (learned over time)
            bestForagingDepth: 0.5,
            // Generation counter
            generation: 0,
            // Total successful food deliveries (used for learning)
            successfulDeliveries: 0
        };

        function getMostSuccessfulRole() {
            const roles = colonyMemory.roleSuccess;
            let bestRole = null;
            let bestAvgLife = 0;

            for (const [role, data] of Object.entries(roles)) {
                if (data.count > 5) { // Need at least 5 samples
                    const avgLife = data.totalLifespan / data.count;
                    if (avgLife > bestAvgLife) {
                        bestAvgLife = avgLife;
                        bestRole = role;
                    }
                }
            }
            return bestRole;
        }

        function recordAntDeath(ant) {
            // Record role success (longer-lived ants = more successful)
            if (ant.role !== ANT_ROLES.WORKER) {
                const roleKey = ant.role.toLowerCase();
                if (colonyMemory.roleSuccess[roleKey]) {
                    colonyMemory.roleSuccess[roleKey].totalLifespan += ant.age;
                    colonyMemory.roleSuccess[roleKey].count++;
                }
            }

            // If ant died young (<50% lifespan), mark danger zone AND deposit alarm pheromones
            if (ant.getAgeRatio() < 0.5) {
                const g = ant.screenToGrid(ant.x, ant.y);
                const key = `${g.x},${g.y}`;
                colonyMemory.dangerZones.set(key, (colonyMemory.dangerZones.get(key) || 0) + 1);

                // Deposit alarm pheromones - stronger for younger deaths
                const alarmStrength = 0.8 * (1 - ant.getAgeRatio() * 2);
                if (alarmPheromoneGrid[g.y]) {
                    alarmPheromoneGrid[g.y][g.x] = Math.min(1,
                        (alarmPheromoneGrid[g.y][g.x] || 0) + alarmStrength);

                    // Spread alarm to neighboring cells
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            const ny = g.y + dy, nx = g.x + dx;
                            if (alarmPheromoneGrid[ny]) {
                                alarmPheromoneGrid[ny][nx] = Math.min(1,
                                    (alarmPheromoneGrid[ny][nx] || 0) + alarmStrength * 0.3);
                            }
                        }
                    }
                }

                // Clean up old danger zones if too many
                if (colonyMemory.dangerZones.size > 100) {
                    const entries = [...colonyMemory.dangerZones.entries()];
                    entries.sort((a, b) => a[1] - b[1]);
                    for (let i = 0; i < 20; i++) {
                        colonyMemory.dangerZones.delete(entries[i][0]);
                    }
                }
            }

            // Update best foraging depth based on successful ant positions
            if (ant.gatherExperience > 20) {
                const normalizedY = ant.y / H;
                colonyMemory.bestForagingDepth = colonyMemory.bestForagingDepth * 0.95 + normalizedY * 0.05;
            }
        }

        function applyGeneticMemory(ant) {
            // Apply inherited biases to new ant
            const bestRole = getMostSuccessfulRole();

            // Give slight XP boost toward successful role (10-20 points)
            if (bestRole && Math.random() < 0.7) { // 70% chance to inherit
                const inheritedXP = 10 + Math.random() * 15;
                switch(bestRole) {
                    case 'excavator': ant.digExperience = inheritedXP; break;
                    case 'gatherer': ant.gatherExperience = inheritedXP; break;
                    case 'nurse': ant.nurseExperience = inheritedXP; break;
                }
            }

            // Store preferred foraging depth for ant to use
            ant.inheritedForagingDepth = colonyMemory.bestForagingDepth;

            colonyMemory.generation++;
        }

        // ============ ANT MORTALITY SYSTEM ============
        const BASE_LIFESPAN = 6000;     // Base lifespan in update cycles (~100 seconds at 60fps)
        const LIFESPAN_VARIANCE = 2000; // Random variance (so 67-133 seconds lifespan)
        let totalDeaths = 0;

        class Ant {
            constructor() {
                this.x = W / 2 + (Math.random() - 0.5) * 20;
                this.y = H * 0.2;
                this.angle = Math.random() * Math.PI * 2;
                this.speed = 2 + Math.random() * 1; // Faster ants (2-3 speed)
                this.hasFood = false;
                this.digging = false;
                this.wanderPhase = Math.random() * Math.PI * 2;

                // Role specialization
                this.role = ANT_ROLES.WORKER;
                this.digExperience = 0;
                this.gatherExperience = 0;
                this.nurseExperience = 0;

                // Genetic memory - inherited from colony
                this.inheritedForagingDepth = 0.5;

                // Task recruitment system - ant-to-ant communication
                this.recruitmentBias = null; // {angle: number, strength: number}
                this.recruitmentDecay = 0;   // Frames until bias fades

                // Mortality system
                this.age = 0;
                this.maxAge = BASE_LIFESPAN + Math.random() * LIFESPAN_VARIANCE;
                this.isAlive = true;
            }

            // Age the ant and check for death
            updateAge() {
                this.age++;

                // Nurses near queen live longer (care extends life)
                if (this.role === ANT_ROLES.NURSE && queen) {
                    const distToQueen = Math.hypot(queen.x - this.x, queen.y - this.y);
                    if (distToQueen < 40) {
                        this.maxAge += 0.1; // Slow aging when near queen
                    }
                }

                // Weather affects elder ant survival
                if (this.getAgeStage() === 'elder') {
                    const weatherDeathRisk = weather.getDeathRiskMultiplier();
                    if (weatherDeathRisk > 1 && Math.random() < 0.0005 * weatherDeathRisk) {
                        this.isAlive = false;
                        totalDeaths++;
                        return;
                    }
                }

                // Check for natural death
                if (this.age >= this.maxAge) {
                    this.isAlive = false;
                    totalDeaths++;
                }

                // Older ants slow down slightly
                if (this.age > this.maxAge * 0.8) {
                    this.speed *= 0.995; // Gradual slowdown
                }
            }

            getAgeRatio() {
                return this.age / this.maxAge;
            }

            // Age Polyethism - task division based on life stage
            getAgeStage() {
                const ratio = this.getAgeRatio();
                if (ratio < 0.3) return 'young';
                if (ratio < 0.7) return 'mature';
                return 'elder';
            }

            // Check for role specialization based on experience
            updateRole() {
                if (this.role !== ANT_ROLES.WORKER) return; // Already specialized

                const maxExp = Math.max(this.digExperience, this.gatherExperience, this.nurseExperience);
                if (maxExp >= ROLE_THRESHOLD) {
                    if (this.digExperience === maxExp) {
                        this.role = ANT_ROLES.EXCAVATOR;
                        this.speed *= 0.8; // Slower but stronger digger
                    } else if (this.gatherExperience === maxExp) {
                        this.role = ANT_ROLES.GATHERER;
                        this.speed *= 1.2; // Faster for food runs
                    } else if (this.nurseExperience === maxExp) {
                        this.role = ANT_ROLES.NURSE;
                    }
                }
            }
            
            // Helper to convert screen coords to grid coords
            screenToGrid(sx, sy) {
                const cols = soilGrid[0]?.length || 1;
                const rows = soilGrid.length || 1;
                return {
                    x: Math.floor(sx / W * cols),
                    y: Math.floor(sy / H * rows)
                };
            }

            update() {
                this.wanderPhase += 0.1;

                const cols = soilGrid[0]?.length || 1;
                const rows = soilGrid.length || 1;

                // Weather effects on movement speed
                const weatherSpeedMod = weather.getSpeedModifier();

                // Check if ant is in flooded area - push toward surface
                if (weather.isFlooded(this.y)) {
                    // Ant is struggling in water, push upward
                    this.y -= 2;
                    this.angle = -Math.PI / 2 + (Math.random() - 0.5) * 0.5; // Point upward
                    // Small chance of drowning
                    if (Math.random() < 0.001) {
                        this.isAlive = false;
                        totalDeaths++;
                    }
                    return; // Skip normal behavior when flooded
                }

                // Cold weather: ants cluster near queen for warmth
                if (weather.state === 'COLD' && queen && !this.hasFood) {
                    const distToQueen = Math.hypot(queen.x - this.x, queen.y - this.y);
                    if (distToQueen > 60) {
                        const toQueen = Math.atan2(queen.y - this.y, queen.x - this.x);
                        this.angle = this.angle * 0.9 + toQueen * 0.1;
                    }
                }

                // Age Polyethism - behavioral biases based on life stage
                const ageStage = this.getAgeStage();

                // Young ants (0-30%): Stay near queen, gain nurse experience faster
                if (ageStage === 'young' && this.role === ANT_ROLES.WORKER && !this.hasFood && queen) {
                    const distToQueen = Math.hypot(queen.x - this.x, queen.y - this.y);
                    if (distToQueen > 50) {
                        // Young ants naturally gravitate toward queen
                        const toQueen = Math.atan2(queen.y - this.y, queen.x - this.x);
                        this.angle = this.angle * 0.95 + toQueen * 0.05;
                    }
                    this.nurseExperience += 0.08; // Faster nurse XP for young
                }

                // Elder ants (70-100%): Venture farther, gain gatherer experience faster
                if (ageStage === 'elder') {
                    this.gatherExperience += 0.05; // Faster gatherer XP for elders
                    // Elders move slightly faster - urgency of remaining time
                    if (this.speed < 1.5) this.speed *= 1.002;
                }

                // Nurse behavior: stay near queen
                if (this.role === ANT_ROLES.NURSE && queen && !this.hasFood) {
                    const distToQueen = Math.hypot(queen.x - this.x, queen.y - this.y);
                    if (distToQueen > 40) {
                        // Return to queen
                        const toQueen = Math.atan2(queen.y - this.y, queen.x - this.x);
                        this.angle = this.angle * 0.8 + toQueen * 0.2;
                    } else {
                        // Circle around queen
                        this.angle += 0.03;
                        this.nurseExperience += 0.1;
                    }
                }

                if (this.hasFood) {
                    // Head toward queen if she exists, otherwise nest center
                    const targetX = queen ? queen.x : W / 2;
                    const targetY = queen ? queen.y : H * 0.2;
                    const toNest = Math.atan2(targetY - this.y, targetX - this.x);
                    this.angle = this.angle * 0.9 + toNest * 0.1;

                    const dist = Math.hypot(targetX - this.x, targetY - this.y);
                    if (dist < 20) {
                        this.hasFood = false;
                        // Feed the queen!
                        if (queen) {
                            queen.feedQueen();
                        }
                        // Gain gatherer experience for successful delivery
                        this.gatherExperience += 5;
                    }

                    const g = this.screenToGrid(this.x, this.y);
                    if (g.x >= 0 && g.x < cols && g.y >= 0 && g.y < rows && pheromoneGrid[g.y]) {
                        pheromoneGrid[g.y][g.x] = Math.min(1, (pheromoneGrid[g.y][g.x] || 0) + 0.1);
                    }

                    // Task Recruitment - recruit nearby idle ants using spatial grid (O(1) instead of O(N))
                    if (Math.random() < 0.02) { // Check occasionally, not every frame
                        const nearbyAnts = antSpatialGrid.getNearby(this.x, this.y, 25);
                        for (const other of nearbyAnts) {
                            if (other === this || other.hasFood || other.digging) continue;
                            if (Math.random() < 0.4) {
                                // Calculate opposite direction (toward where food came from)
                                const recruitAngle = this.angle + Math.PI;
                                other.recruitmentBias = { angle: recruitAngle, strength: 0.25 };
                                other.recruitmentDecay = 45; // ~0.75 seconds
                                // Visual feedback stored for drawing
                                this.lastRecruitedAnt = other;
                                this.recruitFlashTime = 8;
                                break; // Only recruit one ant per check
                            }
                        }
                    }
                } else {
                    // Apply recruitment bias if active
                    if (this.recruitmentDecay > 0 && this.recruitmentBias) {
                        this.angle = this.angle * (1 - this.recruitmentBias.strength) +
                                     this.recruitmentBias.angle * this.recruitmentBias.strength;
                        this.recruitmentDecay--;
                        this.recruitmentBias.strength *= 0.97; // Fade influence
                    }

                    // FOOD SCENT DETECTION - ants can smell food from far away!
                    let closestFood = null;
                    let closestFoodDist = 300; // Detection range
                    for (const food of foodSources) {
                        if (food.amount <= 0) continue;
                        const dist = Math.hypot(food.x - this.x, food.y - this.y);
                        if (dist < closestFoodDist) {
                            closestFoodDist = dist;
                            closestFood = food;
                        }
                    }

                    // If food detected, move toward it
                    if (closestFood) {
                        const toFood = Math.atan2(closestFood.y - this.y, closestFood.x - this.x);
                        // Stronger attraction when closer
                        const strength = 0.1 + (1 - closestFoodDist / 300) * 0.3;
                        this.angle = this.angle * (1 - strength) + toFood * strength;
                    } else {
                        // No food detected - explore toward surface (upward bias)
                        // This helps ants find food on the surface
                        if (Math.random() < 0.05) {
                            this.angle += (Math.random() < 0.6 ? -0.3 : 0.3); // Bias upward (-Y)
                        }
                    }

                    let bestPheromone = 0;
                    let bestAngle = this.angle;

                    // Role-based pheromone sensitivity weights
                    // Gatherers prefer food trails, Excavators prefer exploration trails
                    let foodWeight, explorationWeight;
                    switch(this.role) {
                        case ANT_ROLES.GATHERER:
                            foodWeight = 1.5; explorationWeight = 0.3;
                            break;
                        case ANT_ROLES.EXCAVATOR:
                            foodWeight = 0.3; explorationWeight = 1.5;
                            break;
                        case ANT_ROLES.NURSE:
                            foodWeight = 1.0; explorationWeight = 0.2; // Nurses mostly follow food to queen
                            break;
                        default: // WORKER
                            foodWeight = 1.0; explorationWeight = 0.8;
                    }

                    for (let i = 0; i < 5; i++) {
                        const testAngle = this.angle + (i - 2) * 0.4;
                        const testX = this.x + Math.cos(testAngle) * 10;
                        const testY = this.y + Math.sin(testAngle) * 10;
                        const g = this.screenToGrid(testX, testY);

                        if (g.x >= 0 && g.x < cols && g.y >= 0 && g.y < rows && pheromoneGrid[g.y]) {
                            const foodPheromone = (pheromoneGrid[g.y][g.x] || 0) * foodWeight;
                            const explorePheromone = (explorationPheromoneGrid[g.y]?.[g.x] || 0) * explorationWeight;
                            // Alarm pheromones repel ants (negative weight)
                            const alarmPheromone = (alarmPheromoneGrid[g.y]?.[g.x] || 0) * 2.0;
                            const combinedPheromone = foodPheromone + explorePheromone - alarmPheromone;
                            if (combinedPheromone > bestPheromone) {
                                bestPheromone = combinedPheromone;
                                bestAngle = testAngle;
                            }
                        }
                    }

                    if (bestPheromone > 0.1) {
                        this.angle = this.angle * 0.7 + bestAngle * 0.3;
                        // Gatherers gain experience from following trails
                        if (this.role === ANT_ROLES.WORKER) {
                            this.gatherExperience += 0.1;
                        }
                    } else {
                        this.angle += Math.sin(this.wanderPhase) * 0.3;
                    }

                    for (const food of foodSources) {
                        const dist = Math.hypot(food.x - this.x, food.y - this.y);
                        // Gatherers have better food detection range
                        const range = this.role === ANT_ROLES.GATHERER ? 25 : 15;
                        if (dist < range && food.amount > 0) {
                            this.hasFood = true;
                            food.amount -= 1;
                            this.gatherExperience += 2;
                            break;
                        }
                    }
                }

                // Apply weather modifier to movement speed
                const effectiveSpeed = this.speed * weatherSpeedMod;
                const nextX = this.x + Math.cos(this.angle) * effectiveSpeed;
                const nextY = this.y + Math.sin(this.angle) * effectiveSpeed;
                const g = this.screenToGrid(nextX, nextY);

                if (g.x >= 0 && g.x < cols && g.y >= 0 && g.y < rows && soilGrid[g.y]) {
                    if (soilGrid[g.y][g.x] > 0) {
                        this.digging = true;
                        // Excavators dig faster, weather slows digging
                        const digMultiplier = this.role === ANT_ROLES.EXCAVATOR ? 2.0 : 1.0;
                        const prevSoil = soilGrid[g.y][g.x];
                        soilGrid[g.y][g.x] -= 0.02 * digSpeed * digMultiplier * weatherSpeedMod;
                        if (soilGrid[g.y][g.x] <= 0) {
                            soilGrid[g.y][g.x] = 0;
                        }
                        // Mark AO cache dirty if cell changed significantly
                        if (prevSoil > 0.5 && soilGrid[g.y][g.x] <= 0.5) {
                            markAODirty(g.x, g.y);
                        }
                        // Spawn dust particles when digging
                        if (Math.random() < 0.15) { // 15% chance per dig frame
                            const depth = g.y / (soilGrid.length || 1);
                            spawnDustParticle(this.x, this.y, depth);
                        }
                        // Deposit exploration pheromones while digging
                        // Excavators leave stronger exploration trails
                        const explorationStrength = this.role === ANT_ROLES.EXCAVATOR ? 0.15 : 0.05;
                        if (explorationPheromoneGrid[g.y]) {
                            explorationPheromoneGrid[g.y][g.x] = Math.min(1,
                                (explorationPheromoneGrid[g.y][g.x] || 0) + explorationStrength);
                        }
                        // Gain digging experience
                        this.digExperience += 0.5 * digMultiplier;
                        this.speed = 0.3;
                    } else {
                        this.digging = false;
                        // Base speed varies by role
                        const baseSpeed = this.role === ANT_ROLES.GATHERER ? 1.3 :
                                         this.role === ANT_ROLES.EXCAVATOR ? 0.9 : 1.0;
                        this.speed = baseSpeed + Math.random() * 0.5;
                        this.x = nextX;
                        this.y = nextY;
                    }
                }

                // Track time near queen for nurse experience
                if (queen && !this.hasFood) {
                    const distToQueen = Math.hypot(queen.x - this.x, queen.y - this.y);
                    if (distToQueen < 30) {
                        this.nurseExperience += 0.2;
                    }
                }

                if (this.x < 10 || this.x > W - 10) this.angle = Math.PI - this.angle;
                if (this.y < 10 || this.y > H - 10) this.angle = -this.angle;

                this.x = Math.max(10, Math.min(W - 10, this.x));
                this.y = Math.max(10, Math.min(H - 10, this.y));

                // Check for role specialization
                this.updateRole();

                // Age the ant
                this.updateAge();
            }
            
            getRoleColor() {
                // Color coding by role
                switch(this.role) {
                    case ANT_ROLES.EXCAVATOR: return '#5a3a2a'; // Dark brown
                    case ANT_ROLES.GATHERER: return '#4a6a3a';  // Green tint
                    case ANT_ROLES.NURSE: return '#6a5a4a';     // Warm brown
                    default: return '#3a2a1a';                   // Default dark
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);

                // Aging affects color - older ants become grayer
                const ageRatio = this.getAgeRatio();
                let baseColor = this.hasFood ? '#d4a054' : this.getRoleColor();

                // Fade to gray as ant ages (after 60% of lifespan)
                if (ageRatio > 0.6) {
                    const fadeFactor = (ageRatio - 0.6) / 0.4; // 0 to 1
                    const grayValue = Math.floor(60 + fadeFactor * 30);
                    baseColor = `rgb(${grayValue + 20}, ${grayValue + 10}, ${grayValue})`;
                }

                const size = this.role === ANT_ROLES.EXCAVATOR ? 1.2 : 1.0; // Excavators slightly bigger

                // Abdomen
                ctx.beginPath();
                ctx.ellipse(0, 0, 3 * size, 2 * size, 0, 0, Math.PI * 2);
                ctx.fillStyle = baseColor;
                ctx.fill();

                // Role indicator stripe
                if (this.role !== ANT_ROLES.WORKER) {
                    ctx.beginPath();
                    ctx.ellipse(0, 0, 2 * size, 1.2 * size, 0, 0, Math.PI * 2);
                    let stripeColor;
                    switch(this.role) {
                        case ANT_ROLES.EXCAVATOR: stripeColor = 'rgba(100, 60, 40, 0.5)'; break;
                        case ANT_ROLES.GATHERER: stripeColor = 'rgba(80, 140, 60, 0.5)'; break;
                        case ANT_ROLES.NURSE: stripeColor = 'rgba(180, 140, 100, 0.5)'; break;
                    }
                    ctx.fillStyle = stripeColor;
                    ctx.fill();
                }

                // Head
                ctx.beginPath();
                ctx.ellipse(-4 * size, 0, 2 * size, 1.5 * size, 0, 0, Math.PI * 2);
                ctx.fillStyle = baseColor;
                ctx.fill();

                // Mandibles for excavators
                if (this.role === ANT_ROLES.EXCAVATOR) {
                    ctx.beginPath();
                    ctx.moveTo(-5 * size, -1);
                    ctx.lineTo(-7 * size, -2);
                    ctx.lineTo(-6 * size, 0);
                    ctx.moveTo(-5 * size, 1);
                    ctx.lineTo(-7 * size, 2);
                    ctx.lineTo(-6 * size, 0);
                    ctx.strokeStyle = '#4a3020';
                    ctx.lineWidth = 0.8;
                    ctx.stroke();
                }

                // Antennae
                ctx.beginPath();
                ctx.moveTo(-5, -1);
                ctx.lineTo(-8, -3);
                ctx.moveTo(-5, 1);
                ctx.lineTo(-8, 3);
                ctx.strokeStyle = baseColor;
                ctx.lineWidth = 0.5;
                ctx.stroke();

                ctx.restore();

                // Draw recruitment line to recently recruited ant
                if (this.recruitFlashTime > 0 && this.lastRecruitedAnt) {
                    ctx.save();
                    ctx.globalAlpha = this.recruitFlashTime / 8;
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(this.lastRecruitedAnt.x, this.lastRecruitedAnt.y);
                    ctx.strokeStyle = 'rgba(255, 200, 100, 0.6)';
                    ctx.lineWidth = 1.5;
                    ctx.stroke();

                    // Small spark at recruited ant
                    ctx.beginPath();
                    ctx.arc(this.lastRecruitedAnt.x, this.lastRecruitedAnt.y, 4, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 220, 120, 0.5)';
                    ctx.fill();
                    ctx.restore();

                    this.recruitFlashTime--;
                }
            }
        }
        
        function getSoilColor(depth) {
            for (let i = 1; i < SOIL_COLORS.length; i++) {
                if (depth <= SOIL_COLORS[i].depth) {
                    const t = (depth - SOIL_COLORS[i-1].depth) / (SOIL_COLORS[i].depth - SOIL_COLORS[i-1].depth);
                    const c1 = SOIL_COLORS[i-1].color;
                    const c2 = SOIL_COLORS[i].color;
                    return [
                        c1[0] + (c2[0] - c1[0]) * t,
                        c1[1] + (c2[1] - c1[1]) * t,
                        c1[2] + (c2[2] - c1[2]) * t
                    ];
                }
            }
            return SOIL_COLORS[SOIL_COLORS.length - 1].color;
        }
        
        // ============ CACHED AMBIENT OCCLUSION SYSTEM ============
        let aoCache = [];           // Cached AO values
        let aoDirtyRegions = [];    // Regions that need recalculation

        function initAOCache() {
            const rows = soilGrid.length;
            const cols = soilGrid[0]?.length || 0;
            aoCache = [];
            for (let y = 0; y < rows; y++) {
                aoCache[y] = [];
                for (let x = 0; x < cols; x++) {
                    aoCache[y][x] = 0;
                }
            }
            // Mark entire grid for initial calculation
            aoDirtyRegions = [[0, 0, cols - 1, rows - 1]];
        }

        function markAODirty(x, y) {
            // Mark a 5x5 region around the changed cell
            const cols = soilGrid[0]?.length || 0;
            const rows = soilGrid.length;
            const minX = Math.max(0, x - 3);
            const maxX = Math.min(cols - 1, x + 3);
            const minY = Math.max(0, y - 3);
            const maxY = Math.min(rows - 1, y + 3);
            aoDirtyRegions.push([minX, minY, maxX, maxY]);
        }

        function calculateAO(x, y, gridCols, gridRows) {
            if (!soilGrid[y] || soilGrid[y][x] <= 0) return 0;

            let tunnelNeighbors = 0;
            let totalChecked = 0;

            for (let dy = -2; dy <= 2; dy++) {
                for (let dx = -2; dx <= 2; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    const nx = x + dx;
                    const ny = y + dy;
                    if (nx >= 0 && nx < gridCols && ny >= 0 && ny < gridRows) {
                        totalChecked++;
                        if (soilGrid[ny] && soilGrid[ny][nx] < 0.5) {
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            tunnelNeighbors += (3 - dist) / 3;
                        }
                    }
                }
            }
            return totalChecked > 0 ? Math.min(1, tunnelNeighbors / 4) : 0;
        }

        function updateAOCache() {
            if (aoDirtyRegions.length === 0) return;

            const cols = soilGrid[0]?.length || 0;
            const rows = soilGrid.length;

            // Process all dirty regions
            for (const [minX, minY, maxX, maxY] of aoDirtyRegions) {
                for (let y = minY; y <= maxY && y < rows; y++) {
                    for (let x = minX; x <= maxX && x < cols; x++) {
                        if (!aoCache[y]) aoCache[y] = [];
                        aoCache[y][x] = calculateAO(x, y, cols, rows);
                    }
                }
            }
            aoDirtyRegions = []; // Clear after processing
        }

        // Fast cached lookup
        function getAmbientOcclusion(x, y) {
            return aoCache[y]?.[x] || 0;
        }

        function drawSoil() {
            const gridRows = soilGrid.length;
            const gridCols = soilGrid[0]?.length || 0;

            // Update AO cache for any dirty regions
            updateAOCache();

            // Calculate pixel size of each grid cell on screen
            const cellPixelWidth = W / gridCols;
            const cellPixelHeight = H / gridRows;

            const imageData = ctx.createImageData(W, H);

            for (let y = 0; y < gridRows; y++) {
                for (let x = 0; x < gridCols; x++) {
                    const soil = soilGrid[y] ? soilGrid[y][x] || 0 : 0;
                    const pheromone = pheromoneGrid[y] ? pheromoneGrid[y][x] || 0 : 0;

                    let r, g, b;
                    if (soil > 0) {
                        const depth = y / gridRows;
                        const color = getSoilColor(depth);

                        // Use cached ambient occlusion (much faster!)
                        const occlusion = getAmbientOcclusion(x, y);
                        const shadowFactor = 1 - (occlusion * 0.4); // Darken by up to 40%

                        r = color[0] * soil * shadowFactor;
                        g = color[1] * soil * shadowFactor;
                        b = color[2] * soil * shadowFactor;
                    } else {
                        // Tunnel interior - subtle gradient based on depth
                        const tunnelDepth = y / gridRows;
                        const depthDarken = 0.7 + tunnelDepth * 0.3; // Darker at bottom

                        r = (15 + pheromone * 30) * depthDarken;
                        g = (12 + pheromone * 20) * depthDarken;
                        b = (10 + pheromone * 10) * depthDarken;

                        // Add subtle highlight on "ceiling" of tunnels
                        if (y > 0 && soilGrid[y-1] && soilGrid[y-1][x] > 0.5) {
                            // This is just below solid soil - add highlight
                            r = Math.min(255, r + 8);
                            g = Math.min(255, g + 6);
                            b = Math.min(255, b + 4);
                        }
                    }

                    // Calculate screen pixel bounds for this grid cell
                    const startX = Math.floor(x * cellPixelWidth);
                    const endX = Math.floor((x + 1) * cellPixelWidth);
                    const startY = Math.floor(y * cellPixelHeight);
                    const endY = Math.floor((y + 1) * cellPixelHeight);

                    for (let py = startY; py < endY && py < H; py++) {
                        for (let px = startX; px < endX && px < W; px++) {
                            const i = (py * W + px) * 4;
                            imageData.data[i] = r;
                            imageData.data[i + 1] = g;
                            imageData.data[i + 2] = b;
                            imageData.data[i + 3] = 255;
                        }
                    }
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }
        
        function drawSky() {
            const skyColor = weather.getSkyColor();
            const gradient = ctx.createLinearGradient(0, 0, 0, H * 0.15);
            // Blend weather color with base sky
            const topR = Math.round(skyColor[0] * 0.6);
            const topG = Math.round(skyColor[1] * 0.6);
            const topB = Math.round(skyColor[2] * 0.7);
            gradient.addColorStop(0, `rgb(${topR}, ${topG}, ${topB})`);
            gradient.addColorStop(1, `rgb(${skyColor[0]}, ${skyColor[1]}, ${skyColor[2]})`);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, W, H * 0.15);

            // Cloud overlay during rain/storm
            if (weather.state === 'RAIN' || weather.state === 'STORM' || weather.state === 'COLD') {
                ctx.globalAlpha = weather.state === 'STORM' ? 0.4 : 0.25;
                for (let i = 0; i < 5; i++) {
                    const cloudX = (W * (0.15 + i * 0.2) + time * 5) % (W + 100) - 50;
                    const cloudY = H * 0.05 + Math.sin(i * 1.5) * 10;
                    ctx.beginPath();
                    ctx.arc(cloudX, cloudY, 30 + i * 5, 0, Math.PI * 2);
                    ctx.arc(cloudX + 25, cloudY - 5, 25, 0, Math.PI * 2);
                    ctx.arc(cloudX + 50, cloudY, 28, 0, Math.PI * 2);
                    ctx.fillStyle = weather.state === 'STORM' ? '#3a4050' : '#607080';
                    ctx.fill();
                }
                ctx.globalAlpha = 1;
            }
        }

        // ============ SURFACE LIGHT SHAFTS ============
        function drawLightShafts() {
            // Light shafts are dimmer in bad weather
            const weatherIntensity = {
                CLEAR: 1.0, RAIN: 0.4, DROUGHT: 1.2, COLD: 0.6, STORM: 0.15
            };
            const intensity = weatherIntensity[weather.state] || 1.0;
            if (intensity < 0.1) return; // Skip in heavy storms

            const surfaceY = H * 0.15;
            const shaftCount = 3;

            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            ctx.globalAlpha = 0.12 * intensity;

            for (let i = 0; i < shaftCount; i++) {
                const shaftX = W * (0.25 + i * 0.25);
                const shaftWidth = 25 + Math.sin(time * 0.3 + i * 2) * 8;
                const shaftLength = H * 0.4;
                const angle = -0.12 + i * 0.06;

                ctx.save();
                ctx.translate(shaftX, surfaceY);
                ctx.rotate(angle);

                const gradient = ctx.createLinearGradient(0, 0, 0, shaftLength);
                gradient.addColorStop(0, 'rgba(255, 250, 210, 0.5)');
                gradient.addColorStop(0.2, 'rgba(255, 240, 190, 0.3)');
                gradient.addColorStop(0.6, 'rgba(255, 230, 170, 0.1)');
                gradient.addColorStop(1, 'transparent');

                ctx.fillStyle = gradient;
                ctx.fillRect(-shaftWidth / 2, 0, shaftWidth, shaftLength);

                ctx.restore();
            }

            ctx.restore();
        }

        // ============ VISIBLE PHEROMONE TRAIL SYSTEM ============
        function drawPheromoneTrails() {
            const gridRows = pheromoneGrid.length;
            const gridCols = pheromoneGrid[0]?.length || 0;
            if (gridRows === 0 || gridCols === 0) return;

            const cellPixelWidth = W / gridCols;
            const cellPixelHeight = H / gridRows;

            ctx.save();
            ctx.globalCompositeOperation = 'lighter'; // Additive blending for glow

            for (let y = 0; y < gridRows; y++) {
                for (let x = 0; x < gridCols; x++) {
                    // Only draw in tunnels (excavated areas)
                    if (soilGrid[y]?.[x] > 0.3) continue;

                    const centerX = (x + 0.5) * cellPixelWidth;
                    const centerY = (y + 0.5) * cellPixelHeight;

                    // Draw food pheromone trails (amber)
                    const foodPheromone = pheromoneGrid[y]?.[x] || 0;
                    if (foodPheromone >= 0.05) {
                        const intensity = Math.min(1, foodPheromone * 1.5);
                        const radius = cellPixelWidth * (0.8 + foodPheromone * 0.5);

                        const gradient = ctx.createRadialGradient(
                            centerX, centerY, 0,
                            centerX, centerY, radius
                        );
                        gradient.addColorStop(0, `rgba(255, 180, 80, ${intensity * 0.4})`);
                        gradient.addColorStop(0.5, `rgba(255, 140, 40, ${intensity * 0.2})`);
                        gradient.addColorStop(1, 'transparent');

                        ctx.fillStyle = gradient;
                        ctx.fillRect(centerX - radius, centerY - radius, radius * 2, radius * 2);
                    }

                    // Draw exploration pheromone trails (cool blue)
                    const explorePheromone = explorationPheromoneGrid[y]?.[x] || 0;
                    if (explorePheromone >= 0.05) {
                        const intensity = Math.min(1, explorePheromone * 1.5);
                        const radius = cellPixelWidth * (0.6 + explorePheromone * 0.4);

                        const gradient = ctx.createRadialGradient(
                            centerX, centerY, 0,
                            centerX, centerY, radius
                        );
                        gradient.addColorStop(0, `rgba(100, 180, 255, ${intensity * 0.35})`);
                        gradient.addColorStop(0.5, `rgba(60, 120, 200, ${intensity * 0.15})`);
                        gradient.addColorStop(1, 'transparent');

                        ctx.fillStyle = gradient;
                        ctx.fillRect(centerX - radius, centerY - radius, radius * 2, radius * 2);
                    }

                    // Draw alarm pheromone zones (danger red)
                    const alarmPheromone = alarmPheromoneGrid[y]?.[x] || 0;
                    if (alarmPheromone >= 0.05) {
                        const intensity = Math.min(1, alarmPheromone * 1.2);
                        const radius = cellPixelWidth * (0.7 + alarmPheromone * 0.5);

                        const gradient = ctx.createRadialGradient(
                            centerX, centerY, 0,
                            centerX, centerY, radius
                        );
                        gradient.addColorStop(0, `rgba(255, 80, 60, ${intensity * 0.4})`);
                        gradient.addColorStop(0.5, `rgba(200, 40, 30, ${intensity * 0.2})`);
                        gradient.addColorStop(1, 'transparent');

                        ctx.fillStyle = gradient;
                        ctx.fillRect(centerX - radius, centerY - radius, radius * 2, radius * 2);
                    }
                }
            }

            ctx.restore();
        }
        
        function drawFoodSources() {
            for (let i = foodSources.length - 1; i >= 0; i--) {
                const food = foodSources[i];
                if (food.amount <= 0) {
                    foodSources.splice(i, 1);
                    continue;
                }
                
                const size = 5 + (food.amount / food.maxAmount) * 10;
                ctx.beginPath();
                ctx.arc(food.x, food.y, size, 0, Math.PI * 2);
                ctx.fillStyle = '#90c060';
                ctx.fill();
                ctx.strokeStyle = '#608040';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }
        
        function decayPheromones() {
            const rows = pheromoneGrid.length;
            for (let y = 0; y < rows; y++) {
                const cols = pheromoneGrid[y]?.length || 0;
                for (let x = 0; x < cols; x++) {
                    // Decay food pheromones
                    if (pheromoneGrid[y][x]) {
                        pheromoneGrid[y][x] *= 0.999;
                    }
                    // Decay exploration pheromones (slightly faster - dig sites become "old news")
                    if (explorationPheromoneGrid[y]?.[x]) {
                        explorationPheromoneGrid[y][x] *= 0.997;
                    }
                    // Decay alarm pheromones (slowest - danger memories persist longest)
                    if (alarmPheromoneGrid[y]?.[x]) {
                        alarmPheromoneGrid[y][x] *= 0.9995;
                    }
                }
            }
        }

        function countTunnelLength() {
            const rows = soilGrid.length;
            const surfaceRow = Math.floor(rows * 0.15);
            let dugCells = 0;

            for (let y = surfaceRow; y < rows; y++) {
                const cols = soilGrid[y]?.length || 0;
                for (let x = 0; x < cols; x++) {
                    if (soilGrid[y][x] === 0) {
                        dugCells++;
                    }
                }
            }

            // Scale by world size to give meaningful lengths
            const cellSize = (W / (soilGrid[0]?.length || 1)) * worldScale;
            return Math.floor(dugCells * cellSize / 10);
        }
        
        function updateStats() {
            document.getElementById('ant-count').textContent = ants.length;
            document.getElementById('tunnel-length').textContent = countTunnelLength();
            document.getElementById('chamber-count').textContent = chambers.length;
            document.getElementById('world-depth').textContent = worldScale.toFixed(1);
            document.getElementById('explored-pct').textContent = (exploredPercentage * 100).toFixed(1);
            document.getElementById('queen-fed').textContent = queen ? queen.foodReceived : 0;
            document.getElementById('birth-count').textContent = totalBirths;
            document.getElementById('death-count').textContent = totalDeaths;
            document.getElementById('generation-count').textContent = colonyMemory.generation;

            // Count roles
            let workers = 0, excavators = 0, gatherers = 0, nurses = 0;
            ants.forEach(ant => {
                switch(ant.role) {
                    case ANT_ROLES.WORKER: workers++; break;
                    case ANT_ROLES.EXCAVATOR: excavators++; break;
                    case ANT_ROLES.GATHERER: gatherers++; break;
                    case ANT_ROLES.NURSE: nurses++; break;
                }
            });
            document.getElementById('worker-count').textContent = workers;
            document.getElementById('excavator-count').textContent = excavators;
            document.getElementById('gatherer-count').textContent = gatherers;
            document.getElementById('nurse-count').textContent = nurses;

            // Update role distribution bar
            const total = workers + excavators + gatherers + nurses;
            if (total > 0) {
                document.getElementById('bar-workers').style.width = (workers / total * 100) + '%';
                document.getElementById('bar-excavators').style.width = (excavators / total * 100) + '%';
                document.getElementById('bar-gatherers').style.width = (gatherers / total * 100) + '%';
                document.getElementById('bar-nurses').style.width = (nurses / total * 100) + '%';
            }
        }
        
        function initAnts() {
            ants.length = 0;
            antSpatialGrid.clear(); // Clear spatial grid

            // Most ants start at nest
            for (let i = 0; i < colonySize - 20; i++) {
                const ant = new Ant();
                ants.push(ant);
                antSpatialGrid.insert(ant);
            }

            // Spawn starter food sources ON THE SURFACE
            foodSources.length = 0;
            const food1 = { x: W / 2 + 100, y: H * 0.10, amount: 300, maxAmount: 300 };
            const food2 = { x: W / 2 - 120, y: H * 0.08, amount: 300, maxAmount: 300 };
            const food3 = { x: W / 2, y: H * 0.05, amount: 200, maxAmount: 200 };
            foodSources.push(food1, food2, food3);

            // Spawn 20 SCOUT ANTS directly near food sources - they'll find food immediately!
            const scoutFoods = [food1, food2, food3];
            for (let i = 0; i < 20; i++) {
                const ant = new Ant();
                const targetFood = scoutFoods[i % 3];
                ant.x = targetFood.x + (Math.random() - 0.5) * 40;
                ant.y = targetFood.y + (Math.random() - 0.5) * 20;
                ant.angle = Math.random() * Math.PI * 2;
                ants.push(ant);
                antSpatialGrid.insert(ant);
            }
        }

        // ============ EXPANSION SYSTEM FUNCTIONS ============

        function calculateExploredPercentage() {
            const cols = soilGrid[0]?.length || 0;
            const rows = soilGrid.length;
            const surfaceRow = Math.floor(rows * 0.15);
            let totalSoilCells = 0;
            let dugCells = 0;

            for (let y = surfaceRow; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    if (soilGrid[y] && soilGrid[y][x] !== undefined) {
                        totalSoilCells++;
                        if (soilGrid[y][x] < 0.5) {  // Consider < 50% as "dug"
                            dugCells++;
                        }
                    }
                }
            }

            return totalSoilCells > 0 ? dugCells / totalSoilCells : 0;
        }

        function checkForExpansion() {
            // Throttle checks to every 60 frames (~1 second)
            if (time - lastExpansionCheck < 1) return;
            lastExpansionCheck = time;

            exploredPercentage = calculateExploredPercentage();

            if (exploredPercentage >= EXPANSION_THRESHOLD) {
                expandWorld();
            }
        }

        function expandWorld() {
            console.log(`Expanding world! Current scale: ${worldScale.toFixed(2)}, Explored: ${(exploredPercentage * 100).toFixed(1)}%`);

            const oldCols = soilGrid[0]?.length || 0;
            const oldRows = soilGrid.length;

            // Calculate new dimensions
            const newCols = Math.ceil(oldCols * EXPANSION_FACTOR);
            const newRows = Math.ceil(oldRows * EXPANSION_FACTOR);

            // Calculate offset to center the old content
            const offsetX = Math.floor((newCols - oldCols) / 2);
            const offsetY = Math.floor((newRows - oldRows) / 2);

            // Create new grids
            const newSoilGrid = [];
            const newPheromoneGrid = [];
            const newExplorationPheromoneGrid = [];
            const newAlarmPheromoneGrid = [];

            // Surface line in new grid coordinates
            const newSurfaceRow = Math.floor(newRows * 0.15 / EXPANSION_FACTOR);

            for (let y = 0; y < newRows; y++) {
                newSoilGrid[y] = [];
                newPheromoneGrid[y] = [];
                newExplorationPheromoneGrid[y] = [];
                newAlarmPheromoneGrid[y] = [];
                for (let x = 0; x < newCols; x++) {
                    // Check if this maps to old grid
                    const oldX = x - offsetX;
                    const oldY = y - offsetY;

                    if (oldX >= 0 && oldX < oldCols && oldY >= 0 && oldY < oldRows) {
                        // Copy from old grid
                        newSoilGrid[y][x] = soilGrid[oldY][oldX];
                        newPheromoneGrid[y][x] = pheromoneGrid[oldY]?.[oldX] || 0;
                        newExplorationPheromoneGrid[y][x] = explorationPheromoneGrid[oldY]?.[oldX] || 0;
                        newAlarmPheromoneGrid[y][x] = alarmPheromoneGrid[oldY]?.[oldX] || 0;
                    } else {
                        // New territory - solid soil (except sky)
                        const worldY = y * SOIL_RESOLUTION / worldScale;
                        const surfaceY = H * 0.15;
                        newSoilGrid[y][x] = worldY > surfaceY ? 1 : 0;
                        newPheromoneGrid[y][x] = 0;
                        newExplorationPheromoneGrid[y][x] = 0;
                        newAlarmPheromoneGrid[y][x] = 0;
                    }
                }
            }

            // Update grids
            soilGrid = newSoilGrid;
            pheromoneGrid = newPheromoneGrid;
            explorationPheromoneGrid = newExplorationPheromoneGrid;
            alarmPheromoneGrid = newAlarmPheromoneGrid;

            // Scale ant positions to new grid
            const scaleRatio = 1 / EXPANSION_FACTOR;
            const centerX = W / 2;
            const centerY = H / 2;

            ants.forEach(ant => {
                // Scale position relative to center
                ant.x = centerX + (ant.x - centerX) * scaleRatio;
                ant.y = centerY + (ant.y - centerY) * scaleRatio;
            });

            // Scale food sources
            foodSources.forEach(food => {
                food.x = centerX + (food.x - centerX) * scaleRatio;
                food.y = centerY + (food.y - centerY) * scaleRatio;
            });

            // Scale chambers
            chambers.forEach(chamber => {
                chamber.x = centerX + (chamber.x - centerX) * scaleRatio;
                chamber.y = centerY + (chamber.y - centerY) * scaleRatio;
                chamber.radius *= scaleRatio;
            });

            // Scale queen position
            if (queen) {
                queen.x = centerX + (queen.x - centerX) * scaleRatio;
                queen.y = centerY + (queen.y - centerY) * scaleRatio;
            }

            // Update world scale
            worldScale *= EXPANSION_FACTOR;
            totalExpansions++;

            // Spawn more ants as colony grows
            const newAnts = Math.floor(colonySize * 0.2);
            for (let i = 0; i < newAnts; i++) {
                const ant = new Ant();
                // Spawn near existing ants
                if (ants.length > 0) {
                    const template = ants[Math.floor(Math.random() * ants.length)];
                    ant.x = template.x + (Math.random() - 0.5) * 30;
                    ant.y = template.y + (Math.random() - 0.5) * 30;
                }
                ants.push(ant);
            }

            console.log(`Expansion complete! New scale: ${worldScale.toFixed(2)}, Grid: ${newCols}x${newRows}, Ants: ${ants.length}`);
        }

        // ============ SAVE/LOAD SYSTEM ============

        function compressSoilGrid() {
            // Store only dug cells (value < 1) with their positions
            const dugCells = [];
            const rows = soilGrid.length;
            for (let y = 0; y < rows; y++) {
                const cols = soilGrid[y]?.length || 0;
                for (let x = 0; x < cols; x++) {
                    const val = soilGrid[y][x];
                    if (val < 1) {
                        // Store as [y, x, value] - only non-solid cells
                        dugCells.push([y, x, Math.round(val * 100) / 100]);
                    }
                }
            }
            return dugCells;
        }

        function compressPheromoneGrid() {
            // Store only significant pheromone values (> 0.01)
            const pheromones = [];
            const rows = pheromoneGrid.length;
            for (let y = 0; y < rows; y++) {
                const cols = pheromoneGrid[y]?.length || 0;
                for (let x = 0; x < cols; x++) {
                    const val = pheromoneGrid[y][x];
                    if (val > 0.01) {
                        pheromones.push([y, x, Math.round(val * 1000) / 1000]);
                    }
                }
            }
            return pheromones;
        }

        function compressExplorationPheromoneGrid() {
            // Store only significant exploration pheromone values (> 0.01)
            const pheromones = [];
            const rows = explorationPheromoneGrid.length;
            for (let y = 0; y < rows; y++) {
                const cols = explorationPheromoneGrid[y]?.length || 0;
                for (let x = 0; x < cols; x++) {
                    const val = explorationPheromoneGrid[y][x];
                    if (val > 0.01) {
                        pheromones.push([y, x, Math.round(val * 1000) / 1000]);
                    }
                }
            }
            return pheromones;
        }

        function compressAlarmPheromoneGrid() {
            // Store only significant alarm pheromone values (> 0.01)
            const pheromones = [];
            const rows = alarmPheromoneGrid.length;
            for (let y = 0; y < rows; y++) {
                const cols = alarmPheromoneGrid[y]?.length || 0;
                for (let x = 0; x < cols; x++) {
                    const val = alarmPheromoneGrid[y][x];
                    if (val > 0.01) {
                        pheromones.push([y, x, Math.round(val * 1000) / 1000]);
                    }
                }
            }
            return pheromones;
        }

        function serializeAnts() {
            return ants.map(ant => ({
                x: ant.x / W,  // Normalize to 0-1 for screen size independence
                y: ant.y / H,
                angle: ant.angle,
                speed: ant.speed,
                hasFood: ant.hasFood,
                digging: ant.digging,
                wanderPhase: ant.wanderPhase,
                // Role specialization
                role: ant.role,
                digExperience: ant.digExperience,
                gatherExperience: ant.gatherExperience,
                nurseExperience: ant.nurseExperience,
                // Mortality
                age: ant.age,
                maxAge: ant.maxAge
            }));
        }

        function exportFarm() {
            const cols = Math.ceil(W / SOIL_RESOLUTION);
            const rows = Math.ceil(H / SOIL_RESOLUTION);

            const saveData = {
                version: "1.0",
                timestamp: new Date().toISOString(),
                name: "Ant Farm Save",

                // Grid dimensions (for reconstruction)
                grid: {
                    cols: cols,
                    rows: rows,
                    resolution: SOIL_RESOLUTION
                },

                // Compressed grids (only store non-default values)
                soilDugCells: compressSoilGrid(),
                pheromones: compressPheromoneGrid(),
                explorationPheromones: compressExplorationPheromoneGrid(),
                alarmPheromones: compressAlarmPheromoneGrid(),

                // Entities
                ants: serializeAnts(),
                foodSources: foodSources.map(f => ({
                    x: f.x / W,
                    y: f.y / H,
                    amount: f.amount,
                    maxAmount: f.maxAmount
                })),
                chambers: chambers.map(c => ({
                    x: c.x / W,
                    y: c.y / H,
                    radius: c.radius
                })),

                // Settings
                settings: {
                    colonySize: colonySize,
                    digSpeed: digSpeed
                },

                // Simulation state
                time: time,

                // Expansion state
                expansion: {
                    worldScale: worldScale,
                    totalExpansions: totalExpansions,
                    exploredPercentage: exploredPercentage
                },

                // Queen state
                queen: queen ? {
                    x: queen.x / W,
                    y: queen.y / H,
                    foodReceived: queen.foodReceived,
                    lastSpawnTime: queen.lastSpawnTime,
                    eggProgress: queen.eggProgress
                } : null,
                totalBirths: totalBirths,
                totalDeaths: totalDeaths,

                // Genetic memory
                geneticMemory: {
                    roleSuccess: colonyMemory.roleSuccess,
                    bestForagingDepth: colonyMemory.bestForagingDepth,
                    generation: colonyMemory.generation,
                    successfulDeliveries: colonyMemory.successfulDeliveries,
                    dangerZones: Array.from(colonyMemory.dangerZones.entries())
                },

                // Stats for display
                stats: {
                    tunnelLength: countTunnelLength(),
                    antCount: ants.length,
                    chamberCount: chambers.length,
                    worldDepth: worldScale,
                    queenFed: queen ? queen.foodReceived : 0,
                    births: totalBirths
                }
            };

            const json = JSON.stringify(saveData, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = `ant-farm-${new Date().toISOString().slice(0,10)}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            console.log(`Exported: ${ants.length} ants, ${saveData.soilDugCells.length} dug cells`);
        }

        function importFarm(saveData) {
            try {
                // Validate version
                if (!saveData.version) {
                    throw new Error("Invalid save file: missing version");
                }

                // Get current grid dimensions
                const currentCols = Math.ceil(W / SOIL_RESOLUTION);
                const currentRows = Math.ceil(H / SOIL_RESOLUTION);

                // Calculate scale factors for different screen sizes
                const scaleX = currentCols / saveData.grid.cols;
                const scaleY = currentRows / saveData.grid.rows;

                // Reinitialize grids (fills with solid soil)
                initSoil();

                // Clear the default nest chamber (initSoil adds one)
                chambers.length = 0;

                // Restore dug cells with scaling
                for (const [y, x, val] of saveData.soilDugCells) {
                    const newY = Math.floor(y * scaleY);
                    const newX = Math.floor(x * scaleX);
                    if (newY >= 0 && newY < currentRows && newX >= 0 && newX < currentCols) {
                        if (!soilGrid[newY]) soilGrid[newY] = [];
                        soilGrid[newY][newX] = val;
                    }
                }

                // Restore pheromones with scaling
                for (const [y, x, val] of saveData.pheromones) {
                    const newY = Math.floor(y * scaleY);
                    const newX = Math.floor(x * scaleX);
                    if (newY >= 0 && newY < currentRows && newX >= 0 && newX < currentCols) {
                        if (!pheromoneGrid[newY]) pheromoneGrid[newY] = [];
                        pheromoneGrid[newY][newX] = val;
                    }
                }

                // Restore exploration pheromones with scaling
                if (saveData.explorationPheromones) {
                    for (const [y, x, val] of saveData.explorationPheromones) {
                        const newY = Math.floor(y * scaleY);
                        const newX = Math.floor(x * scaleX);
                        if (newY >= 0 && newY < currentRows && newX >= 0 && newX < currentCols) {
                            if (!explorationPheromoneGrid[newY]) explorationPheromoneGrid[newY] = [];
                            explorationPheromoneGrid[newY][newX] = val;
                        }
                    }
                }

                // Restore alarm pheromones with scaling
                if (saveData.alarmPheromones) {
                    for (const [y, x, val] of saveData.alarmPheromones) {
                        const newY = Math.floor(y * scaleY);
                        const newX = Math.floor(x * scaleX);
                        if (newY >= 0 && newY < currentRows && newX >= 0 && newX < currentCols) {
                            if (!alarmPheromoneGrid[newY]) alarmPheromoneGrid[newY] = [];
                            alarmPheromoneGrid[newY][newX] = val;
                        }
                    }
                }

                // Restore ants
                ants.length = 0;
                for (const antData of saveData.ants) {
                    const ant = new Ant();
                    ant.x = antData.x * W;
                    ant.y = antData.y * H;
                    ant.angle = antData.angle;
                    ant.speed = antData.speed;
                    ant.hasFood = antData.hasFood;
                    ant.digging = antData.digging;
                    ant.wanderPhase = antData.wanderPhase;
                    // Restore role specialization
                    ant.role = antData.role || ANT_ROLES.WORKER;
                    ant.digExperience = antData.digExperience || 0;
                    ant.gatherExperience = antData.gatherExperience || 0;
                    ant.nurseExperience = antData.nurseExperience || 0;
                    // Restore mortality
                    ant.age = antData.age || 0;
                    ant.maxAge = antData.maxAge || (BASE_LIFESPAN + Math.random() * LIFESPAN_VARIANCE);
                    ants.push(ant);
                }

                totalDeaths = saveData.totalDeaths || 0;

                // Restore food sources
                foodSources.length = 0;
                for (const f of saveData.foodSources) {
                    foodSources.push({
                        x: f.x * W,
                        y: f.y * H,
                        amount: f.amount,
                        maxAmount: f.maxAmount
                    });
                }

                // Restore chambers
                for (const c of saveData.chambers) {
                    chambers.push({
                        x: c.x * W,
                        y: c.y * H,
                        radius: c.radius
                    });
                }

                // Restore settings
                colonySize = saveData.settings.colonySize;
                digSpeed = saveData.settings.digSpeed;
                time = saveData.time || 0;

                // Restore expansion state
                if (saveData.expansion) {
                    worldScale = saveData.expansion.worldScale || 1.0;
                    totalExpansions = saveData.expansion.totalExpansions || 0;
                    exploredPercentage = saveData.expansion.exploredPercentage || 0;
                } else {
                    worldScale = 1.0;
                    totalExpansions = 0;
                    exploredPercentage = 0;
                }
                lastExpansionCheck = time;

                // Restore queen state
                if (saveData.queen) {
                    queen = new QueenAnt(saveData.queen.x * W, saveData.queen.y * H);
                    queen.foodReceived = saveData.queen.foodReceived || 0;
                    queen.lastSpawnTime = saveData.queen.lastSpawnTime || 0;
                    queen.eggProgress = saveData.queen.eggProgress || 0;
                } else {
                    queen = new QueenAnt(W / 2, H * 0.2);
                }
                totalBirths = saveData.totalBirths || 0;

                // Restore genetic memory
                if (saveData.geneticMemory) {
                    colonyMemory.roleSuccess = saveData.geneticMemory.roleSuccess || {
                        excavator: { totalLifespan: 0, count: 0 },
                        gatherer: { totalLifespan: 0, count: 0 },
                        nurse: { totalLifespan: 0, count: 0 }
                    };
                    colonyMemory.bestForagingDepth = saveData.geneticMemory.bestForagingDepth || 0.5;
                    colonyMemory.generation = saveData.geneticMemory.generation || 0;
                    colonyMemory.successfulDeliveries = saveData.geneticMemory.successfulDeliveries || 0;
                    colonyMemory.dangerZones = new Map(saveData.geneticMemory.dangerZones || []);
                }

                // Update UI
                document.getElementById('size').value = colonySize;
                document.getElementById('size-val').textContent = colonySize;
                document.getElementById('speed').value = Math.round(digSpeed * 100);
                document.getElementById('speed-val').textContent = Math.round(digSpeed * 100);

                console.log(`Imported: ${ants.length} ants, ${saveData.soilDugCells.length} dug cells, scale: ${worldScale}x`);
                return true;
            } catch (err) {
                console.error("Import error:", err);
                alert("Failed to import: " + err.message);
                return false;
            }
        }

        function handleFileImport(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const saveData = JSON.parse(e.target.result);
                    importFarm(saveData);
                } catch (err) {
                    alert("Invalid JSON file: " + err.message);
                }
            };
            reader.readAsText(file);

            // Reset file input so same file can be loaded again
            event.target.value = '';
        }
        
        function animate() {
            const dt = 0.016 * simulationSpeed;

            // Always draw even when paused
            drawSoil();
            drawSky();
            drawLightShafts();      // Atmospheric light beams from surface
            drawRoots();            // Organic root tendrils in tunnels

            // Draw weather effects (particles, overlays)
            weather.draw();

            drawPheromoneTrails();  // Visible glowing trails
            drawFoodSources();

            // Draw all ants (even when paused)
            for (const ant of ants) {
                ant.draw();
            }

            // Draw digging dust particles
            updateAndDrawDust();

            // Draw rising ant spirits
            updateAndDrawSpirits();

            // Draw nest chamber background
            ctx.beginPath();
            ctx.arc(W/2, H * 0.2, 12, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(80, 60, 40, 0.5)';
            ctx.fill();

            // Draw the queen
            if (queen) {
                queen.draw();
            }

            ctx.font = '10px Georgia';
            ctx.fillStyle = '#a08060';
            ctx.textAlign = 'center';
            ctx.fillText('NEST', W/2, H * 0.2 + 25);

            // Only update simulation when not paused
            if (!isPaused) {
                time += dt;

                // Update weather system
                weather.update(dt);

                if (time % 0.1 < 0.02) decayPheromones();

                // Check for world expansion
                checkForExpansion();

                // Update ants and remove dead ones
                for (let i = ants.length - 1; i >= 0; i--) {
                    const ant = ants[i];
                    ant.update();

                    // Update spatial grid position
                    antSpatialGrid.update(ant);

                    if (!ant.isAlive) {
                        // Record death for genetic memory
                        recordAntDeath(ant);
                        // Remove from spatial grid
                        antSpatialGrid.remove(ant);
                        // Spawn spirit effect before removing ant
                        spawnDeadAntSpirit(ant.x, ant.y, ant.role);
                        ants.splice(i, 1);  // Remove dead ant
                    }
                }

                // Update queen
                if (queen) {
                    queen.update(time);
                }

                // Check for milestone achievements (throttled to every 60 frames)
                if (Math.floor(time * 60) % 60 === 0) {
                    checkMilestones();
                }
            }

            updateStats();

            // Update procedural audio based on colony activity
            if (audioEnabled) updateAudio();

            requestAnimationFrame(animate);
        }
        
        canvas.onclick = e => {
            if (e.clientX < 200 && e.clientY < 280) return;
            
            if (placingFood) {
                foodSources.push({
                    x: e.clientX,
                    y: e.clientY,
                    amount: 100,
                    maxAmount: 100
                });
                placingFood = false;
                document.getElementById('food-btn').textContent = 'Place Food Source';
            }
        };
        
        document.getElementById('size').oninput = e => {
            colonySize = parseInt(e.target.value);
            document.getElementById('size-val').textContent = e.target.value;
        };
        
        document.getElementById('speed').oninput = e => {
            digSpeed = e.target.value / 100;
            document.getElementById('speed-val').textContent = e.target.value;
        };
        
        document.getElementById('food-btn').onclick = () => {
            placingFood = !placingFood;
            document.getElementById('food-btn').textContent = placingFood ? 'Click to Place...' : 'Place Food Source';
        };
        
        document.getElementById('reset-btn').onclick = () => {
            // Reset expansion state
            worldScale = 1.0;
            targetScale = 1.0;
            totalExpansions = 0;
            exploredPercentage = 0;
            lastExpansionCheck = 0;

            // Reset queen and mortality state
            totalBirths = 0;
            totalDeaths = 0;

            // Reset weather with grace period
            weather.state = 'CLEAR';
            weather.stateTime = 0;
            weather.cycleDuration = 120; // Long initial clear period
            weather.floodLevel = 0;
            weather.particles = [];
            weather.gracePeriod = true; // Reset grace period
            weather.updateUI();

            initSoil();  // This creates a new queen
            initAnts();  // This also clears spatial grid and spawns starter food
            chambers.length = 1;
        };

        document.getElementById('export-btn').onclick = exportFarm;
        document.getElementById('import-btn').onclick = () => {
            document.getElementById('file-input').click();
        };
        document.getElementById('file-input').onchange = handleFileImport;
        document.getElementById('sound-btn').onclick = toggleAudio;

        // Pause button
        document.getElementById('pause-btn').onclick = () => {
            isPaused = !isPaused;
            const btn = document.getElementById('pause-btn');
            btn.textContent = isPaused ? 'Resume' : 'Pause';
            btn.classList.toggle('paused', isPaused);
        };

        // Speed control buttons
        document.querySelectorAll('.speed-btn').forEach(btn => {
            btn.onclick = () => {
                simulationSpeed = parseFloat(btn.dataset.speed);
                document.querySelectorAll('.speed-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
            };
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', e => {
            // Don't trigger if typing in an input
            if (e.target.tagName === 'INPUT') return;

            switch(e.key.toLowerCase()) {
                case ' ': // Space = pause
                    e.preventDefault();
                    document.getElementById('pause-btn').click();
                    break;
                case 'f': // F = food mode
                    document.getElementById('food-btn').click();
                    break;
                case '1':
                    simulationSpeed = 0.5;
                    updateSpeedButtons();
                    break;
                case '2':
                    simulationSpeed = 1;
                    updateSpeedButtons();
                    break;
                case '3':
                    simulationSpeed = 2;
                    updateSpeedButtons();
                    break;
                case '4':
                    simulationSpeed = 4;
                    updateSpeedButtons();
                    break;
                case 'w': // W = cycle weather
                    weather.stateTime = weather.cycleDuration; // Force weather change
                    break;
            }
        });

        function updateSpeedButtons() {
            document.querySelectorAll('.speed-btn').forEach(btn => {
                btn.classList.toggle('active', parseFloat(btn.dataset.speed) === simulationSpeed);
            });
        }

        resize();  // Initialize W, H and soil
        initAnts();
        animate();
    </script>
</body>
</html>