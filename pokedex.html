<!DOCTYPE html>
<html>
<head>
<title>Interactive Pokedex</title>
<style>
/* ============================================
   CSS VARIABLES - THEMING SYSTEM
   ============================================ */
:root {
  /* Primary Color Palette */
  --color-primary: #FF6B6B;
  --color-secondary: #4ECDC4;
  --color-accent: #FFE66D;
  --color-background: #F0F4F8;
  --color-surface: #FFFFFF;
  --color-text-primary: #2D3748;
  --color-text-secondary: #718096;
  --color-text-light: #A0AEC0;

  /* Pokemon Type Colors */
  --type-normal: #A8A878;
  --type-fire: #F08030;
  --type-water: #6890F0;
  --type-electric: #F8D030;
  --type-grass: #78C850;
  --type-ice: #98D8D8;
  --type-fighting: #C03028;
  --type-poison: #A040A0;
  --type-ground: #E0C068;
  --type-flying: #A890F0;
  --type-psychic: #F85888;
  --type-bug: #A8B820;
  --type-rock: #B8A038;
  --type-ghost: #705898;
  --type-dragon: #7038F8;
  --type-dark: #705848;
  --type-steel: #B8B8D0;
  --type-fairy: #EE99AC;

  /* Spacing System */
  --spacing-xs: 0.25rem;
  --spacing-sm: 0.5rem;
  --spacing-md: 1rem;
  --spacing-lg: 1.5rem;
  --spacing-xl: 2rem;
  --spacing-2xl: 3rem;

  /* Border Radius */
  --radius-sm: 0.375rem;
  --radius-md: 0.5rem;
  --radius-lg: 0.75rem;
  --radius-xl: 1rem;
  --radius-full: 9999px;

  /* Shadows */
  --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
  --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
  --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
  --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
  --shadow-2xl: 0 25px 50px -12px rgba(0, 0, 0, 0.25);

  /* Transitions */
  --transition-fast: 150ms ease-in-out;
  --transition-base: 250ms ease-in-out;
  --transition-slow: 350ms ease-in-out;

  /* Z-Index Scale */
  --z-base: 1;
  --z-dropdown: 100;
  --z-sticky: 200;
  --z-overlay: 900;
  --z-modal: 1000;
  --z-tooltip: 1100;
}

/* Dark Mode Support */
@media (prefers-color-scheme: dark) {
  :root {
    --color-background: #1A202C;
    --color-surface: #2D3748;
    --color-text-primary: #F7FAFC;
    --color-text-secondary: #E2E8F0;
    --color-text-light: #CBD5E0;
  }
}

/* ============================================
   GLOBAL RESET & BASE STYLES
   ============================================ */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

html {
  font-size: 16px;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 25%, #f093fb 50%, #4facfe 75%, #00f2fe 100%);
  background-attachment: fixed;
  background-size: 400% 400%;
  animation: gradientShift 15s ease infinite;
  color: var(--color-text-primary);
  min-height: 100vh;
  padding: var(--spacing-lg);
  position: relative;
}

@keyframes gradientShift {
  0% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
}

/* Pokeball Background Pattern */
body::before {
  content: '';
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-image:
    radial-gradient(circle at 20% 30%, rgba(255, 255, 255, 0.05) 0%, transparent 50%),
    radial-gradient(circle at 80% 70%, rgba(255, 255, 255, 0.05) 0%, transparent 50%),
    radial-gradient(circle at 50% 50%, rgba(255, 255, 255, 0.03) 0%, transparent 60%);
  pointer-events: none;
  z-index: 0;
}

/* ============================================
   HEADER & NAVIGATION
   ============================================ */
h1 {
  position: relative;
  z-index: var(--z-base);
  text-align: center;
  font-size: clamp(2rem, 5vw, 3.5rem);
  font-weight: 800;
  color: var(--color-surface);
  text-shadow:
    0 2px 10px rgba(0, 0, 0, 0.3),
    0 4px 20px rgba(0, 0, 0, 0.2);
  margin-bottom: var(--spacing-xl);
  letter-spacing: 0.05em;
  animation: slideDown 0.6s ease-out;
}

@keyframes slideDown {
  from {
    opacity: 0;
    transform: translateY(-30px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* ============================================
   SEARCH & FILTER SECTION
   ============================================ */
.search-filter-container {
  position: relative;
  z-index: var(--z-base);
  max-width: 1200px;
  margin: 0 auto var(--spacing-xl);
  background: rgba(255, 255, 255, 0.95);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  border-radius: var(--radius-xl);
  padding: var(--spacing-lg);
  box-shadow: var(--shadow-xl);
}

.search-bar {
  width: 100%;
  padding: var(--spacing-md) var(--spacing-lg);
  font-size: 1rem;
  border: 2px solid transparent;
  border-radius: var(--radius-full);
  background: var(--color-surface);
  box-shadow: var(--shadow-md);
  transition: all var(--transition-base);
  outline: none;
}

.search-bar:focus {
  border-color: var(--color-primary);
  box-shadow: 0 0 0 3px rgba(255, 107, 107, 0.1), var(--shadow-lg);
  transform: translateY(-1px);
}

.search-bar::placeholder {
  color: var(--color-text-light);
}

.filter-chips {
  display: flex;
  flex-wrap: wrap;
  gap: var(--spacing-sm);
  margin-top: var(--spacing-md);
}

.filter-chip {
  padding: var(--spacing-sm) var(--spacing-md);
  border: 2px solid var(--color-text-light);
  border-radius: var(--radius-full);
  background: var(--color-surface);
  color: var(--color-text-secondary);
  font-size: 0.875rem;
  font-weight: 600;
  cursor: pointer;
  transition: all var(--transition-fast);
  user-select: none;
}

.filter-chip:hover {
  border-color: var(--color-primary);
  background: var(--color-primary);
  color: var(--color-surface);
  transform: translateY(-2px);
  box-shadow: var(--shadow-md);
}

.filter-chip.active {
  border-color: var(--color-primary);
  background: var(--color-primary);
  color: var(--color-surface);
  box-shadow: var(--shadow-md);
}

/* ============================================
   POKEMON GRID LAYOUT
   ============================================ */
#pokedex {
  position: relative;
  z-index: var(--z-base);
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
  gap: var(--spacing-lg);
  max-width: 1400px;
  margin: 0 auto;
  padding: var(--spacing-md);
}

/* ============================================
   POKEMON CARD DESIGN
   ============================================ */
.pokemon-card {
  position: relative;
  background: linear-gradient(135deg, rgba(255, 255, 255, 0.95) 0%, rgba(255, 255, 255, 0.85) 100%);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  border-radius: var(--radius-xl);
  padding: var(--spacing-lg);
  text-align: center;
  cursor: pointer;
  transition: all var(--transition-base);
  box-shadow: var(--shadow-md);
  border: 2px solid rgba(255, 255, 255, 0.3);
  overflow: hidden;
  animation: fadeInUp 0.5s ease-out backwards;
}

@keyframes fadeInUp {
  from {
    opacity: 0;
    transform: translateY(30px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Stagger animation for cards */
.pokemon-card:nth-child(1) { animation-delay: 0.05s; }
.pokemon-card:nth-child(2) { animation-delay: 0.1s; }
.pokemon-card:nth-child(3) { animation-delay: 0.15s; }
.pokemon-card:nth-child(4) { animation-delay: 0.2s; }
.pokemon-card:nth-child(5) { animation-delay: 0.25s; }
.pokemon-card:nth-child(6) { animation-delay: 0.3s; }

.pokemon-card::before {
  content: '';
  position: absolute;
  top: -50%;
  left: -50%;
  width: 200%;
  height: 200%;
  background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.3), transparent);
  transform: rotate(45deg);
  transition: all var(--transition-slow);
  opacity: 0;
}

.pokemon-card:hover::before {
  animation: shimmer 1.5s ease-in-out;
}

@keyframes shimmer {
  0% {
    top: -50%;
    left: -50%;
    opacity: 0;
  }
  50% {
    opacity: 1;
  }
  100% {
    top: 150%;
    left: 150%;
    opacity: 0;
  }
}

.pokemon-card:hover {
  transform: translateY(-12px) scale(1.03);
  box-shadow: var(--shadow-2xl);
  border-color: rgba(255, 107, 107, 0.5);
}

.pokemon-card:active {
  transform: translateY(-8px) scale(1.01);
}

.pokemon-card img {
  width: 100%;
  max-width: 150px;
  height: auto;
  margin-bottom: var(--spacing-md);
  filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.1));
  transition: all var(--transition-base);
  image-rendering: pixelated;
  image-rendering: -moz-crisp-edges;
  image-rendering: crisp-edges;
}

.pokemon-card:hover img {
  transform: scale(1.1) rotate(5deg);
  filter: drop-shadow(0 8px 16px rgba(0, 0, 0, 0.2));
}

.pokemon-card h3 {
  font-size: 1.25rem;
  font-weight: 700;
  color: var(--color-text-primary);
  margin-bottom: var(--spacing-sm);
  text-transform: capitalize;
}

.pokemon-id {
  position: absolute;
  top: var(--spacing-sm);
  left: var(--spacing-sm);
  background: rgba(0, 0, 0, 0.6);
  color: var(--color-surface);
  padding: var(--spacing-xs) var(--spacing-sm);
  border-radius: var(--radius-full);
  font-size: 0.75rem;
  font-weight: 700;
}

.pokemon-types {
  display: flex;
  gap: var(--spacing-xs);
  justify-content: center;
  flex-wrap: wrap;
}

.type-badge {
  padding: var(--spacing-xs) var(--spacing-md);
  border-radius: var(--radius-full);
  font-size: 0.75rem;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  color: white;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
  box-shadow: var(--shadow-sm);
}

/* Type Badge Colors */
.type-normal { background: var(--type-normal); }
.type-fire { background: var(--type-fire); }
.type-water { background: var(--type-water); }
.type-electric { background: var(--type-electric); }
.type-grass { background: var(--type-grass); }
.type-ice { background: var(--type-ice); }
.type-fighting { background: var(--type-fighting); }
.type-poison { background: var(--type-poison); }
.type-ground { background: var(--type-ground); }
.type-flying { background: var(--type-flying); }
.type-psychic { background: var(--type-psychic); }
.type-bug { background: var(--type-bug); }
.type-rock { background: var(--type-rock); }
.type-ghost { background: var(--type-ghost); }
.type-dragon { background: var(--type-dragon); }
.type-dark { background: var(--type-dark); }
.type-steel { background: var(--type-steel); }
.type-fairy { background: var(--type-fairy); }

/* ============================================
   MODAL / DETAIL VIEW
   ============================================ */
#overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.75);
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  display: none;
  z-index: var(--z-overlay);
  animation: fadeIn var(--transition-base);
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

#pokemon-details {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%) scale(0.9);
  width: 90%;
  max-width: 600px;
  max-height: 90vh;
  overflow-y: auto;
  background: linear-gradient(135deg, rgba(255, 255, 255, 0.98) 0%, rgba(255, 255, 255, 0.95) 100%);
  backdrop-filter: blur(20px);
  -webkit-backdrop-filter: blur(20px);
  padding: var(--spacing-2xl);
  border-radius: var(--radius-xl);
  box-shadow: var(--shadow-2xl);
  display: none;
  z-index: var(--z-modal);
  animation: modalSlideIn var(--transition-slow);
  border: 2px solid rgba(255, 255, 255, 0.5);
}

@keyframes modalSlideIn {
  from {
    opacity: 0;
    transform: translate(-50%, -50%) scale(0.85);
  }
  to {
    opacity: 1;
    transform: translate(-50%, -50%) scale(1);
  }
}

#pokemon-details::-webkit-scrollbar {
  width: 8px;
}

#pokemon-details::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.05);
  border-radius: var(--radius-full);
}

#pokemon-details::-webkit-scrollbar-thumb {
  background: var(--color-primary);
  border-radius: var(--radius-full);
}

#pokemon-details img {
  width: 100%;
  max-width: 250px;
  height: auto;
  margin: 0 auto var(--spacing-lg);
  display: block;
  filter: drop-shadow(0 10px 30px rgba(0, 0, 0, 0.2));
  image-rendering: pixelated;
  image-rendering: -moz-crisp-edges;
  image-rendering: crisp-edges;
}

#detail-name {
  text-align: center;
  font-size: 2rem;
  font-weight: 800;
  color: var(--color-text-primary);
  margin-bottom: var(--spacing-md);
  text-transform: capitalize;
}

#detail-types {
  text-align: center;
  margin-bottom: var(--spacing-xl);
  font-size: 1.125rem;
  color: var(--color-text-secondary);
}

/* Stats Section */
#detail-stats {
  margin-bottom: var(--spacing-xl);
}

.stat-bar {
  width: 100%;
  background: rgba(0, 0, 0, 0.08);
  border-radius: var(--radius-full);
  overflow: hidden;
  margin-bottom: var(--spacing-md);
  position: relative;
  height: 32px;
  box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
}

.stat-value {
  height: 100%;
  background: linear-gradient(90deg, var(--color-primary) 0%, var(--color-secondary) 100%);
  color: white;
  padding: 0 var(--spacing-md);
  display: flex;
  align-items: center;
  justify-content: space-between;
  font-weight: 700;
  font-size: 0.875rem;
  border-radius: var(--radius-full);
  transition: width var(--transition-slow);
  box-shadow: inset 0 1px 2px rgba(255, 255, 255, 0.3);
  text-transform: capitalize;
}

.stat-value::before {
  content: attr(data-stat-name);
  font-weight: 700;
}

/* Close Button */
#pokemon-details button {
  width: 100%;
  padding: var(--spacing-md) var(--spacing-xl);
  background: linear-gradient(135deg, var(--color-primary) 0%, #ff8787 100%);
  color: white;
  border: none;
  border-radius: var(--radius-full);
  font-size: 1rem;
  font-weight: 700;
  cursor: pointer;
  transition: all var(--transition-base);
  box-shadow: var(--shadow-md);
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

#pokemon-details button:hover {
  transform: translateY(-2px);
  box-shadow: var(--shadow-lg);
  background: linear-gradient(135deg, #ff8787 0%, var(--color-primary) 100%);
}

#pokemon-details button:active {
  transform: translateY(0);
  box-shadow: var(--shadow-sm);
}

#pokemon-details button:focus {
  outline: none;
  box-shadow: 0 0 0 3px rgba(255, 107, 107, 0.3), var(--shadow-lg);
}

/* ============================================
   LOADING STATES & ANIMATIONS
   ============================================ */
.loading-spinner {
  display: inline-block;
  width: 50px;
  height: 50px;
  border: 5px solid rgba(255, 255, 255, 0.3);
  border-radius: 50%;
  border-top-color: var(--color-primary);
  animation: spin 1s linear infinite;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

.loading-container {
  display: flex;
  justify-content: center;
  align-items: center;
  padding: var(--spacing-2xl);
}

/* ============================================
   EMPTY STATES
   ============================================ */
.empty-state {
  text-align: center;
  padding: var(--spacing-2xl);
  color: var(--color-surface);
  animation: fadeIn var(--transition-base);
}

.empty-state-icon {
  font-size: 4rem;
  margin-bottom: var(--spacing-lg);
  opacity: 0.5;
}

.empty-state-title {
  font-size: 1.5rem;
  font-weight: 700;
  margin-bottom: var(--spacing-sm);
  color: var(--color-surface);
}

.empty-state-description {
  font-size: 1rem;
  color: rgba(255, 255, 255, 0.8);
}

/* ============================================
   RESPONSIVE BREAKPOINTS
   ============================================ */

/* Mobile Phones (320px - 767px) */
@media (max-width: 767px) {
  body {
    padding: var(--spacing-sm);
  }

  h1 {
    font-size: 2rem;
    margin-bottom: var(--spacing-lg);
  }

  #pokedex {
    grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
    gap: var(--spacing-md);
    padding: var(--spacing-sm);
  }

  .pokemon-card {
    padding: var(--spacing-md);
  }

  .pokemon-card img {
    max-width: 100px;
  }

  .pokemon-card h3 {
    font-size: 1rem;
  }

  #pokemon-details {
    width: 95%;
    padding: var(--spacing-lg);
    max-height: 85vh;
  }

  #detail-name {
    font-size: 1.5rem;
  }

  #pokemon-details img {
    max-width: 180px;
  }

  .search-filter-container {
    padding: var(--spacing-md);
  }

  .filter-chips {
    gap: var(--spacing-xs);
  }

  .filter-chip {
    font-size: 0.75rem;
    padding: var(--spacing-xs) var(--spacing-sm);
  }
}

/* Tablets (768px - 1023px) */
@media (min-width: 768px) and (max-width: 1023px) {
  #pokedex {
    grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
    gap: var(--spacing-lg);
  }

  .pokemon-card img {
    max-width: 130px;
  }

  #pokemon-details {
    width: 85%;
    max-width: 550px;
  }
}

/* Desktop (1024px+) */
@media (min-width: 1024px) {
  #pokedex {
    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
  }

  .pokemon-card:hover {
    transform: translateY(-15px) scale(1.05);
  }
}

/* Large Screens (1440px+) */
@media (min-width: 1440px) {
  #pokedex {
    max-width: 1600px;
    grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
    gap: var(--spacing-xl);
  }
}

/* ============================================
   ACCESSIBILITY IMPROVEMENTS
   ============================================ */

/* Focus Visible for Keyboard Navigation */
.pokemon-card:focus-visible,
.filter-chip:focus-visible,
.search-bar:focus-visible,
button:focus-visible {
  outline: 3px solid var(--color-primary);
  outline-offset: 2px;
}

/* Reduced Motion Support */
@media (prefers-reduced-motion: reduce) {
  *,
  *::before,
  *::after {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
  }

  body {
    animation: none;
  }
}

/* High Contrast Mode Support */
@media (prefers-contrast: high) {
  .pokemon-card {
    border: 3px solid var(--color-text-primary);
  }

  .type-badge {
    border: 2px solid white;
  }
}

/* ============================================
   UTILITY CLASSES
   ============================================ */
.visually-hidden {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}

.fade-in {
  animation: fadeIn var(--transition-base);
}

.slide-up {
  animation: fadeInUp var(--transition-base);
}

/* ============================================
   PRINT STYLES
   ============================================ */
@media print {
  body {
    background: white;
  }

  .pokemon-card {
    break-inside: avoid;
    box-shadow: none;
    border: 1px solid #ccc;
  }

  #overlay,
  #pokemon-details {
    display: none !important;
  }
}
</style>
</head>
<body>
<h1>Pokedex</h1>

<!-- Search & Filter Container -->
<div class="search-filter-container">
  <input
    type="text"
    class="search-bar"
    id="pokemon-search"
    placeholder="Search Pokemon by name or number..."
    aria-label="Search Pokemon"
  >
  <div class="filter-chips" id="type-filters"></div>
  <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 1rem; flex-wrap: wrap; gap: 0.5rem;">
    <div style="display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap;">
      <label style="font-weight: 600; color: var(--color-text-primary);">Sort by:</label>
      <select id="sort-select" style="padding: 0.5rem; border-radius: 0.5rem; border: 2px solid var(--color-text-light); font-size: 0.875rem;">
        <option value="id">Pokedex Number</option>
        <option value="name">Name (A-Z)</option>
        <option value="hp">HP</option>
        <option value="attack">Attack</option>
        <option value="speed">Speed</option>
      </select>
      <button id="sort-order-btn" class="filter-chip active" style="margin: 0;">↑ Asc</button>
    </div>
    <div style="font-weight: 600; color: var(--color-text-secondary);" id="result-count">Showing 50 Pokemon</div>
  </div>
</div>

<div id="pokedex"></div>
<div id="pokemon-details">
  <img id="detail-image" src="" alt="">
  <h2 id="detail-name"></h2>
  <p id="detail-types"></p>
  <div id="detail-stats"></div>
  <button onclick="closeDetails()">Close</button>
</div>
<div id="overlay"></div>

<script>
const pokedex = document.getElementById('pokedex');
const details = document.getElementById('pokemon-details');
const overlay = document.getElementById('overlay');
const detailImage = document.getElementById('detail-image');
const detailName = document.getElementById('detail-name');
const detailTypes = document.getElementById('detail-types');
const detailStats = document.getElementById('detail-stats');

// ============================================
// POKEAPI DATA MANAGER WITH CACHING
// ============================================
const CACHE_PREFIX = 'pokedex_v1_';
const CACHE_DURATION = 24 * 60 * 60 * 1000; // 24 hours
const API_BASE = 'https://pokeapi.co/api/v2';
const BATCH_SIZE = 50;

let pokemonList = [];
let currentOffset = 0;
let totalPokemon = 1010; // Total Pokemon as of Gen 9
let isLoading = false;

// Cache helpers
function getCacheKey(type, identifier) {
  return `${CACHE_PREFIX}${type}_${identifier}`;
}

function isCacheValid(cacheData) {
  if (!cacheData || !cacheData.timestamp) return false;
  const age = Date.now() - cacheData.timestamp;
  return age < CACHE_DURATION;
}

function getFromCache(type, identifier) {
  try {
    const key = getCacheKey(type, identifier);
    const cached = localStorage.getItem(key);
    if (!cached) return null;
    const data = JSON.parse(cached);
    return isCacheValid(data) ? data.payload : null;
  } catch (error) {
    console.error('Cache read error:', error);
    return null;
  }
}

function saveToCache(type, identifier, data) {
  try {
    const key = getCacheKey(type, identifier);
    const cacheData = {
      timestamp: Date.now(),
      payload: data
    };
    localStorage.setItem(key, JSON.stringify(cacheData));
    return true;
  } catch (error) {
    console.error('Cache write error:', error);
    return false;
  }
}

// Fetch Pokemon from PokeAPI with caching
async function fetchPokemonBatch(offset = 0, limit = BATCH_SIZE) {
  const cacheKey = `list_${offset}_${limit}`;

  // Check cache first
  const cached = getFromCache('list', cacheKey);
  if (cached) {
    console.log('📦 Loading from cache:', cacheKey);
    return cached;
  }

  console.log('🌐 Fetching from PokeAPI:', offset, 'to', offset + limit);

  try {
    const response = await fetch(
      `${API_BASE}/pokemon?offset=${offset}&limit=${limit}`
    );

    if (!response.ok) throw new Error('API request failed');

    const data = await response.json();
    totalPokemon = data.count;

    // Fetch detailed data for each Pokemon in parallel
    const detailedPromises = data.results.map(p =>
      fetchPokemonDetails(p.url.split('/').slice(-2, -1)[0])
    );

    const detailedData = await Promise.all(detailedPromises);

    // Cache the result
    saveToCache('list', cacheKey, detailedData);

    return detailedData;
  } catch (error) {
    console.error('Failed to fetch Pokemon:', error);
    // Return stale cache as fallback
    const staleCache = getFromCache('list', cacheKey);
    if (staleCache) {
      console.warn('⚠️ Using stale cache due to network error');
      return staleCache;
    }
    throw error;
  }
}

// Fetch detailed Pokemon data
async function fetchPokemonDetails(idOrName) {
  // Check cache first
  const cached = getFromCache('pokemon', idOrName);
  if (cached) return cached;

  try {
    const response = await fetch(`${API_BASE}/pokemon/${idOrName}`);
    if (!response.ok) throw new Error('Pokemon not found');

    const data = await response.json();

    // Transform API data to our schema
    const pokemon = {
      id: data.id,
      name: data.name,
      types: data.types.map(t => t.type.name.charAt(0).toUpperCase() + t.type.name.slice(1)),
      imageUrl: data.sprites.versions?.['generation-v']?.['black-white']?.animated?.front_default
               || data.sprites.front_default
               || `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/${data.id}.png`,
      stats: {
        hp: data.stats[0].base_stat,
        attack: data.stats[1].base_stat,
        defense: data.stats[2].base_stat,
        specialAttack: data.stats[3].base_stat,
        specialDefense: data.stats[4].base_stat,
        speed: data.stats[5].base_stat
      },
      abilities: data.abilities.map(a => a.ability.name),
      height: data.height,
      weight: data.weight
    };

    // Save to cache
    saveToCache('pokemon', idOrName, pokemon);
    saveToCache('pokemon', data.id, pokemon);

    return pokemon;
  } catch (error) {
    console.error(`Failed to fetch Pokemon ${idOrName}:`, error);
    throw error;
  }
}

// Load more Pokemon
async function loadMorePokemon() {
  if (isLoading || currentOffset >= totalPokemon) return;

  isLoading = true;
  showLoadingIndicator();

  try {
    const newPokemon = await fetchPokemonBatch(currentOffset, BATCH_SIZE);
    pokemonList = [...pokemonList, ...newPokemon];
    currentOffset += BATCH_SIZE;

    renderPokemon();
    updateLoadMoreButton();
  } catch (error) {
    showError('Failed to load Pokemon. Check your connection and try again.');
  } finally {
    isLoading = false;
    hideLoadingIndicator();
  }
}

function showLoadingIndicator() {
  const existing = document.querySelector('.loading-container');
  if (existing) return;

  const loader = document.createElement('div');
  loader.className = 'loading-container';
  loader.innerHTML = '<div class="loading-spinner"></div><p style="color: white; margin-top: 1rem; font-weight: 600;">Loading more Pokemon...</p>';

  // Add to bottom instead of grid
  const indicator = document.getElementById('load-progress');
  if (indicator) {
    indicator.appendChild(loader);
  } else {
    document.body.appendChild(loader);
  }
}

function hideLoadingIndicator() {
  const loader = document.querySelector('.loading-container');
  if (loader) loader.remove();
}

// Infinite scroll with Intersection Observer
let scrollSentinel = null;
let scrollObserver = null;

function setupInfiniteScroll() {
  // Remove old sentinel if exists
  if (scrollSentinel) scrollSentinel.remove();

  // Don't create sentinel if all Pokemon loaded
  if (currentOffset >= totalPokemon) return;

  // Create invisible sentinel element at bottom
  scrollSentinel = document.createElement('div');
  scrollSentinel.id = 'scroll-sentinel';
  scrollSentinel.style.cssText = `
    width: 100%;
    height: 1px;
    margin-top: 2rem;
  `;
  document.body.appendChild(scrollSentinel);

  // Create observer to detect when sentinel becomes visible
  if (scrollObserver) scrollObserver.disconnect();

  scrollObserver = new IntersectionObserver(
    (entries) => {
      entries.forEach(entry => {
        // When sentinel is visible and not already loading, load more
        if (entry.isIntersecting && !isLoading && currentOffset < totalPokemon) {
          console.log('📜 Reached bottom, loading more Pokemon...');
          loadMorePokemon();
        }
      });
    },
    {
      root: null,
      rootMargin: '400px', // Trigger 400px before reaching bottom
      threshold: 0
    }
  );

  scrollObserver.observe(scrollSentinel);
}

function updateLoadMoreButton() {
  // Show progress indicator at bottom
  let indicator = document.getElementById('load-progress');

  if (currentOffset >= totalPokemon) {
    if (indicator) indicator.remove();
    if (scrollSentinel) scrollSentinel.remove();

    // Show completion message
    let completeMsg = document.getElementById('complete-message');
    if (!completeMsg) {
      completeMsg = document.createElement('div');
      completeMsg.id = 'complete-message';
      completeMsg.style.cssText = `
        text-align: center;
        padding: 2rem;
        color: var(--color-secondary);
        font-weight: 600;
        font-size: 1.1rem;
      `;
      completeMsg.innerHTML = `
        🎉 All ${totalPokemon} Pokemon Loaded!
      `;
      document.body.appendChild(completeMsg);
    }
    return;
  }

  if (!indicator) {
    indicator = document.createElement('div');
    indicator.id = 'load-progress';
    indicator.style.cssText = `
      text-align: center;
      padding: 1rem;
      color: var(--color-text-light);
      font-size: 0.875rem;
      font-weight: 600;
    `;
    document.body.appendChild(indicator);
  }

  indicator.textContent = `Loaded ${currentOffset} of ${totalPokemon} Pokemon`;

  // Setup infinite scroll for next batch
  setupInfiniteScroll();
}

function showError(message) {
  const error = document.createElement('div');
  error.className = 'empty-state';
  error.innerHTML = `
    <div class="empty-state-icon">❌</div>
    <h2 class="empty-state-title">Error</h2>
    <p class="empty-state-description">${message}</p>
  `;
  pokedex.appendChild(error);
}

// ============================================
// FILTERING & SEARCH SYSTEM
// ============================================
let currentFilters = {
  searchText: '',
  types: [],
  sortBy: 'id',
  sortOrder: 'asc'
};

// Favorites stored in localStorage
let favoritePokemon = JSON.parse(localStorage.getItem('favoritePokemon') || '[]');

// Get all unique types
function getAllTypes() {
  const typesSet = new Set();
  pokemonList.forEach(pokemon => pokemon.types.forEach(type => typesSet.add(type)));
  return Array.from(typesSet).sort();
}

// Fuzzy matching for search
function fuzzyMatch(text, search) {
  const textLower = text.toLowerCase();
  const searchLower = search.toLowerCase();
  if (textLower.includes(searchLower)) return true;
  let searchIndex = 0;
  for (let i = 0; i < textLower.length && searchIndex < searchLower.length; i++) {
    if (textLower[i] === searchLower[searchIndex]) searchIndex++;
  }
  return searchIndex === searchLower.length;
}

// Filter Pokemon
function filterPokemon() {
  let filtered = [...pokemonList];

  if (currentFilters.searchText) {
    filtered = filtered.filter(pokemon =>
      fuzzyMatch(pokemon.name, currentFilters.searchText) ||
      pokemon.id.toString().includes(currentFilters.searchText)
    );
  }

  if (currentFilters.types.length > 0) {
    filtered = filtered.filter(pokemon =>
      currentFilters.types.some(type =>
        pokemon.types.map(t => t.toLowerCase()).includes(type.toLowerCase())
      )
    );
  }

  filtered.sort((a, b) => {
    let comparison = 0;
    switch(currentFilters.sortBy) {
      case 'name': comparison = a.name.localeCompare(b.name); break;
      case 'id': comparison = a.id - b.id; break;
      case 'hp': comparison = a.stats.hp - b.stats.hp; break;
      case 'attack': comparison = a.stats.attack - b.stats.attack; break;
      case 'speed': comparison = a.stats.speed - b.stats.speed; break;
    }
    return currentFilters.sortOrder === 'desc' ? -comparison : comparison;
  });

  return filtered;
}

// Toggle type filter
function toggleTypeFilter(type) {
  const index = currentFilters.types.indexOf(type);
  if (index === -1) {
    currentFilters.types.push(type);
  } else {
    currentFilters.types.splice(index, 1);
  }
  updateFilterChips();
  renderPokemon();
}

// Clear all filters
function clearFilters() {
  currentFilters.searchText = '';
  currentFilters.types = [];
  document.getElementById('pokemon-search').value = '';
  updateFilterChips();
  renderPokemon();
}

// Update filter chips display
function updateFilterChips() {
  const container = document.getElementById('type-filters');
  const allTypes = getAllTypes();

  let html = '';
  allTypes.forEach(type => {
    const isActive = currentFilters.types.includes(type);
    html += `
      <button
        class="filter-chip ${isActive ? 'active' : ''}"
        onclick="toggleTypeFilter('${type}')"
        aria-pressed="${isActive}"
      >
        ${type}
      </button>
    `;
  });

  if (currentFilters.types.length > 0 || currentFilters.searchText) {
    html += `
      <button
        class="filter-chip"
        onclick="clearFilters()"
        style="background: #ff6b6b; color: white; border-color: #ff6b6b;"
      >
        Clear ✕
      </button>
    `;
  }

  container.innerHTML = html;
}

// Toggle favorite
function toggleFavorite(pokemonId, event) {
  if (event) event.stopPropagation();
  const index = favoritePokemon.indexOf(pokemonId);
  if (index > -1) {
    favoritePokemon.splice(index, 1);
  } else {
    favoritePokemon.push(pokemonId);
  }
  localStorage.setItem('favoritePokemon', JSON.stringify(favoritePokemon));
  renderPokemon();
}

// Render filtered Pokemon
function renderPokemon() {
  pokedex.innerHTML = '';
  const filtered = filterPokemon();

  document.getElementById('result-count').textContent = `Showing ${filtered.length} Pokemon`;

  if (filtered.length === 0) {
    pokedex.innerHTML = `
      <div class="empty-state">
        <div class="empty-state-icon">🔍</div>
        <h2 class="empty-state-title">No Pokemon Found</h2>
        <p class="empty-state-description">Try adjusting your search or filters</p>
      </div>
    `;
    return;
  }

  filtered.forEach(displayPokemon);
  updateLoadMoreButton();
}

function displayPokemon(pokemon) {
  const card = document.createElement('div');
  card.className = 'pokemon-card';
  const isFavorite = favoritePokemon.includes(pokemon.id);

  const typeBadges = pokemon.types
    .map(type => `<span class="type-badge type-${type.toLowerCase()}">${type}</span>`)
    .join('');

  card.innerHTML = `
    <span class="pokemon-id">#${String(pokemon.id).padStart(3, '0')}</span>
    <button
      class="favorite-btn ${isFavorite ? 'is-favorite' : ''}"
      onclick="toggleFavorite(${pokemon.id}, event)"
      title="${isFavorite ? 'Remove from' : 'Add to'} favorites"
      style="position: absolute; top: 0.5rem; right: 0.5rem; background: rgba(255,255,255,0.9); border: none; border-radius: 50%; width: 36px; height: 36px; font-size: 1.25rem; cursor: pointer; box-shadow: 0 2px 4px rgba(0,0,0,0.1); z-index: 10; transition: all 0.2s;"
    >
      ${isFavorite ? '⭐' : '☆'}
    </button>
    <img src="${pokemon.imageUrl}" alt="${pokemon.name}">
    <h3>${pokemon.name}</h3>
    <div class="pokemon-types">
      ${typeBadges}
    </div>
  `;
  card.addEventListener('click', () => showDetails(pokemon));
  pokedex.appendChild(card);
}

function showDetails(pokemon) {
  detailImage.src = pokemon.imageUrl;
  detailName.textContent = pokemon.name;
  detailTypes.textContent = `Types: ${pokemon.types.join(', ')}`;

  detailStats.innerHTML = '';
  for (const stat in pokemon.stats) {
    const statBar = document.createElement('div');
    statBar.className = 'stat-bar';
    const statValue = document.createElement('div');
    statValue.className = 'stat-value';
    statValue.style.width = `${pokemon.stats[stat]}%`;
    statValue.textContent = `${stat}: ${pokemon.stats[stat]}`;
    statBar.appendChild(statValue);
    detailStats.appendChild(statBar);
  }

  details.style.display = 'block';
  overlay.style.display = 'block';
}

function closeDetails() {
  details.style.display = 'none';
  overlay.style.display = 'none';
}

// Initialize search and filters
document.getElementById('pokemon-search').addEventListener('input', (e) => {
  currentFilters.searchText = e.target.value;
  renderPokemon();
});

document.getElementById('sort-select').addEventListener('change', (e) => {
  currentFilters.sortBy = e.target.value;
  renderPokemon();
});

document.getElementById('sort-order-btn').addEventListener('click', () => {
  currentFilters.sortOrder = currentFilters.sortOrder === 'asc' ? 'desc' : 'asc';
  document.getElementById('sort-order-btn').textContent =
    currentFilters.sortOrder === 'asc' ? '↑ Asc' : '↓ Desc';
  renderPokemon();
});

// Export favorites
function exportFavorites() {
  const exportData = {
    version: '1.0',
    timestamp: new Date().toISOString(),
    favorites: favoritePokemon,
    pokemon: pokemonList.filter(p => favoritePokemon.includes(p.id))
  };
  const dataStr = JSON.stringify(exportData, null, 2);
  const blob = new Blob([dataStr], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.download = `pokedex-favorites-${Date.now()}.json`;
  link.href = url;
  link.click();
  URL.revokeObjectURL(url);
  alert('Favorites exported!');
}

// Import favorites
function importFavorites() {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = 'application/json';
  input.onchange = (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (event) => {
      try {
        const importData = JSON.parse(event.target.result);
        if (importData.favorites && Array.isArray(importData.favorites)) {
          favoritePokemon = [...new Set([...favoritePokemon, ...importData.favorites])];
          localStorage.setItem('favoritePokemon', JSON.stringify(favoritePokemon));
          alert(`Imported ${importData.favorites.length} favorites!`);
          renderPokemon();
        } else {
          alert('Invalid file format');
        }
      } catch (err) {
        alert('Error reading file');
      }
    };
    reader.readAsText(file);
  };
  input.click();
}

// Add export/import buttons
const exportImportContainer = document.createElement('div');
exportImportContainer.style.cssText = 'text-align: center; margin: 1rem auto; max-width: 1200px;';
exportImportContainer.innerHTML = `
  <button onclick="exportFavorites()" style="padding: 0.75rem 1.5rem; margin: 0.5rem; background: #4ECDC4; color: white; border: none; border-radius: 9999px; cursor: pointer; font-weight: 600;">
    📥 Export Favorites
  </button>
  <button onclick="importFavorites()" style="padding: 0.75rem 1.5rem; margin: 0.5rem; background: #FFE66D; color: #2D3748; border: none; border-radius: 9999px; cursor: pointer; font-weight: 600;">
    📤 Import Favorites
  </button>
  <button onclick="viewFavorites()" id="view-favorites-btn" style="padding: 0.75rem 1.5rem; margin: 0.5rem; background: #FF6B6B; color: white; border: none; border-radius: 9999px; cursor: pointer; font-weight: 600;">
    ⭐ View Favorites (${favoritePokemon.length})
  </button>
`;
document.body.insertBefore(exportImportContainer, pokedex);

// View favorites toggle
let showingFavorites = false;
function viewFavorites() {
  showingFavorites = !showingFavorites;
  const btn = document.getElementById('view-favorites-btn');
  if (showingFavorites) {
    btn.textContent = `🏠 View All`;
    btn.style.background = '#667eea';
    pokedex.innerHTML = '';
    const favorites = pokemonList.filter(p => favoritePokemon.includes(p.id));
    if (favorites.length === 0) {
      pokedex.innerHTML = `
        <div class="empty-state">
          <div class="empty-state-icon">⭐</div>
          <h2 class="empty-state-title">No Favorites Yet</h2>
          <p class="empty-state-description">Click the star on Pokemon cards to add favorites</p>
        </div>
      `;
    } else {
      favorites.forEach(displayPokemon);
    }
  } else {
    btn.textContent = `⭐ View Favorites (${favoritePokemon.length})`;
    btn.style.background = '#FF6B6B';
    renderPokemon();
  }
}

// Initialize - Load first batch of Pokemon
async function initialize() {
  console.log('🚀 Initializing Pokedex...');
  updateFilterChips();

  // Show initial loading state
  pokedex.innerHTML = `
    <div class="empty-state">
      <div class="loading-spinner"></div>
      <h2 class="empty-state-title" style="margin-top: 2rem;">Loading Pokemon...</h2>
      <p class="empty-state-description">Fetching data from PokeAPI</p>
    </div>
  `;

  try {
    await loadMorePokemon();
    console.log('✅ Initial load complete! Infinite scroll enabled.');

    // Setup infinite scroll after first load
    setupInfiniteScroll();
  } catch (error) {
    console.error('Failed to initialize:', error);
    pokedex.innerHTML = `
      <div class="empty-state">
        <div class="empty-state-icon">❌</div>
        <h2 class="empty-state-title">Failed to Load Pokemon</h2>
        <p class="empty-state-description">Please check your internet connection and refresh the page.</p>
      </div>
    `;
  }
}

initialize();
</script>
</body>
</html>