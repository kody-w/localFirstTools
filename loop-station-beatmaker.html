<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Professional loop station and beatmaker with 8-track recording, built-in instruments, effects chain, and pattern sequencer using Web Audio API">
    <title>Loop Station & Beatmaker</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f0f1e 0%, #1a1a2e 100%);
            color: #e0e0e0;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: rgba(0, 0, 0, 0.9);
            padding: 12px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #ff006e;
            z-index: 100;
        }

        .header h1 {
            font-size: 1.4rem;
            background: linear-gradient(45deg, #ff006e, #fb5607, #ffbe0b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .transport-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .bpm-control {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(255, 255, 255, 0.1);
            padding: 6px 12px;
            border-radius: 6px;
        }

        .bpm-control input {
            width: 60px;
            background: transparent;
            border: none;
            color: #ffbe0b;
            font-size: 1.2rem;
            font-weight: bold;
            text-align: center;
        }

        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .tracks-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 20px;
            overflow-y: auto;
            gap: 10px;
        }

        .track {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 12px;
            display: grid;
            grid-template-columns: 60px 1fr 200px;
            gap: 12px;
            align-items: center;
            transition: all 0.3s;
        }

        .track.recording {
            border-color: #ff006e;
            box-shadow: 0 0 20px rgba(255, 0, 110, 0.3);
        }

        .track.playing {
            border-color: #00f5ff;
        }

        .track-label {
            font-weight: bold;
            color: #ffbe0b;
            font-size: 0.9rem;
        }

        .track-waveform {
            height: 60px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 4px;
            position: relative;
            overflow: hidden;
        }

        .track-waveform canvas {
            width: 100%;
            height: 100%;
        }

        .track-controls {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 6px;
        }

        .track-btn {
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.75rem;
            transition: all 0.2s;
            font-weight: 600;
        }

        .track-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
        }

        .track-btn.active {
            background: #ff006e;
            border-color: #ff006e;
        }

        .track-btn.record {
            background: rgba(255, 0, 110, 0.3);
        }

        .track-btn.record:hover, .track-btn.record.active {
            background: #ff006e;
        }

        .track-sliders {
            display: flex;
            gap: 8px;
            margin-top: 6px;
        }

        .slider-group {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .slider-group label {
            font-size: 0.7rem;
            color: #888;
            margin-bottom: 4px;
        }

        .slider-group input[type="range"] {
            width: 100%;
            height: 4px;
            background: #333;
            outline: none;
            border-radius: 2px;
            -webkit-appearance: none;
        }

        .slider-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: #ff006e;
            cursor: pointer;
            border-radius: 50%;
        }

        .slider-group input[type="range"]::-moz-range-thumb {
            width: 12px;
            height: 12px;
            background: #ff006e;
            cursor: pointer;
            border-radius: 50%;
            border: none;
        }

        .instruments-panel {
            width: 350px;
            background: rgba(0, 0, 0, 0.8);
            border-left: 2px solid #ff006e;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        .instrument-section {
            padding: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .instrument-section h3 {
            color: #ffbe0b;
            margin-bottom: 15px;
            font-size: 1rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .drum-pads {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
        }

        .drum-pad {
            aspect-ratio: 1;
            background: linear-gradient(135deg, rgba(255, 0, 110, 0.3), rgba(251, 86, 7, 0.3));
            border: 2px solid rgba(255, 0, 110, 0.5);
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: all 0.1s;
            color: #fff;
            font-weight: bold;
            font-size: 0.75rem;
        }

        .drum-pad:hover {
            background: linear-gradient(135deg, rgba(255, 0, 110, 0.6), rgba(251, 86, 7, 0.6));
            transform: scale(1.05);
        }

        .drum-pad:active, .drum-pad.active {
            transform: scale(0.95);
            box-shadow: 0 0 20px rgba(255, 0, 110, 0.6);
        }

        .drum-pad .key-hint {
            font-size: 0.6rem;
            color: #888;
            margin-top: 4px;
        }

        .synth-keyboard {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 6px;
        }

        .synth-key {
            padding: 20px 10px;
            background: linear-gradient(135deg, rgba(0, 245, 255, 0.3), rgba(123, 47, 247, 0.3));
            border: 2px solid rgba(0, 245, 255, 0.5);
            border-radius: 6px;
            cursor: pointer;
            text-align: center;
            transition: all 0.1s;
            color: #fff;
            font-weight: bold;
            font-size: 0.8rem;
        }

        .synth-key:hover {
            background: linear-gradient(135deg, rgba(0, 245, 255, 0.6), rgba(123, 47, 247, 0.6));
        }

        .synth-key:active, .synth-key.active {
            transform: scale(0.95);
            box-shadow: 0 0 15px rgba(0, 245, 255, 0.6);
        }

        .synth-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 12px;
        }

        .synth-control {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .synth-control label {
            font-size: 0.8rem;
            color: #aaa;
        }

        .synth-control select {
            padding: 4px 8px;
            background: #222;
            color: #fff;
            border: 1px solid #444;
            border-radius: 4px;
        }

        .effects-section {
            padding: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .effects-section h3 {
            color: #00f5ff;
            margin-bottom: 15px;
            font-size: 1rem;
        }

        .effect-control {
            margin-bottom: 15px;
        }

        .effect-control label {
            display: block;
            font-size: 0.8rem;
            color: #aaa;
            margin-bottom: 6px;
        }

        .effect-control input[type="range"] {
            width: 100%;
        }

        .effect-toggle {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .toggle-switch {
            position: relative;
            width: 50px;
            height: 24px;
            background: #333;
            border-radius: 12px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .toggle-switch.active {
            background: #00f5ff;
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 20px;
            height: 20px;
            background: #fff;
            border-radius: 50%;
            transition: transform 0.3s;
        }

        .toggle-switch.active::after {
            transform: translateX(26px);
        }

        .transport-bar {
            background: rgba(0, 0, 0, 0.9);
            padding: 15px 20px;
            border-top: 2px solid #ff006e;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 20px;
        }

        .transport-buttons {
            display: flex;
            gap: 10px;
        }

        .transport-btn {
            padding: 12px 24px;
            background: linear-gradient(135deg, #ff006e, #fb5607);
            border: none;
            color: #fff;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 700;
            transition: all 0.3s;
            text-transform: uppercase;
            font-size: 0.85rem;
        }

        .transport-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(255, 0, 110, 0.4);
        }

        .transport-btn.active {
            background: #00ff88;
            color: #000;
        }

        .master-controls {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .master-volume {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .master-volume label {
            font-size: 0.75rem;
            color: #888;
        }

        .master-volume input[type="range"] {
            width: 150px;
        }

        .action-buttons {
            display: flex;
            gap: 8px;
        }

        .action-btn {
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.2s;
        }

        .action-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .metronome-indicator {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            transition: all 0.1s;
        }

        .metronome-indicator.beat {
            background: #ffbe0b;
            box-shadow: 0 0 20px #ffbe0b;
        }

        .pattern-sequencer {
            padding: 20px;
            display: none;
        }

        .pattern-sequencer.active {
            display: block;
        }

        .pattern-grid {
            display: grid;
            grid-template-columns: 80px repeat(16, 1fr);
            gap: 2px;
            margin-top: 10px;
        }

        .pattern-row-label {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            color: #aaa;
        }

        .pattern-step {
            aspect-ratio: 1;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.1s;
        }

        .pattern-step.active {
            background: #ff006e;
        }

        .pattern-step.playing {
            border-color: #ffbe0b;
            border-width: 2px;
        }

        @media (max-width: 1024px) {
            .instruments-panel {
                width: 300px;
            }

            .track {
                grid-template-columns: 50px 1fr 180px;
            }
        }

        @media (max-width: 768px) {
            .main-container {
                flex-direction: column;
            }

            .instruments-panel {
                width: 100%;
                max-height: 300px;
            }
        }

        .countdown-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .countdown-overlay.active {
            display: flex;
        }

        .countdown-number {
            font-size: 10rem;
            font-weight: bold;
            color: #ff006e;
            animation: pulse 1s ease-in-out;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.8; }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Loop Station & Beatmaker</h1>
        <div class="transport-controls">
            <div class="bpm-control">
                <label>BPM:</label>
                <input type="number" id="bpmInput" value="120" min="60" max="200" onchange="updateBPM()">
            </div>
            <div class="metronome-indicator" id="metronomeIndicator"></div>
        </div>
    </div>

    <div class="main-container">
        <div class="tracks-section" id="tracksSection">
            <!-- Tracks will be dynamically generated -->
        </div>

        <div class="instruments-panel">
            <div class="instrument-section">
                <h3>Drum Kit</h3>
                <div class="drum-pads" id="drumPads">
                    <!-- Drum pads will be generated -->
                </div>
            </div>

            <div class="instrument-section">
                <h3>Bass Synth</h3>
                <div class="synth-keyboard" id="bassKeys">
                    <!-- Bass keys will be generated -->
                </div>
                <div class="synth-controls">
                    <div class="synth-control">
                        <label>Waveform:</label>
                        <select id="bassWaveform" onchange="updateBassWaveform()">
                            <option value="sine">Sine</option>
                            <option value="square">Square</option>
                            <option value="sawtooth" selected>Sawtooth</option>
                            <option value="triangle">Triangle</option>
                        </select>
                    </div>
                </div>
            </div>

            <div class="instrument-section">
                <h3>Lead Synth</h3>
                <div class="synth-keyboard" id="leadKeys">
                    <!-- Lead keys will be generated -->
                </div>
                <div class="synth-controls">
                    <div class="synth-control">
                        <label>Waveform:</label>
                        <select id="leadWaveform" onchange="updateLeadWaveform()">
                            <option value="sine">Sine</option>
                            <option value="square" selected>Square</option>
                            <option value="sawtooth">Sawtooth</option>
                            <option value="triangle">Triangle</option>
                        </select>
                    </div>
                    <div class="synth-control">
                        <label>Octave:</label>
                        <select id="leadOctave" onchange="updateLeadOctave()">
                            <option value="3">3</option>
                            <option value="4" selected>4</option>
                            <option value="5">5</option>
                            <option value="6">6</option>
                        </select>
                    </div>
                </div>
            </div>

            <div class="effects-section">
                <h3>Master Effects</h3>
                <div class="effect-toggle">
                    <label>Reverb</label>
                    <div class="toggle-switch" id="reverbToggle" onclick="toggleEffect('reverb')"></div>
                </div>
                <div class="effect-control">
                    <label>Reverb Mix</label>
                    <input type="range" id="reverbMix" min="0" max="100" value="30" oninput="updateReverbMix()">
                </div>
                <div class="effect-toggle">
                    <label>Delay</label>
                    <div class="toggle-switch" id="delayToggle" onclick="toggleEffect('delay')"></div>
                </div>
                <div class="effect-control">
                    <label>Delay Time</label>
                    <input type="range" id="delayTime" min="0" max="1" step="0.01" value="0.25" oninput="updateDelayTime()">
                </div>
                <div class="effect-control">
                    <label>Delay Feedback</label>
                    <input type="range" id="delayFeedback" min="0" max="0.9" step="0.1" value="0.3" oninput="updateDelayFeedback()">
                </div>
            </div>
        </div>
    </div>

    <div class="transport-bar">
        <div class="transport-buttons">
            <button class="transport-btn" id="metronomeBtn" onclick="toggleMetronome()">Metronome</button>
            <button class="transport-btn" onclick="clearAllTracks()">Clear All</button>
        </div>
        <div class="master-controls">
            <div class="master-volume">
                <label>Master Volume</label>
                <input type="range" id="masterVolume" min="0" max="100" value="80" oninput="updateMasterVolume()">
            </div>
        </div>
        <div class="action-buttons">
            <button class="action-btn" onclick="exportMasterMix()">Export Mix</button>
            <button class="action-btn" onclick="saveProject()">Save Project</button>
            <button class="action-btn" onclick="loadProject()">Load Project</button>
        </div>
    </div>

    <div class="countdown-overlay" id="countdownOverlay">
        <div class="countdown-number" id="countdownNumber">3</div>
    </div>

    <script>
        // Audio context and nodes
        let audioContext;
        let masterGain;
        let effectsChain = {};
        let tracks = [];
        let metronomeActive = false;
        let bpm = 120;
        let loopLength = 4; // bars
        let beatsPerBar = 4;
        let currentBeat = 0;
        let metronomeInterval;

        // Instrument settings
        let bassWaveform = 'sawtooth';
        let leadWaveform = 'square';
        let leadOctave = 4;

        // Drum samples (using oscillators for now)
        const drumKits = {
            kick: { type: 'sine', freq: 60, decay: 0.5 },
            snare: { type: 'triangle', freq: 200, decay: 0.2, noise: true },
            hihat: { type: 'square', freq: 8000, decay: 0.05 },
            clap: { type: 'square', freq: 400, decay: 0.15, noise: true },
            tom: { type: 'sine', freq: 150, decay: 0.3 },
            crash: { type: 'square', freq: 5000, decay: 0.8, noise: true },
            ride: { type: 'square', freq: 3000, decay: 0.3 },
            shaker: { type: 'square', freq: 10000, decay: 0.1 }
        };

        const drumPadKeys = ['q', 'w', 'e', 'r', 't', 'y', 'u', 'i'];
        const bassKeys = ['a', 's', 'd', 'f', 'g', 'h', 'j', 'k'];
        const leadKeys = ['z', 'x', 'c', 'v', 'b', 'n', 'm', ','];

        // Track class
        class Track {
            constructor(id, name) {
                this.id = id;
                this.name = name;
                this.buffer = null;
                this.source = null;
                this.gainNode = null;
                this.panNode = null;
                this.isRecording = false;
                this.isMuted = false;
                this.isSolo = false;
                this.volume = 0.8;
                this.pan = 0;
                this.recordedChunks = [];
                this.mediaRecorder = null;
                this.waveformCanvas = null;
            }

            async startRecording() {
                if (!audioContext) initAudioContext();

                this.isRecording = true;
                this.recordedChunks = [];

                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                this.mediaRecorder = new MediaRecorder(stream);

                this.mediaRecorder.ondataavailable = (e) => {
                    if (e.data.size > 0) {
                        this.recordedChunks.push(e.data);
                    }
                };

                this.mediaRecorder.onstop = async () => {
                    const blob = new Blob(this.recordedChunks, { type: 'audio/webm' });
                    const arrayBuffer = await blob.arrayBuffer();
                    this.buffer = await audioContext.decodeAudioData(arrayBuffer);
                    this.drawWaveform();
                    stream.getTracks().forEach(track => track.stop());
                };

                this.mediaRecorder.start();

                // Auto-stop after loop length
                const loopDuration = (60 / bpm) * beatsPerBar * loopLength * 1000;
                setTimeout(() => {
                    if (this.isRecording) {
                        this.stopRecording();
                    }
                }, loopDuration);
            }

            stopRecording() {
                if (this.mediaRecorder && this.isRecording) {
                    this.mediaRecorder.stop();
                    this.isRecording = false;
                }
            }

            play() {
                if (!this.buffer || this.isMuted) return;

                this.stop();

                this.source = audioContext.createBufferSource();
                this.source.buffer = this.buffer;
                this.source.loop = true;

                this.gainNode = audioContext.createGain();
                this.gainNode.gain.value = this.volume;

                this.panNode = audioContext.createStereoPanner();
                this.panNode.pan.value = this.pan;

                this.source.connect(this.gainNode);
                this.gainNode.connect(this.panNode);
                this.panNode.connect(effectsChain.input);

                this.source.start();
            }

            stop() {
                if (this.source) {
                    try {
                        this.source.stop();
                    } catch (e) {}
                    this.source = null;
                }
            }

            clear() {
                this.stop();
                this.buffer = null;
                this.recordedChunks = [];
                if (this.waveformCanvas) {
                    const ctx = this.waveformCanvas.getContext('2d');
                    ctx.clearRect(0, 0, this.waveformCanvas.width, this.waveformCanvas.height);
                }
            }

            drawWaveform() {
                if (!this.buffer || !this.waveformCanvas) return;

                const canvas = this.waveformCanvas;
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;

                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(0, 0, width, height);

                const data = this.buffer.getChannelData(0);
                const step = Math.ceil(data.length / width);
                const amp = height / 2;

                ctx.strokeStyle = '#00f5ff';
                ctx.lineWidth = 1;
                ctx.beginPath();

                for (let i = 0; i < width; i++) {
                    let min = 1.0;
                    let max = -1.0;

                    for (let j = 0; j < step; j++) {
                        const datum = data[(i * step) + j];
                        if (datum < min) min = datum;
                        if (datum > max) max = datum;
                    }

                    ctx.moveTo(i, (1 + min) * amp);
                    ctx.lineTo(i, (1 + max) * amp);
                }

                ctx.stroke();
            }
        }

        // Initialize audio context
        function initAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();

                // Create master gain
                masterGain = audioContext.createGain();
                masterGain.gain.value = 0.8;
                masterGain.connect(audioContext.destination);

                // Create effects chain
                effectsChain.input = audioContext.createGain();

                // Reverb (using convolver)
                effectsChain.reverb = audioContext.createConvolver();
                effectsChain.reverbGain = audioContext.createGain();
                effectsChain.reverbGain.gain.value = 0.3;
                createReverbImpulse();

                // Delay
                effectsChain.delay = audioContext.createDelay();
                effectsChain.delay.delayTime.value = 0.25;
                effectsChain.delayFeedback = audioContext.createGain();
                effectsChain.delayFeedback.gain.value = 0.3;
                effectsChain.delayGain = audioContext.createGain();
                effectsChain.delayGain.gain.value = 0;

                // Connect effects chain
                effectsChain.input.connect(masterGain);

                // Reverb chain
                effectsChain.input.connect(effectsChain.reverb);
                effectsChain.reverb.connect(effectsChain.reverbGain);
                effectsChain.reverbGain.connect(masterGain);

                // Delay chain
                effectsChain.input.connect(effectsChain.delay);
                effectsChain.delay.connect(effectsChain.delayFeedback);
                effectsChain.delayFeedback.connect(effectsChain.delay);
                effectsChain.delay.connect(effectsChain.delayGain);
                effectsChain.delayGain.connect(masterGain);
            }
        }

        function createReverbImpulse() {
            const length = audioContext.sampleRate * 2;
            const impulse = audioContext.createBuffer(2, length, audioContext.sampleRate);
            const left = impulse.getChannelData(0);
            const right = impulse.getChannelData(1);

            for (let i = 0; i < length; i++) {
                left[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2);
                right[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2);
            }

            effectsChain.reverb.buffer = impulse;
        }

        // Initialize tracks
        function initTracks() {
            const tracksSection = document.getElementById('tracksSection');

            for (let i = 1; i <= 8; i++) {
                const track = new Track(i, `Track ${i}`);
                tracks.push(track);

                const trackEl = document.createElement('div');
                trackEl.className = 'track';
                trackEl.innerHTML = `
                    <div class="track-label">Track ${i}</div>
                    <div class="track-waveform">
                        <canvas id="waveform${i}" width="800" height="60"></canvas>
                    </div>
                    <div>
                        <div class="track-controls">
                            <button class="track-btn record" onclick="recordTrack(${i})">REC</button>
                            <button class="track-btn" onclick="playTrack(${i})">PLAY</button>
                            <button class="track-btn" onclick="muteTrack(${i})">MUTE</button>
                            <button class="track-btn" onclick="clearTrack(${i})">CLEAR</button>
                        </div>
                        <div class="track-sliders">
                            <div class="slider-group">
                                <label>Vol</label>
                                <input type="range" min="0" max="100" value="80" oninput="updateTrackVolume(${i}, this.value)">
                            </div>
                            <div class="slider-group">
                                <label>Pan</label>
                                <input type="range" min="-100" max="100" value="0" oninput="updateTrackPan(${i}, this.value)">
                            </div>
                        </div>
                    </div>
                `;
                tracksSection.appendChild(trackEl);

                track.waveformCanvas = document.getElementById(`waveform${i}`);
            }
        }

        // Initialize drum pads
        function initDrumPads() {
            const drumPadsContainer = document.getElementById('drumPads');
            const drumNames = Object.keys(drumKits);

            drumNames.forEach((name, index) => {
                const pad = document.createElement('div');
                pad.className = 'drum-pad';
                pad.innerHTML = `
                    ${name.toUpperCase()}
                    <div class="key-hint">${drumPadKeys[index].toUpperCase()}</div>
                `;
                pad.onclick = () => playDrum(name);
                drumPadsContainer.appendChild(pad);
            });
        }

        // Initialize synth keyboards
        function initSynthKeyboards() {
            const bassContainer = document.getElementById('bassKeys');
            const leadContainer = document.getElementById('leadKeys');

            const bassNotes = [55, 58.27, 61.74, 65.41, 69.3, 73.42, 77.78, 82.41]; // A1 to E2
            const leadNotes = [261.63, 293.66, 329.63, 349.23, 392, 440, 493.88, 523.25]; // C4 to C5

            bassNotes.forEach((freq, index) => {
                const key = document.createElement('div');
                key.className = 'synth-key';
                key.textContent = bassKeys[index].toUpperCase();
                key.onclick = () => playBass(freq);
                bassContainer.appendChild(key);
            });

            leadNotes.forEach((freq, index) => {
                const key = document.createElement('div');
                key.className = 'synth-key';
                key.textContent = leadKeys[index].toUpperCase();
                key.onclick = () => playLead(freq);
                leadContainer.appendChild(key);
            });
        }

        // Play drum sound
        function playDrum(drumName) {
            if (!audioContext) initAudioContext();

            const drum = drumKits[drumName];
            const now = audioContext.currentTime;

            if (drum.noise) {
                // Create noise for snare/clap/crash
                const bufferSize = audioContext.sampleRate * drum.decay;
                const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                const data = buffer.getChannelData(0);

                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }

                const noise = audioContext.createBufferSource();
                noise.buffer = buffer;

                const filter = audioContext.createBiquadFilter();
                filter.type = 'bandpass';
                filter.frequency.value = drum.freq;

                const gain = audioContext.createGain();
                gain.gain.setValueAtTime(0.3, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + drum.decay);

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(effectsChain.input);

                noise.start(now);
                noise.stop(now + drum.decay);
            } else {
                // Create tonal drum
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();

                osc.type = drum.type;
                osc.frequency.setValueAtTime(drum.freq, now);
                osc.frequency.exponentialRampToValueAtTime(drum.freq * 0.01, now + drum.decay);

                gain.gain.setValueAtTime(0.5, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + drum.decay);

                osc.connect(gain);
                gain.connect(effectsChain.input);

                osc.start(now);
                osc.stop(now + drum.decay);
            }

            // Visual feedback
            const padIndex = Object.keys(drumKits).indexOf(drumName);
            const pad = document.querySelectorAll('.drum-pad')[padIndex];
            if (pad) {
                pad.classList.add('active');
                setTimeout(() => pad.classList.remove('active'), 100);
            }
        }

        // Play bass synth
        function playBass(frequency) {
            if (!audioContext) initAudioContext();

            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();

            osc.type = bassWaveform;
            osc.frequency.value = frequency;

            filter.type = 'lowpass';
            filter.frequency.value = 800;

            gain.gain.setValueAtTime(0.4, audioContext.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);

            osc.connect(filter);
            filter.connect(gain);
            gain.connect(effectsChain.input);

            osc.start();
            osc.stop(audioContext.currentTime + 0.5);
        }

        // Play lead synth
        function playLead(frequency) {
            if (!audioContext) initAudioContext();

            const adjustedFreq = frequency * Math.pow(2, leadOctave - 4);

            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();

            osc.type = leadWaveform;
            osc.frequency.value = adjustedFreq;

            gain.gain.setValueAtTime(0.3, audioContext.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);

            osc.connect(gain);
            gain.connect(effectsChain.input);

            osc.start();
            osc.stop(audioContext.currentTime + 0.3);
        }

        // Keyboard control
        document.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT' || e.repeat) return;

            const key = e.key.toLowerCase();

            // Drum pads
            const drumIndex = drumPadKeys.indexOf(key);
            if (drumIndex !== -1) {
                const drumName = Object.keys(drumKits)[drumIndex];
                playDrum(drumName);
            }

            // Bass keys
            const bassIndex = bassKeys.indexOf(key);
            if (bassIndex !== -1) {
                const bassNotes = [55, 58.27, 61.74, 65.41, 69.3, 73.42, 77.78, 82.41];
                playBass(bassNotes[bassIndex]);
            }

            // Lead keys
            const leadIndex = leadKeys.indexOf(key);
            if (leadIndex !== -1) {
                const leadNotes = [261.63, 293.66, 329.63, 349.23, 392, 440, 493.88, 523.25];
                playLead(leadNotes[leadIndex]);
            }
        });

        // Track controls
        async function recordTrack(trackId) {
            const track = tracks[trackId - 1];
            if (track.isRecording) {
                track.stopRecording();
                return;
            }

            // Countdown
            await showCountdown();
            track.startRecording();
        }

        function playTrack(trackId) {
            const track = tracks[trackId - 1];
            track.play();
        }

        function muteTrack(trackId) {
            const track = tracks[trackId - 1];
            track.isMuted = !track.isMuted;
            if (track.isMuted) {
                track.stop();
            }
        }

        function clearTrack(trackId) {
            const track = tracks[trackId - 1];
            track.clear();
        }

        function updateTrackVolume(trackId, value) {
            const track = tracks[trackId - 1];
            track.volume = value / 100;
            if (track.gainNode) {
                track.gainNode.gain.value = track.volume;
            }
        }

        function updateTrackPan(trackId, value) {
            const track = tracks[trackId - 1];
            track.pan = value / 100;
            if (track.panNode) {
                track.panNode.pan.value = track.pan;
            }
        }

        function clearAllTracks() {
            if (confirm('Clear all tracks?')) {
                tracks.forEach(track => track.clear());
            }
        }

        // Countdown
        function showCountdown() {
            return new Promise((resolve) => {
                const overlay = document.getElementById('countdownOverlay');
                const number = document.getElementById('countdownNumber');
                let count = 3;

                overlay.classList.add('active');

                const interval = setInterval(() => {
                    number.textContent = count;
                    count--;

                    if (count < 0) {
                        clearInterval(interval);
                        overlay.classList.remove('active');
                        resolve();
                    }
                }, 1000);
            });
        }

        // Metronome
        function toggleMetronome() {
            metronomeActive = !metronomeActive;
            const btn = document.getElementById('metronomeBtn');

            if (metronomeActive) {
                btn.classList.add('active');
                startMetronome();
            } else {
                btn.classList.remove('active');
                stopMetronome();
            }
        }

        function startMetronome() {
            if (!audioContext) initAudioContext();

            const beatDuration = 60 / bpm;
            currentBeat = 0;

            metronomeInterval = setInterval(() => {
                playMetronomeClick(currentBeat === 0);
                currentBeat = (currentBeat + 1) % beatsPerBar;
            }, beatDuration * 1000);
        }

        function stopMetronome() {
            if (metronomeInterval) {
                clearInterval(metronomeInterval);
                metronomeInterval = null;
            }
        }

        function playMetronomeClick(isDownbeat) {
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();

            osc.frequency.value = isDownbeat ? 1000 : 800;
            gain.gain.setValueAtTime(0.3, audioContext.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.05);

            osc.connect(gain);
            gain.connect(audioContext.destination);

            osc.start();
            osc.stop(audioContext.currentTime + 0.05);

            // Visual feedback
            const indicator = document.getElementById('metronomeIndicator');
            indicator.classList.add('beat');
            setTimeout(() => indicator.classList.remove('beat'), 100);
        }

        function updateBPM() {
            bpm = parseInt(document.getElementById('bpmInput').value);
            if (metronomeActive) {
                stopMetronome();
                startMetronome();
            }
        }

        // Master controls
        function updateMasterVolume() {
            const value = parseInt(document.getElementById('masterVolume').value) / 100;
            if (masterGain) {
                masterGain.gain.value = value;
            }
        }

        // Effects
        function toggleEffect(effectName) {
            const toggle = document.getElementById(`${effectName}Toggle`);
            toggle.classList.toggle('active');

            if (effectName === 'reverb') {
                const isActive = toggle.classList.contains('active');
                effectsChain.reverbGain.gain.value = isActive ? 0.3 : 0;
            } else if (effectName === 'delay') {
                const isActive = toggle.classList.contains('active');
                effectsChain.delayGain.gain.value = isActive ? 0.5 : 0;
            }
        }

        function updateReverbMix() {
            const value = parseInt(document.getElementById('reverbMix').value) / 100;
            if (effectsChain.reverbGain) {
                effectsChain.reverbGain.gain.value = value;
            }
        }

        function updateDelayTime() {
            const value = parseFloat(document.getElementById('delayTime').value);
            if (effectsChain.delay) {
                effectsChain.delay.delayTime.value = value;
            }
        }

        function updateDelayFeedback() {
            const value = parseFloat(document.getElementById('delayFeedback').value);
            if (effectsChain.delayFeedback) {
                effectsChain.delayFeedback.gain.value = value;
            }
        }

        // Synth settings
        function updateBassWaveform() {
            bassWaveform = document.getElementById('bassWaveform').value;
        }

        function updateLeadWaveform() {
            leadWaveform = document.getElementById('leadWaveform').value;
        }

        function updateLeadOctave() {
            leadOctave = parseInt(document.getElementById('leadOctave').value);
        }

        // Export and save
        function exportMasterMix() {
            alert('Export functionality requires MediaRecorder. Playing all tracks and recording master output...');
            // Implementation would require recording master output while playing all tracks
        }

        function saveProject() {
            const project = {
                bpm: bpm,
                loopLength: loopLength,
                tracks: tracks.map(track => ({
                    name: track.name,
                    volume: track.volume,
                    pan: track.pan,
                    isMuted: track.isMuted
                })),
                settings: {
                    bassWaveform,
                    leadWaveform,
                    leadOctave
                }
            };

            const json = JSON.stringify(project, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `loop-station-project-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function loadProject() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const text = await file.text();
                const project = JSON.parse(text);

                // Restore project settings
                bpm = project.bpm;
                document.getElementById('bpmInput').value = bpm;

                if (project.settings) {
                    bassWaveform = project.settings.bassWaveform;
                    leadWaveform = project.settings.leadWaveform;
                    leadOctave = project.settings.leadOctave;

                    document.getElementById('bassWaveform').value = bassWaveform;
                    document.getElementById('leadWaveform').value = leadWaveform;
                    document.getElementById('leadOctave').value = leadOctave;
                }

                alert('Project loaded! Note: Audio buffers are not saved in this version.');
            };
            input.click();
        }

        // Initialize
        function init() {
            initTracks();
            initDrumPads();
            initSynthKeyboards();
        }

        init();
    </script>
</body>
</html>