<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Agent Workflow Executor</title>
    <style>
        :root {
            --primary-color: #6563ff;
            --primary-light: #9d9bff;
            --primary-dark: #4240d4;
            --secondary-color: #24b47e;
            --secondary-light: #4ccea3;
            --secondary-dark: #0c9660;
            --bg-color: #f7f9fb;
            --bg-dark: #edf1f5;
            --bg-darker: #e4e9f0;
            --bg-light: #ffffff;
            --text-color: #101214;
            --text-light: #4a4f55;
            --text-lighter: #737880;
            --text-highlight: #303540;
            --text-soft: #9095a0;
            --border-color: #e0e6ed;
            --border-dark: #ccd4de;
            --shadow-sm: 0 1px 2px rgba(10, 15, 30, 0.06);
            --shadow-md: 0 2px 4px rgba(10, 15, 30, 0.1);
            --shadow-lg: 0 8px 16px rgba(10, 15, 30, 0.1);
            --success-color: #00c853;
            --warning-color: #ffab00;
            --error-color: #f44336;
            --info-color: #2196f3;
            --font-main: system-ui, -apple-system, "Segoe UI", Roboto, Ubuntu, "Helvetica Neue", sans-serif;
            --font-mono: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;
            --node-width: 280px;
            --node-header-height: 44px;
            --node-border-radius: 8px;
            --panel-width: 320px;
            --sidebar-width: 75px;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: var(--font-main);
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: 1.5;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }

        .app-container {
            display: flex;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
        }

        /* Left sidebar */
        .sidebar {
            width: var(--sidebar-width);
            height: 100%;
            background-color: var(--bg-light);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 16px 0;
            box-shadow: var(--shadow-sm);
            z-index: 10;
        }

        .logo {
            width: 40px;
            height: 40px;
            margin-bottom: 24px;
            border-radius: 8px;
            background-color: var(--primary-color);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 24px;
            font-weight: bold;
        }

        .sidebar-menu {
            list-style: none;
            width: 100%;
        }

        .sidebar-item {
            width: 100%;
            height: 50px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin-bottom: 8px;
            cursor: pointer;
            position: relative;
            color: var(--text-lighter);
            font-size: 11px;
        }

        .sidebar-item.active {
            color: var(--primary-color);
        }

        .sidebar-item.active::before {
            content: '';
            position: absolute;
            left: 0;
            top: 6px;
            height: 38px;
            width: 3px;
            background-color: var(--primary-color);
            border-radius: 0 3px 3px 0;
        }

        .sidebar-icon {
            font-size: 20px;
            margin-bottom: 4px;
        }

        /* Main content */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            height: 100%;
            position: relative;
            overflow: hidden;
        }

        /* Top header */
        .top-header {
            height: 60px;
            background-color: var(--bg-light);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            padding: 0 20px;
            justify-content: space-between;
            box-shadow: var(--shadow-sm);
            z-index: 5;
        }

        .workflow-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-highlight);
            display: flex;
            align-items: center;
        }

        .workflow-title .icon {
            margin-right: 10px;
            color: var(--primary-color);
        }

        .header-actions {
            display: flex;
            gap: 12px;
        }

        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            border: none;
            transition: all 0.2s ease;
            gap: 8px;
        }

        .btn-primary {
            background-color: var(--primary-color);
            color: white;
        }

        .btn-primary:hover {
            background-color: var(--primary-dark);
        }

        .btn-secondary {
            background-color: var(--secondary-color);
            color: white;
        }

        .btn-secondary:hover {
            background-color: var(--secondary-dark);
        }

        .btn-outline {
            background-color: transparent;
            border: 1px solid var(--border-dark);
            color: var(--text-light);
        }

        .btn-outline:hover {
            background-color: var(--bg-dark);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .btn-icon {
            padding: 8px;
            border-radius: 4px;
            color: var(--text-light);
            background-color: transparent;
        }

        .btn-icon:hover {
            background-color: var(--bg-dark);
            color: var(--text-highlight);
        }

        /* Workflow canvas */
        .workflow-canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        .workflow-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: var(--bg-color);
            background-image: 
                linear-gradient(to right, var(--bg-darker) 1px, transparent 1px),
                linear-gradient(to bottom, var(--bg-darker) 1px, transparent 1px);
            background-size: 20px 20px;
        }

        /* The actual canvas where nodes are positioned */
        .canvas-content {
            position: relative;
            min-width: 2000px;
            min-height: 1000px;
            transform-origin: 0 0;
        }

        /* Canvas controls */
        .canvas-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background-color: var(--bg-light);
            border-radius: 6px;
            box-shadow: var(--shadow-md);
            display: flex;
            overflow: hidden;
        }

        .canvas-control-btn {
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: transparent;
            border: none;
            cursor: pointer;
            color: var(--text-light);
        }

        .canvas-control-btn:hover {
            background-color: var(--bg-dark);
            color: var(--text-highlight);
        }

        /* Workflow nodes */
        .workflow-node {
            position: absolute;
            width: var(--node-width);
            background-color: var(--bg-light);
            border-radius: var(--node-border-radius);
            box-shadow: var(--shadow-md);
            overflow: hidden;
            transition: box-shadow 0.2s ease;
        }

        .workflow-node:hover {
            box-shadow: var(--shadow-lg);
        }

        .node-header {
            height: var(--node-header-height);
            background-color: var(--primary-color);
            color: white;
            display: flex;
            align-items: center;
            padding: 0 16px;
            font-weight: 500;
            border-top-left-radius: var(--node-border-radius);
            border-top-right-radius: var(--node-border-radius);
            cursor: move;
        }

        .node-header .node-icon {
            margin-right: 10px;
            font-size: 18px;
        }

        .node-content {
            padding: 16px;
        }

        .node-title {
            font-weight: 600;
            color: var(--text-highlight);
            margin-bottom: 8px;
        }

        .node-description {
            font-size: 13px;
            color: var(--text-light);
            margin-bottom: 16px;
        }

        .node-status {
            font-size: 12px;
            padding: 4px 8px;
            border-radius: 4px;
            margin-bottom: 16px;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .status-waiting {
            background-color: var(--bg-darker);
            color: var(--text-lighter);
        }

        .status-running {
            background-color: rgba(33, 150, 243, 0.1);
            color: var(--info-color);
        }

        .status-completed {
            background-color: rgba(0, 200, 83, 0.1);
            color: var(--success-color);
        }

        .status-error {
            background-color: rgba(244, 67, 54, 0.1);
            color: var(--error-color);
        }

        .node-actions {
            display: flex;
            justify-content: flex-end;
            margin-top: 16px;
        }

        .node-edit-btn {
            background-color: transparent;
            border: none;
            cursor: pointer;
            color: var(--primary-color);
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        /* Node connection points */
        .node-connection {
            position: absolute;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background-color: white;
            border: 2px solid var(--primary-color);
            z-index: 2;
        }

        .connection-input {
            top: calc(var(--node-header-height) / 2 - 7px);
            left: -7px;
        }

        .connection-output {
            top: calc(var(--node-header-height) / 2 - 7px);
            right: -7px;
        }

        /* Connection lines */
        .connection-line {
            position: absolute;
            height: 2px;
            background-color: var(--primary-color);
            z-index: 1;
            transform-origin: left center;
        }

        /* Right sidebar / panel */
        .right-panel {
            width: var(--panel-width);
            height: 100%;
            background-color: var(--bg-light);
            border-left: 1px solid var(--border-color);
            overflow-y: auto;
            box-shadow: var(--shadow-sm);
            z-index: 10;
            transition: transform 0.3s ease;
        }

        .right-panel.collapsed {
            transform: translateX(100%);
        }

        .panel-header {
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 16px;
            border-bottom: 1px solid var(--border-color);
            background-color: var(--bg-light);
            position: sticky;
            top: 0;
            z-index: 1;
        }

        .panel-title {
            font-size: 16px;
            font-weight: 600;
        }

        .panel-close {
            background: none;
            border: none;
            cursor: pointer;
            color: var(--text-lighter);
            font-size: 18px;
        }

        .panel-content {
            padding: 20px 16px;
        }

        .panel-section {
            margin-bottom: 24px;
        }

        .panel-section-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-highlight);
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .form-group {
            margin-bottom: 16px;
        }

        .form-label {
            display: block;
            font-size: 13px;
            font-weight: 500;
            color: var(--text-light);
            margin-bottom: 6px;
        }

        .form-control {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 14px;
            color: var(--text-color);
            transition: border-color 0.2s;
        }

        .form-control:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        textarea.form-control {
            min-height: 120px;
            resize: vertical;
        }

        /* Document content */
        .document-content {
            width: 100%;
            min-height: 200px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 16px;
            font-family: var(--font-main);
            font-size: 14px;
            line-height: 1.6;
            resize: vertical;
        }

        .document-content:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        /* File drop area */
        .file-drop-area {
            border: 2px dashed var(--border-color);
            border-radius: 6px;
            padding: 24px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .file-drop-area:hover, .file-drop-area.drag-active {
            border-color: var(--primary-color);
            background-color: rgba(101, 99, 255, 0.05);
        }

        .drop-icon {
            font-size: 40px;
            color: var(--text-soft);
            margin-bottom: 12px;
        }

        .drop-title {
            font-size: 14px;
            font-weight: 500;
            color: var(--text-light);
            margin-bottom: 8px;
        }

        .drop-subtitle {
            font-size: 13px;
            color: var(--text-lighter);
        }

        /* Node parameters */
        .parameter-item {
            background-color: var(--bg-color);
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 12px;
        }

        .parameter-name {
            font-size: 13px;
            font-weight: 500;
            color: var(--text-highlight);
            margin-bottom: 6px;
        }

        .parameter-value {
            font-size: 13px;
            font-family: var(--font-mono);
            color: var(--text-light);
            word-break: break-word;
        }

        /* Results panel */
        .results-tabs {
            display: flex;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 16px;
        }

        .results-tab {
            padding: 8px 16px;
            font-size: 14px;
            font-weight: 500;
            color: var(--text-lighter);
            cursor: pointer;
            border-bottom: 2px solid transparent;
        }

        .results-tab.active {
            color: var(--primary-color);
            border-bottom-color: var(--primary-color);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Questions list */
        .questions-list {
            margin-top: 16px;
        }

        .question-item {
            background-color: var(--bg-color);
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 10px;
            border-left: 3px solid var(--border-dark);
        }

        .question-item.answered {
            border-left-color: var(--success-color);
        }

        .question-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
        }

        .question-id {
            font-size: 12px;
            color: var(--text-lighter);
            background-color: var(--bg-darker);
            padding: 2px 6px;
            border-radius: 4px;
        }

        .question-text {
            font-weight: 500;
            color: var(--text-highlight);
        }

        .answer-content {
            font-size: 13px;
            background-color: rgba(36, 180, 126, 0.05);
            border-radius: 4px;
            padding: 8px;
            color: var(--text-light);
            margin-top: 8px;
            border-left: 2px solid var(--secondary-color);
        }

        /* Analysis results */
        .analysis-result {
            background-color: var(--bg-color);
            border-radius: 6px;
            padding: 16px;
            font-family: var(--font-mono);
            font-size: 13px;
            white-space: pre-wrap;
            color: var(--text-light);
            max-height: 500px;
            overflow-y: auto;
        }

        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-color);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-dark);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-soft);
        }

        /* Loading spinner */
        .loading-spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid rgba(0, 0, 0, 0.1);
            border-top-color: var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Toast notifications */
        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 9999;
        }

        .toast {
            padding: 12px 16px;
            border-radius: 6px;
            margin-bottom: 8px;
            box-shadow: var(--shadow-md);
            display: flex;
            align-items: flex-start;
            max-width: 320px;
            animation: toast-in 0.3s ease forwards;
        }

        .toast-success {
            background-color: var(--success-color);
            color: white;
        }

        .toast-error {
            background-color: var(--error-color);
            color: white;
        }

        .toast-warning {
            background-color: var(--warning-color);
            color: white;
        }

        .toast-info {
            background-color: var(--info-color);
            color: white;
        }

        .toast-icon {
            margin-right: 12px;
            font-size: 20px;
            flex-shrink: 0;
        }

        .toast-content {
            flex: 1;
        }

        .toast-title {
            font-weight: 600;
            margin-bottom: 4px;
        }

        .toast-message {
            font-size: 13px;
            opacity: 0.9;
        }

        @keyframes toast-in {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* Execution timeline */
        .execution-timeline {
            position: relative;
            padding-left: 24px;
        }

        .timeline-line {
            position: absolute;
            top: 0;
            bottom: 0;
            left: 10px;
            width: 2px;
            background-color: var(--border-color);
        }

        .timeline-item {
            position: relative;
            margin-bottom: 16px;
            padding-bottom: 8px;
        }

        .timeline-dot {
            position: absolute;
            left: -24px;
            top: 4px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: var(--bg-dark);
            border: 2px solid var(--border-dark);
            z-index: 1;
        }

        .timeline-item.completed .timeline-dot {
            background-color: var(--success-color);
            border-color: var(--success-color);
        }

        .timeline-item.active .timeline-dot {
            background-color: white;
            border-color: var(--primary-color);
        }

        .timeline-item.error .timeline-dot {
            background-color: var(--error-color);
            border-color: var(--error-color);
        }

        .timeline-content {
            padding-left: 8px;
        }

        .timeline-title {
            font-weight: 500;
            color: var(--text-highlight);
            margin-bottom: 4px;
        }

        .timeline-info {
            font-size: 12px;
            color: var(--text-lighter);
        }

        /* Metrics */
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-bottom: 20px;
        }

        .metric-card {
            background-color: var(--bg-color);
            border-radius: 6px;
            padding: 14px;
            text-align: center;
        }

        .metric-value {
            font-size: 24px;
            font-weight: 600;
            color: var(--primary-color);
            margin-bottom: 6px;
        }

        .metric-label {
            font-size: 12px;
            color: var(--text-lighter);
        }

        /* Node editor modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
        }

        .modal-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .modal {
            background-color: var(--bg-light);
            border-radius: 8px;
            box-shadow: var(--shadow-lg);
            width: 90%;
            max-width: 600px;
            max-height: 90vh;
            overflow-y: auto;
            transform: translateY(20px);
            transition: transform 0.3s;
        }

        .modal-overlay.visible .modal {
            transform: translateY(0);
        }

        .modal-header {
            padding: 16px 20px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .modal-title {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-highlight);
        }

        .modal-close {
            background: none;
            border: none;
            cursor: pointer;
            color: var(--text-lighter);
            font-size: 20px;
        }

        .modal-body {
            padding: 20px;
        }

        .modal-footer {
            padding: 16px 20px;
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: flex-end;
            gap: 12px;
        }

        /* Code editor */
        .code-editor {
            font-family: var(--font-mono);
            width: 100%;
            min-height: 150px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 12px;
            line-height: 1.5;
            tab-size: 2;
            background-color: var(--bg-color);
            color: var(--text-color);
        }

        /* Checkbox style */
        .checkbox-container {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }

        .checkbox {
            margin-right: 8px;
        }

        .checkbox-label {
            font-size: 14px;
            color: var(--text-light);
        }

        /* Sample icons using Material Symbols */
        .icon {
            font-family: 'Material Symbols Outlined';
            font-weight: normal;
            font-style: normal;
            display: inline-block;
            line-height: 1;
            text-transform: none;
            letter-spacing: normal;
            word-wrap: normal;
            white-space: nowrap;
            direction: ltr;
            -webkit-font-smoothing: antialiased;
            text-rendering: optimizeLegibility;
            -moz-osx-font-smoothing: grayscale;
            font-feature-settings: 'liga';
        }

        /* Utilities */
        .mt-4 { margin-top: 16px; }
        .mb-4 { margin-bottom: 16px; }
        .flex { display: flex; }
        .items-center { align-items: center; }
        .justify-between { justify-content: space-between; }
        .gap-2 { gap: 8px; }
        .text-sm { font-size: 14px; }
        .text-xs { font-size: 12px; }
        .text-center { text-align: center; }
        .hidden { display: none; }

        /* Templates card list style */
        .template-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 16px;
        }

        .template-card {
            background-color: var(--bg-light);
            border-radius: 8px;
            border: 1px solid var(--border-color);
            overflow: hidden;
            transition: all 0.2s ease;
            cursor: pointer;
        }

        .template-card:hover {
            box-shadow: var(--shadow-md);
            border-color: var(--primary-light);
        }

        .template-header {
            padding: 16px;
            border-bottom: 1px solid var(--border-color);
            background-color: var(--bg-color);
        }

        .template-title {
            font-weight: 600;
            font-size: 15px;
            color: var(--text-highlight);
            margin-bottom: 4px;
        }

        .template-metadata {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
            color: var(--text-lighter);
        }

        .template-body {
            padding: 16px;
        }

        .template-description {
            font-size: 13px;
            color: var(--text-light);
            margin-bottom: 12px;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .template-stats {
            display: flex;
            align-items: center;
            gap: 16px;
            font-size: 12px;
        }

        .template-stat {
            display: flex;
            align-items: center;
            gap: 4px;
            color: var(--text-lighter);
        }

        .template-actions {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            margin-top: 12px;
        }

        /* Execution history table */
        .history-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 12px;
        }

        .history-table th, 
        .history-table td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }

        .history-table th {
            font-weight: 500;
            color: var(--text-light);
            background-color: var(--bg-color);
        }

        .history-table tbody tr:hover {
            background-color: var(--bg-color);
        }

        .history-status {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
        }

        .history-status.completed {
            background-color: rgba(0, 200, 83, 0.1);
            color: var(--success-color);
        }

        .history-status.failed {
            background-color: rgba(244, 67, 54, 0.1);
            color: var(--error-color);
        }

        .history-actions {
            display: flex;
            gap: 8px;
        }

        .history-action-btn {
            background: none;
            border: none;
            cursor: pointer;
            color: var(--text-lighter);
            font-size: 18px;
        }

        .history-action-btn:hover {
            color: var(--primary-color);
        }

        .history-details {
            display: none;
            padding: 10px;
            background-color: var(--bg-color);
            margin-top: -1px;
            border-bottom: 1px solid var(--border-color);
            font-size: 13px;
        }

        .history-details.visible {
            display: block;
        }

        /* Settings panel */
        .settings-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 24px;
        }

        .settings-card {
            background-color: var(--bg-light);
            border-radius: 8px;
            border: 1px solid var(--border-color);
            overflow: hidden;
        }

        .settings-header {
            padding: 16px;
            border-bottom: 1px solid var(--border-color);
            background-color: var(--bg-color);
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .settings-icon {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            background-color: var(--primary-light);
            color: var(--primary-dark);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
        }

        .settings-title {
            font-weight: 600;
            font-size: 15px;
            color: var(--text-highlight);
        }

        .settings-body {
            padding: 16px;
        }

        .theme-selector {
            display: flex;
            gap: 12px;
        }

        .theme-option {
            flex: 1;
            border: 2px solid var(--border-color);
            border-radius: 6px;
            padding: 12px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .theme-option.active {
            border-color: var(--primary-color);
        }

        .theme-preview {
            height: 80px;
            border-radius: 4px;
            margin-bottom: 8px;
        }

        .theme-preview.light {
            background: linear-gradient(to bottom, #ffffff 0%, #f5f7fa 100%);
        }

        .theme-preview.dark {
            background: linear-gradient(to bottom, #2d3748 0%, #1a202c 100%);
        }

        .theme-preview.system {
            background: linear-gradient(to right, #ffffff 50%, #2d3748 50%);
        }

        .theme-name {
            font-size: 13px;
            font-weight: 500;
        }

        .color-schemes {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-top: 16px;
        }

        .color-scheme {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.2s;
            position: relative;
        }

        .color-scheme:hover {
            transform: scale(1.1);
        }

        .color-scheme.active:after {
            content: '';
            position: absolute;
            inset: -4px;
            border: 2px solid var(--text-color);
            border-radius: 50%;
        }

        .color-scheme.blue { background: linear-gradient(135deg, #4299e1, #3182ce); }
        .color-scheme.purple { background: linear-gradient(135deg, #9f7aea, #805ad5); }
        .color-scheme.green { background: linear-gradient(135deg, #48bb78, #38a169); }
        .color-scheme.orange { background: linear-gradient(135deg, #ed8936, #dd6b20); }
        .color-scheme.red { background: linear-gradient(135deg, #f56565, #e53e3e); }
        .color-scheme.pink { background: linear-gradient(135deg, #ed64a6, #d53f8c); }

        /* Content panels */
        .main-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            height: 100%;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .workflow-editor-panel,
        .executions-panel,
        .templates-panel,
        .settings-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            height: 100%;
            overflow: hidden;
        }

        .executions-panel,
        .templates-panel,
        .settings-panel {
            display: none;
        }

        .panel-active {
            display: flex;
        }

        .templates-header,
        .executions-header,
        .settings-header {
            height: 60px;
            background-color: var(--bg-light);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            padding: 0 20px;
            justify-content: space-between;
            box-shadow: var(--shadow-sm);
        }

        .templates-content,
        .executions-content,
        .settings-content {
            flex: 1;
            overflow-y: auto;
            padding: 24px;
        }

        .search-box {
            display: flex;
            align-items: center;
            background-color: var(--bg-color);
            border-radius: 6px;
            border: 1px solid var(--border-color);
            padding: 8px 12px;
            width: 300px;
        }

        .search-box input {
            flex: 1;
            border: none;
            outline: none;
            background: transparent;
            font-size: 14px;
            color: var(--text-color);
        }

        .search-box .icon {
            color: var(--text-lighter);
            margin-right: 8px;
        }

        .filter-dropdown {
            position: relative;
            display: inline-block;
        }

        .filter-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            background-color: var(--bg-color);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 14px;
            color: var(--text-light);
        }

        .filter-menu {
            position: absolute;
            top: 100%;
            right: 0;
            background-color: var(--bg-light);
            border-radius: 6px;
            box-shadow: var(--shadow-md);
            min-width: 200px;
            z-index: 10;
            display: none;
        }

        .filter-menu.open {
            display: block;
        }

        .filter-option {
            padding: 8px 16px;
            cursor: pointer;
            font-size: 14px;
        }

        .filter-option:hover {
            background-color: var(--bg-color);
        }

        .empty-state {
            text-align: center;
            padding: 40px 0;
            color: var(--text-lighter);
        }

        .empty-state .icon {
            font-size: 48px;
            margin-bottom: 16px;
            opacity: 0.5;
        }

        .empty-state-title {
            font-weight: 500;
            font-size: 18px;
            margin-bottom: 8px;
            color: var(--text-light);
        }

        .empty-state-message {
            font-size: 14px;
            max-width: 400px;
            margin: 0 auto;
            line-height: 1.6;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" rel="stylesheet" />
</head>
<body>
    <!-- Toast container for notifications -->
    <div class="toast-container" id="toast-container"></div>
    
    <!-- Node editor modal -->
    <div class="modal-overlay" id="node-editor-modal">
        <div class="modal">
            <div class="modal-header">
                <h3 class="modal-title" id="node-editor-title">Edit Node</h3>
                <button class="modal-close" id="node-editor-close">
                    <span class="icon">close</span>
                </button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label" for="node-name-input">Node Name</label>
                    <input type="text" id="node-name-input" class="form-control">
                </div>
                
                <div class="form-group">
                    <label class="form-label" for="node-description-input">Description</label>
                    <input type="text" id="node-description-input" class="form-control">
                </div>
                
                <div class="form-group">
                    <label class="form-label" for="node-agent-select">Agent</label>
                    <select id="node-agent-select" class="form-control">
                        <option value="QuestionAndAnswer">QuestionAndAnswer</option>
                        <option value="ContextMemory">ContextMemory</option>
                        <option value="ManageMemory">ManageMemory</option>
                        <option value="EmailDrafting">EmailDrafting</option>
                        <option value="LearnNewAgent">LearnNewAgent</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label class="form-label">Skills</label>
                    <div id="node-skills-container" class="mb-4">
                        <!-- Skills checkboxes will be populated dynamically -->
                    </div>
                </div>
                
                <div class="form-group">
                    <label class="form-label" for="node-system-prompt">System Prompt</label>
                    <textarea id="node-system-prompt" class="form-control"></textarea>
                </div>
                
                <div class="form-group">
                    <label class="form-label" for="node-params-editor">Parameters</label>
                    <textarea id="node-params-editor" class="code-editor" spellcheck="false"></textarea>
                    <div class="text-xs mt-4">Parameters in JSON format</div>
                </div>
            </div>
            <div class="modal-footer">
                <button id="node-editor-cancel" class="btn btn-outline">Cancel</button>
                <button id="node-editor-save" class="btn btn-primary">Save Changes</button>
            </div>
        </div>
    </div>

    <!-- Template View Modal -->
    <div class="modal-overlay" id="template-view-modal">
        <div class="modal">
            <div class="modal-header">
                <h3 class="modal-title" id="template-view-title">Template Details</h3>
                <button class="modal-close" id="template-view-close">
                    <span class="icon">close</span>
                </button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">Description</label>
                    <div id="template-view-description" class="text-sm mb-4"></div>
                </div>
                
                <div class="form-group">
                    <label class="form-label">Metadata</label>
                    <div class="parameter-item">
                        <div class="flex justify-between">
                            <div class="parameter-name">Created</div>
                            <div class="parameter-value" id="template-view-created"></div>
                        </div>
                    </div>
                    <div class="parameter-item">
                        <div class="flex justify-between">
                            <div class="parameter-name">Last Modified</div>
                            <div class="parameter-value" id="template-view-modified"></div>
                        </div>
                    </div>
                    <div class="parameter-item">
                        <div class="flex justify-between">
                            <div class="parameter-name">Version</div>
                            <div class="parameter-value" id="template-view-version"></div>
                        </div>
                    </div>
                </div>
                
                <div class="form-group">
                    <label class="form-label">Steps</label>
                    <div id="template-view-steps" class="mb-4"></div>
                </div>
            </div>
            <div class="modal-footer">
                <button id="template-view-cancel" class="btn btn-outline">Cancel</button>
                <button id="template-view-load" class="btn btn-primary">Load Template</button>
            </div>
        </div>
    </div>

    <!-- Confirm Reset Modal -->
    <div class="modal-overlay" id="confirm-reset-modal">
        <div class="modal" style="max-width: 450px;">
            <div class="modal-header">
                <h3 class="modal-title">Clear All Data</h3>
                <button class="modal-close" id="confirm-reset-close">
                    <span class="icon">close</span>
                </button>
            </div>
            <div class="modal-body">
                <div class="text-center mb-4" style="color: var(--error-color);">
                    <span class="icon" style="font-size: 48px;">warning</span>
                </div>
                <p class="text-sm mb-4">
                    Are you sure you want to clear all application data? This action will permanently delete all your saved workflows, templates, settings, and execution history.
                </p>
                <p class="text-sm" style="color: var(--error-color);">
                    This action cannot be undone.
                </p>
            </div>
            <div class="modal-footer">
                <button id="confirm-reset-cancel" class="btn btn-outline">Cancel</button>
                <button id="confirm-reset-confirm" class="btn btn-outline" style="color: var(--error-color); border-color: var(--error-color);">
                    Clear All Data
                </button>
            </div>
        </div>
    </div>

    <!-- Execution Details Modal -->
    <div class="modal-overlay" id="execution-details-modal">
        <div class="modal" style="max-width: 700px;">
            <div class="modal-header">
                <h3 class="modal-title" id="execution-details-title">Execution Details</h3>
                <button class="modal-close" id="execution-details-close">
                    <span class="icon">close</span>
                </button>
            </div>
            <div class="modal-body">
                <div class="flex justify-between mb-4">
                    <div>
                        <div class="text-xs text-lighter">Workflow</div>
                        <div class="text-sm" id="execution-details-workflow"></div>
                    </div>
                    <div>
                        <div class="text-xs text-lighter">Status</div>
                        <div class="history-status" id="execution-details-status"></div>
                    </div>
                </div>
                
                <div class="flex justify-between mb-4">
                    <div>
                        <div class="text-xs text-lighter">Started</div>
                        <div class="text-sm" id="execution-details-started"></div>
                    </div>
                    <div>
                        <div class="text-xs text-lighter">Duration</div>
                        <div class="text-sm" id="execution-details-duration"></div>
                    </div>
                </div>
                
                <div class="form-group">
                    <label class="form-label">Execution Steps</label>
                    <div class="execution-timeline" id="execution-details-timeline">
                        <div class="timeline-line"></div>
                        <!-- Timeline items will be inserted here -->
                    </div>
                </div>
                
                <div class="form-group">
                    <label class="form-label">Metrics</label>
                    <div class="metrics-grid">
                        <div class="metric-card">
                            <div class="metric-value" id="execution-details-questions">0</div>
                            <div class="metric-label">Total Questions</div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-value" id="execution-details-answers">0</div>
                            <div class="metric-label">Answers Found</div>
                        </div>
                    </div>
                </div>
                
                <div class="form-group">
                    <label class="form-label">Error Details</label>
                    <div class="parameter-item" id="execution-details-error-container">
                        <div class="parameter-value" id="execution-details-error">No errors reported.</div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button id="execution-details-close-btn" class="btn btn-outline">Close</button>
                <button id="execution-details-replay" class="btn btn-primary">Replay Workflow</button>
            </div>
        </div>
    </div>

    <!-- Input for importing data -->
    <input type="file" id="import-data-file" accept=".json" class="hidden">

    <div class="app-container">
        <!-- Left sidebar -->
        <div class="sidebar">
            <div class="logo">W</div>
            <ul class="sidebar-menu">
                <li class="sidebar-item active" title="Workflow Editor">
                    <span class="icon sidebar-icon">schema</span>
                    <span>Editor</span>
                </li>
                <li class="sidebar-item" title="Executions" id="executions-tab">
                    <span class="icon sidebar-icon">history</span>
                    <span>History</span>
                </li>
                <li class="sidebar-item" title="Templates" id="templates-tab">
                    <span class="icon sidebar-icon">dashboard</span>
                    <span>Templates</span>
                </li>
                <li class="sidebar-item" title="Settings" id="settings-tab">
                    <span class="icon sidebar-icon">settings</span>
                    <span>Settings</span>
                </li>
            </ul>
        </div>

        <!-- Main content -->
        <div class="main-content">
            <!-- Workflow Editor Panel -->
            <div class="workflow-editor-panel" id="workflow-editor-panel">
                <!-- Top header -->
                <div class="top-header">
                    <div class="workflow-title">
                        <span class="icon">description</span>
                        <input type="text" id="workflow-name-input" class="form-control" style="width: 300px; display: inline-block;" value="Question Answering Pipeline">
                    </div>
                    <div class="header-actions">
                        <button id="add-node-btn" class="btn btn-outline">
                            <span class="icon">add</span>
                            Add Step
                        </button>
                        <button id="import-workflow-btn" class="btn btn-outline">
                            <span class="icon">upload</span>
                            Import
                        </button>
                        <button id="export-workflow-btn" class="btn btn-outline">
                            <span class="icon">download</span>
                            Export
                        </button>
                        <button id="execute-workflow-btn" class="btn btn-primary">
                            <span class="icon">play_arrow</span>
                            Execute
                        </button>
                    </div>
                </div>

                <!-- Workflow canvas -->
                <div class="workflow-canvas-container">
                    <div class="workflow-canvas" id="workflow-canvas">
                        <div class="canvas-content" id="canvas-content">
                            <!-- Workflow nodes will be dynamically inserted here -->
                        </div>
                    </div>

                    <!-- Canvas controls -->
                    <div class="canvas-controls">
                        <button class="canvas-control-btn" id="zoom-in-btn" title="Zoom In">
                            <span class="icon">add</span>
                        </button>
                        <button class="canvas-control-btn" id="zoom-out-btn" title="Zoom Out">
                            <span class="icon">remove</span>
                        </button>
                        <button class="canvas-control-btn" id="fit-view-btn" title="Fit to View">
                            <span class="icon">fit_screen</span>
                        </button>
                        <button class="canvas-control-btn" id="center-view-btn" title="Center View">
                            <span class="icon">center_focus_strong</span>
                        </button>
                    </div>
                </div>
            </div>

            <!-- History Panel (Executions) -->
            <div class="executions-panel" id="executions-panel">
                <div class="executions-header">
                    <div class="panel-title">
                        <span class="icon">history</span>
                        Execution History
                    </div>
                    <div class="flex items-center gap-2">
                        <div class="search-box">
                            <span class="icon">search</span>
                            <input type="text" id="history-search" placeholder="Search executions...">
                        </div>
                        <div class="filter-dropdown">
                            <button class="filter-btn" id="history-filter-btn">
                                <span class="icon">filter_list</span>
                                Filter
                            </button>
                            <div class="filter-menu" id="history-filter-menu">
                                <div class="filter-option" data-filter="all">All Executions</div>
                                <div class="filter-option" data-filter="completed">Completed</div>
                                <div class="filter-option" data-filter="failed">Failed</div>
                                <div class="filter-option" data-filter="today">Today</div>
                                <div class="filter-option" data-filter="week">This Week</div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="executions-content">
                    <table class="history-table" id="history-table">
                        <thead>
                            <tr>
                                <th width="40%">Workflow</th>
                                <th width="20%">Executed</th>
                                <th width="10%">Duration</th>
                                <th width="15%">Status</th>
                                <th width="15%">Actions</th>
                            </tr>
                        </thead>
                        <tbody id="history-table-body">
                            <!-- History items will be inserted here -->
                        </tbody>
                    </table>
                    
                    <div class="empty-state" id="history-empty-state">
                        <span class="icon">history</span>
                        <div class="empty-state-title">No execution history</div>
                        <div class="empty-state-message">
                            Your workflow execution history will appear here. Start by executing a workflow to see results.
                        </div>
                    </div>
                </div>
            </div>

            <!-- Templates Panel -->
            <div class="templates-panel" id="templates-panel">
                <div class="templates-header">
                    <div class="panel-title">
                        <span class="icon">dashboard</span>
                        Workflow Templates
                    </div>
                    <div class="flex items-center gap-2">
                        <div class="search-box">
                            <span class="icon">search</span>
                            <input type="text" id="templates-search" placeholder="Search templates...">
                        </div>
                        <button class="btn btn-primary" id="create-template-btn">
                            <span class="icon">add</span>
                            New Template
                        </button>
                    </div>
                </div>
                <div class="templates-content">
                    <div class="template-list" id="template-list">
                        <!-- Template cards will be inserted here -->
                    </div>
                    
                    <div class="empty-state" id="templates-empty-state">
                        <span class="icon">dashboard</span>
                        <div class="empty-state-title">No saved templates</div>
                        <div class="empty-state-message">
                            Save your workflows as templates to quickly reuse them later. Click "New Template" to create one or export your current workflow.
                        </div>
                    </div>
                </div>
            </div>

            <!-- Settings Panel -->
            <div class="settings-panel" id="settings-panel">
                <div class="settings-header">
                    <div class="panel-title">
                        <span class="icon">settings</span>
                        Application Settings
                    </div>
                </div>
                <div class="settings-content">
                    <div class="settings-grid">
                        <!-- Theme Settings -->
                        <div class="settings-card">
                            <div class="settings-header">
                                <div class="settings-icon">
                                    <span class="icon">palette</span>
                                </div>
                                <div class="settings-title">Theme Settings</div>
                            </div>
                            <div class="settings-body">
                                <div class="form-group">
                                    <label class="form-label">Theme Mode</label>
                                    <div class="theme-selector">
                                        <div class="theme-option active" data-theme="light">
                                            <div class="theme-preview light"></div>
                                            <div class="theme-name">Light</div>
                                        </div>
                                        <div class="theme-option" data-theme="dark">
                                            <div class="theme-preview dark"></div>
                                            <div class="theme-name">Dark</div>
                                        </div>
                                        <div class="theme-option" data-theme="system">
                                            <div class="theme-preview system"></div>
                                            <div class="theme-name">System</div>
                                        </div>
                                    </div>
                                </div>
                                
                                <div class="form-group">
                                    <label class="form-label">Accent Color</label>
                                    <div class="color-schemes">
                                        <div class="color-scheme blue active" data-color="blue"></div>
                                        <div class="color-scheme purple" data-color="purple"></div>
                                        <div class="color-scheme green" data-color="green"></div>
                                        <div class="color-scheme orange" data-color="orange"></div>
                                        <div class="color-scheme red" data-color="red"></div>
                                        <div class="color-scheme pink" data-color="pink"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- API Settings -->
                        <div class="settings-card">
                            <div class="settings-header">
                                <div class="settings-icon">
                                    <span class="icon">api</span>
                                </div>
                                <div class="settings-title">API Configuration</div>
                            </div>
                            <div class="settings-body">
                                <div class="form-group">
                                    <label class="form-label" for="settings-api-url">API Base URL</label>
                                    <input type="text" id="settings-api-url" class="form-control" value="http://localhost:7071/api/">
                                </div>
                                
                                <div class="form-group">
                                    <label class="form-label" for="settings-api-key">API Key</label>
                                    <input type="password" id="settings-api-key" class="form-control" placeholder="Enter your API key">
                                </div>
                                
                                <div class="form-group">
                                    <label class="form-label">Connection Test</label>
                                    <button class="btn btn-outline" id="test-api-btn">
                                        <span class="icon">network_check</span>
                                        Test Connection
                                    </button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Interface Settings -->
                        <div class="settings-card">
                            <div class="settings-header">
                                <div class="settings-icon">
                                    <span class="icon">tune</span>
                                </div>
                                <div class="settings-title">Interface Settings</div>
                            </div>
                            <div class="settings-body">
                                <div class="form-group">
                                    <div class="checkbox-container">
                                        <input type="checkbox" id="auto-save-checkbox" class="checkbox" checked>
                                        <label for="auto-save-checkbox" class="checkbox-label">Auto-save workflows</label>
                                    </div>
                                </div>
                                
                                <div class="form-group">
                                    <div class="checkbox-container">
                                        <input type="checkbox" id="clear-results-checkbox" class="checkbox" checked>
                                        <label for="clear-results-checkbox" class="checkbox-label">Clear results before new execution</label>
                                    </div>
                                </div>
                                
                                <div class="form-group">
                                    <div class="checkbox-container">
                                        <input type="checkbox" id="show-welcome-checkbox" class="checkbox" checked>
                                        <label for="show-welcome-checkbox" class="checkbox-label">Show welcome screen on startup</label>
                                    </div>
                                </div>
                                
                                <div class="form-group">
                                    <label class="form-label" for="history-limit">History limit</label>
                                    <select id="history-limit" class="form-control">
                                        <option value="10">10 entries</option>
                                        <option value="20" selected>20 entries</option>
                                        <option value="50">50 entries</option>
                                        <option value="100">100 entries</option>
                                        <option value="0">Unlimited</option>
                                    </select>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Storage Management -->
                        <div class="settings-card">
                            <div class="settings-header">
                                <div class="settings-icon">
                                    <span class="icon">storage</span>
                                </div>
                                <div class="settings-title">Storage Management</div>
                            </div>
                            <div class="settings-body">
                                <div class="form-group">
                                    <label class="form-label">Local Storage</label>
                                    <div class="text-sm mb-4">Application data is stored in your browser's local storage.</div>
                                    
                                    <div class="metrics-grid">
                                        <div class="metric-card">
                                            <div class="metric-value" id="storage-workflows">0</div>
                                            <div class="metric-label">Saved Workflows</div>
                                        </div>
                                        <div class="metric-card">
                                            <div class="metric-value" id="storage-history">0</div>
                                            <div class="metric-label">History Entries</div>
                                        </div>
                                    </div>
                                </div>
                                
                                <div class="form-group">
                                    <button class="btn btn-outline" id="export-all-data-btn">
                                        <span class="icon">download</span>
                                        Export All Data
                                    </button>
                                </div>
                                
                                <div class="form-group">
                                    <button class="btn btn-outline" id="import-data-btn">
                                        <span class="icon">upload</span>
                                        Import Data
                                    </button>
                                </div>
                                
                                <div class="form-group">
                                    <button class="btn btn-outline" id="clear-all-data-btn" style="color: var(--error-color);">
                                        <span class="icon">delete</span>
                                        Clear All Data
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Right panel -->
        <div class="right-panel" id="right-panel">
            <div class="panel-header">
                <div class="panel-title">Document Input</div>
                <button class="panel-close" id="panel-close-btn">
                    <span class="icon">close</span>
                </button>
            </div>

            <div class="panel-content">
                <div class="panel-section">
                    <div class="panel-section-title">
                        <span class="icon">description</span>
                        Document Text
                    </div>
                    <p class="text-sm text-xs mb-4">Enter or paste the document text that will be used to answer the questions.</p>
                    
                    <div class="form-group">
                        <textarea id="document-content" class="document-content" placeholder="Paste your document content here..."></textarea>
                    </div>
                    
                    <div class="form-group">
                        <button id="load-sample-text-btn" class="btn btn-outline">
                            <span class="icon">auto_awesome</span>
                            Load Sample Text
                        </button>
                    </div>
                </div>

                <div class="panel-section">
                    <div class="panel-section-title">
                        <span class="icon">settings</span>
                        API Configuration
                    </div>
                    <p class="text-sm text-xs mb-4">Configure the API endpoints used to execute your workflow.</p>
                    
                    <div class="form-group">
                        <label class="form-label" for="api-url-input">API Base URL</label>
                        <input type="text" id="api-url-input" class="form-control" value="http://localhost:7071/api/">
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label" for="api-key-input">API Key (optional)</label>
                        <input type="password" id="api-key-input" class="form-control" placeholder="Enter your API key">
                    </div>
                </div>

                <div class="panel-section" id="workflow-upload-section">
                    <div class="panel-section-title">
                        <span class="icon">upload_file</span>
                        Upload Workflow Template
                    </div>
                    <p class="text-sm text-xs mb-4">Import a JSON workflow template file to use for execution.</p>
                    
                    <div class="file-drop-area" id="workflow-drop-area">
                        <span class="icon drop-icon">cloud_upload</span>
                        <div class="drop-title">Drag & Drop Workflow Template</div>
                        <div class="drop-subtitle">or click to browse</div>
                        <input type="file" id="workflow-file-input" accept=".json" class="hidden">
                    </div>
                </div>
            </div>
        </div>

        <!-- Results panel (initially hidden, will replace right panel when shown) -->
        <div class="right-panel hidden" id="results-panel">
            <div class="panel-header">
                <div class="panel-title">Execution Results</div>
                <button class="panel-close" id="results-close-btn">
                    <span class="icon">close</span>
                </button>
            </div>

            <div class="panel-content">
                <div class="metrics-grid">
                    <div class="metric-card">
                        <div class="metric-value" id="metric-total-questions">0</div>
                        <div class="metric-label">Total Questions</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="metric-unanswered">0</div>
                        <div class="metric-label">Initially Unanswered</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="metric-answers-found">0</div>
                        <div class="metric-label">Answers Found</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="metric-success-rate">0%</div>
                        <div class="metric-label">Success Rate</div>
                    </div>
                </div>

                <div class="results-tabs">
                    <div class="results-tab active" data-tab="questions-tab">Questions</div>
                    <div class="results-tab" data-tab="analysis-tab">Analysis</div>
                    <div class="results-tab" data-tab="timeline-tab">Timeline</div>
                    <div class="results-tab" data-tab="logs-tab">API Logs</div>
                </div>

                <div id="questions-tab" class="tab-content active">
                    <div class="questions-list" id="questions-list">
                        <!-- Questions will be inserted here -->
                        <div class="text-center text-sm">No questions processed yet.</div>
                    </div>
                </div>

                <div id="analysis-tab" class="tab-content">
                    <div class="analysis-result" id="analysis-result">
                        No document analysis results yet.
                    </div>
                </div>

                <div id="timeline-tab" class="tab-content">
                    <div class="execution-timeline" id="execution-timeline">
                        <div class="timeline-line"></div>
                        <!-- Timeline items will be inserted here -->
                        <div class="text-center text-sm">No execution steps recorded yet.</div>
                    </div>
                </div>

                <div id="logs-tab" class="tab-content">
                    <div class="analysis-result" id="api-logs">
                        No API logs available yet.
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Sample workflow template
        const defaultWorkflowTemplate = {
            "name": "Question Analysis & Answering Pipeline",
            "description": "Retrieves questions, analyzes documents for answers, and automatically answers questions where possible",
            "version": "1.0",
            "metadata": {
                "created": "2025-03-15T00:00:00.000Z",
                "author": "Workflow Builder"
            },
            "steps": [
                {
                    "id": "step_1",
                    "name": "List Available Questions",
                    "agent": "QuestionAndAnswer",
                    "description": "Retrieves all questions from the system that need answers",
                    "enabled": true,
                    "skills": ["list_questions"],
                    "systemPrompt": "You are a helpful assistant tasked with retrieving business questions that need to be answered. List all the questions, paying close attention to which ones are already answered and which still need answers.",
                    "parameters": {
                        "action": "list_questions"
                    }
                },
                {
                    "id": "step_2",
                    "name": "Process Document for Answer Content",
                    "agent": "ContextMemory",
                    "description": "Analyzes document text to extract key information",
                    "enabled": true,
                    "skills": ["recall"],
                    "systemPrompt": "You are a data extraction specialist. You have been given a text document that may contain information relevant to answering business questions. Analyze this document and extract key details that could be used to answer business questions, including names, addresses, dates, financial figures, project parameters, and any other factual information.",
                    "parameters": {
                        "user_guid": "document_analysis_context"
                    }
                },
                {
                    "id": "step_3",
                    "name": "Generate Automatic Answers",
                    "agent": "ManageMemory",
                    "description": "Creates answers based on document analysis and questions",
                    "enabled": true,
                    "skills": ["create"],
                    "systemPrompt": "You are a question-answering assistant. Using the information extracted from the document, determine if any of the unanswered questions can be confidently answered. For each question:\n1. Assess if the document contains a clear answer\n2. If yes, formulate a concise answer and assign a high confidence score (0.8-1.0)\n3. If uncertain, formulate a possible answer but assign a lower confidence score (below 0.8)\n4. If no relevant information exists, skip the question\n\nProvide your answers in the exact format required for the auto_answers parameter.",
                    "parameters": {
                        "data": {},
                        "conversation_id": "auto_answer_generation",
                        "session_id": "answer_processing",
                        "conversation_context": "",
                        "companion_id": "question_answerer",
                        "mood": "neutral",
                        "theme": "data_analysis"
                    }
                },
                {
                    "id": "step_4",
                    "name": "Submit Automatic Answers",
                    "agent": "QuestionAndAnswer",
                    "description": "Submits generated answers to the question system",
                    "enabled": true,
                    "skills": ["auto_answer_questions"],
                    "systemPrompt": "You are a data submission assistant. Take the automatically generated question answers and submit them to the question and answer system using the auto_answer_questions action. Format the answers exactly as required by the API, ensuring that each answer has the correct question_id, answer text, and confidence score.",
                    "parameters": {
                        "action": "auto_answer_questions",
                        "auto_answers": []
                    }
                },
                {
                    "id": "step_5",
                    "name": "Generate Report on Process",
                    "agent": "QuestionAndAnswer",
                    "description": "Creates a summary report of the question answering process",
                    "enabled": true,
                    "skills": ["list_questions"],
                    "systemPrompt": "You are a reporting assistant. After the automatic question answering process has completed, generate a summary report that includes:\n1. How many questions were successfully answered\n2. How many questions remain unanswered\n3. Any questions where the confidence was low but an answer was attempted\n4. Suggestions for how to obtain the missing information",
                    "parameters": {
                        "action": "list_questions"
                    }
                }
            ]
        };

        // Sample document text content for demonstration
        const sampleDocumentText = `
Company Profile: Acme Tech Solutions, Inc.

Headquarters: 123 Innovation Way, San Francisco, CA 94105
Established: March 15, 1998
CEO: Dr. Sarah Johnson (appointed January 2020)
Annual Revenue (2024): $78.5 million
Employee Count: 342 full-time employees

Primary Business Objectives:
- Increase market share in cloud-based enterprise software by 15% within 18 months
- Expand operations to European markets by Q3 2025
- Reduce operational costs by 8% while maintaining current service quality
- Achieve carbon neutrality across all operations by 2027

Current Projects:
1. NextGen Data Analytics Platform (Project Code: ND-2024)
   - Budget: $4.2 million
   - Timeline: January 2025 - November 2025
   - Technical Lead: Michael Chen
   - Key technologies: Python, TensorFlow, AWS

2. Enterprise Security Enhancement Program
   - Budget: $2.8 million
   - Timeline: Ongoing (started October 2024)
   - Requirements: SOC 2 Type II compliance, Zero Trust Architecture implementation
   - External partners: CyberShield Consulting

Technology Stack:
- Front-end: React.js, Angular, Vue.js
- Back-end: Node.js, Django, Spring Boot
- Databases: PostgreSQL, MongoDB, Redis
- Cloud Infrastructure: AWS (primary), Azure (secondary)
- Security: Implements OAuth 2.0, SAML, and custom SSO solutions

Key Clients:
- FinanceCore International (Financial services)
- HealthFirst Networks (Healthcare)
- RetailGiant Inc. (Retail)
- GovSecure Agency (Government)

Recent Achievements:
- Received ISO 27001 certification in January 2025
- Named "Top 50 Innovative Companies" by Tech Innovators Magazine
- Granted three new patents for proprietary data processing algorithms

Contact:
- Main Phone: (415) 555-9876
- Support Email: support@acmetech.example.com
- Sales: sales@acmetech.example.com
`;

        // Available agent skills mapping
        const agentSkills = {
            "QuestionAndAnswer": [
                "list_questions",
                "list_requirements",
                "add_questions",
                "add_requirements",
                "answer_questions",
                "answer_requirements",
                "auto_answer_questions",
                "auto_answer_requirements",
                "generate_sow",
                "get_question_mapping",
                "get_requirement_mapping",
                "import_questions",
                "import_requirements"
            ],
            "ContextMemory": [
                "recall"
            ],
            "ManageMemory": [
                "create"
            ],
            "EmailDrafting": [
                "draft",
                "send"
            ],
            "LearnNewAgent": [
                "create"
            ]
        };

        // Default parameters for agents
        const defaultAgentParameters = {
            "QuestionAndAnswer": {
                "action": "list_questions"
            },
            "ContextMemory": {
                "user_guid": "context_memory_guid"
            },
            "ManageMemory": {
                "data": {},
                "conversation_id": "conversation_id",
                "session_id": "session_id",
                "conversation_context": "",
                "companion_id": "companion_id",
                "mood": "neutral",
                "theme": "general"
            },
            "EmailDrafting": {
                "subject": "",
                "to": "",
                "body": ""
            },
            "LearnNewAgent": {
                "agent_name": "",
                "python_implementation": ""
            }
        };

        // DOM Elements
        const domElements = {
            // Workflow elements
            workflowCanvas: document.getElementById('workflow-canvas'),
            canvasContent: document.getElementById('canvas-content'),
            workflowNameInput: document.getElementById('workflow-name-input'),
            addNodeBtn: document.getElementById('add-node-btn'),
            importWorkflowBtn: document.getElementById('import-workflow-btn'),
            exportWorkflowBtn: document.getElementById('export-workflow-btn'),
            
            // Document content
            documentContent: document.getElementById('document-content'),
            loadSampleTextBtn: document.getElementById('load-sample-text-btn'),
            
            // API configuration
            apiUrlInput: document.getElementById('api-url-input'),
            apiKeyInput: document.getElementById('api-key-input'),
            
            // Execution controls
            executeWorkflowBtn: document.getElementById('execute-workflow-btn'),
            
            // Canvas controls
            zoomInBtn: document.getElementById('zoom-in-btn'),
            zoomOutBtn: document.getElementById('zoom-out-btn'),
            fitViewBtn: document.getElementById('fit-view-btn'),
            centerViewBtn: document.getElementById('center-view-btn'),
            
            // Panel elements
            rightPanel: document.getElementById('right-panel'),
            panelCloseBtn: document.getElementById('panel-close-btn'),
            resultsPanel: document.getElementById('results-panel'),
            resultsCloseBtn: document.getElementById('results-close-btn'),
            
            // Results elements
            metricTotalQuestions: document.getElementById('metric-total-questions'),
            metricUnanswered: document.getElementById('metric-unanswered'),
            metricAnswersFound: document.getElementById('metric-answers-found'),
            metricSuccessRate: document.getElementById('metric-success-rate'),
            
            questionsList: document.getElementById('questions-list'),
            analysisResult: document.getElementById('analysis-result'),
            executionTimeline: document.getElementById('execution-timeline'),
            apiLogs: document.getElementById('api-logs'),
            
            resultsTabs: document.querySelectorAll('.results-tab'),
            tabContents: document.querySelectorAll('.tab-content'),
            
            // Node editor modal
            nodeEditorModal: document.getElementById('node-editor-modal'),
            nodeEditorTitle: document.getElementById('node-editor-title'),
            nodeEditorClose: document.getElementById('node-editor-close'),
            nodeNameInput: document.getElementById('node-name-input'),
            nodeDescriptionInput: document.getElementById('node-description-input'),
            nodeAgentSelect: document.getElementById('node-agent-select'),
            nodeSkillsContainer: document.getElementById('node-skills-container'),
            nodeSystemPrompt: document.getElementById('node-system-prompt'),
            nodeParamsEditor: document.getElementById('node-params-editor'),
            nodeEditorCancel: document.getElementById('node-editor-cancel'),
            nodeEditorSave: document.getElementById('node-editor-save'),
            
            // File import elements
            workflowFileInput: document.getElementById('workflow-file-input'),
            workflowDropArea: document.getElementById('workflow-drop-area'),
            
            // Toast container
            toastContainer: document.getElementById('toast-container'),
            
            // Sidebar tabs
            executionsTab: document.getElementById('executions-tab'),
            templatesTab: document.getElementById('templates-tab'),
            settingsTab: document.getElementById('settings-tab'),

            // Extensions panel elements
            executionsPanel: document.getElementById('executions-panel'),
            templatesPanel: document.getElementById('templates-panel'),
            settingsPanel: document.getElementById('settings-panel'),
            workflowEditorPanel: document.getElementById('workflow-editor-panel'),

            // History panel elements
            historyTable: document.getElementById('history-table'),
            historyTableBody: document.getElementById('history-table-body'),
            historyEmptyState: document.getElementById('history-empty-state'),
            historySearch: document.getElementById('history-search'),
            historyFilterBtn: document.getElementById('history-filter-btn'),
            historyFilterMenu: document.getElementById('history-filter-menu'),
            historyFilterOptions: document.querySelectorAll('#history-filter-menu .filter-option'),

            // Templates panel elements
            templateList: document.getElementById('template-list'),
            templatesEmptyState: document.getElementById('templates-empty-state'),
            templatesSearch: document.getElementById('templates-search'),
            createTemplateBtn: document.getElementById('create-template-btn'),

            // Settings panel elements
            themeOptions: document.querySelectorAll('.theme-option'),
            colorSchemes: document.querySelectorAll('.color-scheme'),
            settingsApiUrl: document.getElementById('settings-api-url'),
            settingsApiKey: document.getElementById('settings-api-key'),
            testApiBtn: document.getElementById('test-api-btn'),
            autoSaveCheckbox: document.getElementById('auto-save-checkbox'),
            clearResultsCheckbox: document.getElementById('clear-results-checkbox'),
            showWelcomeCheckbox: document.getElementById('show-welcome-checkbox'),
            historyLimit: document.getElementById('history-limit'),
            storageWorkflows: document.getElementById('storage-workflows'),
            storageHistory: document.getElementById('storage-history'),
            exportAllDataBtn: document.getElementById('export-all-data-btn'),
            importDataBtn: document.getElementById('import-data-btn'),
            importDataFile: document.getElementById('import-data-file'),
            clearAllDataBtn: document.getElementById('clear-all-data-btn'),

            // Template view modal elements
            templateViewModal: document.getElementById('template-view-modal'),
            templateViewTitle: document.getElementById('template-view-title'),
            templateViewClose: document.getElementById('template-view-close'),
            templateViewDescription: document.getElementById('template-view-description'),
            templateViewCreated: document.getElementById('template-view-created'),
            templateViewModified: document.getElementById('template-view-modified'),
            templateViewVersion: document.getElementById('template-view-version'),
            templateViewSteps: document.getElementById('template-view-steps'),
            templateViewCancel: document.getElementById('template-view-cancel'),
            templateViewLoad: document.getElementById('template-view-load'),

            // Confirm reset modal elements
            confirmResetModal: document.getElementById('confirm-reset-modal'),
            confirmResetClose: document.getElementById('confirm-reset-close'),
            confirmResetCancel: document.getElementById('confirm-reset-cancel'),
            confirmResetConfirm: document.getElementById('confirm-reset-confirm'),

            // Execution details modal elements
            executionDetailsModal: document.getElementById('execution-details-modal'),
            executionDetailsTitle: document.getElementById('execution-details-title'),
            executionDetailsClose: document.getElementById('execution-details-close'),
            executionDetailsWorkflow: document.getElementById('execution-details-workflow'),
            executionDetailsStatus: document.getElementById('execution-details-status'),
            executionDetailsStarted: document.getElementById('execution-details-started'),
            executionDetailsDuration: document.getElementById('execution-details-duration'),
            executionDetailsTimeline: document.getElementById('execution-details-timeline'),
            executionDetailsQuestions: document.getElementById('execution-details-questions'),
            executionDetailsAnswers: document.getElementById('execution-details-answers'),
            executionDetailsErrorContainer: document.getElementById('execution-details-error-container'),
            executionDetailsError: document.getElementById('execution-details-error'),
            executionDetailsCloseBtn: document.getElementById('execution-details-close-btn'),
            executionDetailsReplay: document.getElementById('execution-details-replay')
        };

        // State management
        let state = {
            workflowTemplate: null,
            documentContent: '',
            apiUrl: '',
            apiKey: '',
            canvasState: {
                scale: 1,
                translateX: 0,
                translateY: 0,
                dragging: false,
                lastMouseX: 0,
                lastMouseY: 0
            },
            executionState: {
                running: false,
                currentStepIndex: -1,
                steps: [],
                startTime: null,
                endTime: null,
                results: {
                    questions: [],
                    answersGenerated: 0,
                    answersSubmitted: 0,
                    documentAnalysis: null
                }
            },
            nodes: [],
            connections: [],
            nodeBeingEdited: null,
            executionHistory: [],
            savedTemplates: [],
            appSettings: {
                theme: 'light',
                accentColor: 'blue',
                autoSave: true,
                clearResultsBeforeExecution: true,
                showWelcomeOnStartup: true,
                historyLimit: 20
            },
            currentView: 'editor', // 'editor', 'executions', 'templates', 'settings'
            selectedTemplate: null,
            selectedExecution: null,
            filteredHistory: [],
            filteredTemplates: [],
            filterCriteria: {
                history: 'all',
                templates: ''
            }
        };

        if (domElements.historyFilterMenu.classList.contains('open') &&
                    !e.target.closest('#history-filter-btn') &&
                    !e.target.closest('#history-filter-menu')) {
                    domElements.historyFilterMenu.classList.remove('open');
                }
       
            // Templates panel
            domElements.templatesSearch.addEventListener('input', function() {
                filterTemplates();
            });
            
            domElements.createTemplateBtn.addEventListener('click', function() {
                createNewTemplate();
            });
            
            // Settings panel
            domElements.themeOptions.forEach(option => {
                option.addEventListener('click', function() {
                    const theme = this.getAttribute('data-theme');
                    setTheme(theme);
                });
            });
            
            domElements.colorSchemes.forEach(scheme => {
                scheme.addEventListener('click', function() {
                    const color = this.getAttribute('data-color');
                    setAccentColor(color);
                });
            });
            
            domElements.settingsApiUrl.addEventListener('input', function() {
                state.apiUrl = this.value;
                state.appSettings.apiUrl = this.value;
                saveSettings();
            });
            
            domElements.settingsApiKey.addEventListener('input', function() {
                state.apiKey = this.value;
                state.appSettings.apiKey = this.value;
                saveSettings();
            });
            
            domElements.testApiBtn.addEventListener('click', function() {
                testApiConnection();
            });
            
            domElements.autoSaveCheckbox.addEventListener('change', function() {
                state.appSettings.autoSave = this.checked;
                saveSettings();
            });
            
            domElements.clearResultsCheckbox.addEventListener('change', function() {
                state.appSettings.clearResultsBeforeExecution = this.checked;
                saveSettings();
            });
            
            domElements.showWelcomeCheckbox.addEventListener('change', function() {
                state.appSettings.showWelcomeOnStartup = this.checked;
                saveSettings();
            });
            
            domElements.historyLimit.addEventListener('change', function() {
                state.appSettings.historyLimit = parseInt(this.value);
                saveSettings();
            });
            
            domElements.exportAllDataBtn.addEventListener('click', function() {
                exportAllData();
            });
            
            domElements.importDataBtn.addEventListener('click', function() {
                domElements.importDataFile.click();
            });
            
            domElements.importDataFile.addEventListener('change', function() {
                if (this.files.length > 0) {
                    importData(this.files[0]);
                }
            });
            
            domElements.clearAllDataBtn.addEventListener('click', function() {
                showConfirmResetModal();
            });
            
            // Template view modal
            domElements.templateViewClose.addEventListener('click', function() {
                closeTemplateViewModal();
            });
            
            domElements.templateViewCancel.addEventListener('click', function() {
                closeTemplateViewModal();
            });
            
            domElements.templateViewLoad.addEventListener('click', function() {
                loadSelectedTemplate();
            });
            
            // Confirm reset modal
            domElements.confirmResetClose.addEventListener('click', function() {
                closeConfirmResetModal();
            });
            
            domElements.confirmResetCancel.addEventListener('click', function() {
                closeConfirmResetModal();
            });
            
            domElements.confirmResetConfirm.addEventListener('click', function() {
                clearAllData();
                closeConfirmResetModal();
            });
            
            // Execution details modal
            domElements.executionDetailsClose.addEventListener('click', function() {
                closeExecutionDetailsModal();
            });
            
            domElements.executionDetailsCloseBtn.addEventListener('click', function() {
                closeExecutionDetailsModal();
            });
            
            domElements.executionDetailsReplay.addEventListener('click', function() {
                replayExecution();
            });
        
        

        // Add function to init
        function initExtendedFeatures() {
            loadSettings();
            applyTheme();
            updateStorageMetrics();
        }

        // View switching
        function switchView(view) {
            // Update state
            state.currentView = view;
            
            // Remove active class from all sidebar items
            document.querySelectorAll('.sidebar-item').forEach(item => {
                item.classList.remove('active');
            });
            
            // Add active class to selected sidebar item
            let activeTab;
            switch (view) {
                case 'editor':
                    activeTab = document.querySelector('.sidebar-item:first-child');
                    break;
                case 'executions':
                    activeTab = domElements.executionsTab;
                    break;
                case 'templates':
                    activeTab = domElements.templatesTab;
                    break;
                case 'settings':
                    activeTab = domElements.settingsTab;
                    break;
            }
            
            if (activeTab) {
                activeTab.classList.add('active');
            }
            
            // Hide all panels
            domElements.workflowEditorPanel.style.display = 'none';
            domElements.executionsPanel.style.display = 'none';
            domElements.templatesPanel.style.display = 'none';
            domElements.settingsPanel.style.display = 'none';
            
            // Show selected panel
            switch (view) {
                case 'editor':
                    domElements.workflowEditorPanel.style.display = 'flex';
                    break;
                case 'executions':
                    domElements.executionsPanel.style.display = 'flex';
                    break;
                case 'templates':
                    domElements.templatesPanel.style.display = 'flex';
                    break;
                case 'settings':
                    domElements.settingsPanel.style.display = 'flex';
                    break;
            }
        }

        // Load state from localStorage
        function loadFromLocalStorage() {
            try {
                const savedState = localStorage.getItem('workflowExecutorState');
                if (savedState) {
                    const parsedState = JSON.parse(savedState);
                    
                    // Restore API configuration
                    if (parsedState.apiUrl) {
                        state.apiUrl = parsedState.apiUrl;
                        domElements.apiUrlInput.value = parsedState.apiUrl;
                    } else {
                        state.apiUrl = domElements.apiUrlInput.value;
                    }
                    
                    if (parsedState.apiKey) {
                        state.apiKey = parsedState.apiKey;
                        domElements.apiKeyInput.value = parsedState.apiKey;
                    }
                    
                    // Restore document content
                    if (parsedState.documentContent) {
                        state.documentContent = parsedState.documentContent;
                        domElements.documentContent.value = parsedState.documentContent;
                    }
                    
                    // Restore execution history
                    if (parsedState.executionHistory) {
                        state.executionHistory = parsedState.executionHistory;
                    }
                    
                    // Restore saved templates
                    if (parsedState.savedTemplates) {
                        state.savedTemplates = parsedState.savedTemplates;
                    }
                } else {
                    // Default API URL if none saved
                    state.apiUrl = domElements.apiUrlInput.value;
                }
            } catch (error) {
                console.error('Error loading saved state:', error);
                // Set default API URL
                state.apiUrl = domElements.apiUrlInput.value;
            }
        }

        // Save state to localStorage
        function saveToLocalStorage() {
            try {
                const stateToSave = {
                    apiUrl: state.apiUrl,
                    apiKey: state.apiKey,
                    documentContent: state.documentContent,
                    executionHistory: state.executionHistory,
                    savedTemplates: state.savedTemplates
                };
                
                localStorage.setItem('workflowExecutorState', JSON.stringify(stateToSave));
            } catch (error) {
                console.error('Error saving state:', error);
            }
        }

        // Update workflow name
        function updateWorkflowName() {
            if (state.workflowTemplate) {
                state.workflowTemplate.name = domElements.workflowNameInput.value;
            }
        }

        // Set up canvas dragging
        function setupCanvasDrag() {
            const canvas = domElements.workflowCanvas;
            
            canvas.addEventListener('mousedown', (e) => {
                if (e.target === canvas || e.target === domElements.canvasContent) {
                    state.canvasState.dragging = true;
                    state.canvasState.lastMouseX = e.clientX;
                    state.canvasState.lastMouseY = e.clientY;
                    canvas.style.cursor = 'grabbing';
                }
            });
            
            document.addEventListener('mousemove', (e) => {
                if (state.canvasState.dragging) {
                    const deltaX = e.clientX - state.canvasState.lastMouseX;
                    const deltaY = e.clientY - state.canvasState.lastMouseY;
                    
                    state.canvasState.translateX += deltaX;
                    state.canvasState.translateY += deltaY;
                    
                    state.canvasState.lastMouseX = e.clientX;
                    state.canvasState.lastMouseY = e.clientY;
                    
                    updateCanvasTransform();
                }
            });
            
            document.addEventListener('mouseup', () => {
                if (state.canvasState.dragging) {
                    state.canvasState.dragging = false;
                    canvas.style.cursor = 'default';
                }
            });
            
            // Mouse wheel for zooming
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                
                const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                
                // Get mouse position relative to canvas
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                // Zoom centered on mouse position
                zoomCanvasAtPoint(zoomFactor, mouseX, mouseY);
            });
        }

        // Update canvas transform
        function updateCanvasTransform() {
            const { scale, translateX, translateY } = state.canvasState;
            domElements.canvasContent.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
        }

        // Zoom canvas
        function zoomCanvas(factor) {
            const canvas = domElements.workflowCanvas;
            const rect = canvas.getBoundingClientRect();
            
            // Zoom centered on canvas center
            const centerX = rect.width / 2;
            const centerY = rect.height / 2;
            
            zoomCanvasAtPoint(factor, centerX, centerY);
        }

        // Zoom canvas at point
        function zoomCanvasAtPoint(factor, x, y) {
            const { scale, translateX, translateY } = state.canvasState;
            
            // Calculate new scale
            const newScale = scale * factor;
            
            // Limit scale to reasonable bounds
            if (newScale < 0.2 || newScale > 3) return;
            
            // Calculate new translate values to zoom centered on mouse position
            const newTranslateX = translateX - ((x - translateX) * (factor - 1));
            const newTranslateY = translateY - ((y - translateY) * (factor - 1));
            
            // Update state
            state.canvasState.scale = newScale;
            state.canvasState.translateX = newTranslateX;
            state.canvasState.translateY = newTranslateY;
            
            // Update transform
            updateCanvasTransform();
        }

        // Fit canvas to view
        function fitCanvasToView() {
            // Reset transform
            state.canvasState.scale = 0.8;
            
            // Center the canvas
            centerCanvas();
        }

        // Center canvas
        function centerCanvas() {
            const canvas = domElements.workflowCanvas;
            const content = domElements.canvasContent;
            
            // Calculate center position
            const contentRect = content.getBoundingClientRect();
            const canvasRect = canvas.getBoundingClientRect();
            
            state.canvasState.translateX = (canvasRect.width - (contentRect.width * state.canvasState.scale)) / 2;
            state.canvasState.translateY = (canvasRect.height - (contentRect.height * state.canvasState.scale)) / 2;
            
            // Update transform
            updateCanvasTransform();
        }

        // Toggle right panel
        function toggleRightPanel() {
            domElements.rightPanel.classList.toggle('collapsed');
        }

        // Open results panel
        function openResultsPanel() {
            domElements.rightPanel.classList.add('hidden');
            domElements.resultsPanel.classList.remove('hidden');
        }

        // Close results panel
        function closeResultsPanel() {
            domElements.resultsPanel.classList.add('hidden');
            domElements.rightPanel.classList.remove('hidden');
        }

        // Handle drag over event
        function handleDragOver(e) {
            e.preventDefault();
            e.stopPropagation();
            domElements.workflowDropArea.classList.add('drag-active');
        }

        // Handle drag leave event
        function handleDragLeave(e) {
            e.preventDefault();
            e.stopPropagation();
            domElements.workflowDropArea.classList.remove('drag-active');
        }

        // Handle drop event
        function handleDrop(e) {
            e.preventDefault();
            e.stopPropagation();
            domElements.workflowDropArea.classList.remove('drag-active');
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                processWorkflowFile(files[0]);
            }
        }

        // Handle file select event
        function handleFileSelect(e) {
            const files = e.target.files;
            if (files.length > 0) {
                processWorkflowFile(files[0]);
            }
        }

        // Process workflow file
        function processWorkflowFile(file) {
            if (file.type !== 'application/json') {
                showToast('error', 'Invalid File Type', 'Please upload a JSON file.');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const workflowTemplate = JSON.parse(e.target.result);
                    loadWorkflowTemplate(workflowTemplate);
                    showToast('success', 'Workflow Loaded', 'Workflow template imported successfully.');
                } catch (error) {
                    showToast('error', 'Invalid JSON', 'Could not parse the workflow template file.');
                }
            };
            reader.readAsText(file);
        }

        // Export workflow
        function exportWorkflow() {
            if (!state.workflowTemplate) {
                showToast('error', 'No Workflow', 'No workflow to export.');
                return;
            }
            
            // Prepare export data
            const exportData = {
                ...state.workflowTemplate,
                metadata: {
                    ...state.workflowTemplate.metadata,
                    exportedAt: new Date().toISOString(),
                    version: state.workflowTemplate.version || "1.0"
                },
                nodePositions: state.nodes.map(node => ({
                    id: node.id,
                    x: node.x,
                    y: node.y
                }))
            };
            
            // Convert to JSON
            const jsonData = JSON.stringify(exportData, null, 2);
            
            // Create download link
            const blob = new Blob([jsonData], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            // Create temporary link and trigger download
            const link = document.createElement('a');
            link.href = url;
            
            // Format filename
            const filename = state.workflowTemplate.name
                ? state.workflowTemplate.name.replace(/\s+/g, '_').toLowerCase() + '.json'
                : 'workflow_export.json';
            
            link.download = filename;
            link.click();
            
            // Clean up
            URL.revokeObjectURL(url);
            
            showToast('success', 'Export Successful', `Workflow exported as "${filename}"`);
            
            // Save template to saved templates list
            saveWorkflowAsTemplate(exportData);
        }

        // Save workflow as template
        function saveWorkflowAsTemplate(workflowData) {
            // Check if template with this name already exists
            const existingIndex = state.savedTemplates.findIndex(t => 
                t.name === workflowData.name
            );
            
            if (existingIndex !== -1) {
                // Update existing template
                state.savedTemplates[existingIndex] = {
                    ...workflowData,
                    savedAt: new Date().toISOString()
                };
            } else {
                // Add new template
                state.savedTemplates.push({
                    ...workflowData,
                    savedAt: new Date().toISOString()
                });
            }
            
            // Limit to last 10 templates
            if (state.savedTemplates.length > 10) {
                state.savedTemplates = state.savedTemplates.slice(-10);
            }
            
            // Save to localStorage
            saveToLocalStorage();
        }

        // Load workflow template
        function loadWorkflowTemplate(template) {
            // Validate basic structure of the template
            if (!template.name || !template.steps || !Array.isArray(template.steps)) {
                showToast('error', 'Invalid Workflow', 'The workflow template is missing required fields.');
                return;
            }
            
            // Update state
            state.workflowTemplate = template;
            
            // Update UI
            domElements.workflowNameInput.value = template.name;
            
            // Clear previous nodes and connections
            state.nodes = [];
            state.connections = [];
            
            // Render workflow
            renderWorkflow();
        }

        // Render workflow
        function renderWorkflow() {
            // Clear canvas
            domElements.canvasContent.innerHTML = '';
            
            // Create nodes
            createNodes();
            
            // Create connections
            createConnections();
            
            // Fit view
            setTimeout(fitCanvasToView, 100);
        }

        // Create nodes
        function createNodes() {
            const steps = state.workflowTemplate.steps;
            
            // Calculate positions (respect saved positions if available)
            const nodePositions = state.workflowTemplate.nodePositions || [];
            const startX = 100;
            const startY = 100;
            const stepDistance = 300;
            
            // Create nodes for each step
            steps.forEach((step, index) => {
                // Create node element
                const node = document.createElement('div');
                node.className = 'workflow-node';
                node.id = `node-${step.id}`;
                node.setAttribute('data-node-id', step.id);
                node.setAttribute('data-step-index', index);
                
                // Set position (use saved position if available)
                const savedPosition = nodePositions.find(pos => pos.id === step.id);
                const x = savedPosition ? savedPosition.x : startX + (index * stepDistance);
                const y = savedPosition ? savedPosition.y : startY;
                
                node.style.left = `${x}px`;
                node.style.top = `${y}px`;
                
                // Generate node content
                node.innerHTML = `
                    <div class="node-header">
                        <span class="node-icon icon">${getIconForAgent(step.agent)}</span>
                        ${step.agent}
                    </div>
                    <div class="node-content">
                        <div class="node-title">${step.name}</div>
                        <div class="node-description">${step.description || 'No description available'}</div>
                        <div class="node-status status-waiting" id="node-status-${step.id}">
                            <span class="icon">hourglass_empty</span>
                            Waiting
                        </div>
                        <div class="parameter-item">
                            <div class="parameter-name">Skills</div>
                            <div class="parameter-value">${step.skills.join(', ')}</div>
                        </div>
                        <div class="node-actions">
                            <button class="node-edit-btn" data-node-id="${step.id}">
                                <span class="icon">edit</span>
                                Edit
                            </button>
                        </div>
                    </div>
                `;
                
                // Add connection points
                const inputPoint = document.createElement('div');
                inputPoint.className = 'node-connection connection-input';
                inputPoint.setAttribute('data-node-id', step.id);
                inputPoint.setAttribute('data-connection-type', 'input');
                
                const outputPoint = document.createElement('div');
                outputPoint.className = 'node-connection connection-output';
                outputPoint.setAttribute('data-node-id', step.id);
                outputPoint.setAttribute('data-connection-type', 'output');
                
                // Add connection points to node
                node.appendChild(inputPoint);
                node.appendChild(outputPoint);
                
                // Add node to canvas
                domElements.canvasContent.appendChild(node);
                
                // Make node draggable
                makeDraggable(node);
                
                // Add edit button event listener
                const editBtn = node.querySelector('.node-edit-btn');
                editBtn.addEventListener('click', () => openNodeEditor(step.id));
                
                // Add node to state
                state.nodes.push({
                    id: step.id,
                    element: node,
                    step: step,
                    index: index,
                    x: x,
                    y: y
                });
            });
        }

        // Make a node draggable
        function makeDraggable(nodeElement) {
            const header = nodeElement.querySelector('.node-header');
            
            header.addEventListener('mousedown', (e) => {
                e.preventDefault();
                e.stopPropagation();
                
                const startX = e.clientX;
                const startY = e.clientY;
                
                const nodeRect = nodeElement.getBoundingClientRect();
                const offsetX = startX - nodeRect.left;
                const offsetY = startY - nodeRect.top;
                
                const onMouseMove = (moveEvent) => {
                    moveEvent.preventDefault();
                    
                    const canvasContent = domElements.canvasContent;
                    const canvasRect = canvasContent.getBoundingClientRect();
                    
                    // Calculate new position relative to canvas content
                    const canvasX = (moveEvent.clientX - canvasRect.left - offsetX) / state.canvasState.scale;
                    const canvasY = (moveEvent.clientY - canvasRect.top - offsetY) / state.canvasState.scale;
                    
                    // Update node position
                    nodeElement.style.left = `${canvasX}px`;
                    nodeElement.style.top = `${canvasY}px`;
                    
                    // Update node position in state
                    const nodeId = nodeElement.getAttribute('data-node-id');
                    const node = state.nodes.find(n => n.id === nodeId);
                    if (node) {
                        node.x = canvasX;
                        node.y = canvasY;
                    }
                    
                    // Update connections
                    updateConnections();
                };
                
                const onMouseUp = () => {
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                };
                
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            });
        }

        // Create connections between nodes
        function createConnections() {
            const nodes = state.nodes;
            
            // Clear existing connections
            state.connections = [];
            const connectionElements = document.querySelectorAll('.connection-line');
            connectionElements.forEach(el => el.remove());
            
            // Create connections between consecutive nodes
            for (let i = 0; i < nodes.length - 1; i++) {
                const sourceNode = nodes[i];
                const targetNode = nodes[i + 1];
                
                createConnection(sourceNode, targetNode);
            }
        }

        // Update all connections
        function updateConnections() {
            // Remove existing connection lines
            const connectionElements = document.querySelectorAll('.connection-line');
            connectionElements.forEach(el => el.remove());
            
            // Recreate connections
            state.connections.forEach(connection => {
                const { sourceNode, targetNode } = connection;
                createConnection(sourceNode, targetNode, true);
            });
        }

        // Create a connection between two nodes
        function createConnection(sourceNode, targetNode, isUpdate = false) {
            // Get node elements
            const sourceElement = sourceNode.element;
            const targetElement = targetNode.element;
            
            // Get connection points
            const sourcePoint = sourceElement.querySelector('.connection-output');
            const targetPoint = targetElement.querySelector('.connection-input');
            
            // Get node positions and sizes
            const sourceRect = sourceElement.getBoundingClientRect();
            const targetRect = targetElement.getBoundingClientRect();
            
            // Calculate connection start and end points
            const startX = sourceNode.x + sourceElement.offsetWidth;
            const startY = sourceNode.y + (sourceElement.offsetHeight / 2);
            const endX = targetNode.x;
            const endY = targetNode.y + (targetElement.offsetHeight / 2);
            
            // Calculate connection properties
            const deltaX = endX - startX;
            const deltaY = endY - startY;
            const length = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            const angle = Math.atan2(deltaY, deltaX) * (180 / Math.PI);
            
            // Create connection element
            const connection = document.createElement('div');
            connection.className = 'connection-line';
            connection.id = `connection-${sourceNode.id}-${targetNode.id}`;
            connection.style.width = `${length}px`;
            connection.style.left = `${startX}px`;
            connection.style.top = `${startY}px`;
            connection.style.transform = `rotate(${angle}deg)`;
            
            // Add connection to canvas
            domElements.canvasContent.appendChild(connection);
            
            // Add or update connection in state
            if (!isUpdate) {
                state.connections.push({
                    id: `${sourceNode.id}-${targetNode.id}`,
                    element: connection,
                    sourceNode: sourceNode,
                    targetNode: targetNode,
                    startX: startX,
                    startY: startY,
                    endX: endX,
                    endY: endY,
                    length: length,
                    angle: angle
                });
            } else {
                // Find and update existing connection
                const connectionIndex = state.connections.findIndex(c => 
                    c.sourceNode.id === sourceNode.id && c.targetNode.id === targetNode.id
                );
                
                if (connectionIndex !== -1) {
                    state.connections[connectionIndex] = {
                        ...state.connections[connectionIndex],
                        element: connection,
                        startX: startX,
                        startY: startY,
                        endX: endX,
                        endY: endY,
                        length: length,
                        angle: angle
                    };
                }
            }
            
            return connection;
        }

        // Open node editor
        function openNodeEditor(nodeId) {
            const node = state.nodes.find(n => n.id === nodeId);
            if (!node) return;
            
            // Store node being edited
            state.nodeBeingEdited = node;
            
            // Set modal title
            domElements.nodeEditorTitle.textContent = `Edit Node: ${node.step.name}`;
            
            // Fill form fields
            domElements.nodeNameInput.value = node.step.name;
            domElements.nodeDescriptionInput.value = node.step.description || '';
            domElements.nodeAgentSelect.value = node.step.agent;
            domElements.nodeSystemPrompt.value = node.step.systemPrompt || '';
            
            // Set parameters
            domElements.nodeParamsEditor.value = JSON.stringify(node.step.parameters || {}, null, 2);
            
            // Update skills checkboxes
            updateNodeSkills();
            
            // Show selected skills
            setTimeout(() => {
                const checkboxes = domElements.nodeSkillsContainer.querySelectorAll('input[type="checkbox"]');
                checkboxes.forEach(checkbox => {
                    checkbox.checked = node.step.skills.includes(checkbox.value);
                });
            }, 100);
            
            // Show modal
            domElements.nodeEditorModal.classList.add('visible');
        }

        // Close node editor
        function closeNodeEditor() {
            domElements.nodeEditorModal.classList.remove('visible');
            state.nodeBeingEdited = null;
        }

        // Update node skills based on selected agent
        function updateNodeSkills() {
            const agent = domElements.nodeAgentSelect.value;
            const skills = agentSkills[agent] || [];
            
            // Clear skills container
            domElements.nodeSkillsContainer.innerHTML = '';
            
            // Add checkboxes for each skill
            skills.forEach(skill => {
                const checkboxContainer = document.createElement('div');
                checkboxContainer.className = 'checkbox-container';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `skill-${skill}`;
                checkbox.className = 'checkbox';
                checkbox.value = skill;
                
                const label = document.createElement('label');
                label.htmlFor = `skill-${skill}`;
                label.className = 'checkbox-label';
                label.textContent = skill;
                
                checkboxContainer.appendChild(checkbox);
                checkboxContainer.appendChild(label);
                
                domElements.nodeSkillsContainer.appendChild(checkboxContainer);
            });
            
            // Update parameters template based on agent
            const defaultParams = defaultAgentParameters[agent] || {};
            
            // If node being edited has parameters, merge with defaults
            if (state.nodeBeingEdited && state.nodeBeingEdited.step.parameters) {
                const mergedParams = { ...defaultParams, ...state.nodeBeingEdited.step.parameters };
                domElements.nodeParamsEditor.value = JSON.stringify(mergedParams, null, 2);
            } else {
                domElements.nodeParamsEditor.value = JSON.stringify(defaultParams, null, 2);
            }
        }

        // Save node edits
        function saveNodeEdits() {
            if (!state.nodeBeingEdited) return;
            
            try {
                // Parse parameters
                const parameters = JSON.parse(domElements.nodeParamsEditor.value);
                
                // Get selected skills
                const selectedSkills = [];
                const checkboxes = domElements.nodeSkillsContainer.querySelectorAll('input[type="checkbox"]:checked');
                checkboxes.forEach(checkbox => {
                    selectedSkills.push(checkbox.value);
                });
                
                // Update node
                const updatedStep = {
                    ...state.nodeBeingEdited.step,
                    name: domElements.nodeNameInput.value,
                    description: domElements.nodeDescriptionInput.value,
                    agent: domElements.nodeAgentSelect.value,
                    skills: selectedSkills,
                    systemPrompt: domElements.nodeSystemPrompt.value,
                    parameters: parameters
                };
                
                // Update in workflow template
                const stepIndex = state.workflowTemplate.steps.findIndex(s => s.id === state.nodeBeingEdited.id);
                if (stepIndex !== -1) {
                    state.workflowTemplate.steps[stepIndex] = updatedStep;
                }
                
                // Update in node state
                state.nodeBeingEdited.step = updatedStep;
                
                // Update node UI
                renderNodeUI(state.nodeBeingEdited);
                
                // Close modal
                closeNodeEditor();
                
                showToast('success', 'Node Updated', 'Node configuration saved successfully.');
            } catch (error) {
                showToast('error', 'Invalid Parameters', 'Please check the JSON parameters format.');
            }
        }

        // Render node UI
        function renderNodeUI(node) {
            const nodeElement = node.element;
            
            // Update node title and description
            const titleElement = nodeElement.querySelector('.node-title');
            const descriptionElement = nodeElement.querySelector('.node-description');
            const skillsElement = nodeElement.querySelector('.parameter-value');
            
            if (titleElement) titleElement.textContent = node.step.name;
            if (descriptionElement) descriptionElement.textContent = node.step.description || 'No description available';
            if (skillsElement) skillsElement.textContent = node.step.skills.join(', ');
            
            // Update header agent icon if agent changed
            const headerElement = nodeElement.querySelector('.node-header');
            headerElement.innerHTML = `
                <span class="node-icon icon">${getIconForAgent(node.step.agent)}</span>
                ${node.step.agent}
            `;
        }

        // Add new node
        function addNewNode() {
            if (!state.workflowTemplate) {
                showToast('error', 'No Workflow', 'Please create or import a workflow first.');
                return;
            }
            
            // Generate unique ID
            const newId = `step_${state.workflowTemplate.steps.length + 1}`;
            
            // Create new step
            const newStep = {
                id: newId,
                name: `New Step ${state.workflowTemplate.steps.length + 1}`,
                agent: "QuestionAndAnswer",
                description: "New step description",
                enabled: true,
                skills: ["list_questions"],
                systemPrompt: "You are a helpful assistant tasked with a specific role in this workflow.",
                parameters: {
                    action: "list_questions"
                }
            };
            
            // Add to workflow template
            state.workflowTemplate.steps.push(newStep);
            
            // Render workflow
            renderWorkflow();
            
            // Open editor for new node
            setTimeout(() => {
                openNodeEditor(newId);
            }, 100);
        }

        // Execute workflow
        async function executeWorkflow() {
            if (!state.workflowTemplate || state.workflowTemplate.steps.length === 0) {
                showToast('error', 'No Workflow', 'No workflow steps to execute.');
                return;
            }
            
            if (state.executionState.running) {
                showToast('warning', 'Already Running', 'Workflow execution is already in progress.');
                return;
            }
            
            // Get API information
            const apiUrl = state.apiUrl.trim();
            if (!apiUrl) {
                showToast('error', 'API Configuration', 'Please provide an API URL.');
                return;
            }
            
            // Get document content
            const documentContent = state.documentContent.trim();
            if (!documentContent) {
                showToast('error', 'Missing Content', 'Please provide document content for analysis.');
                return;
            }
            
            // Check if we should clear results before execution
            if (state.appSettings.clearResultsBeforeExecution) {
                // Reset results panel if it exists
                if (domElements.questionsList) {
                    domElements.questionsList.innerHTML = '<div class="text-center text-sm">No questions processed yet.</div>';
                }
                
                if (domElements.analysisResult) {
                    domElements.analysisResult.textContent = 'No document analysis results yet.';
                }
                
                if (domElements.apiLogs) {
                    domElements.apiLogs.textContent = '';
                }
            }
            
            // Initialize execution state
            state.executionState = {
                running: true,
                currentStepIndex: -1,
                steps: state.workflowTemplate.steps.map(step => ({
                    id: step.id,
                    name: step.name,
                    status: 'waiting',
                    startTime: null,
                    endTime: null,
                    result: null,
                    error: null
                })),
                startTime: new Date(),
                endTime: null,
                results: {
                    questions: [],
                    answersGenerated: 0,
                    answersSubmitted: 0,
                    documentAnalysis: null
                },
                apiLogs: []
            };
            
            // Reset node statuses
            resetNodeStatuses();
            
            // Reset timeline
            resetExecutionTimeline();
            
            // Reset metrics
            resetMetrics();
            
            // Show results panel
            openResultsPanel();
            
            // Show toast
            showToast('info', 'Workflow Started', 'Executing workflow steps...');
            
            // Execute workflow steps
            try {
                const workflowResult = await executeWorkflowSteps();
                
                // Complete execution
                state.executionState.endTime = new Date();
                state.executionState.running = false;
                
                // Add to execution history
                addToExecutionHistory(workflowResult);
                
                showToast('success', 'Workflow Completed', 'All steps executed successfully.');
            } catch (error) {
                console.error('Workflow execution error:', error);
                
                // Mark execution as failed
                state.executionState.endTime = new Date();
                state.executionState.running = false;
                
                // Add to execution history
                addToExecutionHistory({ 
                    status: 'failed',
                    error: error.message
                });
                
                showToast('error', 'Workflow Failed', error.message || 'An error occurred during execution.');
            }
        }

        // Execute workflow steps
        async function executeWorkflowSteps() {
            const steps = state.executionState.steps;
            let stepResults = {};
            
            for (let i = 0; i < steps.length; i++) {
                // Set current step
                state.executionState.currentStepIndex = i;
                const currentStep = steps[i];
                
                // Update step status
                updateStepStatus(i, 'running');
                
                try {
                    // Prepare step input (combining workflow context with step configuration)
                    const stepConfig = state.workflowTemplate.steps[i];
                    const stepInput = prepareStepInput(stepConfig, stepResults, i);
                    
                    // Execute step
                    const result = await executeApiStep(stepConfig, stepInput, i);
                    
                    // Store result
                    currentStep.result = result;
                    stepResults[stepConfig.id] = result;
                    
                    // Process step result for UI updates
                    processStepResult(result, i);
                    
                    // Mark step as completed
                    currentStep.endTime = new Date();
                    updateStepStatus(i, 'completed');
                } catch (error) {
                    console.error(`Error executing step ${i}:`, error);
                    
                    // Store error
                    currentStep.error = error.message;
                    currentStep.endTime = new Date();
                    
                    // Update step status
                    updateStepStatus(i, 'error', error.message);
                    
                    // Throw error to stop workflow
                    throw new Error(`Error in step "${currentStep.name}": ${error.message}`);
                }
            }
            
            return {
                status: 'completed',
                steps: stepResults
            };
        }

        // Prepare step input
        function prepareStepInput(stepConfig, previousResults, stepIndex) {
            // Start with the step's configured parameters
            const input = { ...stepConfig.parameters };
            
            // Add document content for relevant steps
            if (stepConfig.agent === 'ContextMemory' || 
                (stepIndex === 0 && stepConfig.agent === 'QuestionAndAnswer')) {
                input.documentContent = state.documentContent;
            }
            
            // For steps that need question data from previous steps
            if (stepIndex > 0 && (stepConfig.agent === 'QuestionAndAnswer' || stepConfig.agent === 'ManageMemory')) {
                // Find previous results with question data
                for (const [resultId, result] of Object.entries(previousResults)) {
                    if (result.questions || result.questionsList) {
                        input.previousQuestions = result.questions || result.questionsList || [];
                        break;
                    }
                    
                    // For auto_answer_questions step
                    if (stepConfig.agent === 'QuestionAndAnswer' && 
                        stepConfig.skills.includes('auto_answer_questions') &&
                        result.generatedAnswers) {
                        input.auto_answers = result.generatedAnswers;
                    }
                }
            }
            
            // Special handling for the document analysis step results
            if (stepIndex > 1 && stepConfig.agent === 'ManageMemory') {
                for (const [resultId, result] of Object.entries(previousResults)) {
                    if (result.documentAnalysis) {
                        input.documentAnalysis = result.documentAnalysis;
                        input.conversation_context = result.documentAnalysis;
                        break;
                    }
                }
            }
            
            return input;
        }

        // Execute API step
        async function executeApiStep(stepConfig, stepInput, stepIndex) {
            const apiUrl = state.apiUrl.trim();
            const apiKey = state.apiKey.trim();
            
            // Prepare request body
            const requestBody = {
                agent: stepConfig.agent,
                skills: stepConfig.skills,
                systemPrompt: stepConfig.systemPrompt,
                parameters: stepInput
            };
            
            // Log API request
            logApiActivity('request', requestBody);
            
            try {
                // Make API request
                const response = await fetch(`${apiUrl}/execute-agent`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        ...(apiKey ? { 'x-api-key': apiKey } : {})
                    },
                    body: JSON.stringify(requestBody)
                });
                
                // Check if response is ok
                if (!response.ok) {
                    const errorText = await response.text();
                    
                    // Log API error
                    logApiActivity('error', { 
                        status: response.status, 
                        statusText: response.statusText,
                        error: errorText
                    });
                    
                    throw new Error(`API Error: ${response.status} ${response.statusText} - ${errorText}`);
                }
                
                // Parse response
                const responseData = await response.json();
                
                // Log API response
                logApiActivity('response', responseData);
                
                // Simulate API response for demo purposes
                if (typeof window !== 'undefined' && !response.headers.get('x-served-by')) {
                    return simulateStepExecution(stepConfig, stepInput, stepIndex);
                }
                
                return responseData;
            } catch (error) {
                // Special handling for demo mode
                if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
                    console.warn('API connection failed. Falling back to demo mode.');
                    return simulateStepExecution(stepConfig, stepInput, stepIndex);
                }
                
                // Log API error
                logApiActivity('error', { 
                    message: error.message,
                    stack: error.stack
                });
                
                throw error;
            }
        }

        // Log API activity
        function logApiActivity(type, data) {
            const timestamp = new Date().toISOString();
            const logEntry = {
                timestamp,
                type,
                data
            };
            
            // Add to state
            state.executionState.apiLogs.push(logEntry);
            
            // Update logs display
            const formattedLog = `[${timestamp}] ${type.toUpperCase()}:\n${JSON.stringify(data, null, 2)}\n\n`;
            domElements.apiLogs.textContent += formattedLog;
            
            // Auto-scroll to bottom
            domElements.apiLogs.scrollTop = domElements.apiLogs.scrollHeight;
        }

        // Simulate step execution for demo purposes
        function simulateStepExecution(stepConfig, stepInput, stepIndex) {
            // Log simulation notice
            logApiActivity('info', { message: 'Running in simulation mode due to unavailable API' });
            
            // Return different results based on step type
            switch (stepIndex) {
                case 0: // List Available Questions
                    return simulateListQuestions();
                case 1: // Process Document
                    return simulateProcessDocument(stepInput.documentContent);
                case 2: // Generate Automatic Answers
                    return simulateGenerateAnswers(stepInput.previousQuestions, stepInput.documentAnalysis);
                case 3: // Submit Automatic Answers
                    return simulateSubmitAnswers(stepInput.auto_answers);
                case 4: // Generate Report
                    return simulateFinalReport();
                default:
                    return { message: "Step executed successfully", simulated: true };
            }
        }

        // Process step result to update UI
        function processStepResult(result, stepIndex) {
            switch (stepIndex) {
                case 0: // List Available Questions
                    processQuestionsResult(result);
                    break;
                case 1: // Process Document
                    processDocumentAnalysisResult(result);
                    break;
                case 2: // Generate Answers
                    processGeneratedAnswersResult(result);
                    break;
                case 3: // Submit Answers
                    processSubmittedAnswersResult(result);
                    break;
                case 4: // Final Report
                    processFinalReportResult(result);
                    break;
            }
            
            // Update execution timeline
            updateExecutionTimeline();
        }

        // Process questions result
        function processQuestionsResult(result) {
            // Extract questions from result
            const questions = result.questions || result.questionsList || [];
            
            // Update state
            state.executionState.results.questions = questions;
            state.executionState.results.totalQuestions = questions.length;
            state.executionState.results.unansweredQuestions = questions.filter(q => !q.answered).length;
            
            // Update metrics
            updateMetrics({
                totalQuestions: questions.length,
                unanswered: questions.filter(q => !q.answered).length
            });
            
            // Render questions list
            renderQuestionsList(questions);
        }

        // Process document analysis result
        function processDocumentAnalysisResult(result) {
            // Extract document analysis
            const documentAnalysis = result.documentAnalysis || result.analysis || result;
            
            // Update state
            state.executionState.results.documentAnalysis = documentAnalysis;
            
            // Update UI
            if (typeof documentAnalysis === 'string') {
                domElements.analysisResult.textContent = documentAnalysis;
            } else {
                domElements.analysisResult.textContent = JSON.stringify(documentAnalysis, null, 2);
            }
        }

        // Process generated answers result
        function processGeneratedAnswersResult(result) {
            // Extract generated answers
            const generatedAnswers = result.generatedAnswers || result.answers || [];
            
            // Update state
            state.executionState.results.answersGenerated = generatedAnswers.length;
            
            // Update metrics
            updateMetrics({
                answersGenerated: generatedAnswers.length
            });
        }

        // Process submitted answers result
        function processSubmittedAnswersResult(result) {
            // Extract submitted answers info
            const submittedAnswers = result.submittedAnswers || result.processedAnswers || [];
            const answersCount = submittedAnswers.length || result.submitted || 0;
            
            // Update state
            state.executionState.results.answersSubmitted = answersCount;
            
            // Mark questions as answered
            if (state.executionState.results.questions.length > 0) {
                // Create a map of question IDs to answers
                const answersMap = new Map();
                submittedAnswers.forEach(answer => {
                    answersMap.set(answer.question_id, answer);
                });
                
                // Update questions
                state.executionState.results.questions = state.executionState.results.questions.map(question => {
                    if (answersMap.has(question.id)) {
                        const answer = answersMap.get(question.id);
                        return {
                            ...question,
                            answered: true,
                            answer: answer.answer,
                            confidence: answer.confidence
                        };
                    }
                    return question;
                });
                
                // Re-render questions list
                renderQuestionsList(state.executionState.results.questions);
            }
            
            // Update metrics
            updateMetrics({
                answersSubmitted: answersCount
            });
            
            // Calculate success rate
            if (state.executionState.results.totalQuestions > 0) {
                const successRate = Math.round((answersCount / state.executionState.results.totalQuestions) * 100);
                updateMetrics({ successRate: `${successRate}%` });
            }
        }

        // Process final report result
        function processFinalReportResult(result) {
            // No special UI updates for final report currently
        }

        // Update step status
        function updateStepStatus(stepIndex, status, message = '') {
            const step = state.executionState.steps[stepIndex];
            const nodeId = step.id;
            
            // Update step in state
            step.status = status;
            
            if (status === 'running') {
                step.startTime = new Date();
            } else if (status === 'completed' || status === 'error') {
                step.endTime = new Date();
            }
            
            // Update node status in UI
            const statusElement = document.getElementById(`node-status-${nodeId}`);
            if (statusElement) {
                statusElement.className = `node-status status-${status}`;
                
                let statusHtml = '';
                switch (status) {
                    case 'running':
                        statusHtml = `
                            <span class="loading-spinner"></span>
                            Running...
                        `;
                        break;
                    case 'completed':
                        statusHtml = `
                            <span class="icon">check_circle</span>
                            Completed
                        `;
                        break;
                    case 'error':
                        statusHtml = `
                            <span class="icon">error</span>
                            Error
                        `;
                        break;
                    default:
                        statusHtml = `
                            <span class="icon">hourglass_empty</span>
                            Waiting
                        `;
                }
                
                statusElement.innerHTML = statusHtml;
            }
            
            // Update execution timeline
            updateExecutionTimeline();
        }

        // Update execution timeline
        function updateExecutionTimeline() {
            const steps = state.executionState.steps;
            const currentStepIndex = state.executionState.currentStepIndex;
            
            domElements.executionTimeline.innerHTML = '<div class="timeline-line"></div>';
            
            steps.forEach((step, index) => {
                const timelineItem = document.createElement('div');
                timelineItem.className = `timeline-item ${step.status}`;
                
                let timeInfo = '';
                if (step.startTime) {
                    const startTime = new Date(step.startTime).toLocaleTimeString();
                    if (step.endTime) {
                        const endTime = new Date(step.endTime).toLocaleTimeString();
                        const duration = Math.round((new Date(step.endTime) - new Date(step.startTime)) / 1000);
                        timeInfo = `${startTime} - ${endTime} (${duration}s)`;
                    } else {
                        timeInfo = `Started at ${startTime}`;
                    }
                }
                
                timelineItem.innerHTML = `
                    <div class="timeline-dot"></div>
                    <div class="timeline-content">
                        <div class="timeline-title">${index + 1}. ${step.name}</div>
                        <div class="timeline-info">${timeInfo}</div>
                        ${step.error ? `<div class="text-xs" style="color: var(--error-color);">${step.error}</div>` : ''}
                    </div>
                `;
                
                domElements.executionTimeline.appendChild(timelineItem);
            });
        }

        // Update metrics
        function updateMetrics(metrics) {
            if (metrics.totalQuestions !== undefined) {
                domElements.metricTotalQuestions.textContent = metrics.totalQuestions;
            }
            
            if (metrics.unanswered !== undefined) {
                domElements.metricUnanswered.textContent = metrics.unanswered;
            }
            
            if (metrics.answersGenerated !== undefined) {
                // Only update if greater than current value
                const currentValue = parseInt(domElements.metricAnswersFound.textContent) || 0;
                if (metrics.answersGenerated > currentValue) {
                    domElements.metricAnswersFound.textContent = metrics.answersGenerated;
                }
            }
            
            if (metrics.answersSubmitted !== undefined) {
                // Calculate success rate
                const totalQuestions = parseInt(domElements.metricTotalQuestions.textContent) || 0;
                if (totalQuestions > 0) {
                    const successRate = Math.round((metrics.answersSubmitted / totalQuestions) * 100);
                    domElements.metricSuccessRate.textContent = `${successRate}%`;
                }
            }
            
            if (metrics.successRate !== undefined) {
                domElements.metricSuccessRate.textContent = metrics.successRate;
            }
        }

        // Render questions list
        function renderQuestionsList(questions) {
            const questionsList = domElements.questionsList;
            
            if (!questions || questions.length === 0) {
                questionsList.innerHTML = '<div class="text-center text-sm">No questions processed yet.</div>';
                return;
            }
            
            // Group questions by section
            const sectionMap = {};
            questions.forEach(question => {
                const section = question.section || 'General';
                if (!sectionMap[section]) {
                    sectionMap[section] = [];
                }
                sectionMap[section].push(question);
            });
            
            // Clear questions list
            questionsList.innerHTML = '';
            
            // Render questions by section
            for (const [section, sectionQuestions] of Object.entries(sectionMap)) {
                const sectionEl = document.createElement('div');
                sectionEl.className = 'mb-4';
                
                const sectionTitle = document.createElement('h3');
                sectionTitle.className = 'text-sm font-bold mb-2';
                sectionTitle.textContent = section;
                sectionEl.appendChild(sectionTitle);
                
                sectionQuestions.forEach(question => {
                    const questionEl = document.createElement('div');
                    questionEl.className = `question-item ${question.answered ? 'answered' : ''}`;
                    
                    let questionHtml = `
                        <div class="question-header">
                            <div class="question-text">${question.question}</div>
                            <div class="question-id">${question.id}</div>
                        </div>
                    `;
                    
                    if (question.answered && question.answer) {
                        questionHtml += `
                            <div class="answer-content">
                                ${question.answer}
                                ${question.confidence ? `<div class="text-xs text-gray-500 mt-1">Confidence: ${Math.round(question.confidence * 100)}%</div>` : ''}
                            </div>
                        `;
                    }
                    
                    questionEl.innerHTML = questionHtml;
                    sectionEl.appendChild(questionEl);
                });
                
                questionsList.appendChild(sectionEl);
            }
        }

        // Reset node statuses
        function resetNodeStatuses() {
            state.nodes.forEach(node => {
                const statusElement = document.getElementById(`node-status-${node.id}`);
                if (statusElement) {
                    statusElement.className = 'node-status status-waiting';
                    statusElement.innerHTML = `
                        <span class="icon">hourglass_empty</span>
                        Waiting
                    `;
                }
            });
        }

        // Reset execution timeline
        function resetExecutionTimeline() {
            domElements.executionTimeline.innerHTML = '<div class="timeline-line"></div>';
            domElements.apiLogs.textContent = '';
        }

        // Reset metrics
        function resetMetrics() {
            domElements.metricTotalQuestions.textContent = '0';
            domElements.metricUnanswered.textContent = '0';
            domElements.metricAnswersFound.textContent = '0';
            domElements.metricSuccessRate.textContent = '0%';
        }

        // Load sample text
        function loadSampleText() {
            domElements.documentContent.value = sampleDocumentText;
            state.documentContent = sampleDocumentText;
            saveToLocalStorage();
        }

        // Show toast notification
        function showToast(type, title, message) {
            const toast = document.createElement('div');
            toast.className = `toast toast-${type}`;
            
            let icon = '';
            switch (type) {
                case 'success':
                    icon = 'check_circle';
                    break;
                case 'error':
                    icon = 'error';
                    break;
                case 'warning':
                    icon = 'warning';
                    break;
                case 'info':
                    icon = 'info';
                    break;
            }
            
            toast.innerHTML = `
                <div class="toast-icon icon">${icon}</div>
                <div class="toast-content">
                    <div class="toast-title">${title}</div>
                    <div class="toast-message">${message}</div>
                </div>
            `;
            
            domElements.toastContainer.appendChild(toast);
            
            // Remove toast after 5 seconds
            setTimeout(() => {
                toast.style.opacity = '0';
                toast.style.transform = 'translateX(100%)';
                setTimeout(() => {
                    domElements.toastContainer.removeChild(toast);
                }, 300);
            }, 5000);
        }

        // Get icon for agent
        function getIconForAgent(agent) {
            const icons = {
                'QuestionAndAnswer': 'quiz',
                'ContextMemory': 'memory',
                'ManageMemory': 'database',
                'EmailDrafting': 'mail',
                'LearnNewAgent': 'school'
            };
            
            return icons[agent] || 'extension';
        }

        // Execution History Management
        function populateExecutionHistory() {
            // Clear the table body
            domElements.historyTableBody.innerHTML = '';
            
            // Get execution history
            const history = state.executionHistory || [];
            
            // Update UI based on history length
            if (history.length === 0) {
                domElements.historyEmptyState.style.display = 'block';
                domElements.historyTable.style.display = 'none';
                return;
            } else {
                domElements.historyEmptyState.style.display = 'none';
                domElements.historyTable.style.display = 'table';
            }
            
            // Filter history based on current criteria
            filterExecutionHistory();
        }

        function filterExecutionHistory() {
            const history = state.executionHistory || [];
            const searchTerm = domElements.historySearch.value.toLowerCase();
            const filter = state.filterCriteria.history;
            
            // Apply filters
            state.filteredHistory = history.filter(entry => {
                // Apply search term filter
                if (searchTerm && !entry.workflowName.toLowerCase().includes(searchTerm)) {
                    return false;
                }
                
                // Apply status filter
                if (filter === 'completed' && entry.status !== 'completed') {
                    return false;
                }
                
                if (filter === 'failed' && entry.status !== 'failed') {
                    return false;
                }
                
                // Apply date filters
                if (filter === 'today') {
                    const today = new Date();
                    const entryDate = new Date(entry.startTime);
                    
                    return today.toDateString() === entryDate.toDateString();
                }
                
                if (filter === 'week') {
                    const today = new Date();
                    const entryDate = new Date(entry.startTime);
                    const oneWeekAgo = new Date(today);
                    oneWeekAgo.setDate(today.getDate() - 7);
                    
                    return entryDate >= oneWeekAgo;
                }
                
                return true;
            });
            
            // Render filtered history
            renderExecutionHistory();
        }

        function renderExecutionHistory() {
            // Clear the table body
            domElements.historyTableBody.innerHTML = '';
            
            // Show/hide empty state
            if (state.filteredHistory.length === 0) {
                domElements.historyEmptyState.style.display = 'block';
                domElements.historyTable.style.display = 'none';
                return;
            } else {
                domElements.historyEmptyState.style.display = 'none';
                domElements.historyTable.style.display = 'table';
            }
            
            // Render each history entry
            state.filteredHistory.forEach(entry => {
                const row = document.createElement('tr');
                row.setAttribute('data-execution-id', entry.id);
                
                // Format execution time
                const executionDate = new Date(entry.startTime);
                const formattedDate = executionDate.toLocaleDateString() + ' ' + 
                             executionDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                
                // Format duration
                const durationInSeconds = Math.round(entry.duration / 1000);
                const formattedDuration = durationInSeconds < 60 
                    ? `${durationInSeconds}s` 
                    : `${Math.floor(durationInSeconds / 60)}m ${durationInSeconds % 60}s`;
                
                // Create cells
                row.innerHTML = `
                    <td>
                        <div class="font-medium">${entry.workflowName}</div>
                        <div class="text-xs text-lighter">${entry.steps.length} steps</div>
                    </td>
                    <td>${formattedDate}</td>
                    <td>${formattedDuration}</td>
                    <td>
                        <div class="history-status ${entry.status}">
                            <span class="icon">${entry.status === 'completed' ? 'check_circle' : 'error'}</span>
                            ${entry.status.charAt(0).toUpperCase() + entry.status.slice(1)}
                        </div>
                    </td>
                    <td>
                        <div class="history-actions">
                            <button class="history-action-btn view-execution-btn" title="View Details">
                                <span class="icon">visibility</span>
                            </button>
                            <button class="history-action-btn replay-execution-btn" title="Replay Execution">
                                <span class="icon">replay</span>
                            </button>
                        </div>
                    </td>
                `;
                
                // Add event listeners
                const viewBtn = row.querySelector('.view-execution-btn');
                viewBtn.addEventListener('click', function() {
                    viewExecutionDetails(entry.id);
                });
                
                const replayBtn = row.querySelector('.replay-execution-btn');
                replayBtn.addEventListener('click', function() {
                    replayExecution(entry.id);
                });
                
                // Add to table
                domElements.historyTableBody.appendChild(row);
            });
        }

        function viewExecutionDetails(executionId) {
            // Find the execution
            const execution = state.executionHistory.find(e => e.id === executionId);
            if (!execution) return;
            
            // Store selected execution
            state.selectedExecution = execution;
            
            // Populate the modal
            domElements.executionDetailsTitle.textContent = `Execution: ${execution.workflowName}`;
            domElements.executionDetailsWorkflow.textContent = execution.workflowName;
            
            // Set status
            domElements.executionDetailsStatus.className = `history-status ${execution.status}`;
            domElements.executionDetailsStatus.innerHTML = `
                <span class="icon">${execution.status === 'completed' ? 'check_circle' : 'error'}</span>
                ${execution.status.charAt(0).toUpperCase() + execution.status.slice(1)}
            `;
            
            // Set times
            const startDate = new Date(execution.startTime);
            domElements.executionDetailsStarted.textContent = startDate.toLocaleString();
            
            // Format duration
            const durationInSeconds = Math.round(execution.duration / 1000);
            const formattedDuration = durationInSeconds < 60 
                ? `${durationInSeconds} seconds` 
                : `${Math.floor(durationInSeconds / 60)} min ${durationInSeconds % 60} sec`;
            domElements.executionDetailsDuration.textContent = formattedDuration;
            
            // Populate timeline
            populateExecutionTimeline(execution);
            
            // Set metrics
            domElements.executionDetailsQuestions.textContent = execution.metrics?.totalQuestions || 0;
            domElements.executionDetailsAnswers.textContent = execution.metrics?.answersGenerated || 0;
            
            // Set error info
            if (execution.error) {
                domElements.executionDetailsErrorContainer.style.display = 'block';
                domElements.executionDetailsError.textContent = execution.error;
            } else {
                domElements.executionDetailsErrorContainer.style.display = 'none';
            }
            
            // Open modal
            domElements.executionDetailsModal.classList.add('visible');
        }

        function populateExecutionTimeline(execution) {
            // Clear the timeline
            domElements.executionDetailsTimeline.innerHTML = '<div class="timeline-line"></div>';
            
            // Add steps to timeline
            execution.steps.forEach((step, index) => {
                const timelineItem = document.createElement('div');
                timelineItem.className = `timeline-item ${step.status}`;
                
                let timeInfo = '';
                if (step.startTime) {
                    const startTime = new Date(step.startTime).toLocaleTimeString([], 
                        {hour: '2-digit', minute: '2-digit', second: '2-digit'});
                    
                    if (step.endTime) {
                        const endTime = new Date(step.endTime).toLocaleTimeString([], 
                            {hour: '2-digit', minute: '2-digit', second: '2-digit'});
                        const duration = Math.round((new Date(step.endTime) - new Date(step.startTime)) / 1000);
                        timeInfo = `${startTime} - ${endTime} (${duration}s)`;
                    } else {
                        timeInfo = `Started at ${startTime}`;
                    }
                }
                
                timelineItem.innerHTML = `
                    <div class="timeline-dot"></div>
                    <div class="timeline-content">
                        <div class="timeline-title">${index + 1}. ${step.name}</div>
                        <div class="timeline-info">${timeInfo}</div>
                        ${step.error ? `<div class="text-xs" style="color: var(--error-color);">${step.error}</div>` : ''}
                    </div>
                `;
                
                domElements.executionDetailsTimeline.appendChild(timelineItem);
            });
        }

        function closeExecutionDetailsModal() {
            domElements.executionDetailsModal.classList.remove('visible');
            state.selectedExecution = null;
        }

        function replayExecution(executionId) {
            // If no id provided, use the selected execution
            if (!executionId && state.selectedExecution) {
                executionId = state.selectedExecution.id;
            }
            
            // Find the execution
            const execution = state.executionHistory.find(e => e.id === executionId);
            if (!execution) return;
            
            // Close modal if open
            closeExecutionDetailsModal();
            
            // Switch to editor view
            switchView('editor');
            
            // Check if we need to load the workflow template
            // This would require storing the workflow template with the execution
            // or searching for a matching template by name
            const matchingTemplate = state.savedTemplates.find(t => t.name === execution.workflowName);
            
            if (matchingTemplate) {
                // Load the template
                loadWorkflowTemplate(matchingTemplate);
                
                // Execute the workflow
                setTimeout(() => {
                    executeWorkflow();
                }, 500);
            } else {
                showToast('error', 'Cannot Replay', 'The original workflow template is not available.');
            }
        }

        // Templates Management
        function populateTemplates() {
            // Clear the template list
            domElements.templateList.innerHTML = '';
            
            // Get templates
            const templates = state.savedTemplates || [];
            
            // Update UI based on templates length
            if (templates.length === 0) {
                domElements.templatesEmptyState.style.display = 'block';
                domElements.templateList.style.display = 'none';
                return;
            } else {
                domElements.templatesEmptyState.style.display = 'none';
                domElements.templateList.style.display = 'grid';
            }
            
            // Filter templates based on search term
            filterTemplates();
        }

        function filterTemplates() {
            const templates = state.savedTemplates || [];
            const searchTerm = domElements.templatesSearch.value.toLowerCase();
            
            // Apply filters
            state.filteredTemplates = templates.filter(template => {
                // Apply search term filter
                if (searchTerm) {
                    return template.name.toLowerCase().includes(searchTerm) || 
                           (template.description && template.description.toLowerCase().includes(searchTerm));
                }
                
                return true;
            });
            
            // Render filtered templates
            renderTemplates();
        }

        function renderTemplates() {
            // Clear the template list
            domElements.templateList.innerHTML = '';
            
            // Show/hide empty state
            if (state.filteredTemplates.length === 0) {
                domElements.templatesEmptyState.style.display = 'block';
                domElements.templateList.style.display = 'none';
                return;
            } else {
                domElements.templatesEmptyState.style.display = 'none';
                domElements.templateList.style.display = 'grid';
            }
            
            // Render each template
            state.filteredTemplates.forEach(template => {
                const templateCard = document.createElement('div');
                templateCard.className = 'template-card';
                templateCard.setAttribute('data-template-id', template.id || template.name);
                
                // Format dates
                const createdDate = template.metadata?.created 
                    ? new Date(template.metadata.created).toLocaleDateString() 
                    : 'Unknown';
                
                const savedDate = template.savedAt 
                    ? new Date(template.savedAt).toLocaleDateString() 
                    : createdDate;
                
                // Create template card
                templateCard.innerHTML = `
                    <div class="template-header">
                        <div class="template-title">${template.name}</div>
                        <div class="template-metadata">
                            <div>Version ${template.version || '1.0'}</div>
                            <div>Saved: ${savedDate}</div>
                        </div>
                    </div>
                    <div class="template-body">
                        <div class="template-description">${template.description || 'No description available'}</div>
                        <div class="template-stats">
                            <div class="template-stat">
                                <span class="icon">schema</span>
                                ${template.steps?.length || 0} steps
                            </div>
                        </div>
                        <div class="template-actions">
                            <button class="btn btn-outline view-template-btn">
                                <span class="icon">visibility</span>
                                View
                            </button>
                            <button class="btn btn-primary load-template-btn">
                                <span class="icon">play_arrow</span>
                                Load
                            </button>
                        </div>
                    </div>
                `;
                
                // Add event listeners
                const viewBtn = templateCard.querySelector('.view-template-btn');
                viewBtn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    viewTemplateDetails(template.id || template.name);
                });
                
                const loadBtn = templateCard.querySelector('.load-template-btn');
                loadBtn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    loadWorkflowTemplate(template);
                    switchView('editor');
                });
                
                // Card click loads template details
                templateCard.addEventListener('click', function() {
                    viewTemplateDetails(template.id || template.name);
                });
                
                // Add to list
                domElements.templateList.appendChild(templateCard);
            });
        }

        function viewTemplateDetails(templateId) {
            // Find the template
            const template = state.savedTemplates.find(t => (t.id || t.name) === templateId);
            if (!template) return;
            
            // Store selected template
            state.selectedTemplate = template;
            
            // Populate the modal
            domElements.templateViewTitle.textContent = template.name;
            domElements.templateViewDescription.textContent = template.description || 'No description available';
            
            // Set metadata
            domElements.templateViewCreated.textContent = template.metadata?.created 
                ? new Date(template.metadata.created).toLocaleString() 
                : 'Unknown';
            
            domElements.templateViewModified.textContent = template.savedAt 
                ? new Date(template.savedAt).toLocaleString() 
                : 'Unknown';
            
            domElements.templateViewVersion.textContent = template.version || '1.0';
            
            // Populate steps
            populateTemplateSteps(template);
            
            // Open modal
            domElements.templateViewModal.classList.add('visible');
        }

        function populateTemplateSteps(template) {
            // Clear the steps container
            domElements.templateViewSteps.innerHTML = '';
            
            // Create a list for steps
            const stepsList = document.createElement('ol');
            stepsList.style.paddingLeft = '20px';
            
            // Add each step
            if (template.steps && template.steps.length > 0) {
                template.steps.forEach(step => {
                    const stepItem = document.createElement('li');
                    stepItem.className = 'mb-4';
                    
                    stepItem.innerHTML = `
                        <div class="font-medium">${step.name}</div>
                        <div class="text-xs text-lighter">${step.agent} - ${step.description || 'No description'}</div>
                    `;
                    
                    stepsList.appendChild(stepItem);
                });
                
                domElements.templateViewSteps.appendChild(stepsList);
            } else {
                domElements.templateViewSteps.textContent = 'No steps defined in this template.';
            }
        }

        function closeTemplateViewModal() {
            domElements.templateViewModal.classList.remove('visible');
            state.selectedTemplate = null;
        }

        function loadSelectedTemplate() {
            if (state.selectedTemplate) {
                loadWorkflowTemplate(state.selectedTemplate);
                closeTemplateViewModal();
                switchView('editor');
            }
        }

        function createNewTemplate() {
            // Check if a workflow is currently loaded
            if (state.workflowTemplate) {
                // Create a copy of the current workflow
                saveWorkflowAsTemplate(state.workflowTemplate);
                
                showToast('success', 'Template Created', 'Current workflow saved as template.');
                
                // Switch to templates view and refresh
                switchView('templates');
                populateTemplates();
            } else {
                showToast('error', 'No Workflow', 'Please create or load a workflow first.');
            }
        }

        // Settings Management
        function populateSettings() {
            // Set API configuration
            domElements.settingsApiUrl.value = state.apiUrl || '';
            domElements.settingsApiKey.value = state.apiKey || '';
            
            // Set checkboxes
            domElements.autoSaveCheckbox.checked = state.appSettings.autoSave !== false;
            domElements.clearResultsCheckbox.checked = state.appSettings.clearResultsBeforeExecution !== false;
            domElements.showWelcomeCheckbox.checked = state.appSettings.showWelcomeOnStartup !== false;
            
            // Set history limit dropdown
            domElements.historyLimit.value = state.appSettings.historyLimit || 20;
            
            // Select theme
            domElements.themeOptions.forEach(option => {
                option.classList.toggle('active', option.getAttribute('data-theme') === state.appSettings.theme);
            });
            
            // Select color scheme
            domElements.colorSchemes.forEach(scheme => {
                scheme.classList.toggle('active', scheme.getAttribute('data-color') === state.appSettings.accentColor);
            });
            
            // Update storage metrics
            updateStorageMetrics();
        }

        function updateStorageMetrics() {
            // Update workflow count
            domElements.storageWorkflows.textContent = state.savedTemplates?.length || 0;
            
            // Update history count
            domElements.storageHistory.textContent = state.executionHistory?.length || 0;
        }

        function setTheme(theme) {
            // Update state
            state.appSettings.theme = theme;
            
            // Update UI
            domElements.themeOptions.forEach(option => {
                option.classList.toggle('active', option.getAttribute('data-theme') === theme);
            });
            
            // Apply theme
            applyTheme();
            
            // Save settings
            saveSettings();
        }

        function setAccentColor(color) {
            // Update state
            state.appSettings.accentColor = color;
            
            // Update UI
            domElements.colorSchemes.forEach(scheme => {
                scheme.classList.toggle('active', scheme.getAttribute('data-color') === color);
            });
            
            // Apply theme
            applyTheme();
            
            // Save settings
            saveSettings();
        }

        function applyTheme() {
            const theme = state.appSettings.theme || 'light';
            const color = state.appSettings.accentColor || 'blue';
            
            // Apply theme class to body
            document.body.className = `theme-${theme} color-${color}`;
            
            // In a full implementation, we would update CSS variables here
            // This is a simplified version
        }

        function saveSettings() {
            // Save settings in localStorage
            try {
                const settingsToSave = {
                    apiUrl: state.apiUrl,
                    apiKey: state.apiKey,
                    theme: state.appSettings.theme,
                    accentColor: state.appSettings.accentColor,
                    autoSave: state.appSettings.autoSave,
                    clearResultsBeforeExecution: state.appSettings.clearResultsBeforeExecution,
                    showWelcomeOnStartup: state.appSettings.showWelcomeOnStartup,
                    historyLimit: state.appSettings.historyLimit
                };
                
                localStorage.setItem('workflowExecutorSettings', JSON.stringify(settingsToSave));
            } catch (error) {
                console.error('Error saving settings:', error);
            }
        }

        function loadSettings() {
            try {
                const savedSettings = localStorage.getItem('workflowExecutorSettings');
                if (savedSettings) {
                    const parsedSettings = JSON.parse(savedSettings);
                    
                    // Update state with saved settings
                    state.apiUrl = parsedSettings.apiUrl || state.apiUrl;
                    state.apiKey = parsedSettings.apiKey || state.apiKey;
                    state.appSettings.theme = parsedSettings.theme || state.appSettings.theme;
                    state.appSettings.accentColor = parsedSettings.accentColor || state.appSettings.accentColor;
                    state.appSettings.autoSave = parsedSettings.autoSave !== undefined ? parsedSettings.autoSave : state.appSettings.autoSave;
                    state.appSettings.clearResultsBeforeExecution = parsedSettings.clearResultsBeforeExecution !== undefined ? 
                        parsedSettings.clearResultsBeforeExecution : state.appSettings.clearResultsBeforeExecution;
                    state.appSettings.showWelcomeOnStartup = parsedSettings.showWelcomeOnStartup !== undefined ? 
                        parsedSettings.showWelcomeOnStartup : state.appSettings.showWelcomeOnStartup;
                    state.appSettings.historyLimit = parsedSettings.historyLimit || state.appSettings.historyLimit;
                }
            } catch (error) {
                console.error('Error loading settings:', error);
            }
        }

        function testApiConnection() {
            const apiUrl = state.apiUrl.trim();
            const apiKey = state.apiKey.trim();
            
            if (!apiUrl) {
                showToast('error', 'API Configuration', 'Please provide an API URL.');
                return;
            }
            
            // Set button to loading state
            domElements.testApiBtn.innerHTML = `
                <span class="loading-spinner"></span>
                Testing...
            `;
            
            // Simulate API test since we're building a demo
            setTimeout(() => {
                // Show success message (in real app this would depend on actual API response)
                showToast('success', 'Connection Successful', 'API is accessible and responding correctly.');
                
                // Reset button
                domElements.testApiBtn.innerHTML = `
                    <span class="icon">network_check</span>
                    Test Connection
                `;
            }, 1500);
        }

        function showConfirmResetModal() {
            domElements.confirmResetModal.classList.add('visible');
        }

        function closeConfirmResetModal() {
            domElements.confirmResetModal.classList.remove('visible');
        }

        function clearAllData() {
            try {
                // Clear localStorage
                localStorage.removeItem('workflowExecutorState');
                localStorage.removeItem('workflowExecutorSettings');
                
                // Reset state
                state.executionHistory = [];
                state.savedTemplates = [];
                state.workflowTemplate = null;
                state.apiUrl = 'http://localhost:7071/api/';
                state.apiKey = '';
                state.appSettings = {
                    theme: 'light',
                    accentColor: 'blue',
                    autoSave: true,
                    clearResultsBeforeExecution: true,
                    showWelcomeOnStartup: true,
                    historyLimit: 20
                };
                
                // Update UI
                updateStorageMetrics();
                applyTheme();
                
                // Clear canvas
                domElements.canvasContent.innerHTML = '';
                
                // Show success message
                showToast('success', 'Data Cleared', 'All application data has been reset successfully.');
                
                // Switch to editor view
                switchView('editor');
            } catch (error) {
                console.error('Error clearing data:', error);
                showToast('error', 'Reset Failed', 'An error occurred while trying to reset application data.');
            }
        }

        function exportAllData() {
            try {
                // Prepare export data
                const exportData = {
                    version: "1.0",
                    exportedAt: new Date().toISOString(),
                    settings: state.appSettings,
                    apiConfig: {
                        apiUrl: state.apiUrl,
                        // We don't export API keys for security reasons
                    },
                    workflows: state.savedTemplates,
                    executionHistory: state.executionHistory
                };
                
                // Convert to JSON
                const jsonData = JSON.stringify(exportData, null, 2);
                
                // Create download link
                const blob = new Blob([jsonData], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                // Create temporary link and trigger download
                const link = document.createElement('a');
                link.href = url;
                
                // Format filename with date
                const date = new Date().toISOString().split('T')[0];
                const filename = `workflow_executor_export_${date}.json`;
                
                link.download = filename;
                link.click();
                
                // Clean up
                URL.revokeObjectURL(url);
                
                showToast('success', 'Export Successful', `All data exported to "${filename}"`);
            } catch (error) {
                console.error('Error exporting data:', error);
                showToast('error', 'Export Failed', 'An error occurred while trying to export application data.');
            }
        }

        function importData(file) {
            if (file.type !== 'application/json') {
                showToast('error', 'Invalid File Type', 'Please upload a JSON file.');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importedData = JSON.parse(e.target.result);
                    
                    // Validate the imported data structure
                    if (!importedData.version || !importedData.exportedAt) {
                        throw new Error('Invalid export file format.');
                    }
                    
                    // Import settings
                    if (importedData.settings) {
                        state.appSettings = {
                            ...state.appSettings,
                            ...importedData.settings
                        };
                        applyTheme();
                    }
                    
                    // Import API config (but not API key for security)
                    if (importedData.apiConfig && importedData.apiConfig.apiUrl) {
                        state.apiUrl = importedData.apiConfig.apiUrl;
                    }
                    
                    // Import workflows/templates
                    if (importedData.workflows && Array.isArray(importedData.workflows)) {
                        // Merge with existing templates
                        const existingIds = new Set(state.savedTemplates.map(t => t.id || t.name));
                        
                        importedData.workflows.forEach(workflow => {
                            const workflowId = workflow.id || workflow.name;
                            
                            if (!existingIds.has(workflowId)) {
                                state.savedTemplates.push(workflow);
                            }
                        });
                    }
                    
                    // Import execution history
                    if (importedData.executionHistory && Array.isArray(importedData.executionHistory)) {
                        // Merge with existing history
                        const existingIds = new Set(state.executionHistory.map(h => h.id));
                        
                        importedData.executionHistory.forEach(execution => {
                            if (!existingIds.has(execution.id)) {
                                state.executionHistory.push(execution);
                            }
                        });
                        
                        // Apply history limit
                        if (state.appSettings.historyLimit > 0) {
                            state.executionHistory = state.executionHistory
                                .sort((a, b) => new Date(b.startTime) - new Date(a.startTime))
                                .slice(0, state.appSettings.historyLimit);
                        }
                    }
                    
                    // Save to localStorage
                    saveToLocalStorage();
                    saveSettings();
                    
                    // Update UI
                    updateStorageMetrics();
                    
                    showToast('success', 'Import Successful', 'Application data imported successfully.');
                } catch (error) {
                    console.error('Error importing data:', error);
                    showToast('error', 'Import Failed', `Could not import data: ${error.message}`);
                }
            };
            reader.readAsText(file);
        }

        // Modify the existing addToExecutionHistory function to respect history limit
        function addToExecutionHistory(result) {
            const executionEntry = {
                id: generateUniqueId(),
                workflowName: state.workflowTemplate.name,
                startTime: state.executionState.startTime.toISOString(),
                endTime: state.executionState.endTime.toISOString(),
                duration: state.executionState.endTime - state.executionState.startTime,
                steps: state.executionState.steps.map(step => ({
                    id: step.id,
                    name: step.name,
                    status: step.status,
                    startTime: step.startTime ? step.startTime.toISOString() : null,
                    endTime: step.endTime ? step.endTime.toISOString() : null,
                    result: step.result,
                    error: step.error
                })),
                metrics: {
                    totalQuestions: state.executionState.results.totalQuestions || 0,
                    answersGenerated: state.executionState.results.answersGenerated || 0,
                    answersSubmitted: state.executionState.results.answersSubmitted || 0
                },
                status: result.status || 'completed',
                error: result.error || null
            };
            
            // Add to start of history array
            state.executionHistory.unshift(executionEntry);
            
            // Apply history limit from settings
            const limit = state.appSettings.historyLimit || 20;
            if (limit > 0 && state.executionHistory.length > limit) {
                state.executionHistory = state.executionHistory.slice(0, limit);
            }
            
            // Save to localStorage
            saveToLocalStorage();
        }

        // Generate unique ID
        function generateUniqueId() {
            return `exec_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
        }

        // Simulate question listing
        function simulateListQuestions() {
            // Generate some sample questions
            const sections = ['Organisation', 'Objectives', 'Technology', 'Team', 'Financial'];
            const questions = [];
            
            sections.forEach(section => {
                const numQuestions = Math.floor(Math.random() * 3) + 2; // 2-4 questions per section
                
                for (let i = 0; i < numQuestions; i++) {
                    const questionId = `${section.substring(0, 3).toLowerCase()}_${100100 + i}`;
                    
                    let questionText = '';
                    switch (section) {
                        case 'Organisation':
                            questionText = ['Company name?', 'Company address?', 'When was the company established?', 
                                          'Who is the current CEO?', 'How many employees does the company have?'][i % 5];
                            break;
                        case 'Objectives':
                            questionText = ['What are the primary business objectives?', 'Is expansion planned?',
                                          'What cost reduction targets exist?', 'Any sustainability goals?'][i % 4];
                            break;
                        case 'Technology':
                            questionText = ['What is the primary technology stack?', 'What cloud platforms are used?',
                                          'What security protocols are implemented?', 'What databases are used?'][i % 4];
                                          break;
                        case 'Team':
                            questionText = ['Who is the technical lead?', 'How many full-time employees?',
                                          'What is the organizational structure?'][i % 3];
                            break;
                        case 'Financial':
                            questionText = ['What is the annual revenue?', 'What is the project budget?',
                                          'What is the cost reduction target?'][i % 3];
                            break;
                    }
                    
                    questions.push({
                        id: questionId,
                        question: questionText,
                        section: section,
                        answered: false
                    });
                }
            });
            
            return {
                status: 'success',
                questionsList: questions,
                simulated: true
            };
        }

        // Simulate processing document
        function simulateProcessDocument(documentContent) {
            // In a real implementation, this would use NLP to extract entities
            // For demo, we'll simulate the analysis with a simple text
            const analysis = `Document Analysis Results:
            
Key entities extracted from the document:
- Company Name: Acme Tech Solutions, Inc.
- Location: 123 Innovation Way, San Francisco, CA 94105
- Founded Date: March 15, 1998
- CEO: Dr. Sarah Johnson (appointed January 2020)
- Employee Count: 342 full-time employees
- Annual Revenue: $78.5 million (2024)
- Projects: NextGen Data Analytics Platform, Enterprise Security Enhancement Program
- Technology Stack: React.js, Angular, Vue.js, Node.js, Django, Spring Boot, PostgreSQL, MongoDB, Redis
- Cloud Infrastructure: AWS (primary), Azure (secondary)
- Security: OAuth 2.0, SAML, custom SSO solutions, ISO 27001 certified

Business Objectives:
- Increase market share by 15% in 18 months
- European market expansion by Q3 2025
- 8% cost reduction target
- Carbon neutrality by 2027

Document appears to be a company profile with relevant business information.`;
            
            return {
                status: 'success',
                documentAnalysis: analysis,
                simulated: true
            };
        }

        // Simulate generating answers
        function simulateGenerateAnswers(questions, documentAnalysis) {
            // Map of keywords to look for in the document for each question
            const questionKeywords = {
                'Company name?': ['company', 'inc', 'incorporated', 'ltd', 'limited'],
                'Company address?': ['address', 'headquarters', 'located', 'location', 'street'],
                'When was the company established?': ['established', 'founded', 'started', 'incorporated', 'est'],
                'Who is the current CEO?': ['ceo', 'chief executive', 'president', 'leader'],
                'How many employees does the company have?': ['employees', 'staff', 'team members', 'workforce', 'headcount'],
                'What are the primary business objectives?': ['objectives', 'goals', 'targets', 'aims', 'mission'],
                'Is expansion planned?': ['expansion', 'growth', 'new markets', 'expand'],
                'What cost reduction targets exist?': ['cost reduction', 'savings', 'reduce costs', 'efficiency'],
                'Any sustainability goals?': ['sustainability', 'green', 'carbon', 'environmental', 'eco'],
                'What is the primary technology stack?': ['technology', 'tech stack', 'programming', 'framework', 'languages'],
                'What cloud platforms are used?': ['cloud', 'aws', 'azure', 'gcp', 'google cloud'],
                'What security protocols are implemented?': ['security', 'protocols', 'encryption', 'authentication', 'sso'],
                'What databases are used?': ['database', 'db', 'sql', 'nosql', 'mongo'],
                'Who is the technical lead?': ['technical lead', 'tech lead', 'lead developer', 'cto', 'chief technology'],
                'How many full-time employees?': ['full-time', 'employees', 'staff', 'team members', 'workforce'],
                'What is the annual revenue?': ['revenue', 'annual revenue', 'earnings', 'income', 'financial'],
                'What is the project budget?': ['budget', 'funding', 'cost', 'allocated', 'financial'],
                'What is the cost reduction target?': ['cost reduction', 'savings target', 'efficiency goal']
            };
            
            // Document content to search
            const docContent = typeof documentAnalysis === 'string' 
                ? documentAnalysis.toLowerCase() 
                : (state.documentContent || '').toLowerCase();
            
            // Generate answers based on document content
            const generatedAnswers = [];
            
            if (!questions) return { status: 'success', generatedAnswers: [], count: 0, simulated: true };
            
            questions.forEach(question => {
                const keywords = questionKeywords[question.question] || [];
                let hasMatch = false;
                let confidenceScore = 0;
                let answer = '';
                
                // Check if any keywords are in the document
                for (const keyword of keywords) {
                    if (docContent.includes(keyword.toLowerCase())) {
                        hasMatch = true;
                        confidenceScore += 0.2; // Increase confidence for each keyword match
                        
                        // Extract a sentence containing the keyword
                        const sentences = docContent.split(/[.!?]+/);
                        for (const sentence of sentences) {
                            if (sentence.toLowerCase().includes(keyword.toLowerCase())) {
                                answer = sentence.trim();
                                break;
                            }
                        }
                    }
                }
                
                // Cap confidence at 0.95
                confidenceScore = Math.min(confidenceScore, 0.95);
                
                // Only include answers with sufficient confidence
                if (hasMatch && confidenceScore >= 0.4) {
                    // Clean up the answer
                    if (!answer) {
                        answer = "Information found but couldn't extract specific details.";
                    }
                    
                    // Format answer based on question
                    switch (question.question) {
                        case 'Company name?':
                            if (docContent.includes('acme tech solutions')) {
                                answer = 'Acme Tech Solutions, Inc.';
                                confidenceScore = 0.95;
                            }
                            break;
                        case 'Company address?':
                            if (docContent.includes('123 innovation way')) {
                                answer = '123 Innovation Way, San Francisco, CA 94105';
                                confidenceScore = 0.95;
                            }
                            break;
                        case 'When was the company established?':
                            if (docContent.includes('march 15, 1998')) {
                                answer = 'March 15, 1998';
                                confidenceScore = 0.95;
                            }
                            break;
                        case 'Who is the current CEO?':
                            if (docContent.includes('sarah johnson')) {
                                answer = 'Dr. Sarah Johnson (appointed January 2020)';
                                confidenceScore = 0.95;
                            }
                            break;
                        case 'How many employees does the company have?':
                            if (docContent.includes('342')) {
                                answer = '342 full-time employees';
                                confidenceScore = 0.95;
                            }
                            break;
                        case 'What is the annual revenue?':
                            if (docContent.includes('78.5 million')) {
                                answer = '$78.5 million (2024)';
                                confidenceScore = 0.95;
                            }
                            break;
                    }
                    
                    // Add to generated answers
                    generatedAnswers.push({
                        question_id: question.id,
                        answer: answer,
                        confidence: confidenceScore,
                        source_text: 'Extracted from document content'
                    });
                }
            });
            
            return {
                status: 'success',
                generatedAnswers: generatedAnswers,
                count: generatedAnswers.length,
                simulated: true
            };
        }

        // Simulate submitting answers
        function simulateSubmitAnswers(answers = []) {
            // If no answers provided, generate some random ones
            const submittedAnswers = answers.length > 0 ? answers : [
                {
                    question_id: 'org_100100',
                    answer: 'Acme Tech Solutions, Inc.',
                    confidence: 0.95
                },
                {
                    question_id: 'org_100101',
                    answer: '123 Innovation Way, San Francisco, CA 94105',
                    confidence: 0.95
                },
                {
                    question_id: 'org_100102',
                    answer: 'March 15, 1998',
                    confidence: 0.95
                }
            ];
            
            return {
                status: 'success',
                submittedAnswers: submittedAnswers,
                submitted: submittedAnswers.length,
                simulated: true
            };
        }

        // Simulate final report
        function simulateFinalReport() {
            const totalQuestions = parseInt(domElements.metricTotalQuestions.textContent) || 0;
            const answersSubmitted = parseInt(domElements.metricAnswersFound.textContent) || 0;
            const successRateText = domElements.metricSuccessRate.textContent || '0%';
            const successRate = parseInt(successRateText.replace('%', '')) || 0;
            
            return {
                status: 'success',
                summary: {
                    totalQuestions,
                    answersSubmitted,
                    successRate,
                    executionTime: calculateExecutionTime()
                },
                simulated: true
            };
        }

        // Calculate execution time
        function calculateExecutionTime() {
            if (!state.executionState.startTime) return '0s';
            
            const endTime = state.executionState.endTime || new Date();
            const durationMs = endTime - state.executionState.startTime;
            
            if (durationMs < 1000) {
                return `${durationMs}ms`;
            } else {
                return `${Math.round(durationMs / 1000)}s`;
            }
        }

        // Initialize the application
function init() {
    // Load default workflow
    loadWorkflowTemplate(defaultWorkflowTemplate);
    
    // Load state from localStorage
    loadFromLocalStorage();
    
    // Set up canvas drag functionality
    setupCanvasDrag();
    
    // Initialize extended features
    initExtendedFeatures();
    
    // Set up event listeners
    setupEventListeners();
    
    // Initial document content
    domElements.documentContent.value = state.documentContent;
    
    // Load execution history
    populateExecutionHistory();
    
    // Load templates
    populateTemplates();
    
    // Load settings
    populateSettings();
}

// Set up all event listeners
function setupEventListeners() {
    // Workflow control events
    domElements.workflowNameInput.addEventListener('input', updateWorkflowName);
    domElements.addNodeBtn.addEventListener('click', addNewNode);
    domElements.importWorkflowBtn.addEventListener('click', () => domElements.workflowFileInput.click());
    domElements.exportWorkflowBtn.addEventListener('click', exportWorkflow);
    domElements.executeWorkflowBtn.addEventListener('click', executeWorkflow);
    
    // Canvas control events
    domElements.zoomInBtn.addEventListener('click', () => zoomCanvas(1.1));
    domElements.zoomOutBtn.addEventListener('click', () => zoomCanvas(0.9));
    domElements.fitViewBtn.addEventListener('click', fitCanvasToView);
    domElements.centerViewBtn.addEventListener('click', centerCanvas);
    
    // Panel events
    domElements.panelCloseBtn.addEventListener('click', toggleRightPanel);
    domElements.resultsCloseBtn.addEventListener('click', closeResultsPanel);
    
    // Results tabs
    domElements.resultsTabs.forEach(tab => {
        tab.addEventListener('click', function() {
            const tabId = this.getAttribute('data-tab');
            
            // Remove active class from all tabs and contents
            domElements.resultsTabs.forEach(t => t.classList.remove('active'));
            domElements.tabContents.forEach(c => c.classList.remove('active'));
            
            // Add active class to selected tab and content
            this.classList.add('active');
            document.getElementById(tabId).classList.add('active');
        });
    });
    
    // Document content
    domElements.documentContent.addEventListener('input', function() {
        state.documentContent = this.value;
        if (state.appSettings.autoSave) {
            saveToLocalStorage();
        }
    });
    
    domElements.loadSampleTextBtn.addEventListener('click', loadSampleText);
    
    // API configuration
    domElements.apiUrlInput.addEventListener('input', function() {
        state.apiUrl = this.value;
        if (state.appSettings.autoSave) {
            saveToLocalStorage();
        }
    });
    
    domElements.apiKeyInput.addEventListener('input', function() {
        state.apiKey = this.value;
        if (state.appSettings.autoSave) {
            saveToLocalStorage();
        }
    });
    
    // Node editor events
    domElements.nodeEditorClose.addEventListener('click', closeNodeEditor);
    domElements.nodeEditorCancel.addEventListener('click', closeNodeEditor);
    domElements.nodeEditorSave.addEventListener('click', saveNodeEdits);
    
    domElements.nodeAgentSelect.addEventListener('change', updateNodeSkills);
    
    // File import events
    domElements.workflowFileInput.addEventListener('change', handleFileSelect);
    domElements.workflowDropArea.addEventListener('dragover', handleDragOver);
    domElements.workflowDropArea.addEventListener('dragleave', handleDragLeave);
    domElements.workflowDropArea.addEventListener('drop', handleDrop);
    domElements.workflowDropArea.addEventListener('click', () => domElements.workflowFileInput.click());
    
    // Sidebar navigation
    document.querySelectorAll('.sidebar-item').forEach((item, index) => {
        item.addEventListener('click', function() {
            const views = ['editor', 'executions', 'templates', 'settings'];
            
            // Only switch if clicking a different tab
            if (state.currentView !== views[index]) {
                switchView(views[index]);
            }
        });
    });
    
    // Handle document clicks to close filter menu
    document.addEventListener('click', function(e) {
        if (domElements.historyFilterMenu.classList.contains('open') &&
            !e.target.closest('#history-filter-btn') &&
            !e.target.closest('#history-filter-menu')) {
            domElements.historyFilterMenu.classList.remove('open');
        }
    });
    
    // History panel
    domElements.historySearch.addEventListener('input', function() {
        filterExecutionHistory();
    });
    
    domElements.historyFilterBtn.addEventListener('click', function() {
        domElements.historyFilterMenu.classList.toggle('open');
    });
    
    domElements.historyFilterOptions.forEach(option => {
        option.addEventListener('click', function() {
            const filter = this.getAttribute('data-filter');
            state.filterCriteria.history = filter;
            domElements.historyFilterMenu.classList.remove('open');
            filterExecutionHistory();
        });
    });
    
    // Templates panel
    domElements.templatesSearch.addEventListener('input', function() {
        filterTemplates();
    });
    
    domElements.createTemplateBtn.addEventListener('click', function() {
        createNewTemplate();
    });
    
    // Settings panel
    domElements.themeOptions.forEach(option => {
        option.addEventListener('click', function() {
            const theme = this.getAttribute('data-theme');
            setTheme(theme);
        });
    });
    
    domElements.colorSchemes.forEach(scheme => {
        scheme.addEventListener('click', function() {
            const color = this.getAttribute('data-color');
            setAccentColor(color);
        });
    });
    
    domElements.settingsApiUrl.addEventListener('input', function() {
        state.apiUrl = this.value;
        state.appSettings.apiUrl = this.value;
        saveSettings();
    });
    
    domElements.settingsApiKey.addEventListener('input', function() {
        state.apiKey = this.value;
        state.appSettings.apiKey = this.value;
        saveSettings();
    });
    
    domElements.testApiBtn.addEventListener('click', function() {
        testApiConnection();
    });
    
    domElements.autoSaveCheckbox.addEventListener('change', function() {
        state.appSettings.autoSave = this.checked;
        saveSettings();
    });
    
    domElements.clearResultsCheckbox.addEventListener('change', function() {
        state.appSettings.clearResultsBeforeExecution = this.checked;
        saveSettings();
    });
    
    domElements.showWelcomeCheckbox.addEventListener('change', function() {
        state.appSettings.showWelcomeOnStartup = this.checked;
        saveSettings();
    });
    
    domElements.historyLimit.addEventListener('change', function() {
        state.appSettings.historyLimit = parseInt(this.value);
        saveSettings();
    });
    
    domElements.exportAllDataBtn.addEventListener('click', function() {
        exportAllData();
    });
    
    domElements.importDataBtn.addEventListener('click', function() {
        domElements.importDataFile.click();
    });
    
    domElements.importDataFile.addEventListener('change', function() {
        if (this.files.length > 0) {
            importData(this.files[0]);
        }
    });
    
    domElements.clearAllDataBtn.addEventListener('click', function() {
        showConfirmResetModal();
    });
    
    // Template view modal
    domElements.templateViewClose.addEventListener('click', function() {
        closeTemplateViewModal();
    });
    
    domElements.templateViewCancel.addEventListener('click', function() {
        closeTemplateViewModal();
    });
    
    domElements.templateViewLoad.addEventListener('click', function() {
        loadSelectedTemplate();
    });
    
    // Confirm reset modal
    domElements.confirmResetClose.addEventListener('click', function() {
        closeConfirmResetModal();
    });
    
    domElements.confirmResetCancel.addEventListener('click', function() {
        closeConfirmResetModal();
    });
    
    domElements.confirmResetConfirm.addEventListener('click', function() {
        clearAllData();
        closeConfirmResetModal();
    });
    
    // Execution details modal
    domElements.executionDetailsClose.addEventListener('click', function() {
        closeExecutionDetailsModal();
    });
    
    domElements.executionDetailsCloseBtn.addEventListener('click', function() {
        closeExecutionDetailsModal();
    });
    
    domElements.executionDetailsReplay.addEventListener('click', function() {
        replayExecution();
    });
}

        // Initialize the application when DOM is loaded
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>