<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="theme-color" content="#000000">
  <title>BothAngles - Holographic Camera Experience</title>
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='0.9em' font-size='90'>ðŸŽ¬</text></svg>">
  
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      -webkit-user-select: none;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }
    
    :root {
      --primary-cyan: #00ffff;
      --primary-magenta: #ff00ff;
      --primary-red: #ff0066;
      --bg-dark: #0a0a0a;
      --bg-panel: rgba(10, 10, 10, 0.85);
      --text-primary: #ffffff;
      --text-secondary: #b0b0b0;
      --border-color: rgba(255, 255, 255, 0.1);
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Segoe UI', Roboto, sans-serif;
      background: var(--bg-dark);
      color: var(--text-primary);
      overflow: hidden;
      position: fixed;
      height: 100vh;
      width: 100vw;
      touch-action: none;
    }
    
    /* Loading Screen */
    .loading-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: var(--bg-dark);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      transition: opacity 0.5s ease-out;
    }
    
    .loading-screen.hide {
      opacity: 0;
      pointer-events: none;
    }
    
    .app-logo {
      font-size: 4em;
      font-weight: 900;
      background: linear-gradient(135deg, var(--primary-cyan), var(--primary-magenta));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 20px;
      letter-spacing: -2px;
    }
    
    .loading-spinner {
      width: 50px;
      height: 50px;
      border: 3px solid var(--border-color);
      border-top: 3px solid var(--primary-cyan);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    /* Three.js Canvas */
    #hologramCanvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      -webkit-transform: translateZ(0);
      transform: translateZ(0);
    }
    
    /* Video container */
    .video-container {
      position: absolute;
      top: -9999px;
      left: -9999px;
      width: 1px;
      height: 1px;
      overflow: hidden;
    }
    
    /* Hidden video elements */
    #frontCamera, #backCamera {
      width: 320px;
      height: 240px;
    }
    
    /* Particle background canvas */
    #particleCanvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
      opacity: 0.5;
    }
    
    /* UI Container */
    .ui-container {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 10;
      pointer-events: none;
    }
    
    .ui-container > * {
      pointer-events: auto;
    }
    
    /* Header */
    .header {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      background: linear-gradient(to bottom, rgba(0,0,0,0.8) 0%, transparent 100%);
      padding: env(safe-area-inset-top, 20px) 20px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .brand {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    
    .brand-logo {
      font-size: 28px;
      font-weight: 800;
      background: linear-gradient(135deg, var(--primary-cyan), var(--primary-magenta));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      letter-spacing: -1px;
    }
    
    .brand-tagline {
      font-size: 12px;
      color: var(--text-secondary);
      font-weight: 500;
      letter-spacing: 0.5px;
    }
    
    /* Status Badge */
    .status-badge {
      background: var(--bg-panel);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 1px solid var(--border-color);
      border-radius: 20px;
      padding: 8px 16px;
      font-size: 12px;
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .status-indicator {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--text-secondary);
    }
    
    .status-indicator.ready {
      background: #00ff88;
      box-shadow: 0 0 8px rgba(0, 255, 136, 0.5);
    }
    
    .status-indicator.recording {
      background: var(--primary-red);
      animation: pulse 1.5s infinite;
    }
    
    @keyframes pulse {
      0%, 100% { 
        opacity: 1;
        transform: scale(1);
      }
      50% { 
        opacity: 0.6;
        transform: scale(1.2);
      }
    }
    
    /* Main Controls */
    .main-controls {
      position: absolute;
      bottom: calc(30px + env(safe-area-inset-bottom, 0px));
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 15px;
      background: var(--bg-panel);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 1px solid var(--border-color);
      border-radius: 30px;
      padding: 15px;
    }
    
    .control-btn {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      border: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      overflow: hidden;
      -webkit-tap-highlight-color: transparent;
    }
    
    .control-btn:active {
      transform: scale(0.95);
    }
    
    .control-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .control-btn.primary {
      background: linear-gradient(135deg, var(--primary-red), #ff3366);
      color: white;
    }
    
    .control-btn.secondary {
      background: rgba(255, 255, 255, 0.1);
      color: white;
      border: 1px solid var(--border-color);
    }
    
    /* Instructions */
    .instructions {
      position: absolute;
      bottom: calc(100px + env(safe-area-inset-bottom, 0px));
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      opacity: 0;
      animation: fadeInUp 1s ease-out 0.5s forwards;
      pointer-events: none;
    }
    
    @keyframes fadeInUp {
      to {
        opacity: 1;
        transform: translateX(-50%) translateY(-10px);
      }
    }
    
    .instructions-text {
      font-size: 14px;
      color: var(--text-secondary);
      margin-bottom: 5px;
    }
    
    .instructions-hint {
      font-size: 12px;
      color: rgba(255, 255, 255, 0.4);
    }
    
    /* Error message */
    .error-message {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--bg-panel);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 1px solid var(--border-color);
      border-radius: 20px;
      padding: 30px;
      max-width: 90%;
      text-align: center;
      z-index: 1000;
      display: none;
    }
    
    .error-message.show {
      display: block;
    }
    
    .error-title {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 10px;
      color: var(--primary-red);
    }
    
    .error-text {
      font-size: 14px;
      color: var(--text-secondary);
      margin-bottom: 20px;
    }
    
    .error-btn {
      background: var(--primary-cyan);
      color: black;
      border: none;
      padding: 10px 20px;
      border-radius: 20px;
      font-weight: 600;
      cursor: pointer;
    }
    
    /* Mobile Responsive */
    @media (max-width: 768px) {
      .header {
        padding: env(safe-area-inset-top, 15px) 15px 15px;
      }
      
      .brand-logo {
        font-size: 24px;
      }
      
      .brand-tagline {
        display: none;
      }
      
      .main-controls {
        bottom: calc(20px + env(safe-area-inset-bottom, 0px));
        padding: 10px;
        gap: 10px;
      }
      
      .control-btn {
        width: 50px;
        height: 50px;
        font-size: 20px;
      }
    }
  </style>
</head>
<body>
  <div class="loading-screen" id="loadingScreen">
    <div class="app-logo">BothAngles</div>
    <div class="loading-spinner"></div>
  </div>
  
  <div class="video-container">
    <video id="frontCamera" autoplay muted playsinline webkit-playsinline></video>
    <video id="backCamera" autoplay muted playsinline webkit-playsinline></video>
  </div>
  
  <canvas id="particleCanvas"></canvas>
  <canvas id="hologramCanvas"></canvas>
  
  <div class="ui-container">
    <header class="header">
      <div class="brand">
        <div class="brand-logo">BothAngles</div>
        <div class="brand-tagline">Holographic Vision</div>
      </div>
      <div class="status-badge">
        <div class="status-indicator" id="statusIndicator"></div>
        <span id="statusText">Ready</span>
      </div>
    </header>
    
    <div class="main-controls">
      <button class="control-btn secondary" id="setupBtn" onclick="window.app.setupCameras()" title="Setup Cameras">
        ðŸ“¹
      </button>
      <button class="control-btn primary" id="recordBtn" onclick="window.app.toggleRecording()" disabled title="Start Recording">
        ðŸ”´
      </button>
    </div>
    
    <div class="instructions" id="instructions">
      <div class="instructions-text">Click the camera button to start</div>
      <div class="instructions-hint">Allow camera & mic access</div>
    </div>
    
    <div class="error-message" id="errorMessage">
      <div class="error-title">Camera Access Error</div>
      <div class="error-text" id="errorText">The operation was aborted.</div>
      <button class="error-btn" onclick="window.app.closeError()">Close</button>
    </div>
  </div>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  
  <script>
    // Global app object
    window.app = {
      frontStream: null,
      backStream: null,
      isRecording: false,
      recordedChunks: [],
      recorder: null,
      scene: null,
      camera: null,
      renderer: null,
      frontTexture: null,
      backTexture: null,
      hologramGroup: null,
      animationId: null,
      isIOS: /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream,
      isMobile: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)
    };
    
    // Initialize particle background
    function initParticleBackground() {
      const canvas = document.getElementById('particleCanvas');
      const ctx = canvas.getContext('2d');
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      
      const particles = [];
      const particleCount = app.isMobile ? 30 : 60;
      
      for (let i = 0; i < particleCount; i++) {
        particles.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          size: Math.random() * 2 + 1,
          speedX: (Math.random() - 0.5) * 0.3,
          speedY: (Math.random() - 0.5) * 0.3,
          color: Math.random() > 0.5 ? '#00ffff' : '#ff00ff'
        });
      }
      
      function animateParticles() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        particles.forEach(particle => {
          particle.x += particle.speedX;
          particle.y += particle.speedY;
          
          if (particle.x < 0 || particle.x > canvas.width) particle.speedX *= -1;
          if (particle.y < 0 || particle.y > canvas.height) particle.speedY *= -1;
          
          ctx.beginPath();
          ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
          ctx.fillStyle = particle.color;
          ctx.fill();
        });
        
        requestAnimationFrame(animateParticles);
      }
      
      animateParticles();
    }
    
    // Initialize Three.js
    function initThreeJS() {
      try {
        app.scene = new THREE.Scene();
        
        app.camera = new THREE.PerspectiveCamera(
          60,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        app.camera.position.z = 5;
        
        const canvas = document.getElementById('hologramCanvas');
        app.renderer = new THREE.WebGLRenderer({
          canvas: canvas,
          antialias: false,
          alpha: true,
          powerPreference: "high-performance",
          preserveDrawingBuffer: true
        });
        
        app.renderer.setSize(window.innerWidth, window.innerHeight);
        app.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        
        // Simple lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        app.scene.add(ambientLight);
        
        const pointLight = new THREE.PointLight(0x00ffff, 1);
        pointLight.position.set(5, 5, 5);
        app.scene.add(pointLight);
        
        app.hologramGroup = new THREE.Group();
        app.scene.add(app.hologramGroup);
        
        // Create placeholder hologram
        createPlaceholderHologram();
        
        animate();
        
      } catch (error) {
        console.error('Three.js initialization error:', error);
        updateStatus('3D init error');
      }
    }
    
    // Create placeholder hologram
    function createPlaceholderHologram() {
      const geometry = new THREE.BoxGeometry(2, 2, 2);
      const edges = new THREE.EdgesGeometry(geometry);
      const material = new THREE.LineBasicMaterial({ color: 0x00ffff });
      const wireframe = new THREE.LineSegments(edges, material);
      app.hologramGroup.add(wireframe);
      
      // Add inner cube
      const innerGeometry = new THREE.BoxGeometry(1, 1, 1);
      const innerEdges = new THREE.EdgesGeometry(innerGeometry);
      const innerMaterial = new THREE.LineBasicMaterial({ color: 0xff00ff });
      const innerWireframe = new THREE.LineSegments(innerEdges, innerMaterial);
      app.hologramGroup.add(innerWireframe);
    }
    
    // Create hologram from video
    function createVideoHologram() {
      // Clear existing
      while(app.hologramGroup.children.length > 0) {
        const child = app.hologramGroup.children[0];
        if (child.geometry) child.geometry.dispose();
        if (child.material) {
          if (child.material.map) child.material.map.dispose();
          child.material.dispose();
        }
        app.hologramGroup.remove(child);
      }
      
      if (!app.frontTexture || !app.backTexture) return;
      
      // Simple plane geometry
      const geometry = new THREE.PlaneGeometry(3, 2);
      
      // Front material
      const frontMaterial = new THREE.MeshBasicMaterial({
        map: app.frontTexture,
        transparent: true,
        opacity: 0.9,
        side: THREE.DoubleSide
      });
      
      // Back material
      const backMaterial = new THREE.MeshBasicMaterial({
        map: app.backTexture,
        transparent: true,
        opacity: 0.9,
        side: THREE.DoubleSide
      });
      
      // Create meshes
      const frontMesh = new THREE.Mesh(geometry, frontMaterial);
      const backMesh = new THREE.Mesh(geometry.clone(), backMaterial);
      
      frontMesh.position.z = 0.5;
      backMesh.position.z = -0.5;
      
      // Add edge glow
      const edgeGeometry = new THREE.EdgesGeometry(geometry);
      const edgeMaterial = new THREE.LineBasicMaterial({ 
        color: 0x00ffff,
        transparent: true,
        opacity: 0.5
      });
      const edges = new THREE.LineSegments(edgeGeometry, edgeMaterial);
      frontMesh.add(edges);
      
      app.hologramGroup.add(frontMesh);
      app.hologramGroup.add(backMesh);
      
      // Add some glow planes
      for (let i = 0; i < 2; i++) {
        const glowMaterial = new THREE.MeshBasicMaterial({
          map: i === 0 ? app.frontTexture : app.backTexture,
          transparent: true,
          opacity: 0.1,
          blending: THREE.AdditiveBlending,
          side: THREE.DoubleSide
        });
        const glowMesh = new THREE.Mesh(geometry.clone(), glowMaterial);
        glowMesh.position.z = i === 0 ? 0.7 : -0.7;
        glowMesh.scale.set(1.1, 1.1, 1);
        app.hologramGroup.add(glowMesh);
      }
    }
    
    // Animation loop
    function animate() {
      app.animationId = requestAnimationFrame(animate);
      
      if (app.hologramGroup) {
        app.hologramGroup.rotation.y += 0.01;
        app.hologramGroup.rotation.x = Math.sin(Date.now() * 0.001) * 0.1;
      }
      
      // Update video textures
      if (app.frontTexture) app.frontTexture.needsUpdate = true;
      if (app.backTexture) app.backTexture.needsUpdate = true;
      
      app.renderer.render(app.scene, app.camera);
    }
    
    // Update status
    function updateStatus(text, state) {
      document.getElementById('statusText').textContent = text;
      const indicator = document.getElementById('statusIndicator');
      indicator.className = 'status-indicator';
      if (state) indicator.classList.add(state);
    }
    
    // Show error
    function showError(message) {
      document.getElementById('errorText').textContent = message;
      document.getElementById('errorMessage').classList.add('show');
    }
    
    // Close error
    window.app.closeError = function() {
      document.getElementById('errorMessage').classList.remove('show');
    };
    
    // Setup cameras with better iOS handling
    window.app.setupCameras = async function() {
      try {
        updateStatus('Requesting access...');
        document.getElementById('instructions').style.display = 'none';
        
        // Clean up existing streams
        if (app.frontStream) {
          app.frontStream.getTracks().forEach(track => track.stop());
          app.frontStream = null;
        }
        if (app.backStream) {
          app.backStream.getTracks().forEach(track => track.stop());
          app.backStream = null;
        }
        
        // Simple constraints for iOS
        const constraints = {
          video: {
            width: { ideal: 320 },
            height: { ideal: 240 }
          },
          audio: true
        };
        
        // Request permissions
        try {
          app.frontStream = await navigator.mediaDevices.getUserMedia(constraints);
        } catch (err) {
          console.error('Camera permission error:', err);
          
          // Try video only if audio fails
          if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
            showError('Please allow camera and microphone access in Safari settings');
            updateStatus('Permission denied');
            return;
          }
          
          // Try without audio
          try {
            const videoOnlyConstraints = { video: constraints.video };
            app.frontStream = await navigator.mediaDevices.getUserMedia(videoOnlyConstraints);
          } catch (videoErr) {
            showError('Camera access failed. Please check Safari settings.');
            updateStatus('Camera error');
            return;
          }
        }
        
        // Clone for back camera (simplified for iOS)
        app.backStream = app.frontStream.clone();
        
        // Setup video elements
        const frontVideo = document.getElementById('frontCamera');
        const backVideo = document.getElementById('backCamera');
        
        frontVideo.srcObject = app.frontStream;
        backVideo.srcObject = app.backStream;
        
        // Wait for videos to load
        await new Promise((resolve) => {
          let loaded = 0;
          const checkLoaded = () => {
            loaded++;
            if (loaded === 2) resolve();
          };
          
          frontVideo.onloadeddata = () => {
            frontVideo.play().then(checkLoaded).catch(console.error);
          };
          
          backVideo.onloadeddata = () => {
            backVideo.play().then(checkLoaded).catch(console.error);
          };
        });
        
        // Create textures
        app.frontTexture = new THREE.VideoTexture(frontVideo);
        app.frontTexture.minFilter = THREE.LinearFilter;
        app.frontTexture.magFilter = THREE.LinearFilter;
        
        app.backTexture = new THREE.VideoTexture(backVideo);
        app.backTexture.minFilter = THREE.LinearFilter;
        app.backTexture.magFilter = THREE.LinearFilter;
        
        // Create hologram
        createVideoHologram();
        
        document.getElementById('setupBtn').style.display = 'none';
        document.getElementById('recordBtn').disabled = false;
        updateStatus('Ready to record', 'ready');
        
      } catch (error) {
        console.error('Setup error:', error);
        showError(`Setup failed: ${error.message}`);
        updateStatus('Setup error');
        document.getElementById('instructions').style.display = 'block';
      }
    };
    
    // Toggle recording
    window.app.toggleRecording = function() {
      if (!app.isRecording) {
        startRecording();
      } else {
        stopRecording();
      }
    };
    
    // Start recording
    function startRecording() {
      try {
        app.recordedChunks = [];
        
        // Get canvas stream
        const canvas = document.getElementById('hologramCanvas');
        const canvasStream = canvas.captureStream(15); // Lower framerate for iOS
        
        // Get audio if available
        const audioTracks = app.frontStream ? app.frontStream.getAudioTracks() : [];
        
        // Combine streams
        const tracks = [...canvasStream.getVideoTracks()];
        if (audioTracks.length > 0) {
          tracks.push(...audioTracks);
        }
        const combinedStream = new MediaStream(tracks);
        
        // Setup recorder with iOS-compatible settings
        const mimeType = MediaRecorder.isTypeSupported('video/mp4') ? 'video/mp4' : 'video/webm';
        
        app.recorder = new MediaRecorder(combinedStream, {
          mimeType: mimeType,
          videoBitsPerSecond: 1000000 // Lower bitrate for iOS
        });
        
        app.recorder.ondataavailable = (event) => {
          if (event.data && event.data.size > 0) {
            app.recordedChunks.push(event.data);
          }
        };
        
        app.recorder.onstop = () => {
          const blob = new Blob(app.recordedChunks, { type: mimeType });
          const url = URL.createObjectURL(blob);
          
          // Download
          const a = document.createElement('a');
          a.href = url;
          a.download = `BothAngles-Hologram.${mimeType.includes('mp4') ? 'mp4' : 'webm'}`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          
          setTimeout(() => URL.revokeObjectURL(url), 100);
          updateStatus('Ready to record', 'ready');
        };
        
        app.recorder.start(100);
        app.isRecording = true;
        document.getElementById('recordBtn').innerHTML = 'â¹ï¸';
        updateStatus('Recording...', 'recording');
        
      } catch (error) {
        console.error('Recording error:', error);
        showError(`Recording failed: ${error.message}`);
        updateStatus('Recording error');
      }
    }
    
    // Stop recording
    function stopRecording() {
      if (app.recorder && app.isRecording) {
        app.recorder.stop();
        app.isRecording = false;
        document.getElementById('recordBtn').innerHTML = 'ðŸ”´';
        updateStatus('Processing...');
      }
    }
    
    // Initialize app
    window.addEventListener('load', () => {
      initParticleBackground();
      initThreeJS();
      
      setTimeout(() => {
        document.getElementById('loadingScreen').classList.add('hide');
        updateStatus('Ready');
      }, 1000);
    });
    
    // Handle resize
    window.addEventListener('resize', () => {
      if (app.camera && app.renderer) {
        app.camera.aspect = window.innerWidth / window.innerHeight;
        app.camera.updateProjectionMatrix();
        app.renderer.setSize(window.innerWidth, window.innerHeight);
      }
      
      const particleCanvas = document.getElementById('particleCanvas');
      particleCanvas.width = window.innerWidth;
      particleCanvas.height = window.innerHeight;
    });
    
    // Cleanup
    window.addEventListener('beforeunload', () => {
      if (app.frontStream) app.frontStream.getTracks().forEach(track => track.stop());
      if (app.backStream) app.backStream.getTracks().forEach(track => track.stop());
      if (app.animationId) cancelAnimationFrame(app.animationId);
    });
    
    // iOS specific fixes
    if (app.isIOS) {
      // Prevent zoom
      document.addEventListener('gesturestart', (e) => e.preventDefault());
      
      // Handle visibility change
      document.addEventListener('visibilitychange', () => {
        if (document.hidden && app.isRecording) {
          stopRecording();
        }
      });
    }
  </script>
</body>
</html>