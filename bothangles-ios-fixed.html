<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="theme-color" content="#000000">
  <title>BothAngles - Holographic Camera Experience</title>
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='0.9em' font-size='90'>🎬</text></svg>">
  
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      -webkit-user-select: none;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }
    
    :root {
      --primary-cyan: #00ffff;
      --primary-magenta: #ff00ff;
      --primary-red: #ff0066;
      --bg-dark: #0a0a0a;
      --bg-panel: rgba(10, 10, 10, 0.85);
      --text-primary: #ffffff;
      --text-secondary: #b0b0b0;
      --border-color: rgba(255, 255, 255, 0.1);
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Segoe UI', Roboto, sans-serif;
      background: var(--bg-dark);
      color: var(--text-primary);
      overflow: hidden;
      position: fixed;
      height: 100vh;
      width: 100vw;
      touch-action: none;
    }
    
    /* Loading Screen */
    .loading-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: var(--bg-dark);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      transition: opacity 0.5s ease-out;
    }
    
    .loading-screen.hide {
      opacity: 0;
      pointer-events: none;
    }
    
    .app-logo {
      font-size: 4em;
      font-weight: 900;
      background: linear-gradient(135deg, var(--primary-cyan), var(--primary-magenta));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 20px;
      letter-spacing: -2px;
    }
    
    .loading-spinner {
      width: 50px;
      height: 50px;
      border: 3px solid var(--border-color);
      border-top: 3px solid var(--primary-cyan);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    /* Three.js Canvas */
    #hologramCanvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      -webkit-transform: translateZ(0);
      transform: translateZ(0);
    }
    
    /* Hidden video elements */
    #frontCamera, #backCamera {
      position: absolute;
      width: 640px;
      height: 480px;
      visibility: hidden;
      pointer-events: none;
    }
    
    /* Particle background canvas */
    #particleCanvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
      opacity: 0.5;
    }
    
    /* UI Container */
    .ui-container {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 10;
      pointer-events: none;
    }
    
    .ui-container > * {
      pointer-events: auto;
    }
    
    /* Header */
    .header {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      background: linear-gradient(to bottom, rgba(0,0,0,0.8) 0%, transparent 100%);
      padding: env(safe-area-inset-top, 20px) 20px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .brand {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    
    .brand-logo {
      font-size: 28px;
      font-weight: 800;
      background: linear-gradient(135deg, var(--primary-cyan), var(--primary-magenta));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      letter-spacing: -1px;
    }
    
    .brand-tagline {
      font-size: 12px;
      color: var(--text-secondary);
      font-weight: 500;
      letter-spacing: 0.5px;
    }
    
    /* Status Badge */
    .status-badge {
      background: var(--bg-panel);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 1px solid var(--border-color);
      border-radius: 20px;
      padding: 8px 16px;
      font-size: 12px;
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .status-indicator {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--text-secondary);
    }
    
    .status-indicator.ready {
      background: #00ff88;
      box-shadow: 0 0 8px rgba(0, 255, 136, 0.5);
    }
    
    .status-indicator.recording {
      background: var(--primary-red);
      animation: pulse 1.5s infinite;
    }
    
    @keyframes pulse {
      0%, 100% { 
        opacity: 1;
        transform: scale(1);
      }
      50% { 
        opacity: 0.6;
        transform: scale(1.2);
      }
    }
    
    /* Main Controls */
    .main-controls {
      position: absolute;
      bottom: calc(30px + env(safe-area-inset-bottom, 0px));
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 15px;
      background: var(--bg-panel);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 1px solid var(--border-color);
      border-radius: 30px;
      padding: 15px;
    }
    
    .control-btn {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      border: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      overflow: hidden;
      -webkit-tap-highlight-color: transparent;
    }
    
    .control-btn::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      border-radius: 50%;
      transform: translate(-50%, -50%);
      transition: width 0.3s, height 0.3s;
    }
    
    .control-btn:active {
      transform: scale(0.95);
    }
    
    .control-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .control-btn.primary {
      background: linear-gradient(135deg, var(--primary-red), #ff3366);
      color: white;
    }
    
    .control-btn.primary::before {
      background: rgba(255, 255, 255, 0.2);
    }
    
    .control-btn.secondary {
      background: rgba(255, 255, 255, 0.1);
      color: white;
      border: 1px solid var(--border-color);
    }
    
    .control-btn.secondary::before {
      background: rgba(255, 255, 255, 0.1);
    }
    
    /* Instructions */
    .instructions {
      position: absolute;
      bottom: calc(100px + env(safe-area-inset-bottom, 0px));
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      opacity: 0;
      animation: fadeInUp 1s ease-out 0.5s forwards;
      pointer-events: none;
    }
    
    @keyframes fadeInUp {
      to {
        opacity: 1;
        transform: translateX(-50%) translateY(-10px);
      }
    }
    
    .instructions-text {
      font-size: 14px;
      color: var(--text-secondary);
      margin-bottom: 5px;
    }
    
    .instructions-hint {
      font-size: 12px;
      color: rgba(255, 255, 255, 0.4);
    }
    
    /* Mobile Responsive */
    @media (max-width: 768px) {
      .header {
        padding: env(safe-area-inset-top, 15px) 15px 15px;
      }
      
      .brand-logo {
        font-size: 24px;
      }
      
      .brand-tagline {
        display: none;
      }
      
      .main-controls {
        bottom: calc(20px + env(safe-area-inset-bottom, 0px));
        padding: 10px;
        gap: 10px;
      }
      
      .control-btn {
        width: 50px;
        height: 50px;
        font-size: 20px;
      }
    }
    
    /* iOS-specific fixes */
    @supports (-webkit-touch-callout: none) {
      body {
        -webkit-overflow-scrolling: touch;
      }
      
      #hologramCanvas {
        -webkit-transform: translate3d(0, 0, 0);
        -webkit-backface-visibility: hidden;
        -webkit-perspective: 1000;
      }
      
      video {
        -webkit-transform: translateZ(0);
      }
    }
  </style>
</head>
<body>
  <div class="loading-screen" id="loadingScreen">
    <div class="app-logo">BothAngles</div>
    <div class="loading-spinner"></div>
  </div>
  
  <video id="frontCamera" autoplay muted playsinline webkit-playsinline></video>
  <video id="backCamera" autoplay muted playsinline webkit-playsinline></video>
  
  <canvas id="particleCanvas"></canvas>
  <canvas id="hologramCanvas"></canvas>
  
  <div class="ui-container">
    <header class="header">
      <div class="brand">
        <div class="brand-logo">BothAngles</div>
        <div class="brand-tagline">Holographic Vision</div>
      </div>
      <div class="status-badge">
        <div class="status-indicator" id="statusIndicator"></div>
        <span id="statusText">Initializing...</span>
      </div>
    </header>
    
    <div class="main-controls">
      <button class="control-btn secondary" id="setupBtn" onclick="setupCameras()" title="Setup Cameras">
        📹
      </button>
      <button class="control-btn primary" id="recordBtn" onclick="toggleRecording()" disabled title="Start Recording">
        🔴
      </button>
    </div>
    
    <div class="instructions" id="instructions">
      <div class="instructions-text">Click the camera button to start</div>
      <div class="instructions-hint">Allow camera & mic access</div>
    </div>
  </div>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  
  <script>
    let frontStream = null;
    let backStream = null;
    let isRecording = false;
    let recordedChunks = [];
    
    // Three.js variables
    let scene, camera, renderer;
    let frontTexture, backTexture;
    let hologramGroup;
    let animationId = null;
    
    // Check if iOS
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    
    // Initialize particle background
    function initParticleBackground() {
      const canvas = document.getElementById('particleCanvas');
      const ctx = canvas.getContext('2d');
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      
      const particles = [];
      const particleCount = isMobile ? 50 : 100;
      
      for (let i = 0; i < particleCount; i++) {
        particles.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          size: Math.random() * 2 + 1,
          speedX: (Math.random() - 0.5) * 0.5,
          speedY: (Math.random() - 0.5) * 0.5,
          color: Math.random() > 0.5 ? '#00ffff' : '#ff00ff'
        });
      }
      
      function animateParticles() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        particles.forEach(particle => {
          particle.x += particle.speedX;
          particle.y += particle.speedY;
          
          if (particle.x < 0 || particle.x > canvas.width) particle.speedX *= -1;
          if (particle.y < 0 || particle.y > canvas.height) particle.speedY *= -1;
          
          ctx.beginPath();
          ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
          ctx.fillStyle = particle.color;
          ctx.fill();
        });
        
        requestAnimationFrame(animateParticles);
      }
      
      animateParticles();
    }
    
    // Initialize Three.js
    function initThreeJS() {
      try {
        scene = new THREE.Scene();
        
        camera = new THREE.PerspectiveCamera(
          60,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.z = 5;
        
        const canvas = document.getElementById('hologramCanvas');
        renderer = new THREE.WebGLRenderer({
          canvas: canvas,
          antialias: !isIOS,
          alpha: true,
          powerPreference: "high-performance"
        });
        
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        
        // Simple lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        
        const pointLight = new THREE.PointLight(0x00ffff, 1);
        pointLight.position.set(5, 5, 5);
        scene.add(pointLight);
        
        hologramGroup = new THREE.Group();
        scene.add(hologramGroup);
        
        // Create placeholder geometry
        createPlaceholderHologram();
        
        animate();
        
      } catch (error) {
        console.error('Three.js initialization error:', error);
        updateStatus('3D init error', '');
      }
    }
    
    // Create placeholder hologram before camera is ready
    function createPlaceholderHologram() {
      const geometry = new THREE.BoxGeometry(2, 2, 2);
      const material = new THREE.MeshBasicMaterial({
        color: 0x00ffff,
        wireframe: true,
        transparent: true,
        opacity: 0.5
      });
      const cube = new THREE.Mesh(geometry, material);
      hologramGroup.add(cube);
    }
    
    // Create hologram from video streams
    function createHologram() {
      // Clear existing objects
      while(hologramGroup.children.length > 0) {
        const child = hologramGroup.children[0];
        if (child.geometry) child.geometry.dispose();
        if (child.material) {
          if (child.material.map) child.material.map.dispose();
          child.material.dispose();
        }
        hologramGroup.remove(child);
      }
      
      if (!frontTexture || !backTexture) return;
      
      // Create simple plane geometry
      const geometry = new THREE.PlaneGeometry(3, 2, 16, 16);
      
      // Create materials with video textures
      const frontMaterial = new THREE.MeshBasicMaterial({
        map: frontTexture,
        transparent: true,
        opacity: 0.8,
        side: THREE.DoubleSide
      });
      
      const backMaterial = new THREE.MeshBasicMaterial({
        map: backTexture,
        transparent: true,
        opacity: 0.8,
        side: THREE.DoubleSide
      });
      
      // Create meshes
      const frontMesh = new THREE.Mesh(geometry, frontMaterial);
      const backMesh = new THREE.Mesh(geometry.clone(), backMaterial);
      
      // Position them
      frontMesh.position.z = 0.5;
      backMesh.position.z = -0.5;
      
      // Add glow effect border
      const edgeGeometry = new THREE.EdgesGeometry(geometry);
      const edgeMaterial = new THREE.LineBasicMaterial({ 
        color: 0x00ffff,
        linewidth: 2
      });
      const edges = new THREE.LineSegments(edgeGeometry, edgeMaterial);
      frontMesh.add(edges);
      
      hologramGroup.add(frontMesh);
      hologramGroup.add(backMesh);
    }
    
    // Animation loop
    function animate() {
      animationId = requestAnimationFrame(animate);
      
      if (hologramGroup) {
        hologramGroup.rotation.y += 0.01;
        hologramGroup.rotation.x = Math.sin(Date.now() * 0.001) * 0.1;
      }
      
      // Update video textures
      if (frontTexture && frontTexture.image && frontTexture.image.readyState >= 2) {
        frontTexture.needsUpdate = true;
      }
      if (backTexture && backTexture.image && backTexture.image.readyState >= 2) {
        backTexture.needsUpdate = true;
      }
      
      renderer.render(scene, camera);
    }
    
    // Update status
    function updateStatus(text, state) {
      document.getElementById('statusText').textContent = text;
      const indicator = document.getElementById('statusIndicator');
      indicator.className = 'status-indicator';
      if (state) indicator.classList.add(state);
    }
    
    // Setup cameras
    async function setupCameras() {
      try {
        updateStatus('Requesting access...', '');
        document.getElementById('instructions').style.display = 'none';
        
        // Request camera permissions
        const constraints = {
          video: {
            width: { ideal: 640 },
            height: { ideal: 480 },
            facingMode: 'user'
          },
          audio: true
        };
        
        frontStream = await navigator.mediaDevices.getUserMedia(constraints);
        
        // Try to get back camera
        try {
          const devices = await navigator.mediaDevices.enumerateDevices();
          const videoDevices = devices.filter(d => d.kind === 'videoinput');
          
          if (videoDevices.length > 1) {
            const backConstraints = {
              video: {
                width: { ideal: 640 },
                height: { ideal: 480 },
                facingMode: { exact: 'environment' }
              },
              audio: false
            };
            backStream = await navigator.mediaDevices.getUserMedia(backConstraints);
          } else {
            backStream = frontStream.clone();
          }
        } catch (e) {
          console.log('Using front camera for both views');
          backStream = frontStream.clone();
        }
        
        // Setup video elements
        const frontVideo = document.getElementById('frontCamera');
        const backVideo = document.getElementById('backCamera');
        
        frontVideo.srcObject = new MediaStream(frontStream.getVideoTracks());
        backVideo.srcObject = new MediaStream(backStream.getVideoTracks());
        
        // Wait for videos to be ready
        await Promise.all([
          new Promise(resolve => {
            frontVideo.onloadedmetadata = () => {
              frontVideo.play().then(resolve);
            };
          }),
          new Promise(resolve => {
            backVideo.onloadedmetadata = () => {
              backVideo.play().then(resolve);
            };
          })
        ]);
        
        // Create video textures
        frontTexture = new THREE.VideoTexture(frontVideo);
        frontTexture.minFilter = THREE.LinearFilter;
        frontTexture.magFilter = THREE.LinearFilter;
        frontTexture.format = THREE.RGBFormat;
        
        backTexture = new THREE.VideoTexture(backVideo);
        backTexture.minFilter = THREE.LinearFilter;
        backTexture.magFilter = THREE.LinearFilter;
        backTexture.format = THREE.RGBFormat;
        
        // Create hologram with video
        createHologram();
        
        document.getElementById('setupBtn').style.display = 'none';
        document.getElementById('recordBtn').disabled = false;
        updateStatus('Ready to record', 'ready');
        
      } catch (error) {
        console.error('Camera setup error:', error);
        updateStatus('Camera error', '');
        document.getElementById('instructions').style.display = 'block';
        alert('Camera access error: ' + error.message);
      }
    }
    
    // Toggle recording
    function toggleRecording() {
      if (!isRecording) {
        startRecording();
      } else {
        stopRecording();
      }
    }
    
    // Start recording
    async function startRecording() {
      try {
        recordedChunks = [];
        
        // Get canvas stream
        const canvas = document.getElementById('hologramCanvas');
        const canvasStream = canvas.captureStream(30);
        
        // Get audio from front camera
        const audioTracks = frontStream.getAudioTracks();
        
        // Combine streams
        const combinedStream = new MediaStream([
          ...canvasStream.getVideoTracks(),
          ...audioTracks
        ]);
        
        // Setup recorder
        const options = {
          mimeType: MediaRecorder.isTypeSupported('video/webm;codecs=vp9') 
            ? 'video/webm;codecs=vp9' 
            : 'video/webm'
        };
        
        const recorder = new MediaRecorder(combinedStream, options);
        
        recorder.ondataavailable = (event) => {
          if (event.data.size > 0) {
            recordedChunks.push(event.data);
          }
        };
        
        recorder.onstop = () => {
          const blob = new Blob(recordedChunks, { type: 'video/webm' });
          const url = URL.createObjectURL(blob);
          
          // Create download link
          const a = document.createElement('a');
          a.href = url;
          a.download = 'BothAngles-Hologram.webm';
          a.click();
          
          URL.revokeObjectURL(url);
          updateStatus('Ready to record', 'ready');
        };
        
        recorder.start();
        window.recorder = recorder;
        
        isRecording = true;
        document.getElementById('recordBtn').innerHTML = '⏹️';
        updateStatus('Recording...', 'recording');
        
      } catch (error) {
        console.error('Recording error:', error);
        alert('Recording error: ' + error.message);
      }
    }
    
    // Stop recording
    function stopRecording() {
      if (window.recorder && isRecording) {
        window.recorder.stop();
        isRecording = false;
        document.getElementById('recordBtn').innerHTML = '🔴';
        updateStatus('Processing...', '');
      }
    }
    
    // Initialize
    window.addEventListener('load', () => {
      initParticleBackground();
      initThreeJS();
      
      setTimeout(() => {
        document.getElementById('loadingScreen').classList.add('hide');
        updateStatus('Ready', 'ready');
      }, 1000);
    });
    
    // Handle resize
    window.addEventListener('resize', () => {
      if (camera && renderer) {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
      
      // Resize particle canvas
      const particleCanvas = document.getElementById('particleCanvas');
      particleCanvas.width = window.innerWidth;
      particleCanvas.height = window.innerHeight;
    });
    
    // Cleanup
    window.addEventListener('beforeunload', () => {
      if (frontStream) frontStream.getTracks().forEach(track => track.stop());
      if (backStream) backStream.getTracks().forEach(track => track.stop());
      if (animationId) cancelAnimationFrame(animationId);
    });
  </script>
</body>
</html>