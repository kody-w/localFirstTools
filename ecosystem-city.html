<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ecosystem City - Urban Evolution Simulation</title>
    <meta name="description" content="Living city ecosystem with evolving creatures, neural network brains, procedural buildings, and genetic algorithms.">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #000; font-family: 'Segoe UI', system-ui, sans-serif; color: white; }

        #loading {
            position: fixed; inset: 0;
            background: linear-gradient(135deg, #0a1628, #1a0a28);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 1000; transition: opacity 0.8s ease;
        }
        #loading.hidden { opacity: 0; pointer-events: none; }
        #loading h1 { font-size: 3em; background: linear-gradient(90deg, #00ff88, #00aaff, #ff00aa); -webkit-background-clip: text; -webkit-text-fill-color: transparent; margin-bottom: 10px; }
        #loading p { color: rgba(255,255,255,0.6); margin-bottom: 30px; }
        .loading-bar { width: 300px; height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; overflow: hidden; }
        .loading-fill { height: 100%; background: linear-gradient(90deg, #00ff88, #00aaff); width: 0%; animation: load 2s ease-out forwards; }
        @keyframes load { to { width: 100%; } }

        #hud { position: absolute; top: 15px; left: 15px; background: rgba(0,0,0,0.85); padding: 15px 20px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.1); backdrop-filter: blur(10px); min-width: 200px; }
        #hud h2 { font-size: 1.1em; color: #00ff88; margin-bottom: 12px; }
        .stat-group { margin-bottom: 10px; }
        .stat-group-title { font-size: 0.7em; color: rgba(255,255,255,0.4); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 4px; }
        .stat { display: flex; justify-content: space-between; padding: 2px 0; font-size: 0.85em; }
        .stat-value { font-weight: bold; }
        .stat-value.plants { color: #00ff88; }
        .stat-value.herbivores { color: #00aaff; }
        .stat-value.predators { color: #ff4466; }

        #time-panel { position: absolute; top: 15px; right: 15px; background: rgba(0,0,0,0.85); padding: 12px 20px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.1); text-align: center; }
        #time-panel .years { font-size: 1.8em; font-weight: bold; color: #ffaa00; }
        #time-panel .label { font-size: 0.75em; color: rgba(255,255,255,0.5); }

        #graph-panel { position: absolute; bottom: 15px; left: 15px; background: rgba(0,0,0,0.85); padding: 12px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.1); }
        #graph-panel h3 { font-size: 0.8em; color: #00aaff; margin-bottom: 8px; }

        #controls { position: absolute; bottom: 15px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.85); padding: 10px 18px; border-radius: 25px; border: 1px solid rgba(255,255,255,0.1); display: flex; gap: 6px; align-items: center; }
        button { background: linear-gradient(135deg, #333, #222); color: white; border: 1px solid rgba(255,255,255,0.1); padding: 7px 14px; cursor: pointer; border-radius: 12px; font-size: 11px; transition: all 0.2s; }
        button:hover { background: linear-gradient(135deg, #444, #333); }
        button.active { background: linear-gradient(135deg, #00aa66, #008855); }
        button.danger { background: linear-gradient(135deg, #aa3344, #882233); }
        .speed-display { background: rgba(255,255,255,0.1); padding: 7px 12px; border-radius: 12px; font-size: 11px; }

        #legend { position: absolute; top: 100px; right: 15px; background: rgba(0,0,0,0.85); padding: 10px 12px; border-radius: 10px; font-size: 0.8em; }
        .legend-item { display: flex; align-items: center; gap: 6px; padding: 3px 0; }
        .legend-dot { width: 10px; height: 10px; border-radius: 50%; }

        #creature-panel { position: absolute; top: 15px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.9); padding: 12px 20px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.15); display: none; min-width: 280px; }
        #creature-panel.visible { display: block; }
        #creature-panel h3 { margin-bottom: 8px; font-size: 1em; }
        .brain-viz { display: flex; gap: 3px; margin-top: 8px; }
        .neuron { width: 6px; height: 6px; border-radius: 50%; background: #333; }
        .neuron.active { background: #00ff88; }

        #instructions { position: absolute; bottom: 65px; left: 15px; font-size: 0.7em; color: rgba(255,255,255,0.4); }
        kbd { background: rgba(255,255,255,0.1); padding: 1px 4px; border-radius: 2px; }
    </style>
</head>
<body>
    <div id="loading">
        <h1>ECOSYSTEM CITY</h1>
        <p>Building city and spawning life...</p>
        <div class="loading-bar"><div class="loading-fill"></div></div>
    </div>

    <div id="hud">
        <h2>üèôÔ∏è Ecosystem City</h2>
        <div class="stat-group">
            <div class="stat-group-title">Population</div>
            <div class="stat"><span>üåø Plants</span><span class="stat-value plants" id="stat-plants">0</span></div>
            <div class="stat"><span>üê∞ Herbivores</span><span class="stat-value herbivores" id="stat-herbivores">0</span></div>
            <div class="stat"><span>ü¶ä Predators</span><span class="stat-value predators" id="stat-predators">0</span></div>
        </div>
        <div class="stat-group">
            <div class="stat-group-title">Evolution</div>
            <div class="stat"><span>Generation</span><span class="stat-value" id="stat-generation">1</span></div>
            <div class="stat"><span>Avg Fitness</span><span class="stat-value" id="stat-fitness">0</span></div>
        </div>
        <div class="stat-group">
            <div class="stat-group-title">City</div>
            <div class="stat"><span>Buildings</span><span class="stat-value" id="stat-buildings">0</span></div>
            <div class="stat"><span>FPS</span><span class="stat-value" id="stat-fps">60</span></div>
        </div>
    </div>

    <div id="time-panel">
        <div class="years" id="years-display">0</div>
        <div class="label">Years of Evolution</div>
    </div>

    <div id="legend">
        <div class="legend-item"><div class="legend-dot" style="background:#00ff88"></div> Plants (Parks)</div>
        <div class="legend-item"><div class="legend-dot" style="background:#00aaff"></div> Herbivores</div>
        <div class="legend-item"><div class="legend-dot" style="background:#ff4466"></div> Predators</div>
        <div class="legend-item"><div class="legend-dot" style="background:#888"></div> Buildings</div>
    </div>

    <div id="creature-panel">
        <h3><span id="creature-icon">üê∞</span> <span id="creature-name">Creature</span></h3>
        <div class="stat"><span>Energy</span><span id="creature-energy">100</span></div>
        <div class="stat"><span>Age</span><span id="creature-age">0</span></div>
        <div class="stat"><span>Generation</span><span id="creature-gen">1</span></div>
        <div style="font-size:0.75em;color:rgba(255,255,255,0.5);margin-top:6px;">Neural Activity:</div>
        <div class="brain-viz" id="brain-viz"></div>
    </div>

    <div id="graph-panel">
        <h3>Population History</h3>
        <canvas id="population-graph" width="300" height="100"></canvas>
    </div>

    <div id="controls">
        <button id="btn-pause">‚è∏ Pause</button>
        <button id="btn-speed-down">‚óÄ</button>
        <div class="speed-display" id="speed-display">1x</div>
        <button id="btn-speed-up">‚ñ∂</button>
        <button id="btn-spawn-herb">+üê∞</button>
        <button id="btn-spawn-pred">+ü¶ä</button>
        <button id="btn-apocalypse" class="danger">‚ò†Ô∏è</button>
    </div>

    <div id="instructions">
        <kbd>WASD</kbd> Move <kbd>Scroll</kbd> Zoom <kbd>Click</kbd> Select <kbd>1-5</kbd> Speed
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
// ============================================================
// NEURAL NETWORK
// ============================================================
class NeuralNetwork {
    constructor(inputSize, hiddenSize, outputSize) {
        this.inputSize = inputSize;
        this.hiddenSize = hiddenSize;
        this.outputSize = outputSize;
        this.weightsIH = this.randomMatrix(hiddenSize, inputSize);
        this.weightsHO = this.randomMatrix(outputSize, hiddenSize);
        this.biasH = this.randomArray(hiddenSize);
        this.biasO = this.randomArray(outputSize);
        this.lastActivations = [];
    }
    randomMatrix(rows, cols) { return Array(rows).fill().map(() => Array(cols).fill().map(() => (Math.random() - 0.5) * 2)); }
    randomArray(size) { return Array(size).fill().map(() => (Math.random() - 0.5) * 2); }
    forward(inputs) {
        const hidden = this.biasH.map((bias, i) => {
            let sum = bias;
            for (let j = 0; j < inputs.length; j++) sum += inputs[j] * this.weightsIH[i][j];
            return Math.tanh(sum);
        });
        const outputs = this.biasO.map((bias, i) => {
            let sum = bias;
            for (let j = 0; j < hidden.length; j++) sum += hidden[j] * this.weightsHO[i][j];
            return Math.tanh(sum);
        });
        this.lastActivations = [...hidden, ...outputs];
        return outputs;
    }
    mutate(rate = 0.1) {
        const m = v => Math.random() < rate ? v + (Math.random() - 0.5) : v;
        this.weightsIH = this.weightsIH.map(r => r.map(m));
        this.weightsHO = this.weightsHO.map(r => r.map(m));
        this.biasH = this.biasH.map(m);
        this.biasO = this.biasO.map(m);
    }
    clone() {
        const nn = new NeuralNetwork(this.inputSize, this.hiddenSize, this.outputSize);
        nn.weightsIH = this.weightsIH.map(r => [...r]);
        nn.weightsHO = this.weightsHO.map(r => [...r]);
        nn.biasH = [...this.biasH];
        nn.biasO = [...this.biasO];
        return nn;
    }
    static crossover(p1, p2) {
        const c = p1.clone();
        for (let i = 0; i < c.weightsIH.length; i++)
            for (let j = 0; j < c.weightsIH[i].length; j++)
                if (Math.random() < 0.5) c.weightsIH[i][j] = p2.weightsIH[i][j];
        for (let i = 0; i < c.weightsHO.length; i++)
            for (let j = 0; j < c.weightsHO[i].length; j++)
                if (Math.random() < 0.5) c.weightsHO[i][j] = p2.weightsHO[i][j];
        return c;
    }
}

// ============================================================
// DNA SYSTEM
// ============================================================
class DNA {
    constructor() {
        this.size = 0.5 + Math.random() * 0.5;
        this.speed = 0.5 + Math.random() * 0.5;
        this.vision = 0.5 + Math.random() * 0.5;
        this.metabolism = 0.5 + Math.random() * 0.5;
        this.colorH = Math.random();
    }
    mutate(rate = 0.15) {
        const m = g => Math.random() < rate ? Math.max(0.1, Math.min(1, g + (Math.random() - 0.5) * 0.3)) : g;
        this.size = m(this.size);
        this.speed = m(this.speed);
        this.vision = m(this.vision);
        this.metabolism = m(this.metabolism);
        this.colorH = m(this.colorH);
    }
    clone() { const d = new DNA(); Object.assign(d, this); return d; }
    static crossover(p1, p2) {
        const c = new DNA();
        ['size','speed','vision','metabolism','colorH'].forEach(g => c[g] = Math.random() < 0.5 ? p1[g] : p2[g]);
        return c;
    }
}

// ============================================================
// CREATURE CLASSES
// ============================================================
let creatureId = 0;

class Creature {
    constructor(x, z, type, gen = 1) {
        this.id = creatureId++;
        this.type = type;
        this.x = x; this.z = z; this.y = 0;
        this.rotation = Math.random() * Math.PI * 2;
        this.generation = gen;
        this.energy = 100;
        this.age = 0;
        this.alive = true;
        this.dna = new DNA();
        this.brain = new NeuralNetwork(6, 10, 3);
        this.fitness = 0;
        this.mesh = null;
        this.vx = 0; this.vz = 0;
        this.reproCD = 0;
    }

    createMesh(color) {
        const size = 0.3 + this.dna.size * 0.3;
        const geo = new THREE.SphereGeometry(size, 12, 8);
        const mat = new THREE.MeshStandardMaterial({ color, roughness: 0.6 });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.set(this.x, size, this.z);
        mesh.castShadow = true;
        this.mesh = mesh;
        this.meshSize = size;
        return mesh;
    }

    update(delta, world) {
        if (!this.alive) return;
        this.age += delta;
        this.energy -= (0.3 + this.dna.metabolism * 0.3) * delta;
        this.reproCD -= delta;

        if (this.energy <= 0 || this.age > 80) { this.die(); return; }

        const inputs = this.sense(world);
        const [fwd, turn, action] = this.brain.forward(inputs);

        const speed = (1 + this.dna.speed) * 4;
        this.rotation += turn * 3 * delta;
        const move = (fwd + 1) / 2;

        let newX = this.x + Math.sin(this.rotation) * move * speed * delta;
        let newZ = this.z + Math.cos(this.rotation) * move * speed * delta;

        // Collision with buildings
        if (!world.isBlocked(newX, newZ)) {
            this.x = newX;
            this.z = newZ;
        } else {
            this.rotation += Math.PI / 2;
        }

        // Keep in bounds
        const bound = 95;
        this.x = Math.max(-bound, Math.min(bound, this.x));
        this.z = Math.max(-bound, Math.min(bound, this.z));

        if (this.mesh) {
            this.mesh.position.set(this.x, this.meshSize, this.z);
            this.mesh.rotation.y = this.rotation;
        }

        this.fitness += delta * (this.energy / 100);
    }

    sense(world) {
        const food = this.findNearest(world, this.foodTypes());
        const threat = this.findNearest(world, this.threatTypes());
        return [
            food ? Math.min(1, this.dist(food) / 20) : 1,
            food ? this.angleTo(food) / Math.PI : 0,
            threat ? Math.min(1, this.dist(threat) / 15) : 1,
            threat ? this.angleTo(threat) / Math.PI : 0,
            this.energy / 100,
            Math.random() * 0.1
        ];
    }

    findNearest(world, types) {
        let nearest = null, minD = this.dna.vision * 25;
        world.creatures.forEach(c => {
            if (!c.alive || c === this || !types.includes(c.type)) return;
            const d = this.dist(c);
            if (d < minD) { minD = d; nearest = c; }
        });
        return nearest;
    }

    dist(o) { return Math.sqrt((o.x-this.x)**2 + (o.z-this.z)**2); }
    angleTo(o) {
        const a = Math.atan2(o.x-this.x, o.z-this.z);
        let d = a - this.rotation;
        while (d > Math.PI) d -= Math.PI*2;
        while (d < -Math.PI) d += Math.PI*2;
        return d;
    }

    foodTypes() { return []; }
    threatTypes() { return []; }

    reproduce(partner, world) {
        if (this.energy < 55 || partner.energy < 55 || this.reproCD > 0) return null;
        this.energy -= 25; partner.energy -= 25;
        const child = this.createChild((this.x+partner.x)/2, (this.z+partner.z)/2, partner);
        this.reproCD = 8; partner.reproCD = 8;
        return child;
    }

    createChild(x, z, partner) { return null; }
    die() {
        this.alive = false;
        if (this.mesh?.parent) this.mesh.parent.remove(this.mesh);
    }
}

class Plant extends Creature {
    constructor(x, z) {
        super(x, z, 'plant', 1);
        this.energy = 50;
    }
    createMesh() {
        const g = new THREE.Group();
        const h = 0.3 + this.dna.size * 0.4;
        const stem = new THREE.Mesh(
            new THREE.CylinderGeometry(0.05, 0.08, h, 6),
            new THREE.MeshStandardMaterial({ color: 0x228822 })
        );
        stem.position.y = h/2;
        g.add(stem);
        const leaves = new THREE.Mesh(
            new THREE.SphereGeometry(h * 0.6, 8, 6),
            new THREE.MeshStandardMaterial({ color: 0x33aa44 })
        );
        leaves.position.y = h;
        leaves.castShadow = true;
        g.add(leaves);
        g.position.set(this.x, 0, this.z);
        this.mesh = g;
        this.meshSize = h;
        return g;
    }
    update(delta, world) {
        if (!this.alive) return;
        this.age += delta;
        this.energy = Math.min(100, this.energy + delta * 2);
        if (this.energy > 80 && Math.random() < 0.005 * delta) {
            const nearby = world.creatures.filter(c => c.type === 'plant' && c.alive && this.dist(c) < 4).length;
            if (nearby < 3 && world.isInPark(this.x, this.z)) {
                const a = Math.random() * Math.PI * 2;
                const d = 2 + Math.random() * 3;
                const nx = this.x + Math.cos(a) * d;
                const nz = this.z + Math.sin(a) * d;
                if (world.isInPark(nx, nz)) {
                    world.addCreature(new Plant(nx, nz));
                    this.energy -= 15;
                }
            }
        }
        if (this.age > 150) this.die();
        if (this.mesh) {
            const s = 0.5 + this.energy / 200;
            this.mesh.scale.set(s, s, s);
        }
    }
    sense() { return []; }
}

class Herbivore extends Creature {
    constructor(x, z, gen = 1) { super(x, z, 'herbivore', gen); }
    createMesh() { return super.createMesh(new THREE.Color().setHSL(0.55 + this.dna.colorH * 0.1, 0.7, 0.5).getHex()); }
    foodTypes() { return ['plant']; }
    threatTypes() { return ['predator']; }
    update(delta, world) {
        super.update(delta, world);
        if (!this.alive) return;
        // Eat plants
        world.creatures.filter(c => c.type === 'plant' && c.alive && this.dist(c) < 1).forEach(p => {
            const amt = Math.min(p.energy, 15 * delta);
            this.energy = Math.min(100, this.energy + amt);
            p.energy -= amt;
            if (p.energy <= 0) p.die();
        });
        // Reproduce
        if (this.energy > 70 && this.reproCD <= 0) {
            const mate = world.creatures.find(c => c.type === 'herbivore' && c !== this && c.alive && c.energy > 60 && this.dist(c) < 3);
            if (mate) {
                const child = this.reproduce(mate, world);
                if (child) world.addCreature(child);
            }
        }
    }
    createChild(x, z, partner) {
        const c = new Herbivore(x, z, Math.max(this.generation, partner.generation) + 1);
        c.dna = DNA.crossover(this.dna, partner.dna); c.dna.mutate();
        c.brain = NeuralNetwork.crossover(this.brain, partner.brain); c.brain.mutate();
        c.energy = 50;
        return c;
    }
}

class Predator extends Creature {
    constructor(x, z, gen = 1) { super(x, z, 'predator', gen); this.attackCD = 0; }
    createMesh() {
        const size = 0.4 + this.dna.size * 0.4;
        const geo = new THREE.ConeGeometry(size, size * 1.5, 6);
        const mat = new THREE.MeshStandardMaterial({ color: new THREE.Color().setHSL(0.0 + this.dna.colorH * 0.05, 0.8, 0.45).getHex() });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.rotation.x = Math.PI / 2;
        const g = new THREE.Group();
        g.add(mesh);
        g.position.set(this.x, size, this.z);
        this.mesh = g;
        this.meshSize = size;
        return g;
    }
    foodTypes() { return ['herbivore']; }
    threatTypes() { return []; }
    update(delta, world) {
        super.update(delta, world);
        if (!this.alive) return;
        this.attackCD -= delta;
        // Hunt
        if (this.attackCD <= 0) {
            const prey = world.creatures.find(c => c.type === 'herbivore' && c.alive && this.dist(c) < 1.5);
            if (prey) {
                prey.energy -= 40;
                if (prey.energy <= 0) {
                    prey.die();
                    this.energy = Math.min(100, this.energy + 40);
                    this.fitness += 5;
                }
                this.attackCD = 0.8;
            }
        }
        // Reproduce
        if (this.energy > 75 && this.reproCD <= 0) {
            const mate = world.creatures.find(c => c.type === 'predator' && c !== this && c.alive && c.energy > 70 && this.dist(c) < 3);
            if (mate) {
                const child = this.reproduce(mate, world);
                if (child) world.addCreature(child);
            }
        }
    }
    createChild(x, z, partner) {
        const c = new Predator(x, z, Math.max(this.generation, partner.generation) + 1);
        c.dna = DNA.crossover(this.dna, partner.dna); c.dna.mutate();
        c.brain = NeuralNetwork.crossover(this.brain, partner.brain); c.brain.mutate();
        c.energy = 50;
        return c;
    }
}

// ============================================================
// CITY GENERATOR
// ============================================================
class City {
    constructor(scene) {
        this.scene = scene;
        this.buildings = [];
        this.parks = [];
        this.roads = [];
        this.generate();
    }

    generate() {
        const blockSize = 20;
        const roadWidth = 4;
        const gridSize = 10;

        // Materials
        const roadMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.9 });
        const sidewalkMat = new THREE.MeshStandardMaterial({ color: 0x666666, roughness: 0.8 });
        const grassMat = new THREE.MeshStandardMaterial({ color: 0x2d5a2d, roughness: 0.9 });

        const buildingColors = [0x8899aa, 0x667788, 0x556677, 0x445566, 0x778899, 0x99aabb, 0x4a6070, 0x5a7080];

        // Create ground
        const groundGeo = new THREE.PlaneGeometry(200, 200);
        const ground = new THREE.Mesh(groundGeo, grassMat);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        this.scene.add(ground);

        // Create city grid
        for (let gx = -gridSize/2; gx < gridSize/2; gx++) {
            for (let gz = -gridSize/2; gz < gridSize/2; gz++) {
                const bx = gx * blockSize;
                const bz = gz * blockSize;

                // Roads (horizontal and vertical)
                const roadH = new THREE.Mesh(
                    new THREE.PlaneGeometry(blockSize, roadWidth),
                    roadMat
                );
                roadH.rotation.x = -Math.PI / 2;
                roadH.position.set(bx + blockSize/2, 0.01, bz);
                this.scene.add(roadH);
                this.roads.push({ x: bx, z: bz - roadWidth/2, w: blockSize, h: roadWidth });

                const roadV = new THREE.Mesh(
                    new THREE.PlaneGeometry(roadWidth, blockSize),
                    roadMat
                );
                roadV.rotation.x = -Math.PI / 2;
                roadV.position.set(bx, 0.01, bz + blockSize/2);
                this.scene.add(roadV);
                this.roads.push({ x: bx - roadWidth/2, z: bz, w: roadWidth, h: blockSize });

                // Decide block type
                const distFromCenter = Math.sqrt(gx*gx + gz*gz);
                const isPark = Math.random() < 0.15 || (distFromCenter > 3 && Math.random() < 0.2);

                if (isPark) {
                    // Park
                    const parkGeo = new THREE.PlaneGeometry(blockSize - roadWidth - 2, blockSize - roadWidth - 2);
                    const park = new THREE.Mesh(parkGeo, new THREE.MeshStandardMaterial({ color: 0x3a7a3a }));
                    park.rotation.x = -Math.PI / 2;
                    park.position.set(bx + blockSize/2, 0.02, bz + blockSize/2);
                    this.scene.add(park);
                    this.parks.push({
                        x: bx + roadWidth/2 + 1,
                        z: bz + roadWidth/2 + 1,
                        w: blockSize - roadWidth - 2,
                        h: blockSize - roadWidth - 2
                    });
                } else {
                    // Buildings
                    const numBuildings = Math.floor(Math.random() * 3) + 1;
                    for (let i = 0; i < numBuildings; i++) {
                        const bWidth = 3 + Math.random() * 6;
                        const bDepth = 3 + Math.random() * 6;
                        const bHeight = distFromCenter < 2 ? 15 + Math.random() * 35 : 5 + Math.random() * 15;

                        const buildingX = bx + roadWidth/2 + 2 + Math.random() * (blockSize - roadWidth - bWidth - 4);
                        const buildingZ = bz + roadWidth/2 + 2 + Math.random() * (blockSize - roadWidth - bDepth - 4);

                        const buildingGeo = new THREE.BoxGeometry(bWidth, bHeight, bDepth);
                        const buildingMat = new THREE.MeshStandardMaterial({
                            color: buildingColors[Math.floor(Math.random() * buildingColors.length)],
                            roughness: 0.7,
                            metalness: 0.1
                        });
                        const building = new THREE.Mesh(buildingGeo, buildingMat);
                        building.position.set(buildingX + bWidth/2, bHeight/2, buildingZ + bDepth/2);
                        building.castShadow = true;
                        building.receiveShadow = true;
                        this.scene.add(building);

                        // Windows
                        this.addWindows(building, bWidth, bDepth, bHeight);

                        this.buildings.push({
                            x: buildingX,
                            z: buildingZ,
                            w: bWidth,
                            h: bDepth,
                            height: bHeight
                        });
                    }
                }
            }
        }

        // Add road markings
        this.addRoadMarkings();
    }

    addWindows(building, w, d, h) {
        const windowMat = new THREE.MeshBasicMaterial({ color: 0xffffcc });
        const windowSize = 0.8;
        const spacing = 2.5;

        for (let y = 3; y < h - 2; y += spacing) {
            // Front and back
            for (let x = -w/2 + 1.5; x < w/2 - 1; x += spacing) {
                if (Math.random() > 0.3) {
                    const win = new THREE.Mesh(new THREE.PlaneGeometry(windowSize, windowSize * 1.2), windowMat);
                    win.position.set(x, y - h/2, d/2 + 0.01);
                    building.add(win);
                }
            }
            // Sides
            for (let z = -d/2 + 1.5; z < d/2 - 1; z += spacing) {
                if (Math.random() > 0.3) {
                    const win = new THREE.Mesh(new THREE.PlaneGeometry(windowSize, windowSize * 1.2), windowMat);
                    win.rotation.y = Math.PI / 2;
                    win.position.set(w/2 + 0.01, y - h/2, z);
                    building.add(win);
                }
            }
        }
    }

    addRoadMarkings() {
        const markingMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
        this.roads.forEach(road => {
            if (road.w > road.h) {
                // Horizontal road - add dashes
                for (let x = road.x; x < road.x + road.w; x += 4) {
                    const dash = new THREE.Mesh(new THREE.PlaneGeometry(2, 0.2), markingMat);
                    dash.rotation.x = -Math.PI / 2;
                    dash.position.set(x + 1, 0.02, road.z + road.h/2);
                    this.scene.add(dash);
                }
            }
        });
    }

    isBlocked(x, z, radius = 0.5) {
        for (const b of this.buildings) {
            if (x > b.x - radius && x < b.x + b.w + radius &&
                z > b.z - radius && z < b.z + b.h + radius) {
                return true;
            }
        }
        return false;
    }

    isInPark(x, z) {
        for (const p of this.parks) {
            if (x > p.x && x < p.x + p.w && z > p.z && z < p.z + p.h) {
                return true;
            }
        }
        return false;
    }

    getRandomParkPosition() {
        if (this.parks.length === 0) return { x: 0, z: 0 };
        const park = this.parks[Math.floor(Math.random() * this.parks.length)];
        return {
            x: park.x + Math.random() * park.w,
            z: park.z + Math.random() * park.h
        };
    }
}

// ============================================================
// WORLD MANAGER
// ============================================================
class World {
    constructor(city) {
        this.city = city;
        this.creatures = [];
        this.history = { plants: [], herbivores: [], predators: [] };
        this.totalYears = 0;
        this.generation = 1;
        this.historyTimer = 0;
    }

    addCreature(c) {
        this.creatures.push(c);
        scene.add(c.createMesh());
    }

    isBlocked(x, z) { return this.city.isBlocked(x, z); }
    isInPark(x, z) { return this.city.isInPark(x, z); }

    update(delta) {
        this.creatures.forEach(c => c.update(delta, this));
        this.creatures = this.creatures.filter(c => c.alive);
        this.totalYears += delta / 10;

        // Track history
        this.historyTimer += delta;
        if (this.historyTimer > 0.5) {
            this.historyTimer = 0;
            const counts = this.getCounts();
            this.history.plants.push(counts.plants);
            this.history.herbivores.push(counts.herbivores);
            this.history.predators.push(counts.predators);
            if (this.history.plants.length > 150) {
                this.history.plants.shift();
                this.history.herbivores.shift();
                this.history.predators.shift();
            }
        }

        this.creatures.forEach(c => { if (c.generation > this.generation) this.generation = c.generation; });

        // Spawn plants in parks
        const plantCount = this.creatures.filter(c => c.type === 'plant').length;
        if (plantCount < 60 && Math.random() < 0.05) {
            const pos = this.city.getRandomParkPosition();
            this.addCreature(new Plant(pos.x, pos.z));
        }
    }

    getCounts() {
        const c = { plants: 0, herbivores: 0, predators: 0 };
        this.creatures.forEach(cr => { if (c[cr.type + 's'] !== undefined) c[cr.type + 's']++; });
        return c;
    }

    getAvgFitness() {
        const active = this.creatures.filter(c => c.type !== 'plant');
        return active.length ? active.reduce((s, c) => s + c.fitness, 0) / active.length : 0;
    }

    spawn(type, n = 1) {
        for (let i = 0; i < n; i++) {
            let x, z, attempts = 0;
            do {
                x = (Math.random() - 0.5) * 180;
                z = (Math.random() - 0.5) * 180;
                attempts++;
            } while (this.city.isBlocked(x, z) && attempts < 20);

            if (type === 'plant') {
                const pos = this.city.getRandomParkPosition();
                this.addCreature(new Plant(pos.x, pos.z));
            } else if (type === 'herbivore') this.addCreature(new Herbivore(x, z));
            else if (type === 'predator') this.addCreature(new Predator(x, z));
        }
    }

    apocalypse() {
        this.creatures.filter(() => Math.random() < 0.75).forEach(c => c.die());
        this.creatures = this.creatures.filter(c => c.alive);
    }
}

// ============================================================
// THREE.JS SETUP
// ============================================================
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x1a2535);
scene.fog = new THREE.Fog(0x1a2535, 80, 200);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 60, 80);
camera.lookAt(0, 0, 0);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

// Lighting
scene.add(new THREE.AmbientLight(0x404050, 0.6));
const sun = new THREE.DirectionalLight(0xffeedd, 1.2);
sun.position.set(80, 100, 40);
sun.castShadow = true;
sun.shadow.mapSize.width = 2048;
sun.shadow.mapSize.height = 2048;
sun.shadow.camera.near = 10;
sun.shadow.camera.far = 300;
sun.shadow.camera.left = -100;
sun.shadow.camera.right = 100;
sun.shadow.camera.top = 100;
sun.shadow.camera.bottom = -100;
scene.add(sun);

// Camera controls
let camTarget = new THREE.Vector3(0, 0, 0);
let camDist = 80, camAngle = 0, camPitch = 0.7;
let dragging = false, lastMX = 0, lastMY = 0;
let selectedCreature = null;

renderer.domElement.addEventListener('mousedown', e => {
    if (e.button === 0) {
        const mouse = new THREE.Vector2((e.clientX / window.innerWidth) * 2 - 1, -(e.clientY / window.innerHeight) * 2 + 1);
        const ray = new THREE.Raycaster();
        ray.setFromCamera(mouse, camera);
        const hits = ray.intersectObjects(world.creatures.map(c => c.mesh).filter(m => m), true);
        if (hits.length) {
            const m = hits[0].object.parent?.type === 'Group' ? hits[0].object.parent : hits[0].object;
            selectedCreature = world.creatures.find(c => c.mesh === m || c.mesh?.children?.includes(hits[0].object));
            if (selectedCreature) document.getElementById('creature-panel').classList.add('visible');
            return;
        }
        dragging = true;
    }
    lastMX = e.clientX; lastMY = e.clientY;
});
renderer.domElement.addEventListener('mousemove', e => {
    if (dragging) {
        camAngle -= (e.clientX - lastMX) * 0.01;
        camPitch = Math.max(0.2, Math.min(1.4, camPitch + (e.clientY - lastMY) * 0.01));
    }
    lastMX = e.clientX; lastMY = e.clientY;
});
renderer.domElement.addEventListener('mouseup', () => dragging = false);
renderer.domElement.addEventListener('wheel', e => camDist = Math.max(20, Math.min(200, camDist + e.deltaY * 0.1)));

const keys = { w: false, a: false, s: false, d: false };
document.addEventListener('keydown', e => {
    if (e.key.toLowerCase() in keys) keys[e.key.toLowerCase()] = true;
    if (e.key === 'p') togglePause();
    if (e.key >= '1' && e.key <= '5') { timeScale = [0.5, 1, 2, 5, 20][+e.key - 1]; updateSpeed(); }
});
document.addEventListener('keyup', e => { if (e.key.toLowerCase() in keys) keys[e.key.toLowerCase()] = false; });

function updateCamera(dt) {
    const sp = 40 * dt;
    if (keys.w) camTarget.z -= sp;
    if (keys.s) camTarget.z += sp;
    if (keys.a) camTarget.x -= sp;
    if (keys.d) camTarget.x += sp;
    camera.position.x = camTarget.x + Math.sin(camAngle) * camDist;
    camera.position.z = camTarget.z + Math.cos(camAngle) * camDist;
    camera.position.y = camDist * camPitch;
    camera.lookAt(camTarget);
}

// ============================================================
// UI & CONTROLS
// ============================================================
let paused = false, timeScale = 1;
function togglePause() { paused = !paused; document.getElementById('btn-pause').textContent = paused ? '‚ñ∂ Play' : '‚è∏ Pause'; }
function updateSpeed() { document.getElementById('speed-display').textContent = timeScale + 'x'; }

document.getElementById('btn-pause').onclick = togglePause;
document.getElementById('btn-speed-down').onclick = () => { timeScale = Math.max(0.25, timeScale / 2); updateSpeed(); };
document.getElementById('btn-speed-up').onclick = () => { timeScale = Math.min(20, timeScale * 2); updateSpeed(); };
document.getElementById('btn-spawn-herb').onclick = () => world.spawn('herbivore', 5);
document.getElementById('btn-spawn-pred').onclick = () => world.spawn('predator', 3);
document.getElementById('btn-apocalypse').onclick = () => world.apocalypse();

const graphCanvas = document.getElementById('population-graph');
const graphCtx = graphCanvas.getContext('2d');

function drawGraph() {
    graphCtx.fillStyle = '#111';
    graphCtx.fillRect(0, 0, 300, 100);
    const h = world.history;
    const max = Math.max(1, ...h.plants, ...h.herbivores, ...h.predators);
    const draw = (data, color) => {
        if (data.length < 2) return;
        graphCtx.strokeStyle = color;
        graphCtx.lineWidth = 1.5;
        graphCtx.beginPath();
        data.forEach((v, i) => {
            const x = (i / 149) * 300;
            const y = 100 - (v / max) * 95;
            i === 0 ? graphCtx.moveTo(x, y) : graphCtx.lineTo(x, y);
        });
        graphCtx.stroke();
    };
    draw(h.plants, '#00ff88');
    draw(h.herbivores, '#00aaff');
    draw(h.predators, '#ff4466');
}

function updateUI() {
    const c = world.getCounts();
    document.getElementById('stat-plants').textContent = c.plants;
    document.getElementById('stat-herbivores').textContent = c.herbivores;
    document.getElementById('stat-predators').textContent = c.predators;
    document.getElementById('stat-generation').textContent = world.generation;
    document.getElementById('stat-fitness').textContent = world.getAvgFitness().toFixed(1);
    document.getElementById('stat-buildings').textContent = city.buildings.length;
    document.getElementById('years-display').textContent = Math.floor(world.totalYears);

    if (selectedCreature && !selectedCreature.alive) {
        selectedCreature = null;
        document.getElementById('creature-panel').classList.remove('visible');
    }
    if (selectedCreature) {
        const icons = { plant: 'üåø', herbivore: 'üê∞', predator: 'ü¶ä' };
        document.getElementById('creature-icon').textContent = icons[selectedCreature.type];
        document.getElementById('creature-name').textContent = `${selectedCreature.type} #${selectedCreature.id}`;
        document.getElementById('creature-energy').textContent = selectedCreature.energy.toFixed(1);
        document.getElementById('creature-age').textContent = selectedCreature.age.toFixed(1) + 's';
        document.getElementById('creature-gen').textContent = selectedCreature.generation;
        if (selectedCreature.brain) {
            document.getElementById('brain-viz').innerHTML = selectedCreature.brain.lastActivations.slice(0, 12)
                .map(a => `<div class="neuron ${Math.abs(a) > 0.3 ? 'active' : ''}"></div>`).join('');
        }
    }
}

// ============================================================
// MAIN LOOP
// ============================================================
const city = new City(scene);
const world = new World(city);

// Initial spawn
for (let i = 0; i < 80; i++) world.spawn('plant');
for (let i = 0; i < 25; i++) world.spawn('herbivore');
for (let i = 0; i < 8; i++) world.spawn('predator');

let lastTime = performance.now(), frames = 0, fpsTime = 0;

function animate() {
    requestAnimationFrame(animate);
    const now = performance.now();
    const dt = Math.min((now - lastTime) / 1000, 0.1);
    lastTime = now;

    frames++; fpsTime += dt;
    if (fpsTime >= 1) { document.getElementById('stat-fps').textContent = frames; frames = 0; fpsTime = 0; }

    if (!paused) world.update(dt * timeScale);
    updateCamera(dt);
    updateUI();
    drawGraph();
    renderer.render(scene, camera);
}

setTimeout(() => document.getElementById('loading').classList.add('hidden'), 1500);
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

animate();
    </script>
</body>
</html>
