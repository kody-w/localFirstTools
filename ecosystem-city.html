<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ecosystem City - Evolution Simulation</title>
    <meta name="description" content="Living city ecosystem with evolving creatures, neural network brains, and genetic algorithms.">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            overflow: hidden;
            background: #000;
            font-family: 'Segoe UI', system-ui, sans-serif;
            color: white;
        }

        #loading {
            position: fixed;
            inset: 0;
            background: linear-gradient(135deg, #0a1628, #1a0a28);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 0.8s ease;
        }
        #loading.hidden { opacity: 0; pointer-events: none; }
        #loading h1 {
            font-size: 3em;
            background: linear-gradient(90deg, #00ff88, #00aaff, #ff00aa);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }
        #loading p { color: rgba(255,255,255,0.6); margin-bottom: 30px; }
        .loading-bar { width: 300px; height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; overflow: hidden; }
        .loading-fill { height: 100%; background: linear-gradient(90deg, #00ff88, #00aaff); width: 0%; animation: load 2s ease-out forwards; }
        @keyframes load { to { width: 100%; } }

        /* HUD */
        #hud {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(0,0,0,0.85);
            padding: 15px 20px;
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            min-width: 220px;
        }
        #hud h2 { font-size: 1.1em; color: #00ff88; margin-bottom: 12px; display: flex; align-items: center; gap: 8px; }
        .stat-group { margin-bottom: 12px; }
        .stat-group-title { font-size: 0.75em; color: rgba(255,255,255,0.4); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 6px; }
        .stat { display: flex; justify-content: space-between; padding: 3px 0; font-size: 0.9em; }
        .stat-label { color: rgba(255,255,255,0.7); }
        .stat-value { font-weight: bold; }
        .stat-value.plants { color: #00ff88; }
        .stat-value.herbivores { color: #00aaff; }
        .stat-value.predators { color: #ff4466; }
        .stat-value.generation { color: #ffaa00; }

        /* Population Graph */
        #graph-panel {
            position: absolute;
            bottom: 15px;
            left: 15px;
            background: rgba(0,0,0,0.85);
            padding: 15px;
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
        }
        #graph-panel h3 { font-size: 0.9em; color: #00aaff; margin-bottom: 10px; }
        #population-graph { background: rgba(0,0,0,0.5); border-radius: 8px; }

        /* Controls */
        #controls {
            position: absolute;
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.85);
            padding: 12px 20px;
            border-radius: 25px;
            border: 1px solid rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            display: flex;
            gap: 8px;
            align-items: center;
        }
        button {
            background: linear-gradient(135deg, #333, #222);
            color: white;
            border: 1px solid rgba(255,255,255,0.1);
            padding: 8px 16px;
            cursor: pointer;
            border-radius: 15px;
            font-size: 12px;
            transition: all 0.2s;
        }
        button:hover { background: linear-gradient(135deg, #444, #333); transform: translateY(-1px); }
        button.active { background: linear-gradient(135deg, #00aa66, #008855); border-color: #00ff88; }
        button.danger { background: linear-gradient(135deg, #aa3344, #882233); }
        .speed-display {
            background: rgba(255,255,255,0.1);
            padding: 8px 15px;
            border-radius: 15px;
            font-size: 12px;
            min-width: 80px;
            text-align: center;
        }

        /* Time Display */
        #time-panel {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(0,0,0,0.85);
            padding: 15px 20px;
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            text-align: center;
        }
        #time-panel .years { font-size: 2em; font-weight: bold; color: #ffaa00; }
        #time-panel .label { font-size: 0.8em; color: rgba(255,255,255,0.5); }

        /* Selected Creature Panel */
        #creature-panel {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.9);
            padding: 15px 25px;
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.15);
            backdrop-filter: blur(10px);
            display: none;
            min-width: 300px;
        }
        #creature-panel.visible { display: block; }
        #creature-panel h3 { margin-bottom: 10px; display: flex; align-items: center; gap: 10px; }
        #creature-panel .dna-display { font-family: monospace; font-size: 0.8em; background: rgba(255,255,255,0.05); padding: 8px; border-radius: 6px; margin: 10px 0; word-break: break-all; }
        .brain-viz { display: flex; gap: 5px; margin-top: 10px; }
        .neuron { width: 8px; height: 8px; border-radius: 50%; background: #333; }
        .neuron.active { background: #00ff88; box-shadow: 0 0 5px #00ff88; }

        /* Legend */
        #legend {
            position: absolute;
            top: 200px;
            right: 15px;
            background: rgba(0,0,0,0.85);
            padding: 12px 15px;
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.1);
            font-size: 0.85em;
        }
        .legend-item { display: flex; align-items: center; gap: 8px; padding: 4px 0; }
        .legend-dot { width: 12px; height: 12px; border-radius: 50%; }

        /* Family Tree Modal */
        #family-tree-modal {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }
        #family-tree-modal.visible { display: flex; }
        #family-tree-content {
            background: #111;
            padding: 30px;
            border-radius: 15px;
            max-width: 90vw;
            max-height: 90vh;
            overflow: auto;
        }

        /* Instructions */
        #instructions {
            position: absolute;
            bottom: 70px;
            left: 15px;
            font-size: 0.75em;
            color: rgba(255,255,255,0.4);
            line-height: 1.6;
        }
        kbd { background: rgba(255,255,255,0.1); padding: 2px 6px; border-radius: 3px; }
    </style>
</head>
<body>
    <div id="loading">
        <h1>ECOSYSTEM CITY</h1>
        <p>Initializing neural networks and spawning life...</p>
        <div class="loading-bar"><div class="loading-fill"></div></div>
    </div>

    <div id="hud">
        <h2><span>üåç</span> Ecosystem Status</h2>
        <div class="stat-group">
            <div class="stat-group-title">Population</div>
            <div class="stat"><span class="stat-label">üåø Plants</span><span class="stat-value plants" id="stat-plants">0</span></div>
            <div class="stat"><span class="stat-label">üê∞ Herbivores</span><span class="stat-value herbivores" id="stat-herbivores">0</span></div>
            <div class="stat"><span class="stat-label">ü¶ä Predators</span><span class="stat-value predators" id="stat-predators">0</span></div>
        </div>
        <div class="stat-group">
            <div class="stat-group-title">Evolution</div>
            <div class="stat"><span class="stat-label">Generation</span><span class="stat-value generation" id="stat-generation">1</span></div>
            <div class="stat"><span class="stat-label">Avg Fitness</span><span class="stat-value" id="stat-fitness">0</span></div>
            <div class="stat"><span class="stat-label">Species</span><span class="stat-value" id="stat-species">2</span></div>
        </div>
        <div class="stat-group">
            <div class="stat-group-title">World</div>
            <div class="stat"><span class="stat-label">Chunks</span><span class="stat-value" id="stat-chunks">0</span></div>
            <div class="stat"><span class="stat-label">FPS</span><span class="stat-value" id="stat-fps">60</span></div>
        </div>
    </div>

    <div id="time-panel">
        <div class="years" id="years-display">0</div>
        <div class="label">Years of Evolution</div>
    </div>

    <div id="legend">
        <div class="legend-item"><div class="legend-dot" style="background:#00ff88"></div> Plants</div>
        <div class="legend-item"><div class="legend-dot" style="background:#00aaff"></div> Herbivores</div>
        <div class="legend-item"><div class="legend-dot" style="background:#ff4466"></div> Predators</div>
        <div class="legend-item"><div class="legend-dot" style="background:#ffaa00"></div> Selected</div>
    </div>

    <div id="creature-panel">
        <h3><span id="creature-icon">üê∞</span> <span id="creature-name">Creature</span></h3>
        <div class="stat"><span class="stat-label">Energy</span><span id="creature-energy">100</span></div>
        <div class="stat"><span class="stat-label">Age</span><span id="creature-age">0</span></div>
        <div class="stat"><span class="stat-label">Children</span><span id="creature-children">0</span></div>
        <div class="stat"><span class="stat-label">Generation</span><span id="creature-gen">1</span></div>
        <div class="dna-display" id="creature-dna">DNA: ...</div>
        <div style="font-size:0.8em;color:rgba(255,255,255,0.5);margin-top:8px;">Neural Activity:</div>
        <div class="brain-viz" id="brain-viz"></div>
    </div>

    <div id="graph-panel">
        <h3>Population Over Time</h3>
        <canvas id="population-graph" width="350" height="120"></canvas>
    </div>

    <div id="controls">
        <button id="btn-pause">‚è∏ Pause</button>
        <button id="btn-speed-down">‚óÄ</button>
        <div class="speed-display" id="speed-display">1x Speed</div>
        <button id="btn-speed-up">‚ñ∂</button>
        <button id="btn-spawn-herb" class="secondary">+üê∞</button>
        <button id="btn-spawn-pred" class="secondary">+ü¶ä</button>
        <button id="btn-apocalypse" class="danger">‚ò†Ô∏è Meteor</button>
        <button id="btn-tree">üå≥ Family Tree</button>
    </div>

    <div id="instructions">
        <kbd>Click</kbd> Select creature &nbsp; <kbd>WASD</kbd> Move &nbsp; <kbd>Space</kbd> Up &nbsp; <kbd>Scroll</kbd> Zoom<br>
        <kbd>1-5</kbd> Time speed &nbsp; <kbd>P</kbd> Pause &nbsp; <kbd>F</kbd> Follow selected
    </div>

    <div id="family-tree-modal">
        <div id="family-tree-content">
            <h2 style="margin-bottom:20px;">üå≥ Species Family Tree</h2>
            <canvas id="tree-canvas" width="800" height="500"></canvas>
            <button onclick="document.getElementById('family-tree-modal').classList.remove('visible')" style="margin-top:20px;">Close</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
// ============================================================
// NEAT NEURAL NETWORK IMPLEMENTATION
// ============================================================
class NeuralNetwork {
    constructor(inputSize, hiddenSize, outputSize) {
        this.inputSize = inputSize;
        this.hiddenSize = hiddenSize;
        this.outputSize = outputSize;

        // Initialize weights with small random values
        this.weightsIH = this.randomMatrix(hiddenSize, inputSize);
        this.weightsHO = this.randomMatrix(outputSize, hiddenSize);
        this.biasH = this.randomArray(hiddenSize);
        this.biasO = this.randomArray(outputSize);

        this.lastActivations = [];
    }

    randomMatrix(rows, cols) {
        return Array(rows).fill().map(() =>
            Array(cols).fill().map(() => (Math.random() - 0.5) * 2)
        );
    }

    randomArray(size) {
        return Array(size).fill().map(() => (Math.random() - 0.5) * 2);
    }

    sigmoid(x) {
        return 1 / (1 + Math.exp(-Math.max(-500, Math.min(500, x))));
    }

    tanh(x) {
        return Math.tanh(x);
    }

    forward(inputs) {
        // Hidden layer
        const hidden = this.biasH.map((bias, i) => {
            let sum = bias;
            for (let j = 0; j < inputs.length; j++) {
                sum += inputs[j] * this.weightsIH[i][j];
            }
            return this.tanh(sum);
        });

        // Output layer
        const outputs = this.biasO.map((bias, i) => {
            let sum = bias;
            for (let j = 0; j < hidden.length; j++) {
                sum += hidden[j] * this.weightsHO[i][j];
            }
            return this.tanh(sum);
        });

        this.lastActivations = [...hidden, ...outputs];
        return outputs;
    }

    mutate(rate = 0.1, strength = 0.5) {
        const mutateValue = (v) => {
            if (Math.random() < rate) {
                return v + (Math.random() - 0.5) * strength * 2;
            }
            return v;
        };

        this.weightsIH = this.weightsIH.map(row => row.map(mutateValue));
        this.weightsHO = this.weightsHO.map(row => row.map(mutateValue));
        this.biasH = this.biasH.map(mutateValue);
        this.biasO = this.biasO.map(mutateValue);
    }

    clone() {
        const nn = new NeuralNetwork(this.inputSize, this.hiddenSize, this.outputSize);
        nn.weightsIH = this.weightsIH.map(row => [...row]);
        nn.weightsHO = this.weightsHO.map(row => [...row]);
        nn.biasH = [...this.biasH];
        nn.biasO = [...this.biasO];
        return nn;
    }

    static crossover(parent1, parent2) {
        const child = parent1.clone();

        // Crossover weights
        for (let i = 0; i < child.weightsIH.length; i++) {
            for (let j = 0; j < child.weightsIH[i].length; j++) {
                if (Math.random() < 0.5) {
                    child.weightsIH[i][j] = parent2.weightsIH[i][j];
                }
            }
        }

        for (let i = 0; i < child.weightsHO.length; i++) {
            for (let j = 0; j < child.weightsHO[i].length; j++) {
                if (Math.random() < 0.5) {
                    child.weightsHO[i][j] = parent2.weightsHO[i][j];
                }
            }
        }

        return child;
    }

    // Serialize for DNA display
    serialize() {
        const allWeights = [
            ...this.weightsIH.flat(),
            ...this.weightsHO.flat(),
            ...this.biasH,
            ...this.biasO
        ];
        return allWeights.map(w => ((w + 2) / 4 * 255) | 0)
            .map(v => v.toString(16).padStart(2, '0')).join('').toUpperCase();
    }
}

// ============================================================
// DNA / GENETICS SYSTEM
// ============================================================
class DNA {
    constructor() {
        // Physical traits (0-1 range)
        this.size = 0.5 + Math.random() * 0.5;           // Body size
        this.speed = 0.5 + Math.random() * 0.5;          // Movement speed
        this.visionRange = 0.5 + Math.random() * 0.5;    // How far can see
        this.metabolism = 0.5 + Math.random() * 0.5;     // Energy consumption rate
        this.reproductionUrge = 0.3 + Math.random() * 0.4; // How quickly they want to reproduce

        // Color genes (RGB)
        this.colorR = Math.random();
        this.colorG = Math.random();
        this.colorB = Math.random();

        // Behavioral traits
        this.aggression = Math.random();
        this.curiosity = Math.random();
        this.sociability = Math.random();
    }

    mutate(rate = 0.1) {
        const mutateGene = (gene) => {
            if (Math.random() < rate) {
                return Math.max(0, Math.min(1, gene + (Math.random() - 0.5) * 0.3));
            }
            return gene;
        };

        this.size = mutateGene(this.size);
        this.speed = mutateGene(this.speed);
        this.visionRange = mutateGene(this.visionRange);
        this.metabolism = mutateGene(this.metabolism);
        this.reproductionUrge = mutateGene(this.reproductionUrge);
        this.colorR = mutateGene(this.colorR);
        this.colorG = mutateGene(this.colorG);
        this.colorB = mutateGene(this.colorB);
        this.aggression = mutateGene(this.aggression);
        this.curiosity = mutateGene(this.curiosity);
        this.sociability = mutateGene(this.sociability);
    }

    clone() {
        const dna = new DNA();
        Object.assign(dna, this);
        return dna;
    }

    static crossover(parent1, parent2) {
        const child = new DNA();
        const genes = ['size', 'speed', 'visionRange', 'metabolism', 'reproductionUrge',
                      'colorR', 'colorG', 'colorB', 'aggression', 'curiosity', 'sociability'];

        genes.forEach(gene => {
            child[gene] = Math.random() < 0.5 ? parent1[gene] : parent2[gene];
        });

        return child;
    }

    getColor(baseHue) {
        // Mix DNA colors with species base color
        const r = Math.floor((this.colorR * 0.5 + 0.5) * 255);
        const g = Math.floor((this.colorG * 0.5 + 0.5) * 255);
        const b = Math.floor((this.colorB * 0.5 + 0.5) * 255);
        return (r << 16) | (g << 8) | b;
    }

    toString() {
        return Object.entries(this)
            .map(([k, v]) => `${k.charAt(0)}${(v * 99)|0}`)
            .join('');
    }
}

// ============================================================
// CREATURE BASE CLASS
// ============================================================
let creatureIdCounter = 0;

class Creature {
    constructor(x, z, type, generation = 1, parentIds = []) {
        this.id = creatureIdCounter++;
        this.type = type;
        this.x = x;
        this.z = z;
        this.y = 0.5;
        this.rotation = Math.random() * Math.PI * 2;

        this.generation = generation;
        this.parentIds = parentIds;
        this.childrenCount = 0;

        this.energy = 100;
        this.maxEnergy = 100;
        this.age = 0;
        this.alive = true;

        this.dna = new DNA();

        // Neural network inputs: [nearestFoodDist, nearestFoodAngle, nearestThreatDist, nearestThreatAngle, energy, random]
        // Outputs: [moveForward, turnLeft, turnRight, eat/attack]
        this.brain = new NeuralNetwork(8, 12, 4);

        this.fitness = 0;
        this.mesh = null;

        this.velocity = new THREE.Vector3();
        this.targetRotation = this.rotation;
    }

    createMesh() {
        const group = new THREE.Group();

        const size = 0.3 + this.dna.size * 0.4;
        const color = this.getColor();

        // Body
        const bodyGeo = new THREE.SphereGeometry(size, 16, 12);
        const bodyMat = new THREE.MeshStandardMaterial({ color, roughness: 0.7 });
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        body.position.y = size;
        body.castShadow = true;
        group.add(body);

        // Eyes
        const eyeGeo = new THREE.SphereGeometry(size * 0.2, 8, 8);
        const eyeMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const pupilGeo = new THREE.SphereGeometry(size * 0.1, 8, 8);
        const pupilMat = new THREE.MeshBasicMaterial({ color: 0x000000 });

        [-1, 1].forEach(side => {
            const eye = new THREE.Mesh(eyeGeo, eyeMat);
            eye.position.set(size * 0.3 * side, size * 1.1, size * 0.6);
            group.add(eye);

            const pupil = new THREE.Mesh(pupilGeo, pupilMat);
            pupil.position.set(size * 0.3 * side, size * 1.1, size * 0.75);
            group.add(pupil);
        });

        group.position.set(this.x, 0, this.z);
        this.mesh = group;
        return group;
    }

    getColor() {
        return 0x888888;
    }

    update(delta, world) {
        if (!this.alive) return;

        this.age += delta;

        // Energy consumption based on metabolism and activity
        const baseConsumption = 0.5 + this.dna.metabolism * 0.5;
        const movementCost = this.velocity.length() * 0.1;
        this.energy -= (baseConsumption + movementCost) * delta;

        // Die if no energy or too old
        const maxAge = 60 + (1 - this.dna.metabolism) * 40;
        if (this.energy <= 0 || this.age > maxAge) {
            this.die();
            return;
        }

        // Get sensory input
        const inputs = this.getSensoryInput(world);

        // Neural network decision
        const outputs = this.brain.forward(inputs);

        // Apply outputs
        this.applyBehavior(outputs, delta);

        // Update position
        this.x += this.velocity.x * delta;
        this.z += this.velocity.z * delta;

        // Update mesh
        if (this.mesh) {
            this.mesh.position.set(this.x, 0, this.z);
            this.mesh.rotation.y = this.rotation;
        }

        // Fitness accumulation
        this.fitness += delta * (this.energy / this.maxEnergy);
    }

    getSensoryInput(world) {
        // Find nearest food
        const nearestFood = this.findNearest(world, this.getFoodTypes());
        const foodDist = nearestFood ? this.distanceTo(nearestFood) : 100;
        const foodAngle = nearestFood ? this.angleTo(nearestFood) : 0;

        // Find nearest threat
        const nearestThreat = this.findNearest(world, this.getThreatTypes());
        const threatDist = nearestThreat ? this.distanceTo(nearestThreat) : 100;
        const threatAngle = nearestThreat ? this.angleTo(nearestThreat) : 0;

        // Find nearest mate
        const nearestMate = this.findNearestMate(world);
        const mateDist = nearestMate ? this.distanceTo(nearestMate) : 100;
        const mateAngle = nearestMate ? this.angleTo(nearestMate) : 0;

        return [
            foodDist / (this.dna.visionRange * 30),
            foodAngle / Math.PI,
            threatDist / (this.dna.visionRange * 30),
            threatAngle / Math.PI,
            this.energy / this.maxEnergy,
            mateDist / 20,
            mateAngle / Math.PI,
            Math.random() * 0.1 // Noise for exploration
        ];
    }

    findNearest(world, types) {
        let nearest = null;
        let minDist = this.dna.visionRange * 30;

        world.creatures.forEach(c => {
            if (!c.alive || c === this) return;
            if (!types.includes(c.type)) return;

            const dist = this.distanceTo(c);
            if (dist < minDist) {
                minDist = dist;
                nearest = c;
            }
        });

        return nearest;
    }

    findNearestMate(world) {
        let nearest = null;
        let minDist = 15;

        world.creatures.forEach(c => {
            if (!c.alive || c === this) return;
            if (c.type !== this.type) return;
            if (c.energy < 50 || this.energy < 50) return;

            const dist = this.distanceTo(c);
            if (dist < minDist) {
                minDist = dist;
                nearest = c;
            }
        });

        return nearest;
    }

    distanceTo(other) {
        const dx = other.x - this.x;
        const dz = other.z - this.z;
        return Math.sqrt(dx * dx + dz * dz);
    }

    angleTo(other) {
        const dx = other.x - this.x;
        const dz = other.z - this.z;
        const targetAngle = Math.atan2(dx, dz);
        let diff = targetAngle - this.rotation;
        while (diff > Math.PI) diff -= Math.PI * 2;
        while (diff < -Math.PI) diff += Math.PI * 2;
        return diff;
    }

    applyBehavior(outputs, delta) {
        const [moveForward, turnLeft, turnRight, action] = outputs;

        const speed = (1 + this.dna.speed) * 5;
        const turnSpeed = 3;

        // Movement
        const forward = (moveForward + 1) / 2; // Convert from -1,1 to 0,1
        this.velocity.x = Math.sin(this.rotation) * forward * speed;
        this.velocity.z = Math.cos(this.rotation) * forward * speed;

        // Turning
        this.rotation += (turnRight - turnLeft) * turnSpeed * delta;
    }

    getFoodTypes() { return []; }
    getThreatTypes() { return []; }

    reproduce(partner, world) {
        if (this.energy < 60 || partner.energy < 60) return null;

        // Energy cost
        this.energy -= 30;
        partner.energy -= 30;

        // Create offspring
        const childX = (this.x + partner.x) / 2 + (Math.random() - 0.5) * 2;
        const childZ = (this.z + partner.z) / 2 + (Math.random() - 0.5) * 2;

        const child = this.createChild(childX, childZ, partner);

        this.childrenCount++;
        partner.childrenCount++;

        return child;
    }

    createChild(x, z, partner) {
        return null; // Override in subclasses
    }

    die() {
        this.alive = false;
        if (this.mesh && this.mesh.parent) {
            this.mesh.parent.remove(this.mesh);
        }
    }
}

// ============================================================
// PLANT CLASS
// ============================================================
class Plant extends Creature {
    constructor(x, z) {
        super(x, z, 'plant', 1);
        this.energy = 50 + Math.random() * 50;
        this.maxEnergy = 100;
        this.growthRate = 0.5 + Math.random() * 0.5;
    }

    createMesh() {
        const group = new THREE.Group();

        const size = 0.2 + this.dna.size * 0.3;

        // Stem
        const stemGeo = new THREE.CylinderGeometry(0.05, 0.08, size * 2, 8);
        const stemMat = new THREE.MeshStandardMaterial({ color: 0x228822 });
        const stem = new THREE.Mesh(stemGeo, stemMat);
        stem.position.y = size;
        group.add(stem);

        // Leaves/top
        const leafGeo = new THREE.SphereGeometry(size * 0.8, 8, 8);
        const leafMat = new THREE.MeshStandardMaterial({
            color: new THREE.Color().setHSL(0.3 + this.dna.colorG * 0.1, 0.8, 0.4)
        });
        const leaf = new THREE.Mesh(leafGeo, leafMat);
        leaf.position.y = size * 2;
        leaf.castShadow = true;
        group.add(leaf);

        group.position.set(this.x, 0, this.z);
        this.mesh = group;
        return group;
    }

    getColor() {
        return 0x00ff88;
    }

    update(delta, world) {
        if (!this.alive) return;

        this.age += delta;

        // Photosynthesis - gain energy
        this.energy += this.growthRate * delta * 2;
        this.energy = Math.min(this.energy, this.maxEnergy);

        // Reproduce by spreading seeds
        if (this.energy > 80 && Math.random() < 0.01 * delta) {
            const angle = Math.random() * Math.PI * 2;
            const dist = 3 + Math.random() * 5;
            const childX = this.x + Math.cos(angle) * dist;
            const childZ = this.z + Math.sin(angle) * dist;

            // Check if too many plants nearby
            const nearbyPlants = world.creatures.filter(c =>
                c.type === 'plant' && c.alive && this.distanceTo(c) < 5
            ).length;

            if (nearbyPlants < 4) {
                const child = new Plant(childX, childZ);
                child.energy = 30;
                world.addCreature(child);
                this.energy -= 20;
                this.childrenCount++;
            }
        }

        // Die of old age
        if (this.age > 120) {
            this.die();
        }

        // Update mesh scale based on energy
        if (this.mesh) {
            const scale = 0.5 + (this.energy / this.maxEnergy) * 0.5;
            this.mesh.scale.set(scale, scale, scale);
        }
    }

    getSensoryInput() { return []; }
    applyBehavior() { }
}

// ============================================================
// HERBIVORE CLASS
// ============================================================
class Herbivore extends Creature {
    constructor(x, z, generation = 1, parentIds = []) {
        super(x, z, 'herbivore', generation, parentIds);
        this.reproductionCooldown = 0;
    }

    getColor() {
        const h = 0.55 + this.dna.colorB * 0.1; // Blue-ish
        const s = 0.7;
        const l = 0.5 + this.dna.colorG * 0.2;
        return new THREE.Color().setHSL(h, s, l).getHex();
    }

    getFoodTypes() { return ['plant']; }
    getThreatTypes() { return ['predator']; }

    update(delta, world) {
        super.update(delta, world);
        if (!this.alive) return;

        this.reproductionCooldown -= delta;

        // Eat nearby plants
        const nearbyPlants = world.creatures.filter(c =>
            c.type === 'plant' && c.alive && this.distanceTo(c) < 1
        );

        if (nearbyPlants.length > 0) {
            const plant = nearbyPlants[0];
            const eatAmount = Math.min(plant.energy, 20 * delta);
            this.energy = Math.min(this.maxEnergy, this.energy + eatAmount);
            plant.energy -= eatAmount;
            if (plant.energy <= 0) plant.die();
        }

        // Try to reproduce
        if (this.energy > 70 && this.reproductionCooldown <= 0) {
            const mate = this.findNearestMate(world);
            if (mate && this.distanceTo(mate) < 2) {
                const child = this.reproduce(mate, world);
                if (child) {
                    world.addCreature(child);
                    this.reproductionCooldown = 10;
                    mate.reproductionCooldown = 10;
                }
            }
        }
    }

    createChild(x, z, partner) {
        const child = new Herbivore(x, z, Math.max(this.generation, partner.generation) + 1, [this.id, partner.id]);

        // Inherit DNA
        child.dna = DNA.crossover(this.dna, partner.dna);
        child.dna.mutate(0.15);

        // Inherit brain
        child.brain = NeuralNetwork.crossover(this.brain, partner.brain);
        child.brain.mutate(0.1, 0.3);

        child.energy = 50;
        return child;
    }
}

// ============================================================
// PREDATOR CLASS
// ============================================================
class Predator extends Creature {
    constructor(x, z, generation = 1, parentIds = []) {
        super(x, z, 'predator', generation, parentIds);
        this.reproductionCooldown = 0;
        this.attackCooldown = 0;
    }

    getColor() {
        const h = 0.0 + this.dna.colorR * 0.05; // Red-ish
        const s = 0.8;
        const l = 0.4 + this.dna.colorG * 0.2;
        return new THREE.Color().setHSL(h, s, l).getHex();
    }

    createMesh() {
        const group = new THREE.Group();

        const size = 0.4 + this.dna.size * 0.5;
        const color = this.getColor();

        // Body (more angular/aggressive)
        const bodyGeo = new THREE.ConeGeometry(size, size * 1.5, 6);
        const bodyMat = new THREE.MeshStandardMaterial({ color, roughness: 0.6 });
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        body.rotation.x = Math.PI / 2;
        body.position.y = size;
        body.castShadow = true;
        group.add(body);

        // Eyes (red)
        const eyeGeo = new THREE.SphereGeometry(size * 0.15, 8, 8);
        const eyeMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });

        [-1, 1].forEach(side => {
            const eye = new THREE.Mesh(eyeGeo, eyeMat);
            eye.position.set(size * 0.3 * side, size * 1.1, size * 0.4);
            group.add(eye);
        });

        group.position.set(this.x, 0, this.z);
        this.mesh = group;
        return group;
    }

    getFoodTypes() { return ['herbivore']; }
    getThreatTypes() { return []; }

    update(delta, world) {
        super.update(delta, world);
        if (!this.alive) return;

        this.reproductionCooldown -= delta;
        this.attackCooldown -= delta;

        // Hunt nearby herbivores
        if (this.attackCooldown <= 0) {
            const nearbyPrey = world.creatures.filter(c =>
                c.type === 'herbivore' && c.alive && this.distanceTo(c) < 1.5
            );

            if (nearbyPrey.length > 0) {
                const prey = nearbyPrey[0];
                const damage = 30 + this.dna.aggression * 20;
                prey.energy -= damage;

                if (prey.energy <= 0) {
                    prey.die();
                    this.energy = Math.min(this.maxEnergy, this.energy + 50);
                    this.fitness += 10;
                }

                this.attackCooldown = 1;
            }
        }

        // Try to reproduce
        if (this.energy > 80 && this.reproductionCooldown <= 0) {
            const mate = this.findNearestMate(world);
            if (mate && this.distanceTo(mate) < 2) {
                const child = this.reproduce(mate, world);
                if (child) {
                    world.addCreature(child);
                    this.reproductionCooldown = 15;
                    mate.reproductionCooldown = 15;
                }
            }
        }
    }

    createChild(x, z, partner) {
        const child = new Predator(x, z, Math.max(this.generation, partner.generation) + 1, [this.id, partner.id]);

        child.dna = DNA.crossover(this.dna, partner.dna);
        child.dna.mutate(0.15);

        child.brain = NeuralNetwork.crossover(this.brain, partner.brain);
        child.brain.mutate(0.1, 0.3);

        child.energy = 50;
        return child;
    }
}

// ============================================================
// WORLD / ECOSYSTEM MANAGER
// ============================================================
class World {
    constructor() {
        this.creatures = [];
        this.populationHistory = { plants: [], herbivores: [], predators: [] };
        this.maxHistoryLength = 200;
        this.totalYears = 0;
        this.generation = 1;
        this.historyInterval = 0;
    }

    addCreature(creature) {
        this.creatures.push(creature);
        const mesh = creature.createMesh();
        scene.add(mesh);
    }

    removeCreature(creature) {
        const idx = this.creatures.indexOf(creature);
        if (idx > -1) {
            this.creatures.splice(idx, 1);
        }
        if (creature.mesh && creature.mesh.parent) {
            scene.remove(creature.mesh);
        }
    }

    update(delta) {
        // Update all creatures
        this.creatures.forEach(c => c.update(delta, this));

        // Remove dead creatures
        this.creatures = this.creatures.filter(c => c.alive);

        // Track time
        this.totalYears += delta / 10; // 10 seconds = 1 year

        // Track population history
        this.historyInterval += delta;
        if (this.historyInterval > 0.5) {
            this.historyInterval = 0;

            const counts = this.getPopulationCounts();
            this.populationHistory.plants.push(counts.plants);
            this.populationHistory.herbivores.push(counts.herbivores);
            this.populationHistory.predators.push(counts.predators);

            // Trim history
            Object.values(this.populationHistory).forEach(arr => {
                while (arr.length > this.maxHistoryLength) arr.shift();
            });
        }

        // Update max generation
        this.creatures.forEach(c => {
            if (c.generation > this.generation) this.generation = c.generation;
        });

        // Spawn plants if too few
        const plantCount = this.creatures.filter(c => c.type === 'plant').length;
        if (plantCount < 50 && Math.random() < 0.1) {
            const x = (Math.random() - 0.5) * 100;
            const z = (Math.random() - 0.5) * 100;
            this.addCreature(new Plant(x, z));
        }
    }

    getPopulationCounts() {
        const counts = { plants: 0, herbivores: 0, predators: 0 };
        this.creatures.forEach(c => {
            if (c.type === 'plant') counts.plants++;
            else if (c.type === 'herbivore') counts.herbivores++;
            else if (c.type === 'predator') counts.predators++;
        });
        return counts;
    }

    getAverageFitness() {
        const active = this.creatures.filter(c => c.type !== 'plant' && c.alive);
        if (active.length === 0) return 0;
        return active.reduce((sum, c) => sum + c.fitness, 0) / active.length;
    }

    spawn(type, count = 1) {
        for (let i = 0; i < count; i++) {
            const x = (Math.random() - 0.5) * 80;
            const z = (Math.random() - 0.5) * 80;

            if (type === 'plant') this.addCreature(new Plant(x, z));
            else if (type === 'herbivore') this.addCreature(new Herbivore(x, z));
            else if (type === 'predator') this.addCreature(new Predator(x, z));
        }
    }

    apocalypse() {
        // Kill 80% of all creatures
        const toKill = this.creatures.filter(() => Math.random() < 0.8);
        toKill.forEach(c => c.die());
        this.creatures = this.creatures.filter(c => c.alive);
    }
}

// ============================================================
// THREE.JS SETUP
// ============================================================
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x1a2030);
scene.fog = new THREE.Fog(0x1a2030, 50, 150);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 40, 50);
camera.lookAt(0, 0, 0);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

// Lighting
const ambientLight = new THREE.AmbientLight(0x404060, 0.5);
scene.add(ambientLight);

const sunLight = new THREE.DirectionalLight(0xffffee, 1);
sunLight.position.set(50, 80, 30);
sunLight.castShadow = true;
sunLight.shadow.mapSize.width = 2048;
sunLight.shadow.mapSize.height = 2048;
sunLight.shadow.camera.near = 10;
sunLight.shadow.camera.far = 200;
sunLight.shadow.camera.left = -80;
sunLight.shadow.camera.right = 80;
sunLight.shadow.camera.top = 80;
sunLight.shadow.camera.bottom = -80;
scene.add(sunLight);

// Ground
const groundGeo = new THREE.PlaneGeometry(200, 200, 50, 50);
const groundMat = new THREE.MeshStandardMaterial({
    color: 0x2d4a2d,
    roughness: 0.9,
    metalness: 0
});
const ground = new THREE.Mesh(groundGeo, groundMat);
ground.rotation.x = -Math.PI / 2;
ground.receiveShadow = true;
scene.add(ground);

// Grid helper
const gridHelper = new THREE.GridHelper(200, 40, 0x333333, 0x222222);
gridHelper.position.y = 0.01;
scene.add(gridHelper);

// ============================================================
// CAMERA CONTROLS
// ============================================================
let cameraTarget = new THREE.Vector3(0, 0, 0);
let cameraDistance = 50;
let cameraAngle = 0;
let cameraPitch = 0.8;
let isDragging = false;
let lastMouseX = 0;
let lastMouseY = 0;
let followingCreature = null;

renderer.domElement.addEventListener('mousedown', (e) => {
    if (e.button === 0) {
        // Check for creature click
        const mouse = new THREE.Vector2(
            (e.clientX / window.innerWidth) * 2 - 1,
            -(e.clientY / window.innerHeight) * 2 + 1
        );
        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(mouse, camera);

        const meshes = world.creatures.map(c => c.mesh).filter(m => m);
        const intersects = raycaster.intersectObjects(meshes, true);

        if (intersects.length > 0) {
            const clickedMesh = intersects[0].object.parent;
            const creature = world.creatures.find(c => c.mesh === clickedMesh);
            if (creature) {
                selectCreature(creature);
                return;
            }
        }

        isDragging = true;
    }
    lastMouseX = e.clientX;
    lastMouseY = e.clientY;
});

renderer.domElement.addEventListener('mousemove', (e) => {
    if (isDragging) {
        const dx = e.clientX - lastMouseX;
        const dy = e.clientY - lastMouseY;
        cameraAngle -= dx * 0.01;
        cameraPitch = Math.max(0.2, Math.min(1.4, cameraPitch + dy * 0.01));
    }
    lastMouseX = e.clientX;
    lastMouseY = e.clientY;
});

renderer.domElement.addEventListener('mouseup', () => isDragging = false);
renderer.domElement.addEventListener('wheel', (e) => {
    cameraDistance = Math.max(10, Math.min(150, cameraDistance + e.deltaY * 0.05));
});

// Keyboard controls
const keys = { w: false, a: false, s: false, d: false, space: false, shift: false };
document.addEventListener('keydown', (e) => {
    const key = e.key.toLowerCase();
    if (key in keys) keys[key] = true;
    if (key === ' ') keys.space = true;
    if (e.shiftKey) keys.shift = true;

    // Hotkeys
    if (key === 'p') togglePause();
    if (key === 'f' && selectedCreature) {
        followingCreature = followingCreature === selectedCreature ? null : selectedCreature;
    }
    if (key >= '1' && key <= '5') {
        const speeds = [0.5, 1, 2, 5, 20];
        timeScale = speeds[parseInt(key) - 1];
        updateSpeedDisplay();
    }
});
document.addEventListener('keyup', (e) => {
    const key = e.key.toLowerCase();
    if (key in keys) keys[key] = false;
    if (key === ' ') keys.space = false;
    if (!e.shiftKey) keys.shift = false;
});

function updateCamera(delta) {
    // WASD movement
    const moveSpeed = 30 * delta;
    if (keys.w) cameraTarget.z -= moveSpeed * Math.cos(cameraAngle);
    if (keys.s) cameraTarget.z += moveSpeed * Math.cos(cameraAngle);
    if (keys.a) cameraTarget.x -= moveSpeed * Math.cos(cameraAngle);
    if (keys.d) cameraTarget.x += moveSpeed * Math.cos(cameraAngle);

    // Follow creature
    if (followingCreature && followingCreature.alive) {
        cameraTarget.x = followingCreature.x;
        cameraTarget.z = followingCreature.z;
    }

    // Update camera position
    camera.position.x = cameraTarget.x + Math.sin(cameraAngle) * cameraDistance;
    camera.position.z = cameraTarget.z + Math.cos(cameraAngle) * cameraDistance;
    camera.position.y = cameraDistance * cameraPitch;
    camera.lookAt(cameraTarget);
}

// ============================================================
// SELECTION & UI
// ============================================================
let selectedCreature = null;

function selectCreature(creature) {
    selectedCreature = creature;
    document.getElementById('creature-panel').classList.add('visible');
    updateCreaturePanel();
}

function updateCreaturePanel() {
    if (!selectedCreature || !selectedCreature.alive) {
        document.getElementById('creature-panel').classList.remove('visible');
        selectedCreature = null;
        return;
    }

    const icons = { plant: 'üåø', herbivore: 'üê∞', predator: 'ü¶ä' };
    document.getElementById('creature-icon').textContent = icons[selectedCreature.type] || '?';
    document.getElementById('creature-name').textContent =
        `${selectedCreature.type.charAt(0).toUpperCase() + selectedCreature.type.slice(1)} #${selectedCreature.id}`;
    document.getElementById('creature-energy').textContent = selectedCreature.energy.toFixed(1);
    document.getElementById('creature-age').textContent = selectedCreature.age.toFixed(1) + 's';
    document.getElementById('creature-children').textContent = selectedCreature.childrenCount;
    document.getElementById('creature-gen').textContent = selectedCreature.generation;
    document.getElementById('creature-dna').textContent = 'DNA: ' + selectedCreature.dna.toString();

    // Brain visualization
    if (selectedCreature.brain) {
        const viz = document.getElementById('brain-viz');
        viz.innerHTML = selectedCreature.brain.lastActivations
            .slice(0, 16)
            .map(a => `<div class="neuron ${a > 0.3 ? 'active' : ''}" style="opacity:${0.3 + Math.abs(a) * 0.7}"></div>`)
            .join('');
    }

    // Highlight selected creature
    world.creatures.forEach(c => {
        if (c.mesh) {
            c.mesh.traverse(obj => {
                if (obj.material && obj.material.emissive) {
                    obj.material.emissive.setHex(c === selectedCreature ? 0xffaa00 : 0x000000);
                    obj.material.emissiveIntensity = c === selectedCreature ? 0.3 : 0;
                }
            });
        }
    });
}

// ============================================================
// POPULATION GRAPH
// ============================================================
const graphCanvas = document.getElementById('population-graph');
const graphCtx = graphCanvas.getContext('2d');

function drawPopulationGraph() {
    graphCtx.fillStyle = '#111';
    graphCtx.fillRect(0, 0, 350, 120);

    const history = world.populationHistory;
    const maxVal = Math.max(
        Math.max(...history.plants, 1),
        Math.max(...history.herbivores, 1),
        Math.max(...history.predators, 1)
    );

    const drawLine = (data, color) => {
        if (data.length < 2) return;
        graphCtx.strokeStyle = color;
        graphCtx.lineWidth = 2;
        graphCtx.beginPath();
        data.forEach((val, i) => {
            const x = (i / (world.maxHistoryLength - 1)) * 350;
            const y = 120 - (val / maxVal) * 110;
            if (i === 0) graphCtx.moveTo(x, y);
            else graphCtx.lineTo(x, y);
        });
        graphCtx.stroke();
    };

    drawLine(history.plants, '#00ff88');
    drawLine(history.herbivores, '#00aaff');
    drawLine(history.predators, '#ff4466');
}

// ============================================================
// SIMULATION CONTROLS
// ============================================================
let paused = false;
let timeScale = 1;

function togglePause() {
    paused = !paused;
    document.getElementById('btn-pause').textContent = paused ? '‚ñ∂ Play' : '‚è∏ Pause';
    document.getElementById('btn-pause').classList.toggle('active', paused);
}

function updateSpeedDisplay() {
    document.getElementById('speed-display').textContent = `${timeScale}x Speed`;
}

document.getElementById('btn-pause').addEventListener('click', togglePause);
document.getElementById('btn-speed-down').addEventListener('click', () => {
    const speeds = [0.25, 0.5, 1, 2, 5, 10, 20];
    const idx = speeds.indexOf(timeScale);
    if (idx > 0) timeScale = speeds[idx - 1];
    updateSpeedDisplay();
});
document.getElementById('btn-speed-up').addEventListener('click', () => {
    const speeds = [0.25, 0.5, 1, 2, 5, 10, 20];
    const idx = speeds.indexOf(timeScale);
    if (idx < speeds.length - 1) timeScale = speeds[idx + 1];
    updateSpeedDisplay();
});
document.getElementById('btn-spawn-herb').addEventListener('click', () => world.spawn('herbivore', 5));
document.getElementById('btn-spawn-pred').addEventListener('click', () => world.spawn('predator', 3));
document.getElementById('btn-apocalypse').addEventListener('click', () => world.apocalypse());
document.getElementById('btn-tree').addEventListener('click', () => {
    document.getElementById('family-tree-modal').classList.add('visible');
    drawFamilyTree();
});

function drawFamilyTree() {
    const canvas = document.getElementById('tree-canvas');
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#111';
    ctx.fillRect(0, 0, 800, 500);

    ctx.fillStyle = '#fff';
    ctx.font = '14px sans-serif';
    ctx.fillText('Species divergence visualization', 20, 30);
    ctx.fillText(`Max Generation: ${world.generation}`, 20, 50);
    ctx.fillText('Herbivores shown in blue, Predators in red', 20, 70);

    // Simple generation-based tree
    const generations = {};
    world.creatures.forEach(c => {
        if (!generations[c.generation]) generations[c.generation] = { herbivores: 0, predators: 0 };
        if (c.type === 'herbivore') generations[c.generation].herbivores++;
        if (c.type === 'predator') generations[c.generation].predators++;
    });

    const gens = Object.keys(generations).map(Number).sort((a, b) => a - b);
    gens.forEach((gen, i) => {
        const x = 50 + i * 30;
        const data = generations[gen];

        // Herbivores
        ctx.fillStyle = '#00aaff';
        ctx.fillRect(x, 400 - data.herbivores * 5, 20, data.herbivores * 5);

        // Predators
        ctx.fillStyle = '#ff4466';
        ctx.fillRect(x, 400 - data.herbivores * 5 - data.predators * 5, 20, data.predators * 5);

        // Label
        ctx.fillStyle = '#666';
        ctx.font = '10px sans-serif';
        ctx.fillText(gen, x + 5, 420);
    });

    ctx.fillStyle = '#666';
    ctx.fillText('Generation ‚Üí', 350, 450);
}

// ============================================================
// MAIN LOOP
// ============================================================
const world = new World();

// Initial population
for (let i = 0; i < 80; i++) world.spawn('plant');
for (let i = 0; i < 20; i++) world.spawn('herbivore');
for (let i = 0; i < 5; i++) world.spawn('predator');

let lastTime = performance.now();
let frameCount = 0;
let fpsTime = 0;

function animate() {
    requestAnimationFrame(animate);

    const now = performance.now();
    let delta = Math.min((now - lastTime) / 1000, 0.1);
    lastTime = now;

    // FPS counter
    frameCount++;
    fpsTime += delta;
    if (fpsTime >= 1) {
        document.getElementById('stat-fps').textContent = frameCount;
        frameCount = 0;
        fpsTime = 0;
    }

    // Apply time scale
    if (!paused) {
        const simDelta = delta * timeScale;
        world.update(simDelta);
    }

    updateCamera(delta);
    updateCreaturePanel();

    // Update UI
    const counts = world.getPopulationCounts();
    document.getElementById('stat-plants').textContent = counts.plants;
    document.getElementById('stat-herbivores').textContent = counts.herbivores;
    document.getElementById('stat-predators').textContent = counts.predators;
    document.getElementById('stat-generation').textContent = world.generation;
    document.getElementById('stat-fitness').textContent = world.getAverageFitness().toFixed(1);
    document.getElementById('stat-species').textContent = '2'; // Herbivores + Predators
    document.getElementById('stat-chunks').textContent = world.creatures.length;
    document.getElementById('years-display').textContent = Math.floor(world.totalYears).toLocaleString();

    drawPopulationGraph();

    renderer.render(scene, camera);
}

// Hide loading screen
setTimeout(() => document.getElementById('loading').classList.add('hidden'), 2000);

// Handle resize
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

animate();
    </script>
</body>
</html>
