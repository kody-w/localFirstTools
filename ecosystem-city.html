<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ecosystem City - Urban Evolution Simulation</title>
    <meta name="description" content="Living city ecosystem with evolving creatures, human commuters, neural network brains, and realistic traffic simulation.">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #000; font-family: 'Segoe UI', system-ui, sans-serif; color: white; }

        #loading {
            position: fixed; inset: 0;
            background: linear-gradient(135deg, #0a1628, #1a0a28);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 1000; transition: opacity 0.8s ease;
        }
        #loading.hidden { opacity: 0; pointer-events: none; }
        #loading h1 { font-size: 3em; background: linear-gradient(90deg, #00ff88, #00aaff, #ff00aa); -webkit-background-clip: text; -webkit-text-fill-color: transparent; margin-bottom: 10px; }
        #loading p { color: rgba(255,255,255,0.6); margin-bottom: 30px; }
        .loading-bar { width: 300px; height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; overflow: hidden; }
        .loading-fill { height: 100%; background: linear-gradient(90deg, #00ff88, #00aaff); width: 0%; animation: load 2s ease-out forwards; }
        @keyframes load { to { width: 100%; } }
        @keyframes fadeInOut { 0% { opacity: 0; transform: translate(-50%, -50%) scale(0.9); } 10% { opacity: 1; transform: translate(-50%, -50%) scale(1); } 80% { opacity: 1; } 100% { opacity: 0; } }

        #hud { position: absolute; top: 15px; left: 15px; background: rgba(0,0,0,0.85); padding: 15px 20px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.1); backdrop-filter: blur(10px); min-width: 200px; }
        #hud h2 { font-size: 1.1em; color: #00ff88; margin-bottom: 12px; }
        .stat-group { margin-bottom: 10px; }
        .stat-group-title { font-size: 0.7em; color: rgba(255,255,255,0.4); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 4px; }
        .stat { display: flex; justify-content: space-between; padding: 2px 0; font-size: 0.85em; }
        .stat-value { font-weight: bold; }
        .stat-value.plants { color: #00ff88; }
        .stat-value.herbivores { color: #00aaff; }
        .stat-value.predators { color: #ff4466; }
        .stat-value.humans { color: #ffdd44; }

        #time-panel { position: absolute; top: 15px; right: 15px; background: rgba(0,0,0,0.85); padding: 12px 20px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.1); text-align: center; min-width: 140px; }
        #time-panel .clock { font-size: 2em; font-weight: bold; font-family: 'Courier New', monospace; }
        #time-panel .clock.day { color: #ffdd44; }
        #time-panel .clock.night { color: #6688ff; }
        #time-panel .day-label { font-size: 0.75em; color: rgba(255,255,255,0.5); margin-top: 4px; }
        #traffic-indicator { margin-top: 8px; padding: 4px 8px; border-radius: 8px; font-size: 0.7em; font-weight: bold; }
        #traffic-indicator.low { background: #2a5a2a; color: #88ff88; }
        #traffic-indicator.medium { background: #5a5a2a; color: #ffff88; }
        #traffic-indicator.high { background: #5a2a2a; color: #ff8888; }

        #minimap { position: absolute; bottom: 130px; right: 15px; background: rgba(0,0,0,0.9); border-radius: 8px; border: 2px solid rgba(255,255,255,0.2); overflow: hidden; }
        #minimap canvas { display: block; }
        #minimap-label { position: absolute; top: 4px; left: 6px; font-size: 0.65em; color: rgba(255,255,255,0.5); }

        #graph-panel { position: absolute; bottom: 15px; left: 15px; background: rgba(0,0,0,0.85); padding: 12px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.1); }
        #graph-panel h3 { font-size: 0.8em; color: #00aaff; margin-bottom: 8px; }

        #controls { position: absolute; bottom: 15px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.85); padding: 10px 18px; border-radius: 25px; border: 1px solid rgba(255,255,255,0.1); display: flex; gap: 6px; align-items: center; }
        button { background: linear-gradient(135deg, #333, #222); color: white; border: 1px solid rgba(255,255,255,0.1); padding: 7px 14px; cursor: pointer; border-radius: 12px; font-size: 11px; transition: all 0.2s; min-height: 44px; }
        button:hover { background: linear-gradient(135deg, #444, #333); }
        button:focus { outline: 2px solid #00ff88; outline-offset: 2px; }
        button:focus-visible { outline: 2px solid #00ff88; outline-offset: 2px; }
        button.active { background: linear-gradient(135deg, #00aa66, #008855); }
        button.danger { background: linear-gradient(135deg, #aa3344, #882233); }
        .speed-display { background: rgba(255,255,255,0.1); padding: 7px 12px; border-radius: 12px; font-size: 11px; }
        .sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 0, 0); white-space: nowrap; border: 0; }
        [role="region"]:focus { outline: 2px solid #00aaff; outline-offset: 2px; }
        .btn-text { display: inline; margin-left: 4px; }

        #legend { position: absolute; top: 100px; left: 15px; background: rgba(0,0,0,0.85); padding: 10px 12px; border-radius: 10px; font-size: 0.8em; }
        .legend-item { display: flex; align-items: center; gap: 6px; padding: 3px 0; }
        .legend-dot { width: 10px; height: 10px; border-radius: 50%; }

        #creature-panel { position: absolute; top: 15px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.9); padding: 12px 20px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.15); display: none; min-width: 280px; }
        #creature-panel.visible { display: block; }
        #creature-panel h3 { margin-bottom: 8px; font-size: 1em; }
        .brain-viz { display: flex; gap: 3px; margin-top: 8px; }
        .neuron { width: 6px; height: 6px; border-radius: 50%; background: #333; }
        .neuron.active { background: #00ff88; }

        #instructions { position: absolute; bottom: 65px; left: 15px; font-size: 0.7em; color: rgba(255,255,255,0.4); }
        kbd { background: rgba(255,255,255,0.1); padding: 1px 4px; border-radius: 2px; }

        /* Tooltip for creature hover */
        #hover-tooltip { position: fixed; background: rgba(0,0,0,0.95); padding: 12px 16px; border-radius: 10px; border: 1px solid rgba(255,255,255,0.2); pointer-events: none; z-index: 1000; display: none; min-width: 180px; font-size: 12px; }
        #hover-tooltip.visible { display: block; }
        #hover-tooltip h4 { margin: 0 0 8px 0; color: #00ff88; font-size: 13px; }
        #hover-tooltip .trait-bar { height: 6px; background: rgba(255,255,255,0.1); border-radius: 3px; margin: 4px 0; overflow: hidden; }
        #hover-tooltip .trait-fill { height: 100%; border-radius: 3px; transition: width 0.2s; }

        /* Ecosystem Health Dashboard */
        #health-panel { position: absolute; top: 250px; left: 15px; background: rgba(0,0,0,0.85); padding: 12px 16px; border-radius: 10px; border: 1px solid rgba(255,255,255,0.1); min-width: 180px; }
        #health-panel h3 { font-size: 0.85em; color: #00aaff; margin-bottom: 10px; }
        .health-meter { height: 10px; background: rgba(255,255,255,0.1); border-radius: 5px; overflow: hidden; margin: 6px 0; }
        .health-fill { height: 100%; border-radius: 5px; transition: width 0.5s, background 0.5s; }
        .challenge-prompt { font-size: 0.75em; color: rgba(255,255,255,0.6); margin-top: 10px; padding: 8px; background: rgba(255,255,255,0.05); border-radius: 6px; }

        /* Narrative Event Log */
        #event-log { position: absolute; bottom: 130px; right: 15px; background: rgba(0,0,0,0.85); padding: 12px 16px; border-radius: 10px; border: 1px solid rgba(255,255,255,0.1); width: 240px; max-height: 180px; overflow-y: auto; }
        #event-log h3 { font-size: 0.85em; color: #ffaa00; margin-bottom: 8px; }
        .event-item { font-size: 0.75em; padding: 4px 0; border-bottom: 1px solid rgba(255,255,255,0.05); color: rgba(255,255,255,0.8); }
        .event-item:last-child { border-bottom: none; }
        .event-time { color: rgba(255,255,255,0.4); }
    </style>
</head>
<body>
    <div id="loading">
        <h1>ECOSYSTEM CITY</h1>
        <p>Building city and spawning life...</p>
        <div class="loading-bar"><div class="loading-fill"></div></div>
    </div>

    <div id="hud" role="region" aria-label="Simulation Statistics" tabindex="0">
        <h2>üèôÔ∏è Ecosystem City</h2>
        <div class="stat-group" role="group" aria-label="Population Statistics">
            <div class="stat-group-title">Population</div>
            <div class="stat"><span aria-hidden="true">üåø</span><span> Plants</span><span class="stat-value plants" id="stat-plants" aria-live="polite">0</span></div>
            <div class="stat"><span aria-hidden="true">üê∞</span><span> Herbivores</span><span class="stat-value herbivores" id="stat-herbivores" aria-live="polite">0</span></div>
            <div class="stat"><span aria-hidden="true">ü¶ä</span><span> Predators</span><span class="stat-value predators" id="stat-predators" aria-live="polite">0</span></div>
            <div class="stat"><span aria-hidden="true">üßë</span><span> Humans</span><span class="stat-value humans" id="stat-humans" aria-live="polite">0</span></div>
        </div>
        <div class="stat-group" role="group" aria-label="Traffic Statistics">
            <div class="stat-group-title">Traffic</div>
            <div class="stat"><span>Commuting</span><span class="stat-value" id="stat-commuting" aria-live="polite">0</span></div>
            <div class="stat"><span>At Work</span><span class="stat-value" id="stat-working" aria-live="polite">0</span></div>
            <div class="stat"><span>At Home</span><span class="stat-value" id="stat-home" aria-live="polite">0</span></div>
        </div>
        <div class="stat-group" role="group" aria-label="Evolution Statistics">
            <div class="stat-group-title">Evolution</div>
            <div class="stat"><span>Generation</span><span class="stat-value" id="stat-generation">1</span></div>
            <div class="stat"><span>FPS</span><span class="stat-value" id="stat-fps">60</span></div>
        </div>
    </div>

    <div id="time-panel" role="region" aria-label="Time and Traffic Status" tabindex="0">
        <div class="clock day" id="clock-display" aria-label="Current simulation time">06:00</div>
        <div class="day-label">Day <span id="day-count" aria-live="polite">1</span></div>
        <div id="traffic-indicator" class="low" role="status" aria-live="polite">LOW TRAFFIC</div>
    </div>

    <div id="legend" role="region" aria-label="Map Legend" tabindex="0">
        <div class="legend-item"><div class="legend-dot" style="background:#00ff88" aria-hidden="true"></div><span> Plants (green)</span></div>
        <div class="legend-item"><div class="legend-dot" style="background:#00aaff" aria-hidden="true"></div><span> Herbivores (blue)</span></div>
        <div class="legend-item"><div class="legend-dot" style="background:#ff4466" aria-hidden="true"></div><span> Predators (red)</span></div>
        <div class="legend-item"><div class="legend-dot" style="background:#ffdd44" aria-hidden="true"></div><span> Humans (yellow)</span></div>
        <div class="legend-item"><div class="legend-dot" style="background:#888" aria-hidden="true"></div><span> Buildings (gray)</span></div>
    </div>

    <div id="health-panel" role="region" aria-label="Ecosystem Health">
        <h3>üî¨ Ecosystem Health</h3>
        <div class="stat" style="font-size:0.8em;"><span>Balance</span><span id="health-status">Stable</span></div>
        <div class="health-meter"><div class="health-fill" id="health-fill" style="width:70%;background:#00aa66;"></div></div>
        <div class="stat" style="font-size:0.75em;"><span>Prey/Pred Ratio</span><span id="prey-pred-ratio">3:1</span></div>
        <div class="challenge-prompt" id="challenge-prompt">üî¨ Observe: How do predators affect herbivore populations?</div>
    </div>

    <div id="event-log" role="log" aria-label="Evolution Events" aria-live="polite">
        <h3>üìú Evolution Log</h3>
        <div id="event-list"></div>
    </div>

    <div id="hover-tooltip">
        <h4 id="tooltip-title">Creature</h4>
        <div id="tooltip-content"></div>
    </div>

    <div id="minimap" role="img" aria-label="City minimap showing creature locations">
        <canvas id="minimap-canvas" width="180" height="180" aria-hidden="true"></canvas>
        <div id="minimap-label">CITY MAP</div>
    </div>

    <div id="creature-panel">
        <h3><span id="creature-icon">üê∞</span> <span id="creature-name">Creature</span></h3>
        <div class="stat"><span>Energy</span><span id="creature-energy">100</span></div>
        <div class="stat"><span>Age</span><span id="creature-age">0</span></div>
        <div class="stat"><span>State</span><span id="creature-state">-</span></div>
        <div style="font-size:0.75em;color:rgba(255,255,255,0.5);margin-top:6px;">Neural Activity:</div>
        <div class="brain-viz" id="brain-viz"></div>
    </div>

    <div id="graph-panel" role="region" aria-label="Population History Graph" tabindex="0">
        <h3>Population History</h3>
        <canvas id="population-graph" width="300" height="100" aria-hidden="true"></canvas>
        <p class="sr-only" id="graph-description" aria-live="off">Line graph showing population trends for plants (solid), herbivores (dashed), predators (dotted), and humans (dash-dot).</p>
    </div>

    <div id="controls" role="toolbar" aria-label="Simulation Controls">
        <button id="btn-pause" aria-label="Pause simulation" aria-pressed="false">‚è∏<span class="btn-text">Pause</span></button>
        <button id="btn-speed-down" aria-label="Decrease simulation speed">‚óÄ<span class="btn-text">Slower</span></button>
        <div class="speed-display" id="speed-display" role="status" aria-live="polite" aria-label="Current speed">1x</div>
        <button id="btn-speed-up" aria-label="Increase simulation speed">‚ñ∂<span class="btn-text">Faster</span></button>
        <button id="btn-spawn-human" aria-label="Spawn 10 humans">+<span aria-hidden="true">üßë</span><span class="btn-text">Human</span></button>
        <button id="btn-spawn-herb" aria-label="Spawn 5 herbivores">+<span aria-hidden="true">üê∞</span><span class="btn-text">Herbivore</span></button>
        <button id="btn-spawn-pred" aria-label="Spawn 3 predators">+<span aria-hidden="true">ü¶ä</span><span class="btn-text">Predator</span></button>
        <button id="btn-rush-hour" class="active" aria-label="Toggle rush hour mode" aria-pressed="true">Rush Hour</button>
        <button id="btn-save" aria-label="Save simulation">üíæ<span class="btn-text">Save</span></button>
        <button id="btn-load" aria-label="Load simulation">üìÇ<span class="btn-text">Load</span></button>
    </div>

    <div id="instructions">
        <kbd>WASD</kbd> Move <kbd>Scroll</kbd> Zoom <kbd>Click</kbd> Select <kbd>1-5</kbd> Speed
    </div>

    <div id="debug-panel" style="position:absolute; top:15px; right:200px; background:rgba(0,0,0,0.9); padding:12px 15px; border-radius:10px; border:2px solid #ff6600; font-size:12px; z-index:999;">
        <div style="color:#ff6600; margin-bottom:8px; font-weight:bold;">üîß Align Buildings</div>
        <div style="color:#0f0; font-size:12px;"><kbd style="background:#333;padding:2px 6px;border-radius:3px;">M</kbd> + drag = Move</div>
        <div style="color:#0f0; font-size:12px; margin-bottom:8px;"><kbd style="background:#333;padding:2px 6px;border-radius:3px;">R</kbd> + drag = Rotate</div>
        <div style="color:#fff;">Pos: <span id="offset-display">X:0 Z:0</span></div>
        <div style="color:#fff;">Rot: <span id="rotation-display">0¬∞</span></div>
        <button id="btn-copy-offset" style="margin-top:10px; width:100%; background:#0066ff; border:none; padding:8px; border-radius:6px; color:white; cursor:pointer;">Copy Values</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script>
// ============================================================
// TRAFFIC DATA - Based on real cellphone mobility patterns
// Normalized hourly traffic density (0-1 scale)
// Source pattern: aggregated urban commute data
// ============================================================
const TRAFFIC_DATA = {
    // Hour: [traffic_density, commute_to_work_probability, commute_home_probability]
    0:  [0.05, 0.00, 0.02],  // Midnight - very low
    1:  [0.03, 0.00, 0.01],
    2:  [0.02, 0.00, 0.00],
    3:  [0.02, 0.00, 0.00],
    4:  [0.03, 0.01, 0.00],
    5:  [0.08, 0.05, 0.00],  // Early risers
    6:  [0.25, 0.25, 0.00],  // Morning rush starts
    7:  [0.65, 0.60, 0.00],  // Peak morning
    8:  [0.85, 0.80, 0.00],  // Peak morning rush
    9:  [0.55, 0.30, 0.00],  // Rush ending
    10: [0.30, 0.05, 0.00],
    11: [0.35, 0.02, 0.02],  // Lunch movement
    12: [0.40, 0.02, 0.02],  // Lunch peak
    13: [0.35, 0.02, 0.02],
    14: [0.30, 0.01, 0.01],
    15: [0.35, 0.00, 0.05],  // Early leavers
    16: [0.55, 0.00, 0.30],  // Evening rush starts
    17: [0.90, 0.00, 0.70],  // Peak evening rush
    18: [0.95, 0.00, 0.85],  // Peak evening
    19: [0.60, 0.00, 0.40],  // Rush ending
    20: [0.35, 0.00, 0.15],
    21: [0.25, 0.00, 0.05],
    22: [0.15, 0.00, 0.03],
    23: [0.08, 0.00, 0.02]
};

function getTrafficLevel(hour) {
    const h = Math.floor(hour) % 24;
    return TRAFFIC_DATA[h];
}

// ============================================================
// SPATIAL GRID - O(1) creature lookup instead of O(n¬≤)
// ============================================================
class SpatialGrid {
    constructor(cellSize = 20, worldSize = 200) {
        this.cellSize = cellSize;
        this.worldSize = worldSize;
        this.gridCount = Math.ceil(worldSize / cellSize);
        this.cells = new Map();
    }

    getKey(x, z) {
        const cx = Math.floor((x + this.worldSize / 2) / this.cellSize);
        const cz = Math.floor((z + this.worldSize / 2) / this.cellSize);
        return `${cx},${cz}`;
    }

    add(creature) {
        const key = this.getKey(creature.x, creature.z);
        if (!this.cells.has(key)) this.cells.set(key, new Set());
        this.cells.get(key).add(creature);
        creature._gridKey = key;
    }

    remove(creature) {
        if (creature._gridKey && this.cells.has(creature._gridKey)) {
            this.cells.get(creature._gridKey).delete(creature);
        }
    }

    update(creature) {
        const newKey = this.getKey(creature.x, creature.z);
        if (newKey !== creature._gridKey) {
            this.remove(creature);
            this.add(creature);
        }
    }

    getNearby(x, z, radius = 25) {
        const nearby = [];
        const cellRadius = Math.ceil(radius / this.cellSize);
        const cx = Math.floor((x + this.worldSize / 2) / this.cellSize);
        const cz = Math.floor((z + this.worldSize / 2) / this.cellSize);

        for (let dx = -cellRadius; dx <= cellRadius; dx++) {
            for (let dz = -cellRadius; dz <= cellRadius; dz++) {
                const key = `${cx + dx},${cz + dz}`;
                if (this.cells.has(key)) {
                    nearby.push(...this.cells.get(key));
                }
            }
        }
        return nearby;
    }

    clear() {
        this.cells.clear();
    }
}

// ============================================================
// NEURAL NETWORK
// ============================================================
class NeuralNetwork {
    constructor(inputSize, hiddenSize, outputSize) {
        this.inputSize = inputSize;
        this.hiddenSize = hiddenSize;
        this.outputSize = outputSize;
        this.weightsIH = this.randomMatrix(hiddenSize, inputSize);
        this.weightsHO = this.randomMatrix(outputSize, hiddenSize);
        this.biasH = this.randomArray(hiddenSize);
        this.biasO = this.randomArray(outputSize);
        this.lastActivations = [];
    }
    randomMatrix(rows, cols) { return Array(rows).fill().map(() => Array(cols).fill().map(() => (Math.random() - 0.5) * 2)); }
    randomArray(size) { return Array(size).fill().map(() => (Math.random() - 0.5) * 2); }
    forward(inputs) {
        const hidden = this.biasH.map((bias, i) => {
            let sum = bias;
            for (let j = 0; j < inputs.length; j++) sum += inputs[j] * this.weightsIH[i][j];
            return Math.tanh(sum);
        });
        const outputs = this.biasO.map((bias, i) => {
            let sum = bias;
            for (let j = 0; j < hidden.length; j++) sum += hidden[j] * this.weightsHO[i][j];
            return Math.tanh(sum);
        });
        this.lastActivations = [...hidden, ...outputs];
        return outputs;
    }
    mutate(rate = 0.1) {
        const m = v => Math.random() < rate ? v + (Math.random() - 0.5) : v;
        this.weightsIH = this.weightsIH.map(r => r.map(m));
        this.weightsHO = this.weightsHO.map(r => r.map(m));
        this.biasH = this.biasH.map(m);
        this.biasO = this.biasO.map(m);
    }
    clone() {
        const nn = new NeuralNetwork(this.inputSize, this.hiddenSize, this.outputSize);
        nn.weightsIH = this.weightsIH.map(r => [...r]);
        nn.weightsHO = this.weightsHO.map(r => [...r]);
        nn.biasH = [...this.biasH];
        nn.biasO = [...this.biasO];
        return nn;
    }
    static crossover(p1, p2) {
        const c = p1.clone();
        for (let i = 0; i < c.weightsIH.length; i++)
            for (let j = 0; j < c.weightsIH[i].length; j++)
                if (Math.random() < 0.5) c.weightsIH[i][j] = p2.weightsIH[i][j];
        for (let i = 0; i < c.weightsHO.length; i++)
            for (let j = 0; j < c.weightsHO[i].length; j++)
                if (Math.random() < 0.5) c.weightsHO[i][j] = p2.weightsHO[i][j];
        return c;
    }

    toJSON() {
        return {
            inputSize: this.inputSize,
            hiddenSize: this.hiddenSize,
            outputSize: this.outputSize,
            weightsIH: this.weightsIH,
            weightsHO: this.weightsHO,
            biasH: this.biasH,
            biasO: this.biasO
        };
    }

    static fromJSON(json) {
        const nn = new NeuralNetwork(json.inputSize, json.hiddenSize, json.outputSize);
        nn.weightsIH = json.weightsIH;
        nn.weightsHO = json.weightsHO;
        nn.biasH = json.biasH;
        nn.biasO = json.biasO;
        return nn;
    }
}

// ============================================================
// DNA SYSTEM
// ============================================================
class DNA {
    constructor() {
        this.size = 0.5 + Math.random() * 0.5;
        this.speed = 0.5 + Math.random() * 0.5;
        this.vision = 0.5 + Math.random() * 0.5;
        this.metabolism = 0.5 + Math.random() * 0.5;
        this.colorH = Math.random();
    }
    mutate(rate = 0.15) {
        const m = g => Math.random() < rate ? Math.max(0.1, Math.min(1, g + (Math.random() - 0.5) * 0.3)) : g;
        this.size = m(this.size);
        this.speed = m(this.speed);
        this.vision = m(this.vision);
        this.metabolism = m(this.metabolism);
        this.colorH = m(this.colorH);
    }
    clone() { const d = new DNA(); Object.assign(d, this); return d; }
    static crossover(p1, p2) {
        const c = new DNA();
        ['size','speed','vision','metabolism','colorH'].forEach(g => c[g] = Math.random() < 0.5 ? p1[g] : p2[g]);
        return c;
    }

    toJSON() {
        return { size: this.size, speed: this.speed, vision: this.vision, metabolism: this.metabolism, colorH: this.colorH };
    }

    static fromJSON(json) {
        const d = new DNA();
        Object.assign(d, json);
        return d;
    }
}

// ============================================================
// CREATURE CLASSES
// ============================================================
let creatureId = 0;

class Creature {
    constructor(x, z, type, gen = 1) {
        this.id = creatureId++;
        this.type = type;
        this.x = x; this.z = z; this.y = 0;
        this.rotation = Math.random() * Math.PI * 2;
        this.generation = gen;
        this.energy = 100;
        this.age = 0;
        this.alive = true;
        this.dna = new DNA();
        this.brain = new NeuralNetwork(6, 10, 3);
        this.fitness = 0;
        this.mesh = null;
        this.vx = 0; this.vz = 0;
        this.reproCD = 0;
        this.state = 'idle';
    }

    createMesh(color) {
        const size = 0.3 + this.dna.size * 0.3;
        const geo = new THREE.SphereGeometry(size, 12, 8);
        const mat = new THREE.MeshStandardMaterial({ color, roughness: 0.6 });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.set(this.x, size, this.z);
        mesh.castShadow = true;
        this.mesh = mesh;
        this.meshSize = size;
        return mesh;
    }

    update(delta, world) {
        if (!this.alive) return;
        this.age += delta;
        this.energy -= (0.3 + this.dna.metabolism * 0.3) * delta;
        this.reproCD -= delta;

        if (this.energy <= 0 || this.age > 80) { this.die(); return; }

        const inputs = this.sense(world);
        const [fwd, turn, action] = this.brain.forward(inputs);

        const speed = (1 + this.dna.speed) * 4;
        this.rotation += turn * 3 * delta;
        const move = (fwd + 1) / 2;

        let newX = this.x + Math.sin(this.rotation) * move * speed * delta;
        let newZ = this.z + Math.cos(this.rotation) * move * speed * delta;

        // Collision with buildings
        if (!world.city.isBlocked(newX, newZ)) {
            this.x = newX;
            this.z = newZ;
        } else {
            this.rotation += Math.PI / 2;
        }

        // Keep in bounds
        const bound = 95;
        this.x = Math.max(-bound, Math.min(bound, this.x));
        this.z = Math.max(-bound, Math.min(bound, this.z));

        if (this.mesh) {
            this.mesh.position.set(this.x, this.meshSize, this.z);
            this.mesh.rotation.y = this.rotation;
        }

        this.fitness += delta * (this.energy / 100);
    }

    sense(world) {
        const food = this.findNearest(world, this.foodTypes());
        const threat = this.findNearest(world, this.threatTypes());
        return [
            food ? Math.min(1, this.dist(food) / 20) : 1,
            food ? this.angleTo(food) / Math.PI : 0,
            threat ? Math.min(1, this.dist(threat) / 15) : 1,
            threat ? this.angleTo(threat) / Math.PI : 0,
            this.energy / 100,
            Math.random() * 0.1
        ];
    }

    findNearest(world, types) {
        let nearest = null, minD = this.dna.vision * 25;
        // Use spatial grid for O(1) lookup instead of O(n)
        const nearby = world.spatialGrid.getNearby(this.x, this.z, minD);
        for (const c of nearby) {
            if (!c.alive || c === this || !types.includes(c.type)) continue;
            const d = this.dist(c);
            if (d < minD) { minD = d; nearest = c; }
        }
        return nearest;
    }

    dist(o) { return Math.sqrt((o.x-this.x)**2 + (o.z-this.z)**2); }
    angleTo(o) {
        const a = Math.atan2(o.x-this.x, o.z-this.z);
        let d = a - this.rotation;
        while (d > Math.PI) d -= Math.PI*2;
        while (d < -Math.PI) d += Math.PI*2;
        return d;
    }

    foodTypes() { return []; }
    threatTypes() { return []; }

    reproduce(partner, world) {
        if (this.energy < 55 || partner.energy < 55 || this.reproCD > 0) return null;
        this.energy -= 25; partner.energy -= 25;
        const child = this.createChild((this.x+partner.x)/2, (this.z+partner.z)/2, partner);
        this.reproCD = 8; partner.reproCD = 8;
        return child;
    }

    createChild(x, z, partner) { return null; }
    die() {
        this.alive = false;
        if (this.mesh?.parent) this.mesh.parent.remove(this.mesh);
    }

    toJSON() {
        return {
            type: this.type,
            id: this.id,
            x: this.x, z: this.z, y: this.y,
            rotation: this.rotation,
            generation: this.generation,
            energy: this.energy,
            age: this.age,
            fitness: this.fitness,
            state: this.state,
            reproCD: this.reproCD,
            dna: this.dna.toJSON(),
            brain: this.brain ? this.brain.toJSON() : null
        };
    }
}

class Plant extends Creature {
    constructor(x, z) {
        super(x, z, 'plant', 1);
        this.energy = 50;
        this.state = 'growing';
    }
    createMesh() {
        const g = new THREE.Group();
        const h = 0.3 + this.dna.size * 0.4;
        const stem = new THREE.Mesh(
            new THREE.CylinderGeometry(0.05, 0.08, h, 6),
            new THREE.MeshStandardMaterial({ color: 0x228822 })
        );
        stem.position.y = h/2;
        g.add(stem);
        const leaves = new THREE.Mesh(
            new THREE.SphereGeometry(h * 0.6, 8, 6),
            new THREE.MeshStandardMaterial({ color: 0x33aa44 })
        );
        leaves.position.y = h;
        leaves.castShadow = true;
        g.add(leaves);
        g.position.set(this.x, 0, this.z);
        this.mesh = g;
        this.meshSize = h;
        return g;
    }
    update(delta, world) {
        if (!this.alive) return;
        this.age += delta;
        this.energy = Math.min(100, this.energy + delta * 2);
        if (this.energy > 80 && Math.random() < 0.005 * delta) {
            const nearby = world.creatures.filter(c => c.type === 'plant' && c.alive && this.dist(c) < 4).length;
            if (nearby < 3 && world.city.isInPark(this.x, this.z)) {
                const a = Math.random() * Math.PI * 2;
                const d = 2 + Math.random() * 3;
                const nx = this.x + Math.cos(a) * d;
                const nz = this.z + Math.sin(a) * d;
                if (world.city.isInPark(nx, nz)) {
                    world.addCreature(new Plant(nx, nz));
                    this.energy -= 15;
                }
            }
        }
        if (this.age > 150) this.die();
        if (this.mesh) {
            const s = 0.5 + this.energy / 200;
            this.mesh.scale.set(s, s, s);
        }
    }
    sense() { return []; }
}

class Herbivore extends Creature {
    constructor(x, z, gen = 1) { super(x, z, 'herbivore', gen); this.state = 'foraging'; }
    createMesh() { return super.createMesh(new THREE.Color().setHSL(0.55 + this.dna.colorH * 0.1, 0.7, 0.5).getHex()); }
    foodTypes() { return ['plant']; }
    threatTypes() { return ['predator']; }
    update(delta, world) {
        super.update(delta, world);
        if (!this.alive) return;
        this.state = this.energy < 50 ? 'hungry' : 'foraging';
        // Eat plants
        world.creatures.filter(c => c.type === 'plant' && c.alive && this.dist(c) < 1).forEach(p => {
            const amt = Math.min(p.energy, 15 * delta);
            this.energy = Math.min(100, this.energy + amt);
            p.energy -= amt;
            if (p.energy <= 0) p.die();
        });
        // Reproduce
        if (this.energy > 70 && this.reproCD <= 0) {
            const mate = world.creatures.find(c => c.type === 'herbivore' && c !== this && c.alive && c.energy > 60 && this.dist(c) < 3);
            if (mate) {
                const child = this.reproduce(mate, world);
                if (child) world.addCreature(child);
            }
        }
    }
    createChild(x, z, partner) {
        const c = new Herbivore(x, z, Math.max(this.generation, partner.generation) + 1);
        c.dna = DNA.crossover(this.dna, partner.dna); c.dna.mutate();
        c.brain = NeuralNetwork.crossover(this.brain, partner.brain); c.brain.mutate();
        c.energy = 50;
        return c;
    }
}

class Predator extends Creature {
    constructor(x, z, gen = 1) { super(x, z, 'predator', gen); this.attackCD = 0; this.state = 'hunting'; }
    createMesh() {
        const size = 0.4 + this.dna.size * 0.4;
        const geo = new THREE.ConeGeometry(size, size * 1.5, 6);
        const mat = new THREE.MeshStandardMaterial({ color: new THREE.Color().setHSL(0.0 + this.dna.colorH * 0.05, 0.8, 0.45).getHex() });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.rotation.x = Math.PI / 2;
        const g = new THREE.Group();
        g.add(mesh);
        g.position.set(this.x, size, this.z);
        this.mesh = g;
        this.meshSize = size;
        return g;
    }
    foodTypes() { return ['herbivore']; }
    threatTypes() { return []; }
    update(delta, world) {
        super.update(delta, world);
        if (!this.alive) return;
        this.attackCD -= delta;
        this.state = this.energy < 40 ? 'starving' : 'hunting';
        // Hunt
        if (this.attackCD <= 0) {
            const prey = world.creatures.find(c => c.type === 'herbivore' && c.alive && this.dist(c) < 1.5);
            if (prey) {
                prey.energy -= 40;
                if (prey.energy <= 0) {
                    prey.die();
                    this.energy = Math.min(100, this.energy + 40);
                    this.fitness += 5;
                }
                this.attackCD = 0.8;
            }
        }
        // Reproduce
        if (this.energy > 75 && this.reproCD <= 0) {
            const mate = world.creatures.find(c => c.type === 'predator' && c !== this && c.alive && c.energy > 70 && this.dist(c) < 3);
            if (mate) {
                const child = this.reproduce(mate, world);
                if (child) world.addCreature(child);
            }
        }
    }
    createChild(x, z, partner) {
        const c = new Predator(x, z, Math.max(this.generation, partner.generation) + 1);
        c.dna = DNA.crossover(this.dna, partner.dna); c.dna.mutate();
        c.brain = NeuralNetwork.crossover(this.brain, partner.brain); c.brain.mutate();
        c.energy = 50;
        return c;
    }
}

// ============================================================
// HUMAN CLASS - City Dwellers with Commute Behavior
// ============================================================
class Human extends Creature {
    constructor(x, z, homeBuilding, workBuilding) {
        super(x, z, 'human', 1);
        this.home = homeBuilding;
        this.work = workBuilding;
        this.state = 'home';
        this.energy = 100;
        this.destination = null;
        this.path = [];
        this.pathIndex = 0;
        this.waitTimer = 0;
        this.wakeHour = 6 + Math.random() * 2;      // 6-8 AM
        this.leaveWorkHour = 17 + Math.random() * 2; // 5-7 PM
        this.speed = 3 + Math.random() * 2;
        this.trafficDelay = 0;
    }

    createMesh() {
        const g = new THREE.Group();
        // Body
        const body = new THREE.Mesh(
            new THREE.CapsuleGeometry(0.2, 0.5, 4, 8),
            new THREE.MeshStandardMaterial({ color: 0xffdd44 })
        );
        body.position.y = 0.5;
        g.add(body);
        // Head
        const head = new THREE.Mesh(
            new THREE.SphereGeometry(0.15, 8, 6),
            new THREE.MeshStandardMaterial({ color: 0xffcc99 })
        );
        head.position.y = 0.9;
        g.add(head);
        g.position.set(this.x, 0, this.z);
        g.castShadow = true;
        this.mesh = g;
        this.meshSize = 0.5;
        return g;
    }

    update(delta, world) {
        if (!this.alive) return;
        this.age += delta;

        const hour = world.timeOfDay;
        const [trafficDensity, toWorkProb, toHomeProb] = getTrafficLevel(hour);

        // State machine based on time of day
        if (this.state === 'home') {
            if (hour >= this.wakeHour && hour < this.wakeHour + 0.5 && Math.random() < toWorkProb * delta * 0.5) {
                this.startCommute(this.work, world);
                this.state = 'commuting_to_work';
            }
        } else if (this.state === 'work') {
            if (hour >= this.leaveWorkHour && hour < this.leaveWorkHour + 0.5 && Math.random() < toHomeProb * delta * 0.5) {
                this.startCommute(this.home, world);
                this.state = 'commuting_home';
            }
        } else if (this.state === 'commuting_to_work' || this.state === 'commuting_home') {
            // Apply traffic delay based on congestion
            this.trafficDelay = trafficDensity * 0.8;
            this.moveAlongPath(delta, world);

            if (this.reachedDestination()) {
                this.state = this.state === 'commuting_to_work' ? 'work' : 'home';
                this.path = [];
            }
        }

        // Update mesh position
        if (this.mesh) {
            this.mesh.position.set(this.x, 0, this.z);
            this.mesh.rotation.y = this.rotation;
        }
    }

    startCommute(building, world) {
        this.destination = { x: building.cx, z: building.cz };
        this.path = this.findPath(world);
        this.pathIndex = 0;
    }

    findPath(world) {
        // Simple pathfinding: generate waypoints along roads
        const path = [];
        const startX = this.x, startZ = this.z;
        const endX = this.destination.x, endZ = this.destination.z;

        // Find nearest road intersection to start and end
        const roadGrid = 20; // Block size
        const startRoadX = Math.round(startX / roadGrid) * roadGrid;
        const startRoadZ = Math.round(startZ / roadGrid) * roadGrid;
        const endRoadX = Math.round(endX / roadGrid) * roadGrid;
        const endRoadZ = Math.round(endZ / roadGrid) * roadGrid;

        // Add waypoints along the grid
        path.push({ x: startRoadX, z: startZ });
        path.push({ x: startRoadX, z: startRoadZ });

        // Walk along roads (Manhattan-style)
        let cx = startRoadX, cz = startRoadZ;
        while (Math.abs(cx - endRoadX) > roadGrid || Math.abs(cz - endRoadZ) > roadGrid) {
            if (Math.abs(cx - endRoadX) > Math.abs(cz - endRoadZ)) {
                cx += (endRoadX > cx ? roadGrid : -roadGrid);
            } else {
                cz += (endRoadZ > cz ? roadGrid : -roadGrid);
            }
            path.push({ x: cx, z: cz });
        }

        path.push({ x: endRoadX, z: endZ });
        path.push({ x: endX, z: endZ });

        return path;
    }

    moveAlongPath(delta, world) {
        if (this.path.length === 0 || this.pathIndex >= this.path.length) return;

        const target = this.path[this.pathIndex];
        const dx = target.x - this.x;
        const dz = target.z - this.z;
        const dist = Math.sqrt(dx*dx + dz*dz);

        if (dist < 0.5) {
            this.pathIndex++;
            return;
        }

        // Speed affected by traffic
        const effectiveSpeed = this.speed * (1 - this.trafficDelay);
        const step = effectiveSpeed * delta;

        this.rotation = Math.atan2(dx, dz);
        this.x += (dx / dist) * Math.min(step, dist);
        this.z += (dz / dist) * Math.min(step, dist);
    }

    reachedDestination() {
        if (!this.destination) return true;
        const dx = this.destination.x - this.x;
        const dz = this.destination.z - this.z;
        return Math.sqrt(dx*dx + dz*dz) < 2;
    }

    sense() { return []; }
    foodTypes() { return []; }
    threatTypes() { return ['predator']; }

    toJSON() {
        const base = super.toJSON();
        return {
            ...base,
            homeIdx: this.home ? city.residentialBuildings.indexOf(this.home) : -1,
            workIdx: this.work ? city.commercialBuildings.indexOf(this.work) : -1,
            wakeHour: this.wakeHour,
            leaveWorkHour: this.leaveWorkHour,
            speed: this.speed
        };
    }
}

// ============================================================
// CITY GENERATOR - Fixed alignment
// ============================================================
class City {
    constructor(scene) {
        this.scene = scene;
        this.buildings = [];
        this.parks = [];
        this.roads = [];
        this.residentialBuildings = [];
        this.commercialBuildings = [];
        this.windowMeshes = []; // Store window meshes for night lighting
        this.blockSize = 20;
        this.roadWidth = 4;
        this.gridSize = 10;

        // Content group for buildings/parks - can be moved/rotated
        this.contentGroup = new THREE.Group();
        this.scene.add(this.contentGroup);

        this.generate();
        this.setupAlignControls();
    }

    setupAlignControls() {
        let moveMode = false;
        let rotateMode = false;
        let dragging = false;
        let lastX = 0, lastY = 0;

        // Track M and R keys
        window.addEventListener('keydown', (e) => {
            if (e.key.toLowerCase() === 'm') moveMode = true;
            if (e.key.toLowerCase() === 'r') rotateMode = true;
        });
        window.addEventListener('keyup', (e) => {
            if (e.key.toLowerCase() === 'm') moveMode = false;
            if (e.key.toLowerCase() === 'r') rotateMode = false;
        });

        window.addEventListener('mousedown', (e) => {
            if (moveMode || rotateMode) {
                dragging = true;
                lastX = e.clientX;
                lastY = e.clientY;
                e.preventDefault();
            }
        });

        window.addEventListener('mousemove', (e) => {
            if (!dragging) return;
            const dx = e.clientX - lastX;
            const dy = e.clientY - lastY;

            if (moveMode) {
                this.contentGroup.position.x += dx * 0.15;
                this.contentGroup.position.z += dy * 0.15;
            }
            if (rotateMode) {
                this.contentGroup.rotation.y += dx * 0.005;
            }

            lastX = e.clientX;
            lastY = e.clientY;
            this.updateDisplay();
        });

        window.addEventListener('mouseup', () => dragging = false);

        document.getElementById('btn-copy-offset')?.addEventListener('click', () => {
            const data = {
                x: this.contentGroup.position.x.toFixed(2),
                z: this.contentGroup.position.z.toFixed(2),
                rotationDeg: (this.contentGroup.rotation.y * 180 / Math.PI).toFixed(2)
            };
            const json = JSON.stringify(data, null, 2);
            navigator.clipboard.writeText(json).then(() => alert('Copied!\n' + json));
        });
    }

    updateDisplay() {
        const pos = document.getElementById('offset-display');
        const rot = document.getElementById('rotation-display');
        if (pos) pos.textContent = `X:${this.contentGroup.position.x.toFixed(1)} Z:${this.contentGroup.position.z.toFixed(1)}`;
        if (rot) rot.textContent = `${(this.contentGroup.rotation.y * 180 / Math.PI).toFixed(1)}¬∞`;
    }

    generate() {
        const { blockSize, roadWidth, gridSize } = this;
        const halfGrid = gridSize / 2;

        // Materials
        const roadMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.9 });
        const grassMat = new THREE.MeshStandardMaterial({ color: 0x2d5a2d, roughness: 0.9 });
        const buildingColors = [0x8899aa, 0x667788, 0x556677, 0x445566, 0x778899, 0x99aabb];

        // Create ground
        const groundSize = gridSize * blockSize;
        const groundGeo = new THREE.PlaneGeometry(groundSize, groundSize);
        const ground = new THREE.Mesh(groundGeo, grassMat);
        ground.rotation.x = -Math.PI / 2;
        ground.position.set(0, 0, 0);
        ground.receiveShadow = true;
        this.scene.add(ground);

        // Create city grid - all coordinates relative to center
        for (let gx = -halfGrid; gx < halfGrid; gx++) {
            for (let gz = -halfGrid; gz < halfGrid; gz++) {
                // Block center position
                const blockCenterX = gx * blockSize + blockSize / 2;
                const blockCenterZ = gz * blockSize + blockSize / 2;

                // Road positions (at block edges)
                const roadX = gx * blockSize;
                const roadZ = gz * blockSize;

                // Horizontal road (along X axis, at Z edge of block)
                const roadH = new THREE.Mesh(
                    new THREE.PlaneGeometry(blockSize, roadWidth),
                    roadMat
                );
                roadH.rotation.x = -Math.PI / 2;
                roadH.position.set(blockCenterX, 0.01, roadZ);
                this.scene.add(roadH);

                // Store road data matching visual position exactly
                this.roads.push({
                    x: roadX,
                    z: roadZ - roadWidth / 2,
                    w: blockSize,
                    h: roadWidth,
                    cx: blockCenterX,
                    cz: roadZ
                });

                // Vertical road (along Z axis, at X edge of block)
                const roadV = new THREE.Mesh(
                    new THREE.PlaneGeometry(roadWidth, blockSize),
                    roadMat
                );
                roadV.rotation.x = -Math.PI / 2;
                roadV.position.set(roadX, 0.01, blockCenterZ);
                this.scene.add(roadV);

                this.roads.push({
                    x: roadX - roadWidth / 2,
                    z: gz * blockSize,
                    w: roadWidth,
                    h: blockSize,
                    cx: roadX,
                    cz: blockCenterZ
                });

                // Block content area (inside the roads)
                const contentX = roadX + roadWidth / 2;
                const contentZ = roadZ + roadWidth / 2;
                const contentW = blockSize - roadWidth;
                const contentH = blockSize - roadWidth;

                // Distance from center for building height
                const distFromCenter = Math.sqrt(gx * gx + gz * gz);

                // Decide block type (15% parks, more on edges)
                const isPark = Math.random() < (distFromCenter > 3 ? 0.25 : 0.1);

                if (isPark) {
                    // Park - brighter grass
                    const parkGeo = new THREE.PlaneGeometry(contentW - 2, contentH - 2);
                    const parkMat = new THREE.MeshStandardMaterial({ color: 0x3a8a3a });
                    const park = new THREE.Mesh(parkGeo, parkMat);
                    park.rotation.x = -Math.PI / 2;
                    park.position.set(contentX + contentW / 2, 0.02, contentZ + contentH / 2);
                    this.contentGroup.add(park);

                    // Store park data matching visual position
                    this.parks.push({
                        x: contentX + 1,
                        z: contentZ + 1,
                        w: contentW - 2,
                        h: contentH - 2,
                        cx: contentX + contentW / 2,
                        cz: contentZ + contentH / 2
                    });
                } else {
                    // Buildings
                    const numBuildings = 1 + Math.floor(Math.random() * 2);
                    const isResidential = distFromCenter > 2.5;

                    for (let i = 0; i < numBuildings; i++) {
                        const bWidth = 4 + Math.random() * 5;
                        const bDepth = 4 + Math.random() * 5;
                        const maxHeight = distFromCenter < 2 ? 40 : (distFromCenter < 3 ? 20 : 10);
                        const bHeight = 5 + Math.random() * maxHeight;

                        // Building position within content area
                        const margin = 1;
                        const bx = contentX + margin + Math.random() * (contentW - bWidth - margin * 2);
                        const bz = contentZ + margin + Math.random() * (contentH - bDepth - margin * 2);

                        const buildingGeo = new THREE.BoxGeometry(bWidth, bHeight, bDepth);
                        const buildingMat = new THREE.MeshStandardMaterial({
                            color: buildingColors[Math.floor(Math.random() * buildingColors.length)],
                            roughness: 0.7
                        });
                        const building = new THREE.Mesh(buildingGeo, buildingMat);

                        // Position building - center of geometry
                        const buildingCenterX = bx + bWidth / 2;
                        const buildingCenterZ = bz + bDepth / 2;
                        building.position.set(buildingCenterX, bHeight / 2, buildingCenterZ);
                        building.castShadow = true;
                        building.receiveShadow = true;
                        this.contentGroup.add(building);

                        // Add windows
                        this.addWindows(building, bWidth, bDepth, bHeight, isResidential);

                        // Store building data matching visual position
                        const buildingData = {
                            x: bx,
                            z: bz,
                            w: bWidth,
                            h: bDepth,
                            height: bHeight,
                            cx: buildingCenterX,
                            cz: buildingCenterZ,
                            isResidential
                        };

                        this.buildings.push(buildingData);
                        if (isResidential) {
                            this.residentialBuildings.push(buildingData);
                        } else {
                            this.commercialBuildings.push(buildingData);
                        }
                    }
                }
            }
        }

        // Add road markings at intersections
        this.addRoadMarkings();
    }

    addWindows(building, w, d, h, isResidential = false) {
        const windowSize = 0.6;
        const spacing = 2;

        for (let y = 2; y < h - 1; y += spacing) {
            // Front and back faces
            for (let x = -w / 2 + 1; x < w / 2 - 0.5; x += spacing) {
                if (Math.random() > 0.25) {
                    const windowMat = new THREE.MeshBasicMaterial({ color: 0xffffcc });
                    const win = new THREE.Mesh(
                        new THREE.PlaneGeometry(windowSize, windowSize * 1.3),
                        windowMat
                    );
                    win.position.set(x, y - h / 2, d / 2 + 0.01);
                    building.add(win);
                    this.windowMeshes.push({ mesh: win, isResidential, baseColor: 0xffffcc });

                    const winBackMat = new THREE.MeshBasicMaterial({ color: 0xffffcc });
                    const winBack = new THREE.Mesh(
                        new THREE.PlaneGeometry(windowSize, windowSize * 1.3),
                        winBackMat
                    );
                    winBack.position.set(x, y - h / 2, -d / 2 - 0.01);
                    winBack.rotation.y = Math.PI;
                    building.add(winBack);
                    this.windowMeshes.push({ mesh: winBack, isResidential, baseColor: 0xffffcc });
                }
            }
            // Side faces
            for (let z = -d / 2 + 1; z < d / 2 - 0.5; z += spacing) {
                if (Math.random() > 0.25) {
                    const windowMat = new THREE.MeshBasicMaterial({ color: 0xffffcc });
                    const win = new THREE.Mesh(
                        new THREE.PlaneGeometry(windowSize, windowSize * 1.3),
                        windowMat
                    );
                    win.rotation.y = Math.PI / 2;
                    win.position.set(w / 2 + 0.01, y - h / 2, z);
                    building.add(win);
                    this.windowMeshes.push({ mesh: win, isResidential, baseColor: 0xffffcc });

                    const winLeftMat = new THREE.MeshBasicMaterial({ color: 0xffffcc });
                    const winLeft = new THREE.Mesh(
                        new THREE.PlaneGeometry(windowSize, windowSize * 1.3),
                        winLeftMat
                    );
                    winLeft.position.set(-w / 2 - 0.01, y - h / 2, z);
                    winLeft.rotation.y = -Math.PI / 2;
                    building.add(winLeft);
                    this.windowMeshes.push({ mesh: winLeft, isResidential, baseColor: 0xffffcc });
                }
            }
        }
    }

    updateWindowLighting(timeOfDay) {
        const hour = timeOfDay;
        const isNight = hour < 6 || hour >= 20;
        const isEvening = hour >= 18 && hour < 20;
        const isMorning = hour >= 5 && hour < 7;

        // Calculate window brightness (brighter at night)
        let brightness = 0.3; // Daytime dim
        if (isNight) brightness = 1.0;
        else if (isEvening || isMorning) brightness = 0.6;

        this.windowMeshes.forEach(w => {
            // Random flicker for lived-in feel
            const flicker = 0.9 + Math.random() * 0.2;

            // Residential: warm yellow-orange at night
            // Commercial: cool blue-white at night
            if (isNight || isEvening || isMorning) {
                if (w.isResidential) {
                    w.mesh.material.color.setHex(0xffcc66); // Warm
                } else {
                    w.mesh.material.color.setHex(0xccddff); // Cool
                }
                const finalBrightness = brightness * flicker;
                w.mesh.material.color.multiplyScalar(finalBrightness);
            } else {
                // Daytime: subtle reflection
                w.mesh.material.color.setHex(0xaabbcc);
            }
        });
    }

    addRoadMarkings() {
        const markingMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const { blockSize, gridSize } = this;
        const halfGrid = gridSize / 2;

        // Add dashed center lines on roads
        for (let g = -halfGrid; g < halfGrid; g++) {
            const roadPos = g * blockSize;

            // Horizontal dashes
            for (let x = -halfGrid * blockSize; x < halfGrid * blockSize; x += 3) {
                const dash = new THREE.Mesh(
                    new THREE.PlaneGeometry(1.5, 0.15),
                    markingMat
                );
                dash.rotation.x = -Math.PI / 2;
                dash.position.set(x + blockSize / 2, 0.02, roadPos);
                this.scene.add(dash);
            }

            // Vertical dashes
            for (let z = -halfGrid * blockSize; z < halfGrid * blockSize; z += 3) {
                const dash = new THREE.Mesh(
                    new THREE.PlaneGeometry(0.15, 1.5),
                    markingMat
                );
                dash.rotation.x = -Math.PI / 2;
                dash.position.set(roadPos, 0.02, z + blockSize / 2);
                this.scene.add(dash);
            }
        }
    }

    isBlocked(x, z, radius = 0.5) {
        for (const b of this.buildings) {
            if (x > b.x - radius && x < b.x + b.w + radius &&
                z > b.z - radius && z < b.z + b.h + radius) {
                return true;
            }
        }
        return false;
    }

    isOnRoad(x, z) {
        for (const r of this.roads) {
            if (x >= r.x && x <= r.x + r.w && z >= r.z && z <= r.z + r.h) {
                return true;
            }
        }
        return false;
    }

    isInPark(x, z) {
        for (const p of this.parks) {
            if (x > p.x && x < p.x + p.w && z > p.z && z < p.z + p.h) {
                return true;
            }
        }
        return false;
    }

    getRandomParkPosition() {
        if (this.parks.length === 0) return { x: 0, z: 0 };
        const park = this.parks[Math.floor(Math.random() * this.parks.length)];
        return {
            x: park.x + Math.random() * park.w,
            z: park.z + Math.random() * park.h
        };
    }

    getRandomResidential() {
        if (this.residentialBuildings.length === 0) return this.buildings[0];
        return this.residentialBuildings[Math.floor(Math.random() * this.residentialBuildings.length)];
    }

    getRandomCommercial() {
        if (this.commercialBuildings.length === 0) return this.buildings[0];
        return this.commercialBuildings[Math.floor(Math.random() * this.commercialBuildings.length)];
    }
}

// ============================================================
// WORLD MANAGER
// ============================================================
class World {
    constructor(city) {
        this.city = city;
        this.creatures = [];
        this.spatialGrid = new SpatialGrid(20, 200); // 20-unit cells, 200-unit world
        this.history = { plants: [], herbivores: [], predators: [], humans: [] };
        this.totalYears = 0;
        this.generation = 1;
        this.historyTimer = 0;
        this.timeOfDay = 6; // Start at 6 AM
        this.dayCount = 1;
        this.hourSpeed = 0.5; // Hours per real second at 1x speed
        this.events = [];
        this.lastGenMilestone = 1;
        this.challenges = [
            "üî¨ Observe: How do predators affect herbivore populations?",
            "üåø Experiment: What happens if plants can't spread?",
            "üß¨ Study: Which DNA traits help herbivores survive?",
            "üèôÔ∏è Watch: How does rush hour affect human movement?",
            "ü¶ä Predict: Will predators or herbivores go extinct first?",
            "‚è∞ Track: How long until a new generation emerges?",
            "üìä Compare: Morning vs evening traffic patterns"
        ];
        this.currentChallenge = 0;
    }

    addCreature(c) {
        this.creatures.push(c);
        this.spatialGrid.add(c);
        scene.add(c.createMesh());
    }

    update(delta) {
        // Update time of day
        this.timeOfDay += delta * this.hourSpeed;
        if (this.timeOfDay >= 24) {
            this.timeOfDay -= 24;
            this.dayCount++;
        }

        // Update lighting based on time
        this.updateLighting();

        // Update all creatures and maintain spatial grid
        this.creatures.forEach(c => {
            c.update(delta, this);
            if (c.alive) {
                this.spatialGrid.update(c);
            } else {
                this.spatialGrid.remove(c);
            }
        });
        this.creatures = this.creatures.filter(c => c.alive);
        this.totalYears += delta / 10;

        // Track history
        this.historyTimer += delta;
        if (this.historyTimer > 0.5) {
            this.historyTimer = 0;
            const counts = this.getCounts();
            this.history.plants.push(counts.plants);
            this.history.herbivores.push(counts.herbivores);
            this.history.predators.push(counts.predators);
            this.history.humans.push(counts.humans);
            const maxLen = 150;
            if (this.history.plants.length > maxLen) {
                this.history.plants.shift();
                this.history.herbivores.shift();
                this.history.predators.shift();
                this.history.humans.shift();
            }
        }

        this.creatures.forEach(c => { if (c.generation > this.generation) this.generation = c.generation; });

        // Check for narrative milestones every few seconds
        if (this.historyTimer < 0.1) this.checkMilestones();

        // Spawn plants in parks
        const plantCount = this.creatures.filter(c => c.type === 'plant').length;
        if (plantCount < 60 && Math.random() < 0.05) {
            const pos = this.city.getRandomParkPosition();
            this.addCreature(new Plant(pos.x, pos.z));
        }
    }

    updateLighting() {
        const hour = this.timeOfDay;
        let intensity, ambientIntensity, skyColor;

        if (hour >= 6 && hour < 8) { // Sunrise
            const t = (hour - 6) / 2;
            intensity = 0.3 + t * 0.9;
            ambientIntensity = 0.3 + t * 0.3;
            skyColor = new THREE.Color().lerpColors(new THREE.Color(0x1a2535), new THREE.Color(0x87ceeb), t);
        } else if (hour >= 8 && hour < 18) { // Day
            intensity = 1.2;
            ambientIntensity = 0.6;
            skyColor = new THREE.Color(0x87ceeb);
        } else if (hour >= 18 && hour < 20) { // Sunset
            const t = (hour - 18) / 2;
            intensity = 1.2 - t * 0.9;
            ambientIntensity = 0.6 - t * 0.3;
            skyColor = new THREE.Color().lerpColors(new THREE.Color(0xff7744), new THREE.Color(0x1a2535), t);
        } else { // Night
            intensity = 0.2;
            ambientIntensity = 0.2;
            skyColor = new THREE.Color(0x0a1020);
        }

        sun.intensity = intensity;
        ambientLight.intensity = ambientIntensity;
        scene.background = skyColor;
        scene.fog.color = skyColor;
    }

    getCounts() {
        const c = { plants: 0, herbivores: 0, predators: 0, humans: 0 };
        this.creatures.forEach(cr => {
            if (cr.type + 's' in c) c[cr.type + 's']++;
        });
        return c;
    }

    getHumanStats() {
        const stats = { commuting: 0, working: 0, home: 0 };
        this.creatures.forEach(c => {
            if (c.type !== 'human') return;
            if (c.state === 'commuting_to_work' || c.state === 'commuting_home') stats.commuting++;
            else if (c.state === 'work') stats.working++;
            else stats.home++;
        });
        return stats;
    }

    getAvgFitness() {
        const active = this.creatures.filter(c => c.type !== 'plant' && c.type !== 'human');
        return active.length ? active.reduce((s, c) => s + c.fitness, 0) / active.length : 0;
    }

    spawn(type, n = 1) {
        for (let i = 0; i < n; i++) {
            let x, z, attempts = 0;
            do {
                x = (Math.random() - 0.5) * 180;
                z = (Math.random() - 0.5) * 180;
                attempts++;
            } while (this.city.isBlocked(x, z) && attempts < 20);

            if (type === 'plant') {
                const pos = this.city.getRandomParkPosition();
                this.addCreature(new Plant(pos.x, pos.z));
            } else if (type === 'herbivore') {
                this.addCreature(new Herbivore(x, z));
            } else if (type === 'predator') {
                this.addCreature(new Predator(x, z));
            } else if (type === 'human') {
                const home = this.city.getRandomResidential();
                const work = this.city.getRandomCommercial();
                this.addCreature(new Human(home.cx, home.cz, home, work));
            }
        }
    }

    apocalypse() {
        this.creatures.filter(() => Math.random() < 0.75).forEach(c => c.die());
        this.creatures = this.creatures.filter(c => c.alive);
        this.logEvent("üåã Catastrophic event! Many creatures perished.", "danger");
    }

    // ============================================================
    // NARRATIVE EVENT SYSTEM
    // ============================================================
    logEvent(message, type = 'info') {
        const event = {
            time: `Day ${this.dayCount}`,
            message,
            type,
            timestamp: Date.now()
        };
        this.events.unshift(event);
        if (this.events.length > 20) this.events.pop();
        this.updateEventLog();
    }

    updateEventLog() {
        const list = document.getElementById('event-list');
        if (!list) return;
        list.innerHTML = this.events.slice(0, 8).map(e =>
            `<div class="event-item"><span class="event-time">${e.time}</span> ${e.message}</div>`
        ).join('');
    }

    checkMilestones() {
        const counts = this.getCounts();

        // Generation milestones
        if (this.generation >= this.lastGenMilestone + 5) {
            this.lastGenMilestone = this.generation;
            this.logEvent(`üß¨ Generation ${this.generation} reached!`, 'evolution');
            this.currentChallenge = (this.currentChallenge + 1) % this.challenges.length;
        }

        // Population events
        if (counts.herbivores === 0 && this.history.herbivores.length > 5 && this.history.herbivores[this.history.herbivores.length - 5] > 0) {
            this.logEvent("‚ö†Ô∏è Herbivores extinct! Predators will starve.", "danger");
        }
        if (counts.predators === 0 && this.history.predators.length > 5 && this.history.predators[this.history.predators.length - 5] > 0) {
            this.logEvent("ü¶ä Predators extinct! Herbivores may overpopulate.", "warning");
        }
        if (counts.herbivores > 50) {
            this.logEvent("üê∞ Herbivore population boom!", "success");
        }
    }

    getEcosystemHealth() {
        const counts = this.getCounts();
        const totalAnimals = counts.herbivores + counts.predators;
        if (totalAnimals === 0) return { score: 0, status: 'Extinct', color: '#aa3344' };

        const ratio = counts.herbivores / Math.max(1, counts.predators);
        const plantCoverage = counts.plants / 60; // 60 is target

        // Ideal ratio is 3-5 herbivores per predator
        let balanceScore = 0;
        if (ratio >= 2 && ratio <= 8) balanceScore = 100;
        else if (ratio < 2) balanceScore = ratio * 50;
        else balanceScore = Math.max(0, 100 - (ratio - 8) * 10);

        const plantScore = Math.min(100, plantCoverage * 100);
        const diversityScore = (counts.herbivores > 0 && counts.predators > 0) ? 100 : 50;

        const overall = (balanceScore * 0.4 + plantScore * 0.3 + diversityScore * 0.3);

        let status, color;
        if (overall > 70) { status = 'Thriving'; color = '#00aa66'; }
        else if (overall > 50) { status = 'Stable'; color = '#88aa00'; }
        else if (overall > 30) { status = 'Stressed'; color = '#aa8800'; }
        else { status = 'Critical'; color = '#aa3344'; }

        return { score: overall, status, color, ratio: ratio.toFixed(1) };
    }

    // ============================================================
    // SAVE/LOAD SYSTEM v1.0
    // ============================================================
    toJSON() {
        return {
            version: '1.0',
            timestamp: Date.now(),
            timeOfDay: this.timeOfDay,
            dayCount: this.dayCount,
            generation: this.generation,
            totalYears: this.totalYears,
            history: this.history,
            creatures: this.creatures.filter(c => c.alive).map(c => c.toJSON())
        };
    }

    save() {
        try {
            const data = JSON.stringify(this.toJSON());
            localStorage.setItem('ecosystemCity_save', data);
            this.showNotification('Simulation saved successfully!', 'success');
            return true;
        } catch (e) {
            console.error('Save failed:', e);
            this.showNotification('Save failed: ' + e.message, 'error');
            // Fallback: offer download
            this.exportAsFile();
            return false;
        }
    }

    load() {
        try {
            const data = localStorage.getItem('ecosystemCity_save');
            if (!data) {
                this.showNotification('No saved simulation found', 'warning');
                return false;
            }
            const parsed = JSON.parse(data);
            return this.restoreFromJSON(parsed);
        } catch (e) {
            console.error('Load failed:', e);
            this.showNotification('Load failed: ' + e.message, 'error');
            return false;
        }
    }

    restoreFromJSON(json) {
        if (!json.version || !json.creatures) {
            this.showNotification('Invalid save file format', 'error');
            return false;
        }

        // Clear existing creatures
        this.creatures.forEach(c => c.die());
        this.creatures = [];
        this.spatialGrid.clear();

        // Restore world state
        this.timeOfDay = json.timeOfDay || 6;
        this.dayCount = json.dayCount || 1;
        this.generation = json.generation || 1;
        this.totalYears = json.totalYears || 0;
        this.history = json.history || { plants: [], herbivores: [], predators: [], humans: [] };

        // Restore creatures
        let restored = 0;
        for (const cData of json.creatures) {
            try {
                const creature = this.createCreatureFromJSON(cData);
                if (creature) {
                    this.addCreature(creature);
                    restored++;
                }
            } catch (e) {
                console.warn('Failed to restore creature:', e);
            }
        }

        this.showNotification(`Loaded ${restored} creatures from save`, 'success');
        return true;
    }

    createCreatureFromJSON(data) {
        let creature;
        switch (data.type) {
            case 'plant':
                creature = new Plant(data.x, data.z);
                break;
            case 'herbivore':
                creature = new Herbivore(data.x, data.z, data.generation);
                break;
            case 'predator':
                creature = new Predator(data.x, data.z, data.generation);
                break;
            case 'human':
                const home = city.residentialBuildings[data.homeIdx] || city.getRandomResidential();
                const work = city.commercialBuildings[data.workIdx] || city.getRandomCommercial();
                creature = new Human(data.x, data.z, home, work);
                creature.wakeHour = data.wakeHour;
                creature.leaveWorkHour = data.leaveWorkHour;
                creature.speed = data.speed;
                break;
            default:
                return null;
        }

        // Restore common properties
        creature.id = data.id;
        creature.rotation = data.rotation;
        creature.energy = data.energy;
        creature.age = data.age;
        creature.fitness = data.fitness;
        creature.state = data.state;
        creature.reproCD = data.reproCD || 0;

        if (data.dna) creature.dna = DNA.fromJSON(data.dna);
        if (data.brain) creature.brain = NeuralNetwork.fromJSON(data.brain);

        return creature;
    }

    exportAsFile() {
        try {
            const data = JSON.stringify(this.toJSON(), null, 2);
            const blob = new Blob([data], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `ecosystem-city-save-${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);
            this.showNotification('Save exported as file', 'success');
        } catch (e) {
            this.showNotification('Export failed: ' + e.message, 'error');
        }
    }

    importFromFile() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        input.onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const json = JSON.parse(event.target.result);
                    this.restoreFromJSON(json);
                } catch (err) {
                    this.showNotification('Invalid JSON file', 'error');
                }
            };
            reader.readAsText(file);
        };
        input.click();
    }

    showNotification(message, type = 'info') {
        // Remove existing notification
        const existing = document.getElementById('notification');
        if (existing) existing.remove();

        const colors = { success: '#00aa66', error: '#aa3344', warning: '#aa8833', info: '#0066aa' };
        const div = document.createElement('div');
        div.id = 'notification';
        div.style.cssText = `
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: ${colors[type]}; color: white; padding: 15px 25px;
            border-radius: 10px; font-size: 14px; z-index: 10000;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5); animation: fadeInOut 2.5s ease;
        `;
        div.textContent = message;
        div.setAttribute('role', 'alert');
        div.setAttribute('aria-live', 'assertive');
        document.body.appendChild(div);
        setTimeout(() => div.remove(), 2500);
    }
}

// ============================================================
// PARTICLE TRAIL SYSTEM
// ============================================================
class ParticleTrailSystem {
    constructor(scene, maxParticles = 500) {
        this.scene = scene;
        this.maxParticles = maxParticles;
        this.particles = [];

        // Create particle geometry
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(maxParticles * 3);
        const colors = new Float32Array(maxParticles * 3);
        const sizes = new Float32Array(maxParticles);

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

        const material = new THREE.PointsMaterial({
            size: 0.3,
            vertexColors: true,
            transparent: true,
            opacity: 0.7,
            blending: THREE.AdditiveBlending,
            sizeAttenuation: true
        });

        this.mesh = new THREE.Points(geometry, material);
        this.scene.add(this.mesh);
    }

    emit(x, y, z, color, life = 1.0) {
        if (this.particles.length >= this.maxParticles) {
            this.particles.shift();
        }
        this.particles.push({ x, y, z, color, life, maxLife: life });
    }

    update(delta) {
        const positions = this.mesh.geometry.attributes.position.array;
        const colors = this.mesh.geometry.attributes.color.array;
        const sizes = this.mesh.geometry.attributes.size.array;

        // Update existing particles
        for (let i = this.particles.length - 1; i >= 0; i--) {
            this.particles[i].life -= delta;
            if (this.particles[i].life <= 0) {
                this.particles.splice(i, 1);
            }
        }

        // Update buffer
        for (let i = 0; i < this.maxParticles; i++) {
            if (i < this.particles.length) {
                const p = this.particles[i];
                const idx = i * 3;
                positions[idx] = p.x;
                positions[idx + 1] = p.y;
                positions[idx + 2] = p.z;
                const alpha = p.life / p.maxLife;
                colors[idx] = p.color.r * alpha;
                colors[idx + 1] = p.color.g * alpha;
                colors[idx + 2] = p.color.b * alpha;
                sizes[i] = 0.3 * alpha;
            } else {
                const idx = i * 3;
                positions[idx] = 0;
                positions[idx + 1] = -1000;
                positions[idx + 2] = 0;
                sizes[i] = 0;
            }
        }

        this.mesh.geometry.attributes.position.needsUpdate = true;
        this.mesh.geometry.attributes.color.needsUpdate = true;
        this.mesh.geometry.attributes.size.needsUpdate = true;
    }
}

// ============================================================
// THREE.JS SETUP
// ============================================================
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);
scene.fog = new THREE.Fog(0x87ceeb, 80, 250);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 60, 80);
camera.lookAt(0, 0, 0);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

// Lighting
const ambientLight = new THREE.AmbientLight(0x404050, 0.6);
scene.add(ambientLight);

const sun = new THREE.DirectionalLight(0xffeedd, 1.2);
sun.position.set(80, 100, 40);
sun.castShadow = true;
sun.shadow.mapSize.width = 2048;
sun.shadow.mapSize.height = 2048;
sun.shadow.camera.near = 10;
sun.shadow.camera.far = 300;
sun.shadow.camera.left = -100;
sun.shadow.camera.right = 100;
sun.shadow.camera.top = 100;
sun.shadow.camera.bottom = -100;
scene.add(sun);

// Camera controls
let camTarget = new THREE.Vector3(0, 0, 0);
let camDist = 80, camAngle = 0, camPitch = 0.7;
let dragging = false, lastMX = 0, lastMY = 0;
let selectedCreature = null;

renderer.domElement.addEventListener('mousedown', e => {
    if (e.button === 0) {
        const mouse = new THREE.Vector2((e.clientX / window.innerWidth) * 2 - 1, -(e.clientY / window.innerHeight) * 2 + 1);
        const ray = new THREE.Raycaster();
        ray.setFromCamera(mouse, camera);
        const meshes = world.creatures.map(c => c.mesh).filter(m => m);
        const hits = ray.intersectObjects(meshes, true);
        if (hits.length) {
            let hitMesh = hits[0].object;
            while (hitMesh.parent && hitMesh.parent !== scene) hitMesh = hitMesh.parent;
            selectedCreature = world.creatures.find(c => c.mesh === hitMesh);
            if (selectedCreature) {
                document.getElementById('creature-panel').classList.add('visible');
                return;
            }
        }
        dragging = true;
    }
    lastMX = e.clientX; lastMY = e.clientY;
});
renderer.domElement.addEventListener('mousemove', e => {
    if (dragging) {
        camAngle -= (e.clientX - lastMX) * 0.01;
        camPitch = Math.max(0.2, Math.min(1.4, camPitch + (e.clientY - lastMY) * 0.01));
    }
    lastMX = e.clientX; lastMY = e.clientY;
});
renderer.domElement.addEventListener('mouseup', () => dragging = false);
renderer.domElement.addEventListener('wheel', e => camDist = Math.max(20, Math.min(200, camDist + e.deltaY * 0.1)));

// Hover tooltip for creatures
const tooltip = document.getElementById('hover-tooltip');
const tooltipTitle = document.getElementById('tooltip-title');
const tooltipContent = document.getElementById('tooltip-content');
let hoveredCreature = null;

renderer.domElement.addEventListener('mousemove', e => {
    if (dragging) {
        tooltip.classList.remove('visible');
        return;
    }

    const mouse = new THREE.Vector2(
        (e.clientX / window.innerWidth) * 2 - 1,
        -(e.clientY / window.innerHeight) * 2 + 1
    );
    const ray = new THREE.Raycaster();
    ray.setFromCamera(mouse, camera);
    const meshes = world.creatures.filter(c => c.alive && c.mesh).map(c => c.mesh);
    const hits = ray.intersectObjects(meshes, true);

    if (hits.length > 0) {
        let hitMesh = hits[0].object;
        while (hitMesh.parent && hitMesh.parent !== scene) hitMesh = hitMesh.parent;
        hoveredCreature = world.creatures.find(c => c.mesh === hitMesh);

        if (hoveredCreature) {
            tooltip.classList.add('visible');
            tooltip.style.left = (e.clientX + 15) + 'px';
            tooltip.style.top = (e.clientY + 15) + 'px';

            const icons = { plant: 'üåø', herbivore: 'üê∞', predator: 'ü¶ä', human: 'üßë' };
            tooltipTitle.textContent = `${icons[hoveredCreature.type]} ${hoveredCreature.type.charAt(0).toUpperCase() + hoveredCreature.type.slice(1)} #${hoveredCreature.id}`;

            let content = '';
            if (hoveredCreature.type !== 'plant' && hoveredCreature.type !== 'human') {
                content += `<div style="margin-bottom:6px;">Gen ${hoveredCreature.generation} | ${hoveredCreature.state}</div>`;
                content += `<div>Energy: <div class="trait-bar"><div class="trait-fill" style="width:${hoveredCreature.energy}%;background:#00ff88;"></div></div></div>`;
                if (hoveredCreature.dna) {
                    content += `<div>Speed: <div class="trait-bar"><div class="trait-fill" style="width:${hoveredCreature.dna.speed * 100}%;background:#00aaff;"></div></div></div>`;
                    content += `<div>Vision: <div class="trait-bar"><div class="trait-fill" style="width:${hoveredCreature.dna.vision * 100}%;background:#ffaa00;"></div></div></div>`;
                    content += `<div>Size: <div class="trait-bar"><div class="trait-fill" style="width:${hoveredCreature.dna.size * 100}%;background:#ff4466;"></div></div></div>`;
                }
            } else if (hoveredCreature.type === 'human') {
                content += `<div>State: ${hoveredCreature.state}</div>`;
                content += `<div>Wake: ${hoveredCreature.wakeHour?.toFixed(1) || '?'}h</div>`;
                content += `<div>Leave work: ${hoveredCreature.leaveWorkHour?.toFixed(1) || '?'}h</div>`;
            } else {
                content += `<div>Age: ${hoveredCreature.age?.toFixed(1) || 0}s</div>`;
                content += `<div>Energy: ${hoveredCreature.energy?.toFixed(0) || 0}</div>`;
            }
            tooltipContent.innerHTML = content;
        }
    } else {
        tooltip.classList.remove('visible');
        hoveredCreature = null;
    }
});

const keys = { w: false, a: false, s: false, d: false };
document.addEventListener('keydown', e => {
    if (e.key.toLowerCase() in keys) keys[e.key.toLowerCase()] = true;
    if (e.key === 'p') togglePause();
    if (e.key >= '1' && e.key <= '5') { timeScale = [0.5, 1, 2, 5, 20][+e.key - 1]; updateSpeed(); }
    if (e.key === 'Escape') {
        selectedCreature = null;
        document.getElementById('creature-panel').classList.remove('visible');
    }
});
document.addEventListener('keyup', e => { if (e.key.toLowerCase() in keys) keys[e.key.toLowerCase()] = false; });

function updateCamera(dt) {
    const sp = 40 * dt;
    if (keys.w) camTarget.z -= sp;
    if (keys.s) camTarget.z += sp;
    if (keys.a) camTarget.x -= sp;
    if (keys.d) camTarget.x += sp;
    camera.position.x = camTarget.x + Math.sin(camAngle) * camDist;
    camera.position.z = camTarget.z + Math.cos(camAngle) * camDist;
    camera.position.y = camDist * camPitch;
    camera.lookAt(camTarget);
}

// ============================================================
// MINIMAP
// ============================================================
const minimapCanvas = document.getElementById('minimap-canvas');
const minimapCtx = minimapCanvas.getContext('2d');

function drawMinimap() {
    const w = minimapCanvas.width;
    const h = minimapCanvas.height;
    const scale = w / 200; // Map 200 world units to canvas size
    const offsetX = w / 2;
    const offsetZ = h / 2;

    // Background
    minimapCtx.fillStyle = '#1a2a1a';
    minimapCtx.fillRect(0, 0, w, h);

    // Draw roads
    minimapCtx.fillStyle = '#444';
    city.roads.forEach(r => {
        minimapCtx.fillRect(
            offsetX + r.x * scale,
            offsetZ + r.z * scale,
            r.w * scale,
            r.h * scale
        );
    });

    // Draw parks
    minimapCtx.fillStyle = '#3a6a3a';
    city.parks.forEach(p => {
        minimapCtx.fillRect(
            offsetX + p.x * scale,
            offsetZ + p.z * scale,
            p.w * scale,
            p.h * scale
        );
    });

    // Draw buildings
    minimapCtx.fillStyle = '#666';
    city.buildings.forEach(b => {
        minimapCtx.fillRect(
            offsetX + b.x * scale,
            offsetZ + b.z * scale,
            b.w * scale,
            b.h * scale
        );
    });

    // Draw creatures
    world.creatures.forEach(c => {
        if (!c.alive) return;
        const cx = offsetX + c.x * scale;
        const cz = offsetZ + c.z * scale;

        if (c.type === 'plant') minimapCtx.fillStyle = '#00ff88';
        else if (c.type === 'herbivore') minimapCtx.fillStyle = '#00aaff';
        else if (c.type === 'predator') minimapCtx.fillStyle = '#ff4466';
        else if (c.type === 'human') {
            if (c.state === 'commuting_to_work' || c.state === 'commuting_home') {
                minimapCtx.fillStyle = '#ffaa00';
            } else {
                minimapCtx.fillStyle = '#ffdd44';
            }
        }

        minimapCtx.beginPath();
        minimapCtx.arc(cx, cz, c.type === 'human' ? 2 : 1.5, 0, Math.PI * 2);
        minimapCtx.fill();
    });

    // Draw camera view indicator
    minimapCtx.strokeStyle = 'rgba(255,255,255,0.5)';
    minimapCtx.lineWidth = 1;
    minimapCtx.beginPath();
    const camX = offsetX + camTarget.x * scale;
    const camZ = offsetZ + camTarget.z * scale;
    minimapCtx.arc(camX, camZ, 15, 0, Math.PI * 2);
    minimapCtx.stroke();
}

// ============================================================
// UI & CONTROLS
// ============================================================
let paused = false, timeScale = 1;
function togglePause() {
    paused = !paused;
    const btn = document.getElementById('btn-pause');
    btn.innerHTML = paused ? '‚ñ∂<span class="btn-text">Play</span>' : '‚è∏<span class="btn-text">Pause</span>';
    btn.setAttribute('aria-pressed', paused ? 'true' : 'false');
    btn.setAttribute('aria-label', paused ? 'Resume simulation' : 'Pause simulation');
}
function updateSpeed() { document.getElementById('speed-display').textContent = timeScale + 'x'; }

document.getElementById('btn-pause').onclick = togglePause;
document.getElementById('btn-speed-down').onclick = () => { timeScale = Math.max(0.25, timeScale / 2); updateSpeed(); };
document.getElementById('btn-speed-up').onclick = () => { timeScale = Math.min(20, timeScale * 2); updateSpeed(); };
document.getElementById('btn-spawn-human').onclick = () => world.spawn('human', 10);
document.getElementById('btn-spawn-herb').onclick = () => world.spawn('herbivore', 5);
document.getElementById('btn-spawn-pred').onclick = () => world.spawn('predator', 3);
document.getElementById('btn-rush-hour').onclick = function() {
    this.classList.toggle('active');
    const isActive = this.classList.contains('active');
    this.setAttribute('aria-pressed', isActive ? 'true' : 'false');
    world.timeOfDay = isActive ? 7.5 : 12;
};
document.getElementById('btn-save').onclick = () => world.save();
document.getElementById('btn-load').onclick = () => {
    if (confirm('Load saved simulation? Current simulation will be replaced.')) {
        world.load();
    }
};

const graphCanvas = document.getElementById('population-graph');
const graphCtx = graphCanvas.getContext('2d');

function drawGraph() {
    graphCtx.fillStyle = '#111';
    graphCtx.fillRect(0, 0, 300, 100);
    const hist = world.history;
    const max = Math.max(1, ...hist.plants, ...hist.herbivores, ...hist.predators, ...hist.humans);

    const draw = (data, color, dashPattern = []) => {
        if (data.length < 2) return;
        graphCtx.strokeStyle = color;
        graphCtx.lineWidth = 2;
        graphCtx.setLineDash(dashPattern);
        graphCtx.beginPath();
        data.forEach((v, i) => {
            const x = (i / 149) * 300;
            const y = 100 - (v / max) * 95;
            i === 0 ? graphCtx.moveTo(x, y) : graphCtx.lineTo(x, y);
        });
        graphCtx.stroke();
        graphCtx.setLineDash([]);
    };

    // Different dash patterns for accessibility (color-blind safe)
    draw(hist.plants, '#00ff88', []);           // Solid line
    draw(hist.herbivores, '#00aaff', [5, 3]);   // Dashed line
    draw(hist.predators, '#ff4466', [2, 2]);    // Dotted line
    draw(hist.humans, '#ffdd44', [8, 3, 2, 3]); // Dash-dot line
}

function updateUI() {
    const c = world.getCounts();
    const hs = world.getHumanStats();

    document.getElementById('stat-plants').textContent = c.plants;
    document.getElementById('stat-herbivores').textContent = c.herbivores;
    document.getElementById('stat-predators').textContent = c.predators;
    document.getElementById('stat-humans').textContent = c.humans;
    document.getElementById('stat-commuting').textContent = hs.commuting;
    document.getElementById('stat-working').textContent = hs.working;
    document.getElementById('stat-home').textContent = hs.home;
    document.getElementById('stat-generation').textContent = world.generation;

    // Update ecosystem health dashboard
    const health = world.getEcosystemHealth();
    document.getElementById('health-status').textContent = health.status;
    document.getElementById('health-status').style.color = health.color;
    document.getElementById('health-fill').style.width = health.score + '%';
    document.getElementById('health-fill').style.background = health.color;
    document.getElementById('prey-pred-ratio').textContent = health.ratio + ':1';
    document.getElementById('challenge-prompt').textContent = world.challenges[world.currentChallenge];

    // Clock display
    const hour = Math.floor(world.timeOfDay);
    const minute = Math.floor((world.timeOfDay % 1) * 60);
    const clockEl = document.getElementById('clock-display');
    clockEl.textContent = `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
    clockEl.className = 'clock ' + (hour >= 6 && hour < 20 ? 'day' : 'night');
    document.getElementById('day-count').textContent = world.dayCount;

    // Traffic indicator
    const [traffic] = getTrafficLevel(hour);
    const trafficEl = document.getElementById('traffic-indicator');
    if (traffic > 0.6) {
        trafficEl.textContent = 'HEAVY TRAFFIC';
        trafficEl.className = 'high';
    } else if (traffic > 0.3) {
        trafficEl.textContent = 'MODERATE TRAFFIC';
        trafficEl.className = 'medium';
    } else {
        trafficEl.textContent = 'LOW TRAFFIC';
        trafficEl.className = 'low';
    }

    // Selected creature panel
    if (selectedCreature && !selectedCreature.alive) {
        selectedCreature = null;
        document.getElementById('creature-panel').classList.remove('visible');
    }
    if (selectedCreature) {
        const icons = { plant: 'üåø', herbivore: 'üê∞', predator: 'ü¶ä', human: 'üßë' };
        document.getElementById('creature-icon').textContent = icons[selectedCreature.type];
        document.getElementById('creature-name').textContent = `${selectedCreature.type} #${selectedCreature.id}`;
        document.getElementById('creature-energy').textContent = selectedCreature.energy.toFixed(1);
        document.getElementById('creature-age').textContent = selectedCreature.age.toFixed(1) + 's';
        document.getElementById('creature-state').textContent = selectedCreature.state || '-';

        if (selectedCreature.brain) {
            document.getElementById('brain-viz').innerHTML = selectedCreature.brain.lastActivations.slice(0, 12)
                .map(a => `<div class="neuron ${Math.abs(a) > 0.3 ? 'active' : ''}"></div>`).join('');
        } else {
            document.getElementById('brain-viz').innerHTML = '<span style="font-size:0.7em;color:#666">No neural network</span>';
        }
    }
}

// ============================================================
// MAIN LOOP
// ============================================================
const city = new City(scene);
const world = new World(city);
const particles = new ParticleTrailSystem(scene, 500);

// Predator and Human trail colors
const predatorTrailColor = new THREE.Color(0xff4466);
const humanTrailColor = new THREE.Color(0xffaa00);

// Initial spawn
for (let i = 0; i < 50; i++) world.spawn('plant');
for (let i = 0; i < 15; i++) world.spawn('herbivore');
for (let i = 0; i < 5; i++) world.spawn('predator');
for (let i = 0; i < 80; i++) world.spawn('human');

// Log initial event
world.logEvent("üåÖ A new day begins in Ecosystem City!", "info");

let lastTime = performance.now(), frames = 0, fpsTime = 0;
let trailTimer = 0;

function animate() {
    requestAnimationFrame(animate);
    const now = performance.now();
    const dt = Math.min((now - lastTime) / 1000, 0.1);
    lastTime = now;

    frames++; fpsTime += dt;
    if (fpsTime >= 1) { document.getElementById('stat-fps').textContent = frames; frames = 0; fpsTime = 0; }

    if (!paused) {
        world.update(dt * timeScale);

        // Emit particle trails from active creatures
        trailTimer += dt * timeScale;
        if (trailTimer > 0.05) { // Emit every 50ms of sim time
            trailTimer = 0;
            world.creatures.forEach(c => {
                if (!c.alive || !c.mesh) return;

                // Predators hunting leave red trails
                if (c.type === 'predator' && c.state === 'hunting') {
                    particles.emit(c.x, 0.3, c.z, predatorTrailColor, 0.8);
                }

                // Commuting humans leave orange trails
                if (c.type === 'human' && (c.state === 'commuting_to_work' || c.state === 'commuting_home')) {
                    particles.emit(c.x, 0.2, c.z, humanTrailColor, 0.5);
                }
            });

            // Update night lighting on windows (not every frame for performance)
            city.updateWindowLighting(world.timeOfDay);
        }

        particles.update(dt * timeScale);
    }

    updateCamera(dt);
    updateUI();
    drawGraph();
    drawMinimap();
    renderer.render(scene, camera);
}

setTimeout(() => document.getElementById('loading').classList.add('hidden'), 1500);
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

animate();
    </script>
</body>
</html>
