<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Vibe Coding Gallery</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #000;
            color: #fff;
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }

        /* Animated background */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 50%, rgba(120, 30, 255, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(255, 30, 120, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 40% 10%, rgba(30, 255, 120, 0.3) 0%, transparent 50%);
            animation: drift 20s ease-in-out infinite;
            z-index: -1;
        }

        @keyframes drift {
            0%, 100% { transform: scale(1) rotate(0deg); }
            33% { transform: scale(1.1) rotate(120deg); }
            66% { transform: scale(0.95) rotate(240deg); }
        }
        
        .header {
            padding: 60px 20px;
            text-align: center;
            position: relative;
            background: linear-gradient(180deg, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0) 100%);
        }

        @media (max-width: 768px) {
            .header {
                padding: 40px 20px;
            }
        }

        .gallery-title {
            font-size: 5em;
            font-weight: 100;
            letter-spacing: 0.2em;
            margin-bottom: 20px;
            text-transform: uppercase;
            position: relative;
            display: inline-block;
        }

        @media (max-width: 768px) {
            .gallery-title {
                font-size: 3em;
                letter-spacing: 0.1em;
            }
        }

        .gallery-title::before {
            content: 'VIBE CODING';
            position: absolute;
            left: 0;
            top: 0;
            background: linear-gradient(45deg, #ff006e, #8338ec, #3a86ff, #06ffa5);
            background-size: 400% 100%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: shimmer 8s ease-in-out infinite;
        }

        @keyframes shimmer {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .gallery-subtitle {
            font-size: 1.5em;
            font-weight: 200;
            color: rgba(255, 255, 255, 0.6);
            letter-spacing: 0.5em;
            text-transform: uppercase;
        }

        @media (max-width: 768px) {
            .gallery-subtitle {
                font-size: 1.2em;
                letter-spacing: 0.3em;
            }
        }

        .gallery-description {
            max-width: 600px;
            margin: 30px auto 0;
            color: rgba(255, 255, 255, 0.5);
            line-height: 1.6;
            font-weight: 300;
        }

        @media (max-width: 768px) {
            .gallery-description {
                margin: 20px auto 0;
                font-size: 0.95em;
            }
        }

        .gallery-modes {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 40px;
            flex-wrap: wrap;
        }

        @media (max-width: 768px) {
            .gallery-modes {
                gap: 15px;
                margin-top: 30px;
            }
        }

        .mode-button {
            padding: 15px 40px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 30px;
            color: white;
            cursor: pointer;
            font-size: 1.1em;
            letter-spacing: 0.1em;
            transition: all 0.3s ease;
            text-transform: uppercase;
            -webkit-appearance: none;
            appearance: none;
            touch-action: manipulation;
        }

        @media (max-width: 768px) {
            .mode-button {
                padding: 12px 30px;
                font-size: 1em;
            }
        }

        .mode-button:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(255, 255, 255, 0.1);
        }

        .mode-button:active {
            transform: scale(0.98);
        }

        .mode-button.vr-mode {
            background: linear-gradient(135deg, #ff006e, #8338ec);
            border: none;
        }

        .mode-button.vr-mode:hover {
            box-shadow: 0 10px 30px rgba(138, 43, 226, 0.5);
        }
        
        .content {
            padding: 40px 20px 80px;
            max-width: 1600px;
            margin: 0 auto;
        }

        .content.hidden {
            display: none;
        }
        
        .loading {
            text-align: center;
            padding: 100px;
            font-size: 1.2em;
            color: rgba(255, 255, 255, 0.4);
            font-weight: 200;
            letter-spacing: 0.1em;
        }

        .loading::after {
            content: '';
            display: block;
            width: 60px;
            height: 1px;
            background: linear-gradient(90deg, transparent, #fff, transparent);
            margin: 30px auto;
            animation: scan 2s linear infinite;
        }

        @keyframes scan {
            0% { transform: translateX(-100px); }
            100% { transform: translateX(100px); }
        }
        
        .error {
            color: #ff006e;
            padding: 30px;
            background: rgba(255, 0, 110, 0.1);
            border-radius: 20px;
            margin: 20px auto;
            border: 1px solid rgba(255, 0, 110, 0.2);
            max-width: 600px;
            text-align: center;
        }
        
        .exhibition-section {
            margin-bottom: 80px;
        }

        .section-title {
            font-size: 3em;
            font-weight: 100;
            text-align: center;
            margin-bottom: 50px;
            letter-spacing: 0.1em;
            position: relative;
            padding-bottom: 20px;
        }

        @media (max-width: 768px) {
            .section-title {
                font-size: 2em;
                margin-bottom: 30px;
            }
        }

        .section-title::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 100px;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.5), transparent);
        }
        
        .artwork-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(400px, 1fr));
            gap: 40px;
        }

        @media (max-width: 768px) {
            .artwork-grid {
                grid-template-columns: 1fr;
                gap: 20px;
            }
        }
        
        .artwork-frame {
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 20px;
            transition: all 0.5s ease;
            position: relative;
            overflow: hidden;
            cursor: pointer;
            min-height: 300px;
            display: flex;
            flex-direction: column;
        }

        .artwork-frame::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle at var(--mouse-x, 50%) var(--mouse-y, 50%), rgba(255, 255, 255, 0.1), transparent 40%);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        @media (hover: hover) {
            .artwork-frame:hover::before {
                opacity: 1;
            }

            .artwork-frame:hover {
                transform: translateY(-10px);
                background: rgba(255, 255, 255, 0.05);
                border-color: rgba(255, 255, 255, 0.2);
                box-shadow: 
                    0 20px 40px rgba(0, 0, 0, 0.5),
                    0 0 60px rgba(138, 43, 226, 0.2);
            }
        }

        @media (hover: none) {
            .artwork-frame:active {
                transform: scale(0.98);
                background: rgba(255, 255, 255, 0.05);
            }
        }
        
        .artwork-preview {
            width: 100%;
            height: 200px;
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.1), rgba(0, 255, 255, 0.1));
            border-radius: 10px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 4em;
            position: relative;
            overflow: hidden;
        }

        .artwork-preview::after {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent 30%, rgba(255, 255, 255, 0.1) 50%, transparent 70%);
            animation: shine 3s ease-in-out infinite;
        }

        @keyframes shine {
            0% { transform: rotate(0deg) translateX(-100%); }
            100% { transform: rotate(0deg) translateX(100%); }
        }
        
        .artwork-title {
            font-size: 1.8em;
            font-weight: 200;
            margin-bottom: 10px;
            letter-spacing: 0.05em;
        }

        @media (max-width: 768px) {
            .artwork-title {
                font-size: 1.5em;
            }
        }
        
        .artwork-description {
            color: rgba(255, 255, 255, 0.6);
            line-height: 1.6;
            margin-bottom: 20px;
            flex-grow: 1;
            font-weight: 300;
        }
        
        .artwork-actions {
            display: flex;
            gap: 15px;
            margin-top: auto;
        }

        .view-button, .download-button {
            flex: 1;
            padding: 15px 25px;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 400;
            letter-spacing: 0.05em;
            transition: all 0.3s ease;
            text-transform: uppercase;
            -webkit-appearance: none;
            appearance: none;
            touch-action: manipulation;
        }

        .view-button {
            background: linear-gradient(135deg, #ff006e, #8338ec);
            color: white;
        }

        .view-button:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 30px rgba(138, 43, 226, 0.5);
        }

        .view-button:active {
            transform: scale(0.98);
        }

        .download-button {
            background: transparent;
            color: rgba(255, 255, 255, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .download-button:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .download-button:active {
            transform: scale(0.98);
        }

        /* 3D Gallery Styles */
        #three-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            z-index: 1000;
            touch-action: none;
        }

        #three-container.active {
            display: block;
        }

        .three-ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 1001;
        }

        .back-button {
            padding: 12px 30px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 25px;
            color: white;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s ease;
            -webkit-appearance: none;
            appearance: none;
            touch-action: manipulation;
        }

        .back-button:hover {
            background: rgba(0, 0, 0, 0.9);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .back-button:active {
            transform: scale(0.95);
        }

        .controls-hint {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.8);
            z-index: 1001;
            text-align: center;
        }

        /* Mobile controls UI */
        .mobile-controls {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            z-index: 1001;
            gap: 20px;
        }

        .mobile-controls.show {
            display: flex;
        }

        .joystick-container {
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            position: relative;
            touch-action: none;
        }

        .joystick-handle {
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: none;
        }

        .artwork-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            padding: 25px;
            max-width: 400px;
            display: none;
            z-index: 1002;
            pointer-events: none;
            backdrop-filter: blur(10px);
        }

        @media (max-width: 768px) {
            .artwork-tooltip {
                padding: 20px;
                max-width: 300px;
            }
        }

        .artwork-tooltip.visible {
            display: block;
        }

        .tooltip-title {
            font-size: 1.4em;
            font-weight: 300;
            margin-bottom: 10px;
            color: #fff;
        }

        @media (max-width: 768px) {
            .tooltip-title {
                font-size: 1.2em;
            }
        }

        .tooltip-description {
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.7);
            line-height: 1.5;
            margin-bottom: 10px;
        }

        .tooltip-instruction {
            font-size: 0.85em;
            color: #ff006e;
            text-align: center;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* Custom scrollbar */
        @media (hover: hover) {
            ::-webkit-scrollbar {
                width: 8px;
            }

            ::-webkit-scrollbar-track {
                background: rgba(255, 255, 255, 0.05);
            }

            ::-webkit-scrollbar-thumb {
                background: rgba(255, 255, 255, 0.2);
                border-radius: 4px;
            }

            ::-webkit-scrollbar-thumb:hover {
                background: rgba(255, 255, 255, 0.3);
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1 class="gallery-title">VIBE CODING</h1>
        <div class="gallery-subtitle">Kody's Creative Playground</div>
        <p class="gallery-description">
            Welcome to Kody Wildfeuer's vibe coding showcase - a collection of experimental web art, creative coding projects, and digital explorations.<br>
            These are personal creative experiments that represent the intersection of code and art.<br>
            <span style="font-size: 0.85em; opacity: 0.6;">Note: This is Kody's personal creative content and opinions, unrelated to any employer.</span>
        </p>
        <div class="gallery-modes">
            <button class="mode-button" id="classic-mode">Classic Gallery</button>
            <button class="mode-button vr-mode" id="3d-mode">3D Experience</button>
        </div>
    </div>
    
    <div class="content" id="main-content">
        <div class="loading">Loading gallery...</div>
    </div>

    <div id="three-container">
        <div class="three-ui">
            <button class="back-button" id="back-to-gallery">← Back to Gallery</button>
        </div>
        <div class="controls-hint" id="controls-hint">Use WASD to move, Mouse to look around, Click on artworks to view</div>
        <div class="mobile-controls" id="mobile-controls">
            <div class="joystick-container" id="movement-joystick">
                <div class="joystick-handle" id="movement-handle"></div>
            </div>
        </div>
        <div class="artwork-tooltip" id="artwork-tooltip">
            <h3 class="tooltip-title"></h3>
            <p class="tooltip-description"></p>
            <p class="tooltip-instruction">Click to view in new tab</p>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Target repository
        const REPO_OWNER = 'kody-w';
        const REPO_NAME = 'localFirstTools';
        const BRANCH = 'main';
        
        // Store gallery data globally
        let galleryData = null;
        let threeScene = null;
        
        // Main content container
        const mainContent = document.getElementById('main-content');
        const threeContainer = document.getElementById('three-container');
        
        // Icons for random selection
        const artworkIcons = ['🎨', '✨', '🌟', '💫', '🔮', '🎭', '🌈', '🎪', '🎯', '🎲', '🎸', '🎹'];
        
        // Check if device is mobile
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                        (window.matchMedia && window.matchMedia('(max-width: 768px)').matches);
        
        // Generate random artwork metadata
        function generateArtworkMetadata(file) {
            const filename = file.path.split('/').pop();
            const nameWithoutExt = filename.replace('.html', '').replace('.htm', '');
            const formattedName = nameWithoutExt
                .replace(/[-_]/g, ' ')
                .replace(/\b\w/g, l => l.toUpperCase());
            
            const descriptions = [
                "An experimental dive into the creative possibilities of web technology",
                "Interactive art piece exploring the boundaries between code and creativity",
                "A digital meditation on algorithms, aesthetics, and human expression",
                "Pushing browser limits to create unexpected visual experiences",
                "Real-time generative art that evolves with each interaction",
                "Creative coding experiment blending mathematics and imagination",
                "A playful exploration of what happens when code becomes art",
                "Digital canvas where logic meets creativity in unexpected ways",
                "Vibe coding at its finest - where inspiration meets implementation"
            ];
            
            return {
                title: formattedName,
                description: descriptions[Math.floor(Math.random() * descriptions.length)],
                icon: artworkIcons[Math.floor(Math.random() * artworkIcons.length)],
                tags: generateRandomTags()
            };
        }
        
        // Generate random tags
        function generateRandomTags() {
            const allTags = [
                'interactive', 'generative', 'particles', 'animation', 
                'experimental', '3D', 'audio-reactive', 'kinetic',
                'abstract', 'geometric', 'organic', 'minimal',
                'colorful', 'monochrome', 'dynamic', 'static'
            ];
            
            const numTags = Math.floor(Math.random() * 3) + 2;
            const tags = [];
            
            for (let i = 0; i < numTags; i++) {
                const tag = allTags[Math.floor(Math.random() * allTags.length)];
                if (!tags.includes(tag)) {
                    tags.push(tag);
                }
            }
            
            return tags;
        }
        
        // Track mouse position for interactive effects (desktop only)
        if (!isMobile) {
            document.addEventListener('mousemove', (e) => {
                const frames = document.querySelectorAll('.artwork-frame');
                frames.forEach(frame => {
                    const rect = frame.getBoundingClientRect();
                    const x = ((e.clientX - rect.left) / rect.width) * 100;
                    const y = ((e.clientY - rect.top) / rect.height) * 100;
                    frame.style.setProperty('--mouse-x', `${x}%`);
                    frame.style.setProperty('--mouse-y', `${y}%`);
                });
            });
        }
        
        // Mode switching
        document.getElementById('classic-mode').addEventListener('click', () => {
            threeContainer.classList.remove('active');
            mainContent.classList.remove('hidden');
            if (threeScene) {
                threeScene.cleanup();
                threeScene = null;
            }
        });
        
        document.getElementById('3d-mode').addEventListener('click', () => {
            if (galleryData) {
                mainContent.classList.add('hidden');
                threeContainer.classList.add('active');
                init3DGallery(galleryData);
            }
        });
        
        document.getElementById('back-to-gallery').addEventListener('click', () => {
            document.getElementById('classic-mode').click();
        });
        
        // Fetch GitHub repository files
        async function fetchRepoFiles() {
            try {
                const apiUrl = `https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/git/trees/${BRANCH}?recursive=1`;
                
                const response = await fetch(apiUrl);
                
                if (!response.ok) {
                    throw new Error(`GitHub API error: ${response.status}`);
                }
                
                const data = await response.json();
                
                // Filter for HTML files
                const htmlFiles = data.tree
                    .filter(item => item.type === 'blob' && 
                           (item.path.endsWith('.html') || item.path.endsWith('.htm')))
                    .map(item => ({
                        path: item.path,
                        url: `https://github.com/${REPO_OWNER}/${REPO_NAME}/blob/${BRANCH}/${item.path}`,
                        raw_url: `https://raw.githubusercontent.com/${REPO_OWNER}/${REPO_NAME}/${BRANCH}/${item.path}`
                    }));
                
                // Store gallery data globally
                galleryData = {
                    repo: {
                        owner: REPO_OWNER,
                        name: REPO_NAME,
                        branch: BRANCH,
                        url: `https://github.com/${REPO_OWNER}/${REPO_NAME}`
                    },
                    files: htmlFiles
                };
                
                // Display gallery
                displayGallery(galleryData);
                
            } catch (error) {
                console.error("Error fetching repository:", error);
                mainContent.innerHTML = `
                    <div class="error">
                        <strong>Exhibition Temporarily Closed</strong><br>
                        ${error.message}
                    </div>
                `;
            }
        }
        
        // Display gallery content
        function displayGallery(data) {
            mainContent.innerHTML = '';
            
            // Select random files for featured section
            const featuredCount = Math.min(6, data.files.length);
            const shuffled = [...data.files].sort(() => 0.5 - Math.random());
            const featuredFiles = shuffled.slice(0, featuredCount);
            
            // Create featured section
            if (featuredFiles.length > 0) {
                const exhibitionSection = document.createElement('div');
                exhibitionSection.className = 'exhibition-section';
                
                const sectionTitle = document.createElement('h2');
                sectionTitle.className = 'section-title';
                sectionTitle.textContent = 'Featured Artworks';
                exhibitionSection.appendChild(sectionTitle);
                
                const artworkGrid = document.createElement('div');
                artworkGrid.className = 'artwork-grid';
                
                featuredFiles.forEach(file => {
                    const metadata = generateArtworkMetadata(file);
                    const filename = file.path.split('/').pop();
                    
                    const artworkFrame = document.createElement('div');
                    artworkFrame.className = 'artwork-frame';
                    
                    artworkFrame.innerHTML = `
                        <div class="artwork-preview">
                            ${metadata.icon}
                        </div>
                        <h3 class="artwork-title">${metadata.title}</h3>
                        <p class="artwork-description">${metadata.description}</p>
                        <div class="artwork-actions">
                            <button class="view-button" data-url="${file.raw_url}" data-title="${metadata.title}" data-filename="${filename}">View</button>
                            <button class="download-button" data-url="${file.raw_url}" data-filename="${filename}">Save</button>
                        </div>
                    `;
                    
                    artworkGrid.appendChild(artworkFrame);
                });
                
                exhibitionSection.appendChild(artworkGrid);
                mainContent.appendChild(exhibitionSection);
            }
            
            // Create all works section
            if (data.files.length > 0) {
                const allWorksSection = document.createElement('div');
                allWorksSection.className = 'exhibition-section';
                
                const sectionTitle = document.createElement('h2');
                sectionTitle.className = 'section-title';
                sectionTitle.textContent = 'All Works';
                allWorksSection.appendChild(sectionTitle);
                
                const artworkGrid = document.createElement('div');
                artworkGrid.className = 'artwork-grid';
                
                data.files.forEach(file => {
                    const metadata = generateArtworkMetadata(file);
                    const filename = file.path.split('/').pop();
                    
                    const artworkFrame = document.createElement('div');
                    artworkFrame.className = 'artwork-frame';
                    
                    artworkFrame.innerHTML = `
                        <div class="artwork-preview">
                            ${metadata.icon}
                        </div>
                        <h3 class="artwork-title">${metadata.title}</h3>
                        <p class="artwork-description">${metadata.description}</p>
                        <div class="artwork-actions">
                            <button class="view-button" data-url="${file.raw_url}" data-title="${metadata.title}" data-filename="${filename}">View</button>
                            <button class="download-button" data-url="${file.raw_url}" data-filename="${filename}">Save</button>
                        </div>
                    `;
                    
                    artworkGrid.appendChild(artworkFrame);
                });
                
                allWorksSection.appendChild(artworkGrid);
                mainContent.appendChild(allWorksSection);
            }
            
            // Add event listeners
            addEventListeners();
        }
        
        // Add event listeners for buttons
        function addEventListeners() {
            // Add click listeners to artwork frames for opening in new tab
            const artworkFrames = document.querySelectorAll('.artwork-frame');
            artworkFrames.forEach(frame => {
                frame.addEventListener('click', (e) => {
                    // Don't trigger if clicking on a button
                    if (e.target.tagName !== 'BUTTON') {
                        const viewButton = frame.querySelector('.view-button');
                        if (viewButton) {
                            openInNewTab(viewButton.dataset.url, viewButton.dataset.title);
                        }
                    }
                });
            });
            
            const viewButtons = document.querySelectorAll('.view-button');
            viewButtons.forEach(button => {
                button.addEventListener('click', (e) => {
                    e.stopPropagation();
                    openInNewTab(button.dataset.url, button.dataset.title);
                });
            });
            
            const downloadButtons = document.querySelectorAll('.download-button');
            downloadButtons.forEach(button => {
                button.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    try {
                        await downloadHtmlFile(button.dataset.url, button.dataset.filename);
                    } catch (error) {
                        alert(`Error downloading: ${error.message}`);
                    }
                });
            });
        }
        
        // Open HTML content in new tab
        async function openInNewTab(url, title) {
            try {
                // Always fetch and create blob URL to ensure proper HTML rendering
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`Failed to fetch (${response.status})`);
                }
                
                const htmlContent = await response.text();
                
                // Create blob with HTML content
                const blob = new Blob([htmlContent], { type: 'text/html' });
                const blobUrl = URL.createObjectURL(blob);
                
                if (isMobile) {
                    // For mobile, use location.href to navigate to the blob URL
                    window.location.href = blobUrl;
                } else {
                    // For desktop, open in new tab
                    const newTab = window.open(blobUrl, '_blank');
                    
                    // Clean up blob URL after a delay
                    setTimeout(() => {
                        URL.revokeObjectURL(blobUrl);
                    }, 1000);
                }
                
            } catch (error) {
                console.error('Error opening content:', error);
                // If blob approach fails, try creating a data URL
                try {
                    const response = await fetch(url);
                    const htmlContent = await response.text();
                    const dataUrl = 'data:text/html;charset=utf-8,' + encodeURIComponent(htmlContent);
                    
                    if (isMobile) {
                        window.location.href = dataUrl;
                    } else {
                        window.open(dataUrl, '_blank');
                    }
                } catch (fallbackError) {
                    console.error('Fallback also failed:', fallbackError);
                    alert('Unable to open the content. Please try downloading it instead.');
                }
            }
        }
        
        // Download HTML file
        async function downloadHtmlFile(url, filename) {
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`Failed to fetch (${response.status})`);
                }
                
                const htmlContent = await response.text();
                
                const blob = new Blob([htmlContent], { type: 'text/html' });
                const blobUrl = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = blobUrl;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                
                window.URL.revokeObjectURL(blobUrl);
                document.body.removeChild(a);
            } catch (error) {
                console.error('Error downloading:', error);
                throw error;
            }
        }
        
        // Initialize 3D Gallery
        function init3DGallery(data) {
            if (threeScene) {
                threeScene.cleanup();
            }
            
            threeScene = new MinecraftGallery(data);
            threeScene.init();
        }
        
        // Minecraft-style 3D Gallery Class
        class MinecraftGallery {
            constructor(data) {
                this.data = data;
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.artworks = [];
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                this.moveSpeed = 0.2;
                this.lookSpeed = 0.002;
                
                // Movement state
                this.keys = {
                    w: false,
                    a: false,
                    s: false,
                    d: false
                };
                
                // Camera rotation
                this.rotation = {
                    x: 0,
                    y: 0
                };
                
                // Mobile controls
                this.isMobile = isMobile;
                this.touches = {
                    start: null,
                    current: null,
                    joystick: null
                };
                this.joystickActive = false;
                this.joystickVector = new THREE.Vector2();
                
                this.isPointerLocked = false;
                this.hoveredArtwork = null;
                this.tooltip = document.getElementById('artwork-tooltip');
                this.tooltipTitle = this.tooltip.querySelector('.tooltip-title');
                this.tooltipDescription = this.tooltip.querySelector('.tooltip-description');
            }
            
            init() {
                // Scene setup
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.Fog(0x000000, 10, 100);
                
                // Camera
                this.camera = new THREE.PerspectiveCamera(
                    75, 
                    window.innerWidth / window.innerHeight, 
                    0.1, 
                    1000
                );
                this.camera.position.set(0, 2, 10);
                
                // Renderer
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                threeContainer.appendChild(this.renderer.domElement);
                
                // Lighting
                this.setupLighting();
                
                // Create gallery
                this.createGallery();
                
                // Event listeners
                this.setupEventListeners();
                
                // Update controls hint
                const controlsHint = document.getElementById('controls-hint');
                if (this.isMobile) {
                    controlsHint.textContent = 'Swipe to look around, Use joystick to move, Tap on artworks to view';
                    document.getElementById('mobile-controls').classList.add('show');
                }
                
                // Start animation
                this.animate();
            }
            
            setupLighting() {
                // Ambient light
                const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
                this.scene.add(ambientLight);
                
                // Directional light (sun)
                const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
                dirLight.position.set(10, 20, 10);
                dirLight.castShadow = true;
                dirLight.shadow.camera.near = 0.1;
                dirLight.shadow.camera.far = 50;
                dirLight.shadow.camera.left = -50;
                dirLight.shadow.camera.right = 50;
                dirLight.shadow.camera.top = 50;
                dirLight.shadow.camera.bottom = -50;
                this.scene.add(dirLight);
                
                // Point lights for artwork
                const colors = [0xff00ff, 0x00ffff, 0xffff00];
                colors.forEach((color, i) => {
                    const light = new THREE.PointLight(color, 0.5, 10);
                    light.position.set(i * 10 - 10, 3, 0);
                    this.scene.add(light);
                });
            }
            
            createGallery() {
                // Create floor
                const floorGeometry = new THREE.BoxGeometry(100, 1, 100);
                const floorMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x333333,
                    emissive: 0x111111
                });
                const floor = new THREE.Mesh(floorGeometry, floorMaterial);
                floor.position.y = -0.5;
                floor.receiveShadow = true;
                this.scene.add(floor);
                
                // Create walls
                this.createWalls();
                
                // Create artworks
                this.createArtworks();
                
                // Add some decorative cubes
                this.addDecorations();
            }
            
            createWalls() {
                const wallMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x666666,
                    emissive: 0x222222
                });
                
                // Back wall
                const backWall = new THREE.Mesh(
                    new THREE.BoxGeometry(100, 20, 1),
                    wallMaterial
                );
                backWall.position.set(0, 10, -50);
                backWall.castShadow = true;
                backWall.receiveShadow = true;
                this.scene.add(backWall);
                
                // Side walls
                const leftWall = new THREE.Mesh(
                    new THREE.BoxGeometry(1, 20, 100),
                    wallMaterial
                );
                leftWall.position.set(-50, 10, 0);
                leftWall.castShadow = true;
                leftWall.receiveShadow = true;
                this.scene.add(leftWall);
                
                const rightWall = new THREE.Mesh(
                    new THREE.BoxGeometry(1, 20, 100),
                    wallMaterial
                );
                rightWall.position.set(50, 10, 0);
                rightWall.castShadow = true;
                rightWall.receiveShadow = true;
                this.scene.add(rightWall);
            }
            
            createTextSprite(text, fontSize = 0.5) {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 256;
                
                context.fillStyle = 'rgba(0, 0, 0, 0)';
                context.fillRect(0, 0, canvas.width, canvas.height);
                
                context.font = `${canvas.width * fontSize}px Arial`;
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillStyle = 'white';
                
                // For emoji, we need to handle them differently
                if (text.length <= 2 && /\p{Emoji}/u.test(text)) {
                    context.font = `${canvas.width * fontSize * 0.8}px Arial`;
                }
                
                context.fillText(text, canvas.width / 2, canvas.height / 2);
                
                const texture = new THREE.CanvasTexture(canvas);
                texture.needsUpdate = true;
                
                const spriteMaterial = new THREE.SpriteMaterial({ 
                    map: texture,
                    transparent: true
                });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.scale.set(2, 2, 1);
                
                return sprite;
            }
            
            createArtworks() {
                const files = this.data.files;
                const numArtworks = Math.min(files.length, 20);
                
                for (let i = 0; i < numArtworks; i++) {
                    const file = files[i];
                    const metadata = generateArtworkMetadata(file);
                    
                    // Create artwork group
                    const artworkGroup = new THREE.Group();
                    
                    // Frame
                    const frameGeometry = new THREE.BoxGeometry(4, 3, 0.2);
                    const frameMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0x888888,
                        emissive: 0x444444
                    });
                    const frame = new THREE.Mesh(frameGeometry, frameMaterial);
                    
                    // Canvas (artwork) with random color
                    const canvasGeometry = new THREE.BoxGeometry(3.6, 2.6, 0.1);
                    const hue = Math.random();
                    const canvasMaterial = new THREE.MeshLambertMaterial({ 
                        color: new THREE.Color().setHSL(hue, 0.7, 0.5),
                        emissive: new THREE.Color().setHSL(hue, 0.7, 0.3),
                        emissiveIntensity: 0.5
                    });
                    const canvas = new THREE.Mesh(canvasGeometry, canvasMaterial);
                    canvas.position.z = 0.1;
                    frame.add(canvas);
                    
                    // Add emoji sprite to canvas
                    const emojiSprite = this.createTextSprite(metadata.icon, 0.4);
                    emojiSprite.position.z = 0.2;
                    canvas.add(emojiSprite);
                    
                    // Add title below frame
                    const titleSprite = this.createTextSprite(metadata.title.substring(0, 15) + (metadata.title.length > 15 ? '...' : ''), 0.15);
                    titleSprite.position.y = -2;
                    titleSprite.position.z = 0.5;
                    frame.add(titleSprite);
                    
                    artworkGroup.add(frame);
                    
                    // Position artwork
                    const angle = (i / numArtworks) * Math.PI * 2;
                    const radius = 20;
                    artworkGroup.position.x = Math.cos(angle) * radius;
                    artworkGroup.position.z = Math.sin(angle) * radius;
                    artworkGroup.position.y = 3;
                    artworkGroup.rotation.y = -angle + Math.PI;
                    
                    frame.castShadow = true;
                    frame.receiveShadow = true;
                    
                    // Store data for interaction
                    frame.userData = {
                        url: file.raw_url,
                        title: metadata.title,
                        description: metadata.description,
                        filename: file.path.split('/').pop(),
                        icon: metadata.icon
                    };
                    
                    this.artworks.push(frame);
                    this.scene.add(artworkGroup);
                }
            }
            
            addDecorations() {
                const decorationMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x444444,
                    emissive: 0x222222
                });
                
                // Add some pillars
                for (let i = 0; i < 8; i++) {
                    const pillar = new THREE.Mesh(
                        new THREE.BoxGeometry(2, 10, 2),
                        decorationMaterial
                    );
                    
                    const angle = (i / 8) * Math.PI * 2;
                    pillar.position.x = Math.cos(angle) * 30;
                    pillar.position.z = Math.sin(angle) * 30;
                    pillar.position.y = 5;
                    
                    pillar.castShadow = true;
                    pillar.receiveShadow = true;
                    
                    this.scene.add(pillar);
                }
                
                // Add floating cubes
                for (let i = 0; i < 20; i++) {
                    const size = Math.random() * 0.5 + 0.5;
                    const cube = new THREE.Mesh(
                        new THREE.BoxGeometry(size, size, size),
                        new THREE.MeshLambertMaterial({ 
                            color: new THREE.Color().setHSL(Math.random(), 0.7, 0.5),
                            emissive: new THREE.Color().setHSL(Math.random(), 0.7, 0.3),
                            emissiveIntensity: 0.3
                        })
                    );
                    
                    cube.position.x = (Math.random() - 0.5) * 40;
                    cube.position.y = Math.random() * 10 + 10;
                    cube.position.z = (Math.random() - 0.5) * 40;
                    
                    cube.rotation.x = Math.random() * Math.PI * 2;
                    cube.rotation.y = Math.random() * Math.PI * 2;
                    
                    cube.userData.floatSpeed = Math.random() * 0.02 + 0.01;
                    cube.userData.rotateSpeed = Math.random() * 0.02 + 0.01;
                    
                    cube.castShadow = true;
                    
                    this.scene.add(cube);
                }
            }
            
            setupEventListeners() {
                if (this.isMobile) {
                    this.setupMobileControls();
                } else {
                    this.setupDesktopControls();
                }
                
                // Window resize
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }
            
            setupDesktopControls() {
                // Keyboard controls
                window.addEventListener('keydown', (e) => {
                    if (e.key.toLowerCase() in this.keys) {
                        this.keys[e.key.toLowerCase()] = true;
                    }
                });
                
                window.addEventListener('keyup', (e) => {
                    if (e.key.toLowerCase() in this.keys) {
                        this.keys[e.key.toLowerCase()] = false;
                    }
                });
                
                // Mouse controls
                this.renderer.domElement.addEventListener('click', () => {
                    if (!this.isPointerLocked) {
                        this.renderer.domElement.requestPointerLock();
                    }
                });
                
                document.addEventListener('pointerlockchange', () => {
                    this.isPointerLocked = document.pointerLockElement === this.renderer.domElement;
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (this.isPointerLocked) {
                        this.rotation.y -= e.movementX * this.lookSpeed;
                        this.rotation.x -= e.movementY * this.lookSpeed;
                        this.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.rotation.x));
                    }
                });
                
                // Click on artwork
                this.renderer.domElement.addEventListener('click', (e) => {
                    if (!this.isPointerLocked) return;
                    
                    this.raycaster.setFromCamera(new THREE.Vector2(0, 0), this.camera);
                    const intersects = this.raycaster.intersectObjects(this.artworks, true);
                    
                    if (intersects.length > 0) {
                        const artwork = intersects[0].object.parent || intersects[0].object;
                        if (artwork.userData && artwork.userData.url) {
                            openInNewTab(artwork.userData.url, artwork.userData.title);
                        }
                    }
                });
            }
            
            setupMobileControls() {
                const canvas = this.renderer.domElement;
                
                // Touch start
                canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    this.touches.start = {
                        x: touch.clientX,
                        y: touch.clientY
                    };
                    this.touches.current = {...this.touches.start};
                });
                
                // Touch move - camera rotation
                canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (!this.touches.start) return;
                    
                    const touch = e.touches[0];
                    const deltaX = touch.clientX - this.touches.current.x;
                    const deltaY = touch.clientY - this.touches.current.y;
                    
                    this.rotation.y -= deltaX * this.lookSpeed * 2;
                    this.rotation.x -= deltaY * this.lookSpeed * 2;
                    this.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.rotation.x));
                    
                    this.touches.current = {
                        x: touch.clientX,
                        y: touch.clientY
                    };
                });
                
                // Touch end
                canvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    
                    // Check if it was a tap
                    if (this.touches.start && this.touches.current) {
                        const dx = this.touches.current.x - this.touches.start.x;
                        const dy = this.touches.current.y - this.touches.start.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < 10) {
                            // It's a tap - check for artwork
                            // Convert touch coordinates to normalized device coordinates
                            const rect = canvas.getBoundingClientRect();
                            const x = ((this.touches.start.x - rect.left) / rect.width) * 2 - 1;
                            const y = -((this.touches.start.y - rect.top) / rect.height) * 2 + 1;
                            
                            this.raycaster.setFromCamera(new THREE.Vector2(x, y), this.camera);
                            const intersects = this.raycaster.intersectObjects(this.artworks, true);
                            
                            if (intersects.length > 0) {
                                const artwork = intersects[0].object.parent || intersects[0].object;
                                if (artwork.userData && artwork.userData.url) {
                                    // Use the same openInNewTab function for consistency
                                    openInNewTab(artwork.userData.url, artwork.userData.title);
                                }
                            }
                        }
                    }
                    
                    this.touches.start = null;
                    this.touches.current = null;
                });
                
                // Joystick controls
                const joystick = document.getElementById('movement-joystick');
                const handle = document.getElementById('movement-handle');
                
                joystick.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.joystickActive = true;
                    this.updateJoystick(e.touches[0], joystick, handle);
                });
                
                joystick.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (this.joystickActive) {
                        this.updateJoystick(e.touches[0], joystick, handle);
                    }
                });
                
                joystick.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.joystickActive = false;
                    this.joystickVector.set(0, 0);
                    handle.style.transform = 'translate(-50%, -50%)';
                });
            }
            
            updateJoystick(touch, joystick, handle) {
                const rect = joystick.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                let deltaX = touch.clientX - centerX;
                let deltaY = touch.clientY - centerY;
                
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                const maxDistance = rect.width / 2 - 25; // handle radius
                
                if (distance > maxDistance) {
                    deltaX = (deltaX / distance) * maxDistance;
                    deltaY = (deltaY / distance) * maxDistance;
                }
                
                handle.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;
                
                this.joystickVector.x = deltaX / maxDistance;
                this.joystickVector.y = -deltaY / maxDistance;
            }
            
            updateHover() {
                // Cast ray from camera center
                this.raycaster.setFromCamera(new THREE.Vector2(0, 0), this.camera);
                const intersects = this.raycaster.intersectObjects(this.artworks, true);
                
                if (intersects.length > 0) {
                    const artwork = intersects[0].object.parent || intersects[0].object;
                    
                    if (artwork.userData && artwork.userData.title && artwork !== this.hoveredArtwork) {
                        this.hoveredArtwork = artwork;
                        
                        // Show tooltip
                        this.tooltipTitle.textContent = `${artwork.userData.icon} ${artwork.userData.title}`;
                        this.tooltipDescription.textContent = artwork.userData.description;
                        this.tooltip.classList.add('visible');
                        
                        // Position tooltip
                        const vector = new THREE.Vector3();
                        artwork.getWorldPosition(vector);
                        vector.project(this.camera);
                        
                        const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                        const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
                        
                        this.tooltip.style.left = `${Math.min(x + 20, window.innerWidth - 420)}px`;
                        this.tooltip.style.top = `${Math.min(y - 50, window.innerHeight - 250)}px`;
                    }
                } else {
                    if (this.hoveredArtwork) {
                        this.hoveredArtwork = null;
                        this.tooltip.classList.remove('visible');
                    }
                }
            }
            
            updateMovement() {
                const forward = new THREE.Vector3();
                const right = new THREE.Vector3();
                
                this.camera.getWorldDirection(forward);
                forward.y = 0;
                forward.normalize();
                
                right.crossVectors(forward, new THREE.Vector3(0, 1, 0));
                
                if (this.isMobile) {
                    // Mobile joystick movement
                    if (this.joystickActive) {
                        const moveForward = forward.multiplyScalar(this.joystickVector.y * this.moveSpeed);
                        const moveRight = right.multiplyScalar(this.joystickVector.x * this.moveSpeed);
                        this.camera.position.add(moveForward);
                        this.camera.position.add(moveRight);
                    }
                } else {
                    // Desktop keyboard movement
                    if (this.keys.w) this.camera.position.add(forward.multiplyScalar(this.moveSpeed));
                    if (this.keys.s) this.camera.position.add(forward.multiplyScalar(-this.moveSpeed));
                    if (this.keys.a) this.camera.position.add(right.multiplyScalar(-this.moveSpeed));
                    if (this.keys.d) this.camera.position.add(right.multiplyScalar(this.moveSpeed));
                }
                
                // Update camera rotation
                this.camera.rotation.order = 'YXZ';
                this.camera.rotation.y = this.rotation.y;
                this.camera.rotation.x = this.rotation.x;
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                // Update movement
                this.updateMovement();
                
                // Update hover detection
                this.updateHover();
                
                // Animate floating cubes
                this.scene.children.forEach(child => {
                    if (child.userData.floatSpeed) {
                        child.position.y += Math.sin(Date.now() * child.userData.floatSpeed) * 0.01;
                        child.rotation.x += child.userData.rotateSpeed;
                        child.rotation.y += child.userData.rotateSpeed * 0.7;
                    }
                });
                
                this.renderer.render(this.scene, this.camera);
            }
            
            cleanup() {
                if (this.renderer) {
                    threeContainer.removeChild(this.renderer.domElement);
                    this.renderer.dispose();
                }
                
                // Hide tooltip
                this.tooltip.classList.remove('visible');
                
                // Hide mobile controls
                document.getElementById('mobile-controls').classList.remove('show');
                
                // Exit pointer lock
                if (document.pointerLockElement) {
                    document.exitPointerLock();
                }
                
                // Remove event listeners
                window.removeEventListener('keydown', this.handleKeyDown);
                window.removeEventListener('keyup', this.handleKeyUp);
            }
        }
        
        // Initialize gallery
        window.addEventListener('DOMContentLoaded', fetchRepoFiles);
    </script>
</body>
</html>