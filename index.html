<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Vibe Coding Gallery</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #000;
            color: #fff;
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }

        /* Animated background */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 50%, rgba(120, 30, 255, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(255, 30, 120, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 40% 10%, rgba(30, 255, 120, 0.3) 0%, transparent 50%);
            animation: drift 20s ease-in-out infinite;
            z-index: -1;
        }

        @keyframes drift {
            0%, 100% { transform: scale(1) rotate(0deg); }
            33% { transform: scale(1.1) rotate(120deg); }
            66% { transform: scale(0.95) rotate(240deg); }
        }
        
        .header {
            padding: 60px 20px 40px;
            text-align: center;
            position: relative;
            background: linear-gradient(180deg, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0) 100%);
        }

        @media (max-width: 768px) {
            .header {
                padding: 40px 20px 30px;
            }
        }

        .gallery-title {
            font-size: 5em;
            font-weight: 100;
            letter-spacing: 0.2em;
            margin-bottom: 20px;
            text-transform: uppercase;
            position: relative;
            display: inline-block;
        }

        @media (max-width: 768px) {
            .gallery-title {
                font-size: 3em;
                letter-spacing: 0.1em;
            }
        }

        .gallery-title::before {
            content: 'VIBE CODING';
            position: absolute;
            left: 0;
            top: 0;
            background: linear-gradient(45deg, #ff006e, #8338ec, #3a86ff, #06ffa5);
            background-size: 400% 100%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: shimmer 8s ease-in-out infinite;
        }

        @keyframes shimmer {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        /* iPhone-style launcher */
        .launcher-container {
            display: none;
            padding: 20px;
            min-height: calc(100vh - 80px);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            position: relative;
        }

        .launcher-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 50%, rgba(120, 119, 198, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(255, 119, 198, 0.2) 0%, transparent 50%),
                radial-gradient(circle at 40% 10%, rgba(120, 255, 198, 0.2) 0%, transparent 50%);
            pointer-events: none;
        }

        .launcher-container.active {
            display: block;
        }

        .app-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 25px;
            max-width: 400px;
            margin: 0 auto;
            padding: 20px 10px;
            position: relative;
            z-index: 1;
        }

        @media (min-width: 768px) {
            .app-grid {
                grid-template-columns: repeat(6, 1fr);
                gap: 30px;
                max-width: 700px;
            }
        }

        @media (min-width: 1024px) {
            .app-grid {
                grid-template-columns: repeat(8, 1fr);
                max-width: 900px;
            }
        }

        .app-icon {
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            transition: transform 0.2s, filter 0.2s;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            position: relative;
        }

        .app-icon:hover {
            transform: scale(1.1);
        }

        .app-icon:active {
            transform: scale(0.95);
            filter: brightness(0.8);
        }

        .app-icon-image {
            width: 62px;
            height: 62px;
            border-radius: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 30px;
            background: linear-gradient(145deg, #ffffff, #f0f0f0);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15),
                        0 1px 3px rgba(0,0,0,0.1),
                        inset 0 1px 0 rgba(255,255,255,0.5);
            margin-bottom: 8px;
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(10px);
            border: 0.5px solid rgba(255,255,255,0.3);
        }

        @media (min-width: 768px) {
            .app-icon-image {
                width: 80px;
                height: 80px;
                border-radius: 18px;
                font-size: 40px;
            }
        }

        .app-icon-image::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, 
                rgba(255,255,255,0.2) 0%, 
                rgba(255,255,255,0) 50%,
                rgba(0,0,0,0.1) 100%);
            pointer-events: none;
        }

        .app-icon-label {
            font-size: 11px;
            color: rgba(255,255,255,0.95);
            text-align: center;
            max-width: 75px;
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            white-space: normal;
            text-shadow: 0 1px 3px rgba(0,0,0,0.8);
            line-height: 1.2;
            font-weight: 500;
        }

        @media (min-width: 768px) {
            .app-icon-label {
                font-size: 12px;
                max-width: 90px;
            }
        }

        /* App categories with iOS-style colors */
        .app-icon[data-category="games"] .app-icon-image {
            background: linear-gradient(135deg, #FA6E5A, #FE9A52);
        }

        .app-icon[data-category="productivity"] .app-icon-image {
            background: linear-gradient(135deg, #6DD5FA, #2980B9);
        }

        .app-icon[data-category="business"] .app-icon-image {
            background: linear-gradient(135deg, #5EE7A8, #33B679);
        }

        .app-icon[data-category="ai-tools"] .app-icon-image {
            background: linear-gradient(135deg, #B06CFF, #7C3AED);
        }

        .app-icon[data-category="development"] .app-icon-image {
            background: linear-gradient(135deg, #FFA751, #FF6B35);
        }

        .app-icon[data-category="media"] .app-icon-image {
            background: linear-gradient(135deg, #FF6B9D, #C44764);
        }

        .app-icon[data-category="education"] .app-icon-image {
            background: linear-gradient(135deg, #FFD93D, #FCB045);
        }

        .app-icon[data-category="health"] .app-icon-image {
            background: linear-gradient(135deg, #6CE779, #41C563);
        }

        .app-icon[data-category="utilities"] .app-icon-image {
            background: linear-gradient(135deg, #95A5A6, #7F8C8D);
        }

        .app-icon[data-category="index-variants"] .app-icon-image {
            background: linear-gradient(135deg, #E056FD, #BE2EDD);
        }

        /* View toggle button */
        .view-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: linear-gradient(145deg, #2c2c2e, #1c1c1e);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 10px 20px;
            color: #fff;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            transition: all 0.3s;
        }

        .view-toggle:hover {
            background: linear-gradient(145deg, #3c3c3e, #2c2c2e);
            transform: scale(1.05);
        }

        .view-toggle:active {
            transform: scale(0.98);
        }

        .view-toggle-icon {
            font-size: 18px;
        }

        /* Gallery container adjustments */
        .gallery-container {
            transition: opacity 0.3s, transform 0.3s;
        }

        .gallery-container.hidden {
            display: none;
        }

        /* Dock at bottom */
        .dock {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(28,28,30,0.95);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 10px 15px;
            display: flex;
            gap: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.4);
            z-index: 999;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .dock-item {
            width: 50px;
            height: 50px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            cursor: pointer;
            transition: transform 0.2s;
            background: linear-gradient(145deg, #3c3c3e, #2c2c2e);
        }

        .dock-item:hover {
            transform: translateY(-5px) scale(1.1);
        }

        /* App launcher header */
        .launcher-header {
            text-align: center;
            margin-bottom: 20px;
            padding-top: 60px;
            position: relative;
            z-index: 1;
        }

        .launcher-title {
            font-size: 28px;
            font-weight: 700;
            color: rgba(255,255,255,1);
            margin-bottom: 5px;
            letter-spacing: -0.5px;
        }

        .launcher-subtitle {
            font-size: 14px;
            color: rgba(255,255,255,0.8);
            font-weight: 400;
        }

        /* Search bar in launcher */
        .launcher-search {
            max-width: 350px;
            margin: 0 auto 25px;
            position: relative;
            z-index: 1;
        }

        .launcher-search-input {
            width: 100%;
            padding: 10px 40px 10px 35px;
            background: rgba(255,255,255,0.2);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 18px;
            color: #fff;
            font-size: 15px;
            outline: none;
            font-weight: 500;
        }

        .launcher-search-input:focus {
            background: rgba(255,255,255,0.25);
            border-color: rgba(255,255,255,0.4);
        }

        .launcher-search-input::placeholder {
            color: rgba(255,255,255,0.6);
        }

        .launcher-search-icon {
            position: absolute;
            left: 12px;
            top: 50%;
            transform: translateY(-50%);
            color: rgba(255,255,255,0.6);
            font-size: 16px;
        }

        .gallery-subtitle {
            font-size: 1.5em;
            font-weight: 200;
            color: rgba(255, 255, 255, 0.6);
            letter-spacing: 0.5em;
            text-transform: uppercase;
        }

        @media (max-width: 768px) {
            .gallery-subtitle {
                font-size: 1.2em;
                letter-spacing: 0.3em;
            }
        }

        .gallery-description {
            max-width: 600px;
            margin: 30px auto 0;
            color: rgba(255, 255, 255, 0.5);
            line-height: 1.6;
            font-weight: 300;
        }

        @media (max-width: 768px) {
            .gallery-description {
                margin: 20px auto 0;
                font-size: 0.95em;
            }
        }

        /* Search Box */
        .search-container {
            max-width: 600px;
            margin: 30px auto;
            position: relative;
        }

        .search-box {
            width: 100%;
            padding: 15px 50px 15px 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 30px;
            color: white;
            font-size: 1.1em;
            outline: none;
            transition: all 0.3s ease;
        }

        .search-box:focus {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .search-box::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .search-icon {
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            color: rgba(255, 255, 255, 0.5);
            pointer-events: none;
        }

        .gallery-modes {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        
        /* Category filter buttons */
        .category-filters {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin: 20px auto;
            flex-wrap: wrap;
            max-width: 1200px;
        }
        
        .category-filter {
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            color: rgba(255, 255, 255, 0.7);
            cursor: pointer;
            font-size: 0.95em;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .category-filter:hover {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            transform: translateY(-2px);
        }
        
        .category-filter.active {
            background: linear-gradient(135deg, #ff006e, #8338ec);
            border-color: transparent;
            color: white;
        }
        
        .category-filter .count {
            background: rgba(255, 255, 255, 0.2);
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.85em;
        }
        
        /* Statistics section */
        .gallery-stats {
            text-align: center;
            margin: 20px auto;
            padding: 20px;
            max-width: 600px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .gallery-stats .stat-row {
            display: flex;
            justify-content: center;
            gap: 30px;
            flex-wrap: wrap;
        }
        
        .gallery-stats .stat {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }
        
        .gallery-stats .stat-value {
            font-size: 2em;
            font-weight: 300;
            background: linear-gradient(45deg, #ff006e, #8338ec);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .gallery-stats .stat-label {
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.6);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        @media (max-width: 768px) {
            .gallery-modes {
                gap: 15px;
            }
        }

        .mode-button {
            padding: 15px 40px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 30px;
            color: white;
            cursor: pointer;
            font-size: 1.1em;
            letter-spacing: 0.1em;
            transition: all 0.3s ease;
            text-transform: uppercase;
            -webkit-appearance: none;
            appearance: none;
            touch-action: manipulation;
        }

        @media (max-width: 768px) {
            .mode-button {
                padding: 12px 30px;
                font-size: 1em;
            }
        }

        .mode-button:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(255, 255, 255, 0.1);
        }

        .mode-button:active {
            transform: scale(0.98);
        }

        .mode-button.active {
            background: linear-gradient(135deg, #ff006e, #8338ec);
            border: none;
        }

        .mode-button.vr-mode {
            background: linear-gradient(135deg, #ff006e, #8338ec);
            border: none;
        }

        .mode-button.vr-mode:hover {
            box-shadow: 0 10px 30px rgba(138, 43, 226, 0.5);
        }
        
        .content {
            padding: 40px 20px 80px;
            max-width: 1600px;
            margin: 0 auto;
        }

        .content.hidden {
            display: none;
        }
        
        .loading {
            text-align: center;
            padding: 100px;
            font-size: 1.2em;
            color: rgba(255, 255, 255, 0.4);
            font-weight: 200;
            letter-spacing: 0.1em;
        }

        .loading::after {
            content: '';
            display: block;
            width: 60px;
            height: 1px;
            background: linear-gradient(90deg, transparent, #fff, transparent);
            margin: 30px auto;
            animation: scan 2s linear infinite;
        }

        @keyframes scan {
            0% { transform: translateX(-100px); }
            100% { transform: translateX(100px); }
        }
        
        .error {
            color: #ff006e;
            padding: 30px;
            background: rgba(255, 0, 110, 0.1);
            border-radius: 20px;
            margin: 20px auto;
            border: 1px solid rgba(255, 0, 110, 0.2);
            max-width: 600px;
            text-align: center;
        }
        
        .exhibition-section {
            margin-bottom: 80px;
        }

        .section-title {
            font-size: 3em;
            font-weight: 100;
            text-align: center;
            margin-bottom: 50px;
            letter-spacing: 0.1em;
            position: relative;
            padding-bottom: 20px;
        }

        @media (max-width: 768px) {
            .section-title {
                font-size: 2em;
                margin-bottom: 30px;
            }
        }

        .section-title::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 100px;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.5), transparent);
        }
        
        .artwork-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(400px, 1fr));
            gap: 40px;
        }

        @media (max-width: 768px) {
            .artwork-grid {
                grid-template-columns: 1fr;
                gap: 20px;
            }
        }
        
        .artwork-frame {
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 20px;
            transition: all 0.5s ease;
            position: relative;
            overflow: hidden;
            cursor: pointer;
            min-height: 300px;
            display: flex;
            flex-direction: column;
        }

        .artwork-frame.pinned {
            border-color: #ff006e;
            background: rgba(255, 0, 110, 0.05);
        }

        .artwork-frame::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle at var(--mouse-x, 50%) var(--mouse-y, 50%), rgba(255, 255, 255, 0.1), transparent 40%);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        @media (hover: hover) {
            .artwork-frame:hover::before {
                opacity: 1;
            }

            .artwork-frame:hover {
                transform: translateY(-10px);
                background: rgba(255, 255, 255, 0.05);
                border-color: rgba(255, 255, 255, 0.2);
                box-shadow: 
                    0 20px 40px rgba(0, 0, 0, 0.5),
                    0 0 60px rgba(138, 43, 226, 0.2);
            }
        }

        @media (hover: none) {
            .artwork-frame:active {
                transform: scale(0.98);
                background: rgba(255, 255, 255, 0.05);
            }
        }

        .pin-button {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 0.6);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2em;
            transition: all 0.3s ease;
            z-index: 10;
        }

        .pin-button:hover {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            transform: scale(1.1);
        }

        .pin-button.pinned {
            background: #ff006e;
            border-color: #ff006e;
            color: white;
        }
        
        .artwork-preview {
            width: 100%;
            height: 200px;
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.1), rgba(0, 255, 255, 0.1));
            border-radius: 10px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 4em;
            position: relative;
            overflow: hidden;
        }

        .artwork-preview::after {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent 30%, rgba(255, 255, 255, 0.1) 50%, transparent 70%);
            animation: shine 3s ease-in-out infinite;
        }

        @keyframes shine {
            0% { transform: rotate(0deg) translateX(-100%); }
            100% { transform: rotate(0deg) translateX(100%); }
        }
        
        .artwork-title {
            font-size: 1.8em;
            font-weight: 200;
            margin-bottom: 10px;
            letter-spacing: 0.05em;
        }

        @media (max-width: 768px) {
            .artwork-title {
                font-size: 1.5em;
            }
        }
        
        .artwork-description {
            color: rgba(255, 255, 255, 0.6);
            line-height: 1.6;
            margin-bottom: 20px;
            flex-grow: 1;
            font-weight: 300;
        }

        .artwork-stats {
            display: flex;
            gap: 20px;
            margin-bottom: 15px;
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.5);
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .vote-count {
            color: #06ffa5;
        }
        
        .artwork-actions {
            display: flex;
            gap: 15px;
            margin-top: auto;
        }

        .view-button, .download-button, .vote-button {
            flex: 1;
            padding: 15px 25px;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 400;
            letter-spacing: 0.05em;
            transition: all 0.3s ease;
            text-transform: uppercase;
            -webkit-appearance: none;
            appearance: none;
            touch-action: manipulation;
        }

        .view-button {
            background: linear-gradient(135deg, #ff006e, #8338ec);
            color: white;
        }

        .view-button:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 30px rgba(138, 43, 226, 0.5);
        }

        .view-button:active {
            transform: scale(0.98);
        }

        .vote-button {
            background: transparent;
            color: #06ffa5;
            border: 1px solid #06ffa5;
            position: relative;
            overflow: hidden;
        }

        .vote-button:hover {
            background: rgba(6, 255, 165, 0.1);
            transform: scale(1.05);
        }

        .vote-button.voted {
            background: #06ffa5;
            color: #000;
        }

        .download-button {
            background: linear-gradient(135deg, rgba(6, 255, 165, 0.2), rgba(0, 180, 216, 0.2));
            color: #06ffa5;
            border: 1px solid #06ffa5;
            font-weight: 600;
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .download-button::after {
            content: '💾';
            margin-left: 5px;
            display: inline-block;
            transition: transform 0.3s ease;
        }

        .download-button:hover {
            background: linear-gradient(135deg, rgba(6, 255, 165, 0.4), rgba(0, 180, 216, 0.4));
            border-color: #06ffa5;
            box-shadow: 0 0 15px rgba(6, 255, 165, 0.5);
            transform: translateY(-2px);
        }

        .download-button:hover::after {
            transform: scale(1.2);
        }

        .download-button:active {
            transform: scale(0.98);
        }

        /* Vote popup */
        .vote-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            z-index: 1000;
            display: none;
            backdrop-filter: blur(10px);
        }

        .vote-popup.show {
            display: block;
        }

        .vote-popup h3 {
            font-size: 1.8em;
            font-weight: 300;
            margin-bottom: 20px;
            color: #06ffa5;
        }

        .vote-form {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .vote-textarea {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 15px;
            color: white;
            font-family: inherit;
            font-size: 1em;
            resize: vertical;
            min-height: 100px;
            outline: none;
        }

        .vote-textarea:focus {
            border-color: #06ffa5;
        }

        .vote-textarea::placeholder {
            color: rgba(255, 255, 255, 0.4);
        }

        .vote-actions {
            display: flex;
            gap: 10px;
        }

        .submit-vote, .cancel-vote {
            flex: 1;
            padding: 12px 20px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s ease;
        }

        .submit-vote {
            background: #06ffa5;
            color: #000;
        }

        .submit-vote:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 30px rgba(6, 255, 165, 0.3);
        }

        .cancel-vote {
            background: transparent;
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .cancel-vote:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .vote-popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 999;
            display: none;
        }

        .vote-popup-overlay.show {
            display: block;
        }

        /* 3D Gallery Styles */
        #three-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            z-index: 1000;
            touch-action: none;
        }

        #three-container.active {
            display: block;
        }

        .three-ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 1001;
        }

        .back-button {
            padding: 12px 30px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 25px;
            color: white;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s ease;
            -webkit-appearance: none;
            appearance: none;
            touch-action: manipulation;
        }

        .back-button:hover {
            background: rgba(0, 0, 0, 0.9);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .back-button:active {
            transform: scale(0.95);
        }

        .controls-hint {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.8);
            z-index: 1001;
            text-align: center;
        }

        /* Mobile controls UI */
        .mobile-controls {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            z-index: 1001;
            gap: 20px;
        }

        .mobile-controls.show {
            display: flex;
        }

        .joystick-container {
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            position: relative;
            touch-action: none;
        }

        .joystick-handle {
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: none;
        }

        .artwork-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            padding: 25px;
            max-width: 400px;
            display: none;
            z-index: 1002;
            pointer-events: none;
            backdrop-filter: blur(10px);
        }

        @media (max-width: 768px) {
            .artwork-tooltip {
                padding: 20px;
                max-width: 300px;
            }
        }

        .artwork-tooltip.visible {
            display: block;
        }

        .tooltip-title {
            font-size: 1.4em;
            font-weight: 300;
            margin-bottom: 10px;
            color: #fff;
        }

        @media (max-width: 768px) {
            .tooltip-title {
                font-size: 1.2em;
            }
        }

        .tooltip-description {
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.7);
            line-height: 1.5;
            margin-bottom: 10px;
        }

        .tooltip-instruction {
            font-size: 0.85em;
            color: #ff006e;
            text-align: center;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* Custom scrollbar */
        @media (hover: hover) {
            ::-webkit-scrollbar {
                width: 8px;
            }

            ::-webkit-scrollbar-track {
                background: rgba(255, 255, 255, 0.05);
            }

            ::-webkit-scrollbar-thumb {
                background: rgba(255, 255, 255, 0.2);
                border-radius: 4px;
            }

            ::-webkit-scrollbar-thumb:hover {
                background: rgba(255, 255, 255, 0.3);
            }
        }

        /* Toast notification */
        .toast {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 25px;
            padding: 15px 30px;
            color: white;
            font-size: 1em;
            z-index: 2000;
            opacity: 0;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .toast.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        .toast.success {
            border-color: #06ffa5;
            color: #06ffa5;
        }

        .toast.error {
            border-color: #ff006e;
            color: #ff006e;
        }
    </style>
</head>
<body>
    <!-- View Toggle Button -->
    <button class="view-toggle" id="viewToggle">
        <span class="view-toggle-icon">📱</span>
        <span id="viewToggleText">App Launcher</span>
    </button>

    <!-- iPhone-style App Launcher -->
    <div class="launcher-container" id="launcherContainer">
        <div class="launcher-header">
            <h1 class="launcher-title">Local First Tools</h1>
            <p class="launcher-subtitle">Your offline toolkit</p>
        </div>
        
        <div class="launcher-search">
            <input type="text" class="launcher-search-input" id="launcherSearch" placeholder="Search apps...">
            <span class="launcher-search-icon">🔍</span>
        </div>
        
        <div class="app-grid" id="appGrid">
            <!-- Apps will be dynamically loaded here -->
        </div>
    </div>

    <!-- Favorite Apps Dock -->
    <div class="dock" id="dock" style="display: none;">
        <!-- Favorite apps will be added here -->
    </div>

    <!-- Gallery Container -->
    <div class="gallery-container" id="galleryContainer">
    <div class="header">
        <h1 class="gallery-title">VIBE CODING</h1>
        <div class="gallery-subtitle">Kody's Creative Playground</div>
        <p class="gallery-description">
            Welcome to Kody Wildfeuer's vibe coding showcase - a collection of experimental web art, creative coding projects, and digital explorations.<br>
            These are personal creative experiments that represent the intersection of code and art.<br>
            <span style="font-size: 0.85em; opacity: 0.6;">Note: This is Kody's personal creative content and opinions, unrelated to any employer.</span>
        </p>
        
        <!-- Search and Controls -->
        <div class="controls-container">
            <div class="search-container">
                <input type="text" id="searchInput" class="search-box" placeholder="Search creative tools...">
                <span class="search-icon">🔍</span>
            </div>
            <div class="sort-container">
                <label style="color: rgba(255,255,255,0.7);">Sort by:</label>
                <select id="sortSelect" class="sort-select">
                    <option value="votes">Most Voted</option>
                    <option value="alpha">Alphabetical</option>
                    <option value="category">Category</option>
                    <option value="recent">Recently Added</option>
                </select>
            </div>
        </div>
        <div class="gallery-modes">
            <button class="mode-button active" id="main-gallery">Main Gallery</button>
            <button class="mode-button" id="archive-mode">Archive</button>
            <button class="mode-button vr-mode" id="3d-mode">3D Experience</button>
        </div>
    </div>
    
    <div class="content" id="main-content">
        <div class="loading">Loading gallery...</div>
    </div>

    <div id="three-container">
        <div class="three-ui">
            <button class="back-button" id="back-to-gallery">← Back to Gallery</button>
        </div>
        <div class="controls-hint" id="controls-hint">Use WASD to move, Mouse to look around, Click on artworks to view</div>
        <div class="mobile-controls" id="mobile-controls">
            <div class="joystick-container" id="movement-joystick">
                <div class="joystick-handle" id="movement-handle"></div>
            </div>
        </div>
        <div class="artwork-tooltip" id="artwork-tooltip">
            <h3 class="tooltip-title"></h3>
            <p class="tooltip-description"></p>
            <p class="tooltip-instruction">Click to view in new tab</p>
        </div>
    </div>

    <!-- Vote popup -->
    <div class="vote-popup-overlay" id="vote-overlay"></div>
    <div class="vote-popup" id="vote-popup">
        <h3>Vote for Feature Request</h3>
        <form class="vote-form" id="vote-form">
            <textarea class="vote-textarea" id="vote-message" placeholder="What features or improvements would you like to see in this tool?"></textarea>
            <div class="vote-actions">
                <button type="submit" class="submit-vote">Submit Vote</button>
                <button type="button" class="cancel-vote" id="cancel-vote">Cancel</button>
            </div>
        </form>
    </div>

    <!-- Toast notification -->
    <div class="toast" id="toast"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Target repository
        const REPO_OWNER = 'kody-w';
        const REPO_NAME = 'localFirstTools';
        const BRANCH = 'main';
        
        // Detect if running locally
        const isLocal = window.location.protocol === 'file:' || 
                       window.location.hostname === 'localhost' || 
                       window.location.hostname === '127.0.0.1' ||
                       window.location.hostname === '';
        
        // GitHub Pages URL pattern
        const GITHUB_PAGES_BASE = `https://${REPO_OWNER}.github.io/${REPO_NAME}/`;
        
        // Store gallery data globally
        let galleryData = null;
        let threeScene = null;
        let currentView = 'main'; // 'main' or 'archive'
        
        // Local storage keys
        const PINNED_TOOLS_KEY = 'vibe_gallery_pinned_tools';
        const VOTES_KEY = 'vibe_gallery_votes';
        const USER_VOTES_KEY = 'vibe_gallery_user_votes';
        
        // Main content container
        const mainContent = document.getElementById('main-content');
        const threeContainer = document.getElementById('three-container');
        
        // Icons for display
        const artworkIcons = ['🎨', '✨', '🌟', '💫', '🔮', '🎭', '🌈', '🎪', '🎯', '🎲', '🎸', '🎹'];
        
        // Check if device is mobile
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                        (window.matchMedia && window.matchMedia('(max-width: 768px)').matches);
        
        // Get appropriate URL for file based on environment
        function getFileUrl(path) {
            if (isLocal) {
                // For local testing, use relative path
                return path;
            } else {
                // For GitHub Pages, use full URL
                return `${GITHUB_PAGES_BASE}${path}`;
            }
        }
        
        // Local storage helpers
        function getPinnedTools() {
            const pinned = localStorage.getItem(PINNED_TOOLS_KEY);
            return pinned ? JSON.parse(pinned) : [];
        }
        
        function setPinnedTools(pinned) {
            localStorage.setItem(PINNED_TOOLS_KEY, JSON.stringify(pinned));
        }
        
        function getVotes() {
            const votes = localStorage.getItem(VOTES_KEY);
            return votes ? JSON.parse(votes) : {};
        }
        
        function setVotes(votes) {
            localStorage.setItem(VOTES_KEY, JSON.stringify(votes));
        }
        
        function getUserVotes() {
            const userVotes = localStorage.getItem(USER_VOTES_KEY);
            return userVotes ? JSON.parse(userVotes) : {};
        }
        
        function setUserVotes(userVotes) {
            localStorage.setItem(USER_VOTES_KEY, JSON.stringify(userVotes));
        }
        
        // Toast notification
        function showToast(message, type = 'success') {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = `toast ${type}`;
            toast.classList.add('show');
            
            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }
        
        // Enhanced metadata generation using config data
        let configMetadata = {};
        
        // Generate consistent artwork metadata
        function generateArtworkMetadata(file) {
            // First check if we have metadata from config
            const path = file.path.replace('./', '');
            if (configMetadata[path]) {
                return configMetadata[path];
            }
            
            // Fallback to generated metadata
            const filename = file.path.split('/').pop();
            const nameWithoutExt = filename.replace('.html', '').replace('.htm', '');
            const formattedName = nameWithoutExt
                .replace(/[-_]/g, ' ')
                .replace(/\b\w/g, l => l.toUpperCase());
            
            // Determine category from path
            const category = detectCategoryFromPath(file.path);
            
            // Use a hash of the filename to generate consistent metadata
            const hash = filename.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
            
            const descriptions = [
                "An experimental dive into the creative possibilities of web technology",
                "Interactive art piece exploring the boundaries between code and creativity",
                "A digital meditation on algorithms, aesthetics, and human expression",
                "Pushing browser limits to create unexpected visual experiences",
                "Real-time generative art that evolves with each interaction",
                "Creative coding experiment blending mathematics and imagination",
                "A playful exploration of what happens when code becomes art",
                "Digital canvas where logic meets creativity in unexpected ways",
                "Vibe coding at its finest - where inspiration meets implementation"
            ];
            
            return {
                title: formattedName,
                description: descriptions[hash % descriptions.length],
                icon: getCategoryIcon(category) || artworkIcons[hash % artworkIcons.length],
                tags: generateConsistentTags(filename, hash),
                category: category
            };
        }
        
        // Detect category from file path
        function detectCategoryFromPath(path) {
            if (path.includes('apps/games/')) return 'games';
            if (path.includes('apps/ai-tools/')) return 'ai-tools';
            if (path.includes('apps/productivity/')) return 'productivity';
            if (path.includes('apps/business/')) return 'business';
            if (path.includes('apps/media/')) return 'media';
            if (path.includes('apps/development/')) return 'development';
            if (path.includes('apps/education/')) return 'education';
            if (path.includes('apps/health/')) return 'health';
            if (path.includes('apps/utilities/')) return 'utilities';
            if (path.includes('archive/')) return 'archive';
            return 'other';
        }
        
        // Get icon for category
        function getCategoryIcon(category) {
            const icons = {
                'games': '🎮',
                'ai-tools': '🤖',
                'productivity': '📝',
                'business': '💼',
                'media': '🎬',
                'development': '💻',
                'education': '📚',
                'health': '🧘',
                'utilities': '🔧',
                'archive': '📦'
            };
            return icons[category];
        }
        
        // Generate consistent tags based on filename
        function generateConsistentTags(filename, hash) {
            const allTags = [
                'interactive', 'generative', 'particles', 'animation', 
                'experimental', '3D', 'audio-reactive', 'kinetic',
                'abstract', 'geometric', 'organic', 'minimal',
                'colorful', 'monochrome', 'dynamic', 'static'
            ];
            
            // Use hash to select 2-3 tags consistently
            const numTags = 2 + (hash % 2);
            const tags = [];
            
            for (let i = 0; i < numTags; i++) {
                const tagIndex = (hash + i * 7) % allTags.length;
                tags.push(allTags[tagIndex]);
            }
            
            return tags;
        }
        
        // Track mouse position for interactive effects (desktop only)
        if (!isMobile) {
            document.addEventListener('mousemove', (e) => {
                const frames = document.querySelectorAll('.artwork-frame');
                frames.forEach(frame => {
                    const rect = frame.getBoundingClientRect();
                    const x = ((e.clientX - rect.left) / rect.width) * 100;
                    const y = ((e.clientY - rect.top) / rect.height) * 100;
                    frame.style.setProperty('--mouse-x', `${x}%`);
                    frame.style.setProperty('--mouse-y', `${y}%`);
                });
            });
        }
        
        // Search functionality
        const searchInput = document.getElementById('searchInput');
        if (searchInput) {
            searchInput.addEventListener('input', (e) => {
                const searchTerm = e.target.value.toLowerCase();
                filterArtworks(searchTerm);
            });
        }
        
        function filterArtworks(searchTerm) {
            const artworkFrames = document.querySelectorAll('.artwork-frame');
            let visibleCount = 0;
            let totalCount = 0;
            
            artworkFrames.forEach(frame => {
                const title = frame.querySelector('.artwork-title').textContent.toLowerCase();
                const description = frame.querySelector('.artwork-description').textContent.toLowerCase();
                
                // Enhanced search: also search through data attributes if available
                const tags = frame.dataset.tags ? frame.dataset.tags.toLowerCase() : '';
                const category = frame.dataset.category ? frame.dataset.category.toLowerCase() : '';
                
                const matchFound = title.includes(searchTerm) || 
                                 description.includes(searchTerm) ||
                                 tags.includes(searchTerm) ||
                                 category.includes(searchTerm);
                
                totalCount++;
                if (matchFound || searchTerm === '') {
                    frame.style.display = 'flex';
                    visibleCount++;
                } else {
                    frame.style.display = 'none';
                }
            });
            
            // Hide empty sections
            const sections = document.querySelectorAll('.exhibition-section');
            sections.forEach(section => {
                const visibleFrames = section.querySelectorAll('.artwork-frame[style*="display: flex"], .artwork-frame:not([style*="display"])');
                if (visibleFrames.length === 0) {
                    section.style.display = 'none';
                } else {
                    section.style.display = 'block';
                }
            });
            
            // Update search results count
            updateSearchResultsCount(visibleCount, totalCount);
        }
        
        // Update search results counter
        function updateSearchResultsCount(visible, total) {
            let resultsDiv = document.getElementById('search-results-count');
            if (!resultsDiv) {
                resultsDiv = document.createElement('div');
                resultsDiv.id = 'search-results-count';
                resultsDiv.style.cssText = 'text-align: center; margin: 10px auto; color: rgba(255,255,255,0.6); max-width: 600px;';
                const categoryFilters = document.querySelector('.category-filters');
                if (categoryFilters) {
                    categoryFilters.parentNode.insertBefore(resultsDiv, categoryFilters.nextSibling);
                }
            }
            
            if (resultsDiv) {
                const searchInput = document.getElementById('searchInput');
                if (searchInput && searchInput.value && visible < total) {
                    resultsDiv.textContent = `Found ${visible} of ${total} apps matching "${searchInput.value}"`;
                    resultsDiv.style.display = 'block';
                } else {
                    resultsDiv.style.display = 'none';
                }
            }
        }
        
        // Mode switching
        document.getElementById('main-gallery').addEventListener('click', () => {
            currentView = 'main';
            document.getElementById('main-gallery').classList.add('active');
            document.getElementById('archive-mode').classList.remove('active');
            threeContainer.classList.remove('active');
            mainContent.classList.remove('hidden');
            if (threeScene) {
                threeScene.cleanup();
                threeScene = null;
            }
            if (galleryData) {
                displayGallery(galleryData);
            }
        });
        
        document.getElementById('archive-mode').addEventListener('click', () => {
            currentView = 'archive';
            document.getElementById('archive-mode').classList.add('active');
            document.getElementById('main-gallery').classList.remove('active');
            threeContainer.classList.remove('active');
            mainContent.classList.remove('hidden');
            if (threeScene) {
                threeScene.cleanup();
                threeScene = null;
            }
            if (galleryData) {
                displayGallery(galleryData);
            }
        });
        
        document.getElementById('3d-mode').addEventListener('click', () => {
            if (galleryData) {
                mainContent.classList.add('hidden');
                threeContainer.classList.add('active');
                init3DGallery(galleryData);
            }
        });
        
        document.getElementById('back-to-gallery').addEventListener('click', () => {
            document.getElementById('main-gallery').click();
        });
        
        // Vote popup handling
        const voteOverlay = document.getElementById('vote-overlay');
        const votePopup = document.getElementById('vote-popup');
        const voteForm = document.getElementById('vote-form');
        const cancelVote = document.getElementById('cancel-vote');
        let currentVoteFile = null;
        
        voteOverlay.addEventListener('click', closeVotePopup);
        cancelVote.addEventListener('click', closeVotePopup);
        
        function openVotePopup(file) {
            currentVoteFile = file;
            voteOverlay.classList.add('show');
            votePopup.classList.add('show');
            document.getElementById('vote-message').value = '';
        }
        
        function closeVotePopup() {
            voteOverlay.classList.remove('show');
            votePopup.classList.remove('show');
            currentVoteFile = null;
        }
        
        voteForm.addEventListener('submit', (e) => {
            e.preventDefault();
            if (!currentVoteFile) return;
            
            const message = document.getElementById('vote-message').value.trim();
            if (!message) {
                showToast('Please enter a feature request', 'error');
                return;
            }
            
            // Update votes
            const votes = getVotes();
            const userVotes = getUserVotes();
            const fileId = currentVoteFile.path;
            
            // Initialize vote count if not exists
            if (!votes[fileId]) {
                votes[fileId] = { count: 0, requests: [] };
            }
            
            // Add vote
            votes[fileId].count++;
            votes[fileId].requests.push({
                message: message,
                timestamp: new Date().toISOString()
            });
            
            // Mark user as voted for this file
            userVotes[fileId] = true;
            
            // Save to local storage
            setVotes(votes);
            setUserVotes(userVotes);
            
            // Update UI
            updateVoteUI(fileId);
            
            closeVotePopup();
            showToast('Vote submitted! Thank you for your feedback.');
            
            // Log vote for developer (in console)
            console.log('New vote for:', currentVoteFile.path);
            console.log('Feature request:', message);
        });
        
        function updateVoteUI(fileId) {
            const voteButtons = document.querySelectorAll(`.vote-button[data-file="${fileId}"]`);
            const voteCounts = document.querySelectorAll(`.vote-count[data-file="${fileId}"]`);
            const userVotes = getUserVotes();
            const votes = getVotes();
            
            voteButtons.forEach(btn => {
                if (userVotes[fileId]) {
                    btn.classList.add('voted');
                    btn.textContent = 'Voted';
                }
            });
            
            voteCounts.forEach(count => {
                count.textContent = votes[fileId] ? votes[fileId].count : 0;
            });
        }
        
        // Pin functionality - FIXED VERSION
        function togglePin(file) {
            const pinned = getPinnedTools();
            const fileId = file.path;
            const index = pinned.indexOf(fileId);
            
            if (index > -1) {
                pinned.splice(index, 1);
                showToast('Tool unpinned');
            } else {
                pinned.push(fileId);
                showToast('Tool pinned to top');
            }
            
            setPinnedTools(pinned);
            
            // Refresh display
            if (galleryData) {
                displayGallery(galleryData);
            }
        }
        
        // Fetch GitHub repository files
        async function fetchRepoFiles() {
            try {
                // If running locally, try to use local data first
                if (isLocal) {
                    console.log('Running locally - attempting to load apps from local filesystem');
                    
                    // Try to fetch the config file
                    try {
                        const configResponse = await fetch('data/config/utility_apps_config.json');
                        if (configResponse.ok) {
                            const configData = await configResponse.json();
                            console.log('Loaded local config:', configData);
                            
                            // Store metadata for later use
                            configData.apps.forEach(app => {
                                const path = app.path.replace('./', '');
                                configMetadata[path] = {
                                    title: app.title,
                                    description: app.description,
                                    icon: app.icon,
                                    tags: app.tags,
                                    category: detectCategoryFromPath(path)
                                };
                            });
                            
                            // Convert config format to gallery format
                            const files = configData.apps.map(app => ({
                                path: app.path.replace('./', ''),
                                url: '#',
                                raw_url: app.path.replace('./', ''),
                                pages_url: app.path.replace('./', ''),
                                metadata: {
                                    title: app.title,
                                    description: app.description,
                                    icon: app.icon,
                                    tags: app.tags
                                }
                            }));
                            
                            galleryData = {
                                repo: {
                                    owner: REPO_OWNER,
                                    name: REPO_NAME,
                                    branch: BRANCH,
                                    url: `https://github.com/${REPO_OWNER}/${REPO_NAME}`
                                },
                                mainFiles: files.filter(f => !f.path.includes('archive/')),
                                archiveFiles: files.filter(f => f.path.includes('archive/'))
                            };
                            
                            displayGallery(galleryData);
                            return;
                        }
                    } catch (e) {
                        console.log('Local config not found, falling back to GitHub API');
                    }
                }
                
                const apiUrl = `https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/git/trees/${BRANCH}?recursive=1`;
                
                const response = await fetch(apiUrl);
                
                if (!response.ok) {
                    throw new Error(`GitHub API error: ${response.status}`);
                }
                
                const data = await response.json();
                
                // Separate main files and archive files
                const mainFiles = [];
                const archiveFiles = [];
                
                data.tree.forEach(item => {
                    if (item.type === 'blob' && 
                        (item.path.endsWith('.html') || item.path.endsWith('.htm'))) {
                        
                        const file = {
                            path: item.path,
                            url: `https://github.com/${REPO_OWNER}/${REPO_NAME}/blob/${BRANCH}/${item.path}`,
                            raw_url: `https://raw.githubusercontent.com/${REPO_OWNER}/${REPO_NAME}/${BRANCH}/${item.path}`,
                            // Add appropriate URL based on environment
                            pages_url: getFileUrl(item.path)
                        };
                        
                        // Check if file is in archive
                        if (item.path.includes('archive/')) {
                            archiveFiles.push(file);
                        } else {
                            // Exclude gallery-related files
                            const filename = item.path.split('/').pop().toLowerCase();
                            const excludeFiles = ['index.html', 'template.html', 'example.html', 'test.html', 'gallery.html'];
                            if (!excludeFiles.includes(filename)) {
                                mainFiles.push(file);
                            }
                        }
                    }
                });
                
                // Store gallery data globally
                galleryData = {
                    repo: {
                        owner: REPO_OWNER,
                        name: REPO_NAME,
                        branch: BRANCH,
                        url: `https://github.com/${REPO_OWNER}/${REPO_NAME}`
                    },
                    mainFiles: mainFiles,
                    archiveFiles: archiveFiles
                };
                
                // Display gallery
                displayGallery(galleryData);
                
            } catch (error) {
                console.error("Error fetching repository:", error);
                mainContent.innerHTML = `
                    <div class="error">
                        <strong>Exhibition Temporarily Closed</strong><br>
                        ${error.message}
                    </div>
                `;
            }
        }
        
        // Sort files by votes and pinned status
        function sortFiles(files) {
            const pinned = getPinnedTools();
            const votes = getVotes();
            
            return files.sort((a, b) => {
                // First priority: pinned items
                const aPinned = pinned.includes(a.path);
                const bPinned = pinned.includes(b.path);
                if (aPinned && !bPinned) return -1;
                if (!aPinned && bPinned) return 1;
                
                // Second priority: vote count
                const aVotes = votes[a.path]?.count || 0;
                const bVotes = votes[b.path]?.count || 0;
                if (aVotes !== bVotes) return bVotes - aVotes;
                
                // Third priority: alphabetical by title
                const aTitle = generateArtworkMetadata(a).title;
                const bTitle = generateArtworkMetadata(b).title;
                return aTitle.localeCompare(bTitle);
            });
        }
        
        // Current category filter
        let currentCategory = 'all';
        
        // Display gallery content with category support
        function displayGallery(data) {
            mainContent.innerHTML = '';
            
            const files = currentView === 'main' ? data.mainFiles : data.archiveFiles;
            if (!files || files.length === 0) {
                mainContent.innerHTML = `
                    <div class="error">
                        <strong>No items in ${currentView === 'main' ? 'main gallery' : 'archive'}</strong>
                    </div>
                `;
                return;
            }
            
            // Add statistics section
            const statsContainer = document.createElement('div');
            statsContainer.className = 'gallery-stats';
            
            // Calculate statistics
            const totalApps = files.length;
            const uniqueCategories = new Set(files.map(f => generateArtworkMetadata(f).category));
            const totalCategories = uniqueCategories.size;
            const totalVotes = Object.values(getVotes()).reduce((sum, v) => sum + (v.count || 0), 0);
            
            statsContainer.innerHTML = `
                <div class="stat-row">
                    <div class="stat">
                        <div class="stat-value">${totalApps}</div>
                        <div class="stat-label">Total Apps</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value">${totalCategories}</div>
                        <div class="stat-label">Categories</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value">${totalVotes}</div>
                        <div class="stat-label">Community Votes</div>
                    </div>
                </div>
            `;
            
            mainContent.appendChild(statsContainer);
            
            // Add category filters
            const categoryContainer = document.createElement('div');
            categoryContainer.className = 'category-filters';
            
            // Count apps by category
            const categoryCounts = {};
            files.forEach(file => {
                const metadata = generateArtworkMetadata(file);
                const category = metadata.category || 'other';
                categoryCounts[category] = (categoryCounts[category] || 0) + 1;
            });
            
            // Create category buttons
            const categoryButtons = [
                { id: 'all', label: 'All Apps', icon: '🌐' },
                { id: 'games', label: 'Games', icon: '🎮' },
                { id: 'ai-tools', label: 'AI Tools', icon: '🤖' },
                { id: 'productivity', label: 'Productivity', icon: '📝' },
                { id: 'business', label: 'Business', icon: '💼' },
                { id: 'media', label: 'Media', icon: '🎬' },
                { id: 'development', label: 'Development', icon: '💻' },
                { id: 'education', label: 'Education', icon: '📚' },
                { id: 'health', label: 'Health', icon: '🧘' },
                { id: 'utilities', label: 'Utilities', icon: '🔧' }
            ];
            
            categoryButtons.forEach(cat => {
                const count = cat.id === 'all' ? files.length : (categoryCounts[cat.id] || 0);
                if (count > 0 || cat.id === 'all') {
                    const button = document.createElement('button');
                    button.className = `category-filter ${currentCategory === cat.id ? 'active' : ''}`;
                    button.innerHTML = `
                        <span>${cat.icon}</span>
                        <span>${cat.label}</span>
                        <span class="count">${count}</span>
                    `;
                    button.onclick = () => {
                        currentCategory = cat.id;
                        displayGallery(data);
                    };
                    categoryContainer.appendChild(button);
                }
            });
            
            mainContent.appendChild(categoryContainer);
            
            // Filter files by category
            let filteredFiles = files;
            if (currentCategory !== 'all') {
                filteredFiles = files.filter(file => {
                    const metadata = generateArtworkMetadata(file);
                    return metadata.category === currentCategory;
                });
            }
            
            // Sort files
            const sortedFiles = sortFiles(filteredFiles);
            const pinned = getPinnedTools();
            const votes = getVotes();
            const userVotes = getUserVotes();
            
            // Create sections
            const pinnedFiles = sortedFiles.filter(f => pinned.includes(f.path));
            const unpinnedFiles = sortedFiles.filter(f => !pinned.includes(f.path));
            
            // Display pinned section if there are pinned items
            if (pinnedFiles.length > 0 && currentView === 'main') {
                const pinnedSection = createSection('Pinned Tools', pinnedFiles, true);
                mainContent.appendChild(pinnedSection);
            }
            
            // Display main section
            const categoryLabel = currentCategory === 'all' ? '' : 
                categoryButtons.find(c => c.id === currentCategory)?.label || '';
            const sectionTitle = currentView === 'main' ? 
                (categoryLabel || (pinnedFiles.length > 0 ? 'All Tools' : 'Creative Tools')) : 
                'Archive';
            const mainSection = createSection(sectionTitle, unpinnedFiles, false);
            mainContent.appendChild(mainSection);
            
            // Add event listeners
            addEventListeners();
            
            // Restore search term if any
            if (searchInput.value) {
                filterArtworks(searchInput.value.toLowerCase());
            }
        }
        
        function createSection(title, files, isPinnedSection = false) {
            const section = document.createElement('div');
            section.className = 'exhibition-section';
            
            const sectionTitle = document.createElement('h2');
            sectionTitle.className = 'section-title';
            sectionTitle.textContent = title;
            section.appendChild(sectionTitle);
            
            const artworkGrid = document.createElement('div');
            artworkGrid.className = 'artwork-grid';
            
            const pinned = getPinnedTools();
            const votes = getVotes();
            const userVotes = getUserVotes();
            
            files.forEach(file => {
                const metadata = generateArtworkMetadata(file);
                const filename = file.path.split('/').pop();
                const fileVotes = votes[file.path]?.count || 0;
                const hasVoted = userVotes[file.path] || false;
                const isPinned = pinned.includes(file.path);
                
                const artworkFrame = document.createElement('div');
                artworkFrame.className = 'artwork-frame' + (isPinned ? ' pinned' : '');
                
                // Add data attributes for enhanced search
                artworkFrame.dataset.category = metadata.category || '';
                artworkFrame.dataset.tags = (metadata.tags || []).join(' ');
                
                artworkFrame.innerHTML = `
                    <button class="pin-button ${isPinned ? 'pinned' : ''}" data-file="${file.path}" title="${isPinned ? 'Unpin' : 'Pin to top'}">
                        📌
                    </button>
                    <div class="artwork-preview">
                        ${metadata.icon}
                    </div>
                    <h3 class="artwork-title">${metadata.title}</h3>
                    <p class="artwork-description">${metadata.description}</p>
                    <div class="artwork-stats">
                        <div class="stat-item">
                            <span>👍</span>
                            <span class="vote-count" data-file="${file.path}">${fileVotes}</span>
                            <span>votes</span>
                        </div>
                    </div>
                    <div class="artwork-actions">
                        <button class="view-button" data-url="${file.pages_url}" data-title="${metadata.title}" data-filename="${filename}">View</button>
                        <button class="vote-button ${hasVoted ? 'voted' : ''}" data-file="${file.path}">${hasVoted ? 'Voted' : 'Vote'}</button>
                        <button class="download-button" data-url="${file.raw_url}" data-filename="${filename}" title="Download complete app as HTML file">Save Offline</button>
                    </div>
                `;
                
                artworkGrid.appendChild(artworkFrame);
            });
            
            section.appendChild(artworkGrid);
            return section;
        }
        
        // Add event listeners for buttons
        function addEventListeners() {
            // Pin buttons
            const pinButtons = document.querySelectorAll('.pin-button');
            pinButtons.forEach(button => {
                button.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const fileId = button.dataset.file;
                    const file = [...galleryData.mainFiles, ...galleryData.archiveFiles]
                        .find(f => f.path === fileId);
                    if (file) {
                        togglePin(file);
                    }
                });
            });
            
            // Vote buttons
            const voteButtons = document.querySelectorAll('.vote-button');
            voteButtons.forEach(button => {
                button.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const fileId = button.dataset.file;
                    const userVotes = getUserVotes();
                    
                    if (userVotes[fileId]) {
                        showToast('You have already voted for this tool', 'error');
                        return;
                    }
                    
                    const file = [...galleryData.mainFiles, ...galleryData.archiveFiles]
                        .find(f => f.path === fileId);
                    if (file) {
                        openVotePopup(file);
                    }
                });
            });
            
            // View buttons
            const viewButtons = document.querySelectorAll('.view-button');
            viewButtons.forEach(button => {
                button.addEventListener('click', (e) => {
                    e.stopPropagation();
                    // Open GitHub Pages URL directly
                    window.open(button.dataset.url, '_blank');
                });
            });
            
            // Download buttons
            const downloadButtons = document.querySelectorAll('.download-button');
            downloadButtons.forEach(button => {
                button.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    try {
                        await downloadHtmlFile(button.dataset.url, button.dataset.filename);
                    } catch (error) {
                        showToast(`Error downloading: ${error.message}`, 'error');
                    }
                });
            });
            
            // Artwork frame clicks
            const artworkFrames = document.querySelectorAll('.artwork-frame');
            artworkFrames.forEach(frame => {
                frame.addEventListener('click', (e) => {
                    // Don't trigger if clicking on a button
                    if (e.target.tagName !== 'BUTTON' && !e.target.closest('button')) {
                        const viewButton = frame.querySelector('.view-button');
                        if (viewButton) {
                            // Open GitHub Pages URL directly
                            window.open(viewButton.dataset.url, '_blank');
                        }
                    }
                });
            });
        }
        
        // Download HTML file
        async function downloadHtmlFile(url, filename) {
            try {
                // Determine if we need to fetch locally or from GitHub
                let fetchUrl = url;
                
                // If the URL doesn't start with http, it's a local path
                if (!url.startsWith('http')) {
                    // For local files, ensure we have the correct relative path
                    fetchUrl = url.startsWith('/') ? url.substring(1) : url;
                }
                
                const response = await fetch(fetchUrl);
                if (!response.ok) {
                    throw new Error(`Failed to fetch (${response.status})`);
                }
                
                const htmlContent = await response.text();
                
                // Create a complete standalone HTML file
                const blob = new Blob([htmlContent], { type: 'text/html;charset=utf-8' });
                const blobUrl = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = blobUrl;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                
                window.URL.revokeObjectURL(blobUrl);
                document.body.removeChild(a);
                
                showToast(`${filename} downloaded successfully - open it directly in your browser to use offline!`);
            } catch (error) {
                console.error('Error downloading:', error);
                throw error;
            }
        }
        
        // Initialize 3D Gallery
        function init3DGallery(data) {
            if (threeScene) {
                threeScene.cleanup();
            }
            
            // Use only main files for 3D gallery
            const galleryDataFor3D = {
                ...data,
                files: data.mainFiles
            };
            
            threeScene = new MinecraftGallery(galleryDataFor3D);
            threeScene.init();
        }
        
        // Minecraft-style 3D Gallery Class
        class MinecraftGallery {
            constructor(data) {
                this.data = data;
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.artworks = [];
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                this.moveSpeed = 0.2;
                this.lookSpeed = 0.002;
                
                // Movement state
                this.keys = {
                    w: false,
                    a: false,
                    s: false,
                    d: false
                };
                
                // Camera rotation
                this.rotation = {
                    x: 0,
                    y: 0
                };
                
                // Mobile controls
                this.isMobile = isMobile;
                this.touches = {
                    start: null,
                    current: null,
                    joystick: null
                };
                this.joystickActive = false;
                this.joystickVector = new THREE.Vector2();
                
                this.isPointerLocked = false;
                this.hoveredArtwork = null;
                this.tooltip = document.getElementById('artwork-tooltip');
                this.tooltipTitle = this.tooltip.querySelector('.tooltip-title');
                this.tooltipDescription = this.tooltip.querySelector('.tooltip-description');
            }
            
            init() {
                // Scene setup
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.Fog(0x000000, 10, 100);
                
                // Camera
                this.camera = new THREE.PerspectiveCamera(
                    75, 
                    window.innerWidth / window.innerHeight, 
                    0.1, 
                    1000
                );
                this.camera.position.set(0, 2, 10);
                
                // Renderer
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                threeContainer.appendChild(this.renderer.domElement);
                
                // Lighting
                this.setupLighting();
                
                // Create gallery
                this.createGallery();
                
                // Event listeners
                this.setupEventListeners();
                
                // Update controls hint
                const controlsHint = document.getElementById('controls-hint');
                if (this.isMobile) {
                    controlsHint.textContent = 'Swipe to look around, Use joystick to move, Tap on artworks to view';
                    document.getElementById('mobile-controls').classList.add('show');
                }
                
                // Start animation
                this.animate();
            }
            
            setupLighting() {
                // Ambient light
                const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
                this.scene.add(ambientLight);
                
                // Directional light (sun)
                const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
                dirLight.position.set(10, 20, 10);
                dirLight.castShadow = true;
                dirLight.shadow.camera.near = 0.1;
                dirLight.shadow.camera.far = 50;
                dirLight.shadow.camera.left = -50;
                dirLight.shadow.camera.right = 50;
                dirLight.shadow.camera.top = 50;
                dirLight.shadow.camera.bottom = -50;
                this.scene.add(dirLight);
                
                // Point lights for artwork
                const colors = [0xff00ff, 0x00ffff, 0xffff00];
                colors.forEach((color, i) => {
                    const light = new THREE.PointLight(color, 0.5, 10);
                    light.position.set(i * 10 - 10, 3, 0);
                    this.scene.add(light);
                });
            }
            
            createGallery() {
                // Create floor
                const floorGeometry = new THREE.BoxGeometry(100, 1, 100);
                const floorMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x333333,
                    emissive: 0x111111
                });
                const floor = new THREE.Mesh(floorGeometry, floorMaterial);
                floor.position.y = -0.5;
                floor.receiveShadow = true;
                this.scene.add(floor);
                
                // Create walls
                this.createWalls();
                
                // Create artworks
                this.createArtworks();
                
                // Add some decorative cubes
                this.addDecorations();
            }
            
            createWalls() {
                const wallMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x666666,
                    emissive: 0x222222
                });
                
                // Back wall
                const backWall = new THREE.Mesh(
                    new THREE.BoxGeometry(100, 20, 1),
                    wallMaterial
                );
                backWall.position.set(0, 10, -50);
                backWall.castShadow = true;
                backWall.receiveShadow = true;
                this.scene.add(backWall);
                
                // Side walls
                const leftWall = new THREE.Mesh(
                    new THREE.BoxGeometry(1, 20, 100),
                    wallMaterial
                );
                leftWall.position.set(-50, 10, 0);
                leftWall.castShadow = true;
                leftWall.receiveShadow = true;
                this.scene.add(leftWall);
                
                const rightWall = new THREE.Mesh(
                    new THREE.BoxGeometry(1, 20, 100),
                    wallMaterial
                );
                rightWall.position.set(50, 10, 0);
                rightWall.castShadow = true;
                rightWall.receiveShadow = true;
                this.scene.add(rightWall);
            }
            
            createTextSprite(text, fontSize = 0.5) {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 256;
                
                context.fillStyle = 'rgba(0, 0, 0, 0)';
                context.fillRect(0, 0, canvas.width, canvas.height);
                
                context.font = `${canvas.width * fontSize}px Arial`;
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillStyle = 'white';
                
                // For emoji, we need to handle them differently
                if (text.length <= 2 && /\p{Emoji}/u.test(text)) {
                    context.font = `${canvas.width * fontSize * 0.8}px Arial`;
                }
                
                context.fillText(text, canvas.width / 2, canvas.height / 2);
                
                const texture = new THREE.CanvasTexture(canvas);
                texture.needsUpdate = true;
                
                const spriteMaterial = new THREE.SpriteMaterial({ 
                    map: texture,
                    transparent: true
                });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.scale.set(2, 2, 1);
                
                return sprite;
            }
            
            createArtworks() {
                const files = this.data.files || this.data.mainFiles || [];
                const numArtworks = Math.min(files.length, 20);
                
                for (let i = 0; i < numArtworks; i++) {
                    const file = files[i];
                    const metadata = generateArtworkMetadata(file);
                    
                    // Create artwork group
                    const artworkGroup = new THREE.Group();
                    
                    // Frame
                    const frameGeometry = new THREE.BoxGeometry(4, 3, 0.2);
                    const frameMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0x888888,
                        emissive: 0x444444
                    });
                    const frame = new THREE.Mesh(frameGeometry, frameMaterial);
                    
                    // Canvas (artwork) with random color
                    const canvasGeometry = new THREE.BoxGeometry(3.6, 2.6, 0.1);
                    const hue = Math.random();
                    const canvasMaterial = new THREE.MeshLambertMaterial({ 
                        color: new THREE.Color().setHSL(hue, 0.7, 0.5),
                        emissive: new THREE.Color().setHSL(hue, 0.7, 0.3),
                        emissiveIntensity: 0.5
                    });
                    const canvas = new THREE.Mesh(canvasGeometry, canvasMaterial);
                    canvas.position.z = 0.1;
                    frame.add(canvas);
                    
                    // Add emoji sprite to canvas
                    const emojiSprite = this.createTextSprite(metadata.icon, 0.4);
                    emojiSprite.position.z = 0.2;
                    canvas.add(emojiSprite);
                    
                    // Add title below frame
                    const titleSprite = this.createTextSprite(metadata.title.substring(0, 15) + (metadata.title.length > 15 ? '...' : ''), 0.15);
                    titleSprite.position.y = -2;
                    titleSprite.position.z = 0.5;
                    frame.add(titleSprite);
                    
                    artworkGroup.add(frame);
                    
                    // Position artwork
                    const angle = (i / numArtworks) * Math.PI * 2;
                    const radius = 20;
                    artworkGroup.position.x = Math.cos(angle) * radius;
                    artworkGroup.position.z = Math.sin(angle) * radius;
                    artworkGroup.position.y = 3;
                    artworkGroup.rotation.y = -angle + Math.PI;
                    
                    frame.castShadow = true;
                    frame.receiveShadow = true;
                    
                    // Store data for interaction - use GitHub Pages URL
                    frame.userData = {
                        url: file.pages_url,
                        title: metadata.title,
                        description: metadata.description,
                        filename: file.path.split('/').pop(),
                        icon: metadata.icon
                    };
                    
                    this.artworks.push(frame);
                    this.scene.add(artworkGroup);
                }
            }
            
            addDecorations() {
                const decorationMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x444444,
                    emissive: 0x222222
                });
                
                // Add some pillars
                for (let i = 0; i < 8; i++) {
                    const pillar = new THREE.Mesh(
                        new THREE.BoxGeometry(2, 10, 2),
                        decorationMaterial
                    );
                    
                    const angle = (i / 8) * Math.PI * 2;
                    pillar.position.x = Math.cos(angle) * 30;
                    pillar.position.z = Math.sin(angle) * 30;
                    pillar.position.y = 5;
                    
                    pillar.castShadow = true;
                    pillar.receiveShadow = true;
                    
                    this.scene.add(pillar);
                }
                
                // Add floating cubes
                for (let i = 0; i < 20; i++) {
                    const size = Math.random() * 0.5 + 0.5;
                    const cube = new THREE.Mesh(
                        new THREE.BoxGeometry(size, size, size),
                        new THREE.MeshLambertMaterial({ 
                            color: new THREE.Color().setHSL(Math.random(), 0.7, 0.5),
                            emissive: new THREE.Color().setHSL(Math.random(), 0.7, 0.3),
                            emissiveIntensity: 0.3
                        })
                    );
                    
                    cube.position.x = (Math.random() - 0.5) * 40;
                    cube.position.y = Math.random() * 10 + 10;
                    cube.position.z = (Math.random() - 0.5) * 40;
                    
                    cube.rotation.x = Math.random() * Math.PI * 2;
                    cube.rotation.y = Math.random() * Math.PI * 2;
                    
                    cube.userData.floatSpeed = Math.random() * 0.02 + 0.01;
                    cube.userData.rotateSpeed = Math.random() * 0.02 + 0.01;
                    
                    cube.castShadow = true;
                    
                    this.scene.add(cube);
                }
            }
            
            setupEventListeners() {
                if (this.isMobile) {
                    this.setupMobileControls();
                } else {
                    this.setupDesktopControls();
                }
                
                // Window resize
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }
            
            setupDesktopControls() {
                // Keyboard controls
                window.addEventListener('keydown', (e) => {
                    if (e.key.toLowerCase() in this.keys) {
                        this.keys[e.key.toLowerCase()] = true;
                    }
                });
                
                window.addEventListener('keyup', (e) => {
                    if (e.key.toLowerCase() in this.keys) {
                        this.keys[e.key.toLowerCase()] = false;
                    }
                });
                
                // Mouse controls
                this.renderer.domElement.addEventListener('click', () => {
                    if (!this.isPointerLocked) {
                        this.renderer.domElement.requestPointerLock();
                    }
                });
                
                document.addEventListener('pointerlockchange', () => {
                    this.isPointerLocked = document.pointerLockElement === this.renderer.domElement;
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (this.isPointerLocked) {
                        this.rotation.y -= e.movementX * this.lookSpeed;
                        this.rotation.x -= e.movementY * this.lookSpeed;
                        this.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.rotation.x));
                    }
                });
                
                // Click on artwork
                this.renderer.domElement.addEventListener('click', (e) => {
                    if (!this.isPointerLocked) return;
                    
                    this.raycaster.setFromCamera(new THREE.Vector2(0, 0), this.camera);
                    const intersects = this.raycaster.intersectObjects(this.artworks, true);
                    
                    if (intersects.length > 0) {
                        const artwork = intersects[0].object.parent || intersects[0].object;
                        if (artwork.userData && artwork.userData.url) {
                            // Open GitHub Pages URL directly
                            window.open(artwork.userData.url, '_blank');
                        }
                    }
                });
            }
            
            setupMobileControls() {
                const canvas = this.renderer.domElement;
                
                // Touch start
                canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    this.touches.start = {
                        x: touch.clientX,
                        y: touch.clientY
                    };
                    this.touches.current = {...this.touches.start};
                });
                
                // Touch move - camera rotation
                canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (!this.touches.start) return;
                    
                    const touch = e.touches[0];
                    const deltaX = touch.clientX - this.touches.current.x;
                    const deltaY = touch.clientY - this.touches.current.y;
                    
                    this.rotation.y -= deltaX * this.lookSpeed * 2;
                    this.rotation.x -= deltaY * this.lookSpeed * 2;
                    this.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.rotation.x));
                    
                    this.touches.current = {
                        x: touch.clientX,
                        y: touch.clientY
                    };
                });
                
                // Touch end
                canvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    
                    // Check if it was a tap
                    if (this.touches.start && this.touches.current) {
                        const dx = this.touches.current.x - this.touches.start.x;
                        const dy = this.touches.current.y - this.touches.start.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < 10) {
                            // It's a tap - check for artwork
                            // Convert touch coordinates to normalized device coordinates
                            const rect = canvas.getBoundingClientRect();
                            const x = ((this.touches.start.x - rect.left) / rect.width) * 2 - 1;
                            const y = -((this.touches.start.y - rect.top) / rect.height) * 2 + 1;
                            
                            this.raycaster.setFromCamera(new THREE.Vector2(x, y), this.camera);
                            const intersects = this.raycaster.intersectObjects(this.artworks, true);
                            
                            if (intersects.length > 0) {
                                const artwork = intersects[0].object.parent || intersects[0].object;
                                if (artwork.userData && artwork.userData.url) {
                                    // Open GitHub Pages URL directly
                                    window.open(artwork.userData.url, '_blank');
                                }
                            }
                        }
                    }
                    
                    this.touches.start = null;
                    this.touches.current = null;
                });
                
                // Joystick controls
                const joystick = document.getElementById('movement-joystick');
                const handle = document.getElementById('movement-handle');
                
                joystick.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.joystickActive = true;
                    this.updateJoystick(e.touches[0], joystick, handle);
                });
                
                joystick.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (this.joystickActive) {
                        this.updateJoystick(e.touches[0], joystick, handle);
                    }
                });
                
                joystick.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.joystickActive = false;
                    this.joystickVector.set(0, 0);
                    handle.style.transform = 'translate(-50%, -50%)';
                });
            }
            
            updateJoystick(touch, joystick, handle) {
                const rect = joystick.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                let deltaX = touch.clientX - centerX;
                let deltaY = touch.clientY - centerY;
                
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                const maxDistance = rect.width / 2 - 25; // handle radius
                
                if (distance > maxDistance) {
                    deltaX = (deltaX / distance) * maxDistance;
                    deltaY = (deltaY / distance) * maxDistance;
                }
                
                handle.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;
                
                this.joystickVector.x = deltaX / maxDistance;
                this.joystickVector.y = -deltaY / maxDistance;
            }
            
            updateHover() {
                // Cast ray from camera center
                this.raycaster.setFromCamera(new THREE.Vector2(0, 0), this.camera);
                const intersects = this.raycaster.intersectObjects(this.artworks, true);
                
                if (intersects.length > 0) {
                    const artwork = intersects[0].object.parent || intersects[0].object;
                    
                    if (artwork.userData && artwork.userData.title && artwork !== this.hoveredArtwork) {
                        this.hoveredArtwork = artwork;
                        
                        // Show tooltip
                        this.tooltipTitle.textContent = `${artwork.userData.icon} ${artwork.userData.title}`;
                        this.tooltipDescription.textContent = artwork.userData.description;
                        this.tooltip.classList.add('visible');
                        
                        // Position tooltip
                        const vector = new THREE.Vector3();
                        artwork.getWorldPosition(vector);
                        vector.project(this.camera);
                        
                        const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                        const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
                        
                        this.tooltip.style.left = `${Math.min(x + 20, window.innerWidth - 420)}px`;
                        this.tooltip.style.top = `${Math.min(y - 50, window.innerHeight - 250)}px`;
                    }
                } else {
                    if (this.hoveredArtwork) {
                        this.hoveredArtwork = null;
                        this.tooltip.classList.remove('visible');
                    }
                }
            }
            
            updateMovement() {
                const forward = new THREE.Vector3();
                const right = new THREE.Vector3();
                
                this.camera.getWorldDirection(forward);
                forward.y = 0;
                forward.normalize();
                
                right.crossVectors(forward, new THREE.Vector3(0, 1, 0));
                
                if (this.isMobile) {
                    // Mobile joystick movement
                    if (this.joystickActive) {
                        const moveForward = forward.multiplyScalar(this.joystickVector.y * this.moveSpeed);
                        const moveRight = right.multiplyScalar(this.joystickVector.x * this.moveSpeed);
                        this.camera.position.add(moveForward);
                        this.camera.position.add(moveRight);
                    }
                } else {
                    // Desktop keyboard movement
                    if (this.keys.w) this.camera.position.add(forward.multiplyScalar(this.moveSpeed));
                    if (this.keys.s) this.camera.position.add(forward.multiplyScalar(-this.moveSpeed));
                    if (this.keys.a) this.camera.position.add(right.multiplyScalar(-this.moveSpeed));
                    if (this.keys.d) this.camera.position.add(right.multiplyScalar(this.moveSpeed));
                }
                
                // Update camera rotation
                this.camera.rotation.order = 'YXZ';
                this.camera.rotation.y = this.rotation.y;
                this.camera.rotation.x = this.rotation.x;
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                // Update movement
                this.updateMovement();
                
                // Update hover detection
                this.updateHover();
                
                // Animate floating cubes
                this.scene.children.forEach(child => {
                    if (child.userData.floatSpeed) {
                        child.position.y += Math.sin(Date.now() * child.userData.floatSpeed) * 0.01;
                        child.rotation.x += child.userData.rotateSpeed;
                        child.rotation.y += child.userData.rotateSpeed * 0.7;
                    }
                });
                
                this.renderer.render(this.scene, this.camera);
            }
            
            cleanup() {
                if (this.renderer) {
                    threeContainer.removeChild(this.renderer.domElement);
                    this.renderer.dispose();
                }
                
                // Hide tooltip
                this.tooltip.classList.remove('visible');
                
                // Hide mobile controls
                document.getElementById('mobile-controls').classList.remove('show');
                
                // Exit pointer lock
                if (document.pointerLockElement) {
                    document.exitPointerLock();
                }
                
                // Remove event listeners
                window.removeEventListener('keydown', this.handleKeyDown);
                window.removeEventListener('keyup', this.handleKeyUp);
            }
        }
        
        // Initialize gallery
        window.addEventListener('DOMContentLoaded', () => {
            // Show environment info
            if (isLocal) {
                console.log('🏠 Running in LOCAL mode - will use local file paths');
                showToast('Running locally - using local file paths', 'success');
            } else {
                console.log('🌐 Running in PRODUCTION mode - will use GitHub Pages URLs');
            }
            
            fetchRepoFiles();
        });

        // iPhone Launcher functionality
        const viewToggle = document.getElementById('viewToggle');
        const viewToggleText = document.getElementById('viewToggleText');
        const galleryContainer = document.getElementById('galleryContainer');
        const launcherContainer = document.getElementById('launcherContainer');
        const launcherSearch = document.getElementById('launcherSearch');
        const appGrid = document.getElementById('appGrid');
        const dock = document.getElementById('dock');

        // Load view preference from localStorage
        let launcherView = localStorage.getItem('preferredView') || 'gallery';
        
        // Cache apps data
        let cachedApps = JSON.parse(localStorage.getItem('cachedApps') || '[]');
        let lastCacheTime = parseInt(localStorage.getItem('lastCacheTime') || '0');
        const CACHE_DURATION = 24 * 60 * 60 * 1000; // 24 hours

        // Initialize view
        function initializeView() {
            if (launcherView === 'launcher') {
                showLauncher();
            } else {
                showGallery();
            }
        }

        // Toggle between views
        viewToggle.addEventListener('click', () => {
            if (launcherView === 'gallery') {
                showLauncher();
            } else {
                showGallery();
            }
        });

        function showGallery() {
            galleryContainer.classList.remove('hidden');
            launcherContainer.classList.remove('active');
            viewToggleText.textContent = 'App Launcher';
            viewToggle.querySelector('.view-toggle-icon').textContent = '📱';
            launcherView = 'gallery';
            localStorage.setItem('preferredView', 'gallery');
            dock.style.display = 'none';
        }

        function showLauncher() {
            galleryContainer.classList.add('hidden');
            launcherContainer.classList.add('active');
            viewToggleText.textContent = 'Gallery View';
            viewToggle.querySelector('.view-toggle-icon').textContent = '🎨';
            launcherView = 'launcher';
            localStorage.setItem('preferredView', 'launcher');
            dock.style.display = 'flex';
            
            // Load apps if not already loaded
            if (appGrid.children.length === 0) {
                loadLauncherApps();
            }
        }

        // Load apps for launcher
        async function loadLauncherApps() {
            // Check cache
            const now = Date.now();
            if (cachedApps.length > 0 && (now - lastCacheTime) < CACHE_DURATION) {
                renderLauncherApps(cachedApps);
            } else {
                // Fetch fresh data
                try {
                    const response = await fetch('./data/config/utility_apps_config.json');
                    const data = await response.json();
                    cachedApps = data.apps || [];
                    localStorage.setItem('cachedApps', JSON.stringify(cachedApps));
                    localStorage.setItem('lastCacheTime', now.toString());
                    renderLauncherApps(cachedApps);
                } catch (error) {
                    console.error('Error loading apps:', error);
                    // Fall back to cached data if available
                    if (cachedApps.length > 0) {
                        renderLauncherApps(cachedApps);
                    }
                }
            }
        }

        // Render apps in launcher
        function renderLauncherApps(apps) {
            appGrid.innerHTML = '';
            
            // Sort apps by category then by title
            apps.sort((a, b) => {
                const categoryOrder = ['productivity', 'business', 'ai-tools', 'development', 'games', 'media', 'education', 'health', 'utilities'];
                const catA = categoryOrder.indexOf(a.tags?.[0] || 'utilities');
                const catB = categoryOrder.indexOf(b.tags?.[0] || 'utilities');
                if (catA !== catB) return catA - catB;
                return a.title.localeCompare(b.title);
            });

            apps.forEach(app => {
                const appIcon = createAppIcon(app);
                appGrid.appendChild(appIcon);
            });

            // Load favorites to dock
            loadFavoritesToDock();
        }

        // Create app icon element
        function createAppIcon(app) {
            const iconDiv = document.createElement('div');
            iconDiv.className = 'app-icon';
            iconDiv.dataset.category = app.tags?.[0] || 'utilities';
            iconDiv.dataset.appId = app.id;
            iconDiv.dataset.path = app.path;
            
            const iconImage = document.createElement('div');
            iconImage.className = 'app-icon-image';
            iconImage.textContent = app.icon || '📄';
            
            const iconLabel = document.createElement('div');
            iconLabel.className = 'app-icon-label';
            // Clean up the title - remove prefixes and make it shorter
            let cleanTitle = app.title
                .replace(/^[A-Z\s]+-\s*/, '') // Remove prefix like "AI - "
                .replace(/^.*?:\s*/, '') // Remove anything before colon
                .replace(/^.*?-\s*/, '') // Remove anything before dash
                .trim();
            // If still too long or generic, use a shorter version
            if (cleanTitle.length > 20 || cleanTitle.includes('Interactive Assistant')) {
                cleanTitle = cleanTitle.substring(0, 15) + '...';
            }
            // Special handling for common patterns
            if (app.title.includes('Interactive Assistant')) {
                cleanTitle = app.tags?.[0] ? app.tags[0].charAt(0).toUpperCase() + app.tags[0].slice(1) : 'Assistant';
            }
            if (app.title.includes('Chat Application')) {
                cleanTitle = 'Chat';
            }
            if (app.title.includes('Vibe Coding Gallery')) {
                cleanTitle = 'Gallery';
            }
            iconLabel.textContent = cleanTitle;
            
            iconDiv.appendChild(iconImage);
            iconDiv.appendChild(iconLabel);
            
            // Click to launch app
            iconDiv.addEventListener('click', () => launchApp(app));
            
            // Long press to add to favorites (mobile)
            let pressTimer;
            iconDiv.addEventListener('touchstart', (e) => {
                pressTimer = setTimeout(() => {
                    toggleFavorite(app);
                    e.preventDefault();
                }, 500);
            });
            
            iconDiv.addEventListener('touchend', () => {
                clearTimeout(pressTimer);
            });
            
            // Right click to add to favorites (desktop)
            iconDiv.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                toggleFavorite(app);
            });
            
            return iconDiv;
        }

        // Launch app
        function launchApp(app) {
            // Store last launched apps
            let recentApps = JSON.parse(localStorage.getItem('recentApps') || '[]');
            recentApps = recentApps.filter(a => a.id !== app.id);
            recentApps.unshift(app);
            recentApps = recentApps.slice(0, 10); // Keep last 10
            localStorage.setItem('recentApps', JSON.stringify(recentApps));
            
            // Open app in same tab
            window.location.href = app.path;
        }

        // Manage favorites
        function toggleFavorite(app) {
            let favorites = JSON.parse(localStorage.getItem('favoriteApps') || '[]');
            const index = favorites.findIndex(f => f.id === app.id);
            
            if (index > -1) {
                favorites.splice(index, 1);
                showNotification(`Removed ${app.title} from favorites`);
            } else {
                if (favorites.length < 5) { // Limit dock to 5 apps
                    favorites.push(app);
                    showNotification(`Added ${app.title} to favorites`);
                } else {
                    showNotification('Dock is full (max 5 apps)');
                }
            }
            
            localStorage.setItem('favoriteApps', JSON.stringify(favorites));
            loadFavoritesToDock();
        }

        // Load favorites to dock
        function loadFavoritesToDock() {
            const favorites = JSON.parse(localStorage.getItem('favoriteApps') || '[]');
            dock.innerHTML = '';
            
            favorites.forEach(app => {
                const dockItem = document.createElement('div');
                dockItem.className = 'dock-item';
                dockItem.textContent = app.icon || '📄';
                dockItem.title = app.title;
                dockItem.addEventListener('click', () => launchApp(app));
                dock.appendChild(dockItem);
            });
            
            // Add home button to dock
            const homeButton = document.createElement('div');
            homeButton.className = 'dock-item';
            homeButton.textContent = '🏠';
            homeButton.title = 'Home';
            homeButton.style.background = 'linear-gradient(145deg, #4dabf7, #1971c2)';
            homeButton.addEventListener('click', () => {
                window.location.reload();
            });
            dock.appendChild(homeButton);
        }

        // Search functionality for launcher
        launcherSearch.addEventListener('input', (e) => {
            const searchTerm = e.target.value.toLowerCase();
            const appIcons = appGrid.querySelectorAll('.app-icon');
            
            appIcons.forEach(icon => {
                const label = icon.querySelector('.app-icon-label').textContent.toLowerCase();
                const category = icon.dataset.category;
                
                if (label.includes(searchTerm) || category.includes(searchTerm)) {
                    icon.style.display = 'flex';
                } else {
                    icon.style.display = 'none';
                }
            });
        });

        // Show notification
        function showNotification(message) {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 80px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(28,28,30,0.95);
                color: white;
                padding: 12px 24px;
                border-radius: 8px;
                z-index: 10000;
                animation: slideDown 0.3s ease;
                backdrop-filter: blur(10px);
            `;
            notification.textContent = message;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.animation = 'slideUp 0.3s ease';
                setTimeout(() => notification.remove(), 300);
            }, 2000);
        }

        // Add animations
        const style = document.createElement('style');
        style.textContent = `
            @keyframes slideDown {
                from { transform: translate(-50%, -20px); opacity: 0; }
                to { transform: translate(-50%, 0); opacity: 1; }
            }
            @keyframes slideUp {
                from { transform: translate(-50%, 0); opacity: 1; }
                to { transform: translate(-50%, -20px); opacity: 0; }
            }
        `;
        document.head.appendChild(style);

        // Initialize on load
        initializeView();
    </script>
</body>
</html>