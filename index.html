<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Vibe Coding Gallery</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #000;
            color: #fff;
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }

        /* Animated background */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 50%, rgba(120, 30, 255, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(255, 30, 120, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 40% 10%, rgba(30, 255, 120, 0.3) 0%, transparent 50%);
            animation: drift 20s ease-in-out infinite;
            z-index: -1;
        }

        @keyframes drift {
            0%, 100% { transform: scale(1) rotate(0deg); }
            33% { transform: scale(1.1) rotate(120deg); }
            66% { transform: scale(0.95) rotate(240deg); }
        }
        
        .header {
            padding: 60px 20px 40px;
            text-align: center;
            position: relative;
            background: linear-gradient(180deg, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0) 100%);
        }

        @media (max-width: 768px) {
            .header {
                padding: 40px 20px 30px;
            }
        }

        .gallery-title {
            font-size: 5em;
            font-weight: 100;
            letter-spacing: 0.2em;
            margin-bottom: 20px;
            text-transform: uppercase;
            position: relative;
            display: inline-block;
        }

        @media (max-width: 768px) {
            .gallery-title {
                font-size: 3em;
                letter-spacing: 0.1em;
            }
        }

        .gallery-title::before {
            content: 'VIBE CODING';
            position: absolute;
            left: 0;
            top: 0;
            background: linear-gradient(45deg, #ff006e, #8338ec, #3a86ff, #06ffa5);
            background-size: 400% 100%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: shimmer 8s ease-in-out infinite;
        }

        @keyframes shimmer {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .gallery-subtitle {
            font-size: 1.5em;
            font-weight: 200;
            color: rgba(255, 255, 255, 0.6);
            letter-spacing: 0.5em;
            text-transform: uppercase;
        }

        @media (max-width: 768px) {
            .gallery-subtitle {
                font-size: 1.2em;
                letter-spacing: 0.3em;
            }
        }

        .gallery-description {
            max-width: 600px;
            margin: 30px auto 0;
            color: rgba(255, 255, 255, 0.5);
            line-height: 1.6;
            font-weight: 300;
        }

        @media (max-width: 768px) {
            .gallery-description {
                margin: 20px auto 0;
                font-size: 0.95em;
            }
        }

        /* Search Box */
        .search-container {
            max-width: 600px;
            margin: 30px auto;
            position: relative;
        }

        .search-box {
            width: 100%;
            padding: 15px 50px 15px 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 30px;
            color: white;
            font-size: 1.1em;
            outline: none;
            transition: all 0.3s ease;
        }

        .search-box:focus {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .search-box::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .search-icon {
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            color: rgba(255, 255, 255, 0.5);
            pointer-events: none;
        }

        .gallery-modes {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        @media (max-width: 768px) {
            .gallery-modes {
                gap: 15px;
            }
        }

        .mode-button {
            padding: 15px 40px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 30px;
            color: white;
            cursor: pointer;
            font-size: 1.1em;
            letter-spacing: 0.1em;
            transition: all 0.3s ease;
            text-transform: uppercase;
            -webkit-appearance: none;
            appearance: none;
            touch-action: manipulation;
        }

        @media (max-width: 768px) {
            .mode-button {
                padding: 12px 30px;
                font-size: 1em;
            }
        }

        .mode-button:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(255, 255, 255, 0.1);
        }

        .mode-button:active {
            transform: scale(0.98);
        }

        .mode-button.active {
            background: linear-gradient(135deg, #ff006e, #8338ec);
            border: none;
        }

        .mode-button.vr-mode {
            background: linear-gradient(135deg, #ff006e, #8338ec);
            border: none;
        }

        .mode-button.vr-mode:hover {
            box-shadow: 0 10px 30px rgba(138, 43, 226, 0.5);
        }
        
        .content {
            padding: 40px 20px 80px;
            max-width: 1600px;
            margin: 0 auto;
        }

        .content.hidden {
            display: none;
        }
        
        .loading {
            text-align: center;
            padding: 100px;
            font-size: 1.2em;
            color: rgba(255, 255, 255, 0.4);
            font-weight: 200;
            letter-spacing: 0.1em;
        }

        .loading::after {
            content: '';
            display: block;
            width: 60px;
            height: 1px;
            background: linear-gradient(90deg, transparent, #fff, transparent);
            margin: 30px auto;
            animation: scan 2s linear infinite;
        }

        @keyframes scan {
            0% { transform: translateX(-100px); }
            100% { transform: translateX(100px); }
        }
        
        .error {
            color: #ff006e;
            padding: 30px;
            background: rgba(255, 0, 110, 0.1);
            border-radius: 20px;
            margin: 20px auto;
            border: 1px solid rgba(255, 0, 110, 0.2);
            max-width: 600px;
            text-align: center;
        }
        
        .exhibition-section {
            margin-bottom: 80px;
        }

        .section-title {
            font-size: 3em;
            font-weight: 100;
            text-align: center;
            margin-bottom: 50px;
            letter-spacing: 0.1em;
            position: relative;
            padding-bottom: 20px;
        }

        @media (max-width: 768px) {
            .section-title {
                font-size: 2em;
                margin-bottom: 30px;
            }
        }

        .section-title::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 100px;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.5), transparent);
        }
        
        .artwork-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(400px, 1fr));
            gap: 40px;
        }

        @media (max-width: 768px) {
            .artwork-grid {
                grid-template-columns: 1fr;
                gap: 20px;
            }
        }
        
        .artwork-frame {
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 20px;
            transition: all 0.5s ease;
            position: relative;
            overflow: hidden;
            cursor: pointer;
            min-height: 300px;
            display: flex;
            flex-direction: column;
        }

        .artwork-frame.pinned {
            border-color: #ff006e;
            background: rgba(255, 0, 110, 0.05);
        }

        .artwork-frame::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle at var(--mouse-x, 50%) var(--mouse-y, 50%), rgba(255, 255, 255, 0.1), transparent 40%);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        @media (hover: hover) {
            .artwork-frame:hover::before {
                opacity: 1;
            }

            .artwork-frame:hover {
                transform: translateY(-10px);
                background: rgba(255, 255, 255, 0.05);
                border-color: rgba(255, 255, 255, 0.2);
                box-shadow: 
                    0 20px 40px rgba(0, 0, 0, 0.5),
                    0 0 60px rgba(138, 43, 226, 0.2);
            }
        }

        @media (hover: none) {
            .artwork-frame:active {
                transform: scale(0.98);
                background: rgba(255, 255, 255, 0.05);
            }
        }

        .pin-button {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 0.6);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2em;
            transition: all 0.3s ease;
            z-index: 10;
        }

        .pin-button:hover {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            transform: scale(1.1);
        }

        .pin-button.pinned {
            background: #ff006e;
            border-color: #ff006e;
            color: white;
        }
        
        .artwork-preview {
            width: 100%;
            height: 200px;
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.1), rgba(0, 255, 255, 0.1));
            border-radius: 10px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 4em;
            position: relative;
            overflow: hidden;
        }

        .artwork-preview::after {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent 30%, rgba(255, 255, 255, 0.1) 50%, transparent 70%);
            animation: shine 3s ease-in-out infinite;
        }

        @keyframes shine {
            0% { transform: rotate(0deg) translateX(-100%); }
            100% { transform: rotate(0deg) translateX(100%); }
        }
        
        .artwork-title {
            font-size: 1.8em;
            font-weight: 200;
            margin-bottom: 10px;
            letter-spacing: 0.05em;
        }

        @media (max-width: 768px) {
            .artwork-title {
                font-size: 1.5em;
            }
        }
        
        .artwork-description {
            color: rgba(255, 255, 255, 0.6);
            line-height: 1.6;
            margin-bottom: 20px;
            flex-grow: 1;
            font-weight: 300;
        }

        .artwork-stats {
            display: flex;
            gap: 20px;
            margin-bottom: 15px;
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.5);
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .vote-count {
            color: #06ffa5;
        }
        
        .artwork-actions {
            display: flex;
            gap: 15px;
            margin-top: auto;
        }

        .view-button, .download-button, .vote-button {
            flex: 1;
            padding: 15px 25px;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 400;
            letter-spacing: 0.05em;
            transition: all 0.3s ease;
            text-transform: uppercase;
            -webkit-appearance: none;
            appearance: none;
            touch-action: manipulation;
        }

        .view-button {
            background: linear-gradient(135deg, #ff006e, #8338ec);
            color: white;
        }

        .view-button:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 30px rgba(138, 43, 226, 0.5);
        }

        .view-button:active {
            transform: scale(0.98);
        }

        .vote-button {
            background: transparent;
            color: #06ffa5;
            border: 1px solid #06ffa5;
            position: relative;
            overflow: hidden;
        }

        .vote-button:hover {
            background: rgba(6, 255, 165, 0.1);
            transform: scale(1.05);
        }

        .vote-button.voted {
            background: #06ffa5;
            color: #000;
        }

        .download-button {
            background: transparent;
            color: rgba(255, 255, 255, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .download-button:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .download-button:active {
            transform: scale(0.98);
        }

        /* Vote popup */
        .vote-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            z-index: 1000;
            display: none;
            backdrop-filter: blur(10px);
        }

        .vote-popup.show {
            display: block;
        }

        .vote-popup h3 {
            font-size: 1.8em;
            font-weight: 300;
            margin-bottom: 20px;
            color: #06ffa5;
        }

        .vote-form {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .vote-textarea {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 15px;
            color: white;
            font-family: inherit;
            font-size: 1em;
            resize: vertical;
            min-height: 100px;
            outline: none;
        }

        .vote-textarea:focus {
            border-color: #06ffa5;
        }

        .vote-textarea::placeholder {
            color: rgba(255, 255, 255, 0.4);
        }

        .vote-actions {
            display: flex;
            gap: 10px;
        }

        .submit-vote, .cancel-vote {
            flex: 1;
            padding: 12px 20px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s ease;
        }

        .submit-vote {
            background: #06ffa5;
            color: #000;
        }

        .submit-vote:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 30px rgba(6, 255, 165, 0.3);
        }

        .cancel-vote {
            background: transparent;
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .cancel-vote:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .vote-popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 999;
            display: none;
        }

        .vote-popup-overlay.show {
            display: block;
        }

        /* 3D Gallery Styles */
        #three-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            z-index: 1000;
            touch-action: none;
        }

        #three-container.active {
            display: block;
        }

        .three-ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 1001;
        }

        .back-button {
            padding: 12px 30px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 25px;
            color: white;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s ease;
            -webkit-appearance: none;
            appearance: none;
            touch-action: manipulation;
        }

        .back-button:hover {
            background: rgba(0, 0, 0, 0.9);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .back-button:active {
            transform: scale(0.95);
        }

        .controls-hint {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.8);
            z-index: 1001;
            text-align: center;
        }

        /* Mobile controls UI */
        .mobile-controls {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            z-index: 1001;
            gap: 20px;
        }

        .mobile-controls.show {
            display: flex;
        }

        .joystick-container {
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            position: relative;
            touch-action: none;
        }

        .joystick-handle {
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: none;
        }

        .artwork-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            padding: 25px;
            max-width: 400px;
            display: none;
            z-index: 1002;
            pointer-events: none;
            backdrop-filter: blur(10px);
        }

        @media (max-width: 768px) {
            .artwork-tooltip {
                padding: 20px;
                max-width: 300px;
            }
        }

        .artwork-tooltip.visible {
            display: block;
        }

        .tooltip-title {
            font-size: 1.4em;
            font-weight: 300;
            margin-bottom: 10px;
            color: #fff;
        }

        @media (max-width: 768px) {
            .tooltip-title {
                font-size: 1.2em;
            }
        }

        .tooltip-description {
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.7);
            line-height: 1.5;
            margin-bottom: 10px;
        }

        .tooltip-instruction {
            font-size: 0.85em;
            color: #ff006e;
            text-align: center;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* Custom scrollbar */
        @media (hover: hover) {
            ::-webkit-scrollbar {
                width: 8px;
            }

            ::-webkit-scrollbar-track {
                background: rgba(255, 255, 255, 0.05);
            }

            ::-webkit-scrollbar-thumb {
                background: rgba(255, 255, 255, 0.2);
                border-radius: 4px;
            }

            ::-webkit-scrollbar-thumb:hover {
                background: rgba(255, 255, 255, 0.3);
            }
        }

        /* Toast notification */
        .toast {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 25px;
            padding: 15px 30px;
            color: white;
            font-size: 1em;
            z-index: 2000;
            opacity: 0;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .toast.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        .toast.success {
            border-color: #06ffa5;
            color: #06ffa5;
        }

        .toast.error {
            border-color: #ff006e;
            color: #ff006e;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1 class="gallery-title">VIBE CODING</h1>
        <div class="gallery-subtitle">Kody's Creative Playground</div>
        <p class="gallery-description">
            Welcome to Kody Wildfeuer's vibe coding showcase - a collection of experimental web art, creative coding projects, and digital explorations.<br>
            These are personal creative experiments that represent the intersection of code and art.<br>
            <span style="font-size: 0.85em; opacity: 0.6;">Note: This is Kody's personal creative content and opinions, unrelated to any employer.</span>
        </p>
        <div class="search-container">
            <input type="text" class="search-box" id="search-input" placeholder="Search for tools...">
            <span class="search-icon">üîç</span>
        </div>
        <div class="gallery-modes">
            <button class="mode-button active" id="main-gallery">Main Gallery</button>
            <button class="mode-button" id="archive-mode">Archive</button>
            <button class="mode-button vr-mode" id="3d-mode">3D Experience</button>
        </div>
    </div>
    
    <div class="content" id="main-content">
        <div class="loading">Loading gallery...</div>
    </div>

    <div id="three-container">
        <div class="three-ui">
            <button class="back-button" id="back-to-gallery">‚Üê Back to Gallery</button>
        </div>
        <div class="controls-hint" id="controls-hint">Use WASD to move, Mouse to look around, Click on artworks to view</div>
        <div class="mobile-controls" id="mobile-controls">
            <div class="joystick-container" id="movement-joystick">
                <div class="joystick-handle" id="movement-handle"></div>
            </div>
        </div>
        <div class="artwork-tooltip" id="artwork-tooltip">
            <h3 class="tooltip-title"></h3>
            <p class="tooltip-description"></p>
            <p class="tooltip-instruction">Click to view in new tab</p>
        </div>
    </div>

    <!-- Vote popup -->
    <div class="vote-popup-overlay" id="vote-overlay"></div>
    <div class="vote-popup" id="vote-popup">
        <h3>Vote for Feature Request</h3>
        <form class="vote-form" id="vote-form">
            <textarea class="vote-textarea" id="vote-message" placeholder="What features or improvements would you like to see in this tool?"></textarea>
            <div class="vote-actions">
                <button type="submit" class="submit-vote">Submit Vote</button>
                <button type="button" class="cancel-vote" id="cancel-vote">Cancel</button>
            </div>
        </form>
    </div>

    <!-- Toast notification -->
    <div class="toast" id="toast"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Target repository
        const REPO_OWNER = 'kody-w';
        const REPO_NAME = 'localFirstTools';
        const BRANCH = 'main';
        
        // Detect if running locally
        const isLocal = window.location.protocol === 'file:' || 
                       window.location.hostname === 'localhost' || 
                       window.location.hostname === '127.0.0.1' ||
                       window.location.hostname === '';
        
        // GitHub Pages URL pattern
        const GITHUB_PAGES_BASE = `https://${REPO_OWNER}.github.io/${REPO_NAME}/`;
        
        // Store gallery data globally
        let galleryData = null;
        let threeScene = null;
        let currentView = 'main'; // 'main' or 'archive'
        
        // Local storage keys
        const PINNED_TOOLS_KEY = 'vibe_gallery_pinned_tools';
        const VOTES_KEY = 'vibe_gallery_votes';
        const USER_VOTES_KEY = 'vibe_gallery_user_votes';
        
        // Main content container
        const mainContent = document.getElementById('main-content');
        const threeContainer = document.getElementById('three-container');
        
        // Icons for display
        const artworkIcons = ['üé®', '‚ú®', 'üåü', 'üí´', 'üîÆ', 'üé≠', 'üåà', 'üé™', 'üéØ', 'üé≤', 'üé∏', 'üéπ'];
        
        // Check if device is mobile
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                        (window.matchMedia && window.matchMedia('(max-width: 768px)').matches);
        
        // Get appropriate URL for file based on environment
        function getFileUrl(path) {
            if (isLocal) {
                // For local testing, use relative path
                return path;
            } else {
                // For GitHub Pages, use full URL
                return `${GITHUB_PAGES_BASE}${path}`;
            }
        }
        
        // Local storage helpers
        function getPinnedTools() {
            const pinned = localStorage.getItem(PINNED_TOOLS_KEY);
            return pinned ? JSON.parse(pinned) : [];
        }
        
        function setPinnedTools(pinned) {
            localStorage.setItem(PINNED_TOOLS_KEY, JSON.stringify(pinned));
        }
        
        function getVotes() {
            const votes = localStorage.getItem(VOTES_KEY);
            return votes ? JSON.parse(votes) : {};
        }
        
        function setVotes(votes) {
            localStorage.setItem(VOTES_KEY, JSON.stringify(votes));
        }
        
        function getUserVotes() {
            const userVotes = localStorage.getItem(USER_VOTES_KEY);
            return userVotes ? JSON.parse(userVotes) : {};
        }
        
        function setUserVotes(userVotes) {
            localStorage.setItem(USER_VOTES_KEY, JSON.stringify(userVotes));
        }
        
        // Toast notification
        function showToast(message, type = 'success') {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = `toast ${type}`;
            toast.classList.add('show');
            
            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }
        
        // Generate consistent artwork metadata
        function generateArtworkMetadata(file) {
            const filename = file.path.split('/').pop();
            const nameWithoutExt = filename.replace('.html', '').replace('.htm', '');
            const formattedName = nameWithoutExt
                .replace(/[-_]/g, ' ')
                .replace(/\b\w/g, l => l.toUpperCase());
            
            // Use a hash of the filename to generate consistent metadata
            const hash = filename.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
            
            const descriptions = [
                "An experimental dive into the creative possibilities of web technology",
                "Interactive art piece exploring the boundaries between code and creativity",
                "A digital meditation on algorithms, aesthetics, and human expression",
                "Pushing browser limits to create unexpected visual experiences",
                "Real-time generative art that evolves with each interaction",
                "Creative coding experiment blending mathematics and imagination",
                "A playful exploration of what happens when code becomes art",
                "Digital canvas where logic meets creativity in unexpected ways",
                "Vibe coding at its finest - where inspiration meets implementation"
            ];
            
            return {
                title: formattedName,
                description: descriptions[hash % descriptions.length],
                icon: artworkIcons[hash % artworkIcons.length],
                tags: generateConsistentTags(filename, hash)
            };
        }
        
        // Generate consistent tags based on filename
        function generateConsistentTags(filename, hash) {
            const allTags = [
                'interactive', 'generative', 'particles', 'animation', 
                'experimental', '3D', 'audio-reactive', 'kinetic',
                'abstract', 'geometric', 'organic', 'minimal',
                'colorful', 'monochrome', 'dynamic', 'static'
            ];
            
            // Use hash to select 2-3 tags consistently
            const numTags = 2 + (hash % 2);
            const tags = [];
            
            for (let i = 0; i < numTags; i++) {
                const tagIndex = (hash + i * 7) % allTags.length;
                tags.push(allTags[tagIndex]);
            }
            
            return tags;
        }
        
        // Track mouse position for interactive effects (desktop only)
        if (!isMobile) {
            document.addEventListener('mousemove', (e) => {
                const frames = document.querySelectorAll('.artwork-frame');
                frames.forEach(frame => {
                    const rect = frame.getBoundingClientRect();
                    const x = ((e.clientX - rect.left) / rect.width) * 100;
                    const y = ((e.clientY - rect.top) / rect.height) * 100;
                    frame.style.setProperty('--mouse-x', `${x}%`);
                    frame.style.setProperty('--mouse-y', `${y}%`);
                });
            });
        }
        
        // Search functionality
        const searchInput = document.getElementById('search-input');
        searchInput.addEventListener('input', (e) => {
            const searchTerm = e.target.value.toLowerCase();
            filterArtworks(searchTerm);
        });
        
        function filterArtworks(searchTerm) {
            const artworkFrames = document.querySelectorAll('.artwork-frame');
            artworkFrames.forEach(frame => {
                const title = frame.querySelector('.artwork-title').textContent.toLowerCase();
                const description = frame.querySelector('.artwork-description').textContent.toLowerCase();
                
                if (title.includes(searchTerm) || description.includes(searchTerm)) {
                    frame.style.display = 'flex';
                } else {
                    frame.style.display = 'none';
                }
            });
            
            // Hide empty sections
            const sections = document.querySelectorAll('.exhibition-section');
            sections.forEach(section => {
                const visibleFrames = section.querySelectorAll('.artwork-frame[style*="display: flex"], .artwork-frame:not([style*="display"])');
                if (visibleFrames.length === 0) {
                    section.style.display = 'none';
                } else {
                    section.style.display = 'block';
                }
            });
        }
        
        // Mode switching
        document.getElementById('main-gallery').addEventListener('click', () => {
            currentView = 'main';
            document.getElementById('main-gallery').classList.add('active');
            document.getElementById('archive-mode').classList.remove('active');
            threeContainer.classList.remove('active');
            mainContent.classList.remove('hidden');
            if (threeScene) {
                threeScene.cleanup();
                threeScene = null;
            }
            if (galleryData) {
                displayGallery(galleryData);
            }
        });
        
        document.getElementById('archive-mode').addEventListener('click', () => {
            currentView = 'archive';
            document.getElementById('archive-mode').classList.add('active');
            document.getElementById('main-gallery').classList.remove('active');
            threeContainer.classList.remove('active');
            mainContent.classList.remove('hidden');
            if (threeScene) {
                threeScene.cleanup();
                threeScene = null;
            }
            if (galleryData) {
                displayGallery(galleryData);
            }
        });
        
        document.getElementById('3d-mode').addEventListener('click', () => {
            if (galleryData) {
                mainContent.classList.add('hidden');
                threeContainer.classList.add('active');
                init3DGallery(galleryData);
            }
        });
        
        document.getElementById('back-to-gallery').addEventListener('click', () => {
            document.getElementById('main-gallery').click();
        });
        
        // Vote popup handling
        const voteOverlay = document.getElementById('vote-overlay');
        const votePopup = document.getElementById('vote-popup');
        const voteForm = document.getElementById('vote-form');
        const cancelVote = document.getElementById('cancel-vote');
        let currentVoteFile = null;
        
        voteOverlay.addEventListener('click', closeVotePopup);
        cancelVote.addEventListener('click', closeVotePopup);
        
        function openVotePopup(file) {
            currentVoteFile = file;
            voteOverlay.classList.add('show');
            votePopup.classList.add('show');
            document.getElementById('vote-message').value = '';
        }
        
        function closeVotePopup() {
            voteOverlay.classList.remove('show');
            votePopup.classList.remove('show');
            currentVoteFile = null;
        }
        
        voteForm.addEventListener('submit', (e) => {
            e.preventDefault();
            if (!currentVoteFile) return;
            
            const message = document.getElementById('vote-message').value.trim();
            if (!message) {
                showToast('Please enter a feature request', 'error');
                return;
            }
            
            // Update votes
            const votes = getVotes();
            const userVotes = getUserVotes();
            const fileId = currentVoteFile.path;
            
            // Initialize vote count if not exists
            if (!votes[fileId]) {
                votes[fileId] = { count: 0, requests: [] };
            }
            
            // Add vote
            votes[fileId].count++;
            votes[fileId].requests.push({
                message: message,
                timestamp: new Date().toISOString()
            });
            
            // Mark user as voted for this file
            userVotes[fileId] = true;
            
            // Save to local storage
            setVotes(votes);
            setUserVotes(userVotes);
            
            // Update UI
            updateVoteUI(fileId);
            
            closeVotePopup();
            showToast('Vote submitted! Thank you for your feedback.');
            
            // Log vote for developer (in console)
            console.log('New vote for:', currentVoteFile.path);
            console.log('Feature request:', message);
        });
        
        function updateVoteUI(fileId) {
            const voteButtons = document.querySelectorAll(`.vote-button[data-file="${fileId}"]`);
            const voteCounts = document.querySelectorAll(`.vote-count[data-file="${fileId}"]`);
            const userVotes = getUserVotes();
            const votes = getVotes();
            
            voteButtons.forEach(btn => {
                if (userVotes[fileId]) {
                    btn.classList.add('voted');
                    btn.textContent = 'Voted';
                }
            });
            
            voteCounts.forEach(count => {
                count.textContent = votes[fileId] ? votes[fileId].count : 0;
            });
        }
        
        // Pin functionality - FIXED VERSION
        function togglePin(file) {
            const pinned = getPinnedTools();
            const fileId = file.path;
            const index = pinned.indexOf(fileId);
            
            if (index > -1) {
                pinned.splice(index, 1);
                showToast('Tool unpinned');
            } else {
                pinned.push(fileId);
                showToast('Tool pinned to top');
            }
            
            setPinnedTools(pinned);
            
            // Refresh display
            if (galleryData) {
                displayGallery(galleryData);
            }
        }
        
        // Fetch GitHub repository files
        async function fetchRepoFiles() {
            try {
                // If running locally, try to use local data first
                if (isLocal) {
                    console.log('Running locally - attempting to load apps from local filesystem');
                    
                    // Try to fetch the config file
                    try {
                        const configResponse = await fetch('data/config/utility_apps_config.json');
                        if (configResponse.ok) {
                            const configData = await configResponse.json();
                            console.log('Loaded local config:', configData);
                            
                            // Convert config format to gallery format
                            const files = configData.apps.map(app => ({
                                path: app.path.replace('./', ''),
                                url: '#',
                                raw_url: app.path.replace('./', ''),
                                pages_url: app.path.replace('./', '')
                            }));
                            
                            galleryData = {
                                repo: {
                                    owner: REPO_OWNER,
                                    name: REPO_NAME,
                                    branch: BRANCH,
                                    url: `https://github.com/${REPO_OWNER}/${REPO_NAME}`
                                },
                                mainFiles: files.filter(f => !f.path.includes('archive/')),
                                archiveFiles: files.filter(f => f.path.includes('archive/'))
                            };
                            
                            displayGallery(galleryData);
                            return;
                        }
                    } catch (e) {
                        console.log('Local config not found, falling back to GitHub API');
                    }
                }
                
                const apiUrl = `https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/git/trees/${BRANCH}?recursive=1`;
                
                const response = await fetch(apiUrl);
                
                if (!response.ok) {
                    throw new Error(`GitHub API error: ${response.status}`);
                }
                
                const data = await response.json();
                
                // Separate main files and archive files
                const mainFiles = [];
                const archiveFiles = [];
                
                data.tree.forEach(item => {
                    if (item.type === 'blob' && 
                        (item.path.endsWith('.html') || item.path.endsWith('.htm'))) {
                        
                        const file = {
                            path: item.path,
                            url: `https://github.com/${REPO_OWNER}/${REPO_NAME}/blob/${BRANCH}/${item.path}`,
                            raw_url: `https://raw.githubusercontent.com/${REPO_OWNER}/${REPO_NAME}/${BRANCH}/${item.path}`,
                            // Add appropriate URL based on environment
                            pages_url: getFileUrl(item.path)
                        };
                        
                        // Check if file is in archive
                        if (item.path.includes('archive/')) {
                            archiveFiles.push(file);
                        } else {
                            // Exclude gallery-related files
                            const filename = item.path.split('/').pop().toLowerCase();
                            const excludeFiles = ['index.html', 'template.html', 'example.html', 'test.html', 'gallery.html'];
                            if (!excludeFiles.includes(filename)) {
                                mainFiles.push(file);
                            }
                        }
                    }
                });
                
                // Store gallery data globally
                galleryData = {
                    repo: {
                        owner: REPO_OWNER,
                        name: REPO_NAME,
                        branch: BRANCH,
                        url: `https://github.com/${REPO_OWNER}/${REPO_NAME}`
                    },
                    mainFiles: mainFiles,
                    archiveFiles: archiveFiles
                };
                
                // Display gallery
                displayGallery(galleryData);
                
            } catch (error) {
                console.error("Error fetching repository:", error);
                mainContent.innerHTML = `
                    <div class="error">
                        <strong>Exhibition Temporarily Closed</strong><br>
                        ${error.message}
                    </div>
                `;
            }
        }
        
        // Sort files by votes and pinned status
        function sortFiles(files) {
            const pinned = getPinnedTools();
            const votes = getVotes();
            
            return files.sort((a, b) => {
                // First priority: pinned items
                const aPinned = pinned.includes(a.path);
                const bPinned = pinned.includes(b.path);
                if (aPinned && !bPinned) return -1;
                if (!aPinned && bPinned) return 1;
                
                // Second priority: vote count
                const aVotes = votes[a.path]?.count || 0;
                const bVotes = votes[b.path]?.count || 0;
                if (aVotes !== bVotes) return bVotes - aVotes;
                
                // Third priority: alphabetical by title
                const aTitle = generateArtworkMetadata(a).title;
                const bTitle = generateArtworkMetadata(b).title;
                return aTitle.localeCompare(bTitle);
            });
        }
        
        // Display gallery content
        function displayGallery(data) {
            mainContent.innerHTML = '';
            
            const files = currentView === 'main' ? data.mainFiles : data.archiveFiles;
            if (!files || files.length === 0) {
                mainContent.innerHTML = `
                    <div class="error">
                        <strong>No items in ${currentView === 'main' ? 'main gallery' : 'archive'}</strong>
                    </div>
                `;
                return;
            }
            
            // Sort files
            const sortedFiles = sortFiles(files);
            const pinned = getPinnedTools();
            const votes = getVotes();
            const userVotes = getUserVotes();
            
            // Create sections
            const pinnedFiles = sortedFiles.filter(f => pinned.includes(f.path));
            const unpinnedFiles = sortedFiles.filter(f => !pinned.includes(f.path));
            
            // Display pinned section if there are pinned items
            if (pinnedFiles.length > 0 && currentView === 'main') {
                const pinnedSection = createSection('Pinned Tools', pinnedFiles, true);
                mainContent.appendChild(pinnedSection);
            }
            
            // Display main section
            const sectionTitle = currentView === 'main' ? 
                (pinnedFiles.length > 0 ? 'All Tools' : 'Creative Tools') : 
                'Archive';
            const mainSection = createSection(sectionTitle, unpinnedFiles, false);
            mainContent.appendChild(mainSection);
            
            // Add event listeners
            addEventListeners();
            
            // Restore search term if any
            if (searchInput.value) {
                filterArtworks(searchInput.value.toLowerCase());
            }
        }
        
        function createSection(title, files, isPinnedSection = false) {
            const section = document.createElement('div');
            section.className = 'exhibition-section';
            
            const sectionTitle = document.createElement('h2');
            sectionTitle.className = 'section-title';
            sectionTitle.textContent = title;
            section.appendChild(sectionTitle);
            
            const artworkGrid = document.createElement('div');
            artworkGrid.className = 'artwork-grid';
            
            const pinned = getPinnedTools();
            const votes = getVotes();
            const userVotes = getUserVotes();
            
            files.forEach(file => {
                const metadata = generateArtworkMetadata(file);
                const filename = file.path.split('/').pop();
                const fileVotes = votes[file.path]?.count || 0;
                const hasVoted = userVotes[file.path] || false;
                const isPinned = pinned.includes(file.path);
                
                const artworkFrame = document.createElement('div');
                artworkFrame.className = 'artwork-frame' + (isPinned ? ' pinned' : '');
                
                artworkFrame.innerHTML = `
                    <button class="pin-button ${isPinned ? 'pinned' : ''}" data-file="${file.path}" title="${isPinned ? 'Unpin' : 'Pin to top'}">
                        üìå
                    </button>
                    <div class="artwork-preview">
                        ${metadata.icon}
                    </div>
                    <h3 class="artwork-title">${metadata.title}</h3>
                    <p class="artwork-description">${metadata.description}</p>
                    <div class="artwork-stats">
                        <div class="stat-item">
                            <span>üëç</span>
                            <span class="vote-count" data-file="${file.path}">${fileVotes}</span>
                            <span>votes</span>
                        </div>
                    </div>
                    <div class="artwork-actions">
                        <button class="view-button" data-url="${file.pages_url}" data-title="${metadata.title}" data-filename="${filename}">View</button>
                        <button class="vote-button ${hasVoted ? 'voted' : ''}" data-file="${file.path}">${hasVoted ? 'Voted' : 'Vote'}</button>
                        <button class="download-button" data-url="${file.raw_url}" data-filename="${filename}">Save</button>
                    </div>
                `;
                
                artworkGrid.appendChild(artworkFrame);
            });
            
            section.appendChild(artworkGrid);
            return section;
        }
        
        // Add event listeners for buttons
        function addEventListeners() {
            // Pin buttons
            const pinButtons = document.querySelectorAll('.pin-button');
            pinButtons.forEach(button => {
                button.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const fileId = button.dataset.file;
                    const file = [...galleryData.mainFiles, ...galleryData.archiveFiles]
                        .find(f => f.path === fileId);
                    if (file) {
                        togglePin(file);
                    }
                });
            });
            
            // Vote buttons
            const voteButtons = document.querySelectorAll('.vote-button');
            voteButtons.forEach(button => {
                button.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const fileId = button.dataset.file;
                    const userVotes = getUserVotes();
                    
                    if (userVotes[fileId]) {
                        showToast('You have already voted for this tool', 'error');
                        return;
                    }
                    
                    const file = [...galleryData.mainFiles, ...galleryData.archiveFiles]
                        .find(f => f.path === fileId);
                    if (file) {
                        openVotePopup(file);
                    }
                });
            });
            
            // View buttons
            const viewButtons = document.querySelectorAll('.view-button');
            viewButtons.forEach(button => {
                button.addEventListener('click', (e) => {
                    e.stopPropagation();
                    // Open GitHub Pages URL directly
                    window.open(button.dataset.url, '_blank');
                });
            });
            
            // Download buttons
            const downloadButtons = document.querySelectorAll('.download-button');
            downloadButtons.forEach(button => {
                button.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    try {
                        await downloadHtmlFile(button.dataset.url, button.dataset.filename);
                    } catch (error) {
                        showToast(`Error downloading: ${error.message}`, 'error');
                    }
                });
            });
            
            // Artwork frame clicks
            const artworkFrames = document.querySelectorAll('.artwork-frame');
            artworkFrames.forEach(frame => {
                frame.addEventListener('click', (e) => {
                    // Don't trigger if clicking on a button
                    if (e.target.tagName !== 'BUTTON' && !e.target.closest('button')) {
                        const viewButton = frame.querySelector('.view-button');
                        if (viewButton) {
                            // Open GitHub Pages URL directly
                            window.open(viewButton.dataset.url, '_blank');
                        }
                    }
                });
            });
        }
        
        // Download HTML file
        async function downloadHtmlFile(url, filename) {
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`Failed to fetch (${response.status})`);
                }
                
                const htmlContent = await response.text();
                
                const blob = new Blob([htmlContent], { type: 'text/html' });
                const blobUrl = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = blobUrl;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                
                window.URL.revokeObjectURL(blobUrl);
                document.body.removeChild(a);
                
                showToast('File downloaded successfully');
            } catch (error) {
                console.error('Error downloading:', error);
                throw error;
            }
        }
        
        // Initialize 3D Gallery
        function init3DGallery(data) {
            if (threeScene) {
                threeScene.cleanup();
            }
            
            // Use only main files for 3D gallery
            const galleryDataFor3D = {
                ...data,
                files: data.mainFiles
            };
            
            threeScene = new MinecraftGallery(galleryDataFor3D);
            threeScene.init();
        }
        
        // Minecraft-style 3D Gallery Class
        class MinecraftGallery {
            constructor(data) {
                this.data = data;
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.artworks = [];
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                this.moveSpeed = 0.2;
                this.lookSpeed = 0.002;
                
                // Movement state
                this.keys = {
                    w: false,
                    a: false,
                    s: false,
                    d: false
                };
                
                // Camera rotation
                this.rotation = {
                    x: 0,
                    y: 0
                };
                
                // Mobile controls
                this.isMobile = isMobile;
                this.touches = {
                    start: null,
                    current: null,
                    joystick: null
                };
                this.joystickActive = false;
                this.joystickVector = new THREE.Vector2();
                
                this.isPointerLocked = false;
                this.hoveredArtwork = null;
                this.tooltip = document.getElementById('artwork-tooltip');
                this.tooltipTitle = this.tooltip.querySelector('.tooltip-title');
                this.tooltipDescription = this.tooltip.querySelector('.tooltip-description');
            }
            
            init() {
                // Scene setup
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.Fog(0x000000, 10, 100);
                
                // Camera
                this.camera = new THREE.PerspectiveCamera(
                    75, 
                    window.innerWidth / window.innerHeight, 
                    0.1, 
                    1000
                );
                this.camera.position.set(0, 2, 10);
                
                // Renderer
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                threeContainer.appendChild(this.renderer.domElement);
                
                // Lighting
                this.setupLighting();
                
                // Create gallery
                this.createGallery();
                
                // Event listeners
                this.setupEventListeners();
                
                // Update controls hint
                const controlsHint = document.getElementById('controls-hint');
                if (this.isMobile) {
                    controlsHint.textContent = 'Swipe to look around, Use joystick to move, Tap on artworks to view';
                    document.getElementById('mobile-controls').classList.add('show');
                }
                
                // Start animation
                this.animate();
            }
            
            setupLighting() {
                // Ambient light
                const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
                this.scene.add(ambientLight);
                
                // Directional light (sun)
                const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
                dirLight.position.set(10, 20, 10);
                dirLight.castShadow = true;
                dirLight.shadow.camera.near = 0.1;
                dirLight.shadow.camera.far = 50;
                dirLight.shadow.camera.left = -50;
                dirLight.shadow.camera.right = 50;
                dirLight.shadow.camera.top = 50;
                dirLight.shadow.camera.bottom = -50;
                this.scene.add(dirLight);
                
                // Point lights for artwork
                const colors = [0xff00ff, 0x00ffff, 0xffff00];
                colors.forEach((color, i) => {
                    const light = new THREE.PointLight(color, 0.5, 10);
                    light.position.set(i * 10 - 10, 3, 0);
                    this.scene.add(light);
                });
            }
            
            createGallery() {
                // Create floor
                const floorGeometry = new THREE.BoxGeometry(100, 1, 100);
                const floorMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x333333,
                    emissive: 0x111111
                });
                const floor = new THREE.Mesh(floorGeometry, floorMaterial);
                floor.position.y = -0.5;
                floor.receiveShadow = true;
                this.scene.add(floor);
                
                // Create walls
                this.createWalls();
                
                // Create artworks
                this.createArtworks();
                
                // Add some decorative cubes
                this.addDecorations();
            }
            
            createWalls() {
                const wallMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x666666,
                    emissive: 0x222222
                });
                
                // Back wall
                const backWall = new THREE.Mesh(
                    new THREE.BoxGeometry(100, 20, 1),
                    wallMaterial
                );
                backWall.position.set(0, 10, -50);
                backWall.castShadow = true;
                backWall.receiveShadow = true;
                this.scene.add(backWall);
                
                // Side walls
                const leftWall = new THREE.Mesh(
                    new THREE.BoxGeometry(1, 20, 100),
                    wallMaterial
                );
                leftWall.position.set(-50, 10, 0);
                leftWall.castShadow = true;
                leftWall.receiveShadow = true;
                this.scene.add(leftWall);
                
                const rightWall = new THREE.Mesh(
                    new THREE.BoxGeometry(1, 20, 100),
                    wallMaterial
                );
                rightWall.position.set(50, 10, 0);
                rightWall.castShadow = true;
                rightWall.receiveShadow = true;
                this.scene.add(rightWall);
            }
            
            createTextSprite(text, fontSize = 0.5) {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 256;
                
                context.fillStyle = 'rgba(0, 0, 0, 0)';
                context.fillRect(0, 0, canvas.width, canvas.height);
                
                context.font = `${canvas.width * fontSize}px Arial`;
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillStyle = 'white';
                
                // For emoji, we need to handle them differently
                if (text.length <= 2 && /\p{Emoji}/u.test(text)) {
                    context.font = `${canvas.width * fontSize * 0.8}px Arial`;
                }
                
                context.fillText(text, canvas.width / 2, canvas.height / 2);
                
                const texture = new THREE.CanvasTexture(canvas);
                texture.needsUpdate = true;
                
                const spriteMaterial = new THREE.SpriteMaterial({ 
                    map: texture,
                    transparent: true
                });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.scale.set(2, 2, 1);
                
                return sprite;
            }
            
            createArtworks() {
                const files = this.data.files || this.data.mainFiles || [];
                const numArtworks = Math.min(files.length, 20);
                
                for (let i = 0; i < numArtworks; i++) {
                    const file = files[i];
                    const metadata = generateArtworkMetadata(file);
                    
                    // Create artwork group
                    const artworkGroup = new THREE.Group();
                    
                    // Frame
                    const frameGeometry = new THREE.BoxGeometry(4, 3, 0.2);
                    const frameMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0x888888,
                        emissive: 0x444444
                    });
                    const frame = new THREE.Mesh(frameGeometry, frameMaterial);
                    
                    // Canvas (artwork) with random color
                    const canvasGeometry = new THREE.BoxGeometry(3.6, 2.6, 0.1);
                    const hue = Math.random();
                    const canvasMaterial = new THREE.MeshLambertMaterial({ 
                        color: new THREE.Color().setHSL(hue, 0.7, 0.5),
                        emissive: new THREE.Color().setHSL(hue, 0.7, 0.3),
                        emissiveIntensity: 0.5
                    });
                    const canvas = new THREE.Mesh(canvasGeometry, canvasMaterial);
                    canvas.position.z = 0.1;
                    frame.add(canvas);
                    
                    // Add emoji sprite to canvas
                    const emojiSprite = this.createTextSprite(metadata.icon, 0.4);
                    emojiSprite.position.z = 0.2;
                    canvas.add(emojiSprite);
                    
                    // Add title below frame
                    const titleSprite = this.createTextSprite(metadata.title.substring(0, 15) + (metadata.title.length > 15 ? '...' : ''), 0.15);
                    titleSprite.position.y = -2;
                    titleSprite.position.z = 0.5;
                    frame.add(titleSprite);
                    
                    artworkGroup.add(frame);
                    
                    // Position artwork
                    const angle = (i / numArtworks) * Math.PI * 2;
                    const radius = 20;
                    artworkGroup.position.x = Math.cos(angle) * radius;
                    artworkGroup.position.z = Math.sin(angle) * radius;
                    artworkGroup.position.y = 3;
                    artworkGroup.rotation.y = -angle + Math.PI;
                    
                    frame.castShadow = true;
                    frame.receiveShadow = true;
                    
                    // Store data for interaction - use GitHub Pages URL
                    frame.userData = {
                        url: file.pages_url,
                        title: metadata.title,
                        description: metadata.description,
                        filename: file.path.split('/').pop(),
                        icon: metadata.icon
                    };
                    
                    this.artworks.push(frame);
                    this.scene.add(artworkGroup);
                }
            }
            
            addDecorations() {
                const decorationMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x444444,
                    emissive: 0x222222
                });
                
                // Add some pillars
                for (let i = 0; i < 8; i++) {
                    const pillar = new THREE.Mesh(
                        new THREE.BoxGeometry(2, 10, 2),
                        decorationMaterial
                    );
                    
                    const angle = (i / 8) * Math.PI * 2;
                    pillar.position.x = Math.cos(angle) * 30;
                    pillar.position.z = Math.sin(angle) * 30;
                    pillar.position.y = 5;
                    
                    pillar.castShadow = true;
                    pillar.receiveShadow = true;
                    
                    this.scene.add(pillar);
                }
                
                // Add floating cubes
                for (let i = 0; i < 20; i++) {
                    const size = Math.random() * 0.5 + 0.5;
                    const cube = new THREE.Mesh(
                        new THREE.BoxGeometry(size, size, size),
                        new THREE.MeshLambertMaterial({ 
                            color: new THREE.Color().setHSL(Math.random(), 0.7, 0.5),
                            emissive: new THREE.Color().setHSL(Math.random(), 0.7, 0.3),
                            emissiveIntensity: 0.3
                        })
                    );
                    
                    cube.position.x = (Math.random() - 0.5) * 40;
                    cube.position.y = Math.random() * 10 + 10;
                    cube.position.z = (Math.random() - 0.5) * 40;
                    
                    cube.rotation.x = Math.random() * Math.PI * 2;
                    cube.rotation.y = Math.random() * Math.PI * 2;
                    
                    cube.userData.floatSpeed = Math.random() * 0.02 + 0.01;
                    cube.userData.rotateSpeed = Math.random() * 0.02 + 0.01;
                    
                    cube.castShadow = true;
                    
                    this.scene.add(cube);
                }
            }
            
            setupEventListeners() {
                if (this.isMobile) {
                    this.setupMobileControls();
                } else {
                    this.setupDesktopControls();
                }
                
                // Window resize
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }
            
            setupDesktopControls() {
                // Keyboard controls
                window.addEventListener('keydown', (e) => {
                    if (e.key.toLowerCase() in this.keys) {
                        this.keys[e.key.toLowerCase()] = true;
                    }
                });
                
                window.addEventListener('keyup', (e) => {
                    if (e.key.toLowerCase() in this.keys) {
                        this.keys[e.key.toLowerCase()] = false;
                    }
                });
                
                // Mouse controls
                this.renderer.domElement.addEventListener('click', () => {
                    if (!this.isPointerLocked) {
                        this.renderer.domElement.requestPointerLock();
                    }
                });
                
                document.addEventListener('pointerlockchange', () => {
                    this.isPointerLocked = document.pointerLockElement === this.renderer.domElement;
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (this.isPointerLocked) {
                        this.rotation.y -= e.movementX * this.lookSpeed;
                        this.rotation.x -= e.movementY * this.lookSpeed;
                        this.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.rotation.x));
                    }
                });
                
                // Click on artwork
                this.renderer.domElement.addEventListener('click', (e) => {
                    if (!this.isPointerLocked) return;
                    
                    this.raycaster.setFromCamera(new THREE.Vector2(0, 0), this.camera);
                    const intersects = this.raycaster.intersectObjects(this.artworks, true);
                    
                    if (intersects.length > 0) {
                        const artwork = intersects[0].object.parent || intersects[0].object;
                        if (artwork.userData && artwork.userData.url) {
                            // Open GitHub Pages URL directly
                            window.open(artwork.userData.url, '_blank');
                        }
                    }
                });
            }
            
            setupMobileControls() {
                const canvas = this.renderer.domElement;
                
                // Touch start
                canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    this.touches.start = {
                        x: touch.clientX,
                        y: touch.clientY
                    };
                    this.touches.current = {...this.touches.start};
                });
                
                // Touch move - camera rotation
                canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (!this.touches.start) return;
                    
                    const touch = e.touches[0];
                    const deltaX = touch.clientX - this.touches.current.x;
                    const deltaY = touch.clientY - this.touches.current.y;
                    
                    this.rotation.y -= deltaX * this.lookSpeed * 2;
                    this.rotation.x -= deltaY * this.lookSpeed * 2;
                    this.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.rotation.x));
                    
                    this.touches.current = {
                        x: touch.clientX,
                        y: touch.clientY
                    };
                });
                
                // Touch end
                canvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    
                    // Check if it was a tap
                    if (this.touches.start && this.touches.current) {
                        const dx = this.touches.current.x - this.touches.start.x;
                        const dy = this.touches.current.y - this.touches.start.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < 10) {
                            // It's a tap - check for artwork
                            // Convert touch coordinates to normalized device coordinates
                            const rect = canvas.getBoundingClientRect();
                            const x = ((this.touches.start.x - rect.left) / rect.width) * 2 - 1;
                            const y = -((this.touches.start.y - rect.top) / rect.height) * 2 + 1;
                            
                            this.raycaster.setFromCamera(new THREE.Vector2(x, y), this.camera);
                            const intersects = this.raycaster.intersectObjects(this.artworks, true);
                            
                            if (intersects.length > 0) {
                                const artwork = intersects[0].object.parent || intersects[0].object;
                                if (artwork.userData && artwork.userData.url) {
                                    // Open GitHub Pages URL directly
                                    window.open(artwork.userData.url, '_blank');
                                }
                            }
                        }
                    }
                    
                    this.touches.start = null;
                    this.touches.current = null;
                });
                
                // Joystick controls
                const joystick = document.getElementById('movement-joystick');
                const handle = document.getElementById('movement-handle');
                
                joystick.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.joystickActive = true;
                    this.updateJoystick(e.touches[0], joystick, handle);
                });
                
                joystick.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (this.joystickActive) {
                        this.updateJoystick(e.touches[0], joystick, handle);
                    }
                });
                
                joystick.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.joystickActive = false;
                    this.joystickVector.set(0, 0);
                    handle.style.transform = 'translate(-50%, -50%)';
                });
            }
            
            updateJoystick(touch, joystick, handle) {
                const rect = joystick.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                let deltaX = touch.clientX - centerX;
                let deltaY = touch.clientY - centerY;
                
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                const maxDistance = rect.width / 2 - 25; // handle radius
                
                if (distance > maxDistance) {
                    deltaX = (deltaX / distance) * maxDistance;
                    deltaY = (deltaY / distance) * maxDistance;
                }
                
                handle.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;
                
                this.joystickVector.x = deltaX / maxDistance;
                this.joystickVector.y = -deltaY / maxDistance;
            }
            
            updateHover() {
                // Cast ray from camera center
                this.raycaster.setFromCamera(new THREE.Vector2(0, 0), this.camera);
                const intersects = this.raycaster.intersectObjects(this.artworks, true);
                
                if (intersects.length > 0) {
                    const artwork = intersects[0].object.parent || intersects[0].object;
                    
                    if (artwork.userData && artwork.userData.title && artwork !== this.hoveredArtwork) {
                        this.hoveredArtwork = artwork;
                        
                        // Show tooltip
                        this.tooltipTitle.textContent = `${artwork.userData.icon} ${artwork.userData.title}`;
                        this.tooltipDescription.textContent = artwork.userData.description;
                        this.tooltip.classList.add('visible');
                        
                        // Position tooltip
                        const vector = new THREE.Vector3();
                        artwork.getWorldPosition(vector);
                        vector.project(this.camera);
                        
                        const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                        const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
                        
                        this.tooltip.style.left = `${Math.min(x + 20, window.innerWidth - 420)}px`;
                        this.tooltip.style.top = `${Math.min(y - 50, window.innerHeight - 250)}px`;
                    }
                } else {
                    if (this.hoveredArtwork) {
                        this.hoveredArtwork = null;
                        this.tooltip.classList.remove('visible');
                    }
                }
            }
            
            updateMovement() {
                const forward = new THREE.Vector3();
                const right = new THREE.Vector3();
                
                this.camera.getWorldDirection(forward);
                forward.y = 0;
                forward.normalize();
                
                right.crossVectors(forward, new THREE.Vector3(0, 1, 0));
                
                if (this.isMobile) {
                    // Mobile joystick movement
                    if (this.joystickActive) {
                        const moveForward = forward.multiplyScalar(this.joystickVector.y * this.moveSpeed);
                        const moveRight = right.multiplyScalar(this.joystickVector.x * this.moveSpeed);
                        this.camera.position.add(moveForward);
                        this.camera.position.add(moveRight);
                    }
                } else {
                    // Desktop keyboard movement
                    if (this.keys.w) this.camera.position.add(forward.multiplyScalar(this.moveSpeed));
                    if (this.keys.s) this.camera.position.add(forward.multiplyScalar(-this.moveSpeed));
                    if (this.keys.a) this.camera.position.add(right.multiplyScalar(-this.moveSpeed));
                    if (this.keys.d) this.camera.position.add(right.multiplyScalar(this.moveSpeed));
                }
                
                // Update camera rotation
                this.camera.rotation.order = 'YXZ';
                this.camera.rotation.y = this.rotation.y;
                this.camera.rotation.x = this.rotation.x;
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                // Update movement
                this.updateMovement();
                
                // Update hover detection
                this.updateHover();
                
                // Animate floating cubes
                this.scene.children.forEach(child => {
                    if (child.userData.floatSpeed) {
                        child.position.y += Math.sin(Date.now() * child.userData.floatSpeed) * 0.01;
                        child.rotation.x += child.userData.rotateSpeed;
                        child.rotation.y += child.userData.rotateSpeed * 0.7;
                    }
                });
                
                this.renderer.render(this.scene, this.camera);
            }
            
            cleanup() {
                if (this.renderer) {
                    threeContainer.removeChild(this.renderer.domElement);
                    this.renderer.dispose();
                }
                
                // Hide tooltip
                this.tooltip.classList.remove('visible');
                
                // Hide mobile controls
                document.getElementById('mobile-controls').classList.remove('show');
                
                // Exit pointer lock
                if (document.pointerLockElement) {
                    document.exitPointerLock();
                }
                
                // Remove event listeners
                window.removeEventListener('keydown', this.handleKeyDown);
                window.removeEventListener('keyup', this.handleKeyUp);
            }
        }
        
        // Initialize gallery
        window.addEventListener('DOMContentLoaded', () => {
            // Show environment info
            if (isLocal) {
                console.log('üè† Running in LOCAL mode - will use local file paths');
                showToast('Running locally - using local file paths', 'success');
            } else {
                console.log('üåê Running in PRODUCTION mode - will use GitHub Pages URLs');
            }
            
            fetchRepoFiles();
        });
    </script>
</body>
</html>