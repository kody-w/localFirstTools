{
  "id": "color-jumper",
  "name": "Color Jumper",
  "description": "Jump between platforms of matching colors to reach new heights",
  "icon": "ðŸŒˆ",
  "gameData": {
    "width": 20,
    "height": 30,
    "backgroundColor": "#111122",
    "colors": [
      "#FF5252",
      "#FFEB3B",
      "#4CAF50",
      "#2196F3",
      "#9C27B0"
    ],
    "playerSize": 12,
    "platformWidth": 40,
    "platformHeight": 10,
    "initialSpeed": 1.5,
    "gravity": 0.25
  },
  "initializeCode": "function(display) {\n  this.display = display;\n  this.canvas = document.createElement('canvas');\n  this.canvas.width = 280;\n  this.canvas.height = 248;\n  display.appendChild(this.canvas);\n  this.ctx = this.canvas.getContext('2d');\n  \n  // Initialize game state\n  this.player = {\n    x: this.canvas.width / 2,\n    y: this.canvas.height - 50,\n    vx: 0,\n    vy: 0,\n    width: this.gameData.playerSize,\n    height: this.gameData.playerSize,\n    colorIndex: Math.floor(Math.random() * this.gameData.colors.length),\n    canJump: false\n  };\n  \n  this.camera = {\n    y: 0,\n    targetY: 0\n  };\n  \n  this.platforms = [];\n  this.generateInitialPlatforms();\n  \n  this.score = 0;\n  this.highScore = 0;\n  this.gameOver = false;\n  this.speed = this.gameData.initialSpeed;\n  this.jumpVelocity = -10;\n  \n  this.inputState = {\n    left: false,\n    right: false,\n    up: false\n  };\n  \n  this.render();\n}",
  "handleInputCode": "function(button, isPressed) {\n  if (this.gameOver && isPressed && button === 'a') {\n    this.restart();\n    return;\n  }\n  \n  switch(button) {\n    case 'left':\n      this.inputState.left = isPressed;\n      break;\n    case 'right':\n      this.inputState.right = isPressed;\n      break;\n    case 'up':\n    case 'a':\n      this.inputState.up = isPressed;\n      if (isPressed && this.player.canJump) {\n        this.player.vy = this.jumpVelocity;\n        this.player.canJump = false;\n      }\n      break;\n    case 'b':\n      if (isPressed) {\n        // Change player color and provide a small upward boost\n        // This gives the player a chance to reach new platforms\n        this.player.colorIndex = (this.player.colorIndex + 1) % this.gameData.colors.length;\n        \n        // Add a small vertical boost when changing color (if not already jumping high)\n        if (this.player.vy > -5) {\n          this.player.vy = -5;\n        }\n      }\n      break;\n  }\n}",
  "updateCode": "function(deltaTime) {\n  if (this.gameOver) return;\n  \n  const dt = Math.min(deltaTime / 16, 2); // Cap delta time\n  \n  // Update player horizontal movement\n  const moveSpeed = 5 * dt;\n  if (this.inputState.left) {\n    this.player.vx = -moveSpeed;\n  } else if (this.inputState.right) {\n    this.player.vx = moveSpeed;\n  } else {\n    this.player.vx *= 0.8; // Deceleration\n  }\n  \n  // Apply gravity\n  this.player.vy += this.gameData.gravity * dt;\n  \n  // Update player position\n  this.player.x += this.player.vx * dt;\n  this.player.y += this.player.vy * dt;\n  \n  // Screen boundaries\n  if (this.player.x < 0) {\n    this.player.x = 0;\n    this.player.vx = 0;\n  } else if (this.player.x + this.player.width > this.canvas.width) {\n    this.player.x = this.canvas.width - this.player.width;\n    this.player.vx = 0;\n  }\n  \n  // Check for platform collisions\n  let platformCollision = false;\n  this.player.canJump = false;\n  \n  for (let i = 0; i < this.platforms.length; i++) {\n    const platform = this.platforms[i];\n    \n    // Check if player is falling onto a platform (only check platforms with matching color)\n    if (this.player.vy > 0 && \n        this.player.y + this.player.height >= platform.y && \n        this.player.y < platform.y + platform.height &&\n        this.player.x + this.player.width > platform.x &&\n        this.player.x < platform.x + platform.width &&\n        platform.colorIndex === this.player.colorIndex) {\n      \n      this.player.y = platform.y - this.player.height;\n      this.player.vy = 0;\n      this.player.canJump = true;\n      platformCollision = true;\n      \n      // Update score based on platform height\n      const newScore = Math.floor(this.canvas.height - platform.y);\n      if (newScore > this.score) {\n        this.score = newScore;\n        if (this.score > this.highScore) {\n          this.highScore = this.score;\n        }\n      }\n      \n      // No need to check other platforms after a collision\n      break;\n    }\n  }\n  \n  // Update camera position - smooth follow\n  const maxPlayerHeight = this.canvas.height * 0.6;\n  if (this.player.y < maxPlayerHeight) {\n    this.camera.targetY = this.canvas.height - this.player.y - maxPlayerHeight;\n  }\n  this.camera.y += (this.camera.targetY - this.camera.y) * 0.1 * dt;\n  \n  // Generate new platforms as the player climbs\n  this.generatePlatforms();\n  \n  // Remove platforms that are too far below\n  this.platforms = this.platforms.filter(p => p.y < this.canvas.height - this.camera.y + 100);\n  \n  // Check if player has fallen off the bottom\n  if (this.player.y > this.canvas.height - this.camera.y + 100) {\n    this.gameOver = true;\n  }\n  \n  // Increase speed as player progresses\n  this.speed = this.gameData.initialSpeed + (this.score / 1000);\n}",
  "renderCode": "function() {\n  // Clear canvas\n  this.ctx.fillStyle = this.gameData.backgroundColor;\n  this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n  \n  // Apply camera transform\n  this.ctx.save();\n  this.ctx.translate(0, this.camera.y);\n  \n  // Draw platforms\n  for (let i = 0; i < this.platforms.length; i++) {\n    const platform = this.platforms[i];\n    this.ctx.fillStyle = this.gameData.colors[platform.colorIndex];\n    \n    // Highlight platforms that match player's color for better visibility\n    if (platform.colorIndex === this.player.colorIndex) {\n      // Draw a glowing effect around matching platforms\n      this.ctx.shadowColor = this.gameData.colors[platform.colorIndex];\n      this.ctx.shadowBlur = 10;\n    }\n    \n    this.ctx.fillRect(platform.x, platform.y, platform.width, platform.height);\n    \n    // Reset shadow\n    this.ctx.shadowColor = 'transparent';\n    this.ctx.shadowBlur = 0;\n  }\n  \n  // Draw player\n  this.ctx.fillStyle = this.gameData.colors[this.player.colorIndex];\n  this.ctx.shadowColor = this.gameData.colors[this.player.colorIndex];\n  this.ctx.shadowBlur = 8;\n  this.ctx.fillRect(this.player.x, this.player.y, this.player.width, this.player.height);\n  this.ctx.shadowColor = 'transparent';\n  this.ctx.shadowBlur = 0;\n  \n  // Restore context\n  this.ctx.restore();\n  \n  // Draw HUD\n  this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\n  this.ctx.fillRect(0, 0, this.canvas.width, 30);\n  \n  this.ctx.fillStyle = 'white';\n  this.ctx.font = '12px \"Press Start 2P\"';\n  this.ctx.textAlign = 'left';\n  this.ctx.textBaseline = 'top';\n  this.ctx.fillText(`SCORE: ${this.score}`, 10, 10);\n  \n  this.ctx.textAlign = 'right';\n  this.ctx.fillText(`BEST: ${this.highScore}`, this.canvas.width - 10, 10);\n  \n  // Current color indicator\n  this.ctx.fillStyle = this.gameData.colors[this.player.colorIndex];\n  this.ctx.shadowColor = this.gameData.colors[this.player.colorIndex];\n  this.ctx.shadowBlur = 10;\n  this.ctx.fillRect(this.canvas.width / 2 - 10, 5, 20, 20);\n  this.ctx.shadowColor = 'transparent';\n  this.ctx.shadowBlur = 0;\n  \n  // Add control hint\n  this.ctx.textAlign = 'center';\n  this.ctx.fillStyle = 'white';\n  this.ctx.font = '8px \"Press Start 2P\"';\n  this.ctx.fillText('B: CHANGE COLOR', this.canvas.width / 2, 27);\n  \n  // Game over screen\n  if (this.gameOver) {\n    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';\n    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n    \n    this.ctx.fillStyle = 'white';\n    this.ctx.textAlign = 'center';\n    this.ctx.textBaseline = 'middle';\n    this.ctx.font = '20px \"Press Start 2P\"';\n    this.ctx.fillText('GAME OVER', this.canvas.width / 2, this.canvas.height / 2 - 20);\n    \n    this.ctx.font = '12px \"Press Start 2P\"';\n    this.ctx.fillText(`SCORE: ${this.score}`, this.canvas.width / 2, this.canvas.height / 2 + 10);\n    this.ctx.fillText('PRESS A TO RESTART', this.canvas.width / 2, this.canvas.height / 2 + 40);\n  }\n}",
  "cleanupCode": "function() {\n  if (this.canvas && this.canvas.parentNode) {\n    this.canvas.parentNode.removeChild(this.canvas);\n  }\n}",
  "additionalFunctions": {
    "generateInitialPlatforms": "function() {\n  // Add starting platform\n  this.platforms.push({\n    x: this.canvas.width / 2 - this.gameData.platformWidth / 2,\n    y: this.canvas.height - 40,\n    width: this.gameData.platformWidth,\n    height: this.gameData.platformHeight,\n    colorIndex: this.player.colorIndex\n  });\n  \n  // Generate initial set of platforms above\n  for (let y = this.canvas.height - 100; y > 0; y -= 60) {\n    this.platforms.push(this.createRandomPlatform(y));\n  }\n}",
    "generatePlatforms": "function() {\n  // Check if we need to generate more platforms\n  const topPlatformY = Math.min(...this.platforms.map(p => p.y));\n  const screenTop = -this.camera.y;\n  \n  if (topPlatformY > screenTop - 200) {\n    // Generate more platforms with decreased vertical spacing for easier access\n    for (let y = topPlatformY - 50; y > screenTop - 200; y -= 50) {\n      this.platforms.push(this.createRandomPlatform(y));\n    }\n\n    // Check if any of the platforms ahead match the player's color\n    let hasMatchingPlatform = false;\n    for (const platform of this.platforms) {\n      if (platform.y < topPlatformY && platform.colorIndex === this.player.colorIndex) {\n        hasMatchingPlatform = true;\n        break;\n      }\n    }\n    \n    // If no matching platforms ahead, force create one\n    if (!hasMatchingPlatform) {\n      const emergencyY = topPlatformY - 50;\n      this.platforms.push({\n        x: Math.random() * (this.canvas.width - this.gameData.platformWidth),\n        y: emergencyY,\n        width: this.gameData.platformWidth,\n        height: this.gameData.platformHeight,\n        colorIndex: this.player.colorIndex\n      });\n    }\n  }\n}",
    "createRandomPlatform": "function(y) {\n  const width = this.gameData.platformWidth * (0.8 + Math.random() * 0.4);\n  const x = Math.random() * (this.canvas.width - width);\n  \n  // Guarantee at least every third platform matches the player's color\n  // to ensure the player always has a path forward\n  let colorIndex;\n  if (this.platforms.length % 3 === 0) {\n    colorIndex = this.player.colorIndex;\n  } else {\n    colorIndex = Math.floor(Math.random() * this.gameData.colors.length);\n  }\n  \n  return {\n    x: x,\n    y: y,\n    width: width,\n    height: this.gameData.platformHeight,\n    colorIndex: colorIndex\n  };\n}",
    "restart": "function() {\n  this.player = {\n    x: this.canvas.width / 2,\n    y: this.canvas.height - 50,\n    vx: 0,\n    vy: 0,\n    width: this.gameData.playerSize,\n    height: this.gameData.playerSize,\n    colorIndex: Math.floor(Math.random() * this.gameData.colors.length),\n    canJump: false\n  };\n  \n  this.camera = {\n    y: 0,\n    targetY: 0\n  };\n  \n  this.platforms = [];\n  this.generateInitialPlatforms();\n  \n  this.score = 0;\n  this.gameOver = false;\n  this.speed = this.gameData.initialSpeed;\n}"
  }
}