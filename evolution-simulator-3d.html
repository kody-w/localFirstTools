<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Evolution Simulator 3D: Neural Genesis</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; color: #fff; }
        #canvas { width: 100vw; height: 100vh; display: block; }
        
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        .panel {
            background: rgba(0, 20, 40, 0.8);
            border: 1px solid #00ffff;
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 8px;
            pointer-events: auto;
            position: absolute;
        }
        
        #stats-panel {
            top: 20px;
            left: 20px;
            width: 250px;
        }
        
        #graph-panel {
            bottom: 20px;
            left: 20px;
            width: 300px;
            height: 150px;
        }
        
        #controls-panel {
            bottom: 20px;
            right: 20px;
            text-align: right;
        }
        
        #creature-info {
            top: 20px;
            right: 20px;
            width: 250px;
            display: none;
        }
        
        h2 { margin: 0 0 10px 0; font-size: 18px; color: #00ffff; text-transform: uppercase; letter-spacing: 1px; }
        
        .stat-row { display: flex; justify-content: space-between; margin-bottom: 5px; font-size: 14px; }
        .stat-label { color: #aaa; }
        .stat-value { font-weight: bold; color: #fff; }
        
        button {
            background: rgba(0, 100, 200, 0.5);
            border: 1px solid #00ffff;
            color: #fff;
            padding: 8px 15px;
            margin-left: 10px;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
            font-weight: bold;
        }
        
        button:hover { background: rgba(0, 150, 255, 0.8); box-shadow: 0 0 10px #00ffff; }
        
        canvas#graph-canvas { width: 100%; height: 100%; }
        
        .dna-bar {
            height: 4px;
            background: #333;
            margin-top: 2px;
            border-radius: 2px;
            overflow: hidden;
        }
        .dna-fill { height: 100%; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div id="ui-layer">
        <div id="stats-panel" class="panel">
            <h2>Simulation Stats</h2>
            <div class="stat-row"><span class="stat-label">Population:</span><span class="stat-value" id="pop-count">0</span></div>
            <div class="stat-row"><span class="stat-label">Generation:</span><span class="stat-value" id="gen-count">0</span></div>
            <div class="stat-row"><span class="stat-label">Time Scale:</span><span class="stat-value" id="time-scale">1.0x</span></div>
            <div class="stat-row"><span class="stat-label">Food Count:</span><span class="stat-value" id="food-count">0</span></div>
            <hr style="border-color: #333; margin: 10px 0;">
            <div class="stat-row"><span class="stat-label">Avg Speed:</span><span class="stat-value" id="avg-speed">0</span></div>
            <div class="stat-row"><span class="stat-label">Avg Size:</span><span class="stat-value" id="avg-size">0</span></div>
            <div class="stat-row"><span class="stat-label">Avg Sense:</span><span class="stat-value" id="avg-sense">0</span></div>
        </div>
        
        <div id="creature-info" class="panel">
            <h2>Specimen Analysis</h2>
            <div class="stat-row"><span class="stat-label">ID:</span><span class="stat-value" id="c-id">#000</span></div>
            <div class="stat-row"><span class="stat-label">Energy:</span><span class="stat-value" id="c-energy">100%</span></div>
            <div class="stat-row"><span class="stat-label">Age:</span><span class="stat-value" id="c-age">0</span></div>
            <div class="stat-row"><span class="stat-label">Children:</span><span class="stat-value" id="c-children">0</span></div>
            
            <div style="margin-top: 10px;">
                <div class="stat-row"><span class="stat-label">Speed Gene</span><span class="stat-value" id="c-speed-val">0.0</span></div>
                <div class="dna-bar"><div class="dna-fill" id="c-speed-bar" style="background: #ff3333; width: 0%"></div></div>
            </div>
            <div style="margin-top: 5px;">
                <div class="stat-row"><span class="stat-label">Size Gene</span><span class="stat-value" id="c-size-val">0.0</span></div>
                <div class="dna-bar"><div class="dna-fill" id="c-size-bar" style="background: #33ff33; width: 0%"></div></div>
            </div>
            <div style="margin-top: 5px;">
                <div class="stat-row"><span class="stat-label">Sense Gene</span><span class="stat-value" id="c-sense-val">0.0</span></div>
                <div class="dna-bar"><div class="dna-fill" id="c-sense-bar" style="background: #3333ff; width: 0%"></div></div>
            </div>
            
            <div style="margin-top: 15px; text-align: center;">
                <button onclick="followCreature()">Follow Camera</button>
            </div>
        </div>
        
        <div id="graph-panel" class="panel">
            <canvas id="graph-canvas"></canvas>
        </div>
        
        <div id="controls-panel" class="panel">
            <button onclick="resetSim()">RESET WORLD</button>
            <button onclick="togglePause()">PAUSE</button>
            <button onclick="changeSpeed()">SPEED UP</button>
            <button onclick="spawnMeteor()">METEOR STRIKE</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // --- Configuration ---
        const WORLD_SIZE = 400;
        const START_POP = 40;
        const FOOD_RATE = 0.8;
        const MUTATION_RATE = 0.15;
        
        // --- Globals ---
        let scene, camera, renderer;
        let creatures = [];
        let foodItems = [];
        let particles = [];
        let clock = new THREE.Clock();
        let timeScale = 1.0;
        let paused = false;
        let generation = 1;
        let selectedCreature = null;
        let following = false;
        let history = [];
        
        // --- Three.js Setup ---
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050510);
            scene.fog = new THREE.FogExp2(0x050510, 0.002);
            
            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 1000);
            camera.position.set(0, 300, 200);
            camera.lookAt(0, 0, 0);
            
            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            
            // Lights
            const ambient = new THREE.AmbientLight(0x404040);
            scene.add(ambient);
            
            const sun = new THREE.DirectionalLight(0xffffff, 1);
            sun.position.set(100, 200, 100);
            sun.castShadow = true;
            sun.shadow.camera.top = 200;
            sun.shadow.camera.bottom = -200;
            sun.shadow.camera.left = -200;
            sun.shadow.camera.right = 200;
            sun.shadow.mapSize.width = 2048;
            sun.shadow.mapSize.height = 2048;
            scene.add(sun);
            
            // Ground
            const grid = new THREE.GridHelper(WORLD_SIZE, 40, 0x333333, 0x111111);
            scene.add(grid);
            
            const groundGeo = new THREE.PlaneGeometry(WORLD_SIZE, WORLD_SIZE);
            const groundMat = new THREE.MeshPhongMaterial({ 
                color: 0x0a0a0a, 
                shininess: 0 
            });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI/2;
            ground.position.y = -0.1;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Initial Population
            spawnPopulation();
            
            // Event Listeners
            window.addEventListener('resize', onResize);
            document.addEventListener('mousedown', onMouseDown);
            
            animate();
        }
        
        function spawnPopulation() {
            for(let i=0; i<START_POP; i++) {
                spawnCreature();
            }
            
            // Initial Food
            for(let i=0; i<100; i++) {
                spawnFood();
            }
        }
        
        // --- Classes ---
        class Creature {
            constructor(dna, pos) {
                this.id = Math.floor(Math.random() * 10000);
                
                // DNA: Speed (Red), Size (Green), Sense (Blue)
                this.dna = dna || {
                    speed: 0.5 + Math.random() * 0.5,
                    size: 0.5 + Math.random() * 1.0,
                    sense: 0.5 + Math.random() * 0.5
                };
                
                // Stats
                this.energy = 100;
                this.maxEnergy = 100 + (this.dna.size * 50);
                this.age = 0;
                this.children = 0;
                this.dead = false;
                
                // Physics
                this.pos = pos || new THREE.Vector3(
                    (Math.random() - 0.5) * WORLD_SIZE * 0.9,
                    0,
                    (Math.random() - 0.5) * WORLD_SIZE * 0.9
                );
                this.vel = new THREE.Vector3(Math.random()-0.5, 0, Math.random()-0.5).normalize();
                
                // Mesh
                const geometry = new THREE.ConeGeometry(2 * this.dna.size, 6 * this.dna.size, 8);
                geometry.rotateX(Math.PI/2); // Point forward
                
                const color = new THREE.Color(
                    this.dna.speed, // Red = Speed
                    this.dna.size * 0.5, // Green = Size
                    this.dna.sense // Blue = Sense
                );
                
                const material = new THREE.MeshPhongMaterial({ color: color, shininess: 30 });
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.castShadow = true;
                this.mesh.receiveShadow = true;
                this.mesh.position.copy(this.pos);
                this.mesh.position.y = 2 * this.dna.size;
                
                // Sense Radius Ring (only visible when selected)
                const ringGeo = new THREE.RingGeometry(this.dna.sense * 40, this.dna.sense * 40 + 0.5, 32);
                const ringMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.2, side: THREE.DoubleSide });
                this.senseRing = new THREE.Mesh(ringGeo, ringMat);
                this.senseRing.rotation.x = -Math.PI/2;
                this.senseRing.visible = false;
                this.mesh.add(this.senseRing);
                
                scene.add(this.mesh);
            }
            
            update(dt) {
                if(this.dead) return;
                
                this.age += dt;
                
                // Energy Cost Calculation
                // Speed costs energy^2, Size costs energy^3, Sense is linear
                const metabolicRate = (this.dna.speed * this.dna.speed * 2) + 
                                      (this.dna.size * this.dna.size * this.dna.size * 0.5) + 
                                      (this.dna.sense * 0.5);
                                      
                this.energy -= metabolicRate * dt * 5;
                
                if(this.energy <= 0) {
                    this.die();
                    return;
                }
                
                // Behavior: Seek Food
                let nearestFood = null;
                let minDist = this.dna.sense * 50; // Sense range
                
                for(let f of foodItems) {
                    const d = this.pos.distanceTo(f.mesh.position);
                    if(d < minDist) {
                        minDist = d;
                        nearestFood = f;
                    }
                }
                
                if(nearestFood) {
                    // Move towards food
                    const dir = new THREE.Vector3().subVectors(nearestFood.mesh.position, this.pos).normalize();
                    // Steer
                    this.vel.lerp(dir, 0.1);
                } else {
                    // Wander
                    if(Math.random() < 0.05) {
                        const wander = new THREE.Vector3(Math.random()-0.5, 0, Math.random()-0.5).normalize();
                        this.vel.lerp(wander, 0.2);
                    }
                }
                
                this.vel.normalize();
                
                // Move
                const speed = this.dna.speed * 20;
                this.pos.add(this.vel.clone().multiplyScalar(speed * dt));
                
                // Boundaries (Bounce)
                const limit = WORLD_SIZE / 2;
                if(Math.abs(this.pos.x) > limit) {
                    this.pos.x = Math.sign(this.pos.x) * limit;
                    this.vel.x *= -1;
                }
                if(Math.abs(this.pos.z) > limit) {
                    this.pos.z = Math.sign(this.pos.z) * limit;
                    this.vel.z *= -1;
                }
                
                // Update Mesh
                this.mesh.position.copy(this.pos);
                this.mesh.position.y = 2 * this.dna.size; // Keep on ground
                this.mesh.lookAt(this.pos.clone().add(this.vel));
                
                // Eat Food
                if(nearestFood && minDist < 5 * this.dna.size) {
                    this.eat(nearestFood);
                }
                
                // Reproduce
                if(this.energy > this.maxEnergy * 0.8 && Math.random() < 0.01) {
                    this.reproduce();
                }
            }
            
            eat(food) {
                this.energy += 30;
                if(this.energy > this.maxEnergy) this.energy = this.maxEnergy;
                
                // Remove food
                scene.remove(food.mesh);
                const idx = foodItems.indexOf(food);
                if(idx > -1) foodItems.splice(idx, 1);
                
                // Particle effect
                spawnParticles(food.mesh.position, 0x00ff00, 5);
            }
            
            reproduce() {
                this.energy *= 0.5; // Cost of reproduction
                this.children++;
                
                // Mutate DNA
                const newDna = {
                    speed: clamp(this.dna.speed + (Math.random()-0.5) * MUTATION_RATE, 0.1, 2.0),
                    size: clamp(this.dna.size + (Math.random()-0.5) * MUTATION_RATE, 0.2, 3.0),
                    sense: clamp(this.dna.sense + (Math.random()-0.5) * MUTATION_RATE, 0.1, 3.0)
                };
                
                const child = new Creature(newDna, this.pos.clone());
                creatures.push(child);
                
                // Particle effect
                spawnParticles(this.pos, 0xffffff, 10);
            }
            
            die() {
                this.dead = true;
                scene.remove(this.mesh);
                
                // Turn into food
                spawnFood(this.pos.clone());
                spawnParticles(this.pos, 0xff0000, 8);
                
                if(selectedCreature === this) {
                    deselectCreature();
                }
            }
        }
        
        class Food {
            constructor(pos) {
                this.pos = pos || new THREE.Vector3(
                    (Math.random() - 0.5) * WORLD_SIZE,
                    1,
                    (Math.random() - 0.5) * WORLD_SIZE
                );
                
                const geometry = new THREE.IcosahedronGeometry(1, 0);
                const material = new THREE.MeshPhongMaterial({ 
                    color: 0x00ff00, 
                    emissive: 0x004400 
                });
                
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.copy(this.pos);
                
                // Float animation offset
                this.offset = Math.random() * Math.PI * 2;
                
                scene.add(this.mesh);
            }
            
            update(time) {
                this.mesh.position.y = 1 + Math.sin(time * 2 + this.offset) * 0.5;
                this.mesh.rotation.y += 0.02;
            }
        }
        
        // --- Helpers ---
        function spawnCreature() {
            creatures.push(new Creature());
        }
        
        function spawnFood(pos) {
            foodItems.push(new Food(pos));
        }
        
        function spawnParticles(pos, color, count) {
            // Simple particle system could go here
            // For now, just a placeholder
        }
        
        function clamp(val, min, max) {
            return Math.min(Math.max(val, min), max);
        }
        
        // --- Main Loop ---
        function animate() {
            requestAnimationFrame(animate);
            
            const dt = Math.min(clock.getDelta(), 0.1) * timeScale;
            const time = clock.getElapsedTime();
            
            if(!paused) {
                // Spawn Food
                if(Math.random() < FOOD_RATE * timeScale && foodItems.length < 300) {
                    spawnFood();
                }
                
                // Update Creatures
                for(let i = creatures.length - 1; i >= 0; i--) {
                    const c = creatures[i];
                    c.update(dt);
                    if(c.dead) {
                        creatures.splice(i, 1);
                    }
                }
                
                // Update Food
                for(let f of foodItems) {
                    f.update(time);
                }
                
                // Extinction Check
                if(creatures.length === 0) {
                    spawnPopulation();
                    generation++;
                }
                
                // Stats
                if(Math.floor(time * 10) % 10 === 0) {
                    updateStats();
                }
            }
            
            // Camera Follow
            if(following && selectedCreature && !selectedCreature.dead) {
                const targetPos = selectedCreature.mesh.position.clone();
                const offset = new THREE.Vector3(0, 20, 20);
                camera.position.lerp(targetPos.add(offset), 0.1);
                camera.lookAt(selectedCreature.mesh.position);
            }
            
            renderer.render(scene, camera);
        }
        
        // --- UI & Interaction ---
        function updateStats() {
            document.getElementById('pop-count').textContent = creatures.length;
            document.getElementById('gen-count').textContent = generation;
            document.getElementById('food-count').textContent = foodItems.length;
            
            let avgSpeed = 0, avgSize = 0, avgSense = 0;
            for(let c of creatures) {
                avgSpeed += c.dna.speed;
                avgSize += c.dna.size;
                avgSense += c.dna.sense;
            }
            
            if(creatures.length > 0) {
                avgSpeed /= creatures.length;
                avgSize /= creatures.length;
                avgSense /= creatures.length;
            }
            
            document.getElementById('avg-speed').textContent = avgSpeed.toFixed(2);
            document.getElementById('avg-size').textContent = avgSize.toFixed(2);
            document.getElementById('avg-sense').textContent = avgSense.toFixed(2);
            
            // Update Graph Data
            history.push({ speed: avgSpeed, size: avgSize, sense: avgSense });
            if(history.length > 100) history.shift();
            drawGraph();
            
            // Update Selected Info
            if(selectedCreature && !selectedCreature.dead) {
                document.getElementById('c-energy').textContent = Math.round(selectedCreature.energy) + '/' + Math.round(selectedCreature.maxEnergy);
                document.getElementById('c-age').textContent = Math.round(selectedCreature.age);
                document.getElementById('c-children').textContent = selectedCreature.children;
            } else if (selectedCreature && selectedCreature.dead) {
                document.getElementById('c-energy').textContent = "DEAD";
            }
        }
        
        function drawGraph() {
            const canvas = document.getElementById('graph-canvas');
            const ctx = canvas.getContext('2d');
            const w = canvas.width = canvas.offsetWidth;
            const h = canvas.height = canvas.offsetHeight;
            
            ctx.clearRect(0, 0, w, h);
            
            if(history.length < 2) return;
            
            // Helper to draw line
            function drawLine(prop, color, scale) {
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                for(let i=0; i<history.length; i++) {
                    const x = (i / (history.length-1)) * w;
                    const val = history[i][prop];
                    const y = h - (val * scale * h / 4); // Scale factor
                    if(i===0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }
            
            drawLine('speed', '#ff3333', 1);
            drawLine('size', '#33ff33', 0.5);
            drawLine('sense', '#3333ff', 1);
        }
        
        function onMouseDown(event) {
            if(event.target.tagName !== 'CANVAS') return;
            
            const mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            
            const intersects = raycaster.intersectObjects(scene.children, true);
            
            for(let hit of intersects) {
                // Find parent creature mesh
                let obj = hit.object;
                while(obj.parent && obj.parent !== scene) {
                    obj = obj.parent;
                }
                
                // Check if it's a creature
                const creature = creatures.find(c => c.mesh === obj);
                if(creature) {
                    selectCreature(creature);
                    return;
                }
            }
            
            // Deselect if clicked empty space
            deselectCreature();
        }
        
        function selectCreature(c) {
            if(selectedCreature) selectedCreature.senseRing.visible = false;
            selectedCreature = c;
            c.senseRing.visible = true;
            
            const info = document.getElementById('creature-info');
            info.style.display = 'block';
            document.getElementById('c-id').textContent = '#' + c.id;
            
            document.getElementById('c-speed-val').textContent = c.dna.speed.toFixed(2);
            document.getElementById('c-speed-bar').style.width = (c.dna.speed / 2 * 100) + '%';
            
            document.getElementById('c-size-val').textContent = c.dna.size.toFixed(2);
            document.getElementById('c-size-bar').style.width = (c.dna.size / 3 * 100) + '%';
            
            document.getElementById('c-sense-val').textContent = c.dna.sense.toFixed(2);
            document.getElementById('c-sense-bar').style.width = (c.dna.sense / 3 * 100) + '%';
        }
        
        function deselectCreature() {
            if(selectedCreature) selectedCreature.senseRing.visible = false;
            selectedCreature = null;
            following = false;
            document.getElementById('creature-info').style.display = 'none';
            
            // Reset camera
            camera.position.set(0, 300, 200);
            camera.lookAt(0, 0, 0);
        }
        
        function followCreature() {
            following = true;
        }
        
        function resetSim() {
            // Clear
            for(let c of creatures) scene.remove(c.mesh);
            for(let f of foodItems) scene.remove(f.mesh);
            creatures = [];
            foodItems = [];
            history = [];
            generation = 1;
            
            spawnPopulation();
        }
        
        function togglePause() {
            paused = !paused;
        }
        
        function changeSpeed() {
            if(timeScale === 1.0) timeScale = 5.0;
            else if(timeScale === 5.0) timeScale = 20.0;
            else timeScale = 1.0;
            document.getElementById('time-scale').textContent = timeScale.toFixed(1) + 'x';
        }
        
        function spawnMeteor() {
            // Kill 80% of population
            const survivors = Math.floor(creatures.length * 0.2);
            while(creatures.length > survivors) {
                const idx = Math.floor(Math.random() * creatures.length);
                creatures[idx].die();
                creatures.splice(idx, 1);
            }
            // Flash screen
            const flash = document.createElement('div');
            flash.style.position = 'fixed';
            flash.style.top = 0; flash.style.left = 0;
            flash.style.width = '100%'; flash.style.height = '100%';
            flash.style.background = 'white';
            flash.style.opacity = 1;
            flash.style.transition = 'opacity 1s';
            flash.style.pointerEvents = 'none';
            document.body.appendChild(flash);
            setTimeout(() => flash.style.opacity = 0, 50);
            setTimeout(() => flash.remove(), 1000);
        }
        
        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        init();
    </script>
</body>
</html>