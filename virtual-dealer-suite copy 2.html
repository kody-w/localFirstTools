<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Virtual Dealer Suite</title>
    <meta name="description" content="A comprehensive card game suite featuring a Virtual Dealer. Play War, Blackjack, and Texas Hold'em against an AI opponent that teaches and challenges you.">
    <style>
        :root {
            --table-color: #2d5e3e;
            --table-dark: #1a3c26;
            --card-width: 100px;
            --card-height: 140px;
            --accent: #ffd700;
            --text-color: #ffffff;
        }

        * {
            box-sizing: border-box;
            user-select: none;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: radial-gradient(circle at center, var(--table-color), var(--table-dark));
            color: var(--text-color);
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* Header & Dealer Area */
        header {
            padding: 15px;
            background: rgba(0,0,0,0.3);
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .dealer-persona {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .dealer-avatar {
            width: 60px;
            height: 60px;
            background: #333;
            border-radius: 50%;
            border: 2px solid var(--accent);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 30px;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><circle cx="50" cy="50" r="45" fill="%23444"/><circle cx="35" cy="40" r="5" fill="white"/><circle cx="65" cy="40" r="5" fill="white"/><path d="M 30 70 Q 50 80 70 70" stroke="white" stroke-width="3" fill="none"/></svg>');
        }

        .dealer-info h2 {
            margin: 0;
            font-size: 1.2rem;
            color: var(--accent);
        }

        .dealer-info p {
            margin: 5px 0 0;
            font-size: 0.9rem;
            opacity: 0.8;
            font-style: italic;
        }

        /* Game Selection */
        #game-menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(5px);
        }

        .menu-title {
            font-size: 3rem;
            margin-bottom: 40px;
            color: var(--accent);
            text-shadow: 0 2px 10px rgba(0,0,0,0.5);
        }

        .game-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            max-width: 900px;
            width: 90%;
        }

        .game-card {
            background: linear-gradient(145deg, #333, #222);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            cursor: pointer;
            transition: transform 0.2s, border-color 0.2s;
            border: 2px solid transparent;
        }

        .game-card:hover {
            transform: translateY(-5px);
            border-color: var(--accent);
        }

        .game-card h3 {
            font-size: 1.5rem;
            margin-bottom: 10px;
        }

        .game-card p {
            color: #aaa;
            font-size: 0.9rem;
        }

        /* Game Area */
        #game-area {
            flex: 1;
            position: relative;
            display: flex;
            flex-direction: column;
            padding: 20px;
        }

        .table-center {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        .hand-area {
            height: 180px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            padding: 10px;
        }

        .dealer-hand {
            align-items: flex-start;
        }

        .player-hand {
            align-items: flex-end;
        }

        /* Cards */
        .card {
            width: var(--card-width);
            height: var(--card-height);
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 10px;
            font-weight: bold;
            font-size: 24px;
            position: relative;
            transition: transform 0.3s;
        }

        .card.red { color: #d40000; }
        .card.black { color: #000000; }

        .card-corner {
            display: flex;
            flex-direction: column;
            align-items: center;
            line-height: 1;
        }

        .card-corner.bottom {
            transform: rotate(180deg);
        }

        .card-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 40px;
        }

        .card-back {
            background: repeating-linear-gradient(
                45deg,
                #b71c1c,
                #b71c1c 10px,
                #c62828 10px,
                #c62828 20px
            );
            border: 5px solid white;
        }

        .card-back * { display: none; }

        /* Controls */
        #controls {
            height: 100px;
            background: rgba(0,0,0,0.2);
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            padding: 0 20px;
        }

        .btn {
            padding: 12px 30px;
            font-size: 1.1rem;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 1px;
            min-width: 120px;
        }

        .btn-primary {
            background: var(--accent);
            color: #000;
        }

        .btn-primary:hover {
            background: #ffed4a;
            transform: scale(1.05);
        }

        .btn-secondary {
            background: rgba(255,255,255,0.1);
            color: white;
            border: 1px solid rgba(255,255,255,0.3);
        }

        .btn-secondary:hover {
            background: rgba(255,255,255,0.2);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn-autoplay-active {
            background: linear-gradient(45deg, #e74c3c, #c0392b) !important;
            color: white !important;
            border: 2px solid #ff6b6b !important;
            animation: autoplayPulse 1.5s ease-in-out infinite;
        }

        @keyframes autoplayPulse {
            0%, 100% { box-shadow: 0 0 5px #e74c3c; }
            50% { box-shadow: 0 0 20px #e74c3c, 0 0 30px #ff6b6b; }
        }

        /* Messages */
        #message-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            padding: 20px 40px;
            border-radius: 10px;
            text-align: center;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 50;
        }

        #message-overlay.visible {
            opacity: 1;
        }

        #message-overlay h2 {
            color: var(--accent);
            font-size: 2rem;
            margin: 0;
        }

        /* Chips */
        .chip-stack {
            position: absolute;
            bottom: 120px;
            right: 20px;
            text-align: right;
        }

        .chip-count {
            font-size: 1.5rem;
            color: var(--accent);
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }

        /* Animations */
        @keyframes dealCard {
            from { transform: translateY(-200px) rotate(180deg); opacity: 0; }
            to { transform: translateY(0) rotate(0deg); opacity: 1; }
        }
        @keyframes winToPlayer {
            to { transform: translateY(400px) scale(0.5); opacity: 0; }
        }
        @keyframes winToDealer {
            to { transform: translateY(-400px) scale(0.5); opacity: 0; }
        }
        .dealing { animation: dealCard 0.5s ease-out forwards; }
        .win-player { animation: winToPlayer 0.6s ease-in forwards; }
        .win-dealer { animation: winToDealer 0.6s ease-in forwards; }

        /* War Specific UI */
        .war-stats {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            right: 20px;
            text-align: right;
            font-family: monospace;
            color: var(--accent);
        }

        /* Score Tracker */
        .score-tracker {
            position: fixed;
            top: 80px;
            left: 20px;
            background: rgba(0,0,0,0.7);
            padding: 15px 20px;
            border-radius: 10px;
            border: 1px solid rgba(255,215,0,0.3);
            font-family: monospace;
            z-index: 100;
            min-width: 150px;
        }
        .score-tracker h4 {
            margin: 0 0 10px 0;
            color: var(--accent);
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .score-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 1rem;
        }
        .score-player { color: #4caf50; }
        .score-dealer { color: #f44336; }
        .score-tie { color: #ffeb3b; }

        /* Tutor Explanation Panel - Right side, never blocks cards */
        .tutor-panel {
            position: fixed;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            background: linear-gradient(145deg, rgba(0,0,0,0.95), rgba(20,20,40,0.95));
            padding: 15px 20px;
            border-radius: 12px;
            border: 2px solid var(--accent);
            box-shadow: 0 0 20px rgba(255,215,0,0.2);
            z-index: 150;
            max-width: 280px;
            width: 280px;
            text-align: left;
            display: none;
            animation: tutorSlideIn 0.3s ease-out;
        }
        @keyframes tutorSlideIn {
            from { opacity: 0; transform: translateY(-50%) translateX(20px); }
            to { opacity: 1; transform: translateY(-50%) translateX(0); }
        }
        .tutor-panel.visible { display: block; }
        .tutor-panel.paused .tutor-progress-bar {
            animation-play-state: paused;
        }
        .tutor-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .tutor-panel h3 {
            margin: 0;
            color: var(--accent);
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .tutor-close {
            background: none;
            border: none;
            color: #888;
            font-size: 1.2rem;
            cursor: pointer;
            padding: 0 5px;
            line-height: 1;
            transition: color 0.2s;
        }
        .tutor-close:hover { color: #fff; }
        .tutor-explanation {
            font-size: 0.95rem;
            line-height: 1.5;
            color: #eee;
            margin-bottom: 10px;
        }
        .tutor-explanation .highlight {
            color: var(--accent);
            font-weight: bold;
        }
        .tutor-explanation .win { color: #4caf50; font-weight: bold; }
        .tutor-explanation .lose { color: #f44336; font-weight: bold; }
        .tutor-explanation .tie { color: #ffeb3b; font-weight: bold; }
        .tutor-rule {
            font-size: 0.8rem;
            color: #aaa;
            font-style: italic;
            border-top: 1px solid rgba(255,255,255,0.1);
            padding-top: 8px;
            margin-top: 8px;
        }
        .tutor-progress {
            height: 3px;
            background: rgba(255,255,255,0.2);
            border-radius: 2px;
            margin-top: 10px;
            overflow: hidden;
        }
        .tutor-progress-bar {
            height: 100%;
            background: var(--accent);
            border-radius: 2px;
            animation: tutorProgress 3s linear forwards;
        }
        @keyframes tutorProgress {
            from { width: 100%; }
            to { width: 0%; }
        }

        /* ========== LIVING ART MODE ========== */

        /* Dealer Breathing Animation */
        @keyframes dealerBreathe {
            0%, 100% { transform: scale(1); box-shadow: 0 0 10px rgba(255,215,0,0.3); }
            50% { transform: scale(1.02); box-shadow: 0 0 20px rgba(255,215,0,0.5); }
        }

        @keyframes dealerBlink {
            0%, 90%, 100% { clip-path: inset(0 0 0 0); }
            95% { clip-path: inset(35% 0 55% 0); }
        }

        .living-art-mode .dealer-avatar {
            animation: dealerBreathe 4s ease-in-out infinite;
        }

        /* Particle Canvas */
        #particle-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
            opacity: 0;
            transition: opacity 1s ease;
        }
        .living-art-mode #particle-canvas { opacity: 1; }

        /* Felt Breathing */
        @keyframes feltBreathe {
            0%, 100% { background-position: center center; }
            50% { background-position: center calc(50% + 5px); }
        }
        .living-art-mode body {
            animation: feltBreathe 8s ease-in-out infinite;
        }

        /* Light Ray Sweep */
        .light-ray {
            position: fixed;
            top: 0;
            left: -100%;
            width: 200px;
            height: 100%;
            background: linear-gradient(90deg,
                transparent,
                rgba(255,215,0,0.03),
                rgba(255,255,255,0.05),
                rgba(255,215,0,0.03),
                transparent
            );
            transform: skewX(-15deg);
            pointer-events: none;
            z-index: 4;
            opacity: 0;
            transition: opacity 1s;
        }
        .living-art-mode .light-ray {
            opacity: 1;
            animation: lightSweep 20s linear infinite;
        }
        @keyframes lightSweep {
            0% { left: -200px; }
            100% { left: calc(100% + 200px); }
        }

        /* Balatro Card Enhancements */
        .card.foil {
            background: linear-gradient(135deg, #fff 0%, #e8e8e8 25%, #fff 50%, #e8e8e8 75%, #fff 100%);
            box-shadow: 0 0 15px rgba(192, 192, 192, 0.6);
        }
        .card.holographic {
            background: linear-gradient(135deg,
                hsl(0, 100%, 95%) 0%,
                hsl(60, 100%, 95%) 20%,
                hsl(120, 100%, 95%) 40%,
                hsl(180, 100%, 95%) 60%,
                hsl(240, 100%, 95%) 80%,
                hsl(300, 100%, 95%) 100%);
            animation: holoShift 3s linear infinite;
        }
        @keyframes holoShift {
            0%, 100% { filter: hue-rotate(0deg); }
            50% { filter: hue-rotate(360deg); }
        }
        .card.polychrome {
            background: linear-gradient(135deg, #fff, #f0f0ff, #fff);
            box-shadow: 0 0 20px rgba(100, 100, 255, 0.4), inset 0 0 30px rgba(255, 255, 255, 0.8);
        }
        .card.bonus { border: 3px solid #3498db; }
        .card.mult { border: 3px solid #e74c3c; }
        .card.wild { border: 3px solid #9b59b6; }
        .card.glass { opacity: 0.7; background: rgba(255,255,255,0.5); }
        .card.steel { background: linear-gradient(145deg, #bdc3c7, #95a5a6); }
        .card.stone {
            background: linear-gradient(145deg, #7f8c8d, #566573);
            color: white;
        }
        .card.gold {
            background: linear-gradient(145deg, #f1c40f, #d4ac0d);
            box-shadow: 0 0 15px rgba(241, 196, 15, 0.5);
        }

        /* Joker Cards */
        .joker-card {
            width: 80px;
            height: 112px;
            background: linear-gradient(145deg, #9b59b6, #8e44ad);
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(155, 89, 182, 0.4);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 8px;
            color: white;
            font-size: 0.75rem;
            text-align: center;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .joker-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 25px rgba(155, 89, 182, 0.6);
        }
        .joker-card .joker-icon { font-size: 1.8rem; margin-bottom: 4px; }
        .joker-card .joker-name { font-weight: bold; font-size: 0.65rem; }
        .joker-card.common { background: linear-gradient(145deg, #3498db, #2980b9); }
        .joker-card.uncommon { background: linear-gradient(145deg, #2ecc71, #27ae60); }
        .joker-card.rare { background: linear-gradient(145deg, #e74c3c, #c0392b); }
        .joker-card.legendary {
            background: linear-gradient(145deg, #f39c12, #e67e22);
            animation: legendaryGlow 2s ease-in-out infinite;
        }
        @keyframes legendaryGlow {
            0%, 100% { box-shadow: 0 0 15px rgba(243, 156, 18, 0.5); }
            50% { box-shadow: 0 0 30px rgba(243, 156, 18, 0.8); }
        }

        /* Balatro UI Elements */
        .balatro-hud {
            position: fixed;
            top: 80px;
            right: 20px;
            background: rgba(0,0,0,0.85);
            border-radius: 12px;
            padding: 15px;
            min-width: 180px;
            z-index: 50;
            border: 1px solid rgba(255,215,0,0.3);
        }
        .balatro-hud h4 {
            margin: 0 0 10px 0;
            color: var(--accent);
            font-size: 0.9rem;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            padding-bottom: 8px;
        }
        .balatro-stat {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 0.85rem;
        }
        .balatro-stat .label { color: #aaa; }
        .balatro-stat .value { color: #fff; font-weight: bold; }
        .balatro-stat .chips { color: #3498db; }
        .balatro-stat .mult { color: #e74c3c; }

        .joker-slots {
            display: flex;
            gap: 8px;
            padding: 10px;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            margin-top: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }
        .joker-slot-empty {
            width: 80px;
            height: 112px;
            border: 2px dashed rgba(255,255,255,0.2);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: rgba(255,255,255,0.3);
            font-size: 0.7rem;
        }

        .hand-score-preview {
            position: absolute;
            top: -60px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.9);
            padding: 8px 16px;
            border-radius: 8px;
            white-space: nowrap;
            font-size: 0.9rem;
            border: 1px solid var(--accent);
        }
        .hand-score-preview .chips { color: #3498db; }
        .hand-score-preview .mult { color: #e74c3c; }

        .card-roster {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0,0,0,0.9);
            border-radius: 12px;
            padding: 10px;
            max-width: 400px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 45;
            border: 1px solid rgba(255,215,0,0.2);
            display: none;
        }
        .card-roster.visible { display: block; }
        .card-roster h5 { margin: 0 0 8px 0; color: var(--accent); font-size: 0.8rem; }
        .roster-grid {
            display: grid;
            grid-template-columns: repeat(13, 1fr);
            gap: 2px;
            font-size: 0.6rem;
        }
        .roster-cell {
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
            cursor: pointer;
        }
        .roster-cell.in-deck { background: rgba(46, 204, 113, 0.3); }
        .roster-cell.in-hand { background: rgba(52, 152, 219, 0.5); }
        .roster-cell.discarded { background: rgba(231, 76, 60, 0.3); opacity: 0.5; }
        .roster-cell.destroyed { background: rgba(0,0,0,0.5); text-decoration: line-through; opacity: 0.3; }
        .roster-cell.red { color: #ff6b6b; }
        .roster-cell.black { color: #fff; }

        /* Card Selection for Balatro */
        .card.selected {
            transform: translateY(-20px) !important;
            box-shadow: 0 10px 30px rgba(255, 215, 0, 0.5);
            border: 2px solid var(--accent);
        }

        /* Living Art Mode Toggle Button */
        .living-art-toggle {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.6);
            border: 1px solid var(--accent);
            color: var(--accent);
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.85rem;
            z-index: 200;
            transition: all 0.3s;
        }
        .living-art-toggle:hover {
            background: rgba(255,215,0,0.2);
        }
        .living-art-toggle.active {
            background: var(--accent);
            color: #000;
        }

        /* Idle Card Float Animation */
        @keyframes cardFloat {
            0%, 100% { transform: translateY(0) rotate(0deg); }
            25% { transform: translateY(-5px) rotate(0.5deg); }
            75% { transform: translateY(-3px) rotate(-0.5deg); }
        }
        .living-art-mode .card.idle-float {
            animation: cardFloat 6s ease-in-out infinite;
        }

        /* Phantom Cat */
        .phantom-cat {
            position: fixed;
            bottom: 100px;
            left: -100px;
            width: 60px;
            height: 40px;
            z-index: 3;
            opacity: 0.7;
            pointer-events: none;
            font-size: 40px;
            transition: none;
        }
        @keyframes catWalk {
            0% { left: -100px; transform: scaleX(1); }
            45% { left: calc(50% - 30px); transform: scaleX(1); }
            50% { left: calc(50% - 30px); transform: scaleX(1); }
            55% { left: calc(50% - 30px); transform: scaleX(-1); }
            100% { left: calc(100% + 100px); transform: scaleX(-1); }
        }
        .phantom-cat.walking {
            animation: catWalk 12s linear forwards;
        }

        /* Dealer Meta Commentary */
        .dealer-thought {
            position: fixed;
            top: 90px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            padding: 10px 20px;
            border-radius: 10px;
            font-style: italic;
            color: #aaa;
            font-size: 0.9rem;
            opacity: 0;
            transition: opacity 0.5s;
            z-index: 50;
            max-width: 400px;
            text-align: center;
        }
        .dealer-thought.visible { opacity: 1; }

        .advice-box {
            position: absolute;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            width: 200px;
            background: rgba(0,0,0,0.6);
            padding: 10px;
            border-radius: 8px;
            border-left: 3px solid var(--accent);
            font-size: 0.9rem;
            display: none;
        }
        .advice-box.visible { display: block; }

        /* Responsive */
        @media (max-width: 768px) {
            :root {
                --card-width: 70px;
                --card-height: 100px;
            }
            
            .game-grid {
                grid-template-columns: 1fr;
            }

            .btn {
                padding: 10px 20px;
                font-size: 0.9rem;
                min-width: auto;
            }
        }
    </style>
</head>
<body>

    <header>
        <div class="dealer-persona">
            <div class="dealer-avatar"></div>
            <div class="dealer-info">
                <h2>The Dealer</h2>
                <p id="dealer-text">"Select a game to begin."</p>
            </div>
        </div>
        <button class="btn btn-secondary" onclick="showMenu()">Menu</button>
    </header>

    <div id="game-menu">
        <h1 class="menu-title">Virtual Dealer Suite</h1>
        <div class="game-grid" style="grid-template-columns: repeat(2, 1fr);">
            <div class="game-card" onclick="startGame('war')">
                <h3>War</h3>
                <p>The classic game of chance. High card wins.</p>
            </div>
            <div class="game-card" onclick="startGame('blackjack')">
                <h3>Blackjack</h3>
                <p>Get closer to 21 than the dealer without going over.</p>
            </div>
            <div class="game-card" onclick="startGame('poker')">
                <h3>Texas Hold'em</h3>
                <p>Heads-up poker. Best 5-card hand wins.</p>
            </div>
            <div class="game-card" onclick="startGame('balatro')" style="background: linear-gradient(145deg, #4a2c5f, #2d1b3d); border: 2px solid #9b59b6;">
                <h3 style="color: #e74c3c;">Balatro</h3>
                <p>Roguelike poker! Build hands, collect jokers, beat the blinds.</p>
            </div>
        </div>

        <div style="margin-top: 30px; width: 90%; max-width: 900px;">
            <button class="btn btn-primary" onclick="startTutorMode()" style="width: 100%; padding: 20px; font-size: 1.2rem; background: linear-gradient(45deg, #4a90e2, #003973); border: none;">
                üéì Physical Deck Tutor Mode
                <div style="font-size: 0.8rem; opacity: 0.8; margin-top: 5px; text-transform: none; font-weight: normal;">
                    Use your own real cards! I'll teach you how to play and give advice.
                </div>
            </button>
        </div>

        <div style="margin-top: 40px; padding-top: 20px; border-top: 1px solid #333; text-align: center;">
            <h3 style="margin-bottom: 15px; color: #888;">Data Management</h3>
            <div style="display: flex; gap: 10px; justify-content: center;">
                <button class="action-btn" onclick="DataManager.save()" style="width: auto; padding: 10px 20px;">Export Save</button>
                <button class="action-btn" onclick="document.getElementById('file-input').click()" style="width: auto; padding: 10px 20px;">Import Save</button>
                <input type="file" id="file-input" style="display: none" onchange="DataManager.load(this)">
            </div>
            <p style="margin-top: 10px; font-size: 12px; color: #666;">Progress is automatically saved to your browser.</p>
        </div>
    </div>

    <div id="game-area">
        <div class="hand-area dealer-hand" id="dealer-hand">
            <!-- Dealer cards go here -->
        </div>

        <div class="table-center" id="table-center">
            <div id="message-overlay">
                <h2 id="overlay-text">Player Wins!</h2>
            </div>
            <div id="community-cards" class="hand-area" style="display:none;">
                <!-- Community cards for Poker -->
            </div>
        </div>

        <div class="hand-area player-hand" id="player-hand">
            <!-- Player cards go here -->
        </div>

        <div class="chip-stack" id="chip-display" style="display:none;">
            Chips: <span class="chip-count" id="chips">1000</span>
        </div>
    </div>

    <div id="controls">
        <!-- Dynamic controls -->
    </div>

    <!-- Tutor Interface -->
    <div id="tutor-overlay" style="display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); z-index: 200; flex-direction: column; padding: 20px;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h2 style="color: var(--accent); margin: 0;">Physical Deck Tutor</h2>
            <button class="btn btn-secondary" onclick="closeTutor()">Exit Tutor</button>
        </div>
        
        <div id="tutor-menu" style="flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 20px;">
            <h3>Select a game to learn with your cards:</h3>
            <div class="game-grid" style="grid-template-columns: repeat(3, 1fr);">
                <div class="game-card" onclick="startTutorGame('war')"><h3>War</h3></div>
                <div class="game-card" onclick="startTutorGame('blackjack')"><h3>Blackjack</h3></div>
                <div class="game-card" onclick="startTutorGame('poker')"><h3>Poker</h3></div>
            </div>
        </div>

        <div id="tutor-game" style="display: none; flex: 1; flex-direction: column;">
            <div id="tutor-instructions" style="text-align: center; margin-bottom: 20px; font-size: 1.2rem; color: #ddd;"></div>
            
            <div style="flex: 1; display: flex; gap: 20px;">
                <!-- Card Selector -->
                <div style="width: 300px; background: rgba(255,255,255,0.05); padding: 15px; border-radius: 10px; overflow-y: auto;">
                    <h4 style="margin-top: 0;">Select Card</h4>
                    <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 5px; margin-bottom: 15px;">
                        <button class="btn-suit" onclick="selectSuit('‚ô†')" style="color: white">‚ô†</button>
                        <button class="btn-suit" onclick="selectSuit('‚ô•')" style="color: red">‚ô•</button>
                        <button class="btn-suit" onclick="selectSuit('‚ô£')" style="color: white">‚ô£</button>
                        <button class="btn-suit" onclick="selectSuit('‚ô¶')" style="color: red">‚ô¶</button>
                    </div>
                    <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 5px;">
                        <!-- Ranks generated by JS -->
                        <div id="rank-buttons" style="display: contents;"></div>
                    </div>
                </div>

                <!-- Game State Display -->
                <div style="flex: 1; background: rgba(255,255,255,0.05); padding: 15px; border-radius: 10px; display: flex; flex-direction: column;">
                    <div id="tutor-table" style="flex: 1; display: flex; flex-direction: column; gap: 20px;">
                        <!-- Dynamic table content -->
                    </div>
                    <div id="tutor-advice" style="background: rgba(0,0,0,0.5); padding: 15px; border-radius: 5px; border-left: 4px solid var(--accent); margin-top: 20px;">
                        Waiting for input...
                    </div>
                </div>
            </div>
            
            <div style="margin-top: 20px; display: flex; justify-content: center; gap: 10px;">
                <button class="btn btn-secondary" onclick="resetTutorRound()">Reset Round</button>
                <button class="btn btn-primary" id="tutor-action-btn" onclick="evaluateTutor()">Get Advice</button>
            </div>
        </div>
    </div>

    <style>
        .btn-suit {
            background: #333; border: 1px solid #555; font-size: 1.5rem; padding: 10px; cursor: pointer; border-radius: 5px;
        }
        .btn-suit.selected { background: #555; border-color: var(--accent); }
        .btn-rank {
            background: #333; border: 1px solid #555; padding: 10px; cursor: pointer; border-radius: 5px; color: white;
        }
        .btn-rank.selected { background: var(--accent); color: black; }
        
        .tutor-slot {
            border: 2px dashed #555;
            min-height: 100px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
        }
        .tutor-slot:hover { border-color: var(--accent); background: rgba(255,255,255,0.05); }
        .tutor-slot.active { border-color: var(--accent); background: rgba(255,215,0,0.1); }
    </style>

    <script>
        // --- Tutor Mode Logic ---
        let TUTOR = {
            game: null,
            selectedSuit: null,
            selectedRank: null,
            activeSlot: null,
            slots: {}
        };

        function startTutorMode() {
            document.getElementById('tutor-overlay').style.display = 'flex';
            document.getElementById('tutor-menu').style.display = 'flex';
            document.getElementById('tutor-game').style.display = 'none';
            
            // Generate rank buttons
            const rankContainer = document.getElementById('rank-buttons');
            rankContainer.innerHTML = '';
            RANKS.forEach(r => {
                const btn = document.createElement('button');
                btn.className = 'btn-rank';
                btn.textContent = r;
                btn.onclick = () => selectRank(r, btn);
                rankContainer.appendChild(btn);
            });
        }

        function closeTutor() {
            document.getElementById('tutor-overlay').style.display = 'none';
        }

        function startTutorGame(game) {
            TUTOR.game = game;
            document.getElementById('tutor-menu').style.display = 'none';
            document.getElementById('tutor-game').style.display = 'flex';
            resetTutorRound();
        }

        function selectSuit(s) {
            TUTOR.selectedSuit = s;
            document.querySelectorAll('.btn-suit').forEach(b => b.classList.remove('selected'));
            event.target.classList.add('selected');
            checkCardSelection();
        }

        function selectRank(r, btn) {
            TUTOR.selectedRank = r;
            document.querySelectorAll('.btn-rank').forEach(b => b.classList.remove('selected'));
            btn.classList.add('selected');
            checkCardSelection();
        }

        function checkCardSelection() {
            if (TUTOR.selectedSuit && TUTOR.selectedRank && TUTOR.activeSlot) {
                // Create card and place in slot
                const card = new Card(TUTOR.selectedSuit, TUTOR.selectedRank);
                const slotId = TUTOR.activeSlot;
                
                // Store card data
                if (!TUTOR.slots[slotId]) TUTOR.slots[slotId] = [];
                
                // For single card slots, replace. For multi, push.
                const isMulti = slotId.includes('multi');
                if (isMulti) {
                    TUTOR.slots[slotId].push(card);
                } else {
                    TUTOR.slots[slotId] = [card];
                }

                renderTutorSlots();
                
                // Reset selection
                TUTOR.selectedSuit = null;
                TUTOR.selectedRank = null;
                document.querySelectorAll('.btn-suit').forEach(b => b.classList.remove('selected'));
                document.querySelectorAll('.btn-rank').forEach(b => b.classList.remove('selected'));
                
                // Auto-evaluate if enough cards
                evaluateTutor();
            }
        }

        function activateSlot(id) {
            TUTOR.activeSlot = id;
            document.querySelectorAll('.tutor-slot').forEach(s => s.classList.remove('active'));
            document.getElementById(id).classList.add('active');
            document.getElementById('tutor-advice').textContent = `Select a Suit and Rank for ${id.replace('-', ' ')}...`;
        }

        function renderTutorSlots() {
            // Re-render the visual state of slots based on TUTOR.slots
            for (let id in TUTOR.slots) {
                const container = document.getElementById(id);
                if (!container) continue;
                
                container.innerHTML = '';
                const cards = TUTOR.slots[id];
                
                if (cards.length === 0) {
                    container.textContent = `Tap to add ${id.replace('-', ' ')}`;
                } else {
                    cards.forEach(c => {
                        const el = c.render();
                        el.style.transform = 'scale(0.8)';
                        container.appendChild(el);
                    });
                }
            }
        }

        function resetTutorRound() {
            TUTOR.slots = {};
            TUTOR.selectedSuit = null;
            TUTOR.selectedRank = null;
            
            const table = document.getElementById('tutor-table');
            table.innerHTML = '';
            
            if (TUTOR.game === 'war') {
                document.getElementById('tutor-instructions').textContent = "War Tutor: Place both cards to see who wins.";
                table.innerHTML = `
                    <div style="display: flex; gap: 20px; justify-content: center;">
                        <div style="text-align: center;">
                            <h4>Your Card</h4>
                            <div id="player-card" class="tutor-slot" onclick="activateSlot('player-card')">Tap to add</div>
                        </div>
                        <div style="text-align: center;">
                            <h4>Dealer Card</h4>
                            <div id="dealer-card" class="tutor-slot" onclick="activateSlot('dealer-card')">Tap to add</div>
                        </div>
                    </div>
                `;
            } else if (TUTOR.game === 'blackjack') {
                document.getElementById('tutor-instructions').textContent = "Blackjack Tutor: Enter your hand and dealer's up card.";
                table.innerHTML = `
                    <div style="text-align: center;">
                        <h4>Dealer Up Card</h4>
                        <div id="dealer-up" class="tutor-slot" onclick="activateSlot('dealer-up')" style="width: 120px; margin: 0 auto;">Tap to add</div>
                    </div>
                    <div style="text-align: center; margin-top: 20px;">
                        <h4>Your Hand</h4>
                        <div id="player-hand-multi" class="tutor-slot" onclick="activateSlot('player-hand-multi')" style="min-height: 150px;">Tap to add cards</div>
                    </div>
                `;
            } else if (TUTOR.game === 'poker') {
                document.getElementById('tutor-instructions').textContent = "Poker Tutor: Enter your hole cards and community cards.";
                table.innerHTML = `
                    <div style="text-align: center;">
                        <h4>Community Cards</h4>
                        <div id="community-multi" class="tutor-slot" onclick="activateSlot('community-multi')" style="min-height: 120px;">Tap to add cards</div>
                    </div>
                    <div style="text-align: center; margin-top: 20px;">
                        <h4>Your Hole Cards</h4>
                        <div id="hole-cards-multi" class="tutor-slot" onclick="activateSlot('hole-cards-multi')" style="min-height: 150px;">Tap to add cards</div>
                    </div>
                `;
            }
            
            document.getElementById('tutor-advice').textContent = "Select a slot to begin inputting cards.";
        }

        function evaluateTutor() {
            const advice = document.getElementById('tutor-advice');
            
            if (TUTOR.game === 'war') {
                const p = TUTOR.slots['player-card']?.[0];
                const d = TUTOR.slots['dealer-card']?.[0];
                
                if (p && d) {
                    if (p.pokerValue > d.pokerValue) advice.innerHTML = "<span style='color:#4f4'>You Win!</span> Your card is higher.";
                    else if (d.pokerValue > p.pokerValue) advice.innerHTML = "<span style='color:#f44'>Dealer Wins.</span> Their card is higher.";
                    else advice.innerHTML = "<span style='color:#ff4'>It's a Tie!</span> Go to War!";
                }
            } else if (TUTOR.game === 'blackjack') {
                const pHand = TUTOR.slots['player-hand-multi'];
                const dCard = TUTOR.slots['dealer-up']?.[0];
                
                if (pHand && pHand.length >= 2 && dCard) {
                    const score = BlackjackGame.getScore(pHand);
                    const dVal = dCard.value;
                    
                    let msg = `Your score: ${score}. Dealer shows: ${dVal}.<br>`;
                    
                    if (score > 21) msg += "<strong>BUST!</strong> You went over 21.";
                    else if (score === 21) msg += "<strong>BLACKJACK!</strong> Stand and hope for a payout.";
                    else {
                        // Basic Strategy Simplified
                        if (score >= 17) msg += "<strong>STAND.</strong> You have a strong hand.";
                        else if (score <= 11) msg += "<strong>HIT.</strong> Always hit on 11 or less.";
                        else if (score >= 12 && score <= 16) {
                            if (dVal >= 7) msg += "<strong>HIT.</strong> Dealer has a strong up-card.";
                            else msg += "<strong>STAND.</strong> Dealer has a weak up-card, let them bust.";
                        }
                    }
                    advice.innerHTML = msg;
                }
            } else if (TUTOR.game === 'poker') {
                const hole = TUTOR.slots['hole-cards-multi'];
                const comm = TUTOR.slots['community-multi'] || [];
                
                if (hole && hole.length === 2) {
                    const score = PokerGame.evaluate(hole, comm);
                    let msg = "<strong>Hand Analysis:</strong><br>";
                    
                    // Simple pair check for advice
                    const all = [...hole, ...comm];
                    const ranks = all.map(c => c.rank);
                    const hasPair = ranks.some((r, i) => ranks.indexOf(r) !== i);
                    
                    if (hasPair) msg += "You have at least a Pair. Good start.";
                    else if (hole[0].pokerValue > 10 || hole[1].pokerValue > 10) msg += "You have high cards. Playable.";
                    else msg += "Low cards and no pair. Proceed with caution.";
                    
                    if (comm.length === 0) msg += "<br><em>Pre-flop advice: Raise if you have pairs or high cards.</em>";
                    else if (comm.length === 3) msg += "<br><em>Flop advice: Bet if you connected with the board.</em>";
                    
                    advice.innerHTML = msg;
                }
            }
        }

        // --- Game State ---
        const STATE = {
            game: null,
            deck: [],
            playerHand: [],
            dealerHand: [],
            communityCards: [],
            chips: 1000,
            bet: 0,
            phase: 'idle', // idle, dealing, playing, resolving
            messageTimer: null,
            autoplay: false,
            autoplayDelay: 1500, // ms between autoplay actions
            scores: {
                player: 0,
                dealer: 0,
                ties: 0
            }
        };

        // --- Card Roster System ---
        // Tracks every card's location and state across all games
        const CardRoster = {
            cards: new Map(), // id -> Card object
            locations: {
                deck: [],
                playerHand: [],
                dealerHand: [],
                community: [],
                discarded: [],
                destroyed: [],
                played: []
            },

            init: () => {
                CardRoster.cards.clear();
                Object.keys(CardRoster.locations).forEach(k => CardRoster.locations[k] = []);
            },

            register: (card) => {
                CardRoster.cards.set(card.id, card);
                CardRoster.locations.deck.push(card.id);
                card.location = 'deck';
            },

            move: (cardId, from, to) => {
                const card = CardRoster.cards.get(cardId);
                if (!card) return;

                const fromArr = CardRoster.locations[from];
                const idx = fromArr.indexOf(cardId);
                if (idx > -1) fromArr.splice(idx, 1);

                CardRoster.locations[to].push(cardId);
                card.location = to;
            },

            getByLocation: (location) => {
                return CardRoster.locations[location].map(id => CardRoster.cards.get(id)).filter(Boolean);
            },

            getCard: (id) => CardRoster.cards.get(id),

            enhance: (cardId, enhancement) => {
                const card = CardRoster.cards.get(cardId);
                if (card) card.enhancement = enhancement;
            },

            destroy: (cardId) => {
                const card = CardRoster.cards.get(cardId);
                if (card) {
                    CardRoster.move(cardId, card.location, 'destroyed');
                }
            },

            renderUI: () => {
                let panel = document.getElementById('card-roster-panel');
                if (!panel) {
                    panel = document.createElement('div');
                    panel.id = 'card-roster-panel';
                    panel.className = 'card-roster';
                    panel.innerHTML = '<h5>Card Roster <button onclick="CardRoster.hide()" style="float:right;background:none;border:none;color:#fff;cursor:pointer;">√ó</button></h5><div class="roster-content"></div>';
                    document.body.appendChild(panel);
                }

                const content = panel.querySelector('.roster-content');
                let html = '';

                SUITS.forEach(suit => {
                    const isRed = suit === '‚ô•' || suit === '‚ô¶';
                    html += `<div style="margin-bottom:8px;"><strong style="color:${isRed ? '#ff6b6b' : '#fff'}">${suit}</strong><div class="roster-grid">`;
                    RANKS.forEach(rank => {
                        const id = `${suit}${rank}`;
                        const card = CardRoster.cards.get(id);
                        let cls = 'roster-cell ' + (isRed ? 'red' : 'black');
                        if (card) {
                            cls += ` ${card.location === 'deck' ? 'in-deck' : ''}`;
                            cls += ` ${card.location === 'playerHand' ? 'in-hand' : ''}`;
                            cls += ` ${card.location === 'discarded' ? 'discarded' : ''}`;
                            cls += ` ${card.location === 'destroyed' ? 'destroyed' : ''}`;
                        }
                        html += `<div class="${cls}" title="${rank}${suit} - ${card?.location || 'unknown'}">${rank}</div>`;
                    });
                    html += '</div></div>';
                });

                content.innerHTML = html;
            },

            show: () => {
                CardRoster.renderUI();
                document.getElementById('card-roster-panel')?.classList.add('visible');
            },

            hide: () => {
                document.getElementById('card-roster-panel')?.classList.remove('visible');
            },

            toggle: () => {
                const panel = document.getElementById('card-roster-panel');
                if (panel?.classList.contains('visible')) CardRoster.hide();
                else CardRoster.show();
            }
        };

        // --- Joker System for Balatro ---
        class Joker {
            constructor(config) {
                this.id = config.id;
                this.name = config.name;
                this.description = config.description;
                this.rarity = config.rarity || 'common'; // common, uncommon, rare, legendary
                this.effect = config.effect; // function(hand, score) => modifiedScore
                this.icon = config.icon || 'üÉè';
                this.cost = config.cost || 4;
                this.sellValue = Math.floor(this.cost / 2);
            }

            render() {
                const el = document.createElement('div');
                el.className = `joker-card ${this.rarity}`;
                el.innerHTML = `
                    <div class="joker-icon">${this.icon}</div>
                    <div class="joker-name">${this.name}</div>
                `;
                el.title = this.description;
                return el;
            }
        }

        // Joker Library
        const JOKER_LIBRARY = [
            new Joker({ id: 'joker', name: 'Joker', description: '+4 Mult', rarity: 'common', icon: 'üÉè',
                effect: (hand, score) => ({ chips: score.chips, mult: score.mult + 4 }) }),
            new Joker({ id: 'greedy', name: 'Greedy Joker', description: '+3 Mult for each ‚ô¶ played', rarity: 'common', icon: 'üíé',
                effect: (hand, score) => ({ chips: score.chips, mult: score.mult + hand.filter(c => c.suit === '‚ô¶').length * 3 }) }),
            new Joker({ id: 'lusty', name: 'Lusty Joker', description: '+3 Mult for each ‚ô• played', rarity: 'common', icon: '‚ù§Ô∏è',
                effect: (hand, score) => ({ chips: score.chips, mult: score.mult + hand.filter(c => c.suit === '‚ô•').length * 3 }) }),
            new Joker({ id: 'wrathful', name: 'Wrathful Joker', description: '+3 Mult for each ‚ô† played', rarity: 'common', icon: '‚öîÔ∏è',
                effect: (hand, score) => ({ chips: score.chips, mult: score.mult + hand.filter(c => c.suit === '‚ô†').length * 3 }) }),
            new Joker({ id: 'glutton', name: 'Gluttonous Joker', description: '+3 Mult for each ‚ô£ played', rarity: 'common', icon: 'üçÄ',
                effect: (hand, score) => ({ chips: score.chips, mult: score.mult + hand.filter(c => c.suit === '‚ô£').length * 3 }) }),
            new Joker({ id: 'banner', name: 'Banner', description: '+30 Chips for each discard remaining', rarity: 'common', icon: 'üö©',
                effect: (hand, score, state) => ({ chips: score.chips + (state.discardsLeft * 30), mult: score.mult }) }),
            new Joker({ id: 'mystic', name: 'Mystic Summit', description: '+15 Mult when 0 discards remain', rarity: 'common', icon: 'üèîÔ∏è',
                effect: (hand, score, state) => ({ chips: score.chips, mult: score.mult + (state.discardsLeft === 0 ? 15 : 0) }) }),
            new Joker({ id: 'fibonacci', name: 'Fibonacci', description: '+8 Mult for each 2,3,5,8,A played', rarity: 'uncommon', icon: 'üêö',
                effect: (hand, score) => {
                    const fibRanks = ['2','3','5','8','A'];
                    const count = hand.filter(c => fibRanks.includes(c.rank)).length;
                    return { chips: score.chips, mult: score.mult + count * 8 };
                }}),
            new Joker({ id: 'scholar', name: 'Scholar', description: '+20 Chips, +4 Mult for each Ace played', rarity: 'uncommon', icon: 'üìö',
                effect: (hand, score) => {
                    const aces = hand.filter(c => c.rank === 'A').length;
                    return { chips: score.chips + aces * 20, mult: score.mult + aces * 4 };
                }}),
            new Joker({ id: 'blueprint', name: 'Blueprint', description: 'Copies ability of Joker to the right', rarity: 'rare', icon: 'üìã',
                effect: (hand, score, state, jokers, idx) => {
                    if (idx < jokers.length - 1) {
                        return jokers[idx + 1].effect(hand, score, state, jokers, idx + 1);
                    }
                    return score;
                }}),
            new Joker({ id: 'dna', name: 'DNA', description: 'If first hand has only 1 card, copy it to hand', rarity: 'rare', icon: 'üß¨',
                effect: (hand, score) => score }),
            new Joker({ id: 'cavendish', name: 'Cavendish', description: 'x3 Mult. 1/1000 chance to be destroyed', rarity: 'legendary', icon: 'üçå',
                effect: (hand, score) => ({ chips: score.chips, mult: score.mult * 3 }), cost: 8 }),
        ];

        // Balatro Hand Types with base values
        const BALATRO_HANDS = {
            'High Card':      { chips: 5, mult: 1, level: 1 },
            'Pair':           { chips: 10, mult: 2, level: 1 },
            'Two Pair':       { chips: 20, mult: 2, level: 1 },
            'Three of a Kind':{ chips: 30, mult: 3, level: 1 },
            'Straight':       { chips: 30, mult: 4, level: 1 },
            'Flush':          { chips: 35, mult: 4, level: 1 },
            'Full House':     { chips: 40, mult: 4, level: 1 },
            'Four of a Kind': { chips: 60, mult: 7, level: 1 },
            'Straight Flush': { chips: 100, mult: 8, level: 1 },
            'Royal Flush':    { chips: 100, mult: 8, level: 1 },
            'Five of a Kind': { chips: 120, mult: 12, level: 1 },
            'Flush House':    { chips: 140, mult: 14, level: 1 },
            'Flush Five':     { chips: 160, mult: 16, level: 1 }
        };

        // --- Score Tracking System ---
        const ScoreTracker = {
            show: () => {
                let tracker = document.getElementById('score-tracker');
                if (!tracker) {
                    tracker = document.createElement('div');
                    tracker.id = 'score-tracker';
                    tracker.className = 'score-tracker';
                    document.body.appendChild(tracker);
                }
                tracker.style.display = 'block';
                ScoreTracker.update();
            },
            hide: () => {
                const tracker = document.getElementById('score-tracker');
                if (tracker) tracker.style.display = 'none';
            },
            update: () => {
                const tracker = document.getElementById('score-tracker');
                if (!tracker) return;
                tracker.innerHTML = `
                    <h4>Session Score</h4>
                    <div class="score-row">
                        <span class="score-player">Player:</span>
                        <span class="score-player">${STATE.scores.player}</span>
                    </div>
                    <div class="score-row">
                        <span class="score-dealer">Dealer:</span>
                        <span class="score-dealer">${STATE.scores.dealer}</span>
                    </div>
                    <div class="score-row">
                        <span class="score-tie">Ties:</span>
                        <span class="score-tie">${STATE.scores.ties}</span>
                    </div>
                `;
            },
            playerWin: () => {
                STATE.scores.player++;
                ScoreTracker.update();
                DataManager.autoSave();
            },
            dealerWin: () => {
                STATE.scores.dealer++;
                ScoreTracker.update();
                DataManager.autoSave();
            },
            tie: () => {
                STATE.scores.ties++;
                ScoreTracker.update();
                DataManager.autoSave();
            },
            reset: () => {
                STATE.scores = { player: 0, dealer: 0, ties: 0 };
                ScoreTracker.update();
                DataManager.autoSave();
            }
        };

        // --- Tutoring System ---
        const TutoringSystem = {
            explanationDuration: 3500, // How long to show each explanation
            currentTimer: null,
            currentResolve: null,
            isPaused: false,

            ensurePanel: () => {
                let panel = document.getElementById('tutor-panel');
                if (!panel) {
                    panel = document.createElement('div');
                    panel.id = 'tutor-panel';
                    panel.className = 'tutor-panel';
                    document.body.appendChild(panel);

                    // Pause on hover
                    panel.addEventListener('mouseenter', () => {
                        TutoringSystem.pause();
                    });

                    // Resume on mouse leave (if not manually closed)
                    panel.addEventListener('mouseleave', () => {
                        TutoringSystem.resume();
                    });
                }
                return panel;
            },

            show: (title, explanation, rule, duration = null) => {
                if (!STATE.autoplay) return Promise.resolve();

                // Clear any existing timer
                if (TutoringSystem.currentTimer) {
                    clearTimeout(TutoringSystem.currentTimer);
                    TutoringSystem.currentTimer = null;
                }

                const panel = TutoringSystem.ensurePanel();
                const dur = duration || TutoringSystem.explanationDuration;
                TutoringSystem.isPaused = false;
                panel.classList.remove('paused');

                panel.innerHTML = `
                    <div class="tutor-header">
                        <h3>${title}</h3>
                        <button class="tutor-close" onclick="TutoringSystem.close()">&times;</button>
                    </div>
                    <div class="tutor-explanation">${explanation}</div>
                    ${rule ? `<div class="tutor-rule">${rule}</div>` : ''}
                    <div class="tutor-progress">
                        <div class="tutor-progress-bar" style="animation-duration: ${dur}ms;"></div>
                    </div>
                `;
                panel.classList.add('visible');

                return new Promise(resolve => {
                    TutoringSystem.currentResolve = resolve;
                    TutoringSystem.currentTimer = setTimeout(() => {
                        if (!TutoringSystem.isPaused) {
                            panel.classList.remove('visible');
                            TutoringSystem.currentTimer = null;
                            TutoringSystem.currentResolve = null;
                            resolve();
                        }
                    }, dur);
                });
            },

            pause: () => {
                TutoringSystem.isPaused = true;
                const panel = document.getElementById('tutor-panel');
                if (panel) panel.classList.add('paused');
                if (TutoringSystem.currentTimer) {
                    clearTimeout(TutoringSystem.currentTimer);
                    TutoringSystem.currentTimer = null;
                }
            },

            resume: () => {
                if (!TutoringSystem.isPaused) return;
                TutoringSystem.isPaused = false;
                const panel = document.getElementById('tutor-panel');
                if (panel) panel.classList.remove('paused');
                // Auto-close after a short delay when mouse leaves
                TutoringSystem.currentTimer = setTimeout(() => {
                    TutoringSystem.close();
                }, 1000);
            },

            close: () => {
                TutoringSystem.isPaused = false;
                if (TutoringSystem.currentTimer) {
                    clearTimeout(TutoringSystem.currentTimer);
                    TutoringSystem.currentTimer = null;
                }
                const panel = document.getElementById('tutor-panel');
                if (panel) {
                    panel.classList.remove('visible');
                    panel.classList.remove('paused');
                }
                if (TutoringSystem.currentResolve) {
                    TutoringSystem.currentResolve();
                    TutoringSystem.currentResolve = null;
                }
            },

            hide: () => {
                TutoringSystem.close();
            }
        };

        // --- Living Art Mode System ---
        const LivingArtMode = {
            active: false,
            particleCanvas: null,
            particleCtx: null,
            particles: [],
            animationFrame: null,
            blinkInterval: null,
            metaInterval: null,
            chaosInterval: null,

            // Dealer meta-commentary phrases
            metaPhrases: [
                "I wonder if the cards ever get tired of being shuffled...",
                "They say luck is just probability taken personally.",
                "In another timeline, that ace was yours.",
                "The felt remembers every hand ever played here.",
                "Sometimes I deal to ghosts. They're very patient.",
                "Every shuffle is the first time those cards have been in that order.",
                "I've been here longer than the building, you know.",
                "The chips have their own gravity. They always return to the house.",
                "Do you ever wonder what I do when you're not here?",
                "Time moves differently at the table. Always has.",
                "The old dealers used to say the cards can feel fear.",
                "I've seen fortunes made and lost on the turn of a single card.",
                "The house always wins... but sometimes it lets you borrow victory.",
            ],

            init: () => {
                // Create particle canvas
                LivingArtMode.particleCanvas = document.createElement('canvas');
                LivingArtMode.particleCanvas.id = 'particle-canvas';
                document.body.appendChild(LivingArtMode.particleCanvas);

                // Create light ray
                const lightRay = document.createElement('div');
                lightRay.className = 'light-ray';
                document.body.appendChild(lightRay);

                // Create dealer thought bubble
                const thought = document.createElement('div');
                thought.className = 'dealer-thought';
                thought.id = 'dealer-thought';
                document.body.appendChild(thought);

                // Create toggle button
                const toggle = document.createElement('button');
                toggle.className = 'living-art-toggle';
                toggle.textContent = '‚ú® Living Art';
                toggle.onclick = LivingArtMode.toggle;
                document.body.appendChild(toggle);

                // Resize handler
                window.addEventListener('resize', LivingArtMode.resizeCanvas);
                LivingArtMode.resizeCanvas();
            },

            toggle: () => {
                LivingArtMode.active = !LivingArtMode.active;
                document.body.classList.toggle('living-art-mode', LivingArtMode.active);

                const btn = document.querySelector('.living-art-toggle');
                btn.classList.toggle('active', LivingArtMode.active);
                btn.textContent = LivingArtMode.active ? '‚ú® Living Art ON' : '‚ú® Living Art';

                if (LivingArtMode.active) {
                    LivingArtMode.start();
                } else {
                    LivingArtMode.stop();
                }
            },

            start: () => {
                // Initialize particles
                LivingArtMode.particles = [];
                for (let i = 0; i < 30; i++) {
                    LivingArtMode.particles.push(LivingArtMode.createParticle());
                }

                // Start animation loop
                LivingArtMode.animate();

                // Start dealer blink timer
                LivingArtMode.scheduleBlink();

                // Start meta commentary timer
                LivingArtMode.metaInterval = setInterval(() => {
                    if (Math.random() < 0.15) { // 15% chance every 30 seconds
                        LivingArtMode.showMetaThought();
                    }
                }, 30000);

                // Start chaos events timer
                LivingArtMode.chaosInterval = setInterval(() => {
                    LivingArtMode.maybeTriggerChaos();
                }, 45000);
            },

            stop: () => {
                if (LivingArtMode.animationFrame) {
                    cancelAnimationFrame(LivingArtMode.animationFrame);
                }
                if (LivingArtMode.blinkInterval) {
                    clearTimeout(LivingArtMode.blinkInterval);
                }
                if (LivingArtMode.metaInterval) {
                    clearInterval(LivingArtMode.metaInterval);
                }
                if (LivingArtMode.chaosInterval) {
                    clearInterval(LivingArtMode.chaosInterval);
                }
                LivingArtMode.particles = [];
                const thought = document.getElementById('dealer-thought');
                if (thought) thought.classList.remove('visible');
            },

            resizeCanvas: () => {
                if (LivingArtMode.particleCanvas) {
                    LivingArtMode.particleCanvas.width = window.innerWidth;
                    LivingArtMode.particleCanvas.height = window.innerHeight;
                    LivingArtMode.particleCtx = LivingArtMode.particleCanvas.getContext('2d');
                }
            },

            createParticle: () => ({
                x: Math.random() * window.innerWidth,
                y: Math.random() * window.innerHeight,
                size: Math.random() * 2 + 1,
                speedX: (Math.random() - 0.5) * 0.3,
                speedY: -Math.random() * 0.2 - 0.1,
                opacity: Math.random() * 0.5 + 0.2,
                twinkle: Math.random() * Math.PI * 2
            }),

            animate: () => {
                if (!LivingArtMode.active) return;

                const ctx = LivingArtMode.particleCtx;
                const w = LivingArtMode.particleCanvas.width;
                const h = LivingArtMode.particleCanvas.height;

                ctx.clearRect(0, 0, w, h);

                // Draw and update particles (dust motes)
                LivingArtMode.particles.forEach(p => {
                    p.x += p.speedX;
                    p.y += p.speedY;
                    p.twinkle += 0.02;

                    // Wrap around screen
                    if (p.y < -10) p.y = h + 10;
                    if (p.x < -10) p.x = w + 10;
                    if (p.x > w + 10) p.x = -10;

                    // Twinkle effect
                    const twinkleOpacity = p.opacity * (0.7 + 0.3 * Math.sin(p.twinkle));

                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 223, 150, ${twinkleOpacity})`;
                    ctx.fill();
                });

                LivingArtMode.animationFrame = requestAnimationFrame(LivingArtMode.animate);
            },

            scheduleBlink: () => {
                const nextBlink = 8000 + Math.random() * 6000; // 8-14 seconds
                LivingArtMode.blinkInterval = setTimeout(() => {
                    if (!LivingArtMode.active) return;
                    LivingArtMode.dealerBlink();
                    LivingArtMode.scheduleBlink();
                }, nextBlink);
            },

            dealerBlink: () => {
                const avatar = document.querySelector('.dealer-avatar');
                if (!avatar) return;

                // Quick blink animation
                avatar.style.transition = 'clip-path 0.1s';
                avatar.style.clipPath = 'inset(35% 0 55% 0)';
                setTimeout(() => {
                    avatar.style.clipPath = 'inset(0 0 0 0)';
                    setTimeout(() => {
                        avatar.style.transition = '';
                    }, 100);
                }, 100);
            },

            showMetaThought: () => {
                const thought = document.getElementById('dealer-thought');
                if (!thought) return;

                const phrase = LivingArtMode.metaPhrases[
                    Math.floor(Math.random() * LivingArtMode.metaPhrases.length)
                ];

                thought.textContent = `"${phrase}"`;
                thought.classList.add('visible');

                setTimeout(() => {
                    thought.classList.remove('visible');
                }, 8000);
            },

            maybeTriggerChaos: () => {
                if (!LivingArtMode.active) return;

                const roll = Math.random();

                if (roll < 0.05) { // 5% chance - Phantom Cat!
                    LivingArtMode.spawnCat();
                } else if (roll < 0.15) { // 10% chance - gravity glitch
                    LivingArtMode.gravityGlitch();
                }
            },

            spawnCat: () => {
                // Remove existing cat if any
                const existingCat = document.querySelector('.phantom-cat');
                if (existingCat) existingCat.remove();

                const cat = document.createElement('div');
                cat.className = 'phantom-cat';
                cat.textContent = 'üê±';
                document.body.appendChild(cat);

                // Trigger walk animation
                setTimeout(() => cat.classList.add('walking'), 50);

                // Remove after animation
                setTimeout(() => cat.remove(), 13000);
            },

            gravityGlitch: () => {
                // Only affect cards that are fully dealt, not currently animating
                const cards = document.querySelectorAll('.card.dealt:not(.dealing)');
                if (cards.length === 0) return;

                // Pick just one random card to float, not all of them
                const randomCard = cards[Math.floor(Math.random() * cards.length)];

                randomCard.style.transition = 'transform 1.5s ease-out';
                randomCard.style.transform = `translateY(-25px) rotate(${(Math.random()-0.5)*8}deg)`;

                setTimeout(() => {
                    randomCard.style.transition = 'transform 0.8s ease-in';
                    randomCard.style.transform = '';
                    setTimeout(() => {
                        randomCard.style.transition = '';
                    }, 800);
                }, 2000);
            }
        };

        // Initialize Living Art Mode on load
        document.addEventListener('DOMContentLoaded', () => {
            LivingArtMode.init();
        });

        // --- Tutoring System Explanations (continued) ---
        // War explanations
        TutoringSystem.explainWarBattle = (pCard, dCard) => {
                const pVal = pCard.pokerValue;
                const dVal = dCard.pokerValue;
                const pName = `${pCard.rank}${pCard.suit}`;
                const dName = `${dCard.rank}${dCard.suit}`;

                let explanation, outcome, rule;

                if (pVal > dVal) {
                    const diff = pVal - dVal;
                    explanation = `Your <span class="highlight">${pName}</span> (rank ${pVal}) beats the Dealer's <span class="highlight">${dName}</span> (rank ${dVal}).<br>` +
                        `<span class="win">You win this battle!</span> You collect both cards.`;
                    rule = `In War, face cards rank J=11, Q=12, K=13, A=14. Your card was ${diff} rank${diff > 1 ? 's' : ''} higher.`;
                } else if (dVal > pVal) {
                    const diff = dVal - pVal;
                    explanation = `Dealer's <span class="highlight">${dName}</span> (rank ${dVal}) beats your <span class="highlight">${pName}</span> (rank ${pVal}).<br>` +
                        `<span class="lose">Dealer wins this battle.</span> They collect both cards.`;
                    rule = `The Dealer's card was ${diff} rank${diff > 1 ? 's' : ''} higher. Keep playing - luck can change!`;
                } else {
                    explanation = `Both cards are <span class="highlight">${pCard.rank}s</span>! This is a <span class="tie">TIE</span>.<br>` +
                        `When cards match, we go to <span class="highlight">WAR</span>!`;
                    rule = `In War mode, each player places 3 cards face-down, then flips the 4th. Winner takes all 10 cards!`;
                }

                return TutoringSystem.show('Battle Result', explanation, rule);
            };

        TutoringSystem.explainWarOutcome = (potSize, winner) => {
                const explanation = winner === 'Player'
                    ? `<span class="win">Victory!</span> You collected <span class="highlight">${potSize} cards</span> from this battle.`
                    : `<span class="lose">Defeat.</span> The Dealer collected <span class="highlight">${potSize} cards</span>.`;
                const rule = `Current standings: You have ${WarGame.playerDeck.length} cards, Dealer has ${WarGame.dealerDeck.length} cards.`;
                return TutoringSystem.show('Cards Collected', explanation, rule, 2000);
            };

        // Blackjack explanations
        TutoringSystem.explainBlackjackAction = (action, score, dealerUp) => {
                let explanation, rule;
                const dVal = dealerUp.rank === 'A' ? 'Ace' : dealerUp.rank;

                if (action === 'hit') {
                    explanation = `With a score of <span class="highlight">${score}</span> against Dealer showing <span class="highlight">${dVal}</span>,` +
                        ` the AI chooses to <span class="win">HIT</span>.`;
                    if (score <= 11) {
                        rule = `With 11 or less, you cannot bust by taking one card. Always hit here.`;
                    } else {
                        rule = `Dealer's ${dVal} is strong (7+). With ${score}, the risk of busting is worth taking to improve your hand.`;
                    }
                } else {
                    explanation = `With a score of <span class="highlight">${score}</span> against Dealer showing <span class="highlight">${dVal}</span>,` +
                        ` the AI chooses to <span class="highlight">STAND</span>.`;
                    if (score >= 17) {
                        rule = `17+ is a strong hand. Standing avoids bust risk and lets the Dealer potentially bust.`;
                    } else {
                        rule = `Dealer shows weakness (${dVal}). Let them draw - they might bust trying to beat your ${score}.`;
                    }
                }
                return TutoringSystem.show('Strategy Decision', explanation, rule, 2500);
            };

        TutoringSystem.explainBlackjackResult = (pScore, dScore, result) => {
                let explanation, rule;

                if (result === 'bust') {
                    explanation = `Your score hit <span class="lose">${pScore}</span> - that's over 21!<br>` +
                        `<span class="lose">BUST!</span> The Dealer wins automatically.`;
                    rule = `Going over 21 is an instant loss. Consider standing earlier against weak Dealer cards.`;
                } else if (result === 'win') {
                    if (dScore > 21) {
                        explanation = `Dealer busted with <span class="lose">${dScore}</span>!<br>` +
                            `Your <span class="highlight">${pScore}</span> wins. <span class="win">You win!</span>`;
                        rule = `Dealers must hit until 17+. When they show weak cards (2-6), they often bust.`;
                    } else {
                        explanation = `Your <span class="highlight">${pScore}</span> beats Dealer's <span class="highlight">${dScore}</span>.<br>` +
                            `<span class="win">You win!</span>`;
                        rule = `Higher score under 21 wins. Your hand was ${pScore - dScore} points better.`;
                    }
                } else if (result === 'push') {
                    explanation = `Both hands total <span class="highlight">${pScore}</span>!<br>` +
                        `<span class="tie">PUSH</span> - your bet is returned.`;
                    rule = `Ties return your wager. Neither wins nor loses - try again!`;
                } else {
                    explanation = `Dealer's <span class="highlight">${dScore}</span> beats your <span class="highlight">${pScore}</span>.<br>` +
                        `<span class="lose">Dealer wins.</span>`;
                    rule = `The Dealer's hand was ${dScore - pScore} points better. Review basic strategy to improve!`;
                }
                return TutoringSystem.show('Hand Result', explanation, rule);
            };

        // Poker explanations
        TutoringSystem.explainPokerDecision = (action, reason, odds) => {
                let explanation = `The AI decides to <span class="highlight">${action.toUpperCase()}</span>.<br>`;
                explanation += reason;
                const rule = `Win probability: ${odds}%. ${parseFloat(odds) > 50 ? 'Favorable odds support aggression.' : 'Marginal odds suggest caution.'}`;
                return TutoringSystem.show('Poker Strategy', explanation, rule, 2500);
            };

        TutoringSystem.explainPokerResult = (pScore, dScore, pHand, dHand, result) => {
                const getHandName = (score) => {
                    if (score > 70000) return 'Four of a Kind';
                    if (score > 60000) return 'Full House';
                    if (score > 50000) return 'Flush';
                    if (score > 40000) return 'Straight';
                    if (score > 30000) return 'Three of a Kind';
                    if (score > 20000) return 'Two Pair';
                    if (score > 10000) return 'Pair';
                    return 'High Card';
                };

                const pHandName = getHandName(pScore);
                const dHandName = getHandName(dScore);
                let explanation, rule;

                if (result === 'win') {
                    explanation = `Your <span class="win">${pHandName}</span> beats Dealer's <span class="highlight">${dHandName}</span>!<br>` +
                        `<span class="win">You win the pot!</span>`;
                    rule = `Hand rankings: High Card < Pair < Two Pair < Three Kind < Straight < Flush < Full House < Four Kind`;
                } else if (result === 'tie') {
                    explanation = `Both have <span class="tie">${pHandName}</span>!<br>` +
                        `<span class="tie">Split pot.</span>`;
                    rule = `When hand types match, kickers (highest remaining cards) determine the winner.`;
                } else {
                    explanation = `Dealer's <span class="lose">${dHandName}</span> beats your <span class="highlight">${pHandName}</span>.<br>` +
                        `<span class="lose">Dealer takes the pot.</span>`;
                    rule = `${dHandName} outranks ${pHandName}. Position and reading opponents matter too!`;
                }
                return TutoringSystem.show('Showdown', explanation, rule);
            };

        // --- Autoplay System ---
        const Autoplay = {
            toggle: () => {
                STATE.autoplay = !STATE.autoplay;
                const status = STATE.autoplay ? "ON - Watching the AI play!" : "OFF";
                showOverlay(`Autoplay: ${status}`, 1500);

                // Update the autoplay indicator
                Autoplay.updateIndicator();

                // Show/hide score tracker with autoplay
                if (STATE.autoplay) {
                    ScoreTracker.show();
                } else {
                    ScoreTracker.hide();
                }

                // Refresh current game controls to update button state
                Autoplay.refreshControls();

                // If just turned on, trigger next action
                if (STATE.autoplay) {
                    Autoplay.scheduleNext();
                }
            },

            updateIndicator: () => {
                let indicator = document.getElementById('autoplay-indicator');
                if (!indicator) {
                    indicator = document.createElement('div');
                    indicator.id = 'autoplay-indicator';
                    indicator.style.cssText = 'position: fixed; top: 80px; right: 20px; background: linear-gradient(45deg, #e74c3c, #c0392b); color: white; padding: 8px 16px; border-radius: 20px; font-weight: bold; z-index: 1000; display: none; animation: autoplayPulse 1.5s ease-in-out infinite;';
                    document.body.appendChild(indicator);
                }
                indicator.textContent = 'AUTOPLAY';
                indicator.style.display = STATE.autoplay ? 'block' : 'none';
                // Move indicator to left side for Balatro (HUD is on right)
                if (STATE.game === 'balatro') {
                    indicator.style.right = 'auto';
                    indicator.style.left = '20px';
                } else {
                    indicator.style.left = 'auto';
                    indicator.style.right = '20px';
                }
            },

            refreshControls: () => {
                // Trigger control refresh for current game phase
                if (STATE.game === 'war') {
                    if (WarGame.playerDeck.length > 0 && WarGame.dealerDeck.length > 0) {
                        WarGame.nextRound();
                    }
                } else if (STATE.game === 'blackjack') {
                    if (STATE.playerHand.length >= 2) {
                        BlackjackGame.playerTurn();
                    } else {
                        BlackjackGame.bettingPhase();
                    }
                } else if (STATE.game === 'poker') {
                    // Poker has multiple phases - just update current controls
                    // The controls will update on next action
                } else if (STATE.game === 'balatro') {
                    BalatroGame.setControls();
                }
            },

            scheduleNext: () => {
                if (!STATE.autoplay) return;
                setTimeout(() => Autoplay.executeNext(), STATE.autoplayDelay);
            },

            executeNext: () => {
                if (!STATE.autoplay) return;

                if (STATE.game === 'war') {
                    Autoplay.playWar();
                } else if (STATE.game === 'blackjack') {
                    Autoplay.playBlackjack();
                } else if (STATE.game === 'poker') {
                    Autoplay.playPoker();
                } else if (STATE.game === 'balatro') {
                    Autoplay.playBalatro();
                }
            },

            playWar: () => {
                // War has simple decisions: Battle or Go to War
                if (WarGame.playerDeck.length === 0 || WarGame.dealerDeck.length === 0) {
                    return; // Game over
                }

                const controls = document.getElementById('controls');
                const battleBtn = controls.querySelector('.btn-primary');

                if (battleBtn && battleBtn.textContent === 'Battle') {
                    battleBtn.click();
                    // War game now handles its own timing with tutoring - no need to schedule here
                }
            },

            playBlackjack: async () => {
                // Check if player is bankrupt
                if (STATE.chips <= 0) {
                    STATE.autoplay = false;
                    Autoplay.updateIndicator();
                    showOverlay("BANKRUPT!", 3000);
                    return;
                }

                const controls = document.getElementById('controls');
                const buttons = controls.querySelectorAll('.btn');

                // Check what phase we're in
                const hitBtn = Array.from(buttons).find(b => b.textContent === 'Hit');
                const standBtn = Array.from(buttons).find(b => b.textContent === 'Stand');
                const betBtn = Array.from(buttons).find(b => b.textContent.includes('Bet'));

                if (hitBtn && standBtn) {
                    // Playing phase - use basic strategy with tutoring
                    const action = Autoplay.getBlackjackAction();
                    const score = BlackjackGame.getScore(STATE.playerHand);
                    const dealerUp = STATE.dealerHand[0];

                    // Show tutoring explanation
                    await TutoringSystem.explainBlackjackAction(action, score, dealerUp);

                    if (action === 'hit') {
                        hitBtn.click();
                    } else {
                        standBtn.click();
                    }
                    // Blackjack game handles its own continuation
                    setTimeout(() => Autoplay.scheduleNext(), 1500);
                } else if (betBtn) {
                    // Betting phase - bet 10
                    betBtn.click();
                    setTimeout(() => Autoplay.scheduleNext(), 1500);
                }
            },

            getBlackjackAction: () => {
                const score = BlackjackGame.getScore(STATE.playerHand);
                const dealerUpCard = STATE.dealerHand[0];
                const dVal = dealerUpCard.rank === 'A' ? 11 : (['K','Q','J'].includes(dealerUpCard.rank) ? 10 : parseInt(dealerUpCard.rank));

                // Basic Strategy
                if (score >= 17) return 'stand';
                if (score <= 11) return 'hit';
                if (score >= 12 && score <= 16) {
                    if (dVal >= 7) return 'hit';
                    return 'stand';
                }
                return 'hit';
            },

            playPoker: async () => {
                // Check if player is bankrupt
                if (STATE.chips <= 0) {
                    STATE.autoplay = false;
                    Autoplay.updateIndicator();
                    showOverlay("BANKRUPT!", 3000);
                    return;
                }

                const controls = document.getElementById('controls');
                const buttons = controls.querySelectorAll('.btn');

                // Check what phase we're in
                const anteBtn = Array.from(buttons).find(b => b.textContent.includes('Ante'));
                const callBtn = Array.from(buttons).find(b => b.textContent.includes('Call'));
                const checkBtn = Array.from(buttons).find(b => b.textContent === 'Check');
                const betBtn = Array.from(buttons).find(b => b.textContent.includes('Bet') && !b.textContent.includes('Toggle'));
                const foldBtn = Array.from(buttons).find(b => b.textContent === 'Fold');

                if (anteBtn) {
                    // Pre-game - ante up
                    anteBtn.click();
                    setTimeout(() => Autoplay.scheduleNext(), 1500);
                } else if (callBtn && foldBtn) {
                    // Pre-flop decision with tutoring
                    const action = Autoplay.getPokerAction('preflop');
                    const odds = PokerGame.calculateOdds();
                    const r1 = STATE.playerHand[0], r2 = STATE.playerHand[1];
                    const isPair = r1.pokerValue === r2.pokerValue;
                    const hasHighCard = r1.pokerValue >= 11 || r2.pokerValue >= 11;

                    let reason = '';
                    if (action === 'call') {
                        if (isPair) reason = `Pocket pair (${r1.rank}s) - strong starting hand.`;
                        else if (hasHighCard) reason = `High cards (${r1.rank}, ${r2.rank}) - playable hand.`;
                        else reason = `Odds look favorable at ${odds}%.`;
                    } else {
                        reason = `Weak hand (${r1.rank}, ${r2.rank}) with only ${odds}% win chance.`;
                    }

                    await TutoringSystem.explainPokerDecision(action, reason, odds);

                    if (action === 'fold') {
                        foldBtn.click();
                    } else {
                        callBtn.click();
                    }
                    setTimeout(() => Autoplay.scheduleNext(), 1500);
                } else if (checkBtn && betBtn) {
                    // Post-flop decision with tutoring
                    const action = Autoplay.getPokerAction('postflop');
                    const odds = PokerGame.calculateOdds();
                    const score = PokerGame.evaluate(STATE.playerHand, STATE.communityCards);

                    let reason = '';
                    if (action === 'bet') {
                        if (score > 30000) reason = `Strong hand detected - betting for value.`;
                        else reason = `Good odds (${odds}%) justify aggression.`;
                    } else {
                        if (score > 10000) reason = `Decent hand, but checking to control pot size.`;
                        else reason = `Marginal hand - checking to see more cards cheaply.`;
                    }

                    await TutoringSystem.explainPokerDecision(action, reason, odds);

                    if (action === 'bet') {
                        betBtn.click();
                    } else {
                        checkBtn.click();
                    }
                    setTimeout(() => Autoplay.scheduleNext(), 1500);
                }
            },

            playBalatro: async () => {
                const bs = BalatroGame.state;

                // Check if game over
                if (bs.handsLeft <= 0 && bs.currentScore < bs.blindScore) {
                    STATE.autoplay = false;
                    Autoplay.updateIndicator();
                    return;
                }

                // Check if in shop phase
                const controls = document.getElementById('controls');
                const nextRoundBtn = Array.from(controls.querySelectorAll('.btn')).find(b => b.textContent === 'Next Round');
                if (nextRoundBtn) {
                    // In shop - buy jokers if affordable and beneficial
                    const dContainer = document.getElementById('dealer-hand');
                    const jokerEls = dContainer.querySelectorAll('.joker-card');

                    let bought = false;
                    jokerEls.forEach(el => {
                        if (!bought && bs.money >= 4 && bs.jokers.length < bs.maxJokers) {
                            el.click();
                            bought = true;
                        }
                    });

                    await TutoringSystem.show(
                        'Shop Phase',
                        bought ? 'Purchased a Joker to boost scoring potential.' : 'Saving money for future rounds.',
                        'Jokers multiply your score - prioritize them early!',
                        2000
                    );

                    setTimeout(() => {
                        nextRoundBtn.click();
                        Autoplay.scheduleNext();
                    }, 1500);
                    return;
                }

                // Find the best possible hand from current cards
                const bestPlay = Autoplay.findBestBalatroHand();

                if (bestPlay.shouldDiscard && bs.discardsLeft > 0) {
                    // Discard strategy - remove cards not in best potential hand
                    await TutoringSystem.show(
                        'Discard Strategy',
                        `Discarding ${bestPlay.discardCards.length} weak cards to improve hand.`,
                        `Looking for: ${bestPlay.targetHand}`,
                        2500
                    );

                    // Select cards to discard
                    STATE.playerHand.forEach(c => c.selected = false);
                    bestPlay.discardCards.forEach(c => c.selected = true);
                    BalatroGame.renderHand();

                    setTimeout(() => {
                        BalatroGame.discardCards();
                        Autoplay.scheduleNext();
                    }, 1500);
                } else {
                    // Play the best hand
                    const { handName, chips, mult } = bestPlay;
                    const totalScore = chips * mult;
                    const remaining = bs.blindScore - bs.currentScore;

                    await TutoringSystem.show(
                        `Playing: ${handName}`,
                        `${chips} chips √ó ${mult} mult = ${totalScore} points`,
                        remaining > totalScore && bs.handsLeft > 1
                            ? `Need ${remaining} more. ${bs.handsLeft} hands left.`
                            : totalScore >= remaining
                                ? 'This should beat the blind!'
                                : 'Every point counts!',
                        2500
                    );

                    // Select the cards to play
                    STATE.playerHand.forEach(c => c.selected = false);
                    bestPlay.cards.forEach(c => c.selected = true);
                    BalatroGame.renderHand();

                    setTimeout(() => {
                        BalatroGame.playHand();
                        setTimeout(() => Autoplay.scheduleNext(), 1000);
                    }, 1500);
                }
            },

            findBestBalatroHand: () => {
                const hand = STATE.playerHand;
                const bs = BalatroGame.state;
                let bestHand = { cards: [], handName: 'High Card', chips: 0, mult: 0, score: 0 };

                // Generate all combinations of 1-5 cards
                const combinations = [];
                for (let size = 1; size <= Math.min(5, hand.length); size++) {
                    Autoplay.getCombinations(hand, size).forEach(combo => combinations.push(combo));
                }

                // Evaluate each combination
                combinations.forEach(combo => {
                    const result = BalatroGame.evaluateHand(combo);
                    const score = result.chips * result.mult;
                    if (score > bestHand.score) {
                        bestHand = { cards: combo, ...result, score };
                    }
                });

                // Decide if we should discard to improve
                const remaining = bs.blindScore - bs.currentScore;
                const canWinNow = bestHand.score >= remaining;
                const shouldDiscard = !canWinNow && bs.discardsLeft > 0 && bs.handsLeft > 1;

                // Find cards to discard (ones not in our best potential hands)
                let discardCards = [];
                let targetHand = bestHand.handName;

                if (shouldDiscard) {
                    const cardsInBestHand = new Set(bestHand.cards);
                    const potentialDiscards = hand.filter(c => !cardsInBestHand.has(c));

                    // Keep cards that could form better hands
                    const suits = {};
                    const ranks = {};
                    hand.forEach(c => {
                        suits[c.suit] = (suits[c.suit] || 0) + 1;
                        ranks[c.rank] = (ranks[c.rank] || 0) + 1;
                    });

                    // Check for flush draws (4 of same suit)
                    const flushDraw = Object.entries(suits).find(([s, count]) => count >= 4);
                    if (flushDraw) {
                        targetHand = 'Flush';
                        discardCards = hand.filter(c => c.suit !== flushDraw[0]).slice(0, Math.min(3, bs.discardsLeft));
                    }
                    // Check for straight draws
                    else if (Autoplay.hasStraightDraw(hand)) {
                        targetHand = 'Straight';
                        discardCards = potentialDiscards.slice(0, Math.min(2, bs.discardsLeft));
                    }
                    // Check for pair upgrades (trips/quads)
                    else if (Object.values(ranks).some(c => c >= 2)) {
                        const pairRank = Object.entries(ranks).find(([r, c]) => c >= 2)?.[0];
                        targetHand = 'Three of a Kind';
                        discardCards = hand.filter(c => c.rank !== pairRank).slice(0, Math.min(3, bs.discardsLeft));
                    } else {
                        // Generic discard - keep high cards
                        const sorted = [...hand].sort((a, b) => b.pokerValue - a.pokerValue);
                        discardCards = sorted.slice(5).slice(0, Math.min(3, bs.discardsLeft));
                        targetHand = 'Pair';
                    }
                }

                return {
                    ...bestHand,
                    shouldDiscard: shouldDiscard && discardCards.length > 0,
                    discardCards,
                    targetHand
                };
            },

            getCombinations: (arr, size) => {
                const result = [];
                const combine = (start, combo) => {
                    if (combo.length === size) {
                        result.push([...combo]);
                        return;
                    }
                    for (let i = start; i < arr.length; i++) {
                        combo.push(arr[i]);
                        combine(i + 1, combo);
                        combo.pop();
                    }
                };
                combine(0, []);
                return result;
            },

            hasStraightDraw: (cards) => {
                const values = [...new Set(cards.map(c => c.pokerValue))].sort((a, b) => a - b);
                // Check for 4 consecutive cards
                for (let i = 0; i <= values.length - 4; i++) {
                    if (values[i + 3] - values[i] <= 4) return true;
                }
                // Check for A-2-3-4 or A-K-Q-J draws
                if (values.includes(14)) {
                    if (values.filter(v => v <= 5).length >= 3) return true;
                    if (values.filter(v => v >= 11).length >= 3) return true;
                }
                return false;
            },

            getPokerAction: (phase) => {
                const winProb = parseFloat(PokerGame.calculateOdds());
                const score = PokerGame.evaluate(STATE.playerHand, STATE.communityCards);

                if (phase === 'preflop') {
                    // Pre-flop: play with pairs, high cards, or good win probability
                    const r1 = STATE.playerHand[0].pokerValue;
                    const r2 = STATE.playerHand[1].pokerValue;
                    const isPair = r1 === r2;
                    const hasHighCard = r1 >= 11 || r2 >= 11;

                    if (isPair || hasHighCard || winProb > 45) return 'call';
                    if (winProb < 35) return 'fold';
                    return 'call'; // Slight aggression
                } else {
                    // Post-flop: bet with good hands, check with marginal
                    if (score > 20000 || winProb > 60) return 'bet';
                    if (score > 10000 || winProb > 50) return 'check'; // Pair or decent odds
                    if (winProb > 40) return 'check';
                    return 'check'; // Conservative
                }
            }
        };

        // --- Card System ---
        const SUITS = ['‚ô†', '‚ô•', '‚ô£', '‚ô¶'];
        const RANKS = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
        
        class Card {
            constructor(suit, rank) {
                this.suit = suit;
                this.rank = rank;
                this.color = (suit === '‚ô•' || suit === '‚ô¶') ? 'red' : 'black';
                this.faceUp = true;
                this.id = `${suit}${rank}`; // Unique identifier
                // Balatro enhancements
                this.enhancement = null; // foil, holographic, polychrome, bonus, mult, wild, glass, steel, stone, gold
                this.seal = null; // gold, red, blue, purple
                this.edition = null; // foil, holo, poly
                this.bonusChips = 0;
                this.bonusMult = 0;
                this.selected = false;
                this.location = 'deck'; // deck, hand, played, discarded, destroyed
            }

            get value() {
                if (this.rank === 'A') return 14;
                if (['K', 'Q', 'J'].includes(this.rank)) return 10;
                return parseInt(this.rank) || 10;
            }

            get pokerValue() {
                const map = {'2':2, '3':3, '4':4, '5':5, '6':6, '7':7, '8':8, '9':9, '10':10, 'J':11, 'Q':12, 'K':13, 'A':14};
                return map[this.rank];
            }

            get balatroChips() {
                // Base chip value for scoring
                const baseChips = {'A':11, 'K':10, 'Q':10, 'J':10, '10':10, '9':9, '8':8, '7':7, '6':6, '5':5, '4':4, '3':3, '2':2};
                let chips = baseChips[this.rank] || 0;
                chips += this.bonusChips;
                if (this.enhancement === 'bonus') chips += 30;
                if (this.enhancement === 'stone') chips += 50;
                return chips;
            }

            clone() {
                const c = new Card(this.suit, this.rank);
                c.enhancement = this.enhancement;
                c.seal = this.seal;
                c.edition = this.edition;
                c.bonusChips = this.bonusChips;
                c.bonusMult = this.bonusMult;
                c.faceUp = this.faceUp;
                c.location = this.location;
                return c;
            }

            render(selectable = false) {
                const el = document.createElement('div');
                let classes = `card ${this.color}`;
                if (!this.faceUp) classes += ' card-back';
                if (this.enhancement) classes += ` ${this.enhancement}`;
                if (this.edition) classes += ` ${this.edition}`;
                if (this.selected) classes += ' selected';
                el.className = classes;
                el.dataset.cardId = this.id;

                if (selectable) {
                    el.style.cursor = 'pointer';
                    el.onclick = () => {
                        this.selected = !this.selected;
                        el.classList.toggle('selected');
                        if (typeof BalatroGame !== 'undefined') BalatroGame.updateHandPreview();
                    };
                }

                if (this.faceUp) {
                    el.innerHTML = `
                        <div class="card-corner top">
                            <div>${this.rank}</div>
                            <div>${this.suit}</div>
                        </div>
                        <div class="card-center">${this.suit}</div>
                        <div class="card-corner bottom">
                            <div>${this.rank}</div>
                            <div>${this.suit}</div>
                        </div>
                    `;
                    if (this.seal) {
                        const sealEl = document.createElement('div');
                        sealEl.className = 'card-seal';
                        sealEl.style.cssText = 'position:absolute;bottom:5px;right:5px;width:12px;height:12px;border-radius:50%;';
                        sealEl.style.background = this.seal;
                        el.appendChild(sealEl);
                    }
                }
                return el;
            }
        }

        function createDeck() {
            const deck = [];
            for (let s of SUITS) {
                for (let r of RANKS) {
                    deck.push(new Card(s, r));
                }
            }
            return shuffle(deck);
        }

        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // --- UI Functions ---
        function showMenu() {
            document.getElementById('game-menu').style.display = 'flex';
            STATE.game = null;
            STATE.autoplay = false;
            Autoplay.updateIndicator();
            ScoreTracker.hide();
            // Hide Balatro-specific UI
            const balatroHud = document.getElementById('balatro-hud');
            if (balatroHud) balatroHud.style.display = 'none';
            CardRoster.hide();
            updateDealer("Select a game to begin.");
        }
        const returnToMenu = showMenu; // Alias for convenience

        function updateDealer(msg) {
            document.getElementById('dealer-text').textContent = `"${msg}"`;
        }

        function showOverlay(msg, duration = 2000) {
            const el = document.getElementById('message-overlay');
            document.getElementById('overlay-text').textContent = msg;
            el.classList.add('visible');
            if (STATE.messageTimer) clearTimeout(STATE.messageTimer);
            if (duration > 0) {
                STATE.messageTimer = setTimeout(() => {
                    el.classList.remove('visible');
                }, duration);
            }
        }

        function renderHands() {
            const pContainer = document.getElementById('player-hand');
            const dContainer = document.getElementById('dealer-hand');
            const cContainer = document.getElementById('community-cards');

            // Helper to render only new cards
            const renderContainer = (container, cards) => {
                const existingCount = container.children.length;
                const newCount = cards.length;

                // If fewer cards now, clear and re-render
                if (newCount < existingCount) {
                    container.innerHTML = '';
                    cards.forEach(c => {
                        const el = c.render();
                        el.classList.add('dealt'); // Already dealt, no animation
                        container.appendChild(el);
                    });
                } else {
                    // Update existing cards (for face-up changes)
                    for (let i = 0; i < existingCount; i++) {
                        const oldEl = container.children[i];
                        const newEl = cards[i].render();
                        // Keep dealt class, update content
                        newEl.classList.add('dealt');
                        container.replaceChild(newEl, oldEl);
                    }
                    // Add only NEW cards (without dealt class - they'll animate)
                    for (let i = existingCount; i < newCount; i++) {
                        container.appendChild(cards[i].render());
                    }
                }
            };

            renderContainer(pContainer, STATE.playerHand);
            renderContainer(dContainer, STATE.dealerHand);
            renderContainer(cContainer, STATE.communityCards);

            document.getElementById('chips').textContent = STATE.chips;
        }

        function setControls(buttons) {
            const c = document.getElementById('controls');
            c.innerHTML = '';
            buttons.forEach(b => {
                const btn = document.createElement('button');
                let className = `btn ${b.primary ? 'btn-primary' : 'btn-secondary'}`;
                if (b.autoplay && STATE.autoplay) {
                    className += ' btn-autoplay-active';
                }
                btn.className = className;
                btn.textContent = b.text;
                btn.onclick = b.action;
                if (b.disabled) btn.disabled = true;
                c.appendChild(btn);
            });
        }

        // --- Data Management ---
        const DataManager = {
            save: () => {
                const data = {
                    chips: STATE.chips,
                    stats: STATE.stats,
                    scores: STATE.scores,
                    timestamp: Date.now()
                };
                const json = JSON.stringify(data);
                const blob = new Blob([json], {type: "application/json"});
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = `virtual-dealer-save-${new Date().toISOString().slice(0,10)}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            },
            load: (inputElement) => {
                const file = inputElement.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        if (data.chips !== undefined) STATE.chips = data.chips;
                        if (data.stats) STATE.stats = data.stats;
                        if (data.scores) STATE.scores = data.scores;

                        DataManager.autoSave();
                        alert("Data loaded successfully!");
                        location.reload(); // Reload to ensure state is fresh
                    } catch (err) {
                        alert("Invalid save file");
                    }
                };
                reader.readAsText(file);
            },
            autoSave: () => {
                const data = {
                    chips: STATE.chips,
                    stats: STATE.stats,
                    scores: STATE.scores
                };
                localStorage.setItem('virtualDealerSave', JSON.stringify(data));
            },
            autoLoad: () => {
                const saved = localStorage.getItem('virtualDealerSave');
                if (saved) {
                    try {
                        const data = JSON.parse(saved);
                        if (data.chips !== undefined) STATE.chips = data.chips;
                        if (data.stats) STATE.stats = data.stats;
                        if (data.scores) STATE.scores = data.scores;
                    } catch (e) { console.error(e); }
                }
            }
        };

        // --- Shared Helpers ---
        function ensureAdviceBox() {
            let box = document.getElementById('game-advice');
            if (!box) {
                const gameArea = document.getElementById('game-area');
                box = document.createElement('div');
                box.id = 'game-advice';
                box.className = 'advice-box visible';
                gameArea.appendChild(box);
            }
            box.style.display = 'block';
            return box;
        }

        function showGameAdvice(text, enabled) {
            const box = ensureAdviceBox();
            if (enabled) {
                box.style.display = 'block';
                box.innerHTML = text;
            } else {
                box.style.display = 'none';
            }
        }

        function animateDeal() {
            // Only animate cards that haven't been animated yet
            const newCards = document.querySelectorAll('.card:not(.dealt)');
            newCards.forEach(c => {
                c.classList.add('dealing');
                c.classList.add('dealt'); // Mark as already animated
            });

            // Remove the dealing class after animation completes
            setTimeout(() => {
                newCards.forEach(c => c.classList.remove('dealing'));
            }, 500);
        }

        function animateWin(winner) {
            const cls = winner === 'Player' ? 'win-player' : 'win-dealer';
            document.querySelectorAll('.card').forEach(c => c.classList.add(cls));
        }

        // --- Game Logic: WAR ---
        const WarGame = {
            deck: [],
            playerDeck: [],
            dealerDeck: [],
            pot: [],
            state: 'idle', // idle, war
            adviceEnabled: true,

            init: () => {
                // Create and split deck
                const fullDeck = createDeck();
                STATE.deck = []; // Not used in War, we use split decks
                WarGame.playerDeck = fullDeck.slice(0, 26);
                WarGame.dealerDeck = fullDeck.slice(26, 52);
                WarGame.pot = [];
                WarGame.state = 'idle';
                
                // Setup UI
                document.getElementById('community-cards').style.display = 'none';
                document.getElementById('chip-display').style.display = 'none';
                
                // Add War specific UI elements if not present
                if (!document.getElementById('war-stats')) {
                    const gameArea = document.getElementById('game-area');
                    const stats = document.createElement('div');
                    stats.id = 'war-stats';
                    stats.className = 'war-stats';
                    gameArea.appendChild(stats);
                }
                document.getElementById('war-stats').style.display = 'block';
                ensureAdviceBox();

                updateDealer("War. I have 26 cards, you have 26. Collect them all to become the Dealer.");
                WarGame.updateUI();
                WarGame.nextRound();
            },

            updateUI: () => {
                const stats = document.getElementById('war-stats');
                if (stats) {
                    stats.innerHTML = `
                        <div>Dealer Deck: ${WarGame.dealerDeck.length}</div>
                        <div style="margin-top:10px">Player Deck: ${WarGame.playerDeck.length}</div>
                        <div style="margin-top:10px; font-size:0.8em; opacity:0.7">Pot: ${WarGame.pot.length}</div>
                    `;
                }
            },

            nextRound: () => {
                if (WarGame.playerDeck.length === 0) {
                    WarGame.endGame('Dealer');
                    return;
                }
                if (WarGame.dealerDeck.length === 0) {
                    WarGame.endGame('Player');
                    return;
                }

                STATE.playerHand = [];
                STATE.dealerHand = [];
                renderHands();

                setControls([
                    { text: 'Battle', action: WarGame.battle, primary: true },
                    { text: STATE.autoplay ? 'Stop Auto' : 'Autoplay', action: Autoplay.toggle, primary: false, autoplay: true },
                    { text: 'Toggle Advice', action: WarGame.toggleAdvice, primary: false }
                ]);
            },

            toggleAdvice: () => {
                WarGame.adviceEnabled = !WarGame.adviceEnabled;
                showGameAdvice("Advice " + (WarGame.adviceEnabled ? "enabled." : "disabled."), WarGame.adviceEnabled);
            },

            showAdvice: (text) => {
                showGameAdvice(text, WarGame.adviceEnabled);
            },

            battle: () => {
                if (WarGame.playerDeck.length === 0 || WarGame.dealerDeck.length === 0) {
                    WarGame.nextRound(); // Trigger end game check
                    return;
                }

                const pCard = WarGame.playerDeck.shift();
                const dCard = WarGame.dealerDeck.shift();

                STATE.playerHand = [pCard];
                STATE.dealerHand = [dCard];

                renderHands();
                animateDeal();

                WarGame.pot.push(pCard, dCard);
                WarGame.updateUI();

                const pVal = pCard.pokerValue;
                const dVal = dCard.pokerValue;

                // Delay before resolution to let cards be visible
                const initialDelay = STATE.autoplay ? 1000 : 600;

                setTimeout(async () => {
                    if (STATE.autoplay) {
                        // Show tutoring explanation first
                        await TutoringSystem.explainWarBattle(pCard, dCard);
                    }

                    if (pVal > dVal) {
                        WarGame.resolveRound('Player', pCard, dCard);
                    } else if (dVal > pVal) {
                        WarGame.resolveRound('Dealer', pCard, dCard);
                    } else {
                        WarGame.triggerWar(pCard, dCard);
                    }
                }, initialDelay);
            },

            resolveRound: async (winner, pCard, dCard) => {
                let msg = "";
                const potSize = WarGame.pot.length;

                if (winner === 'Player') {
                    msg = `You win! ${pCard.rank} beats ${dCard.rank}.`;
                    WarGame.showAdvice(`<strong>Nice!</strong> High card wins. You collect ${potSize} cards.`);
                    showOverlay("Round Won");
                    ScoreTracker.playerWin();

                    // In autoplay, wait before animating cards away
                    if (STATE.autoplay) {
                        await TutoringSystem.explainWarOutcome(potSize, 'Player');
                    }

                    animateWin('Player');

                    setTimeout(() => {
                        WarGame.playerDeck.push(...WarGame.pot);
                        WarGame.pot = [];
                        WarGame.updateUI();
                        WarGame.nextRound();
                    }, STATE.autoplay ? 800 : 600);
                } else {
                    msg = `I win. ${dCard.rank} beats ${pCard.rank}.`;
                    WarGame.showAdvice(`<strong>Ouch.</strong> Dealer had the higher card. You lost the pot.`);
                    showOverlay("Round Lost");
                    ScoreTracker.dealerWin();

                    // In autoplay, wait before animating cards away
                    if (STATE.autoplay) {
                        await TutoringSystem.explainWarOutcome(potSize, 'Dealer');
                    }

                    animateWin('Dealer');

                    setTimeout(() => {
                        WarGame.dealerDeck.push(...WarGame.pot);
                        WarGame.pot = [];
                        WarGame.updateUI();
                        WarGame.nextRound();
                    }, STATE.autoplay ? 800 : 600);
                }
                updateDealer(msg);
            },

            triggerWar: async (pCard, dCard) => {
                updateDealer("WAR! We tied. 3 cards down, 1 card up.");
                WarGame.showAdvice(`<strong>WAR!</strong> A tie on ${pCard.rank}s. The stakes just got higher.`);
                ScoreTracker.tie();

                if (STATE.autoplay) {
                    // Auto-proceed to war after explanation shows
                    setTimeout(() => {
                        if (STATE.autoplay) WarGame.executeWar();
                    }, 3500);
                }

                setControls([
                    { text: 'Go to War', action: WarGame.executeWar, primary: true }
                ]);
            },

            executeWar: () => {
                // Check if enough cards
                if (WarGame.playerDeck.length < 4 || WarGame.dealerDeck.length < 4) {
                    // Special case: not enough cards for full war
                    // Simplified: whoever runs out loses immediately in this version
                    if (WarGame.playerDeck.length < 1) WarGame.endGame('Dealer');
                    else if (WarGame.dealerDeck.length < 1) WarGame.endGame('Player');
                    else {
                        // Play what we have
                        WarGame.battle();
                    }
                    return;
                }

                // Burn 3 cards
                for(let i=0; i<3; i++) WarGame.pot.push(WarGame.playerDeck.shift());
                for(let i=0; i<3; i++) WarGame.pot.push(WarGame.dealerDeck.shift());
                
                WarGame.updateUI();
                WarGame.battle(); // Play the war card
            },

            endGame: (winner) => {
                STATE.autoplay = false;
                Autoplay.updateIndicator();

                if (winner === 'Player') {
                    updateDealer("Impossible... You have taken everything.");
                    showOverlay("YOU ARE THE DEALER NOW!", 5000);
                    WarGame.showAdvice("<strong>CONGRATULATIONS!</strong> You have collected the entire deck. You are now the master of the table.");
                } else {
                    updateDealer("The house always wins eventually.");
                    showOverlay("GAME OVER", 3000);
                    WarGame.showAdvice("<strong>Game Over.</strong> You ran out of cards. Try again!");
                }
                setControls([
                    { text: 'Play Again', action: WarGame.init, primary: true },
                    { text: 'Menu', action: showMenu, primary: false }
                ]);
            }
        };

        // --- Game Logic: BLACKJACK ---
        const BlackjackGame = {
            adviceEnabled: true,
            init: () => {
                STATE.deck = createDeck();
                document.getElementById('community-cards').style.display = 'none';
                document.getElementById('chip-display').style.display = 'block';
                if (document.getElementById('war-stats')) document.getElementById('war-stats').style.display = 'none';
                ensureAdviceBox();
                
                updateDealer("Blackjack. Place your bet.");
                BlackjackGame.bettingPhase();
            },
            toggleAdvice: () => {
                BlackjackGame.adviceEnabled = !BlackjackGame.adviceEnabled;
                showGameAdvice("Advice " + (BlackjackGame.adviceEnabled ? "enabled." : "disabled."), BlackjackGame.adviceEnabled);
            },
            showAdvice: (text) => {
                showGameAdvice(text, BlackjackGame.adviceEnabled);
            },
            bettingPhase: () => {
                STATE.playerHand = [];
                STATE.dealerHand = [];
                renderHands();
                BlackjackGame.showAdvice("<strong>Betting:</strong> Choose your stake to begin.");
                setControls([
                    { text: 'Bet 10', action: () => BlackjackGame.deal(10), primary: true },
                    { text: 'Bet 50', action: () => BlackjackGame.deal(50), primary: true },
                    { text: STATE.autoplay ? 'Stop Auto' : 'Autoplay', action: Autoplay.toggle, primary: false, autoplay: true },
                    { text: 'Toggle Advice', action: BlackjackGame.toggleAdvice, primary: false }
                ]);
            },
            deal: (bet) => {
                if (STATE.chips < bet) {
                    updateDealer("Insufficient funds.");
                    return;
                }
                STATE.bet = bet;
                STATE.chips -= bet;
                
                if (STATE.deck.length < 10) STATE.deck = createDeck();

                STATE.playerHand = [STATE.deck.pop(), STATE.deck.pop()];
                STATE.dealerHand = [STATE.deck.pop(), STATE.deck.pop()];
                STATE.dealerHand[1].faceUp = false; // Hide hole card

                renderHands();
                animateDeal();
                BlackjackGame.checkBlackjack();
            },
            getScore: (hand) => {
                let score = 0;
                let aces = 0;
                for (let c of hand) {
                    let val = c.rank === 'A' ? 11 : (['K','Q','J'].includes(c.rank) ? 10 : parseInt(c.rank));
                    score += val;
                    if (c.rank === 'A') aces++;
                }
                while (score > 21 && aces > 0) {
                    score -= 10;
                    aces--;
                }
                return score;
            },
            checkBlackjack: () => {
                const pScore = BlackjackGame.getScore(STATE.playerHand);
                if (pScore === 21) {
                    BlackjackGame.resolve(true); // Player Blackjack
                } else {
                    BlackjackGame.playerTurn();
                }
            },
            playerTurn: () => {
                const score = BlackjackGame.getScore(STATE.playerHand);
                const dUp = STATE.dealerHand[0].value;
                updateDealer(`You have ${score}. Hit or Stand?`);
                
                // Advice Logic
                let advice = "";
                if (score >= 17) advice = "<strong>Stand.</strong> You have a strong hand.";
                else if (score <= 11) advice = "<strong>Hit.</strong> No risk of busting.";
                else if (dUp >= 7) advice = "<strong>Hit.</strong> Dealer shows strength (" + dUp + ").";
                else advice = "<strong>Stand.</strong> Dealer shows weakness (" + dUp + "), let them bust.";
                
                BlackjackGame.showAdvice(advice);

                setControls([
                    { text: 'Hit', action: BlackjackGame.hit, primary: true },
                    { text: 'Stand', action: BlackjackGame.stand, primary: false },
                    { text: STATE.autoplay ? 'Stop Auto' : 'Autoplay', action: Autoplay.toggle, primary: false, autoplay: true },
                    { text: 'Toggle Advice', action: BlackjackGame.toggleAdvice, primary: false }
                ]);
            },
            hit: async () => {
                STATE.playerHand.push(STATE.deck.pop());
                renderHands();
                animateDeal();
                const score = BlackjackGame.getScore(STATE.playerHand);
                if (score > 21) {
                    updateDealer("Bust! House wins.");
                    BlackjackGame.showAdvice("<strong>Bust!</strong> You went over 21.");
                    showOverlay("Bust!");
                    ScoreTracker.dealerWin();

                    if (STATE.autoplay) {
                        await TutoringSystem.explainBlackjackResult(score, 0, 'bust');
                    }

                    animateWin('Dealer');
                    setTimeout(BlackjackGame.bettingPhase, STATE.autoplay ? 1500 : 2000);
                } else {
                    BlackjackGame.playerTurn();
                }
            },
            stand: () => {
                STATE.dealerHand[1].faceUp = true;
                renderHands();
                BlackjackGame.dealerTurn();
            },
            dealerTurn: () => {
                let dScore = BlackjackGame.getScore(STATE.dealerHand);
                
                const playDealer = () => {
                    if (dScore < 17) {
                        STATE.dealerHand.push(STATE.deck.pop());
                        renderHands();
                        animateDeal();
                        dScore = BlackjackGame.getScore(STATE.dealerHand);
                        setTimeout(playDealer, 1000);
                    } else {
                        BlackjackGame.resolve();
                    }
                };
                playDealer();
            },
            resolve: async (playerBlackjack = false) => {
                const pScore = BlackjackGame.getScore(STATE.playerHand);
                const dScore = BlackjackGame.getScore(STATE.dealerHand);

                let win = false;
                let push = false;

                if (playerBlackjack) {
                    // Check if dealer also has blackjack
                    STATE.dealerHand[1].faceUp = true;
                    renderHands();
                    if (BlackjackGame.getScore(STATE.dealerHand) === 21) push = true;
                    else win = true;
                } else if (dScore > 21) {
                    win = true;
                } else if (pScore > dScore) {
                    win = true;
                } else if (pScore === dScore) {
                    push = true;
                }

                if (win) {
                    const payout = playerBlackjack ? 2.5 : 2;
                    STATE.chips += STATE.bet * payout;
                    updateDealer(playerBlackjack ? "Blackjack!" : "You win.");
                    BlackjackGame.showAdvice("<strong>Winner!</strong> " + (playerBlackjack ? "Blackjack pays 3:2." : "You beat the dealer."));
                    showOverlay("You Win!");
                    ScoreTracker.playerWin();

                    if (STATE.autoplay) {
                        await TutoringSystem.explainBlackjackResult(pScore, dScore, 'win');
                    }

                    animateWin('Player');

                    // Win Condition
                    if (STATE.chips >= 5000) {
                        STATE.autoplay = false;
                        Autoplay.updateIndicator();
                        TutoringSystem.hide();
                        setTimeout(() => {
                            showOverlay("YOU BROKE THE BANK!", 5000);
                            updateDealer("You have cleaned me out. You are the Dealer now.");
                        }, 2000);
                        return;
                    }
                } else if (push) {
                    STATE.chips += STATE.bet;
                    updateDealer("Push.");
                    BlackjackGame.showAdvice("<strong>Push.</strong> Bets returned.");
                    showOverlay("Push");
                    ScoreTracker.tie();

                    if (STATE.autoplay) {
                        await TutoringSystem.explainBlackjackResult(pScore, dScore, 'push');
                    }
                } else {
                    updateDealer("House wins.");
                    BlackjackGame.showAdvice("<strong>Loss.</strong> Better luck next hand.");
                    showOverlay("Dealer Wins");
                    ScoreTracker.dealerWin();

                    if (STATE.autoplay) {
                        await TutoringSystem.explainBlackjackResult(pScore, dScore, 'lose');
                    }

                    animateWin('Dealer');
                }

                setTimeout(BlackjackGame.bettingPhase, STATE.autoplay ? 1500 : 3000);
            }
        };

        // --- Game Logic: POKER (Simplified Heads-Up) ---
        const PokerGame = {
            adviceEnabled: true,
            init: () => {
                STATE.deck = createDeck();
                document.getElementById('community-cards').style.display = 'flex';
                document.getElementById('chip-display').style.display = 'block';
                if (document.getElementById('war-stats')) document.getElementById('war-stats').style.display = 'none';
                ensureAdviceBox();
                
                updateDealer("Texas Hold'em. Ante up.");
                PokerGame.startRound();
            },
            toggleAdvice: () => {
                PokerGame.adviceEnabled = !PokerGame.adviceEnabled;
                showGameAdvice("Advice " + (PokerGame.adviceEnabled ? "enabled." : "disabled."), PokerGame.adviceEnabled);
                if (PokerGame.adviceEnabled && STATE.playerHand.length > 0) {
                    PokerGame.analyzeHand("Current");
                }
            },
            showAdvice: (text) => {
                showGameAdvice(text, PokerGame.adviceEnabled);
            },
            startRound: () => {
                STATE.playerHand = [];
                STATE.dealerHand = [];
                STATE.communityCards = [];
                renderHands();
                PokerGame.showAdvice("<strong>Ante Up:</strong> Pay the blind to see your cards.");
                setControls([
                    { text: 'Ante 20', action: () => PokerGame.deal(20), primary: true },
                    { text: STATE.autoplay ? 'Stop Auto' : 'Autoplay', action: Autoplay.toggle, primary: false, autoplay: true },
                    { text: 'Toggle Advice', action: PokerGame.toggleAdvice, primary: false }
                ]);
            },
            deal: (ante) => {
                if (STATE.chips < ante) return;
                STATE.bet = ante;
                STATE.chips -= ante;
                
                if (STATE.deck.length < 15) STATE.deck = createDeck();

                STATE.playerHand = [STATE.deck.pop(), STATE.deck.pop()];
                STATE.dealerHand = [STATE.deck.pop(), STATE.deck.pop()];
                STATE.dealerHand.forEach(c => c.faceUp = false);

                renderHands();
                animateDeal();
                updateDealer("Pre-flop. Call or Fold?");
                
                PokerGame.analyzeHand("Pre-flop");

                setControls([
                    { text: 'Call (20)', action: () => PokerGame.flop(20), primary: true },
                    { text: 'Fold', action: PokerGame.fold, primary: false },
                    { text: STATE.autoplay ? 'Stop Auto' : 'Autoplay', action: Autoplay.toggle, primary: false, autoplay: true },
                    { text: 'Toggle Advice', action: PokerGame.toggleAdvice, primary: false }
                ]);
            },
            flop: (bet) => {
                if (STATE.chips < bet) return;
                STATE.chips -= bet;
                STATE.bet += bet;

                STATE.communityCards.push(STATE.deck.pop(), STATE.deck.pop(), STATE.deck.pop());
                renderHands();
                animateDeal();
                updateDealer("The Flop. Check or Bet?");
                
                PokerGame.analyzeHand("Flop");

                setControls([
                    { text: 'Check', action: () => PokerGame.turn(0), primary: false },
                    { text: 'Bet 50', action: () => PokerGame.turn(50), primary: true },
                    { text: STATE.autoplay ? 'Stop Auto' : 'Autoplay', action: Autoplay.toggle, primary: false, autoplay: true },
                    { text: 'Toggle Advice', action: PokerGame.toggleAdvice, primary: false }
                ]);
            },
            turn: (bet) => {
                if (STATE.chips < bet) return;
                STATE.chips -= bet;
                STATE.bet += bet;

                STATE.communityCards.push(STATE.deck.pop());
                renderHands();
                animateDeal();
                updateDealer("The Turn.");
                
                PokerGame.analyzeHand("Turn");

                setControls([
                    { text: 'Check', action: () => PokerGame.river(0), primary: false },
                    { text: 'Bet 50', action: () => PokerGame.river(50), primary: true },
                    { text: STATE.autoplay ? 'Stop Auto' : 'Autoplay', action: Autoplay.toggle, primary: false, autoplay: true },
                    { text: 'Toggle Advice', action: PokerGame.toggleAdvice, primary: false }
                ]);
            },
            river: (bet) => {
                if (STATE.chips < bet) return;
                STATE.chips -= bet;
                STATE.bet += bet;

                STATE.communityCards.push(STATE.deck.pop());
                renderHands();
                animateDeal();
                updateDealer("The River. Final decision.");
                
                PokerGame.analyzeHand("River");

                setControls([
                    { text: 'Check', action: () => PokerGame.showdown(0), primary: false },
                    { text: 'Bet 100', action: () => PokerGame.showdown(100), primary: true },
                    { text: STATE.autoplay ? 'Stop Auto' : 'Autoplay', action: Autoplay.toggle, primary: false, autoplay: true },
                    { text: 'Toggle Advice', action: PokerGame.toggleAdvice, primary: false }
                ]);
            },
            analyzeHand: (stage) => {
                const score = PokerGame.evaluate(STATE.playerHand, STATE.communityCards);
                const winProb = PokerGame.calculateOdds();
                
                let advice = `<strong>${stage}:</strong> Win Probability: ${winProb}%<br>`;
                
                if (score > 60000) advice += "Full House or better! All in.";
                else if (score > 50000) advice += "Flush! Very strong.";
                else if (score > 40000) advice += "Straight! Strong hand.";
                else if (score > 30000) advice += "Three of a Kind. Good position.";
                else if (score > 20000) advice += "Two Pair. Strong.";
                else if (score > 10000) advice += "Pair. Decent.";
                else if (winProb > 60) advice += "High Card but good odds.";
                else advice += "Weak hand. Caution.";
                
                PokerGame.showAdvice(advice);
            },
            showdown: (bet) => {
                if (STATE.chips < bet) return;
                STATE.chips -= bet;
                STATE.bet += bet;

                STATE.dealerHand.forEach(c => c.faceUp = true);
                renderHands();

                const pScore = PokerGame.evaluate(STATE.playerHand, STATE.communityCards);
                const dScore = PokerGame.evaluate(STATE.dealerHand, STATE.communityCards);

                if (pScore > dScore) {
                    STATE.chips += STATE.bet * 2;
                    updateDealer("You have the better hand.");
                    showOverlay("You Win!");
                    animateWin('Player');
                    PokerGame.showAdvice("<strong>Winner!</strong> Your hand was stronger.");
                    ScoreTracker.playerWin();

                    if (STATE.chips >= 5000) {
                        STATE.autoplay = false;
                        Autoplay.updateIndicator();
                        setTimeout(() => {
                            showOverlay("POKER CHAMPION!", 5000);
                            updateDealer("You cleaned me out. The table is yours.");
                        }, 2000);
                        return;
                    }
                } else if (pScore === dScore) {
                    STATE.chips += STATE.bet;
                    updateDealer("Split pot.");
                    showOverlay("Tie!");
                    PokerGame.showAdvice("<strong>Tie!</strong> Same hand strength.");
                    ScoreTracker.tie();
                } else {
                    updateDealer("My hand is stronger.");
                    showOverlay("Dealer Wins");
                    animateWin('Dealer');
                    PokerGame.showAdvice("<strong>Lost.</strong> Dealer had a better hand.");
                    ScoreTracker.dealerWin();
                }

                setTimeout(PokerGame.startRound, 4000);
            },
            fold: () => {
                updateDealer("Folded.");
                PokerGame.showAdvice("<strong>Folded.</strong> Saving chips for a better hand.");
                ScoreTracker.dealerWin();
                setTimeout(PokerGame.startRound, 1000);
            },
            evaluate: (hand, community) => {
                const all = [...hand, ...community];
                if (all.length === 0) return 0;
                
                // Sort by rank descending
                all.sort((a, b) => b.pokerValue - a.pokerValue);
                
                // Check Flush
                const suits = {};
                all.forEach(c => suits[c.suit] = (suits[c.suit] || 0) + 1);
                let flushSuit = null;
                for (let s in suits) if (suits[s] >= 5) flushSuit = s;
                
                let flushScore = 0;
                if (flushSuit) {
                    const flushCards = all.filter(c => c.suit === flushSuit);
                    flushScore = 50000 + flushCards[0].pokerValue;
                }

                // Check Straight
                let straightScore = 0;
                let uniqueRanks = [...new Set(all.map(c => c.pokerValue))];
                let streak = 0;
                let maxStraightRank = 0;
                for (let i = 0; i < uniqueRanks.length - 1; i++) {
                    if (uniqueRanks[i] - uniqueRanks[i+1] === 1) {
                        streak++;
                        if (streak >= 4) maxStraightRank = uniqueRanks[i - 3];
                    } else {
                        streak = 0;
                    }
                }
                // Wheel (A-5)
                if (!maxStraightRank && uniqueRanks.includes(14) && uniqueRanks.includes(5) && uniqueRanks.includes(4) && uniqueRanks.includes(3) && uniqueRanks.includes(2)) {
                    maxStraightRank = 5;
                }
                
                if (maxStraightRank) straightScore = 40000 + maxStraightRank;

                // Check Pairs/Trips/Quads
                const counts = {};
                all.forEach(c => counts[c.pokerValue] = (counts[c.pokerValue] || 0) + 1);
                
                let pairScore = 0;
                let four = 0, three = 0, pair1 = 0, pair2 = 0;
                
                for (let r in counts) {
                    const rank = parseInt(r);
                    const count = counts[r];
                    if (count === 4) four = rank;
                    else if (count === 3) {
                        if (three > 0) pair1 = three; // downgrade previous three to pair
                        three = rank;
                    }
                    else if (count === 2) {
                        if (pair1 > 0) pair2 = pair1;
                        pair1 = rank;
                    }
                }
                
                if (four) pairScore = 70000 + four;
                else if (three && pair1) pairScore = 60000 + three; // Full House
                else if (flushScore) return flushScore; // Flush beats straight
                else if (straightScore) return straightScore;
                else if (three) pairScore = 30000 + three;
                else if (pair1 && pair2) pairScore = 20000 + pair1;
                else if (pair1) pairScore = 10000 + pair1;
                else pairScore = all[0].pokerValue; // High card
                
                return pairScore;
            },
            calculateOdds: () => {
                // Monte Carlo Simulation
                const iterations = 500;
                let wins = 0;
                let ties = 0;
                
                // Known cards
                const knownCards = [...STATE.playerHand, ...STATE.communityCards];
                const knownIds = new Set(knownCards.map(c => c.suit + c.rank));
                
                // Create a deck of remaining cards
                const fullDeck = createDeck();
                const remainingDeck = fullDeck.filter(c => !knownIds.has(c.suit + c.rank));
                
                for (let i = 0; i < iterations; i++) {
                    // Shuffle remaining deck
                    const simDeck = [...remainingDeck];
                    for (let j = simDeck.length - 1; j > 0; j--) {
                        const k = Math.floor(Math.random() * (j + 1));
                        [simDeck[j], simDeck[k]] = [simDeck[k], simDeck[j]];
                    }
                    
                    // Deal opponent hand
                    const oppHand = [simDeck.pop(), simDeck.pop()];
                    
                    // Deal remaining community cards
                    const simCommunity = [...STATE.communityCards];
                    while (simCommunity.length < 5) {
                        simCommunity.push(simDeck.pop());
                    }
                    
                    const myScore = PokerGame.evaluate(STATE.playerHand, simCommunity);
                    const oppScore = PokerGame.evaluate(oppHand, simCommunity);
                    
                    if (myScore > oppScore) wins++;
                    else if (myScore === oppScore) ties++;
                }
                
                return ((wins + ties/2) / iterations * 100).toFixed(1);
            }
        };

        // --- Balatro Game ---
        const BalatroGame = {
            state: {
                ante: 1,
                round: 1,
                blind: 'small', // small, big, boss
                blindScore: 300,
                currentScore: 0,
                handsLeft: 4,
                discardsLeft: 3,
                jokers: [],
                handLevels: JSON.parse(JSON.stringify(BALATRO_HANDS)),
                money: 4,
                maxJokers: 5,
                handSize: 8,
                selectedCards: []
            },

            init: () => {
                // Reset Balatro state
                BalatroGame.state = {
                    ante: 1,
                    round: 1,
                    blind: 'small',
                    blindScore: 300,
                    currentScore: 0,
                    handsLeft: 4,
                    discardsLeft: 3,
                    jokers: [],
                    handLevels: JSON.parse(JSON.stringify(BALATRO_HANDS)),
                    money: 4,
                    maxJokers: 5,
                    handSize: 8,
                    selectedCards: []
                };

                // Initialize deck with roster tracking
                CardRoster.init();
                STATE.deck = [];
                for (let s of SUITS) {
                    for (let r of RANKS) {
                        const card = new Card(s, r);
                        STATE.deck.push(card);
                        CardRoster.register(card);
                    }
                }
                STATE.deck = shuffle(STATE.deck);

                // Give starting joker
                BalatroGame.state.jokers.push(JOKER_LIBRARY[0]); // Basic Joker

                document.getElementById('community-cards').style.display = 'none';
                document.getElementById('chip-display').style.display = 'none';
                updateDealer('"Balatro! Build poker hands, score chips, and beat the blinds."');

                BalatroGame.renderHUD();
                BalatroGame.startRound();
            },

            startRound: () => {
                // Calculate blind score requirement
                const bs = BalatroGame.state;
                const baseScores = { small: 300, big: 450, boss: 600 };
                bs.blindScore = Math.floor(baseScores[bs.blind] * Math.pow(1.5, bs.ante - 1));
                bs.currentScore = 0;
                bs.handsLeft = 4;
                bs.discardsLeft = 3;

                // Draw initial hand
                STATE.playerHand = [];
                for (let i = 0; i < bs.handSize && STATE.deck.length > 0; i++) {
                    const card = STATE.deck.pop();
                    card.location = 'playerHand';
                    CardRoster.move(card.id, 'deck', 'playerHand');
                    STATE.playerHand.push(card);
                }

                BalatroGame.renderHand();
                BalatroGame.setControls();
                BalatroGame.updateHUD();
            },

            renderHand: () => {
                const container = document.getElementById('player-hand');
                container.innerHTML = '';
                STATE.playerHand.forEach(card => {
                    card.faceUp = true;
                    const el = card.render(true); // selectable
                    if (card.selected) el.classList.add('selected');
                    el.style.transform = card.selected ? 'translateY(-15px)' : '';
                    el.onclick = () => {
                        card.selected = !card.selected;
                        BalatroGame.renderHand();
                        BalatroGame.updateHandPreview();
                    };
                    container.appendChild(el);
                });
                animateDeal();
            },

            renderHUD: () => {
                let hud = document.getElementById('balatro-hud');
                if (!hud) {
                    hud = document.createElement('div');
                    hud.id = 'balatro-hud';
                    hud.className = 'balatro-hud';
                    document.body.appendChild(hud);
                }
                hud.style.display = 'block';
            },

            updateHUD: () => {
                const bs = BalatroGame.state;
                const hud = document.getElementById('balatro-hud');
                if (!hud) return;

                hud.innerHTML = `
                    <h4>Ante ${bs.ante} - ${bs.blind.charAt(0).toUpperCase() + bs.blind.slice(1)} Blind</h4>
                    <div class="balatro-stat">
                        <span class="label">Score:</span>
                        <span class="value">${bs.currentScore} / ${bs.blindScore}</span>
                    </div>
                    <div class="balatro-stat">
                        <span class="label">Hands:</span>
                        <span class="value">${bs.handsLeft}</span>
                    </div>
                    <div class="balatro-stat">
                        <span class="label">Discards:</span>
                        <span class="value">${bs.discardsLeft}</span>
                    </div>
                    <div class="balatro-stat">
                        <span class="label">Money:</span>
                        <span class="value">$${bs.money}</span>
                    </div>
                    <div class="joker-slots">
                        ${bs.jokers.map(j => j.render().outerHTML).join('')}
                        ${bs.jokers.length < bs.maxJokers ? '<div class="joker-slot-empty">Empty</div>' : ''}
                    </div>
                    <button class="btn btn-secondary" onclick="CardRoster.toggle()" style="width:100%;margin-top:10px;padding:5px;">Card Roster</button>
                `;
            },

            updateHandPreview: () => {
                const selected = STATE.playerHand.filter(c => c.selected);
                let preview = document.getElementById('hand-preview');

                if (selected.length === 0) {
                    if (preview) preview.remove();
                    return;
                }

                const { handName, chips, mult } = BalatroGame.evaluateHand(selected);

                if (!preview) {
                    preview = document.createElement('div');
                    preview.id = 'hand-preview';
                    preview.className = 'hand-score-preview';
                    document.getElementById('player-hand').appendChild(preview);
                }

                preview.innerHTML = `${handName}: <span class="chips">${chips}</span> √ó <span class="mult">${mult}</span> = ${chips * mult}`;
            },

            evaluateHand: (cards) => {
                if (cards.length === 0) return { handName: 'None', chips: 0, mult: 0, scoringCards: [] };

                const ranks = cards.map(c => c.pokerValue).sort((a, b) => b - a);
                const suits = cards.map(c => c.suit);
                const rankCounts = {};
                ranks.forEach(r => rankCounts[r] = (rankCounts[r] || 0) + 1);
                const counts = Object.values(rankCounts).sort((a, b) => b - a);

                const isFlush = suits.every(s => s === suits[0]) && cards.length >= 5;
                const uniqueRanks = [...new Set(ranks)].sort((a, b) => a - b);
                const isStraight = uniqueRanks.length >= 5 &&
                    (uniqueRanks[uniqueRanks.length - 1] - uniqueRanks[0] === 4 ||
                     (uniqueRanks.includes(14) && uniqueRanks.includes(2) && uniqueRanks.includes(3) && uniqueRanks.includes(4) && uniqueRanks.includes(5)));

                let handName = 'High Card';
                let scoringCards = [cards[0]]; // Just highest card for high card

                if (counts[0] === 5) {
                    handName = isFlush ? 'Flush Five' : 'Five of a Kind';
                    scoringCards = cards;
                } else if (counts[0] === 4) {
                    handName = 'Four of a Kind';
                    const quadRank = Object.keys(rankCounts).find(r => rankCounts[r] === 4);
                    scoringCards = cards.filter(c => c.pokerValue == quadRank);
                } else if (counts[0] === 3 && counts[1] === 2) {
                    handName = isFlush ? 'Flush House' : 'Full House';
                    scoringCards = cards;
                } else if (isFlush && isStraight) {
                    const isRoyal = uniqueRanks.includes(14) && uniqueRanks.includes(13);
                    handName = isRoyal ? 'Royal Flush' : 'Straight Flush';
                    scoringCards = cards;
                } else if (isFlush) {
                    handName = 'Flush';
                    scoringCards = cards;
                } else if (isStraight) {
                    handName = 'Straight';
                    scoringCards = cards;
                } else if (counts[0] === 3) {
                    handName = 'Three of a Kind';
                    const tripRank = Object.keys(rankCounts).find(r => rankCounts[r] === 3);
                    scoringCards = cards.filter(c => c.pokerValue == tripRank);
                } else if (counts[0] === 2 && counts[1] === 2) {
                    handName = 'Two Pair';
                    const pairRanks = Object.keys(rankCounts).filter(r => rankCounts[r] === 2);
                    scoringCards = cards.filter(c => pairRanks.includes(String(c.pokerValue)));
                } else if (counts[0] === 2) {
                    handName = 'Pair';
                    const pairRank = Object.keys(rankCounts).find(r => rankCounts[r] === 2);
                    scoringCards = cards.filter(c => c.pokerValue == pairRank);
                }

                const handData = BalatroGame.state.handLevels[handName];
                let baseChips = handData.chips + (handData.level - 1) * 10;
                let baseMult = handData.mult + (handData.level - 1);

                // Add chip values from scoring cards
                scoringCards.forEach(c => {
                    baseChips += c.balatroChips;
                    if (c.enhancement === 'mult') baseMult += 4;
                });

                // Apply joker effects
                let score = { chips: baseChips, mult: baseMult };
                BalatroGame.state.jokers.forEach((joker, idx) => {
                    score = joker.effect(scoringCards, score, BalatroGame.state, BalatroGame.state.jokers, idx);
                });

                // Edition bonuses
                scoringCards.forEach(c => {
                    if (c.edition === 'foil') score.chips += 50;
                    if (c.edition === 'holo') score.mult += 10;
                    if (c.edition === 'poly') score.mult *= 1.5;
                });

                return { handName, chips: Math.floor(score.chips), mult: Math.floor(score.mult), scoringCards };
            },

            playHand: () => {
                const selected = STATE.playerHand.filter(c => c.selected);
                if (selected.length === 0 || selected.length > 5) {
                    showMessage('Select 1-5 cards to play');
                    return;
                }
                if (BalatroGame.state.handsLeft <= 0) {
                    showMessage('No hands remaining!');
                    return;
                }

                const { handName, chips, mult, scoringCards } = BalatroGame.evaluateHand(selected);
                const totalScore = chips * mult;
                BalatroGame.state.currentScore += totalScore;
                BalatroGame.state.handsLeft--;

                // Animate and show score
                showMessage(`${handName}! ${chips} √ó ${mult} = +${totalScore}`);
                updateDealer(`"${handName}! That's ${totalScore} points!"`);

                // Move played cards to discard
                selected.forEach(card => {
                    const idx = STATE.playerHand.indexOf(card);
                    if (idx > -1) STATE.playerHand.splice(idx, 1);
                    CardRoster.move(card.id, 'playerHand', 'discarded');
                    card.selected = false;
                });

                // Draw new cards
                const toDraw = Math.min(selected.length, STATE.deck.length);
                for (let i = 0; i < toDraw; i++) {
                    const card = STATE.deck.pop();
                    card.location = 'playerHand';
                    CardRoster.move(card.id, 'deck', 'playerHand');
                    STATE.playerHand.push(card);
                }

                BalatroGame.renderHand();
                BalatroGame.updateHUD();
                CardRoster.renderUI();

                // Check win/lose
                setTimeout(() => BalatroGame.checkRoundEnd(), 500);
            },

            discardCards: () => {
                const selected = STATE.playerHand.filter(c => c.selected);
                if (selected.length === 0 || selected.length > 5) {
                    showMessage('Select 1-5 cards to discard');
                    return;
                }
                if (BalatroGame.state.discardsLeft <= 0) {
                    showMessage('No discards remaining!');
                    return;
                }

                BalatroGame.state.discardsLeft--;

                // Move discarded cards
                selected.forEach(card => {
                    const idx = STATE.playerHand.indexOf(card);
                    if (idx > -1) STATE.playerHand.splice(idx, 1);
                    CardRoster.move(card.id, 'playerHand', 'discarded');
                    card.selected = false;
                });

                // Draw new cards
                const toDraw = Math.min(selected.length, STATE.deck.length);
                for (let i = 0; i < toDraw; i++) {
                    const card = STATE.deck.pop();
                    card.location = 'playerHand';
                    CardRoster.move(card.id, 'deck', 'playerHand');
                    STATE.playerHand.push(card);
                }

                showMessage(`Discarded ${selected.length} cards`);
                BalatroGame.renderHand();
                BalatroGame.updateHUD();
                CardRoster.renderUI();
            },

            checkRoundEnd: () => {
                const bs = BalatroGame.state;
                if (bs.currentScore >= bs.blindScore) {
                    // Won the blind!
                    ScoreTracker.playerWin();
                    const reward = bs.blind === 'small' ? 3 : bs.blind === 'big' ? 4 : 5;
                    bs.money += reward;
                    showMessage(`Blind defeated! +$${reward}`);
                    updateDealer(`"Excellent! You beat the ${bs.blind} blind!"`);

                    setTimeout(() => {
                        // Progress to next blind
                        if (bs.blind === 'small') {
                            bs.blind = 'big';
                        } else if (bs.blind === 'big') {
                            bs.blind = 'boss';
                        } else {
                            // Beat boss - next ante
                            bs.ante++;
                            bs.blind = 'small';
                            bs.money += 5; // Ante bonus
                            showMessage(`Ante ${bs.ante}! +$5 bonus`);
                        }
                        BalatroGame.openShop();
                    }, 1000);
                } else if (bs.handsLeft <= 0) {
                    // Lost the round
                    ScoreTracker.dealerWin();
                    showMessage('GAME OVER - No hands remaining');
                    updateDealer('"Tough luck. The blind got you this time."');
                    STATE.autoplay = false;
                    Autoplay.updateIndicator();
                    setControls([
                        { text: 'Try Again', action: () => BalatroGame.init(), primary: true },
                        { text: 'Menu', action: returnToMenu }
                    ]);
                }
            },

            openShop: () => {
                const bs = BalatroGame.state;
                updateDealer('"Welcome to the shop! Spend your earnings wisely."');

                // Generate shop items
                const shopJokers = [];
                for (let i = 0; i < 3; i++) {
                    const available = JOKER_LIBRARY.filter(j => !bs.jokers.some(owned => owned.id === j.id));
                    if (available.length > 0) {
                        shopJokers.push(available[Math.floor(Math.random() * available.length)]);
                    }
                }

                // Render shop in dealer hand area
                const dContainer = document.getElementById('dealer-hand');
                dContainer.innerHTML = '<div style="text-align:center;color:var(--accent);margin-bottom:10px;">SHOP</div>';

                shopJokers.forEach(joker => {
                    const el = joker.render();
                    el.innerHTML += `<div style="font-size:0.6rem;margin-top:4px;">$${joker.cost}</div>`;
                    el.onclick = () => {
                        if (bs.money >= joker.cost && bs.jokers.length < bs.maxJokers) {
                            bs.money -= joker.cost;
                            bs.jokers.push(joker);
                            el.remove();
                            BalatroGame.updateHUD();
                            showMessage(`Bought ${joker.name}!`);
                        } else if (bs.money < joker.cost) {
                            showMessage('Not enough money!');
                        } else {
                            showMessage('Joker slots full!');
                        }
                    };
                    dContainer.appendChild(el);
                });

                // Clear player hand
                document.getElementById('player-hand').innerHTML = '';

                setControls([
                    { text: 'Next Round', action: () => BalatroGame.nextRound(), primary: true },
                    { text: STATE.autoplay ? 'Stop Auto' : 'Autoplay', action: Autoplay.toggle, primary: false, autoplay: true }
                ]);
            },

            nextRound: () => {
                // Reshuffle deck
                CardRoster.init();
                STATE.deck = [];
                for (let s of SUITS) {
                    for (let r of RANKS) {
                        const card = new Card(s, r);
                        STATE.deck.push(card);
                        CardRoster.register(card);
                    }
                }
                STATE.deck = shuffle(STATE.deck);

                document.getElementById('dealer-hand').innerHTML = '';
                BalatroGame.startRound();
            },

            setControls: () => {
                const bs = BalatroGame.state;
                setControls([
                    { text: 'Play Hand', action: () => BalatroGame.playHand(), primary: true },
                    { text: `Discard (${bs.discardsLeft})`, action: () => BalatroGame.discardCards(), primary: false },
                    { text: STATE.autoplay ? 'Stop Auto' : 'Autoplay', action: Autoplay.toggle, primary: false, autoplay: true },
                    { text: 'Sort', action: () => BalatroGame.sortHand(), primary: false },
                    { text: 'Menu', action: returnToMenu }
                ]);
            },

            sortHand: () => {
                STATE.playerHand.sort((a, b) => b.pokerValue - a.pokerValue);
                BalatroGame.renderHand();
            }
        };

        // --- Main ---
        function startGame(gameType) {
            document.getElementById('game-menu').style.display = 'none';
            STATE.game = gameType;

            // Hide Balatro HUD when switching games
            const balatroHud = document.getElementById('balatro-hud');
            if (balatroHud) balatroHud.style.display = 'none';
            CardRoster.hide();

            if (gameType === 'war') WarGame.init();
            if (gameType === 'blackjack') BlackjackGame.init();
            if (gameType === 'poker') PokerGame.init();
            if (gameType === 'balatro') BalatroGame.init();
        }

        // Initialize
        DataManager.autoLoad();
        
        // Auto-save on chip changes (simple hook)
        const originalUpdateDealer = updateDealer;
        updateDealer = (msg) => {
            originalUpdateDealer(msg);
            DataManager.autoSave();
        };


    </script>
</body>
</html>