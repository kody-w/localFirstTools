<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Synesthesia Engine - Bidirectional Art & Music Generator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #0a0a0a;
            color: #ffffff;
            overflow: hidden;
            height: 100vh;
        }

        #app {
            display: flex;
            height: 100vh;
            width: 100vw;
        }

        #canvas-container {
            flex: 1;
            position: relative;
            background: #000;
            overflow: hidden;
        }

        #main-canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: crosshair;
            touch-action: none;
        }

        #controls-panel {
            width: 350px;
            background: #1a1a1a;
            border-left: 2px solid #333;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            transition: transform 0.3s ease;
        }

        #controls-panel.collapsed {
            transform: translateX(350px);
        }

        .panel-section {
            padding: 20px;
            border-bottom: 1px solid #333;
        }

        .panel-section h2 {
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 15px;
            color: #888;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            font-size: 12px;
            margin-bottom: 5px;
            color: #aaa;
        }

        .control-group select,
        .control-group input[type="range"],
        .control-group input[type="number"] {
            width: 100%;
            padding: 8px;
            background: #2a2a2a;
            border: 1px solid #444;
            color: #fff;
            border-radius: 4px;
            font-size: 12px;
        }

        .control-group input[type="range"] {
            padding: 0;
        }

        .btn {
            padding: 10px 15px;
            background: #4a9eff;
            border: none;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            transition: background 0.2s;
            width: 100%;
            margin-bottom: 8px;
        }

        .btn:hover {
            background: #3a8eef;
        }

        .btn:active {
            transform: scale(0.98);
        }

        .btn.danger {
            background: #ff4a4a;
        }

        .btn.danger:hover {
            background: #ef3a3a;
        }

        .btn.success {
            background: #4aff4a;
            color: #000;
        }

        .btn.success:hover {
            background: #3aef3a;
        }

        .btn.recording {
            background: #ff2a2a;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .btn-group {
            display: flex;
            gap: 8px;
        }

        .btn-group .btn {
            flex: 1;
            margin-bottom: 0;
        }

        #toggle-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: rgba(26, 26, 26, 0.95);
            border: 1px solid #444;
            border-radius: 4px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 20px;
            transition: transform 0.3s ease;
        }

        #toggle-panel:hover {
            transform: scale(1.1);
        }

        #status-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 350px;
            background: rgba(26, 26, 26, 0.95);
            padding: 10px 20px;
            border-top: 1px solid #333;
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            font-family: 'Courier New', monospace;
            color: #888;
            transition: right 0.3s ease;
        }

        #status-bar.full-width {
            right: 0;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #4aff4a;
        }

        .status-indicator.inactive {
            background: #888;
        }

        #visualizer-container {
            position: absolute;
            bottom: 50px;
            left: 20px;
            width: 300px;
            height: 100px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #444;
            border-radius: 4px;
            padding: 10px;
        }

        #waveform-canvas,
        #spectrum-canvas {
            width: 100%;
            height: 40px;
            display: block;
            margin-bottom: 5px;
        }

        .color-swatch {
            display: inline-block;
            width: 30px;
            height: 30px;
            border-radius: 4px;
            border: 2px solid #444;
            cursor: pointer;
            margin-right: 5px;
            transition: transform 0.2s;
        }

        .color-swatch:hover {
            transform: scale(1.1);
            border-color: #4a9eff;
        }

        .color-swatch.active {
            border-color: #4aff4a;
            box-shadow: 0 0 10px #4aff4a;
        }

        .preset-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .preset-card {
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }

        .preset-card:hover {
            border-color: #4a9eff;
            transform: translateY(-2px);
        }

        .preset-card.active {
            border-color: #4aff4a;
            background: #2a4a2a;
        }

        .preset-icon {
            font-size: 24px;
            margin-bottom: 5px;
        }

        .preset-name {
            font-size: 11px;
            font-weight: 600;
        }

        #tutorial-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            z-index: 2000;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        #tutorial-overlay.active {
            display: flex;
        }

        .tutorial-content {
            background: #1a1a1a;
            border: 2px solid #4a9eff;
            border-radius: 8px;
            padding: 30px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .tutorial-content h1 {
            color: #4a9eff;
            margin-bottom: 20px;
        }

        .tutorial-content p {
            line-height: 1.6;
            margin-bottom: 15px;
            color: #ccc;
        }

        .tutorial-content ul {
            margin-left: 20px;
            margin-bottom: 15px;
        }

        .tutorial-content li {
            margin-bottom: 8px;
            color: #ccc;
        }

        .keyboard-shortcut {
            display: inline-block;
            background: #2a2a2a;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            border: 1px solid #444;
        }

        #recording-indicator {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(255, 42, 42, 0.95);
            padding: 10px 20px;
            border-radius: 4px;
            font-weight: 600;
            display: none;
            align-items: center;
            gap: 10px;
            z-index: 1000;
        }

        #recording-indicator.active {
            display: flex;
        }

        .rec-dot {
            width: 12px;
            height: 12px;
            background: white;
            border-radius: 50%;
            animation: pulse 1s infinite;
        }

        @media (max-width: 768px) {
            #controls-panel {
                position: fixed;
                top: 0;
                right: 0;
                bottom: 0;
                width: 100%;
                max-width: 350px;
                z-index: 1500;
            }

            #status-bar {
                right: 0;
                font-size: 9px;
                padding: 5px 10px;
            }

            #visualizer-container {
                width: 200px;
                height: 80px;
            }
        }

        .tooltip {
            position: relative;
            display: inline-block;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 200px;
            background-color: #333;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 8px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -100px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 11px;
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        #particle-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .slider-value {
            display: inline-block;
            float: right;
            font-size: 11px;
            color: #4a9eff;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <div id="app">
        <div id="canvas-container">
            <canvas id="main-canvas"></canvas>
            <canvas id="particle-canvas"></canvas>

            <div id="visualizer-container">
                <canvas id="waveform-canvas"></canvas>
                <canvas id="spectrum-canvas"></canvas>
            </div>
        </div>

        <div id="controls-panel">
            <div class="panel-section">
                <h2>Synesthesia Mode</h2>
                <div class="preset-grid">
                    <div class="preset-card active" data-mode="classical" title="Pitch‚ÜíHue, Volume‚ÜíBrightness">
                        <div class="preset-icon">üé®</div>
                        <div class="preset-name">Classical</div>
                    </div>
                    <div class="preset-card" data-mode="kandinsky" title="Abstract shapes respond to tone">
                        <div class="preset-icon">üî∑</div>
                        <div class="preset-name">Kandinsky</div>
                    </div>
                    <div class="preset-card" data-mode="spectrum" title="Frequency bands to visual layers">
                        <div class="preset-icon">üåà</div>
                        <div class="preset-name">Spectrum</div>
                    </div>
                    <div class="preset-card" data-mode="particle" title="Sound creates particle explosions">
                        <div class="preset-icon">‚ú®</div>
                        <div class="preset-name">Particle</div>
                    </div>
                </div>
            </div>

            <div class="panel-section">
                <h2>Drawing Controls</h2>
                <div class="control-group">
                    <label>Brush Size <span class="slider-value" id="brush-size-value">10</span></label>
                    <input type="range" id="brush-size" min="1" max="50" value="10">
                </div>
                <div class="control-group">
                    <label>Color Palette</label>
                    <div id="color-palette">
                        <span class="color-swatch active" style="background: #ff4444" data-color="#ff4444"></span>
                        <span class="color-swatch" style="background: #ff8844" data-color="#ff8844"></span>
                        <span class="color-swatch" style="background: #ffdd44" data-color="#ffdd44"></span>
                        <span class="color-swatch" style="background: #44ff44" data-color="#44ff44"></span>
                        <span class="color-swatch" style="background: #44ddff" data-color="#44ddff"></span>
                        <span class="color-swatch" style="background: #4444ff" data-color="#4444ff"></span>
                        <span class="color-swatch" style="background: #dd44ff" data-color="#dd44ff"></span>
                    </div>
                </div>
                <div class="control-group">
                    <label>Draw Mode</label>
                    <select id="draw-mode">
                        <option value="pen">Pen</option>
                        <option value="spray">Spray Paint</option>
                        <option value="geometric">Geometric Shapes</option>
                        <option value="symmetry">Symmetry (4-way)</option>
                    </select>
                </div>
            </div>

            <div class="panel-section">
                <h2>Audio Controls</h2>
                <div class="control-group">
                    <label>Synthesis Type</label>
                    <select id="synth-type">
                        <option value="sine">Sine (Pure Tone)</option>
                        <option value="triangle">Triangle (Soft)</option>
                        <option value="sawtooth">Sawtooth (Bright)</option>
                        <option value="square">Square (Retro)</option>
                        <option value="fm">FM Synthesis</option>
                        <option value="additive">Additive (Harmonics)</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Master Volume <span class="slider-value" id="volume-value">70</span></label>
                    <input type="range" id="master-volume" min="0" max="100" value="70">
                </div>
                <div class="control-group">
                    <label>Reverb <span class="slider-value" id="reverb-value">30</span></label>
                    <input type="range" id="reverb-amount" min="0" max="100" value="30">
                </div>
                <div class="control-group">
                    <label>Delay <span class="slider-value" id="delay-value">0</span></label>
                    <input type="range" id="delay-amount" min="0" max="100" value="0">
                </div>
            </div>

            <div class="panel-section">
                <h2>Input Sources</h2>
                <button class="btn" id="enable-midi">üéπ Enable MIDI Input</button>
                <button class="btn" id="enable-mic">üé§ Enable Microphone</button>
                <div class="control-group">
                    <label>Microphone Sensitivity <span class="slider-value" id="mic-sens-value">50</span></label>
                    <input type="range" id="mic-sensitivity" min="1" max="100" value="50">
                </div>
            </div>

            <div class="panel-section">
                <h2>Recording & Export</h2>
                <button class="btn success" id="start-recording">‚è∫ Start Recording</button>
                <div class="btn-group">
                    <button class="btn" id="export-video">üìπ Video</button>
                    <button class="btn" id="export-audio">üîä Audio</button>
                </div>
                <button class="btn" id="export-frames">üñº PNG Sequence</button>
                <button class="btn" id="export-composition">üíæ Save Composition</button>
            </div>

            <div class="panel-section">
                <h2>Canvas Actions</h2>
                <div class="btn-group">
                    <button class="btn" id="undo-btn">‚Ü∂ Undo</button>
                    <button class="btn" id="redo-btn">‚Ü∑ Redo</button>
                </div>
                <button class="btn danger" id="clear-canvas">üóë Clear Canvas</button>
                <button class="btn" id="show-tutorial">‚ùì Tutorial</button>
            </div>

            <div class="panel-section">
                <h2>Data Management</h2>
                <button class="btn" id="export-data">üì§ Export Data</button>
                <button class="btn" id="import-data">üì• Import Data</button>
                <input type="file" id="import-file" accept=".json" style="display: none;">
            </div>
        </div>
    </div>

    <div id="toggle-panel" title="Toggle Controls Panel">‚ò∞</div>

    <div id="recording-indicator">
        <span class="rec-dot"></span>
        <span id="recording-time">00:00</span>
    </div>

    <div id="status-bar">
        <div class="status-item">
            <span class="status-indicator" id="audio-status"></span>
            <span>Audio Engine</span>
        </div>
        <div class="status-item">
            <span id="mode-display">Drawing Mode</span>
        </div>
        <div class="status-item">
            <span id="fps-counter">60 FPS</span>
        </div>
        <div class="status-item">
            <span id="midi-status">MIDI: Disconnected</span>
        </div>
        <div class="status-item">
            <span id="mic-status">Mic: Off</span>
        </div>
    </div>

    <div id="tutorial-overlay">
        <div class="tutorial-content">
            <h1>Welcome to the Synesthesia Engine</h1>
            <p>This is a bidirectional art and music generator where drawing creates sound and sound creates visuals.</p>

            <h2>What is Synesthesia?</h2>
            <p>Synesthesia is a neurological phenomenon where stimulation of one sense triggers experiences in another sense. Some people naturally "see" colors when they hear music, or "hear" sounds when they see colors.</p>

            <h2>How to Use:</h2>
            <ul>
                <li><strong>Draw to Create Sound:</strong> Move your mouse/finger across the canvas to draw. Different colors create different pitches, speed affects tempo, and position affects volume.</li>
                <li><strong>Sound to Visual:</strong> Enable MIDI or microphone input to generate visuals from sound. Play music and watch it paint on the canvas!</li>
                <li><strong>Choose a Mode:</strong> Try different synesthesia mappings (Classical, Kandinsky, Spectrum, Particle) for unique experiences.</li>
                <li><strong>Record & Export:</strong> Capture your audiovisual performances as video, audio, or image sequences.</li>
            </ul>

            <h2>Keyboard Shortcuts:</h2>
            <ul>
                <li><span class="keyboard-shortcut">Space</span> - Clear canvas</li>
                <li><span class="keyboard-shortcut">Ctrl+Z</span> - Undo</li>
                <li><span class="keyboard-shortcut">Ctrl+Y</span> - Redo</li>
                <li><span class="keyboard-shortcut">R</span> - Start/Stop recording</li>
                <li><span class="keyboard-shortcut">M</span> - Toggle microphone</li>
                <li><span class="keyboard-shortcut">Tab</span> - Toggle controls panel</li>
                <li><span class="keyboard-shortcut">1-4</span> - Switch synesthesia modes</li>
            </ul>

            <h2>Tips for Best Results:</h2>
            <ul>
                <li>Start with the Classical mode to understand the basic pitch-color relationship</li>
                <li>Try drawing slowly vs. quickly to hear how speed affects the sound</li>
                <li>Use the Particle mode for explosive visual effects</li>
                <li>Enable MIDI and play your favorite instrument to see music visualized</li>
                <li>Experiment with different synthesis types for varied timbres</li>
            </ul>

            <button class="btn" onclick="closeTutorial()">Let's Create!</button>
        </div>
    </div>

    <script>
        // ========================================
        // CORE APPLICATION STATE
        // ========================================
        const APP_NAME = 'synesthesia-engine';

        const state = {
            mode: 'classical',
            drawing: false,
            recording: false,
            recordingStartTime: 0,
            currentColor: '#ff4444',
            brushSize: 10,
            drawMode: 'pen',
            synthType: 'sine',
            volume: 0.7,
            reverb: 0.3,
            delay: 0,
            micEnabled: false,
            micSensitivity: 0.5,
            history: [],
            historyIndex: -1,
            audioNodes: [],
            particles: [],
            visualEvents: [],
            audioEvents: [],
            recordedChunks: [],
            activeNotes: new Map(),
            midiAccess: null
        };

        // Load saved state
        try {
            const saved = localStorage.getItem(APP_NAME);
            if (saved) {
                const parsed = JSON.parse(saved);
                Object.assign(state, parsed);
            }
        } catch (e) {
            console.error('Failed to load saved state:', e);
        }

        // ========================================
        // CANVAS & CONTEXT SETUP
        // ========================================
        const canvas = document.getElementById('main-canvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        const particleCanvas = document.getElementById('particle-canvas');
        const particleCtx = particleCanvas.getContext('2d');
        const waveformCanvas = document.getElementById('waveform-canvas');
        const waveformCtx = waveformCanvas.getContext('2d');
        const spectrumCanvas = document.getElementById('spectrum-canvas');
        const spectrumCtx = spectrumCanvas.getContext('2d');

        function resizeCanvases() {
            const container = document.getElementById('canvas-container');
            const rect = container.getBoundingClientRect();

            canvas.width = rect.width;
            canvas.height = rect.height;
            particleCanvas.width = rect.width;
            particleCanvas.height = rect.height;

            waveformCanvas.width = 280;
            waveformCanvas.height = 40;
            spectrumCanvas.width = 280;
            spectrumCanvas.height = 40;

            // Redraw canvas from history
            redrawCanvas();
        }

        // ========================================
        // AUDIO ENGINE
        // ========================================
        const AudioEngine = {
            context: null,
            masterGain: null,
            analyser: null,
            convolver: null,
            delayNode: null,
            delayFeedback: null,
            compressor: null,

            init() {
                this.context = new (window.AudioContext || window.webkitAudioContext)();

                // Master gain
                this.masterGain = this.context.createGain();
                this.masterGain.gain.value = state.volume;

                // Analyser for visualization
                this.analyser = this.context.createAnalyser();
                this.analyser.fftSize = 2048;

                // Compressor for dynamics
                this.compressor = this.context.createDynamicsCompressor();

                // Delay effect
                this.delayNode = this.context.createDelay(2.0);
                this.delayFeedback = this.context.createGain();
                this.delayNode.delayTime.value = 0.3;
                this.delayFeedback.gain.value = 0.3;

                // Connect delay feedback loop
                this.delayNode.connect(this.delayFeedback);
                this.delayFeedback.connect(this.delayNode);

                // Create convolver for reverb
                this.createReverb();

                // Audio routing
                this.masterGain.connect(this.analyser);
                this.analyser.connect(this.compressor);
                this.compressor.connect(this.context.destination);

                // Update status
                document.getElementById('audio-status').classList.remove('inactive');
            },

            createReverb() {
                this.convolver = this.context.createConvolver();
                const rate = this.context.sampleRate;
                const length = rate * 2; // 2 second reverb
                const impulse = this.context.createBuffer(2, length, rate);

                for (let channel = 0; channel < 2; channel++) {
                    const channelData = impulse.getChannelData(channel);
                    for (let i = 0; i < length; i++) {
                        channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2);
                    }
                }

                this.convolver.buffer = impulse;
            },

            playNote(frequency, duration = 0.5, velocity = 1) {
                if (!this.context) this.init();

                const now = this.context.currentTime;
                const noteId = `${frequency}-${now}`;

                // Create oscillator
                const osc = this.context.createOscillator();
                const gain = this.context.createGain();
                const reverbGain = this.context.createGain();
                const delayGain = this.context.createGain();

                // Set oscillator type based on synth type
                switch(state.synthType) {
                    case 'fm':
                        osc.type = 'sine';
                        const modulator = this.context.createOscillator();
                        const modGain = this.context.createGain();
                        modulator.frequency.value = frequency * 2;
                        modGain.gain.value = 100;
                        modulator.connect(modGain);
                        modGain.connect(osc.frequency);
                        modulator.start(now);
                        modulator.stop(now + duration);
                        break;
                    case 'additive':
                        osc.type = 'sine';
                        // Add harmonics
                        for (let i = 2; i <= 5; i++) {
                            const harmonic = this.context.createOscillator();
                            const harmGain = this.context.createGain();
                            harmonic.frequency.value = frequency * i;
                            harmonic.type = 'sine';
                            harmGain.gain.value = velocity * 0.3 / i;
                            harmonic.connect(harmGain);
                            harmGain.connect(gain);
                            harmonic.start(now);
                            harmonic.stop(now + duration);
                        }
                        break;
                    default:
                        osc.type = state.synthType;
                }

                osc.frequency.value = frequency;

                // Envelope
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(velocity * 0.3, now + 0.01);
                gain.gain.exponentialRampToValueAtTime(velocity * 0.2, now + duration * 0.3);
                gain.gain.exponentialRampToValueAtTime(0.001, now + duration);

                // Connect audio graph
                osc.connect(gain);

                // Dry signal
                gain.connect(this.masterGain);

                // Reverb send
                reverbGain.gain.value = state.reverb;
                gain.connect(reverbGain);
                reverbGain.connect(this.convolver);
                this.convolver.connect(this.masterGain);

                // Delay send
                delayGain.gain.value = state.delay;
                gain.connect(delayGain);
                delayGain.connect(this.delayNode);
                this.delayNode.connect(this.masterGain);

                // Start and stop
                osc.start(now);
                osc.stop(now + duration);

                // Cleanup
                setTimeout(() => {
                    osc.disconnect();
                    gain.disconnect();
                    reverbGain.disconnect();
                    delayGain.disconnect();
                }, (duration + 0.1) * 1000);

                return noteId;
            },

            setVolume(value) {
                if (this.masterGain) {
                    this.masterGain.gain.value = value;
                }
            },

            setReverb(value) {
                state.reverb = value;
            },

            setDelay(value) {
                state.delay = value;
            },

            getAnalyserData() {
                if (!this.analyser) return { waveform: new Uint8Array(128), spectrum: new Uint8Array(128) };

                const waveform = new Uint8Array(this.analyser.fftSize);
                const spectrum = new Uint8Array(this.analyser.frequencyBinCount);

                this.analyser.getByteTimeDomainData(waveform);
                this.analyser.getByteFrequencyData(spectrum);

                return { waveform, spectrum };
            }
        };

        // ========================================
        // SYNESTHESIA MAPPINGS
        // ========================================
        const SynesthesiaEngine = {
            // Convert color to frequency (Classical mode)
            colorToFrequency(color) {
                const rgb = this.hexToRgb(color);
                const hue = this.rgbToHue(rgb);
                // Map hue (0-360) to frequency (200-2000 Hz)
                // Red = low, Violet = high
                const freq = 200 + (hue / 360) * 1800;
                return freq;
            },

            // Convert frequency to color
            frequencyToColor(frequency) {
                // Map frequency (20-20000 Hz) to hue (0-360)
                const normalizedFreq = Math.log(frequency) / Math.log(20000);
                const hue = normalizedFreq * 360;
                return this.hslToHex(hue, 80, 50);
            },

            // Convert position to frequency
            positionToFrequency(x, y, width, height) {
                // X axis = pitch (left to right = low to high)
                // Y axis = volume (top to bottom = loud to quiet)
                const freq = 200 + (x / width) * 1800;
                const velocity = 1 - (y / height);
                return { frequency: freq, velocity: Math.max(0.1, velocity) };
            },

            // Convert speed to duration
            speedToDuration(speed) {
                // Faster strokes = shorter notes
                return Math.max(0.1, Math.min(1, 1 / (speed + 0.5)));
            },

            // Helper functions
            hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : { r: 255, g: 0, 0 };
            },

            rgbToHue(rgb) {
                const r = rgb.r / 255;
                const g = rgb.g / 255;
                const b = rgb.b / 255;
                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                let h = 0;

                if (max !== min) {
                    const d = max - min;
                    switch (max) {
                        case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                        case g: h = ((b - r) / d + 2) / 6; break;
                        case b: h = ((r - g) / d + 4) / 6; break;
                    }
                }

                return h * 360;
            },

            hslToHex(h, s, l) {
                s /= 100;
                l /= 100;
                const a = s * Math.min(l, 1 - l);
                const f = n => {
                    const k = (n + h / 30) % 12;
                    const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
                    return Math.round(255 * color).toString(16).padStart(2, '0');
                };
                return `#${f(0)}${f(8)}${f(4)}`;
            }
        };

        // ========================================
        // DRAWING ENGINE
        // ========================================
        let lastX = 0, lastY = 0;
        let lastDrawTime = Date.now();

        function startDrawing(e) {
            state.drawing = true;
            const pos = getMousePos(e);
            lastX = pos.x;
            lastY = pos.y;
            lastDrawTime = Date.now();

            // Save state for undo
            saveHistoryState();
        }

        function draw(e) {
            if (!state.drawing) return;

            const pos = getMousePos(e);
            const currentTime = Date.now();
            const timeDelta = (currentTime - lastDrawTime) / 1000;
            const distance = Math.sqrt(Math.pow(pos.x - lastX, 2) + Math.pow(pos.y - lastY, 2));
            const speed = distance / Math.max(timeDelta, 0.001);

            // Draw based on mode
            switch(state.drawMode) {
                case 'pen':
                    drawLine(lastX, lastY, pos.x, pos.y, state.currentColor, state.brushSize);
                    break;
                case 'spray':
                    drawSpray(pos.x, pos.y, state.currentColor, state.brushSize);
                    break;
                case 'geometric':
                    drawCircle(pos.x, pos.y, state.currentColor, state.brushSize);
                    break;
                case 'symmetry':
                    drawSymmetry(pos.x, pos.y, state.currentColor, state.brushSize);
                    break;
            }

            // Generate sound based on synesthesia mode
            generateSoundFromDrawing(pos.x, pos.y, speed, state.currentColor);

            // Create particles in particle mode
            if (state.mode === 'particle') {
                createParticles(pos.x, pos.y, state.currentColor, 10);
            }

            lastX = pos.x;
            lastY = pos.y;
            lastDrawTime = currentTime;
        }

        function stopDrawing() {
            state.drawing = false;
        }

        function drawLine(x1, y1, x2, y2, color, size) {
            ctx.strokeStyle = color;
            ctx.lineWidth = size;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
        }

        function drawSpray(x, y, color, size) {
            ctx.fillStyle = color;
            for (let i = 0; i < 20; i++) {
                const offsetX = (Math.random() - 0.5) * size * 2;
                const offsetY = (Math.random() - 0.5) * size * 2;
                ctx.fillRect(x + offsetX, y + offsetY, 2, 2);
            }
        }

        function drawCircle(x, y, color, size) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x, y, size / 2, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawSymmetry(x, y, color, size) {
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;

            // 4-way symmetry
            const points = [
                { x, y },
                { x: cx + (cx - x), y },
                { x, y: cy + (cy - y) },
                { x: cx + (cx - x), y: cy + (cy - y) }
            ];

            points.forEach(p => {
                drawCircle(p.x, p.y, color, size);
            });
        }

        function generateSoundFromDrawing(x, y, speed, color) {
            const { frequency, velocity } = SynesthesiaEngine.positionToFrequency(
                x, y, canvas.width, canvas.height
            );

            let finalFreq = frequency;

            switch(state.mode) {
                case 'classical':
                    // Use position-based frequency
                    break;
                case 'kandinsky':
                    // Use color-based frequency
                    finalFreq = SynesthesiaEngine.colorToFrequency(color);
                    break;
                case 'spectrum':
                    // Use both position and color
                    finalFreq = (frequency + SynesthesiaEngine.colorToFrequency(color)) / 2;
                    break;
                case 'particle':
                    // Random harmonics
                    finalFreq = frequency * (1 + Math.random() * 0.5);
                    break;
            }

            const duration = SynesthesiaEngine.speedToDuration(speed / 100);
            AudioEngine.playNote(finalFreq, duration, velocity);
        }

        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches ? e.touches[0] : e;
            return {
                x: (touch.clientX - rect.left) * (canvas.width / rect.width),
                y: (touch.clientY - rect.top) * (canvas.height / rect.height)
            };
        }

        // ========================================
        // PARTICLE SYSTEM
        // ========================================
        class Particle {
            constructor(x, y, color, vx, vy) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.vx = vx;
                this.vy = vy;
                this.life = 1.0;
                this.size = Math.random() * 5 + 2;
            }

            update(dt) {
                this.x += this.vx * dt * 60;
                this.y += this.vy * dt * 60;
                this.vy += 0.5 * dt * 60; // Gravity
                this.life -= dt;
                return this.life > 0;
            }

            draw(ctx) {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        function createParticles(x, y, color, count) {
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 5 + 2;
                const vx = Math.cos(angle) * speed;
                const vy = Math.sin(angle) * speed;
                state.particles.push(new Particle(x, y, color, vx, vy));
            }
        }

        function updateParticles(dt) {
            state.particles = state.particles.filter(p => p.update(dt));
        }

        function drawParticles() {
            particleCtx.clearRect(0, 0, particleCanvas.width, particleCanvas.height);
            state.particles.forEach(p => p.draw(particleCtx));
        }

        // ========================================
        // MICROPHONE INPUT
        // ========================================
        let micAnalyser = null;
        let micStream = null;

        async function enableMicrophone() {
            try {
                micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                const source = AudioEngine.context.createMediaStreamSource(micStream);
                micAnalyser = AudioEngine.context.createAnalyser();
                micAnalyser.fftSize = 2048;
                source.connect(micAnalyser);

                state.micEnabled = true;
                document.getElementById('mic-status').textContent = 'Mic: Active';
                document.getElementById('enable-mic').textContent = 'üé§ Disable Microphone';
            } catch (e) {
                alert('Failed to access microphone: ' + e.message);
            }
        }

        function disableMicrophone() {
            if (micStream) {
                micStream.getTracks().forEach(track => track.stop());
                micStream = null;
                micAnalyser = null;
                state.micEnabled = false;
                document.getElementById('mic-status').textContent = 'Mic: Off';
                document.getElementById('enable-mic').textContent = 'üé§ Enable Microphone';
            }
        }

        function processMicrophoneInput() {
            if (!state.micEnabled || !micAnalyser) return;

            const dataArray = new Uint8Array(micAnalyser.frequencyBinCount);
            micAnalyser.getByteFrequencyData(dataArray);

            // Find dominant frequency
            let maxVal = 0;
            let maxIndex = 0;
            for (let i = 0; i < dataArray.length; i++) {
                if (dataArray[i] > maxVal) {
                    maxVal = dataArray[i];
                    maxIndex = i;
                }
            }

            if (maxVal > state.micSensitivity * 255) {
                const frequency = maxIndex * AudioEngine.context.sampleRate / micAnalyser.fftSize;
                const color = SynesthesiaEngine.frequencyToColor(frequency);
                const intensity = maxVal / 255;

                // Draw based on sound
                const x = Math.random() * canvas.width;
                const y = canvas.height * (1 - intensity);

                drawCircle(x, y, color, intensity * 30);

                if (state.mode === 'particle') {
                    createParticles(x, y, color, Math.floor(intensity * 20));
                }
            }
        }

        // ========================================
        // MIDI INPUT
        // ========================================
        async function enableMIDI() {
            try {
                const access = await navigator.requestMIDIAccess();
                state.midiAccess = access;

                access.inputs.forEach(input => {
                    input.onmidimessage = handleMIDIMessage;
                });

                document.getElementById('midi-status').textContent = `MIDI: ${access.inputs.size} device(s)`;
                alert(`MIDI enabled! Connected devices: ${access.inputs.size}`);
            } catch (e) {
                alert('MIDI not supported or permission denied: ' + e.message);
            }
        }

        function handleMIDIMessage(message) {
            const [command, note, velocity] = message.data;

            // Note on (144) or note off (128)
            if (command === 144 && velocity > 0) {
                // Note on
                const frequency = 440 * Math.pow(2, (note - 69) / 12);
                const color = SynesthesiaEngine.frequencyToColor(frequency);
                const normalizedVelocity = velocity / 127;

                // Draw visual
                const x = (note / 127) * canvas.width;
                const y = canvas.height * (1 - normalizedVelocity);
                const size = normalizedVelocity * 40;

                drawCircle(x, y, color, size);

                if (state.mode === 'particle') {
                    createParticles(x, y, color, Math.floor(normalizedVelocity * 30));
                }

                // Play sound
                AudioEngine.playNote(frequency, 0.5, normalizedVelocity);
            }
        }

        // ========================================
        // VISUALIZATION
        // ========================================
        function drawVisualizers() {
            const { waveform, spectrum } = AudioEngine.getAnalyserData();

            // Waveform
            waveformCtx.fillStyle = '#000';
            waveformCtx.fillRect(0, 0, waveformCanvas.width, waveformCanvas.height);
            waveformCtx.strokeStyle = '#4aff4a';
            waveformCtx.lineWidth = 2;
            waveformCtx.beginPath();

            const sliceWidth = waveformCanvas.width / waveform.length;
            let x = 0;

            for (let i = 0; i < waveform.length; i++) {
                const v = waveform[i] / 128.0;
                const y = v * waveformCanvas.height / 2;

                if (i === 0) {
                    waveformCtx.moveTo(x, y);
                } else {
                    waveformCtx.lineTo(x, y);
                }

                x += sliceWidth;
            }

            waveformCtx.stroke();

            // Spectrum
            spectrumCtx.fillStyle = '#000';
            spectrumCtx.fillRect(0, 0, spectrumCanvas.width, spectrumCanvas.height);

            const barWidth = spectrumCanvas.width / spectrum.length * 2;
            let barX = 0;

            for (let i = 0; i < spectrum.length; i++) {
                const barHeight = (spectrum[i] / 255) * spectrumCanvas.height;
                const hue = (i / spectrum.length) * 360;
                spectrumCtx.fillStyle = `hsl(${hue}, 80%, 50%)`;
                spectrumCtx.fillRect(barX, spectrumCanvas.height - barHeight, barWidth, barHeight);
                barX += barWidth;
            }
        }

        // ========================================
        // RECORDING & EXPORT
        // ========================================
        let mediaRecorder = null;

        function startRecording() {
            if (state.recording) {
                stopRecording();
                return;
            }

            try {
                // Capture canvas stream
                const canvasStream = canvas.captureStream(30);

                // Capture audio
                const audioDestination = AudioEngine.context.createMediaStreamDestination();
                AudioEngine.masterGain.connect(audioDestination);

                // Combine streams
                const combinedStream = new MediaStream([
                    ...canvasStream.getVideoTracks(),
                    ...audioDestination.stream.getAudioTracks()
                ]);

                mediaRecorder = new MediaRecorder(combinedStream, {
                    mimeType: 'video/webm;codecs=vp9,opus'
                });

                state.recordedChunks = [];

                mediaRecorder.ondataavailable = (e) => {
                    if (e.data.size > 0) {
                        state.recordedChunks.push(e.data);
                    }
                };

                mediaRecorder.start(100);
                state.recording = true;
                state.recordingStartTime = Date.now();

                document.getElementById('recording-indicator').classList.add('active');
                document.getElementById('start-recording').textContent = '‚èπ Stop Recording';
                document.getElementById('start-recording').classList.add('recording');
            } catch (e) {
                alert('Failed to start recording: ' + e.message);
            }
        }

        function stopRecording() {
            if (mediaRecorder && state.recording) {
                mediaRecorder.stop();
                state.recording = false;

                mediaRecorder.onstop = () => {
                    const blob = new Blob(state.recordedChunks, { type: 'video/webm' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `synesthesia-${Date.now()}.webm`;
                    a.click();
                    URL.revokeObjectURL(url);
                };

                document.getElementById('recording-indicator').classList.remove('active');
                document.getElementById('start-recording').textContent = '‚è∫ Start Recording';
                document.getElementById('start-recording').classList.remove('recording');
            }
        }

        function exportAudio() {
            alert('Audio export feature: This would export the audio track separately as WAV. For now, use video export and extract audio.');
        }

        function exportFrames() {
            alert('PNG sequence export: This would export individual frames. Use the video export for now.');
        }

        function exportComposition() {
            const composition = {
                version: '1.0',
                mode: state.mode,
                timestamp: Date.now(),
                canvasData: canvas.toDataURL(),
                visualEvents: state.visualEvents,
                audioEvents: state.audioEvents
            };

            const blob = new Blob([JSON.stringify(composition, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `composition-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // ========================================
        // HISTORY & UNDO/REDO
        // ========================================
        function saveHistoryState() {
            const imageData = canvas.toDataURL();
            state.history = state.history.slice(0, state.historyIndex + 1);
            state.history.push(imageData);
            state.historyIndex = state.history.length - 1;

            // Limit history to 50 states
            if (state.history.length > 50) {
                state.history.shift();
                state.historyIndex--;
            }
        }

        function undo() {
            if (state.historyIndex > 0) {
                state.historyIndex--;
                loadHistoryState(state.historyIndex);
            }
        }

        function redo() {
            if (state.historyIndex < state.history.length - 1) {
                state.historyIndex++;
                loadHistoryState(state.historyIndex);
            }
        }

        function loadHistoryState(index) {
            const img = new Image();
            img.onload = () => {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(img, 0, 0);
            };
            img.src = state.history[index];
        }

        function redrawCanvas() {
            if (state.history.length > 0 && state.historyIndex >= 0) {
                loadHistoryState(state.historyIndex);
            } else {
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                saveHistoryState();
            }
        }

        function clearCanvas() {
            if (confirm('Clear the canvas? This cannot be undone.')) {
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                particleCtx.clearRect(0, 0, particleCanvas.width, particleCanvas.height);
                state.particles = [];
                saveHistoryState();
            }
        }

        // ========================================
        // DATA PERSISTENCE
        // ========================================
        function saveData() {
            const dataToSave = {
                mode: state.mode,
                currentColor: state.currentColor,
                brushSize: state.brushSize,
                drawMode: state.drawMode,
                synthType: state.synthType,
                volume: state.volume,
                reverb: state.reverb,
                delay: state.delay,
                micSensitivity: state.micSensitivity
            };

            localStorage.setItem(APP_NAME, JSON.stringify(dataToSave));
        }

        function exportData() {
            const data = {
                ...state,
                canvasData: canvas.toDataURL()
            };

            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `synesthesia-engine-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function importData() {
            document.getElementById('import-file').click();
        }

        document.getElementById('import-file').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const data = JSON.parse(event.target.result);
                    Object.assign(state, data);

                    // Restore canvas
                    if (data.canvasData) {
                        const img = new Image();
                        img.onload = () => {
                            ctx.drawImage(img, 0, 0);
                            saveHistoryState();
                        };
                        img.src = data.canvasData;
                    }

                    saveData();
                    location.reload();
                } catch (error) {
                    alert('Invalid JSON file: ' + error.message);
                }
            };
            reader.readAsText(file);
        });

        // ========================================
        // UI EVENT HANDLERS
        // ========================================
        document.querySelectorAll('.preset-card').forEach(card => {
            card.addEventListener('click', () => {
                document.querySelectorAll('.preset-card').forEach(c => c.classList.remove('active'));
                card.classList.add('active');
                state.mode = card.dataset.mode;
                document.getElementById('mode-display').textContent = `Mode: ${state.mode}`;
                saveData();
            });
        });

        document.querySelectorAll('.color-swatch').forEach(swatch => {
            swatch.addEventListener('click', () => {
                document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('active'));
                swatch.classList.add('active');
                state.currentColor = swatch.dataset.color;
                saveData();
            });
        });

        document.getElementById('brush-size').addEventListener('input', (e) => {
            state.brushSize = parseInt(e.target.value);
            document.getElementById('brush-size-value').textContent = state.brushSize;
            saveData();
        });

        document.getElementById('draw-mode').addEventListener('change', (e) => {
            state.drawMode = e.target.value;
            saveData();
        });

        document.getElementById('synth-type').addEventListener('change', (e) => {
            state.synthType = e.target.value;
            saveData();
        });

        document.getElementById('master-volume').addEventListener('input', (e) => {
            state.volume = e.target.value / 100;
            document.getElementById('volume-value').textContent = e.target.value;
            AudioEngine.setVolume(state.volume);
            saveData();
        });

        document.getElementById('reverb-amount').addEventListener('input', (e) => {
            state.reverb = e.target.value / 100;
            document.getElementById('reverb-value').textContent = e.target.value;
            AudioEngine.setReverb(state.reverb);
            saveData();
        });

        document.getElementById('delay-amount').addEventListener('input', (e) => {
            state.delay = e.target.value / 100;
            document.getElementById('delay-value').textContent = e.target.value;
            AudioEngine.setDelay(state.delay);
            saveData();
        });

        document.getElementById('mic-sensitivity').addEventListener('input', (e) => {
            state.micSensitivity = e.target.value / 100;
            document.getElementById('mic-sens-value').textContent = e.target.value;
            saveData();
        });

        document.getElementById('enable-midi').addEventListener('click', enableMIDI);

        document.getElementById('enable-mic').addEventListener('click', () => {
            if (state.micEnabled) {
                disableMicrophone();
            } else {
                enableMicrophone();
            }
        });

        document.getElementById('start-recording').addEventListener('click', startRecording);
        document.getElementById('export-video').addEventListener('click', startRecording);
        document.getElementById('export-audio').addEventListener('click', exportAudio);
        document.getElementById('export-frames').addEventListener('click', exportFrames);
        document.getElementById('export-composition').addEventListener('click', exportComposition);

        document.getElementById('undo-btn').addEventListener('click', undo);
        document.getElementById('redo-btn').addEventListener('click', redo);
        document.getElementById('clear-canvas').addEventListener('click', clearCanvas);

        document.getElementById('show-tutorial').addEventListener('click', () => {
            document.getElementById('tutorial-overlay').classList.add('active');
        });

        document.getElementById('export-data').addEventListener('click', exportData);
        document.getElementById('import-data').addEventListener('click', importData);

        document.getElementById('toggle-panel').addEventListener('click', () => {
            const panel = document.getElementById('controls-panel');
            const statusBar = document.getElementById('status-bar');
            panel.classList.toggle('collapsed');
            statusBar.classList.toggle('full-width');
        });

        function closeTutorial() {
            document.getElementById('tutorial-overlay').classList.remove('active');
        }

        // ========================================
        // KEYBOARD SHORTCUTS
        // ========================================
        document.addEventListener('keydown', (e) => {
            // Prevent shortcuts when typing in inputs
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;

            switch(e.key.toLowerCase()) {
                case ' ':
                    e.preventDefault();
                    clearCanvas();
                    break;
                case 'z':
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        undo();
                    }
                    break;
                case 'y':
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        redo();
                    }
                    break;
                case 'r':
                    e.preventDefault();
                    startRecording();
                    break;
                case 'm':
                    e.preventDefault();
                    if (state.micEnabled) {
                        disableMicrophone();
                    } else {
                        enableMicrophone();
                    }
                    break;
                case 'tab':
                    e.preventDefault();
                    document.getElementById('toggle-panel').click();
                    break;
                case '1':
                case '2':
                case '3':
                case '4':
                    e.preventDefault();
                    const cards = document.querySelectorAll('.preset-card');
                    if (cards[parseInt(e.key) - 1]) {
                        cards[parseInt(e.key) - 1].click();
                    }
                    break;
            }
        });

        // ========================================
        // MOUSE/TOUCH EVENTS
        // ========================================
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseout', stopDrawing);

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            startDrawing(e);
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            draw(e);
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            stopDrawing();
        });

        // ========================================
        // ANIMATION LOOP
        // ========================================
        let lastFrameTime = Date.now();
        let frameCount = 0;
        let fpsTimer = Date.now();

        function animate() {
            const now = Date.now();
            const dt = (now - lastFrameTime) / 1000;
            lastFrameTime = now;

            // Update particles
            updateParticles(dt);
            drawParticles();

            // Process microphone input
            processMicrophoneInput();

            // Draw visualizers
            drawVisualizers();

            // Update FPS counter
            frameCount++;
            if (now - fpsTimer > 1000) {
                document.getElementById('fps-counter').textContent = `${frameCount} FPS`;
                frameCount = 0;
                fpsTimer = now;
            }

            // Update recording timer
            if (state.recording) {
                const elapsed = Math.floor((now - state.recordingStartTime) / 1000);
                const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
                const seconds = (elapsed % 60).toString().padStart(2, '0');
                document.getElementById('recording-time').textContent = `${minutes}:${seconds}`;
            }

            requestAnimationFrame(animate);
        }

        // ========================================
        // INITIALIZATION
        // ========================================
        function init() {
            resizeCanvases();
            window.addEventListener('resize', resizeCanvases);

            // Initialize audio engine
            AudioEngine.init();

            // Start animation loop
            animate();

            // Initialize canvas with black background
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            saveHistoryState();

            // Show tutorial on first visit
            if (!localStorage.getItem(APP_NAME + '-tutorial-seen')) {
                document.getElementById('tutorial-overlay').classList.add('active');
                localStorage.setItem(APP_NAME + '-tutorial-seen', 'true');
            }

            // Set initial UI values
            document.getElementById('brush-size-value').textContent = state.brushSize;
            document.getElementById('volume-value').textContent = Math.round(state.volume * 100);
            document.getElementById('reverb-value').textContent = Math.round(state.reverb * 100);
            document.getElementById('delay-value').textContent = Math.round(state.delay * 100);
            document.getElementById('mic-sens-value').textContent = Math.round(state.micSensitivity * 100);

            console.log('Synesthesia Engine initialized');
        }

        // Start the application
        init();
    </script>
</body>
</html>