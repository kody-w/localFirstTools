<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Collaborative Music Garden - Quantum World</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: #000;
            color: #fff;
        }

        #canvas {
            display: block;
            width: 100%;
            height: 100vh;
            cursor: crosshair;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            max-width: 300px;
        }

        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 25px;
            border-radius: 50px;
            backdrop-filter: blur(10px);
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            color: white;
            cursor: pointer;
            font-size: 14px;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .button:active {
            transform: translateY(0);
        }

        .button.active {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            box-shadow: 0 0 20px rgba(245, 87, 108, 0.6);
        }

        #info {
            font-size: 13px;
            line-height: 1.6;
        }

        #info h2 {
            font-size: 18px;
            margin-bottom: 10px;
            color: #f093fb;
        }

        #stats {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            font-size: 12px;
            color: #aaa;
        }

        #toolbar {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .tool-button {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            padding: 12px;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            font-size: 20px;
            transition: all 0.2s;
            min-width: 50px;
            text-align: center;
        }

        .tool-button:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .tool-button.active {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            border-color: #f5576c;
            box-shadow: 0 0 15px rgba(245, 87, 108, 0.6);
        }

        #scale-selector {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            display: flex;
            gap: 10px;
        }

        .scale-button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 8px 15px;
            border-radius: 15px;
            color: white;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }

        .scale-button:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .scale-button.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-color: #764ba2;
        }

        #mobile-controls {
            display: none;
        }

        @media (max-width: 768px) {
            #ui {
                max-width: 200px;
                font-size: 11px;
                padding: 10px;
            }

            #controls {
                bottom: 10px;
                padding: 10px 15px;
                gap: 5px;
            }

            .button {
                padding: 8px 12px;
                font-size: 12px;
            }

            #toolbar {
                flex-direction: row;
                top: auto;
                bottom: 80px;
                right: 10px;
                left: 10px;
            }

            .tool-button {
                flex: 1;
                font-size: 16px;
                padding: 10px;
            }
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 12px;
            pointer-events: none;
            z-index: 200;
            white-space: nowrap;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div id="ui">
        <div id="info">
            <h2>üéµ Music Garden</h2>
            <p>Click to place musical objects</p>
            <p>WASD to move ‚Ä¢ Mouse to look</p>
            <div id="stats">
                <div>Objects: <span id="object-count">0</span></div>
                <div>Playing: <span id="playing-count">0</span></div>
            </div>
        </div>
    </div>

    <div id="scale-selector">
        <button class="scale-button active" data-scale="major">Major</button>
        <button class="scale-button" data-scale="minor">Minor</button>
        <button class="scale-button" data-scale="pentatonic">Pentatonic</button>
        <button class="scale-button" data-scale="chromatic">Chromatic</button>
    </div>

    <div id="toolbar">
        <button class="tool-button active" data-tool="tower" title="Musical Tower">üóº</button>
        <button class="tool-button" data-tool="crystal" title="Crystal Resonator">üíé</button>
        <button class="tool-button" data-tool="river" title="Musical River">üåä</button>
        <button class="tool-button" data-tool="tree" title="Harmony Tree">üå≥</button>
    </div>

    <div id="controls">
        <button class="button" id="clear-btn">Clear</button>
        <button class="button" id="play-pause-btn">‚è∏ Pause</button>
        <button class="button" id="export-btn">Export</button>
        <button class="button" id="import-btn">Import</button>
    </div>

    <script>
        // ==================== CORE CONFIGURATION ====================
        const CONFIG = {
            audioContext: null,
            masterVolume: 0.3,
            scales: {
                major: [0, 2, 4, 5, 7, 9, 11],
                minor: [0, 2, 3, 5, 7, 8, 10],
                pentatonic: [0, 2, 4, 7, 9],
                chromatic: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
            },
            baseFreq: 220, // A3
            colors: {
                tower: [255, 100, 100],
                crystal: [100, 255, 255],
                river: [100, 150, 255],
                tree: [100, 255, 150]
            }
        };

        let currentScale = 'major';
        let currentTool = 'tower';
        let isPlaying = true;

        // ==================== SIMPLIFIED 3D ENGINE ====================
        class Vec3 {
            constructor(x = 0, y = 0, z = 0) {
                this.x = x;
                this.y = y;
                this.z = z;
            }

            add(v) {
                return new Vec3(this.x + v.x, this.y + v.y, this.z + v.z);
            }

            sub(v) {
                return new Vec3(this.x - v.x, this.y - v.y, this.z - v.z);
            }

            mul(s) {
                return new Vec3(this.x * s, this.y * s, this.z * s);
            }

            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
            }

            normalize() {
                const len = this.length();
                return len > 0 ? this.mul(1 / len) : new Vec3();
            }

            dot(v) {
                return this.x * v.x + this.y * v.y + this.z * v.z;
            }

            cross(v) {
                return new Vec3(
                    this.y * v.z - this.z * v.y,
                    this.z * v.x - this.x * v.z,
                    this.x * v.y - this.y * v.x
                );
            }
        }

        class Camera {
            constructor() {
                this.pos = new Vec3(0, 50, 100);
                this.rot = { x: -0.3, y: 0 };
                this.fov = 60;
                this.near = 0.1;
                this.far = 1000;
            }

            project(point, canvas) {
                // Simple perspective projection
                const dx = point.x - this.pos.x;
                const dy = point.y - this.pos.y;
                const dz = point.z - this.pos.z;

                // Rotate around Y axis
                const cosY = Math.cos(this.rot.y);
                const sinY = Math.sin(this.rot.y);
                const rx = dx * cosY - dz * sinY;
                const rz = dx * sinY + dz * cosY;

                // Rotate around X axis
                const cosX = Math.cos(this.rot.x);
                const sinX = Math.sin(this.rot.x);
                const ry = dy * cosX - rz * sinX;
                const finalZ = dy * sinX + rz * cosX;

                if (finalZ <= this.near) return null;

                const scale = (canvas.width / 2) / Math.tan(this.fov * Math.PI / 360);
                const x = canvas.width / 2 + (rx * scale) / finalZ;
                const y = canvas.height / 2 - (ry * scale) / finalZ;

                return { x, y, z: finalZ };
            }
        }

        // ==================== AUDIO SYSTEM ====================
        class AudioSystem {
            constructor() {
                this.context = null;
                this.masterGain = null;
                this.oscillators = new Map();
            }

            init() {
                this.context = new (window.AudioContext || window.webkitAudioContext)();
                this.masterGain = this.context.createGain();
                this.masterGain.gain.value = CONFIG.masterVolume;
                this.masterGain.connect(this.context.destination);
            }

            getNoteFrequency(noteIndex, octave = 4) {
                const scale = CONFIG.scales[currentScale];
                const scaleIndex = noteIndex % scale.length;
                const octaveOffset = Math.floor(noteIndex / scale.length);
                const semitone = scale[scaleIndex];
                return CONFIG.baseFreq * Math.pow(2, (octave + octaveOffset - 3) + semitone / 12);
            }

            playNote(id, noteIndex, type = 'sine', duration = null) {
                if (!this.context || !isPlaying) return;

                // Stop existing note if playing
                this.stopNote(id);

                const osc = this.context.createOscillator();
                const gain = this.context.createGain();
                const filter = this.context.createBiquadFilter();

                osc.type = type;
                osc.frequency.value = this.getNoteFrequency(noteIndex);

                filter.type = 'lowpass';
                filter.frequency.value = 2000;
                filter.Q.value = 1;

                // Envelope
                gain.gain.value = 0;
                gain.gain.linearRampToValueAtTime(0.3, this.context.currentTime + 0.05);

                if (duration) {
                    gain.gain.linearRampToValueAtTime(0.3, this.context.currentTime + duration - 0.1);
                    gain.gain.linearRampToValueAtTime(0, this.context.currentTime + duration);
                }

                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);

                osc.start();
                if (duration) {
                    osc.stop(this.context.currentTime + duration);
                } else {
                    this.oscillators.set(id, { osc, gain, filter });
                }
            }

            stopNote(id) {
                if (!this.oscillators.has(id)) return;

                const { osc, gain } = this.oscillators.get(id);
                try {
                    gain.gain.linearRampToValueAtTime(0, this.context.currentTime + 0.1);
                    osc.stop(this.context.currentTime + 0.1);
                } catch (e) {
                    // Already stopped
                }
                this.oscillators.delete(id);
            }

            stopAll() {
                for (const id of this.oscillators.keys()) {
                    this.stopNote(id);
                }
            }
        }

        // ==================== MUSICAL OBJECTS ====================
        class MusicalObject {
            constructor(pos, type, noteIndex) {
                this.id = Math.random().toString(36).substr(2, 9);
                this.pos = pos;
                this.type = type;
                this.noteIndex = noteIndex;
                this.glow = 0;
                this.phase = Math.random() * Math.PI * 2;
                this.playInterval = null;
                this.lastPlayTime = 0;
            }

            getColor() {
                const baseColor = CONFIG.colors[this.type];
                const glow = Math.max(0, this.glow);
                return [
                    Math.min(255, baseColor[0] + glow * 100),
                    Math.min(255, baseColor[1] + glow * 100),
                    Math.min(255, baseColor[2] + glow * 100)
                ];
            }

            update(deltaTime, objects, audioSystem) {
                this.phase += deltaTime * 2;
                this.glow *= 0.95;

                const playRate = this.getPlayRate();
                const currentTime = Date.now();

                if (currentTime - this.lastPlayTime > playRate) {
                    this.play(audioSystem, objects);
                    this.lastPlayTime = currentTime;
                }
            }

            getPlayRate() {
                switch (this.type) {
                    case 'tower': return 2000;
                    case 'crystal': return 1500;
                    case 'river': return 1000;
                    case 'tree': return 3000;
                    default: return 2000;
                }
            }

            play(audioSystem, objects) {
                const waveType = {
                    tower: 'sine',
                    crystal: 'triangle',
                    river: 'square',
                    tree: 'sawtooth'
                }[this.type];

                audioSystem.playNote(this.id, this.noteIndex, waveType, 0.5);
                this.glow = 1;

                // Check for harmonizing neighbors
                this.harmonize(objects, audioSystem);
            }

            harmonize(objects, audioSystem) {
                const harmonicDistance = 30;
                for (const obj of objects) {
                    if (obj.id === this.id) continue;

                    const dist = this.pos.sub(obj.pos).length();
                    if (dist < harmonicDistance) {
                        // Play a harmonizing note
                        const harmonicNote = this.noteIndex + (obj.noteIndex - this.noteIndex) / 2;
                        setTimeout(() => {
                            audioSystem.playNote(obj.id + '_harmonic', Math.round(harmonicNote), 'sine', 0.3);
                            obj.glow = 0.5;
                        }, 100);
                    }
                }
            }

            render(ctx, camera, canvas) {
                const projected = camera.project(this.pos, canvas);
                if (!projected || projected.z > 500) return;

                const scale = Math.max(0.5, 100 / projected.z);
                const size = this.getSize() * scale;
                const color = this.getColor();
                const alpha = Math.max(0.3, 1 - projected.z / 500);

                ctx.save();
                ctx.globalAlpha = alpha;

                // Draw glow
                if (this.glow > 0) {
                    const gradient = ctx.createRadialGradient(
                        projected.x, projected.y, 0,
                        projected.x, projected.y, size * 2
                    );
                    gradient.addColorStop(0, `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${this.glow * 0.5})`);
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(
                        projected.x - size * 2,
                        projected.y - size * 2,
                        size * 4,
                        size * 4
                    );
                }

                // Draw object
                ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                this.renderShape(ctx, projected.x, projected.y, size);

                ctx.restore();
            }

            getSize() {
                switch (this.type) {
                    case 'tower': return 15;
                    case 'crystal': return 12;
                    case 'river': return 10;
                    case 'tree': return 20;
                    default: return 10;
                }
            }

            renderShape(ctx, x, y, size) {
                switch (this.type) {
                    case 'tower':
                        ctx.fillRect(x - size/2, y - size * 1.5, size, size * 2);
                        break;
                    case 'crystal':
                        ctx.beginPath();
                        ctx.moveTo(x, y - size);
                        ctx.lineTo(x + size, y + size);
                        ctx.lineTo(x - size, y + size);
                        ctx.closePath();
                        ctx.fill();
                        break;
                    case 'river':
                        ctx.beginPath();
                        ctx.arc(x, y, size, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                    case 'tree':
                        // Trunk
                        ctx.fillRect(x - size/4, y, size/2, size);
                        // Canopy
                        ctx.beginPath();
                        ctx.arc(x, y - size/2, size, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                }
            }

            toJSON() {
                return {
                    pos: { x: this.pos.x, y: this.pos.y, z: this.pos.z },
                    type: this.type,
                    noteIndex: this.noteIndex
                };
            }

            static fromJSON(data) {
                return new MusicalObject(
                    new Vec3(data.pos.x, data.pos.y, data.pos.z),
                    data.type,
                    data.noteIndex
                );
            }
        }

        // ==================== WORLD MANAGER ====================
        class MusicGarden {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.camera = new Camera();
                this.audioSystem = new AudioSystem();
                this.objects = [];
                this.keys = {};
                this.mouse = { x: 0, y: 0, down: false };
                this.lastTime = Date.now();
                this.frameCount = 0;

                this.resize();
                this.setupEventListeners();
                this.loadFromStorage();
                this.animate();
            }

            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }

            setupEventListeners() {
                window.addEventListener('resize', () => this.resize());

                // Keyboard
                window.addEventListener('keydown', (e) => {
                    this.keys[e.key.toLowerCase()] = true;
                });
                window.addEventListener('keyup', (e) => {
                    this.keys[e.key.toLowerCase()] = false;
                });

                // Mouse
                this.canvas.addEventListener('mousemove', (e) => {
                    const dx = e.movementX;
                    const dy = e.movementY;

                    if (this.mouse.down) {
                        this.camera.rot.y -= dx * 0.003;
                        this.camera.rot.x -= dy * 0.003;
                        this.camera.rot.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.camera.rot.x));
                    }

                    this.mouse.x = e.clientX;
                    this.mouse.y = e.clientY;
                });

                this.canvas.addEventListener('mousedown', (e) => {
                    if (e.button === 2) {
                        this.mouse.down = true;
                        this.canvas.style.cursor = 'grabbing';
                        e.preventDefault();
                    } else if (e.button === 0) {
                        this.placeObject();
                    }
                });

                this.canvas.addEventListener('mouseup', (e) => {
                    if (e.button === 2) {
                        this.mouse.down = false;
                        this.canvas.style.cursor = 'crosshair';
                    }
                });

                this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());

                // Touch support
                let touchStartX = 0;
                let touchStartY = 0;

                this.canvas.addEventListener('touchstart', (e) => {
                    if (e.touches.length === 1) {
                        touchStartX = e.touches[0].clientX;
                        touchStartY = e.touches[0].clientY;
                    }
                });

                this.canvas.addEventListener('touchmove', (e) => {
                    if (e.touches.length === 1) {
                        const dx = e.touches[0].clientX - touchStartX;
                        const dy = e.touches[0].clientY - touchStartY;

                        this.camera.rot.y -= dx * 0.005;
                        this.camera.rot.x -= dy * 0.005;
                        this.camera.rot.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.camera.rot.x));

                        touchStartX = e.touches[0].clientX;
                        touchStartY = e.touches[0].clientY;
                    }
                    e.preventDefault();
                });

                this.canvas.addEventListener('touchend', (e) => {
                    if (e.changedTouches.length === 1) {
                        this.placeObject();
                    }
                });

                // UI Controls
                document.getElementById('clear-btn').addEventListener('click', () => this.clear());
                document.getElementById('play-pause-btn').addEventListener('click', () => this.togglePlayPause());
                document.getElementById('export-btn').addEventListener('click', () => this.export());
                document.getElementById('import-btn').addEventListener('click', () => this.import());

                // Tool selection
                document.querySelectorAll('.tool-button').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.tool-button').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        currentTool = btn.dataset.tool;
                    });
                });

                // Scale selection
                document.querySelectorAll('.scale-button').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.scale-button').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        currentScale = btn.dataset.scale;
                    });
                });
            }

            placeObject() {
                // Initialize audio on first interaction
                if (!this.audioSystem.context) {
                    this.audioSystem.init();
                }

                // Calculate world position from camera
                const distance = 50;
                const dir = new Vec3(
                    Math.sin(this.camera.rot.y) * Math.cos(this.camera.rot.x),
                    Math.sin(this.camera.rot.x),
                    Math.cos(this.camera.rot.y) * Math.cos(this.camera.rot.x)
                );

                const pos = this.camera.pos.add(dir.mul(distance));
                pos.y = 0; // Place on ground

                // Random note from current scale
                const noteIndex = Math.floor(Math.random() * CONFIG.scales[currentScale].length * 3);

                const obj = new MusicalObject(pos, currentTool, noteIndex);
                this.objects.push(obj);

                // Play a preview note
                obj.play(this.audioSystem, this.objects);

                this.saveToStorage();
                this.updateStats();
            }

            updateCamera(deltaTime) {
                const speed = 50 * deltaTime;
                const forward = new Vec3(
                    Math.sin(this.camera.rot.y),
                    0,
                    Math.cos(this.camera.rot.y)
                );
                const right = new Vec3(
                    Math.sin(this.camera.rot.y + Math.PI/2),
                    0,
                    Math.cos(this.camera.rot.y + Math.PI/2)
                );

                if (this.keys['w']) this.camera.pos = this.camera.pos.add(forward.mul(speed));
                if (this.keys['s']) this.camera.pos = this.camera.pos.sub(forward.mul(speed));
                if (this.keys['a']) this.camera.pos = this.camera.pos.sub(right.mul(speed));
                if (this.keys['d']) this.camera.pos = this.camera.pos.add(right.mul(speed));
                if (this.keys['q']) this.camera.pos.y -= speed;
                if (this.keys['e']) this.camera.pos.y += speed;

                // Keep camera above ground
                this.camera.pos.y = Math.max(10, this.camera.pos.y);
            }

            render() {
                // Clear with gradient sky
                const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
                gradient.addColorStop(0, '#1a0033');
                gradient.addColorStop(1, '#000011');
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Draw ground grid
                this.renderGround();

                // Sort objects by distance for proper rendering
                const sortedObjects = [...this.objects].sort((a, b) => {
                    const distA = a.pos.sub(this.camera.pos).length();
                    const distB = b.pos.sub(this.camera.pos).length();
                    return distB - distA;
                });

                // Render objects
                for (const obj of sortedObjects) {
                    obj.render(this.ctx, this.camera, this.canvas);
                }

                // Draw connection lines between close objects
                this.renderConnections(sortedObjects);
            }

            renderGround() {
                const gridSize = 50;
                const gridSpacing = 20;

                this.ctx.strokeStyle = 'rgba(100, 50, 150, 0.2)';
                this.ctx.lineWidth = 1;

                for (let x = -gridSize; x <= gridSize; x += gridSpacing) {
                    const start = new Vec3(x, 0, -gridSize * gridSpacing);
                    const end = new Vec3(x, 0, gridSize * gridSpacing);

                    const p1 = this.camera.project(start, this.canvas);
                    const p2 = this.camera.project(end, this.canvas);

                    if (p1 && p2) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(p1.x, p1.y);
                        this.ctx.lineTo(p2.x, p2.y);
                        this.ctx.stroke();
                    }
                }

                for (let z = -gridSize; z <= gridSize; z += gridSpacing) {
                    const start = new Vec3(-gridSize * gridSpacing, 0, z);
                    const end = new Vec3(gridSize * gridSpacing, 0, z);

                    const p1 = this.camera.project(start, this.canvas);
                    const p2 = this.camera.project(end, this.canvas);

                    if (p1 && p2) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(p1.x, p1.y);
                        this.ctx.lineTo(p2.x, p2.y);
                        this.ctx.stroke();
                    }
                }
            }

            renderConnections(objects) {
                const connectionDistance = 30;

                for (let i = 0; i < objects.length; i++) {
                    for (let j = i + 1; j < objects.length; j++) {
                        const dist = objects[i].pos.sub(objects[j].pos).length();

                        if (dist < connectionDistance) {
                            const p1 = this.camera.project(objects[i].pos, this.canvas);
                            const p2 = this.camera.project(objects[j].pos, this.canvas);

                            if (p1 && p2) {
                                const alpha = (1 - dist / connectionDistance) * 0.3;
                                const avgGlow = (objects[i].glow + objects[j].glow) / 2;

                                this.ctx.strokeStyle = `rgba(150, 100, 255, ${alpha + avgGlow * 0.3})`;
                                this.ctx.lineWidth = 2;
                                this.ctx.beginPath();
                                this.ctx.moveTo(p1.x, p1.y);
                                this.ctx.lineTo(p2.x, p2.y);
                                this.ctx.stroke();
                            }
                        }
                    }
                }
            }

            update(deltaTime) {
                this.updateCamera(deltaTime);

                for (const obj of this.objects) {
                    obj.update(deltaTime, this.objects, this.audioSystem);
                }

                this.frameCount++;
                if (this.frameCount % 30 === 0) {
                    this.updateStats();
                }
            }

            animate() {
                const currentTime = Date.now();
                const deltaTime = Math.min((currentTime - this.lastTime) / 1000, 0.1);
                this.lastTime = currentTime;

                this.update(deltaTime);
                this.render();

                requestAnimationFrame(() => this.animate());
            }

            updateStats() {
                document.getElementById('object-count').textContent = this.objects.length;
                document.getElementById('playing-count').textContent =
                    this.audioSystem.oscillators.size;
            }

            clear() {
                if (!confirm('Clear all objects?')) return;

                this.audioSystem.stopAll();
                this.objects = [];
                this.saveToStorage();
                this.updateStats();
            }

            togglePlayPause() {
                isPlaying = !isPlaying;
                const btn = document.getElementById('play-pause-btn');

                if (isPlaying) {
                    btn.textContent = '‚è∏ Pause';
                    btn.classList.remove('active');
                } else {
                    btn.textContent = '‚ñ∂ Play';
                    btn.classList.add('active');
                    this.audioSystem.stopAll();
                }
            }

            export() {
                const data = {
                    version: 1,
                    scale: currentScale,
                    objects: this.objects.map(obj => obj.toJSON()),
                    camera: {
                        pos: { x: this.camera.pos.x, y: this.camera.pos.y, z: this.camera.pos.z },
                        rot: { x: this.camera.rot.x, y: this.camera.rot.y }
                    }
                };

                const json = JSON.stringify(data, null, 2);
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `music-garden-${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
            }

            import() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = 'application/json';
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const data = JSON.parse(event.target.result);
                            this.loadData(data);
                        } catch (err) {
                            alert('Error importing file: ' + err.message);
                        }
                    };
                    reader.readAsText(file);
                };
                input.click();
            }

            loadData(data) {
                this.audioSystem.stopAll();
                this.objects = [];

                if (data.scale) {
                    currentScale = data.scale;
                    document.querySelectorAll('.scale-button').forEach(btn => {
                        btn.classList.toggle('active', btn.dataset.scale === currentScale);
                    });
                }

                if (data.objects) {
                    for (const objData of data.objects) {
                        this.objects.push(MusicalObject.fromJSON(objData));
                    }
                }

                if (data.camera) {
                    this.camera.pos = new Vec3(
                        data.camera.pos.x,
                        data.camera.pos.y,
                        data.camera.pos.z
                    );
                    this.camera.rot = { ...data.camera.rot };
                }

                this.saveToStorage();
                this.updateStats();
            }

            saveToStorage() {
                const data = {
                    version: 1,
                    scale: currentScale,
                    objects: this.objects.map(obj => obj.toJSON()),
                    camera: {
                        pos: { x: this.camera.pos.x, y: this.camera.pos.y, z: this.camera.pos.z },
                        rot: { x: this.camera.rot.x, y: this.camera.rot.y }
                    }
                };
                localStorage.setItem('musicGarden', JSON.stringify(data));
            }

            loadFromStorage() {
                const saved = localStorage.getItem('musicGarden');
                if (saved) {
                    try {
                        const data = JSON.parse(saved);
                        this.loadData(data);
                    } catch (err) {
                        console.error('Error loading from storage:', err);
                    }
                }
            }
        }

        // ==================== INITIALIZATION ====================
        let garden;

        window.addEventListener('DOMContentLoaded', () => {
            garden = new MusicGarden();
        });

        // Handle visibility changes to pause audio
        document.addEventListener('visibilitychange', () => {
            if (document.hidden && garden && garden.audioSystem) {
                garden.audioSystem.stopAll();
            }
        });
    </script>
</body>
</html>