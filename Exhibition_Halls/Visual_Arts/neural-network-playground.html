<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Network Playground - Watch AI Learn</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            overflow: hidden;
            height: 100vh;
        }

        .container {
            display: grid;
            grid-template-columns: 300px 1fr 300px;
            grid-template-rows: 60px 1fr;
            gap: 20px;
            padding: 20px;
            height: 100vh;
        }

        .header {
            grid-column: 1 / -1;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 12px;
            padding: 15px 25px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .header h1 {
            font-size: 24px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .stats {
            display: flex;
            gap: 20px;
            font-size: 14px;
        }

        .stat {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .stat-label {
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .stat-value {
            font-size: 18px;
            font-weight: bold;
            color: #667eea;
        }

        .panel {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            overflow-y: auto;
        }

        .panel h2 {
            font-size: 16px;
            margin-bottom: 15px;
            color: #667eea;
            border-bottom: 2px solid #667eea;
            padding-bottom: 8px;
        }

        .canvas-container {
            position: relative;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        canvas {
            display: block;
        }

        #mainCanvas {
            width: 100%;
            height: 100%;
        }

        .controls-group {
            margin-bottom: 20px;
        }

        .controls-group label {
            display: block;
            margin-bottom: 8px;
            font-size: 13px;
            font-weight: 600;
            color: #555;
        }

        .slider-container {
            margin-bottom: 15px;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #e0e0e0;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
        }

        .slider-value {
            float: right;
            font-size: 12px;
            color: #667eea;
            font-weight: bold;
        }

        .button {
            width: 100%;
            padding: 12px;
            margin-bottom: 10px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .button-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .button-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .button-secondary {
            background: #f0f0f0;
            color: #666;
        }

        .button-secondary:hover {
            background: #e0e0e0;
        }

        .button-success {
            background: #10b981;
            color: white;
        }

        .button-danger {
            background: #ef4444;
            color: white;
        }

        .dataset-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 15px;
        }

        .dataset-btn {
            padding: 10px;
            border: 2px solid #667eea;
            background: white;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .dataset-btn:hover {
            background: #667eea;
            color: white;
        }

        .color-btn {
            width: 100%;
            padding: 15px;
            border: 3px solid transparent;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            margin-bottom: 10px;
            transition: all 0.2s ease;
        }

        .color-btn.red {
            background: #ef4444;
            color: white;
        }

        .color-btn.blue {
            background: #3b82f6;
            color: white;
        }

        .color-btn.active {
            border-color: #fbbf24;
            box-shadow: 0 0 0 3px rgba(251, 191, 36, 0.3);
        }

        .network-viz {
            background: #f9fafb;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .layer-config {
            background: white;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 10px;
            border: 1px solid #e5e7eb;
        }

        .layer-config h3 {
            font-size: 12px;
            color: #667eea;
            margin-bottom: 8px;
        }

        select {
            width: 100%;
            padding: 8px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 13px;
            margin-bottom: 8px;
        }

        .help-text {
            font-size: 11px;
            color: #9ca3af;
            font-style: italic;
            margin-top: 5px;
        }

        .chart-container {
            height: 150px;
            background: white;
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 15px;
            position: relative;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .training {
            animation: pulse 1.5s ease-in-out infinite;
        }

        .info-box {
            background: #eff6ff;
            border-left: 4px solid #3b82f6;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 15px;
            font-size: 12px;
            line-height: 1.6;
        }

        .legend {
            display: flex;
            gap: 15px;
            margin-top: 10px;
            font-size: 11px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        /* Responsive */
        @media (max-width: 1200px) {
            .container {
                grid-template-columns: 250px 1fr 250px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üß† Neural Network Playground</h1>
            <div class="stats">
                <div class="stat">
                    <span class="stat-label">Epoch</span>
                    <span class="stat-value" id="epochDisplay">0</span>
                </div>
                <div class="stat">
                    <span class="stat-label">Accuracy</span>
                    <span class="stat-value" id="accuracyDisplay">0%</span>
                </div>
                <div class="stat">
                    <span class="stat-label">Loss</span>
                    <span class="stat-value" id="lossDisplay">0.00</span>
                </div>
                <div class="stat">
                    <span class="stat-label">Points</span>
                    <span class="stat-value" id="pointsDisplay">0</span>
                </div>
            </div>
        </div>

        <div class="panel">
            <h2>üìä Dataset</h2>

            <div class="info-box">
                Click on the canvas to add data points. Try to create patterns that need learning!
            </div>

            <div class="controls-group">
                <label>Choose Your Class</label>
                <button class="color-btn red active" id="redBtn" onclick="app.setDrawClass(0)">
                    üî¥ Class 0 (Red)
                </button>
                <button class="color-btn blue" id="blueBtn" onclick="app.setDrawClass(1)">
                    üîµ Class 1 (Blue)
                </button>
            </div>

            <div class="controls-group">
                <label>Quick Datasets</label>
                <div class="dataset-buttons">
                    <button class="dataset-btn" onclick="app.loadDataset('xor')">XOR</button>
                    <button class="dataset-btn" onclick="app.loadDataset('circle')">Circle</button>
                    <button class="dataset-btn" onclick="app.loadDataset('spiral')">Spiral</button>
                    <button class="dataset-btn" onclick="app.loadDataset('gaussian')">Gaussian</button>
                </div>
            </div>

            <button class="button button-secondary" onclick="app.clearDataset()">
                üóëÔ∏è Clear Dataset
            </button>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #ef4444;"></div>
                    <span>Train (Red)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #3b82f6; border: 2px solid #3b82f6; background: transparent;"></div>
                    <span>Test (Blue)</span>
                </div>
            </div>
        </div>

        <div class="canvas-container">
            <canvas id="mainCanvas" width="600" height="600"></canvas>
        </div>

        <div class="panel">
            <h2>üéõÔ∏è Network Configuration</h2>

            <div class="controls-group">
                <label>Hidden Layer Size
                    <span class="slider-value" id="neuronDisplay">4</span>
                </label>
                <input type="range" id="neuronSlider" min="1" max="8" value="4"
                       oninput="app.updateNeurons(this.value)">
                <div class="help-text">More neurons = more complex patterns</div>
            </div>

            <div class="controls-group">
                <label>Activation Function</label>
                <select id="activationSelect" onchange="app.updateActivation(this.value)">
                    <option value="tanh">Tanh (smooth)</option>
                    <option value="relu">ReLU (sharp)</option>
                    <option value="sigmoid">Sigmoid (classic)</option>
                </select>
            </div>

            <div class="controls-group">
                <label>Learning Rate
                    <span class="slider-value" id="lrDisplay">0.1</span>
                </label>
                <input type="range" id="lrSlider" min="-3" max="0" step="0.1" value="-1"
                       oninput="app.updateLearningRate(this.value)">
                <div class="help-text">Controls learning speed</div>
            </div>

            <div class="controls-group">
                <button class="button button-primary" id="trainBtn" onclick="app.toggleTraining()">
                    ‚ñ∂Ô∏è Start Training
                </button>
                <button class="button button-success" onclick="app.stepTraining()">
                    ‚è≠Ô∏è Step (1 Epoch)
                </button>
                <button class="button button-danger" onclick="app.resetNetwork()">
                    üîÑ Reset Network
                </button>
            </div>

            <h2 style="margin-top: 20px;">üìà Training Progress</h2>

            <div class="chart-container">
                <canvas id="lossChart" width="260" height="130"></canvas>
            </div>

            <div class="network-viz">
                <h3 style="font-size: 13px; margin-bottom: 10px; color: #667eea;">Network Architecture</h3>
                <div style="font-size: 11px; color: #6b7280; font-family: monospace;">
                    Input (2) ‚Üí Hidden (<span id="archNeurons">4</span>) ‚Üí Output (1)
                </div>
                <div style="font-size: 10px; color: #9ca3af; margin-top: 5px;">
                    Activation: <span id="archActivation">tanh</span>
                </div>
            </div>

            <div class="info-box" style="background: #f0fdf4; border-color: #10b981;">
                <strong>üí° Tip:</strong> Start with a simple pattern like XOR. Click "Start Training" and watch the decision boundary learn!
            </div>
        </div>
    </div>

    <script>
        class NeuralNetwork {
            constructor(config) {
                this.inputSize = 2;
                this.hiddenSize = config.hiddenSize || 4;
                this.outputSize = 1;
                this.learningRate = config.learningRate || 0.1;
                this.activation = config.activation || 'tanh';

                this.initializeWeights();
            }

            initializeWeights() {
                // Xavier initialization
                const limit1 = Math.sqrt(6 / (this.inputSize + this.hiddenSize));
                const limit2 = Math.sqrt(6 / (this.hiddenSize + this.outputSize));

                this.w1 = new Float32Array(this.inputSize * this.hiddenSize);
                this.b1 = new Float32Array(this.hiddenSize);
                this.w2 = new Float32Array(this.hiddenSize * this.outputSize);
                this.b2 = new Float32Array(this.outputSize);

                for (let i = 0; i < this.w1.length; i++) {
                    this.w1[i] = (Math.random() * 2 - 1) * limit1;
                }
                for (let i = 0; i < this.w2.length; i++) {
                    this.w2[i] = (Math.random() * 2 - 1) * limit2;
                }
            }

            activate(x, type = this.activation) {
                if (type === 'tanh') return Math.tanh(x);
                if (type === 'relu') return Math.max(0, x);
                if (type === 'sigmoid') return 1 / (1 + Math.exp(-Math.max(-500, Math.min(500, x))));
                return x;
            }

            activateDerivative(x, type = this.activation) {
                if (type === 'tanh') {
                    const t = Math.tanh(x);
                    return 1 - t * t;
                }
                if (type === 'relu') return x > 0 ? 1 : 0;
                if (type === 'sigmoid') {
                    const s = this.activate(x, 'sigmoid');
                    return s * (1 - s);
                }
                return 1;
            }

            forward(input) {
                // Input to hidden
                const hidden = new Float32Array(this.hiddenSize);
                for (let j = 0; j < this.hiddenSize; j++) {
                    let sum = this.b1[j];
                    for (let i = 0; i < this.inputSize; i++) {
                        sum += input[i] * this.w1[i * this.hiddenSize + j];
                    }
                    hidden[j] = this.activate(sum);
                }

                // Hidden to output
                let output = this.b2[0];
                for (let j = 0; j < this.hiddenSize; j++) {
                    output += hidden[j] * this.w2[j];
                }
                output = this.activate(output, 'sigmoid');

                return { hidden, output };
            }

            train(input, target) {
                // Forward pass
                const hiddenRaw = new Float32Array(this.hiddenSize);
                const hidden = new Float32Array(this.hiddenSize);

                for (let j = 0; j < this.hiddenSize; j++) {
                    let sum = this.b1[j];
                    for (let i = 0; i < this.inputSize; i++) {
                        sum += input[i] * this.w1[i * this.hiddenSize + j];
                    }
                    hiddenRaw[j] = sum;
                    hidden[j] = this.activate(sum);
                }

                let outputRaw = this.b2[0];
                for (let j = 0; j < this.hiddenSize; j++) {
                    outputRaw += hidden[j] * this.w2[j];
                }
                const output = this.activate(outputRaw, 'sigmoid');

                // Backward pass
                const outputError = output - target;
                const outputDelta = outputError * this.activateDerivative(outputRaw, 'sigmoid');

                const hiddenError = new Float32Array(this.hiddenSize);
                for (let j = 0; j < this.hiddenSize; j++) {
                    hiddenError[j] = outputDelta * this.w2[j];
                }

                // Update output layer
                for (let j = 0; j < this.hiddenSize; j++) {
                    this.w2[j] -= this.learningRate * outputDelta * hidden[j];
                }
                this.b2[0] -= this.learningRate * outputDelta;

                // Update hidden layer
                for (let j = 0; j < this.hiddenSize; j++) {
                    const delta = hiddenError[j] * this.activateDerivative(hiddenRaw[j]);
                    for (let i = 0; i < this.inputSize; i++) {
                        this.w1[i * this.hiddenSize + j] -= this.learningRate * delta * input[i];
                    }
                    this.b1[j] -= this.learningRate * delta;
                }

                return Math.abs(output - target);
            }
        }

        class App {
            constructor() {
                this.canvas = document.getElementById('mainCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.lossCanvas = document.getElementById('lossChart');
                this.lossCtx = this.lossCanvas.getContext('2d');

                this.dataset = [];
                this.trainData = [];
                this.testData = [];
                this.drawClass = 0;
                this.isTraining = false;
                this.epoch = 0;
                this.lossHistory = [];

                this.network = new NeuralNetwork({
                    hiddenSize: 4,
                    learningRate: 0.1,
                    activation: 'tanh'
                });

                this.setupCanvas();
                this.animate();
            }

            setupCanvas() {
                this.canvas.addEventListener('click', (e) => this.handleClick(e));
                this.render();
            }

            handleClick(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                const y = 1 - ((e.clientY - rect.top) / rect.height) * 2;

                this.dataset.push({ x, y, label: this.drawClass });
                this.splitDataset();
                this.updateStats();
                this.render();
            }

            splitDataset() {
                const shuffled = [...this.dataset].sort(() => Math.random() - 0.5);
                const splitIndex = Math.floor(shuffled.length * 0.8);
                this.trainData = shuffled.slice(0, splitIndex);
                this.testData = shuffled.slice(splitIndex);
            }

            setDrawClass(cls) {
                this.drawClass = cls;
                document.getElementById('redBtn').classList.toggle('active', cls === 0);
                document.getElementById('blueBtn').classList.toggle('active', cls === 1);
            }

            loadDataset(type) {
                this.dataset = [];
                const n = 100;

                if (type === 'xor') {
                    for (let i = 0; i < n; i++) {
                        const x = Math.random() * 2 - 1;
                        const y = Math.random() * 2 - 1;
                        const label = (x > 0) !== (y > 0) ? 1 : 0;
                        this.dataset.push({ x, y, label });
                    }
                } else if (type === 'circle') {
                    for (let i = 0; i < n; i++) {
                        const r = Math.random();
                        const theta = Math.random() * Math.PI * 2;
                        const x = r * Math.cos(theta);
                        const y = r * Math.sin(theta);
                        const label = r < 0.5 ? 0 : 1;
                        this.dataset.push({ x, y, label });
                    }
                } else if (type === 'spiral') {
                    for (let i = 0; i < n/2; i++) {
                        const r = i / (n/2) * 0.8;
                        const t = i / (n/2) * Math.PI * 3;
                        this.dataset.push({
                            x: r * Math.cos(t),
                            y: r * Math.sin(t),
                            label: 0
                        });
                        this.dataset.push({
                            x: r * Math.cos(t + Math.PI),
                            y: r * Math.sin(t + Math.PI),
                            label: 1
                        });
                    }
                } else if (type === 'gaussian') {
                    for (let i = 0; i < n/2; i++) {
                        const x1 = (Math.random() + Math.random() + Math.random() + Math.random() - 2) * 0.3 - 0.5;
                        const y1 = (Math.random() + Math.random() + Math.random() + Math.random() - 2) * 0.3 - 0.5;
                        const x2 = (Math.random() + Math.random() + Math.random() + Math.random() - 2) * 0.3 + 0.5;
                        const y2 = (Math.random() + Math.random() + Math.random() + Math.random() - 2) * 0.3 + 0.5;
                        this.dataset.push({ x: x1, y: y1, label: 0 });
                        this.dataset.push({ x: x2, y: y2, label: 1 });
                    }
                }

                this.splitDataset();
                this.updateStats();
                this.render();
            }

            clearDataset() {
                this.dataset = [];
                this.trainData = [];
                this.testData = [];
                this.updateStats();
                this.render();
            }

            updateNeurons(value) {
                document.getElementById('neuronDisplay').textContent = value;
                document.getElementById('archNeurons').textContent = value;
                this.network.hiddenSize = parseInt(value);
                this.network.initializeWeights();
                this.epoch = 0;
                this.lossHistory = [];
            }

            updateActivation(value) {
                document.getElementById('archActivation').textContent = value;
                this.network.activation = value;
                this.network.initializeWeights();
                this.epoch = 0;
                this.lossHistory = [];
            }

            updateLearningRate(value) {
                const lr = Math.pow(10, parseFloat(value));
                document.getElementById('lrDisplay').textContent = lr.toFixed(3);
                this.network.learningRate = lr;
            }

            toggleTraining() {
                this.isTraining = !this.isTraining;
                const btn = document.getElementById('trainBtn');
                if (this.isTraining) {
                    btn.textContent = '‚è∏Ô∏è Pause Training';
                    btn.classList.add('training');
                } else {
                    btn.textContent = '‚ñ∂Ô∏è Start Training';
                    btn.classList.remove('training');
                }
            }

            stepTraining() {
                if (this.trainData.length === 0) return;

                let totalLoss = 0;
                for (let i = 0; i < this.trainData.length; i++) {
                    const point = this.trainData[i];
                    const loss = this.network.train([point.x, point.y], point.label);
                    totalLoss += loss;
                }

                this.epoch++;
                const avgLoss = totalLoss / this.trainData.length;
                this.lossHistory.push(avgLoss);
                if (this.lossHistory.length > 100) this.lossHistory.shift();

                this.updateStats();
                this.renderLossChart();
            }

            resetNetwork() {
                this.network.initializeWeights();
                this.epoch = 0;
                this.lossHistory = [];
                this.isTraining = false;
                document.getElementById('trainBtn').textContent = '‚ñ∂Ô∏è Start Training';
                document.getElementById('trainBtn').classList.remove('training');
                this.updateStats();
                this.render();
            }

            updateStats() {
                document.getElementById('epochDisplay').textContent = this.epoch;
                document.getElementById('pointsDisplay').textContent = this.dataset.length;

                if (this.testData.length > 0) {
                    let correct = 0;
                    for (const point of this.testData) {
                        const pred = this.network.forward([point.x, point.y]).output;
                        if ((pred > 0.5 ? 1 : 0) === point.label) correct++;
                    }
                    const accuracy = (correct / this.testData.length * 100).toFixed(1);
                    document.getElementById('accuracyDisplay').textContent = accuracy + '%';
                }

                if (this.lossHistory.length > 0) {
                    const loss = this.lossHistory[this.lossHistory.length - 1];
                    document.getElementById('lossDisplay').textContent = loss.toFixed(3);
                }
            }

            render() {
                const ctx = this.ctx;
                const w = this.canvas.width;
                const h = this.canvas.height;

                // Clear
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, w, h);

                // Grid
                ctx.strokeStyle = '#f0f0f0';
                ctx.lineWidth = 1;
                for (let i = 0; i <= 10; i++) {
                    const x = i * w / 10;
                    const y = i * h / 10;
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, h);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(w, y);
                    ctx.stroke();
                }

                // Decision boundary
                if (this.dataset.length > 0 && this.epoch > 0) {
                    const resolution = 40;
                    for (let i = 0; i < resolution; i++) {
                        for (let j = 0; j < resolution; j++) {
                            const x = (i / resolution) * 2 - 1;
                            const y = 1 - (j / resolution) * 2;
                            const pred = this.network.forward([x, y]).output;

                            const px = (x + 1) / 2 * w;
                            const py = (1 - y) / 2 * h;
                            const size = w / resolution;

                            ctx.fillStyle = pred > 0.5
                                ? `rgba(59, 130, 246, ${pred * 0.15})`
                                : `rgba(239, 68, 68, ${(1-pred) * 0.15})`;
                            ctx.fillRect(px, py, size, size);
                        }
                    }
                }

                // Test points (hollow)
                for (const point of this.testData) {
                    const px = (point.x + 1) / 2 * w;
                    const py = (1 - point.y) / 2 * h;

                    ctx.strokeStyle = point.label === 1 ? '#3b82f6' : '#ef4444';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(px, py, 5, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Train points (filled)
                for (const point of this.trainData) {
                    const px = (point.x + 1) / 2 * w;
                    const py = (1 - point.y) / 2 * h;

                    ctx.fillStyle = point.label === 1 ? '#3b82f6' : '#ef4444';
                    ctx.beginPath();
                    ctx.arc(px, py, 5, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            renderLossChart() {
                const ctx = this.lossCtx;
                const w = this.lossCanvas.width;
                const h = this.lossCanvas.height;

                ctx.clearRect(0, 0, w, h);

                if (this.lossHistory.length < 2) return;

                const maxLoss = Math.max(...this.lossHistory, 0.1);
                const minLoss = 0;

                ctx.strokeStyle = '#667eea';
                ctx.lineWidth = 2;
                ctx.beginPath();

                for (let i = 0; i < this.lossHistory.length; i++) {
                    const x = (i / (this.lossHistory.length - 1)) * (w - 20) + 10;
                    const y = h - 10 - ((this.lossHistory[i] - minLoss) / (maxLoss - minLoss)) * (h - 20);

                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();

                // Axes
                ctx.strokeStyle = '#d1d5db';
                ctx.lineWidth = 1;
                ctx.strokeRect(10, 10, w - 20, h - 20);
            }

            animate() {
                if (this.isTraining && this.trainData.length > 0) {
                    this.stepTraining();
                    this.render();
                }
                requestAnimationFrame(() => this.animate());
            }
        }

        const app = new App();
    </script>
</body>
</html>
