<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mind Palace 3D - Walk Through Your Ideas</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0a0a0f;
            color: #e0e0e0;
            overflow: hidden;
            height: 100vh;
        }

        #canvas-container {
            width: 100%;
            height: 100%;
            position: relative;
        }

        canvas { display: block; }

        /* Crosshair */
        .crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 100;
        }

        .crosshair::before,
        .crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.7);
        }

        .crosshair::before {
            width: 2px;
            height: 100%;
            left: 50%;
            transform: translateX(-50%);
        }

        .crosshair::after {
            width: 100%;
            height: 2px;
            top: 50%;
            transform: translateY(-50%);
        }

        /* ========================================
           COMPACT ICON TOOLBAR (Consensus: 5/8)
           ======================================== */
        .toolbar {
            position: fixed;
            top: 12px;
            right: 12px;
            display: flex;
            gap: 6px;
            z-index: 300;
        }

        .tool-btn {
            width: 40px;
            height: 40px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 10px;
            color: white;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            backdrop-filter: blur(10px);
            position: relative;
        }

        .tool-btn:hover {
            background: rgba(99, 102, 241, 0.4);
            border-color: rgba(99, 102, 241, 0.6);
            transform: translateY(-2px);
        }

        .tool-btn .tooltip {
            position: absolute;
            bottom: -32px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 4px 10px;
            border-radius: 6px;
            font-size: 11px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
        }

        .tool-btn:hover .tooltip {
            opacity: 1;
        }

        /* Help dropdown */
        .help-dropdown {
            position: absolute;
            top: 48px;
            right: 0;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 12px 16px;
            font-size: 12px;
            line-height: 1.8;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transform: translateY(-10px);
            transition: all 0.2s;
            backdrop-filter: blur(15px);
        }

        .tool-btn:hover .help-dropdown {
            opacity: 1;
            pointer-events: auto;
            transform: translateY(0);
        }

        .help-dropdown kbd {
            background: rgba(255, 255, 255, 0.15);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
            margin-right: 8px;
        }

        /* ========================================
           COMMAND PALETTE (Consensus: 6/8)
           ======================================== */
        .command-palette {
            position: fixed;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            width: 500px;
            max-width: 90vw;
            background: rgba(15, 15, 25, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 16px;
            backdrop-filter: blur(20px);
            box-shadow: 0 25px 60px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            display: none;
            overflow: hidden;
        }

        .command-palette.active {
            display: block;
        }

        .command-input {
            width: 100%;
            padding: 16px 20px;
            background: transparent;
            border: none;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 16px;
            outline: none;
        }

        .command-input::placeholder {
            color: #666;
        }

        .command-results {
            max-height: 300px;
            overflow-y: auto;
        }

        .command-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 20px;
            cursor: pointer;
            transition: background 0.15s;
        }

        .command-item:hover,
        .command-item.selected {
            background: rgba(99, 102, 241, 0.3);
        }

        .command-item .label {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .command-item .icon {
            width: 24px;
            text-align: center;
        }

        .command-item .shortcut {
            color: #666;
            font-size: 12px;
            font-family: monospace;
        }

        .command-hint {
            padding: 10px 20px;
            font-size: 11px;
            color: #555;
            border-top: 1px solid rgba(255, 255, 255, 0.05);
        }

        /* ========================================
           SLIDE-IN SIDE PANEL (Consensus: 5/8)
           ======================================== */
        .side-panel {
            position: fixed;
            top: 0;
            right: 0;
            width: 320px;
            height: 100vh;
            background: rgba(15, 15, 25, 0.95);
            border-left: 1px solid rgba(255, 255, 255, 0.1);
            transform: translateX(100%);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 500;
            backdrop-filter: blur(20px);
            display: flex;
            flex-direction: column;
        }

        .side-panel.open {
            transform: translateX(0);
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .panel-header h3 {
            font-size: 16px;
            font-weight: 600;
        }

        .panel-close {
            width: 32px;
            height: 32px;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .panel-close:hover {
            background: rgba(239, 68, 68, 0.5);
        }

        .panel-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }

        .panel-section {
            margin-bottom: 20px;
        }

        .panel-section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            cursor: pointer;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .panel-section-header h4 {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #888;
        }

        .panel-section-header .chevron {
            transition: transform 0.2s;
        }

        .panel-section.collapsed .chevron {
            transform: rotate(-90deg);
        }

        .panel-section.collapsed .panel-section-content {
            display: none;
        }

        .panel-section-content {
            padding-top: 12px;
        }

        .panel-input {
            width: 100%;
            padding: 10px 12px;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 8px;
            color: white;
            font-size: 14px;
            margin-bottom: 12px;
        }

        .panel-input:focus {
            outline: none;
            border-color: rgba(99, 102, 241, 0.5);
        }

        .panel-textarea {
            min-height: 60px;
            resize: vertical;
        }

        /* Color chips in panel */
        .color-chips {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }

        .color-chip {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s;
        }

        .color-chip:hover {
            transform: scale(1.15);
        }

        .color-chip.selected {
            border-color: white;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        }

        /* Connection chips */
        .connection-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .connection-chip {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .connection-chip:hover {
            background: rgba(99, 102, 241, 0.3);
        }

        .connection-chip.connected {
            background: rgba(99, 102, 241, 0.4);
            border: 1px solid rgba(99, 102, 241, 0.6);
        }

        .connection-chip .dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        .panel-footer {
            padding: 16px 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            gap: 10px;
        }

        .panel-footer button {
            flex: 1;
            padding: 10px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .btn-save {
            background: linear-gradient(135deg, #6366f1, #8b5cf6);
            color: white;
        }

        .btn-save:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(99, 102, 241, 0.4);
        }

        .btn-delete {
            background: rgba(239, 68, 68, 0.3);
            color: #ef4444;
            flex: 0.5;
        }

        .btn-delete:hover {
            background: rgba(239, 68, 68, 0.5);
        }

        /* ========================================
           ROOM INFO - PROGRESSIVE DISCLOSURE (Consensus: 6/8)
           ======================================== */
        .room-badge {
            position: fixed;
            bottom: 16px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border-radius: 30px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 200;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            max-width: 90vw;
        }

        .room-badge.hidden {
            opacity: 0;
            pointer-events: none;
            transform: translateX(-50%) translateY(20px);
        }

        .room-badge .room-name {
            font-size: 14px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .room-badge .room-color {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        .room-badge .expand-hint {
            font-size: 10px;
            color: #666;
            margin-top: 2px;
        }

        .room-badge .room-details {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s, margin 0.3s, opacity 0.3s;
            opacity: 0;
        }

        .room-badge:hover .room-details,
        .room-badge.expanded .room-details {
            max-height: 150px;
            margin-top: 10px;
            opacity: 1;
        }

        .room-badge .room-desc {
            font-size: 12px;
            color: #aaa;
            margin-bottom: 8px;
        }

        .room-badge .room-connections {
            font-size: 11px;
            color: #666;
        }

        /* ========================================
           COLLAPSIBLE MINIMAP (Consensus: 7/8)
           ======================================== */
        .minimap {
            position: fixed;
            bottom: 16px;
            right: 16px;
            width: 44px;
            height: 44px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            overflow: hidden;
            z-index: 200;
            backdrop-filter: blur(10px);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
        }

        .minimap:hover,
        .minimap.expanded {
            width: 180px;
            height: 180px;
        }

        .minimap canvas {
            width: 100%;
            height: 100%;
            opacity: 0.3;
            transition: opacity 0.3s;
        }

        .minimap:hover canvas,
        .minimap.expanded canvas {
            opacity: 1;
        }

        .minimap .map-icon {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 20px;
            transition: opacity 0.3s;
        }

        .minimap:hover .map-icon,
        .minimap.expanded .map-icon {
            opacity: 0;
        }

        /* ========================================
           SIMPLIFIED START SCREEN (Consensus: 6/8)
           ======================================== */
        .start-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            text-align: center;
            padding: 20px;
        }

        .start-screen.hidden {
            display: none;
        }

        .start-screen h1 {
            font-size: 56px;
            margin-bottom: 8px;
            background: linear-gradient(135deg, #6366f1, #8b5cf6, #a855f7);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .start-screen .subtitle {
            font-size: 18px;
            color: #666;
            margin-bottom: 50px;
        }

        .start-button {
            padding: 18px 50px;
            font-size: 18px;
            background: linear-gradient(135deg, #6366f1, #8b5cf6);
            border: none;
            border-radius: 30px;
            color: white;
            cursor: pointer;
            transition: all 0.3s;
        }

        .start-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 40px rgba(99, 102, 241, 0.4);
        }

        .start-hint {
            margin-top: 30px;
            font-size: 12px;
            color: #444;
        }

        .start-hint kbd {
            background: rgba(255, 255, 255, 0.1);
            padding: 3px 8px;
            border-radius: 4px;
            margin: 0 2px;
        }

        /* Hidden file input */
        #importFile { display: none; }

        /* Responsive */
        @media (max-width: 768px) {
            .toolbar {
                top: auto;
                bottom: 70px;
                right: 16px;
            }

            .side-panel {
                width: 100%;
            }

            .command-palette {
                width: 95vw;
                top: 10%;
            }

            .start-screen h1 {
                font-size: 36px;
            }
        }
    </style>
</head>
<body>
    <!-- Simplified Start Screen -->
    <div class="start-screen" id="startScreen">
        <h1>Mind Palace 3D</h1>
        <p class="subtitle">Walk through your ideas like a museum</p>
        <button class="start-button" onclick="enterPalace()">Enter Palace</button>
        <p class="start-hint">
            <kbd>WASD</kbd> move <kbd>Mouse</kbd> look <kbd>/</kbd> commands
        </p>
    </div>

    <!-- Main Canvas -->
    <div id="canvas-container"></div>
    <div class="crosshair"></div>

    <!-- Compact Icon Toolbar -->
    <div class="toolbar">
        <button class="tool-btn" onclick="openCommandPalette()" title="Commands">
            /
            <span class="tooltip">Commands (/)</span>
        </button>
        <button class="tool-btn" onclick="openNewRoomPanel()">
            +
            <span class="tooltip">New Room (N)</span>
        </button>
        <button class="tool-btn" onclick="exportData()">
            <span style="font-size: 14px;">&#8595;</span>
            <span class="tooltip">Export</span>
        </button>
        <button class="tool-btn" onclick="document.getElementById('importFile').click()">
            <span style="font-size: 14px;">&#8593;</span>
            <span class="tooltip">Import</span>
        </button>
        <button class="tool-btn">
            ?
            <div class="help-dropdown">
                <div><kbd>WASD</kbd> Move around</div>
                <div><kbd>Mouse</kbd> Look around</div>
                <div><kbd>/</kbd> Open commands</div>
                <div><kbd>E</kbd> Edit current room</div>
                <div><kbd>N</kbd> Create new room</div>
                <div><kbd>M</kbd> Toggle minimap</div>
                <div><kbd>ESC</kbd> Unlock cursor</div>
            </div>
        </button>
    </div>
    <input type="file" id="importFile" accept=".json" onchange="importData(event)">

    <!-- Command Palette -->
    <div class="command-palette" id="commandPalette">
        <input type="text" class="command-input" id="commandInput"
               placeholder="Type a command or search rooms..."
               oninput="filterCommands()" onkeydown="handleCommandKey(event)">
        <div class="command-results" id="commandResults"></div>
        <div class="command-hint">&#8593;&#8595; navigate &bull; Enter select &bull; Esc close</div>
    </div>

    <!-- Slide-in Side Panel -->
    <div class="side-panel" id="sidePanel">
        <div class="panel-header">
            <h3 id="panelTitle">Edit Room</h3>
            <button class="panel-close" onclick="closeSidePanel()">&times;</button>
        </div>
        <div class="panel-content">
            <div class="panel-section">
                <div class="panel-section-header" onclick="toggleSection(this)">
                    <h4>Details</h4>
                    <span class="chevron">&#9662;</span>
                </div>
                <div class="panel-section-content">
                    <input type="text" class="panel-input" id="roomNameInput" placeholder="Room name">
                    <textarea class="panel-input panel-textarea" id="roomDescInput" placeholder="Description (optional)"></textarea>
                </div>
            </div>

            <div class="panel-section">
                <div class="panel-section-header" onclick="toggleSection(this)">
                    <h4>Color</h4>
                    <span class="chevron">&#9662;</span>
                </div>
                <div class="panel-section-content">
                    <div class="color-chips" id="colorChips"></div>
                </div>
            </div>

            <div class="panel-section">
                <div class="panel-section-header" onclick="toggleSection(this)">
                    <h4>Connections</h4>
                    <span class="chevron">&#9662;</span>
                </div>
                <div class="panel-section-content">
                    <div class="connection-chips" id="connectionChips"></div>
                </div>
            </div>
        </div>
        <div class="panel-footer">
            <button class="btn-delete" id="deleteRoomBtn" onclick="deleteCurrentRoom()">Delete</button>
            <button class="btn-save" onclick="saveRoom()">Save</button>
        </div>
    </div>

    <!-- Room Badge (Progressive Disclosure) -->
    <div class="room-badge hidden" id="roomBadge">
        <div class="room-name">
            <span class="room-color" id="badgeColor"></span>
            <span id="badgeTitle">Room</span>
        </div>
        <div class="expand-hint">hover for details</div>
        <div class="room-details">
            <div class="room-desc" id="badgeDesc"></div>
            <div class="room-connections" id="badgeConnections"></div>
        </div>
    </div>

    <!-- Collapsible Minimap -->
    <div class="minimap" id="minimap" onclick="toggleMinimap()">
        <span class="map-icon">&#9673;</span>
        <canvas id="minimapCanvas"></canvas>
    </div>

    <script>
        const APP_NAME = 'mind-palace-3d';

        const ROOM_COLORS = [
            { name: 'Indigo', hex: '#6366f1', rgb: [0.39, 0.4, 0.95] },
            { name: 'Purple', hex: '#8b5cf6', rgb: [0.55, 0.36, 0.96] },
            { name: 'Pink', hex: '#ec4899', rgb: [0.93, 0.28, 0.6] },
            { name: 'Red', hex: '#ef4444', rgb: [0.94, 0.27, 0.27] },
            { name: 'Orange', hex: '#f97316', rgb: [0.98, 0.45, 0.09] },
            { name: 'Amber', hex: '#f59e0b', rgb: [0.96, 0.62, 0.04] },
            { name: 'Green', hex: '#22c55e', rgb: [0.13, 0.77, 0.37] },
            { name: 'Teal', hex: '#14b8a6', rgb: [0.08, 0.72, 0.65] },
            { name: 'Cyan', hex: '#06b6d4', rgb: [0.02, 0.71, 0.83] },
            { name: 'Blue', hex: '#3b82f6', rgb: [0.23, 0.51, 0.96] }
        ];

        const defaultPalaceData = {
            rooms: [
                { id: 'lobby', name: 'The Lobby', description: 'Your central hub - where all ideas begin', x: 0, y: 0, z: 0, color: 0, connections: ['ideas', 'projects'], objects: [] },
                { id: 'ideas', name: 'Idea Chamber', description: 'Raw concepts and brainstorms', x: 30, y: 0, z: 0, color: 1, connections: ['lobby'], objects: [] },
                { id: 'projects', name: 'Project Vault', description: 'Active works in progress', x: 0, y: 0, z: 30, color: 4, connections: ['lobby'], objects: [] }
            ],
            lastVisited: 'lobby',
            created: Date.now()
        };

        let palaceData = JSON.parse(localStorage.getItem(APP_NAME)) || defaultPalaceData;

        function saveData() { localStorage.setItem(APP_NAME, JSON.stringify(palaceData)); }

        function exportData() {
            const dataStr = JSON.stringify(palaceData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `${APP_NAME}-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);
        }

        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const imported = JSON.parse(e.target.result);
                    if (imported.rooms && Array.isArray(imported.rooms)) {
                        palaceData = imported;
                        saveData();
                        location.reload();
                    } else {
                        alert('Invalid palace data format');
                    }
                } catch (error) {
                    alert('Invalid JSON file');
                }
            };
            reader.readAsText(file);
        }

        // ============================================
        // WebGL 3D Engine
        // ============================================
        let canvas, gl;
        let camera = { x: 0, y: 1.7, z: 5, rx: 0, ry: 0 };
        let velocity = { x: 0, z: 0 };
        let keys = {};
        let isPointerLocked = false;
        let currentRoom = null;
        let editingRoom = null;
        let selectedColor = 0;
        let selectedConnections = [];
        let commandSelectedIndex = 0;

        const ROOM_SIZE = 12;
        const WALL_HEIGHT = 4;
        const HALLWAY_WIDTH = 3;
        const HALLWAY_LENGTH = 8;

        function mat4Perspective(fov, aspect, near, far) {
            const f = 1.0 / Math.tan(fov / 2);
            return new Float32Array([f / aspect, 0, 0, 0, 0, f, 0, 0, 0, 0, (far + near) / (near - far), -1, 0, 0, (2 * far * near) / (near - far), 0]);
        }

        function mat4LookAt(eye, target, up) {
            const zx = eye[0] - target[0], zy = eye[1] - target[1], zz = eye[2] - target[2];
            const zl = Math.sqrt(zx*zx + zy*zy + zz*zz);
            const z = [zx/zl, zy/zl, zz/zl];
            const xx = up[1]*z[2] - up[2]*z[1], xy = up[2]*z[0] - up[0]*z[2], xz = up[0]*z[1] - up[1]*z[0];
            const xl = Math.sqrt(xx*xx + xy*xy + xz*xz);
            const x = [xx/xl, xy/xl, xz/xl];
            const y = [z[1]*x[2] - z[2]*x[1], z[2]*x[0] - z[0]*x[2], z[0]*x[1] - z[1]*x[0]];
            return new Float32Array([x[0], y[0], z[0], 0, x[1], y[1], z[1], 0, x[2], y[2], z[2], 0, -(x[0]*eye[0] + x[1]*eye[1] + x[2]*eye[2]), -(y[0]*eye[0] + y[1]*eye[1] + y[2]*eye[2]), -(z[0]*eye[0] + z[1]*eye[1] + z[2]*eye[2]), 1]);
        }

        const vertexShaderSource = `
            attribute vec3 aPosition; attribute vec3 aNormal; attribute vec3 aColor;
            uniform mat4 uProjection; uniform mat4 uView; uniform mat4 uModel;
            varying vec3 vColor; varying vec3 vNormal; varying vec3 vPosition;
            void main() {
                vec4 worldPos = uModel * vec4(aPosition, 1.0);
                gl_Position = uProjection * uView * worldPos;
                vColor = aColor; vNormal = mat3(uModel) * aNormal; vPosition = worldPos.xyz;
            }`;

        const fragmentShaderSource = `
            precision mediump float;
            varying vec3 vColor; varying vec3 vNormal; varying vec3 vPosition;
            uniform vec3 uLightPos; uniform vec3 uCameraPos; uniform float uAmbient; uniform float uFogDensity; uniform vec3 uFogColor;
            void main() {
                vec3 normal = normalize(vNormal);
                vec3 lightDir = normalize(uLightPos - vPosition);
                float diff = max(dot(normal, lightDir), 0.0);
                vec3 lighting = vColor * (uAmbient + diff * 0.6);
                float dist = length(uCameraPos - vPosition);
                float fog = 1.0 - exp(-uFogDensity * dist);
                gl_FragColor = vec4(mix(lighting, uFogColor, fog), 1.0);
            }`;

        function createCube(w, h, d, color) {
            const hw = w/2, hh = h/2, hd = d/2, c = color;
            const vertices = [], normals = [], colors = [];
            vertices.push(-hw,-hh,hd, hw,-hh,hd, hw,hh,hd, -hw,-hh,hd, hw,hh,hd, -hw,hh,hd);
            for(let i=0;i<6;i++) { normals.push(0,0,1); colors.push(...c); }
            vertices.push(hw,-hh,-hd, -hw,-hh,-hd, -hw,hh,-hd, hw,-hh,-hd, -hw,hh,-hd, hw,hh,-hd);
            for(let i=0;i<6;i++) { normals.push(0,0,-1); colors.push(...c); }
            vertices.push(hw,-hh,hd, hw,-hh,-hd, hw,hh,-hd, hw,-hh,hd, hw,hh,-hd, hw,hh,hd);
            for(let i=0;i<6;i++) { normals.push(1,0,0); colors.push(...c); }
            vertices.push(-hw,-hh,-hd, -hw,-hh,hd, -hw,hh,hd, -hw,-hh,-hd, -hw,hh,hd, -hw,hh,-hd);
            for(let i=0;i<6;i++) { normals.push(-1,0,0); colors.push(...c); }
            vertices.push(-hw,hh,hd, hw,hh,hd, hw,hh,-hd, -hw,hh,hd, hw,hh,-hd, -hw,hh,-hd);
            for(let i=0;i<6;i++) { normals.push(0,1,0); colors.push(...c); }
            vertices.push(-hw,-hh,-hd, hw,-hh,-hd, hw,-hh,hd, -hw,-hh,-hd, hw,-hh,hd, -hw,-hh,hd);
            for(let i=0;i<6;i++) { normals.push(0,-1,0); colors.push(...c); }
            return { vertices: new Float32Array(vertices), normals: new Float32Array(normals), colors: new Float32Array(colors) };
        }

        function createFloor(w, d, color) {
            const hw = w/2, hd = d/2;
            return {
                vertices: new Float32Array([-hw, 0, hd, hw, 0, hd, hw, 0, -hd, -hw, 0, hd, hw, 0, -hd, -hw, 0, -hd]),
                normals: new Float32Array([0,1,0, 0,1,0, 0,1,0, 0,1,0, 0,1,0, 0,1,0]),
                colors: new Float32Array([...color,...color,...color,...color,...color,...color])
            };
        }

        function createWall(w, h, color) {
            const hw = w/2;
            return {
                vertices: new Float32Array([-hw, 0, 0, hw, 0, 0, hw, h, 0, -hw, 0, 0, hw, h, 0, -hw, h, 0]),
                normals: new Float32Array([0,0,1, 0,0,1, 0,0,1, 0,0,1, 0,0,1, 0,0,1]),
                colors: new Float32Array([...color,...color,...color,...color,...color,...color])
            };
        }

        let meshes = [];
        let shaderProgram;
        let projectionMatrix;

        function initWebGL() {
            canvas = document.createElement('canvas');
            document.getElementById('canvas-container').appendChild(canvas);
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            if (!gl) { alert('WebGL not supported'); return; }
            gl.enable(gl.DEPTH_TEST);
            gl.enable(gl.CULL_FACE);
            gl.cullFace(gl.BACK);

            const vertShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vertShader, vertexShaderSource);
            gl.compileShader(vertShader);

            const fragShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragShader, fragmentShaderSource);
            gl.compileShader(fragShader);

            shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertShader);
            gl.attachShader(shaderProgram, fragShader);
            gl.linkProgram(shaderProgram);
            gl.useProgram(shaderProgram);

            shaderProgram.aPosition = gl.getAttribLocation(shaderProgram, 'aPosition');
            shaderProgram.aNormal = gl.getAttribLocation(shaderProgram, 'aNormal');
            shaderProgram.aColor = gl.getAttribLocation(shaderProgram, 'aColor');
            shaderProgram.uProjection = gl.getUniformLocation(shaderProgram, 'uProjection');
            shaderProgram.uView = gl.getUniformLocation(shaderProgram, 'uView');
            shaderProgram.uModel = gl.getUniformLocation(shaderProgram, 'uModel');
            shaderProgram.uLightPos = gl.getUniformLocation(shaderProgram, 'uLightPos');
            shaderProgram.uCameraPos = gl.getUniformLocation(shaderProgram, 'uCameraPos');
            shaderProgram.uAmbient = gl.getUniformLocation(shaderProgram, 'uAmbient');
            shaderProgram.uFogDensity = gl.getUniformLocation(shaderProgram, 'uFogDensity');
            shaderProgram.uFogColor = gl.getUniformLocation(shaderProgram, 'uFogColor');

            gl.enableVertexAttribArray(shaderProgram.aPosition);
            gl.enableVertexAttribArray(shaderProgram.aNormal);
            gl.enableVertexAttribArray(shaderProgram.aColor);

            projectionMatrix = mat4Perspective(Math.PI / 3, canvas.width / canvas.height, 0.1, 200);
            gl.uniformMatrix4fv(shaderProgram.uProjection, false, projectionMatrix);
            gl.uniform3f(shaderProgram.uLightPos, 0, 20, 0);
            gl.uniform1f(shaderProgram.uAmbient, 0.3);
            gl.uniform1f(shaderProgram.uFogDensity, 0.015);
            gl.uniform3f(shaderProgram.uFogColor, 0.04, 0.04, 0.06);

            buildPalaceGeometry();
        }

        function createMesh(geometry, x, y, z) {
            const mesh = {
                vertexBuffer: gl.createBuffer(),
                normalBuffer: gl.createBuffer(),
                colorBuffer: gl.createBuffer(),
                vertexCount: geometry.vertices.length / 3,
                position: [x || 0, y || 0, z || 0]
            };
            gl.bindBuffer(gl.ARRAY_BUFFER, mesh.vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, geometry.vertices, gl.STATIC_DRAW);
            gl.bindBuffer(gl.ARRAY_BUFFER, mesh.normalBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, geometry.normals, gl.STATIC_DRAW);
            gl.bindBuffer(gl.ARRAY_BUFFER, mesh.colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, geometry.colors, gl.STATIC_DRAW);
            return mesh;
        }

        function createMeshWithTransform(geometry, x, y, z, rotation) {
            const mesh = createMesh(geometry, 0, 0, 0);
            mesh.position = [x, y, z];
            mesh.rotation = rotation || 0;
            return mesh;
        }

        function buildPalaceGeometry() {
            meshes = [];
            const floorColor = [0.08, 0.08, 0.1];

            palaceData.rooms.forEach(room => {
                const roomColor = ROOM_COLORS[room.color || 0].rgb;
                const wallColor = roomColor.map(c => c * 0.4);
                meshes.push(createMesh(createFloor(ROOM_SIZE, ROOM_SIZE, floorColor), room.x, 0, room.z));
                const ceilingColor = roomColor.map(c => c * 0.15);
                meshes.push(createMesh(createFloor(ROOM_SIZE, ROOM_SIZE, ceilingColor), room.x, WALL_HEIGHT, room.z));

                const doorways = { north: false, south: false, east: false, west: false };
                room.connections.forEach(connId => {
                    const connRoom = palaceData.rooms.find(r => r.id === connId);
                    if (!connRoom) return;
                    const dx = connRoom.x - room.x, dz = connRoom.z - room.z;
                    if (Math.abs(dx) > Math.abs(dz)) { if (dx > 0) doorways.east = true; else doorways.west = true; }
                    else { if (dz > 0) doorways.south = true; else doorways.north = true; }
                });

                const hs = ROOM_SIZE / 2, dw = HALLWAY_WIDTH / 2;
                if (!doorways.north) meshes.push(createMeshWithTransform(createWall(ROOM_SIZE, WALL_HEIGHT, wallColor), room.x, 0, room.z - hs, 0));
                else { meshes.push(createMeshWithTransform(createWall(hs - dw, WALL_HEIGHT, wallColor), room.x - (hs + dw) / 2, 0, room.z - hs, 0)); meshes.push(createMeshWithTransform(createWall(hs - dw, WALL_HEIGHT, wallColor), room.x + (hs + dw) / 2, 0, room.z - hs, 0)); }
                if (!doorways.south) meshes.push(createMeshWithTransform(createWall(ROOM_SIZE, WALL_HEIGHT, wallColor), room.x, 0, room.z + hs, Math.PI));
                else { meshes.push(createMeshWithTransform(createWall(hs - dw, WALL_HEIGHT, wallColor), room.x - (hs + dw) / 2, 0, room.z + hs, Math.PI)); meshes.push(createMeshWithTransform(createWall(hs - dw, WALL_HEIGHT, wallColor), room.x + (hs + dw) / 2, 0, room.z + hs, Math.PI)); }
                if (!doorways.east) meshes.push(createMeshWithTransform(createWall(ROOM_SIZE, WALL_HEIGHT, wallColor), room.x + hs, 0, room.z, -Math.PI / 2));
                else { meshes.push(createMeshWithTransform(createWall(hs - dw, WALL_HEIGHT, wallColor), room.x + hs, 0, room.z - (hs + dw) / 2, -Math.PI / 2)); meshes.push(createMeshWithTransform(createWall(hs - dw, WALL_HEIGHT, wallColor), room.x + hs, 0, room.z + (hs + dw) / 2, -Math.PI / 2)); }
                if (!doorways.west) meshes.push(createMeshWithTransform(createWall(ROOM_SIZE, WALL_HEIGHT, wallColor), room.x - hs, 0, room.z, Math.PI / 2));
                else { meshes.push(createMeshWithTransform(createWall(hs - dw, WALL_HEIGHT, wallColor), room.x - hs, 0, room.z - (hs + dw) / 2, Math.PI / 2)); meshes.push(createMeshWithTransform(createWall(hs - dw, WALL_HEIGHT, wallColor), room.x - hs, 0, room.z + (hs + dw) / 2, Math.PI / 2)); }

                meshes.push(createMesh(createCube(0.8, 0.1, 0.8, roomColor), room.x, 0.05, room.z));
                meshes.push(createMesh(createCube(0.4, 0.6, 0.4, roomColor.map(c => c * 0.7)), room.x, 0.35, room.z));
            });

            const builtHallways = new Set();
            palaceData.rooms.forEach(room => {
                room.connections.forEach(connId => {
                    const hallwayKey = [room.id, connId].sort().join('-');
                    if (builtHallways.has(hallwayKey)) return;
                    builtHallways.add(hallwayKey);
                    const connRoom = palaceData.rooms.find(r => r.id === connId);
                    if (!connRoom) return;
                    const color1 = ROOM_COLORS[room.color || 0].rgb;
                    const color2 = ROOM_COLORS[connRoom.color || 0].rgb;
                    const hallwayColor = color1.map((c, i) => (c + color2[i]) / 2 * 0.3);
                    const mx = (room.x + connRoom.x) / 2, mz = (room.z + connRoom.z) / 2;
                    const dx = connRoom.x - room.x, dz = connRoom.z - room.z;
                    const length = Math.sqrt(dx * dx + dz * dz) - ROOM_SIZE;
                    const angle = Math.atan2(dx, dz);
                    meshes.push(createMeshWithTransform(createFloor(HALLWAY_WIDTH, length, [0.08, 0.08, 0.1]), mx, 0, mz, angle));
                    meshes.push(createMeshWithTransform(createFloor(HALLWAY_WIDTH, length, hallwayColor), mx, WALL_HEIGHT, mz, angle));
                    meshes.push(createMeshWithTransform(createWall(length, WALL_HEIGHT, hallwayColor), mx + Math.cos(angle) * HALLWAY_WIDTH / 2, 0, mz - Math.sin(angle) * HALLWAY_WIDTH / 2, angle + Math.PI / 2));
                    meshes.push(createMeshWithTransform(createWall(length, WALL_HEIGHT, hallwayColor), mx - Math.cos(angle) * HALLWAY_WIDTH / 2, 0, mz + Math.sin(angle) * HALLWAY_WIDTH / 2, angle - Math.PI / 2));
                });
            });
        }

        function getModelMatrix(mesh) {
            const cos = Math.cos(mesh.rotation || 0), sin = Math.sin(mesh.rotation || 0);
            const [tx, ty, tz] = mesh.position;
            return new Float32Array([cos, 0, -sin, 0, 0, 1, 0, 0, sin, 0, cos, 0, tx, ty, tz, 1]);
        }

        function render() {
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.clearColor(0.04, 0.04, 0.06, 1);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            const lookX = camera.x + Math.sin(camera.ry) * Math.cos(camera.rx);
            const lookY = camera.y + Math.sin(camera.rx);
            const lookZ = camera.z + Math.cos(camera.ry) * Math.cos(camera.rx);
            const viewMatrix = mat4LookAt([camera.x, camera.y, camera.z], [lookX, lookY, lookZ], [0, 1, 0]);
            gl.uniformMatrix4fv(shaderProgram.uView, false, viewMatrix);
            gl.uniform3f(shaderProgram.uCameraPos, camera.x, camera.y, camera.z);
            meshes.forEach(mesh => {
                gl.uniformMatrix4fv(shaderProgram.uModel, false, getModelMatrix(mesh));
                gl.bindBuffer(gl.ARRAY_BUFFER, mesh.vertexBuffer);
                gl.vertexAttribPointer(shaderProgram.aPosition, 3, gl.FLOAT, false, 0, 0);
                gl.bindBuffer(gl.ARRAY_BUFFER, mesh.normalBuffer);
                gl.vertexAttribPointer(shaderProgram.aNormal, 3, gl.FLOAT, false, 0, 0);
                gl.bindBuffer(gl.ARRAY_BUFFER, mesh.colorBuffer);
                gl.vertexAttribPointer(shaderProgram.aColor, 3, gl.FLOAT, false, 0, 0);
                gl.drawArrays(gl.TRIANGLES, 0, mesh.vertexCount);
            });
        }

        // ============================================
        // Movement & Controls
        // ============================================
        function updateMovement() {
            if (!isPointerLocked) return;
            const speed = 0.15, friction = 0.85;
            let moveX = 0, moveZ = 0;
            if (keys['w'] || keys['arrowup']) moveZ -= 1;
            if (keys['s'] || keys['arrowdown']) moveZ += 1;
            if (keys['a'] || keys['arrowleft']) moveX -= 1;
            if (keys['d'] || keys['arrowright']) moveX += 1;
            const sin = Math.sin(camera.ry), cos = Math.cos(camera.ry);
            velocity.x += (moveX * cos - moveZ * sin) * speed;
            velocity.z += (moveX * sin + moveZ * cos) * speed;
            velocity.x *= friction;
            velocity.z *= friction;
            const newX = camera.x + velocity.x, newZ = camera.z + velocity.z;
            if (isValidPosition(newX, newZ)) { camera.x = newX; camera.z = newZ; }
            else { if (isValidPosition(newX, camera.z)) camera.x = newX; else if (isValidPosition(camera.x, newZ)) camera.z = newZ; velocity.x *= 0.5; velocity.z *= 0.5; }
            updateCurrentRoom();
        }

        function isValidPosition(x, z) {
            const margin = 0.5;
            for (const room of palaceData.rooms) {
                const hs = ROOM_SIZE / 2 - margin;
                if (x >= room.x - hs && x <= room.x + hs && z >= room.z - hs && z <= room.z + hs) return true;
            }
            const builtHallways = new Set();
            for (const room of palaceData.rooms) {
                for (const connId of room.connections) {
                    const hallwayKey = [room.id, connId].sort().join('-');
                    if (builtHallways.has(hallwayKey)) continue;
                    builtHallways.add(hallwayKey);
                    const connRoom = palaceData.rooms.find(r => r.id === connId);
                    if (!connRoom) continue;
                    const mx = (room.x + connRoom.x) / 2, mz = (room.z + connRoom.z) / 2;
                    const dx = connRoom.x - room.x, dz = connRoom.z - room.z;
                    const length = Math.sqrt(dx * dx + dz * dz);
                    const angle = Math.atan2(dx, dz);
                    const cos = Math.cos(-angle), sin = Math.sin(-angle);
                    const localX = (x - mx) * cos - (z - mz) * sin;
                    const localZ = (x - mx) * sin + (z - mz) * cos;
                    if (Math.abs(localX) <= HALLWAY_WIDTH / 2 - margin && Math.abs(localZ) <= length / 2) return true;
                }
            }
            return false;
        }

        function updateCurrentRoom() {
            let closest = null, closestDist = Infinity;
            palaceData.rooms.forEach(room => {
                const dist = Math.sqrt((camera.x - room.x) ** 2 + (camera.z - room.z) ** 2);
                if (dist < closestDist) { closestDist = dist; closest = room; }
            });
            const badge = document.getElementById('roomBadge');
            if (closest && closestDist < ROOM_SIZE / 2 + 1) {
                if (currentRoom !== closest) { currentRoom = closest; palaceData.lastVisited = closest.id; saveData(); }
                document.getElementById('badgeTitle').textContent = closest.name;
                document.getElementById('badgeColor').style.background = ROOM_COLORS[closest.color || 0].hex;
                document.getElementById('badgeDesc').textContent = closest.description || '';
                const connections = closest.connections.map(id => palaceData.rooms.find(r => r.id === id)?.name).filter(Boolean);
                document.getElementById('badgeConnections').textContent = connections.length ? 'Connected: ' + connections.join(', ') : '';
                badge.classList.remove('hidden');
            } else {
                badge.classList.add('hidden');
                currentRoom = null;
            }
        }

        // ============================================
        // Minimap
        // ============================================
        function updateMinimap() {
            const minimapCanvas = document.getElementById('minimapCanvas');
            const ctx = minimapCanvas.getContext('2d');
            minimapCanvas.width = 180;
            minimapCanvas.height = 180;
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(0, 0, 180, 180);
            let minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;
            palaceData.rooms.forEach(room => { minX = Math.min(minX, room.x); maxX = Math.max(maxX, room.x); minZ = Math.min(minZ, room.z); maxZ = Math.max(maxZ, room.z); });
            const padding = 30, rangeX = Math.max(maxX - minX, 1), rangeZ = Math.max(maxZ - minZ, 1);
            const scale = Math.min((180 - padding * 2) / rangeX, (180 - padding * 2) / rangeZ, 3);
            const offsetX = 90 - (minX + maxX) / 2 * scale, offsetZ = 90 - (minZ + maxZ) / 2 * scale;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 2;
            const drawnConnections = new Set();
            palaceData.rooms.forEach(room => {
                room.connections.forEach(connId => {
                    const key = [room.id, connId].sort().join('-');
                    if (drawnConnections.has(key)) return;
                    drawnConnections.add(key);
                    const conn = palaceData.rooms.find(r => r.id === connId);
                    if (!conn) return;
                    ctx.beginPath();
                    ctx.moveTo(room.x * scale + offsetX, room.z * scale + offsetZ);
                    ctx.lineTo(conn.x * scale + offsetX, conn.z * scale + offsetZ);
                    ctx.stroke();
                });
            });
            palaceData.rooms.forEach(room => {
                const color = ROOM_COLORS[room.color || 0].hex;
                const x = room.x * scale + offsetX, z = room.z * scale + offsetZ;
                const size = ROOM_SIZE * scale / 2;
                ctx.fillStyle = room === currentRoom ? color : color + '80';
                ctx.fillRect(x - size/2, z - size/2, size, size);
                if (room === currentRoom) { ctx.strokeStyle = 'white'; ctx.lineWidth = 2; ctx.strokeRect(x - size/2, z - size/2, size, size); }
            });
            const px = camera.x * scale + offsetX, pz = camera.z * scale + offsetZ;
            ctx.save();
            ctx.translate(px, pz);
            ctx.rotate(-camera.ry);
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.moveTo(0, -6);
            ctx.lineTo(-4, 4);
            ctx.lineTo(4, 4);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }

        function toggleMinimap() {
            document.getElementById('minimap').classList.toggle('expanded');
        }

        // ============================================
        // Command Palette
        // ============================================
        const commands = [
            { id: 'new', icon: '+', label: 'New Room', shortcut: 'N', action: openNewRoomPanel },
            { id: 'edit', icon: '&#9998;', label: 'Edit Current Room', shortcut: 'E', action: openEditPanel },
            { id: 'export', icon: '&#8595;', label: 'Export Palace Data', action: exportData },
            { id: 'import', icon: '&#8593;', label: 'Import Palace Data', action: () => document.getElementById('importFile').click() },
            { id: 'map', icon: '&#9673;', label: 'Toggle Minimap', shortcut: 'M', action: toggleMinimap },
        ];

        function openCommandPalette() {
            const palette = document.getElementById('commandPalette');
            palette.classList.add('active');
            document.getElementById('commandInput').value = '';
            document.getElementById('commandInput').focus();
            commandSelectedIndex = 0;
            filterCommands();
            document.exitPointerLock();
        }

        function closeCommandPalette() {
            document.getElementById('commandPalette').classList.remove('active');
        }

        function filterCommands() {
            const query = document.getElementById('commandInput').value.toLowerCase();
            const results = document.getElementById('commandResults');
            results.innerHTML = '';

            // Filter commands
            let items = commands.filter(c => c.label.toLowerCase().includes(query));

            // Add rooms as navigation options
            palaceData.rooms.forEach(room => {
                if (room.name.toLowerCase().includes(query) || query === '') {
                    items.push({
                        id: 'goto-' + room.id,
                        icon: '&#8594;',
                        label: 'Go to ' + room.name,
                        color: ROOM_COLORS[room.color || 0].hex,
                        action: () => teleportToRoom(room)
                    });
                }
            });

            items.slice(0, 8).forEach((item, i) => {
                const div = document.createElement('div');
                div.className = 'command-item' + (i === commandSelectedIndex ? ' selected' : '');
                div.innerHTML = `
                    <span class="label">
                        <span class="icon" ${item.color ? 'style="color:'+item.color+'"' : ''}>${item.icon}</span>
                        <span>${item.label}</span>
                    </span>
                    ${item.shortcut ? '<span class="shortcut">' + item.shortcut + '</span>' : ''}
                `;
                div.onclick = () => { item.action(); closeCommandPalette(); };
                results.appendChild(div);
            });
        }

        function handleCommandKey(e) {
            const items = document.querySelectorAll('.command-item');
            if (e.key === 'ArrowDown') {
                e.preventDefault();
                commandSelectedIndex = Math.min(commandSelectedIndex + 1, items.length - 1);
                items.forEach((el, i) => el.classList.toggle('selected', i === commandSelectedIndex));
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                commandSelectedIndex = Math.max(commandSelectedIndex - 1, 0);
                items.forEach((el, i) => el.classList.toggle('selected', i === commandSelectedIndex));
            } else if (e.key === 'Enter') {
                e.preventDefault();
                if (items[commandSelectedIndex]) items[commandSelectedIndex].click();
            } else if (e.key === 'Escape') {
                closeCommandPalette();
            }
        }

        function teleportToRoom(room) {
            camera.x = room.x;
            camera.z = room.z + 3;
            camera.ry = Math.PI;
        }

        // ============================================
        // Side Panel (Edit/New Room)
        // ============================================
        function openNewRoomPanel() {
            editingRoom = null;
            document.getElementById('panelTitle').textContent = 'New Room';
            document.getElementById('roomNameInput').value = '';
            document.getElementById('roomDescInput').value = '';
            document.getElementById('deleteRoomBtn').style.display = 'none';
            selectedColor = Math.floor(Math.random() * ROOM_COLORS.length);
            selectedConnections = [];
            renderColorChips();
            renderConnectionChips();
            document.getElementById('sidePanel').classList.add('open');
            document.exitPointerLock();
        }

        function openEditPanel() {
            if (!currentRoom) return;
            editingRoom = currentRoom;
            document.getElementById('panelTitle').textContent = 'Edit Room';
            document.getElementById('roomNameInput').value = currentRoom.name;
            document.getElementById('roomDescInput').value = currentRoom.description;
            document.getElementById('deleteRoomBtn').style.display = palaceData.rooms.length > 1 ? 'block' : 'none';
            selectedColor = currentRoom.color || 0;
            selectedConnections = [...currentRoom.connections];
            renderColorChips();
            renderConnectionChips();
            document.getElementById('sidePanel').classList.add('open');
            document.exitPointerLock();
        }

        function closeSidePanel() {
            document.getElementById('sidePanel').classList.remove('open');
            editingRoom = null;
        }

        function toggleSection(header) {
            header.parentElement.classList.toggle('collapsed');
        }

        function renderColorChips() {
            const container = document.getElementById('colorChips');
            container.innerHTML = '';
            ROOM_COLORS.forEach((color, i) => {
                const chip = document.createElement('div');
                chip.className = 'color-chip' + (i === selectedColor ? ' selected' : '');
                chip.style.background = color.hex;
                chip.onclick = () => { selectedColor = i; renderColorChips(); };
                container.appendChild(chip);
            });
        }

        function renderConnectionChips() {
            const container = document.getElementById('connectionChips');
            container.innerHTML = '';
            palaceData.rooms.forEach(room => {
                if (editingRoom && room.id === editingRoom.id) return;
                const isConnected = selectedConnections.includes(room.id);
                const chip = document.createElement('div');
                chip.className = 'connection-chip' + (isConnected ? ' connected' : '');
                chip.innerHTML = `<span class="dot" style="background:${ROOM_COLORS[room.color || 0].hex}"></span>${room.name}`;
                chip.onclick = () => {
                    if (isConnected) selectedConnections = selectedConnections.filter(id => id !== room.id);
                    else selectedConnections.push(room.id);
                    renderConnectionChips();
                };
                container.appendChild(chip);
            });
        }

        function saveRoom() {
            const name = document.getElementById('roomNameInput').value.trim();
            const description = document.getElementById('roomDescInput').value.trim();
            if (!name) { alert('Please enter a room name'); return; }

            if (editingRoom) {
                editingRoom.name = name;
                editingRoom.description = description;
                editingRoom.color = selectedColor;
                const oldConnections = [...editingRoom.connections];
                oldConnections.forEach(connId => {
                    if (!selectedConnections.includes(connId)) {
                        const connRoom = palaceData.rooms.find(r => r.id === connId);
                        if (connRoom) connRoom.connections = connRoom.connections.filter(id => id !== editingRoom.id);
                    }
                });
                selectedConnections.forEach(connId => {
                    if (!oldConnections.includes(connId)) {
                        const connRoom = palaceData.rooms.find(r => r.id === connId);
                        if (connRoom && !connRoom.connections.includes(editingRoom.id)) connRoom.connections.push(editingRoom.id);
                    }
                });
                editingRoom.connections = selectedConnections;
            } else {
                const id = 'room-' + Date.now();
                let newX = 0, newZ = 0;
                if (selectedConnections.length > 0) {
                    const connRoom = palaceData.rooms.find(r => r.id === selectedConnections[0]);
                    if (connRoom) {
                        const directions = [{ x: ROOM_SIZE + HALLWAY_LENGTH, z: 0 }, { x: -ROOM_SIZE - HALLWAY_LENGTH, z: 0 }, { x: 0, z: ROOM_SIZE + HALLWAY_LENGTH }, { x: 0, z: -ROOM_SIZE - HALLWAY_LENGTH }];
                        for (const dir of directions) {
                            const testX = connRoom.x + dir.x, testZ = connRoom.z + dir.z;
                            if (!palaceData.rooms.some(r => Math.abs(r.x - testX) < ROOM_SIZE && Math.abs(r.z - testZ) < ROOM_SIZE)) { newX = testX; newZ = testZ; break; }
                        }
                    }
                } else {
                    newX = Math.round(camera.x / (ROOM_SIZE + HALLWAY_LENGTH)) * (ROOM_SIZE + HALLWAY_LENGTH);
                    newZ = Math.round(camera.z / (ROOM_SIZE + HALLWAY_LENGTH)) * (ROOM_SIZE + HALLWAY_LENGTH);
                }
                palaceData.rooms.push({ id, name, description, x: newX, y: 0, z: newZ, color: selectedColor, connections: selectedConnections, objects: [] });
                selectedConnections.forEach(connId => {
                    const connRoom = palaceData.rooms.find(r => r.id === connId);
                    if (connRoom && !connRoom.connections.includes(id)) connRoom.connections.push(id);
                });
            }
            saveData();
            buildPalaceGeometry();
            closeSidePanel();
        }

        function deleteCurrentRoom() {
            if (!editingRoom || palaceData.rooms.length <= 1) return;
            if (!confirm(`Delete "${editingRoom.name}"?`)) return;
            palaceData.rooms.forEach(room => { room.connections = room.connections.filter(id => id !== editingRoom.id); });
            palaceData.rooms = palaceData.rooms.filter(r => r.id !== editingRoom.id);
            if (currentRoom === editingRoom) { const firstRoom = palaceData.rooms[0]; camera.x = firstRoom.x; camera.z = firstRoom.z; }
            saveData();
            buildPalaceGeometry();
            closeSidePanel();
        }

        // ============================================
        // Event Handlers
        // ============================================
        function enterPalace() {
            document.getElementById('startScreen').classList.add('hidden');
            const startRoom = palaceData.rooms.find(r => r.id === palaceData.lastVisited) || palaceData.rooms[0];
            camera.x = startRoom.x;
            camera.z = startRoom.z + 3;
            camera.ry = Math.PI;
            requestAnimationFrame(gameLoop);
        }

        function gameLoop() {
            updateMovement();
            render();
            updateMinimap();
            requestAnimationFrame(gameLoop);
        }

        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;

            // Command palette
            if (e.key === '/' && !document.getElementById('sidePanel').classList.contains('open')) {
                e.preventDefault();
                openCommandPalette();
                return;
            }

            if (document.getElementById('commandPalette').classList.contains('active')) return;
            if (document.getElementById('sidePanel').classList.contains('open')) return;

            if (e.key.toLowerCase() === 'e' && isPointerLocked) openEditPanel();
            if (e.key.toLowerCase() === 'n' && isPointerLocked) openNewRoomPanel();
            if (e.key.toLowerCase() === 'm') toggleMinimap();
        });

        document.addEventListener('keyup', (e) => { keys[e.key.toLowerCase()] = false; });

        document.addEventListener('mousemove', (e) => {
            if (!isPointerLocked) return;
            camera.ry -= e.movementX * 0.002;
            camera.rx -= e.movementY * 0.002;
            camera.rx = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, camera.rx));
        });

        document.addEventListener('click', (e) => {
            if (!document.getElementById('startScreen').classList.contains('hidden')) return;
            if (document.getElementById('sidePanel').classList.contains('open')) return;
            if (document.getElementById('commandPalette').classList.contains('active')) {
                if (!e.target.closest('.command-palette')) closeCommandPalette();
                return;
            }
            if (e.target.closest('.toolbar') || e.target.closest('.minimap') || e.target.closest('.room-badge')) return;
            if (!isPointerLocked) canvas.requestPointerLock();
        });

        document.addEventListener('pointerlockchange', () => {
            isPointerLocked = document.pointerLockElement === canvas;
        });

        window.addEventListener('resize', () => {
            if (!canvas) return;
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            projectionMatrix = mat4Perspective(Math.PI / 3, canvas.width / canvas.height, 0.1, 200);
            gl.uniformMatrix4fv(shaderProgram.uProjection, false, projectionMatrix);
        });

        initWebGL();
    </script>
</body>
</html>