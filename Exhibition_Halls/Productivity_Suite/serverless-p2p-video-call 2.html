<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Serverless P2P Video Call - Zero Infrastructure</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            min-height: 100vh;
            color: #fff;
        }

        .header {
            text-align: center;
            padding: 20px;
            background: rgba(0,0,0,0.3);
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .header h1 {
            font-size: 1.8rem;
            background: linear-gradient(90deg, #00d4ff, #7b2cbf, #ff006e);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header p {
            color: #888;
            margin-top: 5px;
            font-size: 0.9rem;
        }

        .impossible-badge {
            display: inline-block;
            background: linear-gradient(90deg, #ff006e, #7b2cbf);
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.7rem;
            margin-top: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .video-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        @media (max-width: 900px) {
            .video-grid { grid-template-columns: 1fr; }
        }

        .video-container {
            position: relative;
            background: #000;
            border-radius: 16px;
            overflow: hidden;
            aspect-ratio: 16/9;
            border: 2px solid rgba(255,255,255,0.1);
        }

        .video-container video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .video-label {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
        }

        .connection-status {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: bold;
        }

        .status-disconnected { background: #ff4444; }
        .status-connecting { background: #ffaa00; }
        .status-connected { background: #00cc66; }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 30px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: linear-gradient(90deg, #00d4ff, #7b2cbf);
            color: white;
        }

        .btn-secondary {
            background: rgba(255,255,255,0.1);
            color: white;
            border: 1px solid rgba(255,255,255,0.2);
        }

        .btn-danger {
            background: #ff4444;
            color: white;
        }

        .btn:hover { transform: scale(1.05); opacity: 0.9; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }

        .signaling-section {
            background: rgba(255,255,255,0.05);
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .signaling-section h2 {
            font-size: 1.2rem;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .tab {
            padding: 10px 20px;
            background: rgba(255,255,255,0.1);
            border: none;
            border-radius: 10px;
            color: white;
            cursor: pointer;
            transition: all 0.3s;
        }

        .tab.active {
            background: linear-gradient(90deg, #00d4ff, #7b2cbf);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .signal-box {
            background: #000;
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            position: relative;
        }

        .signal-box textarea {
            width: 100%;
            height: 120px;
            background: transparent;
            border: none;
            color: #00ff88;
            font-family: monospace;
            font-size: 0.8rem;
            resize: vertical;
        }

        .signal-box textarea:focus { outline: none; }

        .copy-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255,255,255,0.2);
            border: none;
            padding: 5px 10px;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            font-size: 0.8rem;
        }

        .qr-container {
            display: flex;
            gap: 20px;
            align-items: flex-start;
            flex-wrap: wrap;
        }

        .qr-box {
            background: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }

        .qr-box canvas {
            max-width: 200px;
        }

        .qr-box p {
            color: #333;
            font-size: 0.8rem;
            margin-top: 10px;
        }

        .qr-scanner {
            flex: 1;
            min-width: 250px;
        }

        .qr-scanner video {
            width: 100%;
            max-width: 300px;
            border-radius: 10px;
        }

        .audio-signaling {
            text-align: center;
        }

        .audio-visualizer {
            height: 100px;
            background: #000;
            border-radius: 10px;
            margin: 15px 0;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .audio-visualizer canvas {
            width: 100%;
            height: 100%;
        }

        .audio-status {
            padding: 10px;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            margin-top: 10px;
            font-family: monospace;
            font-size: 0.9rem;
        }

        .instructions {
            background: rgba(0, 212, 255, 0.1);
            border-left: 4px solid #00d4ff;
            padding: 15px;
            border-radius: 0 10px 10px 0;
            margin: 15px 0;
        }

        .instructions h3 {
            margin-bottom: 10px;
            color: #00d4ff;
        }

        .instructions ol {
            padding-left: 20px;
        }

        .instructions li {
            margin: 8px 0;
            color: #ccc;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .stat-card {
            background: rgba(255,255,255,0.05);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #00d4ff;
        }

        .stat-label {
            font-size: 0.8rem;
            color: #888;
            margin-top: 5px;
        }

        .how-it-works {
            background: rgba(123, 44, 191, 0.1);
            border-radius: 16px;
            padding: 20px;
            margin-top: 20px;
        }

        .how-it-works h3 {
            color: #7b2cbf;
            margin-bottom: 15px;
        }

        .tech-stack {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
        }

        .tech-badge {
            background: rgba(255,255,255,0.1);
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.8rem;
        }

        .hidden { display: none !important; }

        /* Toast notifications */
        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #333;
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            animation: slideIn 0.3s ease;
            z-index: 1000;
        }

        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        .data-controls {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1000;
            display: flex;
            gap: 10px;
        }

        .data-controls button {
            background: rgba(0,0,0,0.5);
            border: 1px solid rgba(255,255,255,0.2);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.8rem;
        }
    </style>
</head>
<body>
    <div class="data-controls">
        <button onclick="exportData()">Export Session</button>
        <button onclick="document.getElementById('importFile').click()">Import Session</button>
        <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importData(event)">
    </div>

    <div class="header">
        <h1>Serverless P2P Video Call</h1>
        <p>Zero servers. Zero infrastructure. Pure peer-to-peer magic.</p>
        <div class="impossible-badge">The "Impossible" Made Possible</div>
    </div>

    <div class="container">
        <!-- Video Grid -->
        <div class="video-grid">
            <div class="video-container">
                <video id="localVideo" autoplay muted playsinline></video>
                <div class="video-label">You</div>
                <div id="localStatus" class="connection-status status-disconnected">Camera Off</div>
            </div>
            <div class="video-container">
                <video id="remoteVideo" autoplay playsinline></video>
                <div class="video-label">Remote Peer</div>
                <div id="remoteStatus" class="connection-status status-disconnected">Waiting...</div>
            </div>
        </div>

        <!-- Controls -->
        <div class="controls">
            <button id="startBtn" class="btn btn-primary" onclick="startCamera()">
                üìπ Start Camera
            </button>
            <button id="createOfferBtn" class="btn btn-secondary" onclick="createOffer()" disabled>
                üì§ Create Offer
            </button>
            <button id="toggleAudioBtn" class="btn btn-secondary" onclick="toggleAudio()" disabled>
                üé§ Mute
            </button>
            <button id="toggleVideoBtn" class="btn btn-secondary" onclick="toggleVideo()" disabled>
                üì∑ Hide Video
            </button>
            <button id="hangupBtn" class="btn btn-danger" onclick="hangup()" disabled>
                üì¥ Hang Up
            </button>
        </div>

        <!-- Signaling Section -->
        <div class="signaling-section">
            <h2>üîó Signal Exchange (No Server Required!)</h2>

            <div class="tabs">
                <button class="tab active" onclick="switchTab('clipboard')">üìã Copy/Paste</button>
                <button class="tab" onclick="switchTab('qr')">üì± QR Code</button>
                <button class="tab" onclick="switchTab('audio')">üîä Audio Tones</button>
            </div>

            <!-- Clipboard Tab -->
            <div id="clipboardTab" class="tab-content active">
                <div class="instructions">
                    <h3>How to Connect</h3>
                    <ol>
                        <li><strong>Caller:</strong> Click "Create Offer" and copy the signal</li>
                        <li><strong>Caller:</strong> Send the signal to your friend (email, chat, carrier pigeon)</li>
                        <li><strong>Receiver:</strong> Paste the signal in "Their Signal" and click "Accept"</li>
                        <li><strong>Receiver:</strong> Copy YOUR signal and send it back to the caller</li>
                        <li><strong>Caller:</strong> Paste the response and click "Connect"</li>
                        <li>üéâ You're connected! No servers touched.</li>
                    </ol>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                    <div>
                        <h4 style="margin-bottom: 10px;">üì§ Your Signal</h4>
                        <div class="signal-box">
                            <textarea id="localSignal" readonly placeholder="Your signal will appear here..."></textarea>
                            <button class="copy-btn" onclick="copySignal()">Copy</button>
                        </div>
                    </div>
                    <div>
                        <h4 style="margin-bottom: 10px;">üì• Their Signal</h4>
                        <div class="signal-box">
                            <textarea id="remoteSignal" placeholder="Paste your friend's signal here..."></textarea>
                        </div>
                        <div style="display: flex; gap: 10px; margin-top: 10px;">
                            <button class="btn btn-primary" onclick="acceptOffer()" id="acceptBtn">Accept Offer</button>
                            <button class="btn btn-primary" onclick="acceptAnswer()" id="connectBtn">Connect</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- QR Code Tab -->
            <div id="qrTab" class="tab-content">
                <div class="instructions">
                    <h3>QR Code & Shareable Link</h3>
                    <p>Generate a scannable QR code or shareable link with your signal. Send it via any messaging app - the recipient can join instantly!</p>
                </div>

                <div class="qr-container">
                    <div class="qr-box">
                        <div id="qrCodeContainer" style="min-width: 200px; min-height: 200px; display: flex; justify-content: center; align-items: center;">
                            <p style="color: #666; font-size: 0.9rem;">Click "Generate QR" after creating an offer</p>
                        </div>
                        <p style="margin-top: 10px;">Your Signal QR Code</p>
                        <button class="btn btn-primary" onclick="generateQR()" style="margin-top: 10px;">üì± Generate QR</button>
                    </div>
                    <div class="qr-scanner">
                        <h4>Scan Their QR Code</h4>
                        <video id="qrScanner" autoplay playsinline style="background: #111; min-height: 200px;"></video>
                        <div style="margin-top: 10px; display: flex; gap: 10px; flex-wrap: wrap;">
                            <button class="btn btn-primary" onclick="startQRScanner()">üì∑ Start Scanner</button>
                            <button class="btn btn-secondary" onclick="stopQRScanner()">üõë Stop</button>
                        </div>
                        <p id="qrScanResult" style="margin-top: 10px; color: #888; font-size: 0.9rem;">Ready to scan</p>
                    </div>
                </div>

                <!-- Shareable Link Section -->
                <div class="shareable-link-section" style="margin-top: 20px; padding: 15px; background: rgba(0,212,255,0.1); border: 1px solid rgba(0,212,255,0.3); border-radius: 12px;">
                    <h4 style="color: #00d4ff; margin-bottom: 10px; display: flex; align-items: center; gap: 8px;">
                        üîó Shareable Link
                    </h4>
                    <p style="color: #aaa; font-size: 0.85rem; margin-bottom: 10px;">Share this link directly - no QR scanner needed!</p>
                    <div id="shareableLinkContainer" style="display: none;">
                        <p id="shareableUrl" style="font-size: 11px; color: rgba(255,255,255,0.8); word-break: break-all; margin: 10px 0; padding: 10px; background: rgba(0,0,0,0.4); border-radius: 8px; font-family: monospace; max-height: 80px; overflow-y: auto;"></p>
                        <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                            <button class="btn btn-primary" onclick="copyShareableLink()">üìã Copy Link</button>
                            <button class="btn btn-secondary" onclick="shareLink()">üì§ Share</button>
                        </div>
                    </div>
                    <p id="shareableLinkPlaceholder" style="color: #666; font-size: 0.9rem;">Create an offer first, then generate QR to get shareable link</p>
                </div>
            </div>

            <!-- Audio Tab -->
            <div id="audioTab" class="tab-content">
                <div class="instructions">
                    <h3>Audio Tone Signaling (Experimental!)</h3>
                    <p>Encode your signal as audio tones. Play them through speakers, and the other device listens!</p>
                    <p style="color: #ff6b6b; margin-top: 10px;">‚ö†Ô∏è Works best in quiet environments. Hold devices close together.</p>
                </div>

                <div class="audio-signaling">
                    <div class="audio-visualizer">
                        <canvas id="audioCanvas"></canvas>
                    </div>

                    <div style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
                        <button class="btn btn-primary" onclick="transmitAudio()">üîä Transmit Signal</button>
                        <button class="btn btn-secondary" onclick="startListening()">üëÇ Start Listening</button>
                        <button class="btn btn-secondary" onclick="stopListening()">üõë Stop Listening</button>
                    </div>

                    <div class="audio-status" id="audioStatus">
                        Status: Ready
                    </div>
                </div>
            </div>
        </div>

        <!-- Connection Stats -->
        <div class="stats" id="statsSection" style="display: none;">
            <div class="stat-card">
                <div class="stat-value" id="statLatency">--</div>
                <div class="stat-label">Latency (ms)</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="statBitrate">--</div>
                <div class="stat-label">Bitrate (kbps)</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="statPacketLoss">--</div>
                <div class="stat-label">Packet Loss (%)</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="statConnectionTime">00:00</div>
                <div class="stat-label">Connected</div>
            </div>
        </div>

        <!-- How It Works -->
        <div class="how-it-works">
            <h3>üß† How This "Impossible" Thing Works</h3>
            <p style="color: #ccc; line-height: 1.6;">
                Conventional wisdom says P2P video calls <em>require</em> STUN/TURN servers for NAT traversal.
                This app proves that's not entirely true. Here's the trick:
            </p>
            <ul style="color: #aaa; margin: 15px 0; padding-left: 20px; line-height: 1.8;">
                <li><strong>WebRTC generates SDP (Session Description Protocol)</strong> - a text blob containing your IP, ports, and media capabilities</li>
                <li><strong>We exchange SDP manually</strong> - via copy/paste, QR codes, or even audio tones</li>
                <li><strong>ICE candidates are embedded</strong> - your local network candidates are included, enabling direct connection</li>
                <li><strong>NAT traversal happens naturally</strong> - if both peers are on IPv6 or have compatible NAT types, direct connection works!</li>
            </ul>
            <p style="color: #ff6b6b; font-size: 0.9rem;">
                ‚ö†Ô∏è Caveat: This works ~60-70% of the time. Symmetric NATs and strict firewalls can still block connections.
                But when it works, you've achieved TRUE peer-to-peer with zero infrastructure!
            </p>

            <div class="tech-stack">
                <span class="tech-badge">WebRTC</span>
                <span class="tech-badge">Manual SDP Exchange</span>
                <span class="tech-badge">QRious Library</span>
                <span class="tech-badge">jsQR Scanner</span>
                <span class="tech-badge">Shareable Links</span>
                <span class="tech-badge">Web Share API</span>
                <span class="tech-badge">Audio FSK Modulation</span>
                <span class="tech-badge">Single HTML File</span>
            </div>
        </div>
    </div>

    <script>
        // App Configuration
        const APP_NAME = 'serverless-p2p-video';
        let appData = JSON.parse(localStorage.getItem(APP_NAME) || '{"sessions": []}');

        // WebRTC Configuration - NO STUN/TURN SERVERS!
        const rtcConfig = {
            iceServers: [] // Empty! No servers!
        };

        // State
        let localStream = null;
        let peerConnection = null;
        let isAudioMuted = false;
        let isVideoHidden = false;
        let connectionStartTime = null;
        let statsInterval = null;

        // Audio signaling state
        let audioContext = null;
        let analyser = null;
        let isListening = false;
        let audioStream = null;

        // QR scanning state
        let qrScannerStream = null;
        let qrAnimationFrame = null;

        // ==================== CAMERA & MEDIA ====================

        async function startCamera() {
            try {
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 1280, height: 720 },
                    audio: true
                });

                document.getElementById('localVideo').srcObject = localStream;
                document.getElementById('localStatus').textContent = 'Camera On';
                document.getElementById('localStatus').className = 'connection-status status-connected';

                document.getElementById('startBtn').disabled = true;
                document.getElementById('createOfferBtn').disabled = false;
                document.getElementById('toggleAudioBtn').disabled = false;
                document.getElementById('toggleVideoBtn').disabled = false;

                showToast('Camera started successfully!');
            } catch (err) {
                console.error('Camera error:', err);
                showToast('Failed to access camera: ' + err.message, 'error');
            }
        }

        function toggleAudio() {
            if (!localStream) return;
            const audioTrack = localStream.getAudioTracks()[0];
            if (audioTrack) {
                isAudioMuted = !isAudioMuted;
                audioTrack.enabled = !isAudioMuted;
                document.getElementById('toggleAudioBtn').textContent = isAudioMuted ? 'üîá Unmute' : 'üé§ Mute';
            }
        }

        function toggleVideo() {
            if (!localStream) return;
            const videoTrack = localStream.getVideoTracks()[0];
            if (videoTrack) {
                isVideoHidden = !isVideoHidden;
                videoTrack.enabled = !isVideoHidden;
                document.getElementById('toggleVideoBtn').textContent = isVideoHidden ? 'üì∑ Show Video' : 'üì∑ Hide Video';
            }
        }

        // ==================== WEBRTC CORE ====================

        function createPeerConnection() {
            peerConnection = new RTCPeerConnection(rtcConfig);

            // Add local tracks
            if (localStream) {
                localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localStream);
                });
            }

            // Handle incoming tracks
            peerConnection.ontrack = (event) => {
                document.getElementById('remoteVideo').srcObject = event.streams[0];
                document.getElementById('remoteStatus').textContent = 'Connected!';
                document.getElementById('remoteStatus').className = 'connection-status status-connected';
            };

            // Handle ICE candidates - collect them all into the SDP
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    // We'll wait for ICE gathering to complete
                    console.log('ICE candidate:', event.candidate.candidate);
                }
            };

            // Connection state changes
            peerConnection.onconnectionstatechange = () => {
                const state = peerConnection.connectionState;
                console.log('Connection state:', state);

                if (state === 'connected') {
                    onConnected();
                } else if (state === 'disconnected' || state === 'failed') {
                    onDisconnected();
                }
            };

            // ICE connection state
            peerConnection.oniceconnectionstatechange = () => {
                console.log('ICE state:', peerConnection.iceConnectionState);
                updateConnectionStatus(peerConnection.iceConnectionState);
            };

            return peerConnection;
        }

        async function createOffer() {
            if (!localStream) {
                showToast('Please start camera first!', 'error');
                return;
            }

            createPeerConnection();

            try {
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);

                // Wait for ICE gathering to complete
                await waitForICEGathering();

                // Get the complete SDP with all ICE candidates
                const completeOffer = {
                    type: 'offer',
                    sdp: peerConnection.localDescription.sdp
                };

                const signalString = btoa(JSON.stringify(completeOffer));
                document.getElementById('localSignal').value = signalString;

                document.getElementById('remoteStatus').textContent = 'Offer Created';
                document.getElementById('remoteStatus').className = 'connection-status status-connecting';

                showToast('Offer created! Copy and send to your friend.');
            } catch (err) {
                console.error('Create offer error:', err);
                showToast('Failed to create offer: ' + err.message, 'error');
            }
        }

        async function acceptOffer() {
            const signalString = document.getElementById('remoteSignal').value.trim();
            if (!signalString) {
                showToast('Please paste the offer signal first!', 'error');
                return;
            }

            if (!localStream) {
                showToast('Please start camera first!', 'error');
                return;
            }

            try {
                const offer = JSON.parse(atob(signalString));

                createPeerConnection();

                await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);

                // Wait for ICE gathering
                await waitForICEGathering();

                const completeAnswer = {
                    type: 'answer',
                    sdp: peerConnection.localDescription.sdp
                };

                const answerString = btoa(JSON.stringify(completeAnswer));
                document.getElementById('localSignal').value = answerString;

                document.getElementById('remoteStatus').textContent = 'Answer Created';
                document.getElementById('remoteStatus').className = 'connection-status status-connecting';

                showToast('Answer created! Copy and send back to caller.');
            } catch (err) {
                console.error('Accept offer error:', err);
                showToast('Failed to accept offer: ' + err.message, 'error');
            }
        }

        async function acceptAnswer() {
            const signalString = document.getElementById('remoteSignal').value.trim();
            if (!signalString) {
                showToast('Please paste the answer signal first!', 'error');
                return;
            }

            try {
                const answer = JSON.parse(atob(signalString));
                await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));

                document.getElementById('remoteStatus').textContent = 'Connecting...';
                document.getElementById('remoteStatus').className = 'connection-status status-connecting';

                showToast('Connecting to peer...');
            } catch (err) {
                console.error('Accept answer error:', err);
                showToast('Failed to accept answer: ' + err.message, 'error');
            }
        }

        function waitForICEGathering() {
            return new Promise((resolve) => {
                if (peerConnection.iceGatheringState === 'complete') {
                    resolve();
                } else {
                    const checkState = () => {
                        if (peerConnection.iceGatheringState === 'complete') {
                            peerConnection.removeEventListener('icegatheringstatechange', checkState);
                            resolve();
                        }
                    };
                    peerConnection.addEventListener('icegatheringstatechange', checkState);

                    // Timeout after 5 seconds
                    setTimeout(resolve, 5000);
                }
            });
        }

        function updateConnectionStatus(state) {
            const statusEl = document.getElementById('remoteStatus');
            switch (state) {
                case 'checking':
                    statusEl.textContent = 'Checking...';
                    statusEl.className = 'connection-status status-connecting';
                    break;
                case 'connected':
                    statusEl.textContent = 'Connected!';
                    statusEl.className = 'connection-status status-connected';
                    break;
                case 'disconnected':
                case 'failed':
                    statusEl.textContent = 'Disconnected';
                    statusEl.className = 'connection-status status-disconnected';
                    break;
            }
        }

        function onConnected() {
            connectionStartTime = Date.now();
            document.getElementById('hangupBtn').disabled = false;
            document.getElementById('statsSection').style.display = 'grid';
            startStatsMonitoring();
            showToast('üéâ Connected! You are now in a serverless P2P call!');

            // Save session
            appData.sessions.push({
                timestamp: new Date().toISOString(),
                duration: 0
            });
            saveData();
        }

        function onDisconnected() {
            stopStatsMonitoring();
            document.getElementById('statsSection').style.display = 'none';
            showToast('Call ended');
        }

        function hangup() {
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }

            document.getElementById('remoteVideo').srcObject = null;
            document.getElementById('remoteStatus').textContent = 'Disconnected';
            document.getElementById('remoteStatus').className = 'connection-status status-disconnected';
            document.getElementById('hangupBtn').disabled = true;
            document.getElementById('createOfferBtn').disabled = false;
            document.getElementById('localSignal').value = '';
            document.getElementById('remoteSignal').value = '';

            onDisconnected();
        }

        // ==================== STATS MONITORING ====================

        function startStatsMonitoring() {
            statsInterval = setInterval(updateStats, 1000);
        }

        function stopStatsMonitoring() {
            if (statsInterval) {
                clearInterval(statsInterval);
                statsInterval = null;
            }
        }

        async function updateStats() {
            if (!peerConnection) return;

            try {
                const stats = await peerConnection.getStats();
                let bytesReceived = 0;
                let packetsLost = 0;
                let packetsReceived = 0;
                let rtt = 0;

                stats.forEach(report => {
                    if (report.type === 'inbound-rtp' && report.kind === 'video') {
                        bytesReceived = report.bytesReceived || 0;
                        packetsLost = report.packetsLost || 0;
                        packetsReceived = report.packetsReceived || 0;
                    }
                    if (report.type === 'candidate-pair' && report.state === 'succeeded') {
                        rtt = report.currentRoundTripTime * 1000 || 0;
                    }
                });

                document.getElementById('statLatency').textContent = Math.round(rtt) || '--';
                document.getElementById('statBitrate').textContent = Math.round(bytesReceived * 8 / 1000) || '--';
                document.getElementById('statPacketLoss').textContent =
                    packetsReceived > 0 ? ((packetsLost / packetsReceived) * 100).toFixed(1) : '0';

                if (connectionStartTime) {
                    const elapsed = Math.floor((Date.now() - connectionStartTime) / 1000);
                    const mins = Math.floor(elapsed / 60).toString().padStart(2, '0');
                    const secs = (elapsed % 60).toString().padStart(2, '0');
                    document.getElementById('statConnectionTime').textContent = `${mins}:${secs}`;
                }
            } catch (err) {
                console.error('Stats error:', err);
            }
        }

        // ==================== QR CODE ====================
        // Using QRious library with API fallback (pattern from levi.html)

        // Dynamically load QRious library
        function loadQRiousLibrary() {
            return new Promise((resolve, reject) => {
                if (window.QRious) {
                    resolve();
                    return;
                }
                const script = document.createElement('script');
                script.src = 'https://cdnjs.cloudflare.com/ajax/libs/qrious/4.0.2/qrious.min.js';
                script.onload = resolve;
                script.onerror = reject;
                document.head.appendChild(script);
            });
        }

        // Dynamically load jsQR library for scanning
        function loadJsQRLibrary() {
            return new Promise((resolve, reject) => {
                if (window.jsQR) {
                    resolve();
                    return;
                }
                const script = document.createElement('script');
                script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jsQR/1.4.0/jsQR.min.js';
                script.onload = resolve;
                script.onerror = reject;
                document.head.appendChild(script);
            });
        }

        function generateQR() {
            const signal = document.getElementById('localSignal').value;
            if (!signal) {
                showToast('No signal to encode! Create an offer first.', 'error');
                return;
            }

            const container = document.getElementById('qrCodeContainer');
            if (!container) return;

            // Generate shareable link first
            const shareableUrl = generateShareableLink();

            // Show loading state
            container.innerHTML = '<div style="color: #333; font-size: 14px; padding: 20px;">Generating QR code...</div>';

            // Try QRious library first, fall back to API
            loadQRiousLibrary().then(() => {
                container.innerHTML = ''; // Clear loading state
                const canvas = document.createElement('canvas');
                canvas.id = 'qrCanvas';
                container.appendChild(canvas);

                // Use shareable URL for QR (more useful than raw signal)
                new window.QRious({
                    element: canvas,
                    value: shareableUrl || signal,
                    size: 200,
                    background: 'white',
                    foreground: 'black',
                    level: 'H' // High error correction for better scanning
                });

                console.log('QR code generated with QRious');
                showToast('QR code & shareable link generated!');
            }).catch((err) => {
                console.log('QRious failed, using API fallback:', err);
                container.innerHTML = ''; // Clear loading state
                // Fallback: Use QR Server API
                const img = document.createElement('img');
                const qrData = shareableUrl || signal;
                img.src = `https://api.qrserver.com/v1/create-qr-code/?size=200x200&ecc=H&data=${encodeURIComponent(qrData)}`;
                img.alt = 'Scan to connect';
                img.style.borderRadius = '10px';
                img.id = 'qrCanvas';
                img.onload = () => {
                    console.log('QR code loaded from API');
                    showToast('QR code & shareable link generated!');
                };
                img.onerror = () => {
                    container.innerHTML = '<div style="color: #c00; font-size: 12px; padding: 10px;">QR generation failed.<br>Use the shareable link instead.</div>';
                    showToast('QR generation failed - use shareable link', 'error');
                };
                container.appendChild(img);
            });
        }

        let qrScanningActive = false;
        let qrScanAnimFrame = null;

        async function startQRScanner() {
            try {
                // Load jsQR library first
                await loadJsQRLibrary();

                qrScannerStream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'environment' }
                });

                const video = document.getElementById('qrScanner');
                video.srcObject = qrScannerStream;

                qrScanningActive = true;
                document.getElementById('qrScanResult').textContent = 'Scanning... Point at a QR code.';
                document.getElementById('qrScanResult').style.color = '#00d4ff';
                showToast('QR scanner started. Point at a QR code.');

                // Wait for video to be ready
                video.onloadedmetadata = () => {
                    video.play();
                    scanQRCode();
                };
            } catch (err) {
                showToast('Failed to start scanner: ' + err.message, 'error');
                document.getElementById('qrScanResult').textContent = 'Camera access denied';
                document.getElementById('qrScanResult').style.color = '#ff4444';
            }
        }

        function scanQRCode() {
            if (!qrScanningActive || !qrScannerStream) return;

            const video = document.getElementById('qrScanner');
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            if (video.readyState === video.HAVE_ENOUGH_DATA) {
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

                if (window.jsQR) {
                    const code = jsQR(imageData.data, imageData.width, imageData.height, {
                        inversionAttempts: 'dontInvert'
                    });

                    if (code) {
                        // Found a QR code!
                        console.log('QR code detected:', code.data.substring(0, 50) + '...');
                        document.getElementById('remoteSignal').value = code.data;
                        document.getElementById('qrScanResult').textContent = 'Signal captured! Click Accept or Connect.';
                        document.getElementById('qrScanResult').style.color = '#00ff88';
                        showToast('QR code scanned successfully!');
                        stopQRScanner();
                        return;
                    }
                }
            }

            // Keep scanning
            qrScanAnimFrame = requestAnimationFrame(scanQRCode);
        }

        function stopQRScanner() {
            qrScanningActive = false;
            if (qrScanAnimFrame) {
                cancelAnimationFrame(qrScanAnimFrame);
                qrScanAnimFrame = null;
            }
            if (qrScannerStream) {
                qrScannerStream.getTracks().forEach(t => t.stop());
                qrScannerStream = null;
                document.getElementById('qrScanner').srcObject = null;
            }
            if (document.getElementById('qrScanResult').textContent === 'Scanning... Point at a QR code.') {
                document.getElementById('qrScanResult').textContent = 'Scanner stopped';
                document.getElementById('qrScanResult').style.color = '#888';
            }
        }

        // ==================== AUDIO SIGNALING ====================

        async function transmitAudio() {
            const signal = document.getElementById('localSignal').value;
            if (!signal) {
                showToast('No signal to transmit! Create an offer first.', 'error');
                return;
            }

            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            gainNode.gain.value = 0.3;

            document.getElementById('audioStatus').textContent = 'Status: Transmitting...';

            // FSK modulation - encode each character as a frequency
            const baseFreq = 1000;
            const freqStep = 50;
            const bitDuration = 0.05; // 50ms per character

            oscillator.start();

            for (let i = 0; i < signal.length; i++) {
                const charCode = signal.charCodeAt(i);
                const freq = baseFreq + (charCode % 64) * freqStep;
                oscillator.frequency.setValueAtTime(freq, audioContext.currentTime + i * bitDuration);
            }

            setTimeout(() => {
                oscillator.stop();
                document.getElementById('audioStatus').textContent = 'Status: Transmission complete';
                showToast('Audio transmission complete!');
            }, signal.length * bitDuration * 1000);
        }

        async function startListening() {
            try {
                audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const source = audioContext.createMediaStreamSource(audioStream);
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 2048;
                source.connect(analyser);

                isListening = true;
                document.getElementById('audioStatus').textContent = 'Status: Listening...';
                visualizeAudio();
                showToast('Listening for audio signals...');
            } catch (err) {
                showToast('Failed to start listening: ' + err.message, 'error');
            }
        }

        function stopListening() {
            isListening = false;
            if (audioStream) {
                audioStream.getTracks().forEach(t => t.stop());
                audioStream = null;
            }
            document.getElementById('audioStatus').textContent = 'Status: Stopped';
        }

        function visualizeAudio() {
            if (!isListening || !analyser) return;

            const canvas = document.getElementById('audioCanvas');
            const ctx = canvas.getContext('2d');
            const width = canvas.width = canvas.offsetWidth;
            const height = canvas.height = canvas.offsetHeight;

            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);

            function draw() {
                if (!isListening) return;
                requestAnimationFrame(draw);

                analyser.getByteFrequencyData(dataArray);

                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, width, height);

                const barWidth = width / bufferLength * 2.5;
                let x = 0;

                for (let i = 0; i < bufferLength; i++) {
                    const barHeight = dataArray[i] / 255 * height;
                    const hue = i / bufferLength * 360;
                    ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
                    ctx.fillRect(x, height - barHeight, barWidth, barHeight);
                    x += barWidth + 1;
                }
            }

            draw();
        }

        // ==================== UI HELPERS ====================

        function switchTab(tabName) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));

            event.target.classList.add('active');
            document.getElementById(tabName + 'Tab').classList.add('active');
        }

        function copySignal() {
            const signal = document.getElementById('localSignal').value;
            if (signal) {
                navigator.clipboard.writeText(signal).then(() => {
                    showToast('Signal copied to clipboard!');
                });
            }
        }

        function showToast(message, type = 'info') {
            const toast = document.createElement('div');
            toast.className = 'toast';
            toast.textContent = message;
            if (type === 'error') toast.style.background = '#ff4444';
            document.body.appendChild(toast);

            setTimeout(() => toast.remove(), 3000);
        }

        // ==================== DATA PERSISTENCE ====================

        function saveData() {
            localStorage.setItem(APP_NAME, JSON.stringify(appData));
        }

        function exportData() {
            const dataStr = JSON.stringify(appData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `${APP_NAME}-data-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);
        }

        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    appData = JSON.parse(e.target.result);
                    saveData();
                    showToast('Session data imported!');
                } catch (error) {
                    showToast('Invalid JSON file', 'error');
                }
            };
            reader.readAsText(file);
        }

        // ==================== SHAREABLE LINK ====================

        let currentShareableUrl = '';

        function generateShareableLink() {
            const signal = document.getElementById('localSignal').value;
            if (!signal) return null;

            // Create URL with signal as query parameter
            const baseUrl = window.location.origin + window.location.pathname;
            currentShareableUrl = `${baseUrl}?signal=${encodeURIComponent(signal)}`;

            // Update UI
            document.getElementById('shareableLinkContainer').style.display = 'block';
            document.getElementById('shareableLinkPlaceholder').style.display = 'none';
            document.getElementById('shareableUrl').textContent = currentShareableUrl;

            return currentShareableUrl;
        }

        function copyShareableLink() {
            if (!currentShareableUrl) {
                showToast('No link to copy! Generate QR first.', 'error');
                return;
            }

            navigator.clipboard.writeText(currentShareableUrl).then(() => {
                showToast('Link copied to clipboard!');
            }).catch(() => {
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = currentShareableUrl;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                showToast('Link copied to clipboard!');
            });
        }

        function shareLink() {
            if (!currentShareableUrl) {
                showToast('No link to share! Generate QR first.', 'error');
                return;
            }

            // Use Web Share API if available
            if (navigator.share) {
                navigator.share({
                    title: 'Join my P2P Video Call',
                    text: 'Click to join my serverless peer-to-peer video call!',
                    url: currentShareableUrl
                }).then(() => {
                    showToast('Shared successfully!');
                }).catch((err) => {
                    if (err.name !== 'AbortError') {
                        // Fallback to copy
                        copyShareableLink();
                    }
                });
            } else {
                // Fallback to copy
                copyShareableLink();
            }
        }

        function checkUrlForSignal() {
            const urlParams = new URLSearchParams(window.location.search);
            const signal = urlParams.get('signal');

            if (signal) {
                try {
                    const decodedSignal = decodeURIComponent(signal);
                    document.getElementById('remoteSignal').value = decodedSignal;

                    // Switch to clipboard tab and show notification
                    switchTab('clipboard');
                    document.querySelector('.tab.active')?.classList.remove('active');
                    document.querySelector('.tab')?.classList.add('active');

                    showToast('Signal received from link! Start your camera, then click Accept or Connect.', 'info');

                    // Clean URL without reloading
                    window.history.replaceState({}, document.title, window.location.pathname);
                } catch (err) {
                    console.error('Failed to parse signal from URL:', err);
                }
            }
        }

        // ==================== INITIALIZATION ====================

        console.log('üöÄ Serverless P2P Video Call - Zero Infrastructure Edition');
        console.log('üì° No STUN servers. No TURN servers. Pure WebRTC magic.');

        // Check for signal in URL on page load
        checkUrlForSignal();
    </script>
</body>
</html>
