<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Meta-Launcher Universe - Portal to Infinite Quantum Worlds</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
            overflow: hidden;
            color: #fff;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
        }

        .ui-overlay {
            position: fixed;
            pointer-events: none;
            z-index: 100;
        }

        .controls {
            top: 20px;
            left: 20px;
            pointer-events: all;
            background: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 12px;
            border: 2px solid #00ffff;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
            max-width: 320px;
            backdrop-filter: blur(10px);
        }

        .qr-container {
            top: 20px;
            right: 20px;
            pointer-events: all;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 12px;
            border: 2px solid #ff00ff;
            box-shadow: 0 0 30px rgba(255, 0, 255, 0.3);
            text-align: center;
            backdrop-filter: blur(10px);
        }

        .qr-container.hidden {
            display: none;
        }

        .explorers-list {
            bottom: 20px;
            left: 20px;
            pointer-events: all;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px;
            border-radius: 12px;
            border: 2px solid #00ff00;
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.3);
            max-width: 280px;
            max-height: 250px;
            overflow-y: auto;
            backdrop-filter: blur(10px);
        }

        .info-panel {
            bottom: 20px;
            right: 20px;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.75);
            padding: 18px;
            border-radius: 12px;
            max-width: 350px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            margin: 5px 0;
            width: 100%;
            transition: all 0.3s ease;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none;
        }

        h2 {
            font-size: 20px;
            margin-bottom: 12px;
            color: #00ffff;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        h3 {
            font-size: 15px;
            margin-bottom: 10px;
            color: #00ff00;
            text-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }

        .explorer-item {
            padding: 8px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            font-size: 13px;
            border-left: 3px solid #00ff00;
        }

        .status {
            font-size: 12px;
            color: #aaa;
            margin: 8px 0;
            line-height: 1.5;
        }

        #qr-code {
            margin: 10px 0;
            background: white;
            padding: 10px;
            border-radius: 8px;
        }

        #qr-code img {
            max-width: 100%;
            height: auto;
            display: block;
        }

        .world-info {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 35px;
            border-radius: 16px;
            border: 3px solid #00ffff;
            pointer-events: all;
            max-width: 550px;
            text-align: center;
            z-index: 1000;
            backdrop-filter: blur(15px);
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.5);
        }

        .world-info.hidden {
            display: none;
        }

        .world-info h2 {
            color: #00ffff;
            margin-bottom: 20px;
            font-size: 28px;
        }

        .world-info p {
            margin: 12px 0;
            line-height: 1.8;
            font-size: 16px;
        }

        .world-info .buttons {
            margin-top: 25px;
        }

        .world-info button {
            width: auto;
            margin: 0 10px;
            display: inline-block;
            padding: 12px 30px;
        }

        .instructions {
            font-size: 13px;
            color: #aaa;
            margin-top: 15px;
            line-height: 1.6;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .instructions kbd {
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 11px;
        }

        .pulse {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }

        .float {
            animation: float 3s ease-in-out infinite;
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, #00ff00, #00aa00);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(180deg, #00ff00, #00ff00);
        }

        .badge {
            display: inline-block;
            padding: 4px 10px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 12px;
            font-size: 11px;
            margin: 3px;
            color: #fff;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <div class="ui-overlay controls">
        <h2>üåå Meta-Launcher Universe</h2>
        <div class="status" id="status">Initializing quantum realm...</div>
        <button id="hostBtn" onclick="hostSession()">üåü Host New Universe</button>
        <button id="joinBtn" onclick="showJoinPrompt()">üöÄ Join Universe</button>
        <div class="instructions">
            <strong>Navigate:</strong> <kbd>WASD</kbd> move, <kbd>Mouse</kbd> look around<br>
            <strong>Interact:</strong> Click glowing planets to enter quantum worlds
        </div>
    </div>

    <div class="ui-overlay qr-container hidden" id="qrContainer">
        <h3>üîÆ Share This Universe</h3>
        <div id="qr-code"></div>
        <div class="status">Scan to join this meta-verse</div>
        <span class="badge pulse">Live Session</span>
    </div>

    <div class="ui-overlay explorers-list" id="explorersList">
        <h3>üë• Other Explorers</h3>
        <div id="explorersContent">
            <div class="status">You're alone in the multiverse...<br>Share the QR code to invite others!</div>
        </div>
    </div>

    <div class="ui-overlay info-panel" id="infoPanel">
        <div class="status">ü™ê Hover over planets to discover quantum worlds</div>
    </div>

    <div class="world-info hidden" id="worldInfo">
        <h2 id="worldTitle">Quantum World</h2>
        <p id="worldDescription">Description</p>
        <div class="buttons">
            <button onclick="enterWorld()" class="float">‚ú® Enter World ‚Üí</button>
            <button onclick="closeWorldInfo()" style="background: linear-gradient(135deg, #666, #999)">‚Üê Back</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <script>
        // App state
        const APP_NAME = 'meta-launcher-universe';
        let scene, camera, renderer;
        let peer = null;
        let myPeerId = null;
        let isHost = false;
        let connections = new Map();
        let explorers = new Map();
        let playerPosition = { x: 0, y: 5, z: 25 };
        let playerVelocity = { x: 0, y: 0, z: 0 };
        let cameraRotation = { x: 0, y: 0 };
        let selectedWorld = null;
        let clock = new THREE.Clock();

        // Quantum Worlds registry - Each planet is a portal to these worlds
        const QUANTUM_WORLDS = [
            {
                id: 'quantum-garden',
                name: 'üå∏ Quantum Garden',
                description: 'Floating islands covered in bioluminescent plants that respond to your presence and bloom with ethereal light',
                path: './quantum-garden.html',
                color: 0x00ff88,
                position: { x: -15, y: 3, z: -8 }
            },
            {
                id: 'neon-city',
                name: 'üåÉ Neon Synthwave City',
                description: 'Cyberpunk metropolis frozen in eternal sunset, with flying vehicles and pulsing neon lights',
                path: './neon-synthwave-city.html',
                color: 0xff00ff,
                position: { x: 15, y: 2, z: -8 }
            },
            {
                id: 'music-garden',
                name: 'üéµ Collaborative Music Garden',
                description: 'Every object generates tones and melodies. Create symphonies with other players in real-time',
                path: './collaborative-music-garden.html',
                color: 0x00ffff,
                position: { x: 0, y: 6, z: -15 }
            },
            {
                id: 'impossible-architecture',
                name: 'üèõÔ∏è Impossible Architecture',
                description: 'M.C. Escher-inspired geometry that defies physics. Walk on walls, defy gravity, explore the impossible',
                path: './impossible-architecture.html',
                color: 0xffff00,
                position: { x: -12, y: 1, z: 3 }
            },
            {
                id: 'bio-ocean',
                name: 'üåä Bioluminescent Ocean',
                description: 'Deep underwater trench with zero-gravity swimming. Discover glowing creatures in the abyss',
                path: './bioluminescent-ocean.html',
                color: 0x0088ff,
                position: { x: 12, y: 1, z: 3 }
            },
            {
                id: 'particle-physics',
                name: '‚öõÔ∏è Particle Physics Lab',
                description: 'YOU are a subatomic particle! Experience quantum tunneling, wave-particle duality, and entanglement',
                path: './particle-physics-playground.html',
                color: 0xff8800,
                position: { x: 0, y: -3, z: 0 }
            },
            {
                id: 'space-station',
                name: 'üõ∏ Zero-G Space Station',
                description: 'Build modular space stations in zero gravity. Collaborate with others to create orbital megastructures',
                path: './zero-g-space-station.html',
                color: 0xcccccc,
                position: { x: -8, y: 5, z: 8 }
            },
            {
                id: 'fractal-forest',
                name: 'üå≥ Fractal Forest',
                description: 'Infinite recursion at every scale. Zoom in forever, each branch contains entire forests',
                path: './fractal-forest.html',
                color: 0x00ff00,
                position: { x: 8, y: 5, z: 8 }
            },
            {
                id: 'paint-dimension',
                name: 'üé® Living Paint Dimension',
                description: 'Your movements create living paint strokes visible to all players. Art becomes reality',
                path: './living-paint-dimension.html',
                color: 0xff0088,
                position: { x: -6, y: -1, z: -5 }
            },
            {
                id: 'ancient-ruins',
                name: 'üè∫ Ancient Ruins',
                description: 'Mysterious temples on a dying star. Uncover secrets left by ancient quantum civilizations',
                path: './ancient-ruins.html',
                color: 0xaa6633,
                position: { x: 6, y: -1, z: -5 }
            }
        ];

        let planets = [];
        let planetMeshes = [];
        let raycaster, mouse;
        let hoveredPlanet = null;
        let stars, starField;

        // Initialize Three.js scene
        function initScene() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000011, 0.012);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(playerPosition.x, playerPosition.y, playerPosition.z);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setClearColor(0x000011);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Create cosmic background
            createStarfield();
            createNebula();

            // Create central platform/hub
            createCentralHub();

            // Create planet portals
            QUANTUM_WORLDS.forEach((world) => {
                const planet = createPlanet(world);
                planets.push({ mesh: planet, world });
                planetMeshes.push(planet);
                scene.add(planet);
            });

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x222244, 0.4);
            scene.add(ambientLight);

            const pointLight1 = new THREE.PointLight(0xffffff, 1.5, 100);
            pointLight1.position.set(0, 15, 0);
            scene.add(pointLight1);

            const pointLight2 = new THREE.PointLight(0x00ffff, 0.8, 80);
            pointLight2.position.set(20, 5, 20);
            scene.add(pointLight2);

            const pointLight3 = new THREE.PointLight(0xff00ff, 0.8, 80);
            pointLight3.position.set(-20, 5, -20);
            scene.add(pointLight3);

            // Raycaster for interaction
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Event listeners
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('click', onMouseClick);
            window.addEventListener('mousemove', onMouseMove);
            document.addEventListener('pointerlockchange', onPointerLockChange);

            updateStatus('Ready to explore the multiverse');
        }

        function createStarfield() {
            const starGeometry = new THREE.BufferGeometry();
            const starMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.15,
                transparent: true,
                opacity: 0.8
            });

            const starVertices = [];
            for (let i = 0; i < 15000; i++) {
                const x = (Math.random() - 0.5) * 2000;
                const y = (Math.random() - 0.5) * 2000;
                const z = (Math.random() - 0.5) * 2000;
                starVertices.push(x, y, z);
            }

            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
            stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);
        }

        function createNebula() {
            const nebulaGeometry = new THREE.BufferGeometry();
            const nebulaMaterial = new THREE.PointsMaterial({
                color: 0x8844ff,
                size: 2,
                transparent: true,
                opacity: 0.15,
                blending: THREE.AdditiveBlending
            });

            const nebulaVertices = [];
            for (let i = 0; i < 3000; i++) {
                const x = (Math.random() - 0.5) * 300;
                const y = (Math.random() - 0.5) * 300;
                const z = (Math.random() - 0.5) * 300;
                nebulaVertices.push(x, y, z);
            }

            nebulaGeometry.setAttribute('position', new THREE.Float32BufferAttribute(nebulaVertices, 3));
            const nebula = new THREE.Points(nebulaGeometry, nebulaMaterial);
            scene.add(nebula);
        }

        function createCentralHub() {
            // Main platform
            const platformGeometry = new THREE.CylinderGeometry(8, 8, 0.8, 32);
            const platformMaterial = new THREE.MeshStandardMaterial({
                color: 0x1a1a3e,
                metalness: 0.9,
                roughness: 0.1,
                emissive: 0x0a0a1e,
                emissiveIntensity: 0.5
            });
            const platform = new THREE.Mesh(platformGeometry, platformMaterial);
            platform.position.y = -0.5;
            platform.receiveShadow = true;
            scene.add(platform);

            // Glowing edge ring
            const ringGeometry = new THREE.TorusGeometry(8, 0.15, 16, 100);
            const ringMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.8
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.position.y = -0.1;
            ring.rotation.x = Math.PI / 2;
            scene.add(ring);

            // Central pillar of light
            const pillarGeometry = new THREE.CylinderGeometry(0.5, 0.5, 50, 32);
            const pillarMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.1,
                side: THREE.DoubleSide
            });
            const pillar = new THREE.Mesh(pillarGeometry, pillarMaterial);
            pillar.position.y = 25;
            scene.add(pillar);
        }

        function createPlanet(world) {
            const group = new THREE.Group();

            // Planet sphere with dynamic material
            const geometry = new THREE.SphereGeometry(1.2, 32, 32);
            const material = new THREE.MeshStandardMaterial({
                color: world.color,
                metalness: 0.4,
                roughness: 0.4,
                emissive: world.color,
                emissiveIntensity: 0.4
            });
            const sphere = new THREE.Mesh(geometry, material);
            sphere.castShadow = true;
            group.add(sphere);

            // Atmospheric glow
            const glowGeometry = new THREE.SphereGeometry(1.5, 32, 32);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: world.color,
                transparent: true,
                opacity: 0.15,
                side: THREE.BackSide,
                blending: THREE.AdditiveBlending
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            group.add(glow);

            // Portal ring (horizontal)
            const ringGeometry = new THREE.TorusGeometry(1.6, 0.08, 16, 100);
            const ringMaterial = new THREE.MeshBasicMaterial({
                color: world.color,
                transparent: true,
                opacity: 0.7
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.rotation.x = Math.PI / 2;
            group.add(ring);

            // Portal ring (vertical)
            const ring2 = ring.clone();
            ring2.rotation.x = 0;
            ring2.rotation.y = Math.PI / 2;
            group.add(ring2);

            // Orbiting particles
            const particleCount = 20;
            const particlesGeometry = new THREE.BufferGeometry();
            const particlesMaterial = new THREE.PointsMaterial({
                color: world.color,
                size: 0.1,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });

            const particlePositions = [];
            for (let i = 0; i < particleCount; i++) {
                const angle = (i / particleCount) * Math.PI * 2;
                const radius = 2;
                particlePositions.push(
                    Math.cos(angle) * radius,
                    (Math.random() - 0.5) * 0.5,
                    Math.sin(angle) * radius
                );
            }

            particlesGeometry.setAttribute('position', new THREE.Float32BufferAttribute(particlePositions, 3));
            const particleSystem = new THREE.Points(particlesGeometry, particlesMaterial);
            group.add(particleSystem);

            group.position.set(world.position.x, world.position.y, world.position.z);
            group.userData = { ...world, particleSystem, ring, ring2 };

            return group;
        }

        // Mouse interaction
        function onMouseMove(event) {
            if (document.pointerLockElement === renderer.domElement) {
                // Camera rotation when locked
                cameraRotation.y -= event.movementX * 0.002;
                cameraRotation.x -= event.movementY * 0.002;
                cameraRotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, cameraRotation.x));
            } else {
                // Planet hover detection
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(planetMeshes, true);

                if (intersects.length > 0) {
                    let intersectedGroup = intersects[0].object;
                    while (intersectedGroup.parent && !intersectedGroup.userData.id) {
                        intersectedGroup = intersectedGroup.parent;
                    }

                    if (intersectedGroup.userData && intersectedGroup.userData.id) {
                        hoveredPlanet = intersectedGroup;
                        const world = intersectedGroup.userData;
                        document.getElementById('infoPanel').innerHTML = `
                            <strong style="color: ${numberToHex(world.color)}; font-size: 18px;">${world.name}</strong><br>
                            <span class="status" style="margin-top: 10px; display: block;">${world.description}</span><br>
                            <span class="status" style="color: #00ffff; font-weight: bold;">‚ú® Click to enter this quantum realm ‚Üí</span>
                        `;
                        document.body.style.cursor = 'pointer';
                    }
                } else {
                    hoveredPlanet = null;
                    document.getElementById('infoPanel').innerHTML = '<div class="status">ü™ê Hover over planets to discover quantum worlds</div>';
                    document.body.style.cursor = 'default';
                }
            }
        }

        function numberToHex(num) {
            return '#' + num.toString(16).padStart(6, '0');
        }

        function onMouseClick() {
            if (hoveredPlanet && hoveredPlanet.userData) {
                selectedWorld = hoveredPlanet.userData;
                showWorldInfo();
            } else {
                // Request pointer lock for movement
                renderer.domElement.requestPointerLock();
            }
        }

        function onPointerLockChange() {
            if (document.pointerLockElement !== renderer.domElement) {
                // Pointer lock released
            }
        }

        function showWorldInfo() {
            if (!selectedWorld) return;

            document.getElementById('worldTitle').textContent = selectedWorld.name;
            document.getElementById('worldDescription').textContent = selectedWorld.description;
            document.getElementById('worldInfo').classList.remove('hidden');
        }

        function closeWorldInfo() {
            document.getElementById('worldInfo').classList.add('hidden');
            selectedWorld = null;
        }

        function enterWorld() {
            if (!selectedWorld) return;

            // Create transition effect
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                background: radial-gradient(circle, transparent, #000);
                z-index: 10000;
                animation: fadeIn 1s forwards;
            `;
            document.body.appendChild(overlay);

            const style = document.createElement('style');
            style.textContent = `
                @keyframes fadeIn {
                    from { opacity: 0; }
                    to { opacity: 1; }
                }
            `;
            document.head.appendChild(style);

            setTimeout(() => {
                window.location.href = selectedWorld.path;
            }, 1000);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Movement controls
        const keys = {};
        window.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            if (e.key === 'Escape' && document.pointerLockElement) {
                document.exitPointerLock();
            }
        });
        window.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);

        function updateMovement(delta) {
            const speed = 10 * delta;
            const direction = new THREE.Vector3();

            if (keys['w']) direction.z -= 1;
            if (keys['s']) direction.z += 1;
            if (keys['a']) direction.x -= 1;
            if (keys['d']) direction.x += 1;
            if (keys[' '] || keys['e']) direction.y += 1;
            if (keys['shift'] || keys['q']) direction.y -= 1;

            // Apply camera rotation to movement direction
            direction.applyEuler(new THREE.Euler(0, cameraRotation.y, 0));
            direction.normalize().multiplyScalar(speed);

            playerPosition.x += direction.x;
            playerPosition.y += direction.y;
            playerPosition.z += direction.z;

            // Update camera
            camera.position.set(playerPosition.x, playerPosition.y, playerPosition.z);
            camera.rotation.set(cameraRotation.x, cameraRotation.y, 0);

            // Broadcast position if connected
            if (peer && peer.open && (direction.x !== 0 || direction.y !== 0 || direction.z !== 0)) {
                broadcastPosition();
            }
        }

        // P2P Networking
        function hostSession() {
            updateStatus('Initializing quantum network...');
            peer = new Peer();

            peer.on('open', (id) => {
                myPeerId = id;
                isHost = true;
                updateStatus('üåü Hosting universe: ' + id.substring(0, 10) + '...');

                const baseUrl = window.location.origin + window.location.pathname;
                const sessionUrl = `${baseUrl}?join=${id}`;
                generateQRCode(sessionUrl);

                document.getElementById('hostBtn').disabled = true;
                document.getElementById('joinBtn').disabled = true;
            });

            peer.on('connection', (conn) => {
                setupConnection(conn);
                updateStatus(`üöÄ Explorer joined! ${connections.size} total explorers`);
            });

            peer.on('error', (err) => {
                console.error('Peer error:', err);
                updateStatus('‚ùå Connection error: ' + err.type);
            });
        }

        function showJoinPrompt() {
            const peerId = prompt('üîÆ Enter universe ID to join:');
            if (peerId && peerId.trim()) {
                joinSession(peerId.trim());
            }
        }

        function joinSession(peerId) {
            updateStatus('Connecting to universe...');
            peer = new Peer();

            peer.on('open', (id) => {
                myPeerId = id;
                updateStatus('üåå Joining universe...');

                const conn = peer.connect(peerId);
                setupConnection(conn);

                document.getElementById('hostBtn').disabled = true;
                document.getElementById('joinBtn').disabled = true;
            });

            peer.on('connection', (conn) => {
                setupConnection(conn);
            });

            peer.on('error', (err) => {
                console.error('Peer error:', err);
                updateStatus('‚ùå Failed to join: ' + err.type);
                document.getElementById('hostBtn').disabled = false;
                document.getElementById('joinBtn').disabled = false;
            });
        }

        function setupConnection(conn) {
            conn.on('open', () => {
                connections.set(conn.peer, conn);
                updateStatus(`‚ú® Connected! ${connections.size + 1} explorers in multiverse`);

                // Send initial position
                conn.send({
                    type: 'position',
                    peerId: myPeerId,
                    position: playerPosition,
                    rotation: cameraRotation
                });
            });

            conn.on('data', (data) => {
                handlePeerData(data, conn.peer);
            });

            conn.on('close', () => {
                connections.delete(conn.peer);
                explorers.delete(conn.peer);
                updateExplorers();
                updateStatus(`Connected to ${connections.size} explorer(s)`);
            });

            conn.on('error', (err) => {
                console.error('Connection error:', err);
            });
        }

        function handlePeerData(data, peerId) {
            if (data.type === 'position') {
                explorers.set(peerId, {
                    position: data.position,
                    rotation: data.rotation || { x: 0, y: 0 },
                    peerId: data.peerId,
                    lastUpdate: Date.now()
                });
                updateExplorers();
            }
        }

        let lastBroadcast = 0;
        function broadcastPosition() {
            const now = Date.now();
            if (now - lastBroadcast < 100) return; // Throttle to 10fps
            lastBroadcast = now;

            const data = {
                type: 'position',
                peerId: myPeerId,
                position: playerPosition,
                rotation: cameraRotation
            };

            connections.forEach((conn) => {
                if (conn && conn.open) {
                    try {
                        conn.send(data);
                    } catch (e) {
                        console.error('Send error:', e);
                    }
                }
            });
        }

        function updateExplorers() {
            const container = document.getElementById('explorersContent');

            if (explorers.size === 0) {
                container.innerHTML = '<div class="status">You\'re alone in the multiverse...<br>Share the QR code to invite others!</div>';
                return;
            }

            let html = '';
            explorers.forEach((explorer, peerId) => {
                const shortId = peerId.substring(0, 8);
                const pos = explorer.position;
                const distance = Math.sqrt(
                    Math.pow(pos.x - playerPosition.x, 2) +
                    Math.pow(pos.y - playerPosition.y, 2) +
                    Math.pow(pos.z - playerPosition.z, 2)
                ).toFixed(1);

                html += `
                    <div class="explorer-item">
                        üë§ <strong>Explorer ${shortId}</strong><br>
                        <span class="status">
                            Position: (${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)})<br>
                            Distance: ${distance} units away
                        </span>
                    </div>
                `;
            });
            container.innerHTML = html;
        }

        function generateQRCode(url) {
            const qrContainer = document.getElementById('qr-code');
            qrContainer.innerHTML = `<img src="https://api.qrserver.com/v1/create-qr-code/?size=200x200&data=${encodeURIComponent(url)}" alt="Session QR Code">`;
            document.getElementById('qrContainer').classList.remove('hidden');
        }

        function updateStatus(message) {
            document.getElementById('status').textContent = message;
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            // Rotate stars slowly
            if (stars) {
                stars.rotation.y += 0.0001;
            }

            // Animate planets
            planets.forEach((planet, index) => {
                const mesh = planet.mesh;

                // Rotate planet
                mesh.rotation.y += 0.008;
                mesh.rotation.x = Math.sin(time + index) * 0.1;

                // Pulse glow
                const scale = 1 + Math.sin(time * 2 + index) * 0.05;
                mesh.scale.set(scale, scale, scale);

                // Rotate portal rings
                if (mesh.userData.ring) {
                    mesh.userData.ring.rotation.z += 0.01;
                }
                if (mesh.userData.ring2) {
                    mesh.userData.ring2.rotation.z -= 0.01;
                }

                // Rotate particle system
                if (mesh.userData.particleSystem) {
                    mesh.userData.particleSystem.rotation.y += 0.02;
                }
            });

            // Update movement
            updateMovement(delta);

            // Render scene
            renderer.render(scene, camera);
        }

        // Auto-join via URL parameter
        function checkAutoJoin() {
            const urlParams = new URLSearchParams(window.location.search);
            const joinId = urlParams.get('join');

            if (joinId) {
                updateStatus('üîÆ Auto-joining universe from QR code...');
                setTimeout(() => {
                    joinSession(joinId);
                }, 1500);
            }
        }

        // Initialize
        window.addEventListener('load', () => {
            initScene();
            animate();
            checkAutoJoin();
        });

        // Data export/import for local-first principles
        function exportData() {
            const data = {
                playerPosition,
                cameraRotation,
                exploredWorlds: [], // Could track which worlds visited
                timestamp: new Date().toISOString()
            };

            const dataStr = JSON.stringify(data, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `meta-launcher-session-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);
        }

        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    if (data.playerPosition) {
                        playerPosition = data.playerPosition;
                        camera.position.set(playerPosition.x, playerPosition.y, playerPosition.z);
                    }
                    if (data.cameraRotation) {
                        cameraRotation = data.cameraRotation;
                    }
                    updateStatus('‚úÖ Session restored successfully!');
                } catch (error) {
                    updateStatus('‚ùå Invalid session file');
                    console.error(error);
                }
            };
            reader.readAsText(file);
        }
    </script>
</body>
</html>
