<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Living Mandelbrot City - Infinite Mathematical Universe</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-dark: #0a0a12;
            --bg-panel: rgba(15, 15, 25, 0.95);
            --accent: #00d4ff;
            --accent-dim: #0088aa;
            --gold: #ffd700;
            --text: #e0e0e0;
            --text-dim: #888;
            --border: rgba(255,255,255,0.1);
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: var(--bg-dark);
            color: var(--text);
            overflow: hidden;
            height: 100vh;
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: crosshair;
        }

        .ui-layer {
            position: fixed;
            z-index: 100;
            pointer-events: none;
        }

        .ui-layer > * {
            pointer-events: auto;
        }

        /* Header */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            padding: 12px 20px;
            background: linear-gradient(180deg, rgba(0,0,0,0.8) 0%, transparent 100%);
            display: flex;
            align-items: center;
            gap: 20px;
            z-index: 100;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .logo-icon {
            width: 36px;
            height: 36px;
            background: linear-gradient(135deg, var(--accent), #ff00aa);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
        }

        .logo-text {
            font-weight: 700;
            font-size: 16px;
            letter-spacing: -0.5px;
        }

        .logo-sub {
            font-size: 10px;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Coordinates Display */
        .coords-display {
            background: var(--bg-panel);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 8px 14px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 11px;
            display: flex;
            gap: 16px;
        }

        .coord-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .coord-label {
            color: var(--text-dim);
        }

        .coord-value {
            color: var(--accent);
        }

        /* Zoom indicator */
        .zoom-indicator {
            margin-left: auto;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .zoom-bar {
            width: 120px;
            height: 6px;
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
            overflow: hidden;
        }

        .zoom-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent), #ff00aa);
            border-radius: 3px;
            transition: width 0.3s ease;
        }

        .zoom-text {
            font-size: 11px;
            color: var(--text-dim);
            min-width: 80px;
        }

        /* Controls */
        .controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            display: flex;
            gap: 8px;
            z-index: 100;
        }

        .btn {
            padding: 10px 16px;
            background: var(--bg-panel);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text);
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .btn:hover {
            background: rgba(0,212,255,0.15);
            border-color: var(--accent);
        }

        .btn.active {
            background: rgba(0,212,255,0.2);
            border-color: var(--accent);
            color: var(--accent);
        }

        /* Info Panel */
        .info-panel {
            position: fixed;
            top: 70px;
            right: 20px;
            width: 320px;
            background: var(--bg-panel);
            border: 1px solid var(--border);
            border-radius: 12px;
            overflow: hidden;
            z-index: 100;
            opacity: 0;
            transform: translateX(20px);
            transition: all 0.3s ease;
            pointer-events: none;
        }

        .info-panel.visible {
            opacity: 1;
            transform: translateX(0);
            pointer-events: auto;
        }

        .info-header {
            padding: 14px 16px;
            background: linear-gradient(135deg, rgba(0,212,255,0.2), rgba(255,0,170,0.2));
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .info-title {
            font-weight: 600;
            font-size: 14px;
        }

        .info-close {
            width: 24px;
            height: 24px;
            background: rgba(255,255,255,0.1);
            border: none;
            border-radius: 50%;
            color: var(--text);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .info-body {
            padding: 16px;
            max-height: 60vh;
            overflow-y: auto;
        }

        .info-section {
            margin-bottom: 16px;
        }

        .info-section:last-child {
            margin-bottom: 0;
        }

        .info-section-title {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-dim);
            margin-bottom: 8px;
        }

        .inhabitant-card {
            background: rgba(255,255,255,0.03);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
        }

        .inhabitant-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
        }

        .inhabitant-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
        }

        .inhabitant-name {
            font-weight: 600;
            font-size: 13px;
        }

        .inhabitant-role {
            font-size: 11px;
            color: var(--accent);
        }

        .inhabitant-story {
            font-size: 12px;
            line-height: 1.5;
            color: var(--text-dim);
        }

        .math-properties {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .math-prop {
            background: rgba(255,255,255,0.03);
            padding: 8px 10px;
            border-radius: 6px;
            font-size: 11px;
        }

        .math-prop-label {
            color: var(--text-dim);
            display: block;
            margin-bottom: 2px;
        }

        .math-prop-value {
            color: var(--gold);
            font-family: monospace;
        }

        /* City overlay */
        .city-mode-indicator {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 10px 16px;
            background: linear-gradient(135deg, rgba(255,215,0,0.2), rgba(255,100,0,0.2));
            border: 1px solid var(--gold);
            border-radius: 8px;
            font-size: 12px;
            color: var(--gold);
            z-index: 100;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .city-mode-indicator.visible {
            opacity: 1;
        }

        /* Building highlight */
        .building-highlight {
            position: fixed;
            border: 2px solid var(--accent);
            border-radius: 4px;
            pointer-events: none;
            z-index: 50;
            box-shadow: 0 0 20px var(--accent);
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .building-highlight.visible {
            opacity: 1;
        }

        /* Instructions */
        .instructions {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-panel);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 10px 20px;
            font-size: 11px;
            color: var(--text-dim);
            display: flex;
            gap: 20px;
            z-index: 100;
        }

        .instruction-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .key {
            background: rgba(255,255,255,0.1);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 10px;
        }

        /* Discovery log */
        .discovery-log {
            position: fixed;
            top: 70px;
            left: 20px;
            width: 260px;
            max-height: 300px;
            overflow-y: auto;
            z-index: 100;
        }

        .discovery-item {
            background: var(--bg-panel);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 10px 12px;
            margin-bottom: 8px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .discovery-item:hover {
            border-color: var(--accent);
            transform: translateX(4px);
        }

        .discovery-coords {
            font-family: monospace;
            color: var(--accent);
            font-size: 9px;
            margin-bottom: 4px;
        }

        .discovery-name {
            font-weight: 600;
        }

        /* Loading overlay */
        .loading-overlay {
            position: fixed;
            inset: 0;
            background: var(--bg-dark);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 0.5s ease;
        }

        .loading-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 3px solid var(--border);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            font-size: 14px;
            color: var(--text-dim);
        }

        /* Data controls */
        .data-controls {
            position: fixed;
            top: 12px;
            right: 20px;
            display: flex;
            gap: 8px;
            z-index: 100;
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent-dim);
        }
    </style>
</head>
<body>
    <div class="loading-overlay" id="loading">
        <div class="loading-spinner"></div>
        <div class="loading-text">Generating infinite universe...</div>
    </div>

    <canvas id="canvas"></canvas>

    <div class="header">
        <div class="logo">
            <div class="logo-icon">üåå</div>
            <div>
                <div class="logo-text">Living Mandelbrot City</div>
                <div class="logo-sub">Infinite Mathematical Universe</div>
            </div>
        </div>
        <div class="coords-display">
            <div class="coord-item">
                <span class="coord-label">Re:</span>
                <span class="coord-value" id="coord-re">-0.5</span>
            </div>
            <div class="coord-item">
                <span class="coord-label">Im:</span>
                <span class="coord-value" id="coord-im">0</span>
            </div>
            <div class="coord-item">
                <span class="coord-label">Iterations:</span>
                <span class="coord-value" id="iterations">0</span>
            </div>
        </div>
        <div class="zoom-indicator">
            <div class="zoom-bar">
                <div class="zoom-fill" id="zoom-fill" style="width: 10%"></div>
            </div>
            <div class="zoom-text" id="zoom-text">Zoom: 1x</div>
        </div>
    </div>

    <div class="data-controls">
        <button class="btn" onclick="exportData()">üíæ Export</button>
        <button class="btn" onclick="document.getElementById('importFile').click()">üìÇ Import</button>
        <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importData(event)">
    </div>

    <div class="controls">
        <button class="btn" onclick="resetView()">üè† Reset</button>
        <button class="btn" onclick="toggleAutoExplore()" id="autoExploreBtn">üîÆ Auto Explore</button>
        <button class="btn" onclick="saveLocation()">üìç Bookmark</button>
        <button class="btn" onclick="randomJump()">üé≤ Random Jump</button>
    </div>

    <div class="discovery-log" id="discoveryLog"></div>

    <div class="info-panel" id="infoPanel">
        <div class="info-header">
            <span class="info-title" id="buildingTitle">District Information</span>
            <button class="info-close" onclick="closeInfoPanel()">√ó</button>
        </div>
        <div class="info-body" id="infoBody"></div>
    </div>

    <div class="city-mode-indicator" id="cityIndicator">
        üèôÔ∏è City View Active ‚Äî Click buildings to meet inhabitants
    </div>

    <div class="building-highlight" id="buildingHighlight"></div>

    <div class="instructions">
        <div class="instruction-item"><span class="key">Scroll</span> Zoom in/out</div>
        <div class="instruction-item"><span class="key">Drag</span> Pan view</div>
        <div class="instruction-item"><span class="key">Click</span> Inspect location</div>
        <div class="instruction-item"><span class="key">Space</span> Random jump</div>
    </div>

    <script>
        // ============================================
        // LIVING MANDELBROT CITY
        // Where mathematics becomes civilization
        // ============================================

        const APP_NAME = 'mandelbrot-city';

        // State
        let state = {
            centerX: -0.5,
            centerY: 0,
            zoom: 1,
            maxIterations: 100,
            discoveries: [],
            bookmarks: [],
            autoExplore: false
        };

        // Canvas setup
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let width, height;
        let imageData;
        let isRendering = false;
        let isDragging = false;
        let dragStartX, dragStartY, dragCenterX, dragCenterY;
        let hoveredBuilding = null;
        let cityMode = false;
        let cityData = null;

        // Seeded random for deterministic generation
        function seededRandom(seed) {
            const x = Math.sin(seed * 9999.9999) * 10000;
            return x - Math.floor(x);
        }

        function mulberry32(seed) {
            return function() {
                let t = seed += 0x6D2B79F5;
                t = Math.imul(t ^ t >>> 15, t | 1);
                t ^= t + Math.imul(t ^ t >>> 7, t | 61);
                return ((t ^ t >>> 14) >>> 0) / 4294967296;
            };
        }

        // Initialize
        function init() {
            loadState();
            resize();
            window.addEventListener('resize', resize);
            setupEventListeners();
            render();
            updateUI();

            setTimeout(() => {
                document.getElementById('loading').classList.add('hidden');
            }, 500);
        }

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            imageData = ctx.createImageData(width, height);
            render();
        }

        // Event listeners
        function setupEventListeners() {
            canvas.addEventListener('wheel', handleWheel, { passive: false });
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('mouseleave', handleMouseUp);
            canvas.addEventListener('click', handleClick);
            document.addEventListener('keydown', handleKeyDown);
        }

        function handleWheel(e) {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            // Convert mouse position to complex plane
            const scale = 4 / (state.zoom * Math.min(width, height));
            const re = state.centerX + (mouseX - width/2) * scale;
            const im = state.centerY + (mouseY - height/2) * scale;

            // Zoom factor
            const factor = e.deltaY > 0 ? 0.9 : 1.1;
            state.zoom *= factor;

            // Adjust center to zoom towards mouse position
            state.centerX = re - (mouseX - width/2) * (4 / (state.zoom * Math.min(width, height)));
            state.centerY = im - (mouseY - height/2) * (4 / (state.zoom * Math.min(width, height)));

            // Increase iterations at deeper zoom
            state.maxIterations = Math.min(1000, Math.floor(100 + Math.log2(state.zoom) * 20));

            updateUI();
            render();
        }

        function handleMouseDown(e) {
            isDragging = true;
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            dragCenterX = state.centerX;
            dragCenterY = state.centerY;
            canvas.style.cursor = 'grabbing';
        }

        function handleMouseMove(e) {
            if (isDragging) {
                const scale = 4 / (state.zoom * Math.min(width, height));
                state.centerX = dragCenterX - (e.clientX - dragStartX) * scale;
                state.centerY = dragCenterY - (e.clientY - dragStartY) * scale;
                updateUI();
                render();
            } else if (cityMode) {
                // Check for building hover
                checkBuildingHover(e.clientX, e.clientY);
            }
        }

        function handleMouseUp() {
            isDragging = false;
            canvas.style.cursor = 'crosshair';
        }

        function handleClick(e) {
            if (isDragging) return;

            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            if (cityMode && hoveredBuilding) {
                showBuildingInfo(hoveredBuilding);
            } else {
                // Show location info
                const scale = 4 / (state.zoom * Math.min(width, height));
                const re = state.centerX + (mouseX - width/2) * scale;
                const im = state.centerY + (mouseY - height/2) * scale;
                showLocationInfo(re, im);
            }
        }

        function handleKeyDown(e) {
            if (e.code === 'Space') {
                e.preventDefault();
                randomJump();
            }
        }

        // Mandelbrot calculation
        function mandelbrot(re, im, maxIter) {
            let zRe = 0, zIm = 0;
            let n = 0;

            while (n < maxIter) {
                const zRe2 = zRe * zRe;
                const zIm2 = zIm * zIm;

                if (zRe2 + zIm2 > 4) break;

                zIm = 2 * zRe * zIm + im;
                zRe = zRe2 - zIm2 + re;
                n++;
            }

            // Smooth coloring
            if (n < maxIter) {
                const log_zn = Math.log(zRe * zRe + zIm * zIm) / 2;
                const nu = Math.log(log_zn / Math.log(2)) / Math.log(2);
                n = n + 1 - nu;
            }

            return { iterations: n, escaped: n < maxIter, finalZ: { re: zRe, im: zIm } };
        }

        // Color mapping
        function getColor(result, maxIter) {
            if (!result.escaped) {
                // Inside the set - dark with subtle variation
                const seed = result.finalZ.re * 1000 + result.finalZ.im * 1000;
                const v = Math.floor(10 + seededRandom(seed) * 15);
                return [v, v, v + 5];
            }

            const t = result.iterations / maxIter;

            // Beautiful gradient
            const r = Math.floor(9 * (1 - t) * t * t * t * 255);
            const g = Math.floor(15 * (1 - t) * (1 - t) * t * t * 255);
            const b = Math.floor(8.5 * (1 - t) * (1 - t) * (1 - t) * t * 255);

            return [
                Math.min(255, r + 20),
                Math.min(255, g + 40),
                Math.min(255, b + 80)
            ];
        }

        // Render
        function render() {
            if (isRendering) return;
            isRendering = true;

            const scale = 4 / (state.zoom * Math.min(width, height));
            const data = imageData.data;

            // Check if we should switch to city mode
            cityMode = state.zoom > 100000;
            document.getElementById('cityIndicator').classList.toggle('visible', cityMode);

            if (cityMode) {
                renderCity(scale, data);
            } else {
                renderFractal(scale, data);
            }

            ctx.putImageData(imageData, 0, 0);
            isRendering = false;
            saveState();
        }

        function renderFractal(scale, data) {
            for (let py = 0; py < height; py++) {
                for (let px = 0; px < width; px++) {
                    const re = state.centerX + (px - width/2) * scale;
                    const im = state.centerY + (py - height/2) * scale;

                    const result = mandelbrot(re, im, state.maxIterations);
                    const color = getColor(result, state.maxIterations);

                    const idx = (py * width + px) * 4;
                    data[idx] = color[0];
                    data[idx + 1] = color[1];
                    data[idx + 2] = color[2];
                    data[idx + 3] = 255;
                }
            }
        }

        function renderCity(scale, data) {
            // Generate city based on coordinates
            const seed = Math.floor((state.centerX * 1e10 + state.centerY * 1e10) % 1e9);
            const rng = mulberry32(seed);

            cityData = generateCityData(seed, rng);

            // Render city grid
            const gridSize = 40;
            const buildings = cityData.buildings;

            // Background
            for (let i = 0; i < data.length; i += 4) {
                data[i] = 15;
                data[i + 1] = 15;
                data[i + 2] = 25;
                data[i + 3] = 255;
            }

            // Draw buildings
            buildings.forEach(building => {
                const x = Math.floor(building.x * width);
                const y = Math.floor(building.y * height);
                const w = Math.floor(building.width * width);
                const h = Math.floor(building.height * height);

                for (let py = y; py < y + h && py < height; py++) {
                    for (let px = x; px < x + w && px < width; px++) {
                        if (px >= 0 && py >= 0) {
                            const idx = (py * width + px) * 4;

                            // Building color based on type
                            const colors = {
                                residential: [60, 70, 90],
                                commercial: [80, 60, 100],
                                industrial: [70, 80, 70],
                                civic: [100, 80, 60],
                                park: [30, 80, 50]
                            };

                            const baseColor = colors[building.type] || [70, 70, 80];
                            const brightness = 0.7 + building.prosperity * 0.3;

                            // Window lights
                            const isWindow = (px - x) % 8 < 3 && (py - y) % 6 < 2 && building.type !== 'park';
                            const windowLit = rng() > 0.6;

                            if (isWindow && windowLit && building.type !== 'park') {
                                data[idx] = 255;
                                data[idx + 1] = 230;
                                data[idx + 2] = 150;
                            } else {
                                data[idx] = Math.floor(baseColor[0] * brightness);
                                data[idx + 1] = Math.floor(baseColor[1] * brightness);
                                data[idx + 2] = Math.floor(baseColor[2] * brightness);
                            }
                            data[idx + 3] = 255;
                        }
                    }
                }

                // Building border
                for (let px = x; px < x + w && px < width; px++) {
                    if (px >= 0) {
                        const topIdx = (y * width + px) * 4;
                        const botIdx = ((y + h - 1) * width + px) * 4;
                        if (y >= 0) { data[topIdx] = 40; data[topIdx+1] = 40; data[topIdx+2] = 50; }
                        if (y + h < height) { data[botIdx] = 20; data[botIdx+1] = 20; data[botIdx+2] = 30; }
                    }
                }
            });

            // Draw roads
            for (let py = 0; py < height; py++) {
                for (let px = 0; px < width; px++) {
                    const gridX = px % gridSize;
                    const gridY = py % gridSize;

                    if (gridX < 3 || gridY < 3) {
                        const idx = (py * width + px) * 4;
                        if (data[idx] < 30) { // Only draw on empty space
                            data[idx] = 35;
                            data[idx + 1] = 35;
                            data[idx + 2] = 40;
                        }
                    }
                }
            }
        }

        function generateCityData(seed, rng) {
            const districtType = ['residential', 'commercial', 'industrial', 'mixed'][Math.floor(rng() * 4)];
            const prosperity = rng();
            const age = Math.floor(rng() * 500) + 50;
            const population = Math.floor(rng() * 50000) + 1000;

            const buildings = [];
            const numBuildings = Math.floor(rng() * 20) + 15;

            for (let i = 0; i < numBuildings; i++) {
                const type = rng() > 0.7 ? districtType : ['residential', 'commercial', 'industrial', 'civic', 'park'][Math.floor(rng() * 5)];

                buildings.push({
                    id: i,
                    x: rng() * 0.9 + 0.05,
                    y: rng() * 0.9 + 0.05,
                    width: rng() * 0.08 + 0.03,
                    height: rng() * 0.1 + 0.04,
                    type: type,
                    prosperity: rng(),
                    inhabitants: generateInhabitants(seed + i * 1000, mulberry32(seed + i * 1000)),
                    name: generateBuildingName(seed + i, type, rng)
                });
            }

            return {
                seed,
                districtType,
                prosperity,
                age,
                population,
                buildings,
                name: generateDistrictName(seed, rng)
            };
        }

        function generateDistrictName(seed, rng) {
            const prefixes = ['New', 'Old', 'Upper', 'Lower', 'East', 'West', 'North', 'South', 'Central', 'Golden', 'Silver', 'Crystal', 'Emerald', 'Azure'];
            const roots = ['haven', 'brook', 'field', 'vale', 'ridge', 'crest', 'dale', 'wood', 'port', 'gate', 'hill', 'cliff', 'shore', 'marsh', 'grove'];
            const suffixes = ['District', 'Quarter', 'Heights', 'Commons', 'Gardens', 'Plaza', 'Square', 'Terrace', 'Point', 'Landing'];

            return `${prefixes[Math.floor(rng() * prefixes.length)]}${roots[Math.floor(rng() * roots.length)]} ${suffixes[Math.floor(rng() * suffixes.length)]}`;
        }

        function generateBuildingName(seed, type, rng) {
            const names = {
                residential: ['Apartments', 'Residences', 'Tower', 'House', 'Manor', 'Lodge', 'Suites'],
                commercial: ['Plaza', 'Center', 'Mall', 'Market', 'Emporium', 'Arcade', 'Exchange'],
                industrial: ['Works', 'Factory', 'Mill', 'Foundry', 'Warehouse', 'Depot', 'Plant'],
                civic: ['Hall', 'Center', 'Library', 'Museum', 'Court', 'Institute', 'Academy'],
                park: ['Gardens', 'Park', 'Green', 'Commons', 'Square', 'Grove', 'Meadow']
            };

            const adjectives = ['Grand', 'Royal', 'Imperial', 'Noble', 'Prime', 'Elite', 'Premier', 'Supreme'];

            return `${adjectives[Math.floor(rng() * adjectives.length)]} ${names[type][Math.floor(rng() * names[type].length)]}`;
        }

        function generateInhabitants(seed, rng) {
            const numInhabitants = Math.floor(rng() * 4) + 1;
            const inhabitants = [];

            const firstNames = ['Aria', 'Zephyr', 'Nova', 'Felix', 'Luna', 'Atlas', 'Iris', 'Orion', 'Sage', 'Phoenix', 'Echo', 'Jasper', 'Willow', 'River', 'Storm', 'Aurora', 'Blaze', 'Crystal', 'Drake', 'Ember'];
            const lastNames = ['Starweaver', 'Moonshade', 'Brightforge', 'Thornwood', 'Silverstream', 'Nightingale', 'Stormwind', 'Goldleaf', 'Ironheart', 'Shadowmere', 'Sunfire', 'Frostborn', 'Ashwood', 'Dawnbringer', 'Ravenscroft'];

            const occupations = ['Mathematician', 'Dream Architect', 'Memory Curator', 'Pattern Weaver', 'Number Theorist', 'Infinity Cartographer', 'Fractal Artist', 'Chaos Navigator', 'Iteration Scholar', 'Convergence Seeker', 'Recursive Philosopher', 'Set Theorist', 'Complex Analyst', 'Limit Explorer', 'Boundary Walker'];

            for (let i = 0; i < numInhabitants; i++) {
                const inhabitantSeed = seed + i * 777;
                const iRng = mulberry32(inhabitantSeed);

                const name = `${firstNames[Math.floor(iRng() * firstNames.length)]} ${lastNames[Math.floor(iRng() * lastNames.length)]}`;
                const age = Math.floor(iRng() * 60) + 18;
                const occupation = occupations[Math.floor(iRng() * occupations.length)];

                inhabitants.push({
                    name,
                    age,
                    occupation,
                    story: generateLifeStory(inhabitantSeed, name, age, occupation, iRng),
                    avatar: generateAvatar(iRng),
                    mathAffinity: getMathAffinityFromCoords(state.centerX, state.centerY, iRng)
                });
            }

            return inhabitants;
        }

        function generateAvatar(rng) {
            const hue = Math.floor(rng() * 360);
            return `hsl(${hue}, 60%, 50%)`;
        }

        function generateLifeStory(seed, name, age, occupation, rng) {
            const origins = [
                `Born at the edge of convergence, where iterations spiral toward infinity`,
                `Emerged from a particularly beautiful Julia set at coordinates ¬±${(rng() * 2).toFixed(4)}`,
                `Descended from a long line of boundary dwellers, always at the edge of the set`,
                `Created in the flash of an iteration overflow, their existence a beautiful error`,
                `Materialized when two escape trajectories crossed at exactly this point`
            ];

            const drives = [
                `Dedicated their life to mapping the infinite coastline of the Mandelbrot boundary`,
                `Seeks to understand why certain coordinates produce such magnificent spirals`,
                `Believes that every point in the set contains a unique mathematical truth`,
                `Spends nights counting iterations, finding poetry in the numbers`,
                `Dreams of finding the deepest zoom level where mathematics becomes music`
            ];

            const quirks = [
                `They can sense iteration counts just by touching a surface`,
                `Their mood changes with the local escape velocity of nearby points`,
                `Collects minibrots - tiny copies of the set found at extreme zooms`,
                `Speaks in recursive sentences that always reference themselves`,
                `Has memorized the first thousand digits of every famous mathematical constant`
            ];

            const coordStory = `Their existence is anchored to coordinates (${state.centerX.toExponential(4)}, ${state.centerY.toExponential(4)})i, a location they consider sacred.`;

            return `${origins[Math.floor(rng() * origins.length)]}. ${drives[Math.floor(rng() * drives.length)]}. ${quirks[Math.floor(rng() * quirks.length)]}. ${coordStory}`;
        }

        function getMathAffinityFromCoords(re, im, rng) {
            const result = mandelbrot(re, im, 100);
            const affinities = [];

            if (result.iterations > 50) affinities.push('Deep Convergence');
            if (result.iterations < 20) affinities.push('Swift Escape');
            if (Math.abs(re) < 0.1 && Math.abs(im) < 0.1) affinities.push('Origin Affinity');
            if (re < -1.5) affinities.push('Tail Dweller');
            if (Math.abs(im) > 0.8) affinities.push('Imaginary Inclination');

            return affinities.length > 0 ? affinities : ['Balanced Coordinates'];
        }

        function checkBuildingHover(mouseX, mouseY) {
            if (!cityData) return;

            hoveredBuilding = null;
            const highlight = document.getElementById('buildingHighlight');

            for (const building of cityData.buildings) {
                const x = building.x * width;
                const y = building.y * height;
                const w = building.width * width;
                const h = building.height * height;

                if (mouseX >= x && mouseX <= x + w && mouseY >= y && mouseY <= y + h) {
                    hoveredBuilding = building;
                    highlight.style.left = x + 'px';
                    highlight.style.top = y + 'px';
                    highlight.style.width = w + 'px';
                    highlight.style.height = h + 'px';
                    highlight.classList.add('visible');
                    canvas.style.cursor = 'pointer';
                    return;
                }
            }

            highlight.classList.remove('visible');
            canvas.style.cursor = 'crosshair';
        }

        function showBuildingInfo(building) {
            const panel = document.getElementById('infoPanel');
            const title = document.getElementById('buildingTitle');
            const body = document.getElementById('infoBody');

            title.textContent = building.name;

            let inhabitantsHtml = building.inhabitants.map(i => `
                <div class="inhabitant-card">
                    <div class="inhabitant-header">
                        <div class="inhabitant-avatar" style="background: ${i.avatar}">${i.name.charAt(0)}</div>
                        <div>
                            <div class="inhabitant-name">${i.name}</div>
                            <div class="inhabitant-role">${i.occupation}, Age ${i.age}</div>
                        </div>
                    </div>
                    <div class="inhabitant-story">${i.story}</div>
                    <div style="margin-top: 8px; font-size: 10px; color: var(--gold);">
                        Math Affinity: ${i.mathAffinity.join(', ')}
                    </div>
                </div>
            `).join('');

            body.innerHTML = `
                <div class="info-section">
                    <div class="info-section-title">Building Type</div>
                    <div style="text-transform: capitalize; color: var(--accent);">${building.type}</div>
                </div>
                <div class="info-section">
                    <div class="info-section-title">Mathematical Properties</div>
                    <div class="math-properties">
                        <div class="math-prop">
                            <span class="math-prop-label">Prosperity Index</span>
                            <span class="math-prop-value">${(building.prosperity * 100).toFixed(1)}%</span>
                        </div>
                        <div class="math-prop">
                            <span class="math-prop-label">Building Seed</span>
                            <span class="math-prop-value">${building.id}</span>
                        </div>
                    </div>
                </div>
                <div class="info-section">
                    <div class="info-section-title">Inhabitants (${building.inhabitants.length})</div>
                    ${inhabitantsHtml}
                </div>
            `;

            panel.classList.add('visible');
        }

        function showLocationInfo(re, im) {
            const result = mandelbrot(re, im, state.maxIterations);
            const panel = document.getElementById('infoPanel');
            const title = document.getElementById('buildingTitle');
            const body = document.getElementById('infoBody');

            const locationName = generateLocationName(re, im);
            title.textContent = locationName;

            body.innerHTML = `
                <div class="info-section">
                    <div class="info-section-title">Coordinates</div>
                    <div class="math-properties">
                        <div class="math-prop">
                            <span class="math-prop-label">Real</span>
                            <span class="math-prop-value">${re.toExponential(6)}</span>
                        </div>
                        <div class="math-prop">
                            <span class="math-prop-label">Imaginary</span>
                            <span class="math-prop-value">${im.toExponential(6)}</span>
                        </div>
                    </div>
                </div>
                <div class="info-section">
                    <div class="info-section-title">Mathematical Properties</div>
                    <div class="math-properties">
                        <div class="math-prop">
                            <span class="math-prop-label">Iterations</span>
                            <span class="math-prop-value">${Math.floor(result.iterations)}</span>
                        </div>
                        <div class="math-prop">
                            <span class="math-prop-label">Status</span>
                            <span class="math-prop-value">${result.escaped ? 'Escaped' : 'In Set'}</span>
                        </div>
                        <div class="math-prop">
                            <span class="math-prop-label">|z| final</span>
                            <span class="math-prop-value">${Math.sqrt(result.finalZ.re**2 + result.finalZ.im**2).toFixed(4)}</span>
                        </div>
                        <div class="math-prop">
                            <span class="math-prop-label">Zoom Level</span>
                            <span class="math-prop-value">${state.zoom.toExponential(2)}</span>
                        </div>
                    </div>
                </div>
                <div class="info-section">
                    <div class="info-section-title">Location Lore</div>
                    <div style="font-size: 12px; line-height: 1.6; color: var(--text-dim);">
                        ${generateLocationLore(re, im, result)}
                    </div>
                </div>
            `;

            panel.classList.add('visible');
        }

        function generateLocationName(re, im) {
            const seed = Math.abs(re * 1e6 + im * 1e6) % 1000;
            const rng = mulberry32(seed);

            const prefixes = ['Point', 'Vertex', 'Node', 'Nexus', 'Locus', 'Singularity', 'Confluence', 'Spiral'];
            const names = ['Mandel', 'Julia', 'Fatou', 'Cantor', 'Hausdorff', 'Benoit', 'Gaston', 'Iteration'];
            const suffixes = ['Prime', 'Complex', 'Infinite', 'Recursive', 'Chaotic', 'Convergent', 'Periodic'];

            return `${prefixes[Math.floor(rng() * prefixes.length)]} ${names[Math.floor(rng() * names.length)]}-${suffixes[Math.floor(rng() * suffixes.length)]}`;
        }

        function generateLocationLore(re, im, result) {
            const seed = Math.abs(re * 1e8 + im * 1e8) % 10000;
            const rng = mulberry32(seed);

            const lores = [
                `This coordinate marks where the ancient mathematicians first glimpsed infinity. Legend says ${Math.floor(result.iterations)} iterations were counted here before the observers transcended understanding.`,
                `The boundary here ripples with potential energy. Each zoom level reveals new civilizations, each unaware they exist within the dreams of those above.`,
                `At this precise location, the ratio of escaped to trapped points achieves perfect harmony. Pilgrims travel across the complex plane to meditate here.`,
                `Historical records indicate this was the site of the Great Divergence, when iteration ${Math.floor(result.iterations)} caused a cascade that shaped the entire western boundary.`,
                `The mathematics here sing. Those with trained ears can hear the convergence series approaching their limit, a sound described as "the whisper of infinity."`
            ];

            return lores[Math.floor(rng() * lores.length)];
        }

        function closeInfoPanel() {
            document.getElementById('infoPanel').classList.remove('visible');
        }

        // UI Updates
        function updateUI() {
            document.getElementById('coord-re').textContent = state.centerX.toExponential(6);
            document.getElementById('coord-im').textContent = state.centerY.toExponential(6);
            document.getElementById('iterations').textContent = state.maxIterations;

            const zoomLog = Math.log10(state.zoom);
            const zoomPercent = Math.min(100, (zoomLog / 15) * 100);
            document.getElementById('zoom-fill').style.width = zoomPercent + '%';
            document.getElementById('zoom-text').textContent = `Zoom: ${state.zoom.toExponential(1)}`;

            updateDiscoveryLog();
        }

        function updateDiscoveryLog() {
            const log = document.getElementById('discoveryLog');
            log.innerHTML = state.discoveries.slice(-5).reverse().map(d => `
                <div class="discovery-item" onclick="jumpTo(${d.x}, ${d.y}, ${d.zoom})">
                    <div class="discovery-coords">(${d.x.toExponential(4)}, ${d.y.toExponential(4)}i)</div>
                    <div class="discovery-name">${d.name}</div>
                </div>
            `).join('');
        }

        // Actions
        function resetView() {
            state.centerX = -0.5;
            state.centerY = 0;
            state.zoom = 1;
            state.maxIterations = 100;
            updateUI();
            render();
        }

        function randomJump() {
            // Jump to interesting locations in the Mandelbrot set
            const interestingPoints = [
                { x: -0.761574, y: -0.0847596, name: 'Elephant Valley' },
                { x: -0.16, y: 1.0405, name: 'Seahorse Tail' },
                { x: -1.25066, y: 0.02012, name: 'Western Antenna' },
                { x: -0.745429, y: 0.113009, name: 'Triple Spiral' },
                { x: -1.985424, y: 0, name: 'Period-3 Bulb' },
                { x: -0.1011, y: 0.9563, name: 'Spiral Galaxy' },
                { x: -1.769110375, y: 0.00423684791, name: 'Deep Zoom Point' }
            ];

            const point = interestingPoints[Math.floor(Math.random() * interestingPoints.length)];
            const jitter = (Math.random() - 0.5) * 0.0001;

            state.centerX = point.x + jitter;
            state.centerY = point.y + jitter;
            state.zoom = Math.pow(10, Math.random() * 8 + 2);
            state.maxIterations = Math.min(1000, Math.floor(100 + Math.log2(state.zoom) * 20));

            addDiscovery(point.name);
            updateUI();
            render();
        }

        function jumpTo(x, y, zoom) {
            state.centerX = x;
            state.centerY = y;
            state.zoom = zoom;
            state.maxIterations = Math.min(1000, Math.floor(100 + Math.log2(state.zoom) * 20));
            updateUI();
            render();
        }

        function saveLocation() {
            const name = generateLocationName(state.centerX, state.centerY);
            state.bookmarks.push({
                x: state.centerX,
                y: state.centerY,
                zoom: state.zoom,
                name: name,
                timestamp: Date.now()
            });
            addDiscovery(name);
            saveState();

            if (window.dialogManager) {
                window.dialogManager.info(`Bookmarked: ${name}`, 'Mandelbrot City');
            } else {
                alert(`Bookmarked: ${name}`);
            }
        }

        function addDiscovery(name) {
            state.discoveries.push({
                x: state.centerX,
                y: state.centerY,
                zoom: state.zoom,
                name: name,
                timestamp: Date.now()
            });

            // Keep only last 20 discoveries
            if (state.discoveries.length > 20) {
                state.discoveries = state.discoveries.slice(-20);
            }
        }

        let autoExploreInterval = null;
        function toggleAutoExplore() {
            state.autoExplore = !state.autoExplore;
            document.getElementById('autoExploreBtn').classList.toggle('active', state.autoExplore);

            if (state.autoExplore) {
                autoExploreInterval = setInterval(() => {
                    // Slowly zoom in and drift
                    state.zoom *= 1.02;
                    state.centerX += (Math.random() - 0.5) * 0.0001 / state.zoom;
                    state.centerY += (Math.random() - 0.5) * 0.0001 / state.zoom;
                    state.maxIterations = Math.min(1000, Math.floor(100 + Math.log2(state.zoom) * 20));
                    updateUI();
                    render();
                }, 100);
            } else {
                clearInterval(autoExploreInterval);
            }
        }

        // Persistence
        function saveState() {
            const saveData = {
                centerX: state.centerX,
                centerY: state.centerY,
                zoom: state.zoom,
                discoveries: state.discoveries,
                bookmarks: state.bookmarks
            };
            localStorage.setItem(APP_NAME, JSON.stringify(saveData));
        }

        function loadState() {
            const saved = localStorage.getItem(APP_NAME);
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    state.centerX = data.centerX ?? -0.5;
                    state.centerY = data.centerY ?? 0;
                    state.zoom = data.zoom ?? 1;
                    state.discoveries = data.discoveries ?? [];
                    state.bookmarks = data.bookmarks ?? [];
                    state.maxIterations = Math.min(1000, Math.floor(100 + Math.log2(state.zoom) * 20));
                } catch (e) {
                    console.warn('Failed to load state:', e);
                }
            }
        }

        function exportData() {
            const data = {
                centerX: state.centerX,
                centerY: state.centerY,
                zoom: state.zoom,
                discoveries: state.discoveries,
                bookmarks: state.bookmarks,
                exportDate: new Date().toISOString()
            };

            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `mandelbrot-city-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    state.centerX = data.centerX ?? state.centerX;
                    state.centerY = data.centerY ?? state.centerY;
                    state.zoom = data.zoom ?? state.zoom;
                    state.discoveries = data.discoveries ?? state.discoveries;
                    state.bookmarks = data.bookmarks ?? state.bookmarks;
                    state.maxIterations = Math.min(1000, Math.floor(100 + Math.log2(state.zoom) * 20));
                    updateUI();
                    render();
                } catch (err) {
                    alert('Invalid JSON file');
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        // Initialize
        init();
    </script>
</body>
</html>
