<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Multiplayer Game Engine - Network Reliability</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: #fff;
            overflow: hidden;
        }

        #mainMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.85);
            padding: 40px;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            text-align: center;
            z-index: 1000;
            min-width: 400px;
        }

        #mainMenu h1 {
            margin-bottom: 10px;
            font-size: 32px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        #mainMenu .subtitle {
            color: #4CAF50;
            margin-bottom: 30px;
            font-size: 14px;
        }

        .menu-section {
            margin: 20px 0;
        }

        .menu-section h3 {
            margin-bottom: 15px;
            color: #ffd700;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            margin: 8px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        button.primary {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
        }

        button.secondary {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%);
        }

        input[type="text"] {
            padding: 12px;
            margin: 8px;
            border-radius: 8px;
            border: 2px solid #667eea;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 16px;
            width: 250px;
        }

        input[type="text"]::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100vh;
        }

        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            display: none;
        }

        #hud div {
            margin: 5px 0;
        }

        #networkStatus {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            min-width: 200px;
            display: none;
        }

        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-connected {
            background: #4CAF50;
            box-shadow: 0 0 10px #4CAF50;
        }

        .status-connecting {
            background: #FFC107;
            box-shadow: 0 0 10px #FFC107;
        }

        .status-disconnected {
            background: #f44336;
            box-shadow: 0 0 10px #f44336;
        }

        #chat {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 350px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            display: none;
        }

        #chatMessages {
            height: 200px;
            overflow-y: auto;
            padding: 10px;
            font-size: 14px;
        }

        #chatInput {
            width: calc(100% - 80px);
            padding: 10px;
            border: none;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border-radius: 0 0 0 10px;
        }

        #chatSend {
            width: 80px;
            padding: 10px;
            border-radius: 0 0 10px 0;
            margin: 0;
        }

        #levelEditor {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 30px;
            border-radius: 15px;
            display: none;
            z-index: 1000;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
        }

        #levelEditor h2 {
            margin-bottom: 20px;
        }

        .editor-controls {
            margin: 15px 0;
        }

        .editor-controls label {
            display: inline-block;
            width: 120px;
        }

        #playerList {
            position: absolute;
            top: 120px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            display: none;
            min-width: 200px;
        }

        .player-item {
            margin: 5px 0;
            padding: 5px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
        }

        #replayControls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            display: none;
        }

        .latency-warning {
            color: #FFC107;
            font-weight: bold;
        }

        .latency-critical {
            color: #f44336;
            font-weight: bold;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            text-align: center;
            display: none;
        }

        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #fff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        #errorDisplay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(244, 67, 54, 0.95);
            padding: 30px;
            border-radius: 10px;
            display: none;
            z-index: 2000;
            max-width: 500px;
        }

        .connection-quality {
            margin-top: 10px;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
        }

        .quality-excellent { color: #4CAF50; }
        .quality-good { color: #8BC34A; }
        .quality-fair { color: #FFC107; }
        .quality-poor { color: #FF9800; }
        .quality-bad { color: #f44336; }
    </style>
</head>
<body>
    <div id="mainMenu">
        <h1>3D Multiplayer Engine</h1>
        <div class="subtitle">Network Reliability Edition</div>

        <div class="menu-section">
            <h3>Multiplayer</h3>
            <input type="text" id="playerName" placeholder="Your Name" value="Player">
            <br>
            <button class="primary" onclick="createRoom()">Create Room</button>
            <br>
            <input type="text" id="roomCode" placeholder="Room Code">
            <button class="primary" onclick="joinRoom()">Join Room</button>
        </div>

        <div class="menu-section">
            <h3>Single Player</h3>
            <button onclick="startSinglePlayer()">Play Solo</button>
            <button onclick="openLevelEditor()">Level Editor</button>
        </div>

        <div class="menu-section">
            <button onclick="loadReplay()">Load Replay</button>
            <button onclick="showHelp()">Help</button>
        </div>
    </div>

    <div id="loading" class="loading">
        <div>Connecting...</div>
        <div class="spinner"></div>
        <div id="loadingStatus"></div>
    </div>

    <div id="errorDisplay">
        <h2>Connection Error</h2>
        <p id="errorMessage"></p>
        <button onclick="closeError()">OK</button>
        <button onclick="retryConnection()">Retry</button>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="hud">
        <div>FPS: <span id="fps">0</span></div>
        <div>Position: <span id="position">0, 0, 0</span></div>
        <div>Players: <span id="playerCount">1</span></div>
        <div>Room: <span id="roomDisplay">Solo</span></div>
        <div id="controls">
            WASD: Move | Space: Jump | E: Level Editor | R: Record | P: Save Replay
        </div>
    </div>

    <div id="networkStatus">
        <div><span class="status-indicator status-disconnected" id="statusDot"></span><span id="connectionStatus">Offline</span></div>
        <div>Ping: <span id="ping">0</span>ms</div>
        <div>Packet Loss: <span id="packetLoss">0</span>%</div>
        <div>Bandwidth: <span id="bandwidth">0</span> KB/s</div>
        <div class="connection-quality">
            Quality: <span id="quality" class="quality-excellent">Excellent</span>
        </div>
        <div style="margin-top: 10px; font-size: 12px;">
            <div>Sent: <span id="bytesSent">0</span> KB</div>
            <div>Received: <span id="bytesReceived">0</span> KB</div>
            <div>Reconnects: <span id="reconnectCount">0</span></div>
        </div>
    </div>

    <div id="playerList">
        <h3>Players</h3>
        <div id="playerListContent"></div>
    </div>

    <div id="chat">
        <div id="chatMessages"></div>
        <div style="display: flex;">
            <input type="text" id="chatInput" placeholder="Type message...">
            <button id="chatSend" onclick="sendChat()">Send</button>
        </div>
    </div>

    <div id="levelEditor">
        <h2>Level Editor</h2>
        <div class="editor-controls">
            <label>Object Type:</label>
            <select id="objectType">
                <option value="box">Box</option>
                <option value="sphere">Sphere</option>
                <option value="cylinder">Cylinder</option>
                <option value="platform">Platform</option>
            </select>
        </div>
        <div class="editor-controls">
            <label>Size:</label>
            <input type="number" id="objectSize" value="1" step="0.5" min="0.5">
        </div>
        <div class="editor-controls">
            <label>Color:</label>
            <input type="color" id="objectColor" value="#ff6b6b">
        </div>
        <div class="editor-controls">
            <button onclick="placeObject()">Place Object</button>
            <button onclick="deleteObject()">Delete Selected</button>
        </div>
        <div class="editor-controls">
            <button onclick="saveLevel()">Save Level</button>
            <button onclick="loadLevel()">Load Level</button>
            <button onclick="exportLevel()">Export JSON</button>
        </div>
        <div class="editor-controls">
            <button onclick="closeLevelEditor()">Close Editor</button>
        </div>
    </div>

    <div id="replayControls">
        <button onclick="pauseReplay()">Pause</button>
        <button onclick="resumeReplay()">Resume</button>
        <button onclick="stopReplay()">Stop</button>
        <span id="replayTime">0:00 / 0:00</span>
    </div>

    <script>
        // Three.js (r128) - Embedded
        const THREE = (function() {
            'use strict';

            const REVISION = '128';
            const MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };
            const TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };
            const CullFaceNone = 0;
            const CullFaceBack = 1;
            const CullFaceFront = 2;
            const PCFShadowMap = 1;
            const sRGBEncoding = 3001;

            class EventDispatcher {
                addEventListener(type, listener) {
                    if (this._listeners === undefined) this._listeners = {};
                    const listeners = this._listeners;
                    if (listeners[type] === undefined) listeners[type] = [];
                    if (listeners[type].indexOf(listener) === -1) listeners[type].push(listener);
                }
                hasEventListener(type, listener) {
                    if (this._listeners === undefined) return false;
                    const listeners = this._listeners;
                    return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;
                }
                removeEventListener(type, listener) {
                    if (this._listeners === undefined) return;
                    const listeners = this._listeners;
                    const listenerArray = listeners[type];
                    if (listenerArray !== undefined) {
                        const index = listenerArray.indexOf(listener);
                        if (index !== -1) listenerArray.splice(index, 1);
                    }
                }
                dispatchEvent(event) {
                    if (this._listeners === undefined) return;
                    const listeners = this._listeners;
                    const listenerArray = listeners[event.type];
                    if (listenerArray !== undefined) {
                        event.target = this;
                        const array = listenerArray.slice(0);
                        for (let i = 0; i < array.length; i++) {
                            array[i].call(this, event);
                        }
                        event.target = null;
                    }
                }
            }

            class Vector3 {
                constructor(x = 0, y = 0, z = 0) {
                    this.x = x;
                    this.y = y;
                    this.z = z;
                }
                set(x, y, z) {
                    this.x = x;
                    this.y = y;
                    this.z = z;
                    return this;
                }
                clone() {
                    return new Vector3(this.x, this.y, this.z);
                }
                copy(v) {
                    this.x = v.x;
                    this.y = v.y;
                    this.z = v.z;
                    return this;
                }
                add(v) {
                    this.x += v.x;
                    this.y += v.y;
                    this.z += v.z;
                    return this;
                }
                sub(v) {
                    this.x -= v.x;
                    this.y -= v.y;
                    this.z -= v.z;
                    return this;
                }
                multiply(v) {
                    this.x *= v.x;
                    this.y *= v.y;
                    this.z *= v.z;
                    return this;
                }
                multiplyScalar(scalar) {
                    this.x *= scalar;
                    this.y *= scalar;
                    this.z *= scalar;
                    return this;
                }
                length() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
                }
                normalize() {
                    const len = this.length();
                    if (len > 0) {
                        this.multiplyScalar(1 / len);
                    }
                    return this;
                }
                dot(v) {
                    return this.x * v.x + this.y * v.y + this.z * v.z;
                }
                cross(v) {
                    const x = this.x, y = this.y, z = this.z;
                    this.x = y * v.z - z * v.y;
                    this.y = z * v.x - x * v.z;
                    this.z = x * v.y - y * v.x;
                    return this;
                }
                applyQuaternion(q) {
                    const x = this.x, y = this.y, z = this.z;
                    const qx = q.x, qy = q.y, qz = q.z, qw = q.w;
                    const ix = qw * x + qy * z - qz * y;
                    const iy = qw * y + qz * x - qx * z;
                    const iz = qw * z + qx * y - qy * x;
                    const iw = -qx * x - qy * y - qz * z;
                    this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
                    this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
                    this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
                    return this;
                }
            }

            class Quaternion {
                constructor(x = 0, y = 0, z = 0, w = 1) {
                    this.x = x;
                    this.y = y;
                    this.z = z;
                    this.w = w;
                }
                set(x, y, z, w) {
                    this.x = x;
                    this.y = y;
                    this.z = z;
                    this.w = w;
                    return this;
                }
                clone() {
                    return new Quaternion(this.x, this.y, this.z, this.w);
                }
                copy(q) {
                    this.x = q.x;
                    this.y = q.y;
                    this.z = q.z;
                    this.w = q.w;
                    return this;
                }
                setFromEuler(euler) {
                    const x = euler.x, y = euler.y, z = euler.z;
                    const c1 = Math.cos(x / 2);
                    const c2 = Math.cos(y / 2);
                    const c3 = Math.cos(z / 2);
                    const s1 = Math.sin(x / 2);
                    const s2 = Math.sin(y / 2);
                    const s3 = Math.sin(z / 2);
                    this.x = s1 * c2 * c3 + c1 * s2 * s3;
                    this.y = c1 * s2 * c3 - s1 * c2 * s3;
                    this.z = c1 * c2 * s3 + s1 * s2 * c3;
                    this.w = c1 * c2 * c3 - s1 * s2 * s3;
                    return this;
                }
            }

            class Euler {
                constructor(x = 0, y = 0, z = 0, order = 'XYZ') {
                    this.x = x;
                    this.y = y;
                    this.z = z;
                    this.order = order;
                }
                set(x, y, z, order) {
                    this.x = x;
                    this.y = y;
                    this.z = z;
                    this.order = order || this.order;
                    return this;
                }
            }

            class Matrix4 {
                constructor() {
                    this.elements = [
                        1, 0, 0, 0,
                        0, 1, 0, 0,
                        0, 0, 1, 0,
                        0, 0, 0, 1
                    ];
                }
                set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
                    const te = this.elements;
                    te[0] = n11; te[4] = n12; te[8] = n13; te[12] = n14;
                    te[1] = n21; te[5] = n22; te[9] = n23; te[13] = n24;
                    te[2] = n31; te[6] = n32; te[10] = n33; te[14] = n34;
                    te[3] = n41; te[7] = n42; te[11] = n43; te[15] = n44;
                    return this;
                }
                identity() {
                    this.set(
                        1, 0, 0, 0,
                        0, 1, 0, 0,
                        0, 0, 1, 0,
                        0, 0, 0, 1
                    );
                    return this;
                }
                copy(m) {
                    const te = this.elements;
                    const me = m.elements;
                    for (let i = 0; i < 16; i++) {
                        te[i] = me[i];
                    }
                    return this;
                }
                makeRotationFromQuaternion(q) {
                    return this.compose(new Vector3(0, 0, 0), q, new Vector3(1, 1, 1));
                }
                compose(position, quaternion, scale) {
                    const te = this.elements;
                    const x = quaternion.x, y = quaternion.y, z = quaternion.z, w = quaternion.w;
                    const x2 = x + x, y2 = y + y, z2 = z + z;
                    const xx = x * x2, xy = x * y2, xz = x * z2;
                    const yy = y * y2, yz = y * z2, zz = z * z2;
                    const wx = w * x2, wy = w * y2, wz = w * z2;
                    const sx = scale.x, sy = scale.y, sz = scale.z;
                    te[0] = (1 - (yy + zz)) * sx;
                    te[1] = (xy + wz) * sx;
                    te[2] = (xz - wy) * sx;
                    te[3] = 0;
                    te[4] = (xy - wz) * sy;
                    te[5] = (1 - (xx + zz)) * sy;
                    te[6] = (yz + wx) * sy;
                    te[7] = 0;
                    te[8] = (xz + wy) * sz;
                    te[9] = (yz - wx) * sz;
                    te[10] = (1 - (xx + yy)) * sz;
                    te[11] = 0;
                    te[12] = position.x;
                    te[13] = position.y;
                    te[14] = position.z;
                    te[15] = 1;
                    return this;
                }
                multiply(m) {
                    return this.multiplyMatrices(this, m);
                }
                multiplyMatrices(a, b) {
                    const ae = a.elements;
                    const be = b.elements;
                    const te = this.elements;
                    const a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
                    const a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
                    const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
                    const a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
                    const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
                    const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
                    const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
                    const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
                    te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
                    te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
                    te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
                    te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
                    te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
                    te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
                    te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
                    te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
                    te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
                    te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
                    te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
                    te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
                    te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
                    te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
                    te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
                    te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
                    return this;
                }
            }

            class Object3D extends EventDispatcher {
                constructor() {
                    super();
                    this.uuid = Math.random().toString(36).substr(2, 9);
                    this.name = '';
                    this.type = 'Object3D';
                    this.parent = null;
                    this.children = [];
                    this.position = new Vector3();
                    this.rotation = new Euler();
                    this.quaternion = new Quaternion();
                    this.scale = new Vector3(1, 1, 1);
                    this.matrix = new Matrix4();
                    this.matrixWorld = new Matrix4();
                    this.visible = true;
                    this.userData = {};
                }
                add(object) {
                    if (object === this) return this;
                    if (object.parent !== null) {
                        object.parent.remove(object);
                    }
                    object.parent = this;
                    this.children.push(object);
                    return this;
                }
                remove(object) {
                    const index = this.children.indexOf(object);
                    if (index !== -1) {
                        object.parent = null;
                        this.children.splice(index, 1);
                    }
                    return this;
                }
                updateMatrixWorld(force) {
                    this.matrix.compose(this.position, this.quaternion, this.scale);
                    if (this.parent === null) {
                        this.matrixWorld.copy(this.matrix);
                    } else {
                        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
                    }
                    const children = this.children;
                    for (let i = 0; i < children.length; i++) {
                        children[i].updateMatrixWorld(force);
                    }
                }
            }

            class Scene extends Object3D {
                constructor() {
                    super();
                    this.type = 'Scene';
                    this.background = null;
                    this.fog = null;
                }
            }

            class Camera extends Object3D {
                constructor() {
                    super();
                    this.type = 'Camera';
                    this.matrixWorldInverse = new Matrix4();
                    this.projectionMatrix = new Matrix4();
                }
            }

            class PerspectiveCamera extends Camera {
                constructor(fov = 50, aspect = 1, near = 0.1, far = 2000) {
                    super();
                    this.type = 'PerspectiveCamera';
                    this.fov = fov;
                    this.aspect = aspect;
                    this.near = near;
                    this.far = far;
                    this.updateProjectionMatrix();
                }
                updateProjectionMatrix() {
                    const near = this.near;
                    const top = near * Math.tan(0.5 * this.fov * Math.PI / 180);
                    const height = 2 * top;
                    const width = this.aspect * height;
                    const left = -0.5 * width;
                    const right = left + width;
                    const bottom = top - height;
                    const x = 2 * near / (right - left);
                    const y = 2 * near / (top - bottom);
                    const a = (right + left) / (right - left);
                    const b = (top + bottom) / (top - bottom);
                    const c = -(this.far + near) / (this.far - near);
                    const d = -2 * this.far * near / (this.far - near);
                    this.projectionMatrix.set(
                        x, 0, a, 0,
                        0, y, b, 0,
                        0, 0, c, d,
                        0, 0, -1, 0
                    );
                }
            }

            class WebGLRenderer {
                constructor(parameters = {}) {
                    const canvas = parameters.canvas || document.createElement('canvas');
                    const context = canvas.getContext('webgl2') || canvas.getContext('webgl');
                    this.domElement = canvas;
                    this.context = context;
                    const gl = context;
                    this.autoClear = true;
                    this.setClearColor(0x000000, 1);
                    gl.enable(gl.DEPTH_TEST);
                    gl.depthFunc(gl.LEQUAL);
                    gl.enable(gl.CULL_FACE);
                }
                setSize(width, height) {
                    this.domElement.width = width;
                    this.domElement.height = height;
                    this.domElement.style.width = width + 'px';
                    this.domElement.style.height = height + 'px';
                    this.context.viewport(0, 0, width, height);
                }
                setClearColor(color, alpha) {
                    const r = ((color >> 16) & 255) / 255;
                    const g = ((color >> 8) & 255) / 255;
                    const b = (color & 255) / 255;
                    this.context.clearColor(r, g, b, alpha);
                }
                clear() {
                    this.context.clear(this.context.COLOR_BUFFER_BIT | this.context.DEPTH_BUFFER_BIT);
                }
                render(scene, camera) {
                    if (this.autoClear) this.clear();
                    camera.updateMatrixWorld();
                    camera.matrixWorldInverse.copy(camera.matrixWorld);
                    scene.updateMatrixWorld();
                }
            }

            class BufferGeometry {
                constructor() {
                    this.attributes = {};
                    this.index = null;
                }
                setAttribute(name, attribute) {
                    this.attributes[name] = attribute;
                    return this;
                }
            }

            class BoxGeometry extends BufferGeometry {
                constructor(width = 1, height = 1, depth = 1) {
                    super();
                    this.type = 'BoxGeometry';
                    this.parameters = { width, height, depth };
                }
            }

            class SphereGeometry extends BufferGeometry {
                constructor(radius = 1, widthSegments = 32, heightSegments = 16) {
                    super();
                    this.type = 'SphereGeometry';
                    this.parameters = { radius, widthSegments, heightSegments };
                }
            }

            class CylinderGeometry extends BufferGeometry {
                constructor(radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 8) {
                    super();
                    this.type = 'CylinderGeometry';
                    this.parameters = { radiusTop, radiusBottom, height, radialSegments };
                }
            }

            class PlaneGeometry extends BufferGeometry {
                constructor(width = 1, height = 1) {
                    super();
                    this.type = 'PlaneGeometry';
                    this.parameters = { width, height };
                }
            }

            class Material {
                constructor() {
                    this.type = 'Material';
                    this.visible = true;
                }
            }

            class MeshBasicMaterial extends Material {
                constructor(parameters = {}) {
                    super();
                    this.type = 'MeshBasicMaterial';
                    this.color = parameters.color !== undefined ? parameters.color : 0xffffff;
                    this.wireframe = parameters.wireframe !== undefined ? parameters.wireframe : false;
                }
            }

            class MeshStandardMaterial extends Material {
                constructor(parameters = {}) {
                    super();
                    this.type = 'MeshStandardMaterial';
                    this.color = parameters.color !== undefined ? parameters.color : 0xffffff;
                    this.roughness = parameters.roughness !== undefined ? parameters.roughness : 0.5;
                    this.metalness = parameters.metalness !== undefined ? parameters.metalness : 0.5;
                }
            }

            class Mesh extends Object3D {
                constructor(geometry, material) {
                    super();
                    this.type = 'Mesh';
                    this.geometry = geometry;
                    this.material = material;
                }
            }

            class Light extends Object3D {
                constructor(color, intensity = 1) {
                    super();
                    this.type = 'Light';
                    this.color = color;
                    this.intensity = intensity;
                }
            }

            class AmbientLight extends Light {
                constructor(color, intensity) {
                    super(color, intensity);
                    this.type = 'AmbientLight';
                }
            }

            class DirectionalLight extends Light {
                constructor(color, intensity) {
                    super(color, intensity);
                    this.type = 'DirectionalLight';
                    this.target = new Object3D();
                }
            }

            class PointLight extends Light {
                constructor(color, intensity, distance = 0) {
                    super(color, intensity);
                    this.type = 'PointLight';
                    this.distance = distance;
                }
            }

            class Color {
                constructor(r, g, b) {
                    if (g === undefined && b === undefined) {
                        return this.set(r);
                    }
                    return this.setRGB(r, g, b);
                }
                set(value) {
                    if (typeof value === 'number') {
                        this.setHex(value);
                    }
                    return this;
                }
                setHex(hex) {
                    hex = Math.floor(hex);
                    this.r = (hex >> 16 & 255) / 255;
                    this.g = (hex >> 8 & 255) / 255;
                    this.b = (hex & 255) / 255;
                    return this;
                }
                setRGB(r, g, b) {
                    this.r = r;
                    this.g = g;
                    this.b = b;
                    return this;
                }
            }

            return {
                REVISION,
                MOUSE,
                TOUCH,
                CullFaceNone,
                CullFaceBack,
                CullFaceFront,
                PCFShadowMap,
                sRGBEncoding,
                Vector3,
                Quaternion,
                Euler,
                Matrix4,
                Scene,
                PerspectiveCamera,
                WebGLRenderer,
                BoxGeometry,
                SphereGeometry,
                CylinderGeometry,
                PlaneGeometry,
                MeshBasicMaterial,
                MeshStandardMaterial,
                Mesh,
                AmbientLight,
                DirectionalLight,
                PointLight,
                Color
            };
        })();

        // Cannon.js (Simplified Physics Engine) - Embedded
        const CANNON = (function() {
            'use strict';

            class Vec3 {
                constructor(x = 0, y = 0, z = 0) {
                    this.x = x;
                    this.y = y;
                    this.z = z;
                }
                set(x, y, z) {
                    this.x = x;
                    this.y = y;
                    this.z = z;
                    return this;
                }
                copy(v) {
                    this.x = v.x;
                    this.y = v.y;
                    this.z = v.z;
                    return this;
                }
                vadd(v, target = new Vec3()) {
                    target.x = this.x + v.x;
                    target.y = this.y + v.y;
                    target.z = this.z + v.z;
                    return target;
                }
                vsub(v, target = new Vec3()) {
                    target.x = this.x - v.x;
                    target.y = this.y - v.y;
                    target.z = this.z - v.z;
                    return target;
                }
                scale(scalar, target = new Vec3()) {
                    target.x = this.x * scalar;
                    target.y = this.y * scalar;
                    target.z = this.z * scalar;
                    return target;
                }
                length() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
                }
                normalize() {
                    const len = this.length();
                    if (len > 0) {
                        const invLen = 1.0 / len;
                        this.x *= invLen;
                        this.y *= invLen;
                        this.z *= invLen;
                    }
                    return this;
                }
            }

            class Quaternion {
                constructor(x = 0, y = 0, z = 0, w = 1) {
                    this.x = x;
                    this.y = y;
                    this.z = z;
                    this.w = w;
                }
                set(x, y, z, w) {
                    this.x = x;
                    this.y = y;
                    this.z = z;
                    this.w = w;
                    return this;
                }
                copy(q) {
                    this.x = q.x;
                    this.y = q.y;
                    this.z = q.z;
                    this.w = q.w;
                    return this;
                }
            }

            class Body {
                constructor(options = {}) {
                    this.position = options.position || new Vec3();
                    this.velocity = new Vec3();
                    this.quaternion = new Quaternion();
                    this.angularVelocity = new Vec3();
                    this.force = new Vec3();
                    this.mass = options.mass !== undefined ? options.mass : 0;
                    this.shape = options.shape || null;
                    this.type = this.mass === 0 ? Body.STATIC : Body.DYNAMIC;
                    this.material = options.material || null;
                    this.linearDamping = 0.01;
                    this.angularDamping = 0.01;
                    this.userData = {};
                }
                applyForce(force, relativePoint) {
                    this.force.x += force.x;
                    this.force.y += force.y;
                    this.force.z += force.z;
                }
                applyImpulse(impulse, relativePoint) {
                    if (this.type === Body.DYNAMIC) {
                        this.velocity.x += impulse.x / this.mass;
                        this.velocity.y += impulse.y / this.mass;
                        this.velocity.z += impulse.z / this.mass;
                    }
                }
            }

            Body.DYNAMIC = 1;
            Body.STATIC = 2;
            Body.KINEMATIC = 4;

            class Shape {
                constructor() {
                    this.type = 'Shape';
                }
            }

            class Box extends Shape {
                constructor(halfExtents) {
                    super();
                    this.type = 'Box';
                    this.halfExtents = halfExtents;
                }
            }

            class Sphere extends Shape {
                constructor(radius) {
                    super();
                    this.type = 'Sphere';
                    this.radius = radius;
                }
            }

            class Plane extends Shape {
                constructor() {
                    super();
                    this.type = 'Plane';
                }
            }

            class Cylinder extends Shape {
                constructor(radiusTop, radiusBottom, height, numSegments) {
                    super();
                    this.type = 'Cylinder';
                    this.radiusTop = radiusTop;
                    this.radiusBottom = radiusBottom;
                    this.height = height;
                    this.numSegments = numSegments;
                }
            }

            class World {
                constructor() {
                    this.gravity = new Vec3(0, -9.82, 0);
                    this.bodies = [];
                    this.defaultContactMaterial = null;
                }
                addBody(body) {
                    this.bodies.push(body);
                }
                removeBody(body) {
                    const index = this.bodies.indexOf(body);
                    if (index !== -1) {
                        this.bodies.splice(index, 1);
                    }
                }
                step(dt) {
                    for (let i = 0; i < this.bodies.length; i++) {
                        const body = this.bodies[i];
                        if (body.type === Body.DYNAMIC) {
                            // Apply gravity
                            body.force.x += this.gravity.x * body.mass;
                            body.force.y += this.gravity.y * body.mass;
                            body.force.z += this.gravity.z * body.mass;

                            // Update velocity
                            body.velocity.x += body.force.x / body.mass * dt;
                            body.velocity.y += body.force.y / body.mass * dt;
                            body.velocity.z += body.force.z / body.mass * dt;

                            // Apply damping
                            body.velocity.x *= (1 - body.linearDamping);
                            body.velocity.y *= (1 - body.linearDamping);
                            body.velocity.z *= (1 - body.linearDamping);

                            // Update position
                            body.position.x += body.velocity.x * dt;
                            body.position.y += body.velocity.y * dt;
                            body.position.z += body.velocity.z * dt;

                            // Reset force
                            body.force.set(0, 0, 0);
                        }
                    }

                    // Simple collision detection
                    this.detectCollisions();
                }
                detectCollisions() {
                    for (let i = 0; i < this.bodies.length; i++) {
                        const bodyA = this.bodies[i];

                        // Ground collision
                        if (bodyA.type === Body.DYNAMIC && bodyA.shape && bodyA.shape.type === 'Sphere') {
                            const radius = bodyA.shape.radius;
                            if (bodyA.position.y - radius < 0) {
                                bodyA.position.y = radius;
                                bodyA.velocity.y = Math.abs(bodyA.velocity.y) * 0.5;
                            }
                        }

                        if (bodyA.type === Body.DYNAMIC && bodyA.shape && bodyA.shape.type === 'Box') {
                            const halfY = bodyA.shape.halfExtents.y;
                            if (bodyA.position.y - halfY < 0) {
                                bodyA.position.y = halfY;
                                bodyA.velocity.y = 0;
                            }
                        }
                    }
                }
            }

            class Material {
                constructor(name) {
                    this.name = name || '';
                }
            }

            class ContactMaterial {
                constructor(materialA, materialB, options = {}) {
                    this.materialA = materialA;
                    this.materialB = materialB;
                    this.friction = options.friction !== undefined ? options.friction : 0.3;
                    this.restitution = options.restitution !== undefined ? options.restitution : 0.3;
                }
            }

            return {
                Vec3,
                Quaternion,
                Body,
                Box,
                Sphere,
                Plane,
                Cylinder,
                World,
                Material,
                ContactMaterial
            };
        })();

        // Game Engine
        class GameEngine {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.world = null;
                this.objects = [];
                this.players = new Map();
                this.localPlayer = null;
                this.keys = {};
                this.isPlaying = false;
                this.clock = { elapsedTime: 0, delta: 0 };
                this.lastTime = performance.now();
                this.fps = 0;
                this.frameCount = 0;
                this.fpsTime = 0;
                this.editorMode = false;
                this.recording = false;
                this.replayData = [];
                this.replayPlaying = false;
                this.selectedObject = null;

                // Network-related properties
                this.networkManager = null;
                this.clientPrediction = true;
                this.serverReconciliation = true;
                this.entityInterpolation = true;
                this.inputSequenceNumber = 0;
                this.pendingInputs = [];
            }

            init() {
                // Setup renderer
                this.renderer = new THREE.WebGLRenderer({
                    canvas: document.getElementById('gameCanvas'),
                    antialias: true
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(0x87CEEB, 1);

                // Setup scene
                this.scene = new THREE.Scene();

                // Setup camera
                this.camera = new THREE.PerspectiveCamera(
                    75,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                this.camera.position.set(0, 5, 10);
                this.camera.rotation.x = -0.4;

                // Setup physics
                this.world = new CANNON.World();
                this.world.gravity.set(0, -20, 0);

                // Create ground
                this.createGround();

                // Create default level
                this.createDefaultLevel();

                // Setup event listeners
                this.setupEventListeners();

                // Start game loop
                this.isPlaying = true;
                this.animate();
            }

            createGround() {
                // Visual ground
                const groundGeometry = new THREE.PlaneGeometry(100, 100);
                const groundMaterial = new THREE.MeshStandardMaterial({
                    color: 0x228B22,
                    roughness: 0.8
                });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.userData.isGround = true;
                this.scene.add(ground);

                // Lights
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
                directionalLight.position.set(10, 20, 10);
                this.scene.add(directionalLight);
            }

            createDefaultLevel() {
                // Create some platforms
                this.createPlatform(0, 2, -10, 8, 0.5, 8, 0xff6b6b);
                this.createPlatform(-8, 4, -5, 4, 0.5, 4, 0x4ecdc4);
                this.createPlatform(8, 4, -5, 4, 0.5, 4, 0x4ecdc4);
                this.createPlatform(0, 6, 0, 6, 0.5, 6, 0xffe66d);
            }

            createPlatform(x, y, z, width, height, depth, color) {
                // Visual
                const geometry = new THREE.BoxGeometry(width, height, depth);
                const material = new THREE.MeshStandardMaterial({
                    color: color,
                    roughness: 0.5,
                    metalness: 0.2
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(x, y, z);
                this.scene.add(mesh);

                // Physics
                const shape = new CANNON.Box(new CANNON.Vec3(width/2, height/2, depth/2));
                const body = new CANNON.Body({ mass: 0, shape: shape });
                body.position.set(x, y, z);
                this.world.addBody(body);

                this.objects.push({ mesh, body, type: 'platform' });
                return { mesh, body };
            }

            createPlayer(id, name, x, y, z, color) {
                // Visual
                const geometry = new THREE.SphereGeometry(0.5, 16, 16);
                const material = new THREE.MeshStandardMaterial({
                    color: color,
                    roughness: 0.3,
                    metalness: 0.7
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(x, y, z);
                this.scene.add(mesh);

                // Physics
                const shape = new CANNON.Sphere(0.5);
                const body = new CANNON.Body({
                    mass: 1,
                    shape: shape,
                    linearDamping: 0.9,
                    angularDamping: 0.9
                });
                body.position.set(x, y, z);
                this.world.addBody(body);

                const player = {
                    id,
                    name,
                    mesh,
                    body,
                    color,
                    canJump: true,
                    // Network interpolation
                    serverPosition: new THREE.Vector3(x, y, z),
                    serverVelocity: new THREE.Vector3(),
                    lastServerUpdate: Date.now(),
                    // Client prediction
                    predictedPosition: new THREE.Vector3(x, y, z),
                    predictedVelocity: new THREE.Vector3()
                };

                this.players.set(id, player);
                return player;
            }

            removePlayer(id) {
                const player = this.players.get(id);
                if (player) {
                    this.scene.remove(player.mesh);
                    this.world.removeBody(player.body);
                    this.players.delete(id);
                }
            }

            updatePlayer(player, dt) {
                if (!player || !player.body) return;

                const speed = 8;
                const jumpForce = 8;

                // Apply movement forces
                const force = new CANNON.Vec3();

                if (this.keys['w'] || this.keys['ArrowUp']) force.z -= speed;
                if (this.keys['s'] || this.keys['ArrowDown']) force.z += speed;
                if (this.keys['a'] || this.keys['ArrowLeft']) force.x -= speed;
                if (this.keys['d'] || this.keys['ArrowRight']) force.x += speed;

                player.body.applyForce(force, player.body.position);

                // Jumping
                if ((this.keys[' '] || this.keys['Space']) && player.canJump) {
                    player.body.velocity.y = jumpForce;
                    player.canJump = false;
                }

                // Check if on ground
                if (player.body.position.y <= 0.5) {
                    player.canJump = true;
                }

                // Sync mesh with physics
                player.mesh.position.copy(player.body.position);
                player.mesh.quaternion.copy(player.body.quaternion);

                // Update camera to follow player
                if (player === this.localPlayer) {
                    this.camera.position.x = player.mesh.position.x;
                    this.camera.position.y = player.mesh.position.y + 5;
                    this.camera.position.z = player.mesh.position.z + 10;
                }
            }

            // Client prediction for local player
            applyInput(player, input) {
                const speed = 8;
                const force = new CANNON.Vec3();

                if (input.keys['w']) force.z -= speed;
                if (input.keys['s']) force.z += speed;
                if (input.keys['a']) force.x -= speed;
                if (input.keys['d']) force.x += speed;

                player.body.applyForce(force, player.body.position);

                if (input.keys[' '] && player.canJump) {
                    player.body.velocity.y = 8;
                    player.canJump = false;
                }
            }

            // Interpolate remote players
            interpolatePlayer(player, dt) {
                if (!player.serverPosition) return;

                const alpha = 0.3; // Interpolation factor

                // Smooth interpolation
                player.mesh.position.x += (player.serverPosition.x - player.mesh.position.x) * alpha;
                player.mesh.position.y += (player.serverPosition.y - player.mesh.position.y) * alpha;
                player.mesh.position.z += (player.serverPosition.z - player.mesh.position.z) * alpha;
            }

            setupEventListeners() {
                window.addEventListener('keydown', (e) => {
                    this.keys[e.key] = true;

                    if (e.key === 'e' || e.key === 'E') {
                        this.toggleLevelEditor();
                    }
                    if (e.key === 'r' || e.key === 'R') {
                        this.toggleRecording();
                    }
                    if (e.key === 'p' || e.key === 'P') {
                        this.saveReplay();
                    }
                });

                window.addEventListener('keyup', (e) => {
                    this.keys[e.key] = false;
                });

                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });

                // Chat enter key
                document.getElementById('chatInput').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        sendChat();
                    }
                });
            }

            animate() {
                if (!this.isPlaying) return;

                requestAnimationFrame(() => this.animate());

                const currentTime = performance.now();
                const dt = Math.min((currentTime - this.lastTime) / 1000, 0.1);
                this.lastTime = currentTime;

                // Update FPS
                this.frameCount++;
                this.fpsTime += dt;
                if (this.fpsTime >= 1) {
                    this.fps = this.frameCount;
                    this.frameCount = 0;
                    this.fpsTime = 0;
                    document.getElementById('fps').textContent = this.fps;
                }

                // Update physics
                this.world.step(dt);

                // Update local player
                if (this.localPlayer && !this.replayPlaying) {
                    this.updatePlayer(this.localPlayer, dt);

                    // Send input to server if multiplayer
                    if (this.networkManager && this.networkManager.isConnected()) {
                        const input = {
                            keys: {...this.keys},
                            sequenceNumber: this.inputSequenceNumber++,
                            timestamp: Date.now()
                        };

                        // Store for reconciliation
                        this.pendingInputs.push(input);

                        // Send to server
                        this.networkManager.sendGameState({
                            type: 'input',
                            input: input,
                            position: {
                                x: this.localPlayer.body.position.x,
                                y: this.localPlayer.body.position.y,
                                z: this.localPlayer.body.position.z
                            },
                            velocity: {
                                x: this.localPlayer.body.velocity.x,
                                y: this.localPlayer.body.velocity.y,
                                z: this.localPlayer.body.velocity.z
                            }
                        });
                    }

                    // Update HUD
                    document.getElementById('position').textContent =
                        `${this.localPlayer.mesh.position.x.toFixed(1)}, ${this.localPlayer.mesh.position.y.toFixed(1)}, ${this.localPlayer.mesh.position.z.toFixed(1)}`;
                }

                // Update remote players with interpolation
                this.players.forEach((player, id) => {
                    if (player !== this.localPlayer) {
                        this.interpolatePlayer(player, dt);
                    }
                });

                // Recording
                if (this.recording && this.localPlayer) {
                    this.replayData.push({
                        time: this.clock.elapsedTime,
                        position: this.localPlayer.mesh.position.clone(),
                        rotation: this.localPlayer.mesh.rotation.clone()
                    });
                }

                this.clock.elapsedTime += dt;
                this.clock.delta = dt;

                // Render
                this.renderer.render(this.scene, this.camera);
            }

            toggleLevelEditor() {
                this.editorMode = !this.editorMode;
                document.getElementById('levelEditor').style.display =
                    this.editorMode ? 'block' : 'none';
            }

            toggleRecording() {
                this.recording = !this.recording;
                if (this.recording) {
                    this.replayData = [];
                    addChatMessage('System', 'Recording started');
                } else {
                    addChatMessage('System', 'Recording stopped');
                }
            }

            saveReplay() {
                if (this.replayData.length > 0) {
                    const data = JSON.stringify(this.replayData);
                    localStorage.setItem('gameReplay', data);
                    addChatMessage('System', 'Replay saved!');
                }
            }

            loadReplay() {
                const data = localStorage.getItem('gameReplay');
                if (data) {
                    this.replayData = JSON.parse(data);
                    this.replayPlaying = true;
                    // Implementation would play back the replay
                    addChatMessage('System', 'Replay loaded');
                }
            }

            exportLevel() {
                const levelData = {
                    objects: this.objects.map(obj => ({
                        type: obj.type,
                        position: {
                            x: obj.mesh.position.x,
                            y: obj.mesh.position.y,
                            z: obj.mesh.position.z
                        },
                        scale: {
                            x: obj.mesh.scale.x,
                            y: obj.mesh.scale.y,
                            z: obj.mesh.scale.z
                        },
                        color: obj.mesh.material.color
                    }))
                };
                return JSON.stringify(levelData, null, 2);
            }

            importLevel(jsonData) {
                try {
                    const levelData = JSON.parse(jsonData);
                    // Clear existing objects
                    this.objects.forEach(obj => {
                        this.scene.remove(obj.mesh);
                        this.world.removeBody(obj.body);
                    });
                    this.objects = [];

                    // Load new objects
                    levelData.objects.forEach(objData => {
                        // Implementation would recreate objects
                    });

                    addChatMessage('System', 'Level imported successfully');
                } catch (e) {
                    addChatMessage('System', 'Error importing level: ' + e.message);
                }
            }
        }

        // Network Manager with Reliability Features
        class NetworkManager {
            constructor(gameEngine) {
                this.gameEngine = gameEngine;
                this.peerId = null;
                this.roomCode = null;
                this.isHost = false;
                this.connections = new Map();
                this.dataChannels = new Map();
                this.pendingConnections = new Map();

                // Network statistics
                this.stats = {
                    bytesSent: 0,
                    bytesReceived: 0,
                    packetsSent: 0,
                    packetsReceived: 0,
                    packetsLost: 0,
                    lastPacketTime: 0,
                    ping: 0,
                    reconnectAttempts: 0
                };

                // Reliability features
                this.heartbeatInterval = null;
                this.reconnectTimeout = null;
                this.connectionQuality = 'excellent';
                this.bandwidthLimit = 512 * 1024; // 512 KB/s
                this.packetQueue = [];
                this.reliablePackets = new Map();
                this.packetSequence = 0;
                this.ackMap = new Map();

                // State synchronization
                this.stateBuffer = [];
                this.lastStateSync = 0;
                this.syncInterval = 50; // 20 updates per second

                // STUN/TURN servers for NAT traversal
                this.iceServers = [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' },
                    { urls: 'stun:stun2.l.google.com:19302' },
                    { urls: 'stun:stun3.l.google.com:19302' },
                    { urls: 'stun:stun4.l.google.com:19302' }
                ];

                this.setupNetworkMonitoring();
            }

            setupNetworkMonitoring() {
                // Monitor network statistics every second
                setInterval(() => {
                    this.updateNetworkStats();
                    this.assessConnectionQuality();
                    this.optimizeBandwidth();
                }, 1000);

                // Heartbeat to detect disconnections
                this.heartbeatInterval = setInterval(() => {
                    this.sendHeartbeat();
                }, 3000);
            }

            async createRoom(playerName) {
                this.isHost = true;
                this.peerId = this.generatePeerId();
                this.roomCode = this.generateRoomCode();

                // Create local player
                const color = this.getRandomColor();
                this.gameEngine.localPlayer = this.gameEngine.createPlayer(
                    this.peerId,
                    playerName,
                    0, 5, 5,
                    color
                );

                this.updateUI();
                addChatMessage('System', `Room created: ${this.roomCode}`);
                addChatMessage('System', 'Waiting for players to join...');

                return this.roomCode;
            }

            async joinRoom(roomCode, playerName) {
                this.roomCode = roomCode;
                this.peerId = this.generatePeerId();

                showLoading('Connecting to room...');

                try {
                    // Simulate WebRTC signaling
                    await this.simulateSignaling(roomCode);

                    // Create local player
                    const color = this.getRandomColor();
                    this.gameEngine.localPlayer = this.gameEngine.createPlayer(
                        this.peerId,
                        playerName,
                        0, 5, 5,
                        color
                    );

                    this.updateUI();
                    hideLoading();
                    addChatMessage('System', `Joined room: ${roomCode}`);

                    // Notify other players
                    this.broadcastPlayerJoin(playerName, color);

                } catch (error) {
                    hideLoading();
                    showError('Failed to join room: ' + error.message);
                    throw error;
                }
            }

            async simulateSignaling(roomCode) {
                // In a real implementation, this would connect to a signaling server
                // For this demo, we simulate the connection
                return new Promise((resolve, reject) => {
                    setTimeout(() => {
                        // Simulate successful connection
                        const mockHostId = 'host_' + roomCode;
                        this.createPeerConnection(mockHostId, false);
                        resolve();
                    }, 1000 + Math.random() * 2000);
                });
            }

            createPeerConnection(remotePeerId, initiator = false) {
                try {
                    const config = {
                        iceServers: this.iceServers,
                        iceCandidatePoolSize: 10
                    };

                    const pc = new RTCPeerConnection(config);

                    // Create reliable data channel
                    let dataChannel;
                    if (initiator) {
                        dataChannel = pc.createDataChannel('game', {
                            ordered: false, // Allow out-of-order delivery for speed
                            maxRetransmits: 3 // Retry 3 times before giving up
                        });
                        this.setupDataChannel(dataChannel, remotePeerId);
                    } else {
                        pc.addEventListener('datachannel', (event) => {
                            dataChannel = event.channel;
                            this.setupDataChannel(dataChannel, remotePeerId);
                        });
                    }

                    // ICE candidate handling
                    pc.addEventListener('icecandidate', (event) => {
                        if (event.candidate) {
                            this.sendSignalingMessage(remotePeerId, {
                                type: 'ice-candidate',
                                candidate: event.candidate
                            });
                        }
                    });

                    // Connection state monitoring
                    pc.addEventListener('connectionstatechange', () => {
                        console.log('Connection state:', pc.connectionState);

                        if (pc.connectionState === 'disconnected' ||
                            pc.connectionState === 'failed') {
                            this.handleDisconnection(remotePeerId);
                        } else if (pc.connectionState === 'connected') {
                            this.handleReconnection(remotePeerId);
                        }
                    });

                    // ICE connection state
                    pc.addEventListener('iceconnectionstatechange', () => {
                        console.log('ICE connection state:', pc.iceConnectionState);

                        if (pc.iceConnectionState === 'failed') {
                            // Try to restart ICE
                            this.restartIce(pc, remotePeerId);
                        }
                    });

                    this.connections.set(remotePeerId, pc);

                    return pc;

                } catch (error) {
                    console.error('Error creating peer connection:', error);
                    showError('Connection error: ' + error.message);
                }
            }

            setupDataChannel(channel, peerId) {
                channel.binaryType = 'arraybuffer';

                channel.addEventListener('open', () => {
                    console.log('Data channel open with', peerId);
                    this.dataChannels.set(peerId, channel);
                    addChatMessage('System', 'Connected to peer: ' + peerId.substring(0, 8));
                    this.updateConnectionStatus('connected');
                });

                channel.addEventListener('close', () => {
                    console.log('Data channel closed with', peerId);
                    this.dataChannels.delete(peerId);
                    this.handleDisconnection(peerId);
                });

                channel.addEventListener('error', (error) => {
                    console.error('Data channel error:', error);
                    this.handleChannelError(peerId, error);
                });

                channel.addEventListener('message', (event) => {
                    this.handleMessage(event.data, peerId);
                });
            }

            handleMessage(data, peerId) {
                try {
                    this.stats.bytesReceived += data.length || data.byteLength || 0;
                    this.stats.packetsReceived++;

                    let message;
                    if (typeof data === 'string') {
                        message = JSON.parse(data);
                    } else {
                        // Handle binary data
                        const decoder = new TextDecoder();
                        message = JSON.parse(decoder.decode(data));
                    }

                    // Update last packet time for ping calculation
                    this.stats.lastPacketTime = Date.now();

                    // Handle acknowledgments
                    if (message.ack !== undefined) {
                        this.handleAck(message.ack);
                    }

                    // Send ACK for reliable packets
                    if (message.reliable && message.seq !== undefined) {
                        this.sendAck(peerId, message.seq);
                    }

                    // Process message based on type
                    switch (message.type) {
                        case 'heartbeat':
                            this.handleHeartbeat(peerId, message);
                            break;
                        case 'state-sync':
                            this.handleStateSync(message);
                            break;
                        case 'input':
                            this.handlePlayerInput(peerId, message);
                            break;
                        case 'player-join':
                            this.handlePlayerJoin(message);
                            break;
                        case 'player-leave':
                            this.handlePlayerLeave(message);
                            break;
                        case 'chat':
                            this.handleChatMessage(message);
                            break;
                        default:
                            console.warn('Unknown message type:', message.type);
                    }

                } catch (error) {
                    console.error('Error handling message:', error);
                }
            }

            sendMessage(peerId, message, reliable = false) {
                const channel = this.dataChannels.get(peerId);
                if (!channel || channel.readyState !== 'open') {
                    // Queue message for later
                    this.packetQueue.push({ peerId, message, reliable });
                    return false;
                }

                try {
                    // Add sequence number for reliable packets
                    if (reliable) {
                        message.reliable = true;
                        message.seq = this.packetSequence++;
                        message.timestamp = Date.now();

                        // Store for potential retransmission
                        this.reliablePackets.set(message.seq, {
                            message,
                            peerId,
                            attempts: 0,
                            lastSent: Date.now()
                        });
                    }

                    const data = JSON.stringify(message);

                    // Check bandwidth limit
                    if (this.stats.bytesSent + data.length > this.bandwidthLimit) {
                        // Throttle: queue for later
                        this.packetQueue.push({ peerId, message, reliable });
                        return false;
                    }

                    channel.send(data);
                    this.stats.bytesSent += data.length;
                    this.stats.packetsSent++;

                    return true;

                } catch (error) {
                    console.error('Error sending message:', error);
                    this.stats.packetsLost++;

                    if (reliable) {
                        // Will retry later
                        return false;
                    }

                    return false;
                }
            }

            broadcast(message, reliable = false) {
                this.dataChannels.forEach((channel, peerId) => {
                    this.sendMessage(peerId, message, reliable);
                });
            }

            sendHeartbeat() {
                const heartbeat = {
                    type: 'heartbeat',
                    timestamp: Date.now(),
                    stats: {
                        fps: this.gameEngine.fps,
                        ping: this.stats.ping
                    }
                };

                this.broadcast(heartbeat, false);
            }

            handleHeartbeat(peerId, message) {
                // Calculate ping
                const now = Date.now();
                const rtt = now - message.timestamp;
                this.stats.ping = Math.round(rtt / 2);

                // Update UI
                document.getElementById('ping').textContent = this.stats.ping;
            }

            sendAck(peerId, seq) {
                const ack = {
                    type: 'ack',
                    ack: seq,
                    timestamp: Date.now()
                };

                this.sendMessage(peerId, ack, false);
            }

            handleAck(seq) {
                // Remove acknowledged packet from reliable queue
                if (this.reliablePackets.has(seq)) {
                    this.reliablePackets.delete(seq);
                }
            }

            // Retransmit unacknowledged packets
            retransmitReliablePackets() {
                const now = Date.now();
                const timeout = 1000; // 1 second timeout
                const maxAttempts = 5;

                this.reliablePackets.forEach((packet, seq) => {
                    if (now - packet.lastSent > timeout) {
                        if (packet.attempts < maxAttempts) {
                            // Retransmit
                            packet.attempts++;
                            packet.lastSent = now;
                            this.sendMessage(packet.peerId, packet.message, false);
                        } else {
                            // Give up
                            this.reliablePackets.delete(seq);
                            this.stats.packetsLost++;
                        }
                    }
                });
            }

            handleDisconnection(peerId) {
                console.log('Peer disconnected:', peerId);
                addChatMessage('System', 'Player disconnected: ' + peerId.substring(0, 8));

                this.updateConnectionStatus('disconnected');

                // Attempt reconnection
                this.attemptReconnection(peerId);

                // Remove player
                this.gameEngine.removePlayer(peerId);
                this.updatePlayerList();
            }

            attemptReconnection(peerId) {
                if (this.reconnectTimeout) {
                    clearTimeout(this.reconnectTimeout);
                }

                let attempts = 0;
                const maxAttempts = 5;
                const baseDelay = 2000;

                const reconnect = () => {
                    if (attempts >= maxAttempts) {
                        showError('Failed to reconnect after ' + maxAttempts + ' attempts');
                        return;
                    }

                    attempts++;
                    this.stats.reconnectAttempts++;

                    console.log(`Reconnection attempt ${attempts}/${maxAttempts}`);
                    addChatMessage('System', `Reconnecting... (${attempts}/${maxAttempts})`);

                    this.updateConnectionStatus('connecting');

                    // Try to recreate connection
                    const pc = this.connections.get(peerId);
                    if (pc) {
                        this.restartIce(pc, peerId);
                    } else {
                        this.createPeerConnection(peerId, true);
                    }

                    // Exponential backoff
                    const delay = baseDelay * Math.pow(2, attempts - 1);
                    this.reconnectTimeout = setTimeout(reconnect, delay);
                };

                reconnect();
            }

            handleReconnection(peerId) {
                console.log('Peer reconnected:', peerId);
                addChatMessage('System', 'Reconnected to peer: ' + peerId.substring(0, 8));

                if (this.reconnectTimeout) {
                    clearTimeout(this.reconnectTimeout);
                    this.reconnectTimeout = null;
                }

                this.updateConnectionStatus('connected');

                // Re-sync state
                this.sendFullStateSync();
            }

            async restartIce(pc, peerId) {
                try {
                    console.log('Restarting ICE for peer:', peerId);

                    // Create new offer with ICE restart
                    const offer = await pc.createOffer({ iceRestart: true });
                    await pc.setLocalDescription(offer);

                    // Send offer to peer (via signaling)
                    this.sendSignalingMessage(peerId, {
                        type: 'offer',
                        offer: offer
                    });

                } catch (error) {
                    console.error('Error restarting ICE:', error);
                }
            }

            handleChannelError(peerId, error) {
                console.error('Channel error with peer', peerId, ':', error);

                // Try to recover
                setTimeout(() => {
                    const channel = this.dataChannels.get(peerId);
                    if (!channel || channel.readyState !== 'open') {
                        this.attemptReconnection(peerId);
                    }
                }, 1000);
            }

            sendGameState(state) {
                const message = {
                    type: 'state-sync',
                    playerId: this.peerId,
                    state: state,
                    timestamp: Date.now()
                };

                // Only send if enough time has passed (rate limiting)
                const now = Date.now();
                if (now - this.lastStateSync >= this.syncInterval) {
                    this.broadcast(message, false);
                    this.lastStateSync = now;
                }
            }

            handleStateSync(message) {
                const player = this.gameEngine.players.get(message.playerId);
                if (player && player !== this.gameEngine.localPlayer) {
                    // Update server position for interpolation
                    if (message.state.position) {
                        player.serverPosition.set(
                            message.state.position.x,
                            message.state.position.y,
                            message.state.position.z
                        );
                    }

                    if (message.state.velocity) {
                        player.serverVelocity.set(
                            message.state.velocity.x,
                            message.state.velocity.y,
                            message.state.velocity.z
                        );
                    }

                    player.lastServerUpdate = Date.now();
                }
            }

            handlePlayerInput(peerId, message) {
                // Server reconciliation would happen here
                // For P2P, we just update the player
                const player = this.gameEngine.players.get(peerId);
                if (player && message.input) {
                    // Apply input to player
                    // This would be more sophisticated in a real implementation
                }
            }

            broadcastPlayerJoin(playerName, color) {
                const message = {
                    type: 'player-join',
                    playerId: this.peerId,
                    playerName: playerName,
                    color: color,
                    position: {
                        x: this.gameEngine.localPlayer.body.position.x,
                        y: this.gameEngine.localPlayer.body.position.y,
                        z: this.gameEngine.localPlayer.body.position.z
                    }
                };

                this.broadcast(message, true);
            }

            handlePlayerJoin(message) {
                if (message.playerId !== this.peerId) {
                    // Create remote player
                    const player = this.gameEngine.createPlayer(
                        message.playerId,
                        message.playerName,
                        message.position.x,
                        message.position.y,
                        message.position.z,
                        message.color
                    );

                    addChatMessage('System', message.playerName + ' joined the game');
                    this.updatePlayerList();

                    // Send our info back
                    if (this.gameEngine.localPlayer) {
                        this.broadcastPlayerJoin(
                            this.gameEngine.localPlayer.name,
                            this.gameEngine.localPlayer.color
                        );
                    }
                }
            }

            handlePlayerLeave(message) {
                if (message.playerId !== this.peerId) {
                    const player = this.gameEngine.players.get(message.playerId);
                    if (player) {
                        addChatMessage('System', player.name + ' left the game');
                        this.gameEngine.removePlayer(message.playerId);
                        this.updatePlayerList();
                    }
                }
            }

            handleChatMessage(message) {
                if (message.playerId !== this.peerId) {
                    addChatMessage(message.playerName, message.text);
                }
            }

            sendChatMessage(text) {
                const message = {
                    type: 'chat',
                    playerId: this.peerId,
                    playerName: this.gameEngine.localPlayer.name,
                    text: text,
                    timestamp: Date.now()
                };

                this.broadcast(message, true);
                addChatMessage(this.gameEngine.localPlayer.name, text);
            }

            sendFullStateSync() {
                // Send complete game state to newly connected peers
                const state = {
                    type: 'full-sync',
                    players: Array.from(this.gameEngine.players.values()).map(p => ({
                        id: p.id,
                        name: p.name,
                        color: p.color,
                        position: {
                            x: p.body.position.x,
                            y: p.body.position.y,
                            z: p.body.position.z
                        }
                    })),
                    timestamp: Date.now()
                };

                this.broadcast(state, true);
            }

            updateNetworkStats() {
                // Update UI with network statistics
                document.getElementById('bytesSent').textContent =
                    (this.stats.bytesSent / 1024).toFixed(1);
                document.getElementById('bytesReceived').textContent =
                    (this.stats.bytesReceived / 1024).toFixed(1);
                document.getElementById('reconnectCount').textContent =
                    this.stats.reconnectAttempts;

                // Calculate packet loss
                const totalPackets = this.stats.packetsSent + this.stats.packetsReceived;
                const lossRate = totalPackets > 0 ?
                    (this.stats.packetsLost / totalPackets * 100) : 0;
                document.getElementById('packetLoss').textContent = lossRate.toFixed(1);

                // Calculate bandwidth
                const bandwidth = (this.stats.bytesSent + this.stats.bytesReceived) / 1024;
                document.getElementById('bandwidth').textContent = bandwidth.toFixed(1);

                // Reset counters
                this.stats.bytesSent = 0;
                this.stats.bytesReceived = 0;
            }

            assessConnectionQuality() {
                const ping = this.stats.ping;
                const lossRate = parseFloat(document.getElementById('packetLoss').textContent);

                let quality = 'excellent';
                let className = 'quality-excellent';

                if (ping > 200 || lossRate > 5) {
                    quality = 'bad';
                    className = 'quality-bad';
                } else if (ping > 150 || lossRate > 3) {
                    quality = 'poor';
                    className = 'quality-poor';
                } else if (ping > 100 || lossRate > 2) {
                    quality = 'fair';
                    className = 'quality-fair';
                } else if (ping > 50 || lossRate > 1) {
                    quality = 'good';
                    className = 'quality-good';
                }

                this.connectionQuality = quality;

                const qualityEl = document.getElementById('quality');
                qualityEl.textContent = quality.charAt(0).toUpperCase() + quality.slice(1);
                qualityEl.className = className;

                // Adjust sync rate based on quality
                if (quality === 'bad') {
                    this.syncInterval = 200; // 5 updates per second
                } else if (quality === 'poor') {
                    this.syncInterval = 100; // 10 updates per second
                } else {
                    this.syncInterval = 50; // 20 updates per second
                }
            }

            optimizeBandwidth() {
                // Process queued packets within bandwidth limit
                while (this.packetQueue.length > 0 &&
                       this.stats.bytesSent < this.bandwidthLimit) {
                    const packet = this.packetQueue.shift();
                    this.sendMessage(packet.peerId, packet.message, packet.reliable);
                }

                // Retransmit reliable packets
                this.retransmitReliablePackets();
            }

            updateConnectionStatus(status) {
                const statusEl = document.getElementById('connectionStatus');
                const dotEl = document.getElementById('statusDot');

                switch (status) {
                    case 'connected':
                        statusEl.textContent = 'Connected';
                        dotEl.className = 'status-indicator status-connected';
                        break;
                    case 'connecting':
                        statusEl.textContent = 'Connecting...';
                        dotEl.className = 'status-indicator status-connecting';
                        break;
                    case 'disconnected':
                        statusEl.textContent = 'Disconnected';
                        dotEl.className = 'status-indicator status-disconnected';
                        break;
                }
            }

            updatePlayerList() {
                const listEl = document.getElementById('playerListContent');
                listEl.innerHTML = '';

                this.gameEngine.players.forEach((player) => {
                    const item = document.createElement('div');
                    item.className = 'player-item';
                    item.textContent = player.name;
                    if (player === this.gameEngine.localPlayer) {
                        item.textContent += ' (You)';
                    }
                    listEl.appendChild(item);
                });

                document.getElementById('playerCount').textContent =
                    this.gameEngine.players.size;
            }

            updateUI() {
                document.getElementById('roomDisplay').textContent = this.roomCode || 'Solo';
                this.updatePlayerList();
            }

            isConnected() {
                return this.dataChannels.size > 0;
            }

            generatePeerId() {
                return 'peer_' + Math.random().toString(36).substr(2, 9);
            }

            generateRoomCode() {
                const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
                let code = '';
                for (let i = 0; i < 6; i++) {
                    code += chars.charAt(Math.floor(Math.random() * chars.length));
                }
                return code;
            }

            getRandomColor() {
                const colors = [0xff6b6b, 0x4ecdc4, 0x45b7d1, 0xf9ca24,
                               0x6c5ce7, 0xa29bfe, 0xfd79a8, 0xfdcb6e];
                return colors[Math.floor(Math.random() * colors.length)];
            }

            sendSignalingMessage(peerId, message) {
                // In a real implementation, this would send to a signaling server
                // For this demo, we log it
                console.log('Signaling message to', peerId, ':', message);
            }

            disconnect() {
                // Clean up all connections
                this.dataChannels.forEach(channel => channel.close());
                this.connections.forEach(pc => pc.close());
                this.dataChannels.clear();
                this.connections.clear();

                if (this.heartbeatInterval) {
                    clearInterval(this.heartbeatInterval);
                }

                if (this.reconnectTimeout) {
                    clearTimeout(this.reconnectTimeout);
                }

                this.updateConnectionStatus('disconnected');
            }
        }

        // Global instances
        let gameEngine;
        let networkManager;

        // UI Functions
        function createRoom() {
            const playerName = document.getElementById('playerName').value.trim() || 'Player';

            gameEngine = new GameEngine();
            gameEngine.init();

            networkManager = new NetworkManager(gameEngine);
            gameEngine.networkManager = networkManager;

            const roomCode = networkManager.createRoom(playerName);

            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('hud').style.display = 'block';
            document.getElementById('networkStatus').style.display = 'block';
            document.getElementById('playerList').style.display = 'block';
            document.getElementById('chat').style.display = 'block';
        }

        async function joinRoom() {
            const roomCode = document.getElementById('roomCode').value.trim();
            const playerName = document.getElementById('playerName').value.trim() || 'Player';

            if (!roomCode) {
                alert('Please enter a room code');
                return;
            }

            gameEngine = new GameEngine();
            gameEngine.init();

            networkManager = new NetworkManager(gameEngine);
            gameEngine.networkManager = networkManager;

            try {
                await networkManager.joinRoom(roomCode, playerName);

                document.getElementById('mainMenu').style.display = 'none';
                document.getElementById('hud').style.display = 'block';
                document.getElementById('networkStatus').style.display = 'block';
                document.getElementById('playerList').style.display = 'block';
                document.getElementById('chat').style.display = 'block';

            } catch (error) {
                console.error('Failed to join room:', error);
            }
        }

        function startSinglePlayer() {
            gameEngine = new GameEngine();
            gameEngine.init();

            const playerName = document.getElementById('playerName').value.trim() || 'Player';
            const color = 0x4ecdc4;
            gameEngine.localPlayer = gameEngine.createPlayer('local', playerName, 0, 5, 5, color);

            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('hud').style.display = 'block';
        }

        function openLevelEditor() {
            startSinglePlayer();
            gameEngine.toggleLevelEditor();
        }

        function placeObject() {
            const type = document.getElementById('objectType').value;
            const size = parseFloat(document.getElementById('objectSize').value);
            const color = parseInt(document.getElementById('objectColor').value.replace('#', '0x'));

            if (gameEngine.localPlayer) {
                const x = gameEngine.localPlayer.mesh.position.x;
                const y = gameEngine.localPlayer.mesh.position.y + 2;
                const z = gameEngine.localPlayer.mesh.position.z - 3;

                gameEngine.createPlatform(x, y, z, size * 2, 0.5, size * 2, color);
            }
        }

        function deleteObject() {
            // Implementation for object deletion
            addChatMessage('System', 'Select an object by clicking on it first');
        }

        function saveLevel() {
            const levelData = gameEngine.exportLevel();
            localStorage.setItem('customLevel', levelData);
            addChatMessage('System', 'Level saved!');
        }

        function loadLevel() {
            const levelData = localStorage.getItem('customLevel');
            if (levelData) {
                gameEngine.importLevel(levelData);
            } else {
                addChatMessage('System', 'No saved level found');
            }
        }

        function exportLevel() {
            const levelData = gameEngine.exportLevel();
            const blob = new Blob([levelData], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'level.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        function closeLevelEditor() {
            gameEngine.toggleLevelEditor();
        }

        function loadReplay() {
            if (!gameEngine) {
                startSinglePlayer();
            }
            gameEngine.loadReplay();
        }

        function sendChat() {
            const input = document.getElementById('chatInput');
            const text = input.value.trim();

            if (text && networkManager) {
                networkManager.sendChatMessage(text);
                input.value = '';
            } else if (text) {
                addChatMessage(gameEngine.localPlayer.name, text);
                input.value = '';
            }
        }

        function addChatMessage(sender, message) {
            const chatMessages = document.getElementById('chatMessages');
            const msgEl = document.createElement('div');
            msgEl.innerHTML = `<strong>${sender}:</strong> ${message}`;
            chatMessages.appendChild(msgEl);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function showHelp() {
            const helpText = `
3D Multiplayer Game Engine - Network Reliability Edition

CONTROLS:
- WASD / Arrow Keys: Move
- Space: Jump
- E: Toggle Level Editor
- R: Start/Stop Recording
- P: Save Replay

MULTIPLAYER:
- Create Room: Start a new multiplayer session
- Join Room: Join an existing room with a code
- Room codes are 6 characters long

LEVEL EDITOR:
- Place objects in the world
- Save and load custom levels
- Export levels as JSON

NETWORK FEATURES:
- Automatic reconnection on disconnect
- NAT traversal with STUN servers
- Lag compensation and prediction
- Bandwidth optimization
- Connection quality monitoring
- Packet loss handling

This version prioritizes network reliability for smooth multiplayer experiences even on poor connections.
            `;
            alert(helpText);
        }

        function showLoading(message) {
            const loading = document.getElementById('loading');
            const status = document.getElementById('loadingStatus');
            status.textContent = message;
            loading.style.display = 'block';
        }

        function hideLoading() {
            document.getElementById('loading').style.display = 'none';
        }

        function showError(message) {
            const errorDisplay = document.getElementById('errorDisplay');
            const errorMessage = document.getElementById('errorMessage');
            errorMessage.textContent = message;
            errorDisplay.style.display = 'block';
        }

        function closeError() {
            document.getElementById('errorDisplay').style.display = 'none';
        }

        function retryConnection() {
            closeError();
            if (networkManager) {
                networkManager.attemptReconnection('retry');
            }
        }

        // Replay controls
        function pauseReplay() {
            if (gameEngine) {
                gameEngine.replayPlaying = false;
            }
        }

        function resumeReplay() {
            if (gameEngine) {
                gameEngine.replayPlaying = true;
            }
        }

        function stopReplay() {
            if (gameEngine) {
                gameEngine.replayPlaying = false;
                gameEngine.replayData = [];
            }
        }

        // Initialize
        window.addEventListener('load', () => {
            console.log('3D Multiplayer Game Engine - Network Reliability Edition loaded');
        });

        // Clean up on page unload
        window.addEventListener('beforeunload', () => {
            if (networkManager) {
                networkManager.disconnect();
            }
        });
    </script>
</body>
</html>