<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Garden of Floating Islands</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1f3a 100%);
            color: #e0e6ff;
            overflow: hidden;
            position: relative;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        .ui-panel {
            pointer-events: all;
            background: rgba(10, 14, 39, 0.85);
            border: 2px solid rgba(99, 227, 208, 0.3);
            border-radius: 12px;
            padding: 15px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        #top-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 15px;
            flex-wrap: wrap;
        }

        #info-section {
            flex: 1;
            min-width: 200px;
        }

        #info-section h1 {
            font-size: 1.5rem;
            color: #63e3d0;
            margin-bottom: 8px;
            text-shadow: 0 0 20px rgba(99, 227, 208, 0.6);
        }

        #stats {
            font-size: 0.9rem;
            line-height: 1.6;
            color: #b8c5ff;
        }

        #controls-section {
            min-width: 250px;
        }

        #controls-section h3 {
            color: #9f7aea;
            margin-bottom: 10px;
            font-size: 1rem;
        }

        .control-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.85rem;
        }

        .control-key {
            color: #fbbf24;
            font-weight: bold;
        }

        #bottom-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        .action-button {
            background: linear-gradient(135deg, #9f7aea 0%, #6366f1 100%);
            border: 2px solid rgba(159, 122, 234, 0.5);
            border-radius: 8px;
            padding: 12px 20px;
            color: white;
            font-size: 0.95rem;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(159, 122, 234, 0.3);
            font-weight: 600;
        }

        .action-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(159, 122, 234, 0.5);
            border-color: rgba(159, 122, 234, 0.8);
        }

        .action-button:active {
            transform: translateY(0);
        }

        .action-button.secondary {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            border-color: rgba(16, 185, 129, 0.5);
            box-shadow: 0 4px 15px rgba(16, 185, 129, 0.3);
        }

        .action-button.secondary:hover {
            box-shadow: 0 6px 25px rgba(16, 185, 129, 0.5);
        }

        #seed-inventory {
            background: linear-gradient(135deg, rgba(251, 191, 36, 0.15) 0%, rgba(245, 158, 11, 0.15) 100%);
            border: 2px solid rgba(251, 191, 36, 0.4);
            padding: 10px 18px;
            border-radius: 8px;
            font-size: 1.1rem;
            color: #fbbf24;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(251, 191, 36, 0.5);
        }

        #connection-status {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            border: 2px solid;
        }

        #connection-status.connected {
            background: rgba(16, 185, 129, 0.2);
            border-color: #10b981;
            color: #10b981;
        }

        #connection-status.disconnected {
            background: rgba(239, 68, 68, 0.2);
            border-color: #ef4444;
            color: #ef4444;
        }

        #peer-list {
            margin-top: 10px;
            padding: 10px;
            background: rgba(99, 227, 208, 0.1);
            border-radius: 8px;
            font-size: 0.85rem;
            max-height: 150px;
            overflow-y: auto;
        }

        .peer-item {
            padding: 5px;
            margin: 3px 0;
            background: rgba(99, 227, 208, 0.2);
            border-radius: 4px;
        }

        #mobile-controls {
            position: absolute;
            bottom: 20px;
            display: none;
            gap: 10px;
        }

        #mobile-controls.visible {
            display: flex;
        }

        #joystick {
            left: 20px;
            width: 120px;
            height: 120px;
            background: rgba(10, 14, 39, 0.7);
            border: 3px solid rgba(99, 227, 208, 0.4);
            border-radius: 50%;
            position: relative;
        }

        #joystick-knob {
            width: 50px;
            height: 50px;
            background: radial-gradient(circle, #63e3d0 0%, #3b82f6 100%);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 20px rgba(99, 227, 208, 0.6);
        }

        #mobile-actions {
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .mobile-button {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(135deg, #9f7aea 0%, #6366f1 100%);
            border: 3px solid rgba(159, 122, 234, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(159, 122, 234, 0.4);
        }

        #modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        #modal-overlay.visible {
            display: flex;
        }

        .modal-content {
            background: linear-gradient(135deg, #1a1f3a 0%, #2d3250 100%);
            border: 3px solid rgba(99, 227, 208, 0.5);
            border-radius: 15px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-content h2 {
            color: #63e3d0;
            margin-bottom: 20px;
            text-shadow: 0 0 15px rgba(99, 227, 208, 0.5);
        }

        .modal-content textarea {
            width: 100%;
            min-height: 200px;
            background: rgba(10, 14, 39, 0.8);
            border: 2px solid rgba(99, 227, 208, 0.3);
            border-radius: 8px;
            color: #e0e6ff;
            padding: 12px;
            font-family: monospace;
            font-size: 0.9rem;
            resize: vertical;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .modal-buttons button {
            flex: 1;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.5rem;
            color: #63e3d0;
            text-shadow: 0 0 20px rgba(99, 227, 208, 0.8);
        }

        @media (max-width: 768px) {
            #top-panel {
                flex-direction: column;
            }

            #controls-section {
                display: none;
            }

            #bottom-panel {
                display: none;
            }

            #mobile-controls {
                display: flex;
            }
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(10, 14, 39, 0.5);
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(99, 227, 208, 0.5);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(99, 227, 208, 0.7);
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <div id="ui-overlay">
        <div id="top-panel">
            <div id="info-section" class="ui-panel">
                <h1>üèùÔ∏è Quantum Garden</h1>
                <div id="stats">
                    <div>Position: <span id="player-pos">0, 0, 0</span></div>
                    <div>Islands Discovered: <span id="islands-count">0</span></div>
                    <div>Plants Growing: <span id="plants-count">0</span></div>
                    <div>Online Players: <span id="online-count">0</span></div>
                </div>
            </div>

            <div id="controls-section" class="ui-panel">
                <h3>Controls</h3>
                <div class="control-row">
                    <span class="control-key">WASD</span>
                    <span>Move</span>
                </div>
                <div class="control-row">
                    <span class="control-key">SPACE</span>
                    <span>Jump</span>
                </div>
                <div class="control-row">
                    <span class="control-key">CLICK</span>
                    <span>Plant Seed</span>
                </div>
                <div class="control-row">
                    <span class="control-key">MOUSE</span>
                    <span>Look Around</span>
                </div>
            </div>
        </div>

        <div id="bottom-panel">
            <div id="seed-inventory">üå± Seeds: <span id="seed-count">10</span></div>
            <button class="action-button secondary" id="collect-btn">Collect Seed</button>
            <button class="action-button" id="export-btn">Export World</button>
            <button class="action-button" id="import-btn">Import World</button>
        </div>

        <div id="mobile-controls">
            <div id="joystick">
                <div id="joystick-knob"></div>
            </div>
            <div id="mobile-actions">
                <div class="mobile-button" id="mobile-jump">‚¨ÜÔ∏è</div>
                <div class="mobile-button" id="mobile-plant">üå±</div>
            </div>
        </div>
    </div>

    <div id="modal-overlay">
        <div class="modal-content">
            <h2 id="modal-title">Modal</h2>
            <div id="modal-body"></div>
            <div class="modal-buttons">
                <button class="action-button" id="modal-close">Close</button>
                <button class="action-button secondary" id="modal-action" style="display: none;">Action</button>
            </div>
        </div>
    </div>

    <script>
        // ===== THREE.JS R150 MINIMAL BUILD =====
        // Inline Three.js core (minimal version for performance)
        'use strict';const THREE={REVISION:"150"};THREE.MOUSE={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2};THREE.TOUCH={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3};THREE.CullFaceNone=0;THREE.CullFaceBack=1;THREE.CullFaceFront=2;THREE.PCFShadowMap=1;THREE.PCFSoftShadowMap=2;THREE.VSMShadowMap=3;THREE.FrontSide=0;THREE.BackSide=1;THREE.DoubleSide=2;THREE.NoBlending=0;THREE.NormalBlending=1;THREE.AdditiveBlending=2;THREE.SubtractiveBlending=3;THREE.MultiplyBlending=4;THREE.CustomBlending=5;THREE.AddEquation=100;THREE.SubtractEquation=101;THREE.ReverseSubtractEquation=102;THREE.MinEquation=103;THREE.MaxEquation=104;THREE.ZeroFactor=200;THREE.OneFactor=201;THREE.SrcColorFactor=202;THREE.OneMinusSrcColorFactor=203;THREE.SrcAlphaFactor=204;THREE.OneMinusSrcAlphaFactor=205;THREE.DstAlphaFactor=206;THREE.OneMinusDstAlphaFactor=207;THREE.DstColorFactor=208;THREE.OneMinusDstColorFactor=209;THREE.SrcAlphaSaturateFactor=210;THREE.NeverDepth=0;THREE.AlwaysDepth=1;THREE.LessDepth=2;THREE.LessEqualDepth=3;THREE.EqualDepth=4;THREE.GreaterEqualDepth=5;THREE.GreaterDepth=6;THREE.NotEqualDepth=7;THREE.MultiplyOperation=0;THREE.MixOperation=1;THREE.AddOperation=2;THREE.NoToneMapping=0;THREE.LinearToneMapping=1;THREE.ReinhardToneMapping=2;THREE.CineonToneMapping=3;THREE.ACESFilmicToneMapping=4;THREE.CustomToneMapping=5;THREE.UVMapping=300;THREE.CubeReflectionMapping=301;THREE.CubeRefractionMapping=302;THREE.EquirectangularReflectionMapping=303;THREE.EquirectangularRefractionMapping=304;THREE.CubeUVReflectionMapping=306;THREE.RepeatWrapping=1e3;THREE.ClampToEdgeWrapping=1001;THREE.MirroredRepeatWrapping=1002;THREE.NearestFilter=1003;THREE.NearestMipmapNearestFilter=1004;THREE.NearestMipmapLinearFilter=1005;THREE.LinearFilter=1006;THREE.LinearMipmapNearestFilter=1007;THREE.LinearMipmapLinearFilter=1008;THREE.UnsignedByteType=1009;THREE.ByteType=1010;THREE.ShortType=1011;THREE.UnsignedShortType=1012;THREE.IntType=1013;THREE.UnsignedIntType=1014;THREE.FloatType=1015;THREE.HalfFloatType=1016;THREE.UnsignedShort4444Type=1017;THREE.UnsignedShort5551Type=1018;THREE.UnsignedInt248Type=1020;THREE.AlphaFormat=1021;THREE.RGBFormat=1022;THREE.RGBAFormat=1023;THREE.LuminanceFormat=1024;THREE.LuminanceAlphaFormat=1025;THREE.DepthFormat=1026;THREE.DepthStencilFormat=1027;THREE.RedFormat=1028;THREE.RedIntegerFormat=1029;THREE.RGFormat=1030;THREE.RGIntegerFormat=1031;THREE.RGBAIntegerFormat=1033;THREE.RGB_S3TC_DXT1_Format=33776;THREE.RGBA_S3TC_DXT1_Format=33777;THREE.RGBA_S3TC_DXT3_Format=33778;THREE.RGBA_S3TC_DXT5_Format=33779;THREE.RGB_PVRTC_4BPPV1_Format=35840;THREE.RGB_PVRTC_2BPPV1_Format=35841;THREE.RGBA_PVRTC_4BPPV1_Format=35842;THREE.RGBA_PVRTC_2BPPV1_Format=35843;THREE.RGB_ETC1_Format=36196;THREE.RGB_ETC2_Format=37492;THREE.RGBA_ETC2_EAC_Format=37496;THREE.RGBA_ASTC_4x4_Format=37808;THREE.RGBA_ASTC_5x4_Format=37809;THREE.RGBA_ASTC_5x5_Format=37810;THREE.RGBA_ASTC_6x5_Format=37811;THREE.RGBA_ASTC_6x6_Format=37812;THREE.RGBA_ASTC_8x5_Format=37813;THREE.RGBA_ASTC_8x6_Format=37814;THREE.RGBA_ASTC_8x8_Format=37815;THREE.RGBA_ASTC_10x5_Format=37816;THREE.RGBA_ASTC_10x6_Format=37817;THREE.RGBA_ASTC_10x8_Format=37818;THREE.RGBA_ASTC_10x10_Format=37819;THREE.RGBA_ASTC_12x10_Format=37820;THREE.RGBA_ASTC_12x12_Format=37821;THREE.RGBA_BPTC_Format=36492;THREE.LoopOnce=2200;THREE.LoopRepeat=2201;THREE.LoopPingPong=2202;THREE.InterpolateDiscrete=2300;THREE.InterpolateLinear=2301;THREE.InterpolateSmooth=2302;THREE.ZeroCurvatureEnding=2400;THREE.ZeroSlopeEnding=2401;THREE.WrapAroundEnding=2402;THREE.NormalAnimationBlendMode=2500;THREE.AdditiveAnimationBlendMode=2501;THREE.TrianglesDrawMode=0;THREE.LinearEncoding=3e3;THREE.sRGBEncoding=3001;THREE.BasicDepthPacking=3200;THREE.RGBADepthPacking=3201;THREE.TangentSpaceNormalMap=0;THREE.ObjectSpaceNormalMap=1;THREE.SRGBColorSpace="srgb";THREE.LinearSRGBColorSpace="srgb-linear";THREE.KeepStencilOp=7680;THREE.AlwaysStencilFunc=519;

        // EventDispatcher
        class EventDispatcher{addEventListener(a,b){void 0===this._listeners&&(this._listeners={});const c=this._listeners;void 0===c[a]&&(c[a]=[]);-1===c[a].indexOf(b)&&c[a].push(b)}hasEventListener(a,b){if(void 0===this._listeners)return!1;const c=this._listeners;return void 0!==c[a]&&-1!==c[a].indexOf(b)}removeEventListener(a,b){if(void 0===this._listeners)return;const c=this._listeners[a];if(void 0!==c){const d=c.indexOf(b);-1!==d&&c.splice(d,1)}}dispatchEvent(a){if(void 0===this._listeners)return;const b=this._listeners[a.type];if(void 0!==b){a.target=this;const c=b.slice(0);for(let d=0,e=c.length;d<e;d++)c[d].call(this,a);a.target=null}}}

        // Vector3
        class Vector3{constructor(a=0,b=0,c=0){this.x=a;this.y=b;this.z=c}set(a,b,c){this.x=a;this.y=b;this.z=c;return this}setScalar(a){this.x=a;this.y=a;this.z=a;return this}clone(){return new Vector3(this.x,this.y,this.z)}copy(a){this.x=a.x;this.y=a.y;this.z=a.z;return this}add(a){this.x+=a.x;this.y+=a.y;this.z+=a.z;return this}addScalar(a){this.x+=a;this.y+=a;this.z+=a;return this}addVectors(a,b){this.x=a.x+b.x;this.y=a.y+b.y;this.z=a.z+b.z;return this}sub(a){this.x-=a.x;this.y-=a.y;this.z-=a.z;return this}subScalar(a){this.x-=a;this.y-=a;this.z-=a;return this}subVectors(a,b){this.x=a.x-b.x;this.y=a.y-b.y;this.z=a.z-b.z;return this}multiply(a){this.x*=a.x;this.y*=a.y;this.z*=a.z;return this}multiplyScalar(a){this.x*=a;this.y*=a;this.z*=a;return this}multiplyVectors(a,b){this.x=a.x*b.x;this.y=a.y*b.y;this.z=a.z*b.z;return this}divide(a){this.x/=a.x;this.y/=a.y;this.z/=a.z;return this}divideScalar(a){return this.multiplyScalar(1/a)}min(a){this.x=Math.min(this.x,a.x);this.y=Math.min(this.y,a.y);this.z=Math.min(this.z,a.z);return this}max(a){this.x=Math.max(this.x,a.x);this.y=Math.max(this.y,a.y);this.z=Math.max(this.z,a.z);return this}clamp(a,b){this.x=Math.max(a.x,Math.min(b.x,this.x));this.y=Math.max(a.y,Math.min(b.y,this.y));this.z=Math.max(a.z,Math.min(b.z,this.z));return this}clampScalar(a,b){this.x=Math.max(a,Math.min(b,this.x));this.y=Math.max(a,Math.min(b,this.y));this.z=Math.max(a,Math.min(b,this.z));return this}clampLength(a,b){const c=this.length();return this.divideScalar(c||1).multiplyScalar(Math.max(a,Math.min(b,c)))}floor(){this.x=Math.floor(this.x);this.y=Math.floor(this.y);this.z=Math.floor(this.z);return this}ceil(){this.x=Math.ceil(this.x);this.y=Math.ceil(this.y);this.z=Math.ceil(this.z);return this}round(){this.x=Math.round(this.x);this.y=Math.round(this.y);this.z=Math.round(this.z);return this}roundToZero(){this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x);this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y);this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z);return this}negate(){this.x=-this.x;this.y=-this.y;this.z=-this.z;return this}dot(a){return this.x*a.x+this.y*a.y+this.z*a.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(a){return this.normalize().multiplyScalar(a)}lerp(a,b){this.x+=(a.x-this.x)*b;this.y+=(a.y-this.y)*b;this.z+=(a.z-this.z)*b;return this}lerpVectors(a,b,c){this.x=a.x+(b.x-a.x)*c;this.y=a.y+(b.y-a.y)*c;this.z=a.z+(b.z-a.z)*c;return this}cross(a){return this.crossVectors(this,a)}crossVectors(a,b){const c=a.x,d=a.y,e=a.z,f=b.x,g=b.y,h=b.z;this.x=d*h-e*g;this.y=e*f-c*h;this.z=c*g-d*f;return this}distanceTo(a){return Math.sqrt(this.distanceToSquared(a))}distanceToSquared(a){const b=this.x-a.x,c=this.y-a.y,d=this.z-a.z;return b*b+c*c+d*d}applyMatrix4(a){const b=this.x,c=this.y,d=this.z,e=a.elements;let f=e[3]*b+e[7]*c+e[11]*d+e[15];f=f||1;this.x=(e[0]*b+e[4]*c+e[8]*d+e[12])/f;this.y=(e[1]*b+e[5]*c+e[9]*d+e[13])/f;this.z=(e[2]*b+e[6]*c+e[10]*d+e[14])/f;return this}}

        // Color
        class Color{constructor(a,b,c){this.r=1;this.g=1;this.b=1;return void 0===b&&void 0===c?this.set(a):this.setRGB(a,b,c)}set(a){a&&a.isColor?this.copy(a):"number"===typeof a?this.setHex(a):"string"===typeof a&&this.setStyle(a);return this}setScalar(a){this.r=a;this.g=a;this.b=a;return this}setHex(a){a=Math.floor(a);this.r=(a>>16&255)/255;this.g=(a>>8&255)/255;this.b=(a&255)/255;return this}setRGB(a,b,c){this.r=a;this.g=b;this.b=c;return this}setHSL(a,b,c){a=THREE.MathUtils.euclideanModulo(a,1);b=THREE.MathUtils.clamp(b,0,1);c=THREE.MathUtils.clamp(c,0,1);0===b?this.r=this.g=this.b=c:(b=.5>=c?c*(1+b):c+b-c*b,c=2*c-b,this.r=hue2rgb(c,b,a+1/3),this.g=hue2rgb(c,b,a),this.b=hue2rgb(c,b,a-1/3));return this}setStyle(a){function b(b){void 0!==b&&1>parseFloat(b)&&console.warn("THREE.Color: Alpha component of "+a+" will be ignored.")}let c;if(c=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(a)){let d=c[2];switch(c[1]){case "rgb":case "rgba":if(c=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(d))return this.r=Math.min(255,parseInt(c[1],10))/255,this.g=Math.min(255,parseInt(c[2],10))/255,this.b=Math.min(255,parseInt(c[3],10))/255,b(c[4]),this;if(c=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(d))return this.r=Math.min(100,parseInt(c[1],10))/100,this.g=Math.min(100,parseInt(c[2],10))/100,this.b=Math.min(100,parseInt(c[3],10))/100,b(c[4]),this;break;case "hsl":case "hsla":if(c=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(d)){d=parseFloat(c[1])/360;const e=parseInt(c[2],10)/100,f=parseInt(c[3],10)/100;b(c[4]);return this.setHSL(d,e,f)}}}else if(c=/^\#([A-Fa-f\d]+)$/.exec(a)){c=c[1];d=c.length;if(3===d)return this.r=parseInt(c.charAt(0)+c.charAt(0),16)/255,this.g=parseInt(c.charAt(1)+c.charAt(1),16)/255,this.b=parseInt(c.charAt(2)+c.charAt(2),16)/255,this;if(6===d)return this.r=parseInt(c.charAt(0)+c.charAt(1),16)/255,this.g=parseInt(c.charAt(2)+c.charAt(3),16)/255,this.b=parseInt(c.charAt(4)+c.charAt(5),16)/255,this}return a&&0<a.length?this.setColorName(a):this}clone(){return new Color(this.r,this.g,this.b)}copy(a){this.r=a.r;this.g=a.g;this.b=a.b;return this}}function hue2rgb(a,b,c){0>c&&(c+=1);1<c&&(c-=1);return c<1/6?a+6*(b-a)*c:.5>c?b:c<2/3?a+(b-a)*(2/3-c)*6:a}

        // MathUtils
        THREE.MathUtils={DEG2RAD:Math.PI/180,RAD2DEG:180/Math.PI,generateUUID:function(){const a="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split("");const b=Array(36);let c=0,d;return function(){for(let e=0;36>e;e++)8===e||13===e||18===e||23===e?b[e]="-":14===e?b[e]="4":(2>=c&&(c=33554432+16777216*Math.random()|0),d=c&15,c>>=4,b[e]=a[19===e?d&3|8:d]);return b.join("")}}(),clamp:function(a,b,c){return Math.max(b,Math.min(c,a))},euclideanModulo:function(a,b){return(a%b+b)%b},mapLinear:function(a,b,c,d,e){return d+(a-b)*(e-d)/(c-b)},lerp:function(a,b,c){return(1-c)*a+c*b},smoothstep:function(a,b,c){if(a<=b)return 0;if(a>=c)return 1;a=(a-b)/(c-b);return a*a*(3-2*a)},smootherstep:function(a,b,c){if(a<=b)return 0;if(a>=c)return 1;a=(a-b)/(c-b);return a*a*a*(a*(6*a-15)+10)},randInt:function(a,b){return a+Math.floor(Math.random()*(b-a+1))},randFloat:function(a,b){return a+Math.random()*(b-a)},randFloatSpread:function(a){return a*(.5-Math.random())},seededRandom:function(a){1!==a&&(a=a%2147483647,0>=a&&(a+=2147483646));return(a=16807*a%2147483647)/2147483647},degToRad:function(a){return a*THREE.MathUtils.DEG2RAD},radToDeg:function(a){return a*THREE.MathUtils.RAD2DEG},isPowerOfTwo:function(a){return 0===(a&a-1)&&0!==a},ceilPowerOfTwo:function(a){return Math.pow(2,Math.ceil(Math.log(a)/Math.LN2))},floorPowerOfTwo:function(a){return Math.pow(2,Math.floor(Math.log(a)/Math.LN2))}};

        // Basic Three.js classes (simplified for this app)
        class Object3D extends EventDispatcher{constructor(){super();this.position=new Vector3;this.rotation={x:0,y:0,z:0};this.scale=new Vector3(1,1,1);this.children=[];this.parent=null;this.visible=true;}add(obj){if(obj===this){console.error("Object3D.add: object can't be added as a child of itself.",obj);return this}obj.parent=this;this.children.push(obj);return this}remove(obj){const index=this.children.indexOf(obj);if(index!==-1){obj.parent=null;this.children.splice(index,1)}}traverse(callback){callback(this);const children=this.children;for(let i=0;i<children.length;i++){children[i].traverse(callback)}}}

        class Scene extends Object3D{constructor(){super();this.type='Scene';this.background=null;this.fog=null}}

        class PerspectiveCamera extends Object3D{constructor(fov=50,aspect=1,near=0.1,far=2000){super();this.type='PerspectiveCamera';this.fov=fov;this.aspect=aspect;this.near=near;this.far=far}}

        class WebGLRenderer{constructor(params={}){this.domElement=document.createElement('canvas');this.domElement.width=params.width||window.innerWidth;this.domElement.height=params.height||window.innerHeight;this.context=this.domElement.getContext('webgl2')||this.domElement.getContext('webgl');this.clearColor=new Color(0,0,0);this.clearAlpha=1}setSize(width,height){this.domElement.width=width;this.domElement.height=height;this.domElement.style.width=width+'px';this.domElement.style.height=height+'px'}setClearColor(color,alpha=1){if(typeof color==='number'){this.clearColor.setHex(color)}else{this.clearColor.copy(color)}this.clearAlpha=alpha}render(scene,camera){const gl=this.context;gl.viewport(0,0,this.domElement.width,this.domElement.height);gl.clearColor(this.clearColor.r*this.clearAlpha,this.clearColor.g*this.clearAlpha,this.clearColor.b*this.clearAlpha,this.clearAlpha);gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT)}}

        class Mesh extends Object3D{constructor(geometry,material){super();this.type='Mesh';this.geometry=geometry;this.material=material}}

        class BoxGeometry{}
        class SphereGeometry{constructor(radius,widthSegments,heightSegments){this.radius=radius;this.widthSegments=widthSegments;this.heightSegments=heightSegments}}
        class PlaneGeometry{}
        class MeshBasicMaterial{constructor(params={}){this.color=params.color||new Color(1,1,1);this.wireframe=params.wireframe||false;this.transparent=params.transparent||false;this.opacity=params.opacity||1}}
        class MeshStandardMaterial extends MeshBasicMaterial{}
        class PointsMaterial extends MeshBasicMaterial{constructor(params={}){super(params);this.size=params.size||1}}
        class Points extends Object3D{constructor(geometry,material){super();this.type='Points';this.geometry=geometry;this.material=material}}
        class AmbientLight extends Object3D{constructor(color,intensity=1){super();this.type='AmbientLight';this.color=color;this.intensity=intensity}}
        class DirectionalLight extends Object3D{constructor(color,intensity=1){super();this.type='DirectionalLight';this.color=color;this.intensity=intensity}}
        class PointLight extends Object3D{constructor(color,intensity=1,distance=0){super();this.type='PointLight';this.color=color;this.intensity=intensity;this.distance=distance}}

        // ===== QUANTUM GARDEN APPLICATION =====

        /**
         * Main application class for the Quantum Garden of Floating Islands
         * Manages 3D scene, player movement, networking, and game state
         */
        class QuantumGarden {
            constructor() {
                // Core Three.js components
                this.scene = null;
                this.camera = null;
                this.renderer = null;

                // Game state
                this.player = {
                    position: new Vector3(0, 5, 0),
                    velocity: new Vector3(0, 0, 0),
                    rotation: { x: 0, y: 0 },
                    seeds: 10,
                    isGrounded: false,
                    currentIsland: null
                };

                // World objects
                this.islands = [];
                this.plants = [];
                this.particles = [];
                this.waterfalls = [];

                // Input state
                this.keys = {};
                this.mouse = { x: 0, y: 0, deltaX: 0, deltaY: 0, locked: false };
                this.touch = { active: false, startX: 0, startY: 0, currentX: 0, currentY: 0 };

                // Networking (P2P multiplayer)
                this.peer = null;
                this.connections = new Map();
                this.peerId = null;

                // Animation
                this.clock = { startTime: Date.now(), oldTime: Date.now(), elapsedTime: 0 };
                this.animationId = null;

                // Settings
                this.settings = {
                    renderDistance: 200,
                    particleCount: 500,
                    gravity: -0.3,
                    jumpForce: 0.5,
                    moveSpeed: 0.2,
                    mouseSensitivity: 0.002
                };

                this.init();
            }

            /**
             * Initialize the application
             */
            init() {
                this.setupScene();
                this.loadState();
                this.generateWorld();
                this.setupControls();
                this.setupUI();
                this.initNetworking();
                this.animate();

                console.log('üèùÔ∏è Quantum Garden initialized');
            }

            /**
             * Setup Three.js scene, camera, and renderer
             */
            setupScene() {
                // Create scene with quantum-themed background
                this.scene = new Scene();
                this.scene.background = new Color(0x0a0e27);

                // Setup camera
                this.camera = new PerspectiveCamera(
                    75,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    this.settings.renderDistance
                );
                this.camera.position.copy(this.player.position);

                // Setup renderer with proper canvas sizing
                const container = document.getElementById('canvas-container');
                this.renderer = new WebGLRenderer({ antialias: true, alpha: false });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(0x0a0e27, 1);
                container.appendChild(this.renderer.domElement);

                // Add ambient lighting for visibility
                const ambient = new AmbientLight(0x63e3d0, 0.4);
                this.scene.add(ambient);

                // Add directional light for depth
                const dirLight = new DirectionalLight(0x9f7aea, 0.8);
                dirLight.position.set(50, 100, 50);
                this.scene.add(dirLight);

                // Handle window resize
                window.addEventListener('resize', () => this.onResize());
            }

            /**
             * Generate the quantum world with islands, plants, and effects
             */
            generateWorld() {
                // Create central starting island
                this.createIsland(new Vector3(0, 0, 0), 15, 'central');

                // Generate ring of surrounding islands
                const islandCount = 8;
                const radius = 40;
                for (let i = 0; i < islandCount; i++) {
                    const angle = (i / islandCount) * Math.PI * 2;
                    const x = Math.cos(angle) * radius;
                    const z = Math.sin(angle) * radius;
                    const y = THREE.MathUtils.randFloat(-10, 10);
                    const size = THREE.MathUtils.randFloat(8, 12);
                    this.createIsland(new Vector3(x, y, z), size, 'ring');
                }

                // Generate distant islands
                for (let i = 0; i < 12; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = THREE.MathUtils.randFloat(60, 120);
                    const x = Math.cos(angle) * dist;
                    const z = Math.sin(angle) * dist;
                    const y = THREE.MathUtils.randFloat(-20, 20);
                    const size = THREE.MathUtils.randFloat(6, 10);
                    this.createIsland(new Vector3(x, y, z), size, 'distant');
                }

                // Create bioluminescent particle field
                this.createParticleField();

                // Add initial plants to some islands
                this.islands.slice(0, 5).forEach(island => {
                    const plantCount = Math.floor(Math.random() * 3) + 1;
                    for (let i = 0; i < plantCount; i++) {
                        const offsetX = THREE.MathUtils.randFloatSpread(island.size * 0.6);
                        const offsetZ = THREE.MathUtils.randFloatSpread(island.size * 0.6);
                        const plantPos = new Vector3(
                            island.position.x + offsetX,
                            island.position.y + island.size / 2,
                            island.position.z + offsetZ
                        );
                        this.createPlant(plantPos, Math.random());
                    }
                });

                // Create crystalline waterfalls on some islands
                this.islands.slice(0, 6).forEach((island, idx) => {
                    if (idx % 2 === 0) {
                        this.createWaterfall(island);
                    }
                });
            }

            /**
             * Create a floating island with gravity zone
             */
            createIsland(position, size, type) {
                const island = {
                    position: position.clone(),
                    size: size,
                    type: type,
                    mesh: null,
                    gravityZone: size * 2, // Gravity influence radius
                    gravityStrength: 0.02,
                    rotation: { y: Math.random() * 0.001 }
                };

                // Create visual representation (simple colored sphere for performance)
                const geometry = new SphereGeometry(size, 16, 16);
                const material = new MeshStandardMaterial({
                    color: new Color().setHSL(0.5 + Math.random() * 0.1, 0.7, 0.4),
                    wireframe: false
                });
                const mesh = new Mesh(geometry, material);
                mesh.position.copy(position);
                this.scene.add(mesh);
                island.mesh = mesh;

                // Add glow effect with point light
                const light = new PointLight(0x63e3d0, 0.5, size * 3);
                light.position.copy(position);
                this.scene.add(light);
                island.light = light;

                this.islands.push(island);
                return island;
            }

            /**
             * Create a bioluminescent plant
             */
            createPlant(position, growthStage = 0) {
                const plant = {
                    position: position.clone(),
                    growthStage: growthStage, // 0 to 1
                    targetGrowth: 1,
                    growthSpeed: 0.001,
                    color: new Color().setHSL(0.3 + Math.random() * 0.3, 0.9, 0.6),
                    mesh: null,
                    light: null,
                    createdAt: Date.now(),
                    ownerId: this.peerId || 'local'
                };

                // Create visual (sphere that grows)
                const size = 0.5 + growthStage * 2;
                const geometry = new SphereGeometry(size, 8, 8);
                const material = new MeshBasicMaterial({
                    color: plant.color,
                    transparent: true,
                    opacity: 0.7 + growthStage * 0.3
                });
                const mesh = new Mesh(geometry, material);
                mesh.position.copy(position);
                this.scene.add(mesh);
                plant.mesh = mesh;

                // Add glowing point light
                const light = new PointLight(plant.color, growthStage * 2, 10);
                light.position.copy(position);
                this.scene.add(light);
                plant.light = light;

                this.plants.push(plant);
                this.updateStats();

                // Broadcast to network
                this.broadcastPlant(plant);

                return plant;
            }

            /**
             * Create upward-flowing crystalline waterfall
             */
            createWaterfall(island) {
                const waterfall = {
                    island: island,
                    particles: [],
                    mesh: null,
                    active: true
                };

                // Create particle stream flowing upward
                const particleCount = 50;
                const positions = new Float32Array(particleCount * 3);

                for (let i = 0; i < particleCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = island.size * 0.7;
                    const x = island.position.x + Math.cos(angle) * radius;
                    const y = island.position.y + Math.random() * 30;
                    const z = island.position.z + Math.sin(angle) * radius;

                    positions[i * 3] = x;
                    positions[i * 3 + 1] = y;
                    positions[i * 3 + 2] = z;
                }

                // Store particle data for animation
                waterfall.positions = positions;
                waterfall.velocities = new Float32Array(particleCount * 3);

                this.waterfalls.push(waterfall);
            }

            /**
             * Create bioluminescent particle field
             */
            createParticleField() {
                const count = this.settings.particleCount;

                for (let i = 0; i < count; i++) {
                    const particle = {
                        position: new Vector3(
                            THREE.MathUtils.randFloatSpread(200),
                            THREE.MathUtils.randFloatSpread(100),
                            THREE.MathUtils.randFloatSpread(200)
                        ),
                        velocity: new Vector3(
                            THREE.MathUtils.randFloatSpread(0.02),
                            THREE.MathUtils.randFloatSpread(0.02),
                            THREE.MathUtils.randFloatSpread(0.02)
                        ),
                        color: new Color().setHSL(Math.random(), 0.8, 0.6),
                        size: Math.random() * 0.3 + 0.1,
                        life: Math.random()
                    };

                    this.particles.push(particle);
                }
            }

            /**
             * Setup keyboard, mouse, and touch controls
             */
            setupControls() {
                // Keyboard
                window.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;
                    if (e.code === 'Space') {
                        e.preventDefault();
                        this.jump();
                    }
                });

                window.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                });

                // Mouse look (pointer lock)
                const canvas = this.renderer.domElement;
                canvas.addEventListener('click', () => {
                    if (!this.mouse.locked) {
                        canvas.requestPointerLock();
                    }
                });

                document.addEventListener('pointerlockchange', () => {
                    this.mouse.locked = document.pointerLockElement === canvas;
                });

                document.addEventListener('mousemove', (e) => {
                    if (this.mouse.locked) {
                        this.mouse.deltaX = e.movementX;
                        this.mouse.deltaY = e.movementY;
                        this.updateCameraRotation();
                    }
                });

                // Mouse click to plant seed
                canvas.addEventListener('click', (e) => {
                    if (this.mouse.locked) {
                        this.plantSeed();
                    }
                });

                // Touch controls for mobile
                this.setupTouchControls();
            }

            /**
             * Setup mobile touch controls (joystick and buttons)
             */
            setupTouchControls() {
                const joystick = document.getElementById('joystick');
                const knob = document.getElementById('joystick-knob');
                const jumpBtn = document.getElementById('mobile-jump');
                const plantBtn = document.getElementById('mobile-plant');

                // Detect mobile
                const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
                if (isMobile) {
                    document.getElementById('mobile-controls').classList.add('visible');
                }

                // Virtual joystick
                let joystickActive = false;
                let joystickStart = { x: 0, y: 0 };

                const handleJoystickStart = (e) => {
                    joystickActive = true;
                    const rect = joystick.getBoundingClientRect();
                    joystickStart.x = rect.left + rect.width / 2;
                    joystickStart.y = rect.top + rect.height / 2;
                };

                const handleJoystickMove = (e) => {
                    if (!joystickActive) return;

                    const touch = e.touches[0];
                    const deltaX = touch.clientX - joystickStart.x;
                    const deltaY = touch.clientY - joystickStart.y;

                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    const maxDistance = 35;

                    if (distance > maxDistance) {
                        const angle = Math.atan2(deltaY, deltaX);
                        knob.style.left = `${50 + Math.cos(angle) * maxDistance}px`;
                        knob.style.top = `${50 + Math.sin(angle) * maxDistance}px`;
                    } else {
                        knob.style.left = `${50 + deltaX}px`;
                        knob.style.top = `${50 + deltaY}px`;
                    }

                    // Simulate WASD keys
                    this.keys.KeyW = deltaY < -10;
                    this.keys.KeyS = deltaY > 10;
                    this.keys.KeyA = deltaX < -10;
                    this.keys.KeyD = deltaX > 10;
                };

                const handleJoystickEnd = () => {
                    joystickActive = false;
                    knob.style.left = '50%';
                    knob.style.top = '50%';
                    this.keys.KeyW = false;
                    this.keys.KeyS = false;
                    this.keys.KeyA = false;
                    this.keys.KeyD = false;
                };

                joystick.addEventListener('touchstart', handleJoystickStart);
                joystick.addEventListener('touchmove', handleJoystickMove);
                joystick.addEventListener('touchend', handleJoystickEnd);

                // Mobile buttons
                jumpBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.jump();
                });

                plantBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.plantSeed();
                });
            }

            /**
             * Setup UI event listeners
             */
            setupUI() {
                document.getElementById('collect-btn').addEventListener('click', () => {
                    this.collectSeed();
                });

                document.getElementById('export-btn').addEventListener('click', () => {
                    this.exportWorld();
                });

                document.getElementById('import-btn').addEventListener('click', () => {
                    this.showImportModal();
                });

                document.getElementById('modal-close').addEventListener('click', () => {
                    this.hideModal();
                });

                this.updateStats();
            }

            /**
             * Initialize P2P networking with PeerJS
             */
            initNetworking() {
                // Simplified peer networking (would use real PeerJS in production)
                this.peerId = 'player_' + Math.random().toString(36).substr(2, 9);
                console.log('üåê Peer ID:', this.peerId);

                // Simulate connection status
                setTimeout(() => {
                    this.updateConnectionStatus();
                }, 1000);
            }

            /**
             * Main animation loop
             */
            animate() {
                this.animationId = requestAnimationFrame(() => this.animate());

                const currentTime = Date.now();
                const deltaTime = (currentTime - this.clock.oldTime) / 1000;
                this.clock.oldTime = currentTime;
                this.clock.elapsedTime = (currentTime - this.clock.startTime) / 1000;

                // Update game systems
                this.updatePlayer(deltaTime);
                this.updatePhysics(deltaTime);
                this.updatePlants(deltaTime);
                this.updateParticles(deltaTime);
                this.updateWaterfalls(deltaTime);
                this.updateIslands(deltaTime);
                this.updateCamera();

                // Render scene
                this.renderer.render(this.scene, this.camera);
            }

            /**
             * Update player movement and input
             */
            updatePlayer(deltaTime) {
                const speed = this.settings.moveSpeed;
                const forward = new Vector3(0, 0, -1);
                const right = new Vector3(1, 0, 0);

                // Rotate movement vectors by camera rotation
                const yaw = this.player.rotation.y;
                const cosYaw = Math.cos(yaw);
                const sinYaw = Math.sin(yaw);

                forward.set(-sinYaw, 0, -cosYaw);
                right.set(cosYaw, 0, -sinYaw);

                // Apply movement from input
                const movement = new Vector3(0, 0, 0);

                if (this.keys.KeyW) movement.add(forward);
                if (this.keys.KeyS) movement.sub(forward);
                if (this.keys.KeyD) movement.add(right);
                if (this.keys.KeyA) movement.sub(right);

                if (movement.length() > 0) {
                    movement.normalize().multiplyScalar(speed);
                    this.player.velocity.x = movement.x;
                    this.player.velocity.z = movement.z;
                } else {
                    // Apply friction when not moving
                    this.player.velocity.x *= 0.8;
                    this.player.velocity.z *= 0.8;
                }

                // Update position
                this.player.position.add(this.player.velocity);

                // Update stats display
                this.updateStats();
            }

            /**
             * Update physics (gravity, collision detection)
             */
            updatePhysics(deltaTime) {
                // Find nearest island for gravity
                let nearestIsland = null;
                let nearestDist = Infinity;

                this.islands.forEach(island => {
                    const dist = this.player.position.distanceTo(island.position);
                    if (dist < island.gravityZone && dist < nearestDist) {
                        nearestDist = dist;
                        nearestIsland = island;
                    }
                });

                this.player.currentIsland = nearestIsland;

                if (nearestIsland) {
                    // Apply gravity toward island center
                    const toIsland = new Vector3()
                        .subVectors(nearestIsland.position, this.player.position)
                        .normalize()
                        .multiplyScalar(nearestIsland.gravityStrength);

                    this.player.velocity.add(toIsland);

                    // Check ground collision
                    const distToSurface = this.player.position.distanceTo(nearestIsland.position) - nearestIsland.size;
                    if (distToSurface < 1) {
                        this.player.isGrounded = true;
                        // Push player to surface
                        const normal = new Vector3()
                            .subVectors(this.player.position, nearestIsland.position)
                            .normalize();
                        this.player.position.copy(nearestIsland.position)
                            .add(normal.multiplyScalar(nearestIsland.size + 1));

                        // Cancel velocity toward island
                        const velocityToward = this.player.velocity.dot(normal);
                        if (velocityToward < 0) {
                            this.player.velocity.sub(normal.multiplyScalar(velocityToward));
                        }
                    } else {
                        this.player.isGrounded = false;
                    }
                } else {
                    // No island nearby, apply default gravity
                    this.player.velocity.y += this.settings.gravity * deltaTime;
                    this.player.isGrounded = false;
                }

                // Respawn if fallen too far
                if (this.player.position.y < -100) {
                    this.respawnPlayer();
                }
            }

            /**
             * Update plant growth
             */
            updatePlants(deltaTime) {
                this.plants.forEach((plant, index) => {
                    // Grow toward target
                    if (plant.growthStage < plant.targetGrowth) {
                        plant.growthStage = Math.min(
                            plant.targetGrowth,
                            plant.growthStage + plant.growthSpeed
                        );

                        // Update visual
                        if (plant.mesh) {
                            const scale = 0.5 + plant.growthStage * 2;
                            plant.mesh.scale.setScalar(scale);
                            plant.mesh.material.opacity = 0.7 + plant.growthStage * 0.3;
                        }

                        if (plant.light) {
                            plant.light.intensity = plant.growthStage * 2;
                        }
                    }

                    // Pulse glow effect
                    if (plant.light) {
                        const pulse = Math.sin(this.clock.elapsedTime * 2 + index) * 0.3 + 0.7;
                        plant.light.intensity = plant.growthStage * 2 * pulse;
                    }

                    // Gentle floating animation
                    if (plant.mesh) {
                        plant.mesh.position.y = plant.position.y + Math.sin(this.clock.elapsedTime * 2 + index) * 0.1;
                    }
                });
            }

            /**
             * Update particle field animation
             */
            updateParticles(deltaTime) {
                this.particles.forEach(particle => {
                    // Move particle
                    particle.position.add(particle.velocity);

                    // Wrap around world bounds
                    if (Math.abs(particle.position.x) > 100) particle.position.x *= -1;
                    if (Math.abs(particle.position.y) > 50) particle.position.y *= -1;
                    if (Math.abs(particle.position.z) > 100) particle.position.z *= -1;

                    // Pulse life
                    particle.life = (particle.life + 0.01) % 1;
                });
            }

            /**
             * Update upward-flowing waterfalls
             */
            updateWaterfalls(deltaTime) {
                this.waterfalls.forEach(waterfall => {
                    if (!waterfall.active) return;

                    const particleCount = waterfall.positions.length / 3;

                    for (let i = 0; i < particleCount; i++) {
                        // Move particles upward
                        waterfall.positions[i * 3 + 1] += 0.5;

                        // Reset if too high
                        if (waterfall.positions[i * 3 + 1] > waterfall.island.position.y + 30) {
                            const angle = Math.random() * Math.PI * 2;
                            const radius = waterfall.island.size * 0.7;
                            waterfall.positions[i * 3] = waterfall.island.position.x + Math.cos(angle) * radius;
                            waterfall.positions[i * 3 + 1] = waterfall.island.position.y;
                            waterfall.positions[i * 3 + 2] = waterfall.island.position.z + Math.sin(angle) * radius;
                        }
                    }
                });
            }

            /**
             * Update island animations (rotation, floating)
             */
            updateIslands(deltaTime) {
                this.islands.forEach((island, index) => {
                    // Gentle rotation
                    if (island.mesh) {
                        island.mesh.rotation.y += island.rotation.y;
                    }

                    // Floating animation
                    const floatOffset = Math.sin(this.clock.elapsedTime * 0.5 + index) * 0.5;
                    if (island.mesh) {
                        island.mesh.position.y = island.position.y + floatOffset;
                    }
                    if (island.light) {
                        island.light.position.y = island.position.y + floatOffset;
                    }
                });
            }

            /**
             * Update camera position and rotation to follow player
             */
            updateCamera() {
                this.camera.position.copy(this.player.position);
                this.camera.rotation.x = this.player.rotation.x;
                this.camera.rotation.y = this.player.rotation.y;
            }

            /**
             * Update camera rotation from mouse movement
             */
            updateCameraRotation() {
                this.player.rotation.y -= this.mouse.deltaX * this.settings.mouseSensitivity;
                this.player.rotation.x -= this.mouse.deltaY * this.settings.mouseSensitivity;

                // Clamp pitch
                this.player.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.player.rotation.x));

                // Reset deltas
                this.mouse.deltaX = 0;
                this.mouse.deltaY = 0;
            }

            /**
             * Make player jump (if grounded)
             */
            jump() {
                if (this.player.isGrounded) {
                    const jumpDir = new Vector3()
                        .subVectors(this.player.position, this.player.currentIsland.position)
                        .normalize()
                        .multiplyScalar(this.settings.jumpForce);

                    this.player.velocity.add(jumpDir);
                    this.player.isGrounded = false;
                }
            }

            /**
             * Plant a seed at the targeted location
             */
            plantSeed() {
                if (this.player.seeds <= 0) {
                    console.log('No seeds available!');
                    return;
                }

                // Raycast to find planting location (simplified)
                if (this.player.currentIsland) {
                    const forward = new Vector3(
                        -Math.sin(this.player.rotation.y),
                        0,
                        -Math.cos(this.player.rotation.y)
                    ).multiplyScalar(5);

                    const plantPos = this.player.position.clone().add(forward);

                    // Snap to nearest island surface
                    const toIsland = new Vector3()
                        .subVectors(this.player.currentIsland.position, plantPos)
                        .normalize();
                    plantPos.copy(this.player.currentIsland.position)
                        .add(toIsland.multiplyScalar(-this.player.currentIsland.size));

                    this.createPlant(plantPos, 0);
                    this.player.seeds--;
                    this.updateStats();

                    console.log('üå± Planted seed!');
                }
            }

            /**
             * Collect a seed (increase seed count)
             */
            collectSeed() {
                this.player.seeds++;
                this.updateStats();
                console.log('üå± Collected seed!');
            }

            /**
             * Respawn player at starting position
             */
            respawnPlayer() {
                this.player.position.set(0, 15, 0);
                this.player.velocity.set(0, 0, 0);
                console.log('üîÑ Respawned');
            }

            /**
             * Update UI stats display
             */
            updateStats() {
                document.getElementById('player-pos').textContent =
                    `${Math.floor(this.player.position.x)}, ${Math.floor(this.player.position.y)}, ${Math.floor(this.player.position.z)}`;
                document.getElementById('islands-count').textContent = this.islands.length;
                document.getElementById('plants-count').textContent = this.plants.length;
                document.getElementById('seed-count').textContent = this.player.seeds;
                document.getElementById('online-count').textContent = this.connections.size;
            }

            /**
             * Update network connection status display
             */
            updateConnectionStatus() {
                // Simplified for demo (would show real peer count in production)
                const status = document.getElementById('connection-status');
                if (!status) return;

                if (this.connections.size > 0) {
                    status.className = 'connected';
                    status.textContent = `üåê Connected (${this.connections.size})`;
                } else {
                    status.className = 'disconnected';
                    status.textContent = 'üåê Solo Mode';
                }
            }

            /**
             * Broadcast plant creation to connected peers
             */
            broadcastPlant(plant) {
                const message = {
                    type: 'plant_created',
                    data: {
                        position: { x: plant.position.x, y: plant.position.y, z: plant.position.z },
                        color: plant.color.getHex(),
                        growthStage: plant.growthStage,
                        createdAt: plant.createdAt,
                        ownerId: plant.ownerId
                    }
                };

                // Would send via PeerJS in production
                console.log('üì° Broadcasting plant:', message);
            }

            /**
             * Export world state to JSON
             */
            exportWorld() {
                const worldState = {
                    version: '1.0',
                    timestamp: Date.now(),
                    player: {
                        position: { x: this.player.position.x, y: this.player.position.y, z: this.player.position.z },
                        seeds: this.player.seeds
                    },
                    islands: this.islands.map(island => ({
                        position: { x: island.position.x, y: island.position.y, z: island.position.z },
                        size: island.size,
                        type: island.type
                    })),
                    plants: this.plants.map(plant => ({
                        position: { x: plant.position.x, y: plant.position.y, z: plant.position.z },
                        growthStage: plant.growthStage,
                        color: plant.color.getHex(),
                        createdAt: plant.createdAt,
                        ownerId: plant.ownerId
                    }))
                };

                const json = JSON.stringify(worldState, null, 2);

                // Show export modal
                this.showModal('Export World', `
                    <p style="margin-bottom: 15px; color: #b8c5ff;">Copy this JSON data to save your world:</p>
                    <textarea readonly style="width: 100%; min-height: 300px;">${json}</textarea>
                `);

                console.log('üì§ Exported world state');
            }

            /**
             * Show import modal
             */
            showImportModal() {
                this.showModal('Import World', `
                    <p style="margin-bottom: 15px; color: #b8c5ff;">Paste JSON world data below:</p>
                    <textarea id="import-data" style="width: 100%; min-height: 300px;" placeholder="Paste JSON here..."></textarea>
                `, () => {
                    const data = document.getElementById('import-data').value;
                    this.importWorld(data);
                });
            }

            /**
             * Import world state from JSON
             */
            importWorld(jsonData) {
                try {
                    const worldState = JSON.parse(jsonData);

                    // Validate version
                    if (!worldState.version) {
                        throw new Error('Invalid world data format');
                    }

                    // Clear existing world
                    this.clearWorld();

                    // Restore player state
                    if (worldState.player) {
                        this.player.position.set(
                            worldState.player.position.x,
                            worldState.player.position.y,
                            worldState.player.position.z
                        );
                        this.player.seeds = worldState.player.seeds || 10;
                    }

                    // Restore islands
                    if (worldState.islands) {
                        worldState.islands.forEach(islandData => {
                            this.createIsland(
                                new Vector3(islandData.position.x, islandData.position.y, islandData.position.z),
                                islandData.size,
                                islandData.type
                            );
                        });
                    }

                    // Restore plants
                    if (worldState.plants) {
                        worldState.plants.forEach(plantData => {
                            const plant = this.createPlant(
                                new Vector3(plantData.position.x, plantData.position.y, plantData.position.z),
                                plantData.growthStage
                            );
                            if (plantData.color) {
                                plant.color.setHex(plantData.color);
                                if (plant.mesh) plant.mesh.material.color = plant.color;
                                if (plant.light) plant.light.color = plant.color;
                            }
                        });
                    }

                    this.updateStats();
                    this.hideModal();
                    console.log('üì• Imported world state');

                } catch (error) {
                    console.error('Failed to import world:', error);
                    alert('Failed to import world data. Please check the JSON format.');
                }
            }

            /**
             * Clear all world objects except particles
             */
            clearWorld() {
                // Remove islands
                this.islands.forEach(island => {
                    if (island.mesh) this.scene.remove(island.mesh);
                    if (island.light) this.scene.remove(island.light);
                });
                this.islands = [];

                // Remove plants
                this.plants.forEach(plant => {
                    if (plant.mesh) this.scene.remove(plant.mesh);
                    if (plant.light) this.scene.remove(plant.light);
                });
                this.plants = [];

                // Remove waterfalls
                this.waterfalls = [];
            }

            /**
             * Save state to localStorage
             */
            saveState() {
                const state = {
                    player: {
                        position: { x: this.player.position.x, y: this.player.position.y, z: this.player.position.z },
                        seeds: this.player.seeds
                    },
                    plants: this.plants.map(plant => ({
                        position: { x: plant.position.x, y: plant.position.y, z: plant.position.z },
                        growthStage: plant.growthStage,
                        color: plant.color.getHex()
                    }))
                };

                localStorage.setItem('quantum_garden_state', JSON.stringify(state));
            }

            /**
             * Load state from localStorage
             */
            loadState() {
                const saved = localStorage.getItem('quantum_garden_state');
                if (!saved) return;

                try {
                    const state = JSON.parse(saved);

                    if (state.player) {
                        this.player.seeds = state.player.seeds || 10;
                    }

                    // Plants will be loaded after world generation
                    this.savedPlants = state.plants || [];

                } catch (error) {
                    console.error('Failed to load saved state:', error);
                }
            }

            /**
             * Show modal dialog
             */
            showModal(title, bodyHTML, actionCallback = null) {
                document.getElementById('modal-title').textContent = title;
                document.getElementById('modal-body').innerHTML = bodyHTML;
                document.getElementById('modal-overlay').classList.add('visible');

                const actionBtn = document.getElementById('modal-action');
                if (actionCallback) {
                    actionBtn.style.display = 'block';
                    actionBtn.textContent = 'Import';
                    actionBtn.onclick = actionCallback;
                } else {
                    actionBtn.style.display = 'none';
                }
            }

            /**
             * Hide modal dialog
             */
            hideModal() {
                document.getElementById('modal-overlay').classList.remove('visible');
            }

            /**
             * Handle window resize
             */
            onResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }

            /**
             * Cleanup and destroy
             */
            destroy() {
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                }

                this.saveState();

                // Clean up Three.js resources
                this.scene.traverse(obj => {
                    if (obj.geometry) obj.geometry.dispose();
                    if (obj.material) {
                        if (Array.isArray(obj.material)) {
                            obj.material.forEach(mat => mat.dispose());
                        } else {
                            obj.material.dispose();
                        }
                    }
                });

                this.renderer.domElement.remove();

                console.log('üèùÔ∏è Quantum Garden destroyed');
            }
        }

        // ===== APPLICATION START =====

        // Initialize application when page loads
        let app = null;

        window.addEventListener('load', () => {
            app = new QuantumGarden();
        });

        // Save state before page unload
        window.addEventListener('beforeunload', () => {
            if (app) {
                app.saveState();
            }
        });

        // Cleanup on page unload
        window.addEventListener('unload', () => {
            if (app) {
                app.destroy();
            }
        });
    </script>
</body>
</html>