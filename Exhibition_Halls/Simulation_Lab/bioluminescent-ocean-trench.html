<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bioluminescent Deep Ocean Trench - Quantum World</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(180deg, #000814 0%, #001a33 100%);
            color: #00ffff;
            overflow: hidden;
            height: 100vh;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        #ui {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            pointer-events: none;
            z-index: 100;
        }

        #hud {
            display: flex;
            justify-content: space-between;
            padding: 20px;
            background: linear-gradient(180deg, rgba(0, 26, 51, 0.8) 0%, transparent 100%);
        }

        .stat-panel {
            background: rgba(0, 26, 51, 0.9);
            border: 2px solid #00ffff;
            border-radius: 10px;
            padding: 15px;
            min-width: 200px;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 14px;
        }

        .stat-label {
            color: #00ff88;
        }

        .stat-value {
            color: #ffffff;
            font-weight: bold;
        }

        #discovered-species {
            max-height: 150px;
            overflow-y: auto;
        }

        .species-item {
            background: rgba(0, 255, 136, 0.1);
            padding: 5px;
            margin: 3px 0;
            border-radius: 5px;
            font-size: 12px;
            border-left: 3px solid #00ff88;
        }

        #controls-help {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 26, 51, 0.9);
            border: 2px solid #00ffff;
            border-radius: 10px;
            padding: 15px;
            pointer-events: none;
        }

        .control-item {
            margin: 5px 0;
            font-size: 12px;
        }

        .control-key {
            display: inline-block;
            background: rgba(0, 255, 255, 0.2);
            padding: 2px 8px;
            border-radius: 3px;
            margin-right: 5px;
            font-weight: bold;
        }

        #menu {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 26, 51, 0.95);
            border: 3px solid #00ffff;
            border-radius: 15px;
            padding: 30px;
            min-width: 400px;
            pointer-events: all;
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.5);
        }

        #menu h1 {
            text-align: center;
            margin-bottom: 20px;
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
        }

        .menu-button {
            display: block;
            width: 100%;
            padding: 15px;
            margin: 10px 0;
            background: linear-gradient(135deg, #001a33, #003d66);
            border: 2px solid #00ffff;
            border-radius: 8px;
            color: #00ffff;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
            pointer-events: all;
        }

        .menu-button:hover {
            background: linear-gradient(135deg, #003d66, #006699);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
            transform: translateY(-2px);
        }

        .hidden {
            display: none !important;
        }

        #notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 26, 51, 0.95);
            border: 2px solid #00ff88;
            border-radius: 10px;
            padding: 20px;
            min-width: 300px;
            text-align: center;
            pointer-events: none;
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.5);
            animation: fadeInOut 3s ease-in-out;
        }

        @keyframes fadeInOut {
            0%, 100% { opacity: 0; }
            10%, 90% { opacity: 1; }
        }

        .discovery-title {
            font-size: 20px;
            margin-bottom: 10px;
            color: #00ff88;
        }

        #mobile-controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: none;
            pointer-events: all;
        }

        .joystick {
            width: 120px;
            height: 120px;
            background: rgba(0, 26, 51, 0.8);
            border: 2px solid #00ffff;
            border-radius: 50%;
            position: relative;
        }

        .joystick-handle {
            width: 40px;
            height: 40px;
            background: #00ffff;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        @media (max-width: 768px) {
            #mobile-controls {
                display: block;
            }

            .stat-panel {
                min-width: 150px;
                padding: 10px;
            }

            #menu {
                min-width: 90%;
            }
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0, 26, 51, 0.5);
        }

        ::-webkit-scrollbar-thumb {
            background: #00ffff;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <div id="ui">
        <div id="hud">
            <div class="stat-panel">
                <div class="stat-item">
                    <span class="stat-label">Depth:</span>
                    <span class="stat-value" id="depth">0m</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Pressure:</span>
                    <span class="stat-value" id="pressure">1 atm</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Temperature:</span>
                    <span class="stat-value" id="temperature">2Â°C</span>
                </div>
            </div>

            <div class="stat-panel">
                <div class="stat-item">
                    <span class="stat-label">Species Discovered:</span>
                    <span class="stat-value" id="species-count">0</span>
                </div>
                <div id="discovered-species"></div>
            </div>
        </div>
    </div>

    <div id="controls-help">
        <div class="control-item"><span class="control-key">WASD</span> Move Horizontally</div>
        <div class="control-item"><span class="control-key">Space</span> Ascend</div>
        <div class="control-item"><span class="control-key">Shift</span> Descend</div>
        <div class="control-item"><span class="control-key">Mouse</span> Look Around</div>
        <div class="control-item"><span class="control-key">E</span> Illuminate</div>
        <div class="control-item"><span class="control-key">ESC</span> Menu</div>
    </div>

    <div id="menu">
        <h1>ðŸŒŠ Bioluminescent Deep Ocean Trench</h1>
        <button class="menu-button" onclick="game.startGame()">Start Exploration</button>
        <button class="menu-button" onclick="game.exportData()">Export Discovery Log</button>
        <button class="menu-button" onclick="game.importData()">Import Discovery Log</button>
        <button class="menu-button" onclick="game.resetData()">Reset All Data</button>
    </div>

    <div id="mobile-controls" class="hidden">
        <div class="joystick" id="joystick">
            <div class="joystick-handle"></div>
        </div>
    </div>

    <script>
        // Simplified 3D Math Library
        class Vec3 {
            constructor(x = 0, y = 0, z = 0) {
                this.x = x;
                this.y = y;
                this.z = z;
            }

            add(v) {
                return new Vec3(this.x + v.x, this.y + v.y, this.z + v.z);
            }

            sub(v) {
                return new Vec3(this.x - v.x, this.y - v.y, this.z - v.z);
            }

            mul(s) {
                return new Vec3(this.x * s, this.y * s, this.z * s);
            }

            dot(v) {
                return this.x * v.x + this.y * v.y + this.z * v.z;
            }

            cross(v) {
                return new Vec3(
                    this.y * v.z - this.z * v.y,
                    this.z * v.x - this.x * v.z,
                    this.x * v.y - this.y * v.x
                );
            }

            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
            }

            normalize() {
                const len = this.length();
                return len > 0 ? this.mul(1 / len) : new Vec3();
            }

            clone() {
                return new Vec3(this.x, this.y, this.z);
            }
        }

        class Matrix4 {
            constructor() {
                this.elements = new Float32Array(16);
                this.identity();
            }

            identity() {
                const e = this.elements;
                e[0] = 1; e[4] = 0; e[8] = 0; e[12] = 0;
                e[1] = 0; e[5] = 1; e[9] = 0; e[13] = 0;
                e[2] = 0; e[6] = 0; e[10] = 1; e[14] = 0;
                e[3] = 0; e[7] = 0; e[11] = 0; e[15] = 1;
                return this;
            }

            perspective(fov, aspect, near, far) {
                const f = 1.0 / Math.tan(fov / 2);
                const nf = 1 / (near - far);
                const e = this.elements;

                e[0] = f / aspect; e[4] = 0; e[8] = 0; e[12] = 0;
                e[1] = 0; e[5] = f; e[9] = 0; e[13] = 0;
                e[2] = 0; e[6] = 0; e[10] = (far + near) * nf; e[14] = 2 * far * near * nf;
                e[3] = 0; e[7] = 0; e[11] = -1; e[15] = 0;

                return this;
            }

            lookAt(eye, target, up) {
                const z = eye.sub(target).normalize();
                const x = up.cross(z).normalize();
                const y = z.cross(x);
                const e = this.elements;

                e[0] = x.x; e[4] = x.y; e[8] = x.z; e[12] = -x.dot(eye);
                e[1] = y.x; e[5] = y.y; e[9] = y.z; e[13] = -y.dot(eye);
                e[2] = z.x; e[6] = z.y; e[10] = z.z; e[14] = -z.dot(eye);
                e[3] = 0; e[7] = 0; e[11] = 0; e[15] = 1;

                return this;
            }

            multiply(m) {
                const ae = this.elements;
                const be = m.elements;
                const result = new Matrix4();
                const te = result.elements;

                for (let i = 0; i < 4; i++) {
                    for (let j = 0; j < 4; j++) {
                        te[i * 4 + j] =
                            ae[i * 4 + 0] * be[0 * 4 + j] +
                            ae[i * 4 + 1] * be[1 * 4 + j] +
                            ae[i * 4 + 2] * be[2 * 4 + j] +
                            ae[i * 4 + 3] * be[3 * 4 + j];
                    }
                }

                return result;
            }
        }

        // Simplified WebGL Renderer
        class Renderer {
            constructor(canvas) {
                this.canvas = canvas;
                this.gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

                if (!this.gl) {
                    alert('WebGL not supported');
                    return;
                }

                this.initShaders();
                this.gl.enable(this.gl.DEPTH_TEST);
                this.gl.enable(this.gl.BLEND);
                this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);

                this.resize();
                window.addEventListener('resize', () => this.resize());
            }

            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
            }

            initShaders() {
                const vsSource = `
                    attribute vec3 aPosition;
                    attribute vec3 aColor;
                    attribute float aSize;

                    uniform mat4 uProjection;
                    uniform mat4 uView;
                    uniform vec3 uPosition;

                    varying vec3 vColor;

                    void main() {
                        vec3 worldPos = aPosition + uPosition;
                        gl_Position = uProjection * uView * vec4(worldPos, 1.0);
                        gl_PointSize = aSize / gl_Position.w;
                        vColor = aColor;
                    }
                `;

                const fsSource = `
                    precision mediump float;
                    varying vec3 vColor;

                    void main() {
                        float dist = length(gl_PointCoord - vec2(0.5));
                        if (dist > 0.5) discard;
                        float alpha = 1.0 - (dist * 2.0);
                        gl_FragColor = vec4(vColor, alpha);
                    }
                `;

                this.program = this.createProgram(vsSource, fsSource);
                this.gl.useProgram(this.program);

                this.attributes = {
                    position: this.gl.getAttribLocation(this.program, 'aPosition'),
                    color: this.gl.getAttribLocation(this.program, 'aColor'),
                    size: this.gl.getAttribLocation(this.program, 'aSize')
                };

                this.uniforms = {
                    projection: this.gl.getUniformLocation(this.program, 'uProjection'),
                    view: this.gl.getUniformLocation(this.program, 'uView'),
                    position: this.gl.getUniformLocation(this.program, 'uPosition')
                };
            }

            createProgram(vsSource, fsSource) {
                const vertexShader = this.compileShader(vsSource, this.gl.VERTEX_SHADER);
                const fragmentShader = this.compileShader(fsSource, this.gl.FRAGMENT_SHADER);

                const program = this.gl.createProgram();
                this.gl.attachShader(program, vertexShader);
                this.gl.attachShader(program, fragmentShader);
                this.gl.linkProgram(program);

                if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {
                    console.error('Program link error:', this.gl.getProgramInfoLog(program));
                }

                return program;
            }

            compileShader(source, type) {
                const shader = this.gl.createShader(type);
                this.gl.shaderSource(shader, source);
                this.gl.compileShader(shader);

                if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
                    console.error('Shader compile error:', this.gl.getShaderInfoLog(shader));
                    this.gl.deleteShader(shader);
                    return null;
                }

                return shader;
            }

            clear() {
                this.gl.clearColor(0.0, 0.05, 0.1, 1.0);
                this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
            }

            render(entities, camera) {
                this.clear();

                const projection = new Matrix4().perspective(
                    Math.PI / 3,
                    this.canvas.width / this.canvas.height,
                    0.1,
                    1000.0
                );

                this.gl.uniformMatrix4fv(this.uniforms.projection, false, projection.elements);
                this.gl.uniformMatrix4fv(this.uniforms.view, false, camera.getViewMatrix().elements);

                for (const entity of entities) {
                    entity.render(this);
                }
            }
        }

        // Camera with 6DOF movement
        class Camera {
            constructor() {
                this.position = new Vec3(0, -50, 0);
                this.rotation = new Vec3(0, 0, 0); // pitch, yaw, roll
                this.velocity = new Vec3(0, 0, 0);
                this.momentum = 0.95; // Underwater drag
            }

            getViewMatrix() {
                const matrix = new Matrix4();

                // Create direction vector from rotation
                const forward = new Vec3(
                    Math.sin(this.rotation.y) * Math.cos(this.rotation.x),
                    Math.sin(this.rotation.x),
                    Math.cos(this.rotation.y) * Math.cos(this.rotation.x)
                );

                const target = this.position.add(forward);
                const up = new Vec3(0, 1, 0);

                matrix.lookAt(this.position, target, up);
                return matrix;
            }

            update() {
                this.position = this.position.add(this.velocity);
                this.velocity = this.velocity.mul(this.momentum);
            }

            getForward() {
                return new Vec3(
                    Math.sin(this.rotation.y) * Math.cos(this.rotation.x),
                    Math.sin(this.rotation.x),
                    Math.cos(this.rotation.y) * Math.cos(this.rotation.x)
                );
            }

            getRight() {
                return new Vec3(
                    Math.cos(this.rotation.y),
                    0,
                    -Math.sin(this.rotation.y)
                );
            }
        }

        // Particle System for bioluminescent effects
        class ParticleSystem {
            constructor(count, color, spread) {
                this.particles = [];
                this.color = color;

                for (let i = 0; i < count; i++) {
                    this.particles.push({
                        position: new Vec3(
                            (Math.random() - 0.5) * spread,
                            (Math.random() - 0.5) * spread,
                            (Math.random() - 0.5) * spread
                        ),
                        velocity: new Vec3(
                            (Math.random() - 0.5) * 0.02,
                            (Math.random() - 0.5) * 0.02,
                            (Math.random() - 0.5) * 0.02
                        ),
                        size: Math.random() * 5 + 2,
                        life: Math.random()
                    });
                }
            }

            update() {
                for (const particle of this.particles) {
                    particle.position = particle.position.add(particle.velocity);
                    particle.life += 0.01;

                    if (particle.life > 1) {
                        particle.life = 0;
                        particle.position = new Vec3(
                            (Math.random() - 0.5) * 100,
                            (Math.random() - 0.5) * 100,
                            (Math.random() - 0.5) * 100
                        );
                    }
                }
            }

            render(renderer) {
                const positions = [];
                const colors = [];
                const sizes = [];

                for (const particle of this.particles) {
                    positions.push(particle.position.x, particle.position.y, particle.position.z);

                    const alpha = Math.sin(particle.life * Math.PI);
                    colors.push(
                        this.color[0] * alpha,
                        this.color[1] * alpha,
                        this.color[2] * alpha
                    );

                    sizes.push(particle.size);
                }

                const gl = renderer.gl;

                // Position buffer
                const posBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
                gl.enableVertexAttribArray(renderer.attributes.position);
                gl.vertexAttribPointer(renderer.attributes.position, 3, gl.FLOAT, false, 0, 0);

                // Color buffer
                const colBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, colBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
                gl.enableVertexAttribArray(renderer.attributes.color);
                gl.vertexAttribPointer(renderer.attributes.color, 3, gl.FLOAT, false, 0, 0);

                // Size buffer
                const sizeBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, sizeBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(sizes), gl.STATIC_DRAW);
                gl.enableVertexAttribArray(renderer.attributes.size);
                gl.vertexAttribPointer(renderer.attributes.size, 1, gl.FLOAT, false, 0, 0);

                gl.uniform3f(renderer.uniforms.position, 0, 0, 0);
                gl.drawArrays(gl.POINTS, 0, this.particles.length);
            }
        }

        // Bioluminescent Creature
        class Creature {
            constructor(type, position) {
                this.type = type;
                this.position = position;
                this.velocity = new Vec3(
                    (Math.random() - 0.5) * 0.1,
                    (Math.random() - 0.5) * 0.05,
                    (Math.random() - 0.5) * 0.1
                );
                this.discovered = false;
                this.glowPhase = Math.random() * Math.PI * 2;
                this.size = 5 + Math.random() * 10;

                // Generate random creature properties
                this.generateProperties();
            }

            generateProperties() {
                const types = [
                    { name: 'Giant Jellyfish', color: [0.6, 0.3, 1.0], size: 20 },
                    { name: 'Glowfish', color: [0.0, 1.0, 0.8], size: 5 },
                    { name: 'Deep Anglerfish', color: [1.0, 0.8, 0.0], size: 15 },
                    { name: 'Bioluminescent Squid', color: [0.5, 0.0, 1.0], size: 10 },
                    { name: 'Crystal Shrimp', color: [0.0, 1.0, 1.0], size: 3 },
                    { name: 'Phantom Eel', color: [0.8, 0.0, 0.8], size: 12 },
                    { name: 'Abyss Whale', color: [0.3, 0.6, 1.0], size: 30 }
                ];

                const selected = types[Math.floor(Math.random() * types.length)];
                this.name = selected.name;
                this.color = selected.color;
                this.size = selected.size + Math.random() * 5;
            }

            update(time) {
                // Swimming behavior
                this.position = this.position.add(this.velocity);

                // Boundary check - keep creatures in area
                if (Math.abs(this.position.x) > 200) this.velocity.x *= -1;
                if (Math.abs(this.position.y) > 200) this.velocity.y *= -1;
                if (Math.abs(this.position.z) > 200) this.velocity.z *= -1;

                // Random direction changes
                if (Math.random() < 0.01) {
                    this.velocity = new Vec3(
                        (Math.random() - 0.5) * 0.1,
                        (Math.random() - 0.5) * 0.05,
                        (Math.random() - 0.5) * 0.1
                    );
                }

                this.glowPhase += 0.05;
            }

            render(renderer) {
                const gl = renderer.gl;
                const glow = (Math.sin(this.glowPhase) + 1) / 2;
                const brightness = this.discovered ? 1.0 : 0.3;

                const positions = [this.position.x, this.position.y, this.position.z];
                const colors = [
                    this.color[0] * brightness * glow,
                    this.color[1] * brightness * glow,
                    this.color[2] * brightness * glow
                ];
                const sizes = [this.size];

                // Position buffer
                const posBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
                gl.enableVertexAttribArray(renderer.attributes.position);
                gl.vertexAttribPointer(renderer.attributes.position, 3, gl.FLOAT, false, 0, 0);

                // Color buffer
                const colBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, colBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
                gl.enableVertexAttribArray(renderer.attributes.color);
                gl.vertexAttribPointer(renderer.attributes.color, 3, gl.FLOAT, false, 0, 0);

                // Size buffer
                const sizeBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, sizeBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(sizes), gl.STATIC_DRAW);
                gl.enableVertexAttribArray(renderer.attributes.size);
                gl.vertexAttribPointer(renderer.attributes.size, 1, gl.FLOAT, false, 0, 0);

                gl.uniform3f(renderer.uniforms.position, 0, 0, 0);
                gl.drawArrays(gl.POINTS, 0, 1);
            }

            checkDiscovery(playerPos, illuminateActive) {
                if (this.discovered) return false;

                const distance = playerPos.sub(this.position).length();
                const discoveryRange = illuminateActive ? 30 : 15;

                if (distance < discoveryRange) {
                    this.discovered = true;
                    return true;
                }

                return false;
            }
        }

        // Ancient Ruin Structure
        class Ruin {
            constructor(position, type) {
                this.position = position;
                this.type = type;
                this.particles = [];
                this.color = [0.0, 0.8, 0.8];

                // Create structure particles
                for (let i = 0; i < 50; i++) {
                    this.particles.push({
                        offset: new Vec3(
                            (Math.random() - 0.5) * 20,
                            Math.random() * 30,
                            (Math.random() - 0.5) * 20
                        ),
                        size: Math.random() * 8 + 3
                    });
                }
            }

            render(renderer) {
                const gl = renderer.gl;
                const positions = [];
                const colors = [];
                const sizes = [];

                for (const particle of this.particles) {
                    const worldPos = this.position.add(particle.offset);
                    positions.push(worldPos.x, worldPos.y, worldPos.z);
                    colors.push(this.color[0], this.color[1], this.color[2]);
                    sizes.push(particle.size);
                }

                // Position buffer
                const posBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
                gl.enableVertexAttribArray(renderer.attributes.position);
                gl.vertexAttribPointer(renderer.attributes.position, 3, gl.FLOAT, false, 0, 0);

                // Color buffer
                const colBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, colBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
                gl.enableVertexAttribArray(renderer.attributes.color);
                gl.vertexAttribPointer(renderer.attributes.color, 3, gl.FLOAT, false, 0, 0);

                // Size buffer
                const sizeBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, sizeBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(sizes), gl.STATIC_DRAW);
                gl.enableVertexAttribArray(renderer.attributes.size);
                gl.vertexAttribPointer(renderer.attributes.size, 1, gl.FLOAT, false, 0, 0);

                gl.uniform3f(renderer.uniforms.position, 0, 0, 0);
                gl.drawArrays(gl.POINTS, 0, this.particles.length);
            }
        }

        // Main Game Class
        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.renderer = new Renderer(this.canvas);
                this.camera = new Camera();
                this.entities = [];
                this.creatures = [];
                this.ruins = [];
                this.discoveredSpecies = new Set();
                this.illuminateActive = false;
                this.isPaused = true;

                this.keys = {};
                this.mouseMovement = { x: 0, y: 0 };

                this.initControls();
                this.loadData();
            }

            initControls() {
                // Keyboard
                document.addEventListener('keydown', (e) => {
                    this.keys[e.key.toLowerCase()] = true;

                    if (e.key === 'Escape' && !this.isPaused) {
                        this.pauseGame();
                    } else if (e.key.toLowerCase() === 'e') {
                        this.illuminateActive = true;
                    }
                });

                document.addEventListener('keyup', (e) => {
                    this.keys[e.key.toLowerCase()] = false;

                    if (e.key.toLowerCase() === 'e') {
                        this.illuminateActive = false;
                    }
                });

                // Mouse
                this.canvas.addEventListener('mousemove', (e) => {
                    if (!this.isPaused) {
                        this.mouseMovement.x = e.movementX;
                        this.mouseMovement.y = e.movementY;
                    }
                });

                // Pointer lock
                this.canvas.addEventListener('click', () => {
                    if (!this.isPaused) {
                        this.canvas.requestPointerLock();
                    }
                });
            }

            startGame() {
                document.getElementById('menu').classList.add('hidden');
                this.isPaused = false;

                if (this.entities.length === 0) {
                    this.initWorld();
                }

                this.canvas.requestPointerLock();
                this.gameLoop();
            }

            pauseGame() {
                this.isPaused = true;
                document.exitPointerLock();
                document.getElementById('menu').classList.remove('hidden');
            }

            initWorld() {
                // Ambient bioluminescent particles
                this.entities.push(new ParticleSystem(500, [0.0, 1.0, 0.8], 300));
                this.entities.push(new ParticleSystem(300, [0.6, 0.3, 1.0], 200));

                // Generate creatures
                for (let i = 0; i < 30; i++) {
                    const creature = new Creature(
                        'random',
                        new Vec3(
                            (Math.random() - 0.5) * 400,
                            (Math.random() - 0.5) * 400,
                            (Math.random() - 0.5) * 400
                        )
                    );
                    this.creatures.push(creature);
                    this.entities.push(creature);
                }

                // Generate ruins
                for (let i = 0; i < 5; i++) {
                    const ruin = new Ruin(
                        new Vec3(
                            (Math.random() - 0.5) * 300,
                            -100 - Math.random() * 100,
                            (Math.random() - 0.5) * 300
                        ),
                        'temple'
                    );
                    this.ruins.push(ruin);
                    this.entities.push(ruin);
                }
            }

            update() {
                // Camera rotation from mouse
                const sensitivity = 0.002;
                this.camera.rotation.y -= this.mouseMovement.x * sensitivity;
                this.camera.rotation.x -= this.mouseMovement.y * sensitivity;
                this.camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.camera.rotation.x));

                this.mouseMovement.x = 0;
                this.mouseMovement.y = 0;

                // Camera movement - 6DOF swimming
                const speed = 0.3;
                const forward = this.camera.getForward();
                const right = this.camera.getRight();
                const up = new Vec3(0, 1, 0);

                if (this.keys['w']) {
                    this.camera.velocity = this.camera.velocity.add(forward.mul(speed));
                }
                if (this.keys['s']) {
                    this.camera.velocity = this.camera.velocity.sub(forward.mul(speed));
                }
                if (this.keys['a']) {
                    this.camera.velocity = this.camera.velocity.sub(right.mul(speed));
                }
                if (this.keys['d']) {
                    this.camera.velocity = this.camera.velocity.add(right.mul(speed));
                }
                if (this.keys[' ']) {
                    this.camera.velocity = this.camera.velocity.add(up.mul(speed));
                }
                if (this.keys['shift']) {
                    this.camera.velocity = this.camera.velocity.sub(up.mul(speed));
                }

                this.camera.update();

                // Update entities
                const time = Date.now() / 1000;
                for (const entity of this.entities) {
                    if (entity.update) {
                        entity.update(time);
                    }
                }

                // Check creature discoveries
                for (const creature of this.creatures) {
                    if (creature.checkDiscovery(this.camera.position, this.illuminateActive)) {
                        this.discoverSpecies(creature);
                    }
                }

                this.updateHUD();
            }

            discoverSpecies(creature) {
                if (!this.discoveredSpecies.has(creature.name)) {
                    this.discoveredSpecies.add(creature.name);
                    this.showNotification(`New Species Discovered: ${creature.name}`);
                    this.updateSpeciesList();
                    this.saveData();
                }
            }

            showNotification(message) {
                const notification = document.createElement('div');
                notification.id = 'notification';
                notification.innerHTML = `<div class="discovery-title">${message}</div>`;
                document.body.appendChild(notification);

                setTimeout(() => {
                    notification.remove();
                }, 3000);
            }

            updateHUD() {
                const depth = Math.abs(this.camera.position.y);
                const pressure = (depth / 10 + 1).toFixed(1);
                const temp = Math.max(2, 25 - depth / 10).toFixed(1);

                document.getElementById('depth').textContent = `${depth.toFixed(0)}m`;
                document.getElementById('pressure').textContent = `${pressure} atm`;
                document.getElementById('temperature').textContent = `${temp}Â°C`;
                document.getElementById('species-count').textContent = this.discoveredSpecies.size;
            }

            updateSpeciesList() {
                const list = document.getElementById('discovered-species');
                list.innerHTML = '';

                for (const species of this.discoveredSpecies) {
                    const item = document.createElement('div');
                    item.className = 'species-item';
                    item.textContent = species;
                    list.appendChild(item);
                }
            }

            gameLoop() {
                if (this.isPaused) return;

                this.update();
                this.renderer.render(this.entities, this.camera);

                requestAnimationFrame(() => this.gameLoop());
            }

            saveData() {
                const data = {
                    discoveredSpecies: Array.from(this.discoveredSpecies),
                    position: {
                        x: this.camera.position.x,
                        y: this.camera.position.y,
                        z: this.camera.position.z
                    },
                    version: '1.0'
                };

                localStorage.setItem('oceanTrenchData', JSON.stringify(data));
            }

            loadData() {
                const saved = localStorage.getItem('oceanTrenchData');
                if (saved) {
                    try {
                        const data = JSON.parse(saved);
                        this.discoveredSpecies = new Set(data.discoveredSpecies || []);

                        if (data.position) {
                            this.camera.position = new Vec3(
                                data.position.x,
                                data.position.y,
                                data.position.z
                            );
                        }

                        this.updateSpeciesList();
                        this.updateHUD();
                    } catch (e) {
                        console.error('Failed to load data:', e);
                    }
                }
            }

            exportData() {
                const data = {
                    discoveredSpecies: Array.from(this.discoveredSpecies),
                    position: {
                        x: this.camera.position.x,
                        y: this.camera.position.y,
                        z: this.camera.position.z
                    },
                    exportDate: new Date().toISOString(),
                    version: '1.0'
                };

                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'ocean-trench-discovery-log.json';
                a.click();
                URL.revokeObjectURL(url);
            }

            importData() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = 'application/json';

                input.onchange = (e) => {
                    const file = e.target.files[0];
                    const reader = new FileReader();

                    reader.onload = (event) => {
                        try {
                            const data = JSON.parse(event.target.result);
                            this.discoveredSpecies = new Set(data.discoveredSpecies || []);

                            if (data.position) {
                                this.camera.position = new Vec3(
                                    data.position.x,
                                    data.position.y,
                                    data.position.z
                                );
                            }

                            this.saveData();
                            this.updateSpeciesList();
                            this.updateHUD();

                            alert('Discovery log imported successfully!');
                        } catch (err) {
                            alert('Failed to import data: ' + err.message);
                        }
                    };

                    reader.readAsText(file);
                };

                input.click();
            }

            resetData() {
                if (confirm('Are you sure you want to reset all discovery data? This cannot be undone.')) {
                    localStorage.removeItem('oceanTrenchData');
                    this.discoveredSpecies.clear();
                    this.camera.position = new Vec3(0, -50, 0);
                    this.camera.rotation = new Vec3(0, 0, 0);
                    this.updateSpeciesList();
                    this.updateHUD();
                    alert('All data has been reset.');
                }
            }
        }

        // Initialize game
        const game = new Game();
    </script>
</body>
</html>