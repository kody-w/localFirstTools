<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>APEX PROTOCOL - Arena Combat</title>
    <meta name="description" content="AAA first-person arena combat game with full Xbox controller AND mouse/keyboard support">
    <!-- xbox, controller, fps, 3d, webgl, game, arena, shooter, keyboard, mouse -->
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
            font-family: 'Segoe UI', -apple-system, sans-serif;
            color: #fff;
            user-select: none;
            -webkit-user-select: none;
        }

        /* Dynamic cursor based on game state */
        body.playing { cursor: none; }
        body.menu { cursor: default; }

        #game-container {
            width: 100%;
            height: 100%;
            position: relative;
        }

        #game-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* 10-foot UI - Large, readable from couch */
        .hud {
            position: absolute;
            pointer-events: none;
            font-weight: 600;
            text-shadow: 0 2px 8px rgba(0,0,0,0.8), 0 0 20px rgba(0,0,0,0.5);
        }

        /* Health Bar - Bottom Left */
        #health-container {
            bottom: 60px;
            left: 60px;
            display: flex;
            align-items: center;
            gap: 20px;
        }

        #health-icon {
            width: 64px;
            height: 64px;
            background: linear-gradient(135deg, #ff4444, #cc0000);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 36px;
            box-shadow: 0 0 30px rgba(255,68,68,0.5);
        }

        #health-bar-outer {
            width: 350px;
            height: 32px;
            background: rgba(0,0,0,0.7);
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 16px;
            overflow: hidden;
        }

        #health-bar-inner {
            height: 100%;
            background: linear-gradient(90deg, #ff4444, #ff6666);
            border-radius: 14px;
            transition: width 0.2s ease-out;
            box-shadow: 0 0 20px rgba(255,68,68,0.6) inset;
        }

        #health-text {
            font-size: 28px;
            min-width: 100px;
        }

        /* Ammo - Bottom Right */
        #ammo-container {
            bottom: 60px;
            right: 60px;
            text-align: right;
            display: flex;
            align-items: center;
            gap: 20px;
        }

        #ammo-count {
            font-size: 72px;
            font-weight: 700;
            letter-spacing: -2px;
            background: linear-gradient(180deg, #fff, #aaa);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        #ammo-max {
            font-size: 32px;
            color: rgba(255,255,255,0.5);
        }

        #weapon-name {
            font-size: 24px;
            color: #00ffff;
            text-transform: uppercase;
            letter-spacing: 4px;
        }

        /* Score/Wave - Top */
        #top-hud {
            top: 40px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
        }

        #wave-display {
            font-size: 24px;
            color: #ffaa00;
            letter-spacing: 6px;
            text-transform: uppercase;
            margin-bottom: 8px;
        }

        #score-display {
            font-size: 48px;
            font-weight: 700;
            background: linear-gradient(180deg, #00ffff, #0088ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        #enemy-count {
            font-size: 20px;
            color: rgba(255,255,255,0.6);
            margin-top: 8px;
        }

        /* Crosshair */
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        #crosshair svg {
            filter: drop-shadow(0 0 4px rgba(0,255,255,0.8));
        }

        /* Damage Overlay */
        #damage-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: radial-gradient(ellipse at center, transparent 40%, rgba(255,0,0,0.4) 100%);
            opacity: 0;
            transition: opacity 0.1s;
        }

        /* Hit Marker */
        #hit-marker {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            opacity: 0;
        }

        /* Kill Feed */
        #kill-feed {
            position: absolute;
            top: 120px;
            right: 60px;
            text-align: right;
        }

        .kill-entry {
            font-size: 22px;
            padding: 8px 16px;
            margin-bottom: 8px;
            background: rgba(0,0,0,0.5);
            border-right: 4px solid #ff4444;
            animation: killFade 3s forwards;
        }

        @keyframes killFade {
            0%, 70% { opacity: 1; transform: translateX(0); }
            100% { opacity: 0; transform: translateX(50px); }
        }

        /* Controls Hint - Bottom Center */
        #controls-hint {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 30px;
            font-size: 14px;
            color: rgba(255,255,255,0.5);
            pointer-events: none;
        }

        #controls-hint span {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .key-hint {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 28px;
            height: 28px;
            padding: 0 8px;
            background: rgba(255,255,255,0.15);
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 6px;
            font-size: 12px;
            font-weight: 700;
        }

        /* Menu Screens */
        .menu-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a0a2a 50%, #0a1a2a 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .menu-screen.hidden {
            display: none;
        }

        #title-screen h1 {
            font-size: 120px;
            font-weight: 900;
            letter-spacing: -4px;
            background: linear-gradient(180deg, #00ffff, #0066ff, #ff00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: none;
            margin-bottom: 20px;
            animation: titlePulse 3s ease-in-out infinite;
        }

        @keyframes titlePulse {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.3); }
        }

        #title-screen h2 {
            font-size: 32px;
            color: rgba(255,255,255,0.6);
            letter-spacing: 20px;
            text-transform: uppercase;
            margin-bottom: 80px;
        }

        .menu-button {
            padding: 24px 80px;
            font-size: 28px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 6px;
            background: linear-gradient(135deg, rgba(0,255,255,0.2), rgba(0,100,255,0.2));
            border: 3px solid rgba(0,255,255,0.5);
            border-radius: 12px;
            color: #fff;
            cursor: pointer;
            margin: 12px;
            transition: all 0.2s;
            pointer-events: auto;
        }

        .menu-button:hover, .menu-button.selected {
            background: linear-gradient(135deg, rgba(0,255,255,0.4), rgba(0,100,255,0.4));
            border-color: #00ffff;
            transform: scale(1.05);
            box-shadow: 0 0 40px rgba(0,255,255,0.4);
        }

        .menu-button:focus {
            outline: none;
            border-color: #00ffff;
            box-shadow: 0 0 40px rgba(0,255,255,0.4);
        }

        /* Controller Prompt - Dynamic */
        .controller-prompt {
            position: absolute;
            bottom: 60px;
            display: flex;
            gap: 40px;
            font-size: 20px;
            color: rgba(255,255,255,0.6);
        }

        .controller-prompt span {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        /* Keyboard prompts */
        .kb-prompt { display: none; }
        .gp-prompt { display: flex; }
        body.keyboard-active .kb-prompt { display: flex; }
        body.keyboard-active .gp-prompt { display: none; }

        .xbox-button {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            font-weight: 700;
            font-size: 18px;
        }

        .xbox-a { background: #2ecc40; }
        .xbox-b { background: #ff4444; }
        .xbox-x { background: #0074d9; }
        .xbox-y { background: #ffdc00; color: #000; }
        .xbox-lb, .xbox-rb {
            background: #333;
            border-radius: 8px;
            width: auto;
            padding: 8px 16px;
        }

        .kb-key {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 40px;
            height: 40px;
            padding: 0 12px;
            background: rgba(255,255,255,0.15);
            border: 2px solid rgba(255,255,255,0.4);
            border-radius: 8px;
            font-weight: 700;
            font-size: 16px;
        }

        /* Upgrade Screen */
        #upgrade-screen {
            background: rgba(0,0,0,0.95);
        }

        #upgrade-screen h2 {
            font-size: 48px;
            margin-bottom: 60px;
            color: #00ffff;
            text-transform: uppercase;
            letter-spacing: 10px;
        }

        .upgrade-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 30px;
            max-width: 1000px;
        }

        .upgrade-card {
            background: rgba(255,255,255,0.05);
            border: 3px solid rgba(255,255,255,0.1);
            border-radius: 16px;
            padding: 30px;
            text-align: center;
            transition: all 0.2s;
            cursor: pointer;
        }

        .upgrade-card:hover, .upgrade-card.selected {
            background: rgba(0,255,255,0.1);
            border-color: #00ffff;
            transform: scale(1.05);
        }

        .upgrade-icon {
            font-size: 64px;
            margin-bottom: 16px;
        }

        .upgrade-name {
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 12px;
        }

        .upgrade-desc {
            font-size: 16px;
            color: rgba(255,255,255,0.6);
        }

        /* Pause Screen */
        #pause-screen {
            background: rgba(0,0,0,0.9);
            backdrop-filter: blur(10px);
        }

        #pause-screen h2 {
            font-size: 72px;
            margin-bottom: 60px;
            letter-spacing: 20px;
        }

        /* Loading Screen */
        #loading-screen {
            background: #000;
        }

        .loading-bar-outer {
            width: 400px;
            height: 8px;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 40px;
        }

        .loading-bar-inner {
            height: 100%;
            background: linear-gradient(90deg, #00ffff, #ff00ff);
            border-radius: 4px;
            animation: loadingProgress 2s ease-out forwards;
        }

        @keyframes loadingProgress {
            from { width: 0%; }
            to { width: 100%; }
        }

        #loading-text {
            font-size: 24px;
            color: rgba(255,255,255,0.5);
            margin-top: 20px;
            letter-spacing: 4px;
        }

        /* Wave Announcement */
        #wave-announce {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none;
            opacity: 0;
            z-index: 100;
        }

        #wave-announce.show {
            animation: waveAnnounce 3s forwards;
        }

        @keyframes waveAnnounce {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            15% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
            25% { transform: translate(-50%, -50%) scale(1); }
            75% { opacity: 1; }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
        }

        #wave-announce h2 {
            font-size: 36px;
            color: #ffaa00;
            letter-spacing: 10px;
            text-transform: uppercase;
        }

        #wave-announce h1 {
            font-size: 120px;
            font-weight: 900;
            background: linear-gradient(180deg, #fff, #00ffff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        /* Boss Warning */
        #boss-warning {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none;
            opacity: 0;
            z-index: 100;
        }

        #boss-warning.show {
            animation: bossWarn 4s forwards;
        }

        @keyframes bossWarn {
            0%, 10%, 20%, 30%, 40% { opacity: 1; }
            5%, 15%, 25%, 35% { opacity: 0.3; }
            50% { opacity: 1; }
            100% { opacity: 0; }
        }

        #boss-warning h1 {
            font-size: 80px;
            color: #ff4444;
            text-transform: uppercase;
            letter-spacing: 20px;
            text-shadow: 0 0 60px rgba(255,0,0,0.8);
        }

        /* FPS Counter */
        #fps-counter {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 16px;
            color: rgba(255,255,255,0.4);
            font-family: monospace;
        }

        /* Input Mode Indicator */
        #input-mode {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 14px;
            color: rgba(255,255,255,0.3);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #input-mode-icon {
            font-size: 20px;
        }

        /* Combo Counter */
        #combo-display {
            position: absolute;
            right: 60px;
            top: 50%;
            transform: translateY(-50%);
            text-align: right;
            opacity: 0;
            transition: opacity 0.3s;
        }

        #combo-display.active {
            opacity: 1;
        }

        #combo-count {
            font-size: 96px;
            font-weight: 900;
            background: linear-gradient(180deg, #ffaa00, #ff4400);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        #combo-label {
            font-size: 24px;
            color: #ffaa00;
            letter-spacing: 6px;
            text-transform: uppercase;
        }

        #combo-multiplier {
            font-size: 32px;
            color: #ff4400;
        }

        /* Minimap */
        #minimap {
            position: absolute;
            top: 40px;
            right: 60px;
            width: 180px;
            height: 180px;
            background: rgba(0,0,0,0.6);
            border: 3px solid rgba(255,255,255,0.2);
            border-radius: 12px;
            overflow: hidden;
        }

        #minimap-canvas {
            width: 100%;
            height: 100%;
        }

        /* Sensitivity Slider (in pause menu) */
        .sensitivity-control {
            display: flex;
            align-items: center;
            gap: 20px;
            margin: 20px 0;
            font-size: 18px;
        }

        .sensitivity-control input[type="range"] {
            width: 200px;
            height: 8px;
            -webkit-appearance: none;
            background: rgba(255,255,255,0.2);
            border-radius: 4px;
            outline: none;
        }

        .sensitivity-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: #00ffff;
            border-radius: 50%;
            cursor: pointer;
        }

        /* Settings Section */
        .settings-section {
            border-top: 1px solid rgba(255,255,255,0.2);
            margin-top: 20px;
            padding-top: 20px;
        }

        .settings-section h3 {
            font-size: 16px;
            color: #00ffff;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        /* Input Mode Toggle */
        .input-mode-toggle {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin: 15px 0;
        }

        .toggle-option {
            padding: 10px 20px;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
            opacity: 0.6;
        }

        .toggle-option:hover {
            opacity: 0.8;
            border-color: rgba(255,255,255,0.5);
        }

        .toggle-option.active {
            border-color: #00ffff;
            background: rgba(0,255,255,0.1);
            opacity: 1;
        }

        .toggle-option .toggle-icon {
            font-size: 24px;
            display: block;
            margin-bottom: 5px;
        }

        /* Auto-switch toggle */
        .auto-switch-toggle {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin: 10px 0;
            font-size: 14px;
            opacity: 0.8;
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 26px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(255,255,255,0.2);
            transition: 0.3s;
            border-radius: 26px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: #00ffff;
        }

        input:checked + .slider:before {
            transform: translateX(24px);
        }

        /* Controller sensitivity (shown when gamepad selected) */
        .controller-sensitivity {
            display: none;
        }

        body:not(.keyboard-active) .controller-sensitivity {
            display: flex;
        }

        body:not(.keyboard-active) .mouse-sensitivity {
            display: none;
        }

        body.keyboard-active .mouse-sensitivity {
            display: flex;
        }

        /* Click to Play Overlay */
        #click-to-play {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            padding: 30px 60px;
            border-radius: 16px;
            border: 2px solid #00ffff;
            text-align: center;
            z-index: 50;
            display: none;
            cursor: pointer;
        }

        #click-to-play h3 {
            font-size: 28px;
            margin-bottom: 10px;
        }

        #click-to-play p {
            color: rgba(255,255,255,0.6);
            font-size: 16px;
        }

        /* Halo-style Scope Overlay */
        #scope-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: radial-gradient(ellipse at center,
                transparent 20%,
                rgba(0, 0, 0, 0.95) 35%,
                #000 40%);
            display: none;
            pointer-events: none;
            z-index: 90;
        }

        #scope-overlay.active { display: block; }

        .scope-crosshair {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
        }

        .scope-line {
            position: absolute;
            background: rgba(255, 0, 0, 0.7);
        }

        .scope-line.h {
            width: 800px; height: 1px;
            left: -400px; top: 0;
        }

        .scope-line.v {
            width: 1px; height: 600px;
            top: -300px; left: 0;
        }

        /* Scope zoom indicator */
        .scope-zoom-indicator {
            position: absolute;
            bottom: 20%;
            right: 25%;
            color: rgba(255, 0, 0, 0.7);
            font-family: monospace;
            font-size: 14px;
        }
    </style>
</head>
<body class="menu">
    <div id="game-container">
        <canvas id="game-canvas"></canvas>

        <!-- Halo-style Scope Overlay -->
        <div id="scope-overlay">
            <div class="scope-crosshair">
                <div class="scope-line h"></div>
                <div class="scope-line v"></div>
            </div>
            <div class="scope-zoom-indicator">2X</div>
        </div>

        <!-- HUD Elements -->
        <div id="health-container" class="hud">
            <div id="health-icon">+</div>
            <div style="display: flex; flex-direction: column; gap: 8px;">
                <!-- Shield Bar (Halo-style) -->
                <div id="shield-bar-outer" style="width: 350px; height: 20px; background: rgba(0,0,0,0.7); border: 2px solid rgba(0,200,255,0.3); border-radius: 10px; overflow: hidden;">
                    <div id="shield-bar-inner" style="height: 100%; width: 100%; background: linear-gradient(90deg, #00ccff, #0099ff); border-radius: 8px; transition: width 0.2s ease-out; box-shadow: 0 0 15px rgba(0,200,255,0.6) inset;"></div>
                </div>
                <!-- Health Bar -->
                <div id="health-bar-outer">
                    <div id="health-bar-inner" style="width: 100%"></div>
                </div>
            </div>
            <div id="health-text">100</div>
        </div>

        <div id="ammo-container" class="hud">
            <div>
                <div id="weapon-name">PLASMA RIFLE</div>
                <div id="ammo-max">/ 30</div>
            </div>
            <div id="ammo-count">30</div>
        </div>

        <div id="top-hud" class="hud">
            <div id="wave-display">WAVE 1</div>
            <div id="score-display">0</div>
            <div id="enemy-count">ENEMIES: 0</div>
        </div>

        <div id="crosshair">
            <svg width="64" height="64" viewBox="0 0 64 64">
                <circle cx="32" cy="32" r="4" fill="none" stroke="#00ffff" stroke-width="2"/>
                <line x1="32" y1="12" x2="32" y2="24" stroke="#00ffff" stroke-width="2"/>
                <line x1="32" y1="40" x2="32" y2="52" stroke="#00ffff" stroke-width="2"/>
                <line x1="12" y1="32" x2="24" y2="32" stroke="#00ffff" stroke-width="2"/>
                <line x1="40" y1="32" x2="52" y2="32" stroke="#00ffff" stroke-width="2"/>
            </svg>
        </div>

        <div id="damage-overlay"></div>

        <div id="hit-marker">
            <svg width="48" height="48" viewBox="0 0 48 48">
                <line x1="12" y1="12" x2="20" y2="20" stroke="#fff" stroke-width="3"/>
                <line x1="36" y1="12" x2="28" y2="20" stroke="#fff" stroke-width="3"/>
                <line x1="12" y1="36" x2="20" y2="28" stroke="#fff" stroke-width="3"/>
                <line x1="36" y1="36" x2="28" y2="28" stroke="#fff" stroke-width="3"/>
            </svg>
        </div>

        <div id="kill-feed"></div>

        <!-- Grenade Inventory HUD (Halo-style) -->
        <div id="grenade-hud" class="hud" style="bottom: 140px; left: 60px; display: flex; gap: 15px; align-items: center;">
            <!-- Frag Grenade -->
            <div id="grenade-frag" style="display: flex; align-items: center; gap: 8px; padding: 8px 12px; background: rgba(0,0,0,0.5); border-radius: 8px; border: 2px solid rgba(100,150,100,0.5);">
                <div style="width: 24px; height: 24px; background: linear-gradient(135deg, #3a5a3a, #5a7a5a); border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 14px;">üí£</div>
                <span id="grenade-frag-count" style="font-size: 24px; font-weight: bold; color: #8a8;">2</span>
                <span style="font-size: 10px; color: rgba(255,255,255,0.5); text-transform: uppercase;">G</span>
            </div>
            <!-- Plasma Grenade -->
            <div id="grenade-plasma" style="display: flex; align-items: center; gap: 8px; padding: 8px 12px; background: rgba(0,0,0,0.5); border-radius: 8px; border: 2px solid rgba(0,150,255,0.5);">
                <div style="width: 24px; height: 24px; background: linear-gradient(135deg, #006699, #00aaff); border-radius: 50%; display: flex; align-items: center; justify-content: center; box-shadow: 0 0 10px rgba(0,150,255,0.5);"></div>
                <span id="grenade-plasma-count" style="font-size: 24px; font-weight: bold; color: #0af;">2</span>
                <span style="font-size: 10px; color: rgba(255,255,255,0.5); text-transform: uppercase;">F</span>
            </div>
        </div>

        <div id="combo-display">
            <div id="combo-count">0</div>
            <div id="combo-label">COMBO</div>
            <div id="combo-multiplier">x1.0</div>
        </div>

        <div id="minimap">
            <canvas id="minimap-canvas"></canvas>
        </div>

        <div id="controls-hint" class="hud">
            <!-- Keyboard hints -->
            <span class="kb-only"><span class="key-hint">WASD</span> Move</span>
            <span class="kb-only"><span class="key-hint">MOUSE</span> Aim</span>
            <span class="kb-only"><span class="key-hint">LMB</span> Fire</span>
            <span class="kb-only"><span class="key-hint">R</span> Reload</span>
            <span class="kb-only"><span class="key-hint">1-4</span> Weapons</span>
            <span class="kb-only"><span class="key-hint">G</span> Frag</span>
            <span class="kb-only"><span class="key-hint">F</span> Plasma</span>
            <span class="kb-only"><span class="key-hint">ESC</span> Pause</span>
        </div>

        <div id="wave-announce">
            <h2>WAVE</h2>
            <h1 id="wave-number">1</h1>
        </div>

        <div id="boss-warning">
            <h1>WARNING: BOSS INCOMING</h1>
        </div>

        <div id="fps-counter">60 FPS</div>

        <div id="input-mode">
            <span id="input-mode-icon">üéÆ</span>
            <span id="input-mode-text">Controller</span>
        </div>

        <div id="click-to-play" onclick="requestPointerLockAndResume()">
            <h3>CLICK TO CONTINUE</h3>
            <p>Click to capture mouse and resume gameplay</p>
        </div>

        <!-- Menu Screens -->
        <div id="loading-screen" class="menu-screen">
            <h1 style="font-size: 80px; letter-spacing: -2px; background: linear-gradient(180deg, #00ffff, #0066ff); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">APEX PROTOCOL</h1>
            <div class="loading-bar-outer">
                <div class="loading-bar-inner"></div>
            </div>
            <div id="loading-text">INITIALIZING COMBAT SYSTEMS...</div>
        </div>

        <div id="title-screen" class="menu-screen hidden">
            <h1>APEX</h1>
            <h2>PROTOCOL</h2>
            <button class="menu-button selected" id="btn-start" tabindex="1">START GAME</button>
            <button class="menu-button" id="btn-continue" tabindex="2">CONTINUE</button>
            <div class="controller-prompt">
                <!-- Gamepad prompts -->
                <span class="gp-prompt"><span class="xbox-button xbox-a">A</span> SELECT</span>
                <span class="gp-prompt"><span class="xbox-button xbox-b">B</span> BACK</span>
                <span class="gp-prompt">STICK TO NAVIGATE</span>
                <!-- Keyboard prompts -->
                <span class="kb-prompt"><span class="kb-key">ENTER</span> SELECT</span>
                <span class="kb-prompt"><span class="kb-key">ESC</span> BACK</span>
                <span class="kb-prompt"><span class="kb-key">‚Üë‚Üì</span> NAVIGATE</span>
            </div>
        </div>

        <div id="pause-screen" class="menu-screen hidden">
            <h2>PAUSED</h2>
            <button class="menu-button selected" id="btn-resume" tabindex="1">RESUME</button>
            <button class="menu-button" id="btn-restart" tabindex="2">RESTART</button>
            <button class="menu-button" id="btn-quit" tabindex="3">QUIT TO MENU</button>

            <div class="settings-section">
                <h3>Input Settings</h3>
                <div class="input-mode-toggle">
                    <div class="toggle-option" id="toggle-gamepad" data-mode="gamepad">
                        <span class="toggle-icon">üéÆ</span>
                        Controller
                    </div>
                    <div class="toggle-option" id="toggle-keyboard" data-mode="keyboard">
                        <span class="toggle-icon">‚å®Ô∏è</span>
                        Keyboard + Mouse
                    </div>
                </div>
                <div class="auto-switch-toggle">
                    <span>Auto-switch on input:</span>
                    <label class="switch">
                        <input type="checkbox" id="auto-switch-input" checked>
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="sensitivity-control mouse-sensitivity">
                    <span>Mouse Sensitivity:</span>
                    <input type="range" id="mouse-sensitivity" min="0.5" max="5" step="0.1" value="2">
                    <span id="mouse-sensitivity-value">2.0</span>
                </div>
                <div class="sensitivity-control controller-sensitivity">
                    <span>Controller Sensitivity:</span>
                    <input type="range" id="controller-sensitivity" min="0.5" max="5" step="0.1" value="2.5">
                    <span id="controller-sensitivity-value">2.5</span>
                </div>
            </div>

            <div class="controller-prompt">
                <span class="gp-prompt"><span class="xbox-button xbox-a">A</span> SELECT</span>
                <span class="gp-prompt"><span class="xbox-button xbox-b">B</span> RESUME</span>
                <span class="kb-prompt"><span class="kb-key">ENTER</span> SELECT</span>
                <span class="kb-prompt"><span class="kb-key">ESC</span> RESUME</span>
            </div>
        </div>

        <div id="upgrade-screen" class="menu-screen hidden">
            <h2>CHOOSE UPGRADE</h2>
            <div class="upgrade-grid" id="upgrade-grid"></div>
            <div class="controller-prompt">
                <span class="gp-prompt"><span class="xbox-button xbox-a">A</span> SELECT</span>
                <span class="gp-prompt">STICK TO CHOOSE</span>
                <span class="kb-prompt"><span class="kb-key">ENTER</span> or <span class="kb-key">1-3</span> SELECT</span>
                <span class="kb-prompt"><span class="kb-key">‚Üê‚Üí</span> CHOOSE</span>
            </div>
        </div>

        <div id="gameover-screen" class="menu-screen hidden">
            <h1 style="font-size: 96px; color: #ff4444; margin-bottom: 20px;">GAME OVER</h1>
            <div style="font-size: 36px; margin-bottom: 20px;">WAVE <span id="final-wave">1</span></div>
            <div style="font-size: 72px; color: #00ffff; margin-bottom: 60px;">SCORE: <span id="final-score">0</span></div>
            <button class="menu-button selected" id="btn-retry" tabindex="1">RETRY</button>
            <button class="menu-button" id="btn-menu" tabindex="2">MAIN MENU</button>
            <div class="controller-prompt">
                <span class="gp-prompt"><span class="xbox-button xbox-a">A</span> SELECT</span>
                <span class="kb-prompt"><span class="kb-key">ENTER</span> SELECT</span>
                <span class="kb-prompt"><span class="kb-key">‚Üë‚Üì</span> NAVIGATE</span>
            </div>
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // ASSET MANIFEST SYSTEM
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        const MANIFEST_PATH = '../../data/games/apex-protocol/manifest.json';
        const ENEMY_BASE_PATH = '../../data/games/apex-protocol/';

        const gameAssets = {
            manifest: null,
            enemies: {},
            loaded: false
        };

        function updateLoadingText(text) {
            const loadingText = document.getElementById('loading-text');
            if (loadingText) loadingText.textContent = text;
        }

        async function loadManifest() {
            try {
                updateLoadingText('LOADING ASSET MANIFEST...');
                const response = await fetch(MANIFEST_PATH);
                if (!response.ok) throw new Error('Failed to load manifest');
                gameAssets.manifest = await response.json();
                console.log('[APEX] Manifest loaded:', gameAssets.manifest.name, 'v' + gameAssets.manifest.version);

                // Load all enemy models
                const enemyKeys = Object.keys(gameAssets.manifest.enemies);
                let loadedCount = 0;

                for (const [key, enemyDef] of Object.entries(gameAssets.manifest.enemies)) {
                    try {
                        updateLoadingText(`LOADING ENEMY: ${key.toUpperCase()}...`);
                        const enemyResponse = await fetch(ENEMY_BASE_PATH + enemyDef.file);
                        if (enemyResponse.ok) {
                            const enemyData = await enemyResponse.json();
                            gameAssets.enemies[key] = {
                                ...enemyDef.stats,
                                modelData: enemyData
                            };
                            loadedCount++;
                            console.log('[APEX] Loaded enemy:', enemyData.name);
                        }
                    } catch (e) {
                        console.warn('[APEX] Failed to load enemy:', key, e);
                    }
                }

                updateLoadingText(`LOADED ${loadedCount}/${enemyKeys.length} ENEMY TYPES`);
                await new Promise(r => setTimeout(r, 300));
                updateLoadingText('INITIALIZING COMBAT SYSTEMS...');

                gameAssets.loaded = true;
                return true;
            } catch (error) {
                console.warn('[APEX] Manifest not found, using fallback enemies:', error.message);
                updateLoadingText('USING DEFAULT ENEMY CONFIGURATION...');
                return false;
            }
        }

        function buildMeshFromBodyPart(part) {
            let geometry;
            const scale = 1;

            switch (part.shape) {
                case 'box':
                    geometry = new THREE.BoxGeometry(
                        (part.width || 1) * scale,
                        (part.height || 1) * scale,
                        (part.depth || 1) * scale
                    );
                    break;
                case 'sphere':
                    geometry = new THREE.SphereGeometry((part.size || 0.5) * scale, 16, 12);
                    break;
                case 'cylinder':
                    geometry = new THREE.CylinderGeometry(
                        (part.radiusTop || 0.5) * scale,
                        (part.radiusBottom || 0.5) * scale,
                        (part.height || 1) * scale,
                        16
                    );
                    break;
                case 'cone':
                    geometry = new THREE.ConeGeometry(
                        (part.size || 0.5) * scale,
                        (part.height || 1) * scale,
                        16
                    );
                    break;
                default:
                    geometry = new THREE.BoxGeometry(1, 1, 1);
            }

            const materialConfig = {
                color: part.color || '#ffffff',
                metalness: part.metalness !== undefined ? part.metalness : 0.5,
                roughness: part.roughness !== undefined ? part.roughness : 0.5
            };

            if (part.emissive) {
                materialConfig.emissive = part.emissive;
                materialConfig.emissiveIntensity = 0.5;
            }

            if (part.transparent) {
                materialConfig.transparent = true;
                materialConfig.opacity = part.opacity !== undefined ? part.opacity : 0.5;
            }

            const material = new THREE.MeshStandardMaterial(materialConfig);
            const mesh = new THREE.Mesh(geometry, material);

            if (part.position) {
                mesh.position.set(part.position[0], part.position[1], part.position[2]);
            }

            if (part.rotation) {
                mesh.rotation.set(
                    THREE.MathUtils.degToRad(part.rotation[0] || 0),
                    THREE.MathUtils.degToRad(part.rotation[1] || 0),
                    THREE.MathUtils.degToRad(part.rotation[2] || 0)
                );
            }

            mesh.castShadow = true;
            mesh.receiveShadow = true;
            mesh.userData.partName = part.name;

            return mesh;
        }

        // ============================================================
        // MODEL BUILDER - Enhanced 3D model builder from JSON definitions
        // ============================================================
        const ModelBuilder = {
            // Build a 3D model from JSON bodyParts definition
            buildFromDefinition(definition, scale = 1) {
                const group = new THREE.Group();

                if (!definition.bodyParts) return group;

                definition.bodyParts.forEach(part => {
                    const mesh = this.createPart(part, scale);
                    if (mesh) {
                        group.add(mesh);
                    }
                });

                return group;
            },

            createPart(part, scale) {
                let geometry;
                const s = scale;
                const DEG_TO_RAD = Math.PI / 180;

                switch (part.shape) {
                    case 'box':
                        geometry = new THREE.BoxGeometry(
                            (part.width || 0.1) * s,
                            (part.height || 0.1) * s,
                            (part.depth || 0.1) * s
                        );
                        break;
                    case 'cylinder':
                        geometry = new THREE.CylinderGeometry(
                            (part.radiusTop || 0.05) * s,
                            (part.radiusBottom || 0.05) * s,
                            (part.height || 0.1) * s,
                            part.segments || 12
                        );
                        break;
                    case 'sphere':
                        geometry = new THREE.SphereGeometry(
                            (part.size || part.radius || 0.05) * s,
                            part.segments || 12,
                            part.segments || 12
                        );
                        break;
                    case 'cone':
                        geometry = new THREE.ConeGeometry(
                            (part.size || 0.05) * s,
                            (part.height || 0.1) * s,
                            part.segments || 12
                        );
                        break;
                    default:
                        return null;
                }

                // Parse color
                const color = typeof part.color === 'string' ?
                    parseInt(part.color.replace('#', '0x')) : part.color;
                const emissiveColor = part.emissive ?
                    (typeof part.emissive === 'string' ?
                        parseInt(part.emissive.replace('#', '0x')) : part.emissive) : 0x000000;

                const material = new THREE.MeshStandardMaterial({
                    color: color,
                    metalness: part.metalness !== undefined ? part.metalness : 0.5,
                    roughness: part.roughness !== undefined ? part.roughness : 0.5,
                    emissive: emissiveColor,
                    emissiveIntensity: part.emissiveIntensity || 0.5
                });

                const mesh = new THREE.Mesh(geometry, material);

                // Position
                if (part.position) {
                    mesh.position.set(
                        part.position[0] * s,
                        part.position[1] * s,
                        part.position[2] * s
                    );
                }

                // Rotation (convert degrees to radians)
                if (part.rotation) {
                    mesh.rotation.set(
                        (part.rotation[0] || 0) * DEG_TO_RAD,
                        (part.rotation[1] || 0) * DEG_TO_RAD,
                        (part.rotation[2] || 0) * DEG_TO_RAD
                    );
                }

                mesh.castShadow = true;
                mesh.receiveShadow = true;
                mesh.name = part.name;

                return mesh;
            }
        };

        // ============================================================
        // HALO WEAPON MODEL DEFINITIONS
        // Detailed weapon models for enhanced viewmodels
        // ============================================================
        const HaloWeaponModels = {
            // Enhanced BR55 with authentic Halo 2 details (trigger guard, ejection port, rails, vents)
            BR55: {
                name: "BR55 Battle Rifle",
                bodyParts: [
                    // Stock - angular Halo 2 style
                    { name: "stock", shape: "box", width: 0.06, height: 0.08, depth: 0.25,
                      color: "#2a2a2a", position: [0, 0, -0.2], metalness: 0.3, roughness: 0.7 },
                    // Stock cheek rest
                    { name: "stockCheekRest", shape: "box", width: 0.055, height: 0.025, depth: 0.12,
                      color: "#333333", position: [0, 0.04, -0.15], metalness: 0.35, roughness: 0.65 },
                    // Stock buttpad
                    { name: "stockButtpad", shape: "box", width: 0.058, height: 0.075, depth: 0.02,
                      color: "#1a1a1a", position: [0, 0, -0.33], metalness: 0.2, roughness: 0.9 },
                    // Grip with ergonomic angle
                    { name: "grip", shape: "box", width: 0.04, height: 0.1, depth: 0.06,
                      color: "#1a1a1a", position: [0, -0.06, 0], rotation: [15, 0, 0], metalness: 0.2, roughness: 0.8 },
                    // Trigger guard - authentic curved design
                    { name: "triggerGuard", shape: "box", width: 0.035, height: 0.008, depth: 0.06,
                      color: "#1a1a1a", position: [0, -0.032, 0.03], metalness: 0.5, roughness: 0.5 },
                    // Trigger
                    { name: "trigger", shape: "box", width: 0.008, height: 0.025, depth: 0.012,
                      color: "#333333", position: [0, -0.02, 0.02], rotation: [20, 0, 0], metalness: 0.6, roughness: 0.4 },
                    // Receiver - main body
                    { name: "receiver", shape: "box", width: 0.08, height: 0.1, depth: 0.35,
                      color: "#3a3a3a", position: [0, 0.03, 0.05], metalness: 0.6, roughness: 0.4 },
                    // Ejection port on right side
                    { name: "ejectionPort", shape: "box", width: 0.01, height: 0.04, depth: 0.06,
                      color: "#0a0a0a", position: [0.045, 0.05, 0.08], metalness: 0.8, roughness: 0.2 },
                    // Charging handle
                    { name: "chargingHandle", shape: "box", width: 0.02, height: 0.015, depth: 0.035,
                      color: "#333333", position: [0.045, 0.07, -0.02], metalness: 0.6, roughness: 0.4 },
                    // Forward assist
                    { name: "forwardAssist", shape: "cylinder", radiusTop: 0.012, radiusBottom: 0.012, height: 0.015,
                      color: "#2a2a2a", position: [0.045, 0.04, 0.12], rotation: [0, 0, 90], metalness: 0.5, roughness: 0.5 },
                    // Magazine with visible rounds indicator
                    { name: "magazine", shape: "box", width: 0.035, height: 0.12, depth: 0.08,
                      color: "#444444", position: [0, -0.06, 0.1], metalness: 0.5, roughness: 0.5 },
                    // Magazine release button
                    { name: "magRelease", shape: "box", width: 0.015, height: 0.02, depth: 0.015,
                      color: "#222222", position: [0.035, -0.02, 0.1], metalness: 0.6, roughness: 0.4 },
                    // Barrel shroud - vented design
                    { name: "barrelShroud", shape: "cylinder", radiusTop: 0.035, radiusBottom: 0.04, height: 0.25,
                      color: "#2a2a2a", position: [0, 0.03, 0.35], rotation: [90, 0, 0], metalness: 0.6, roughness: 0.3 },
                    // Barrel shroud vents (heat dissipation)
                    { name: "ventTop", shape: "box", width: 0.06, height: 0.008, depth: 0.15,
                      color: "#0a0a0a", position: [0, 0.065, 0.35], metalness: 0.7, roughness: 0.3 },
                    { name: "ventLeft", shape: "box", width: 0.008, height: 0.03, depth: 0.12,
                      color: "#0a0a0a", position: [-0.035, 0.03, 0.38], metalness: 0.7, roughness: 0.3 },
                    { name: "ventRight", shape: "box", width: 0.008, height: 0.03, depth: 0.12,
                      color: "#0a0a0a", position: [0.035, 0.03, 0.38], metalness: 0.7, roughness: 0.3 },
                    // Barrel
                    { name: "barrel", shape: "cylinder", radiusTop: 0.015, radiusBottom: 0.015, height: 0.15,
                      color: "#1a1a1a", position: [0, 0.03, 0.52], rotation: [90, 0, 0], metalness: 0.8, roughness: 0.2 },
                    // Picatinny rail on top
                    { name: "picatinnyRail", shape: "box", width: 0.025, height: 0.01, depth: 0.18,
                      color: "#2a2a2a", position: [0, 0.085, 0.1], metalness: 0.6, roughness: 0.4 },
                    // Rail grooves (3 notches)
                    { name: "railGroove1", shape: "box", width: 0.026, height: 0.012, depth: 0.008,
                      color: "#1a1a1a", position: [0, 0.086, 0.04], metalness: 0.5, roughness: 0.5 },
                    { name: "railGroove2", shape: "box", width: 0.026, height: 0.012, depth: 0.008,
                      color: "#1a1a1a", position: [0, 0.086, 0.1], metalness: 0.5, roughness: 0.5 },
                    { name: "railGroove3", shape: "box", width: 0.026, height: 0.012, depth: 0.008,
                      color: "#1a1a1a", position: [0, 0.086, 0.16], metalness: 0.5, roughness: 0.5 },
                    // Scope mount
                    { name: "scopeMount", shape: "box", width: 0.04, height: 0.025, depth: 0.12,
                      color: "#333333", position: [0, 0.1, 0.05], metalness: 0.5, roughness: 0.5 },
                    // Scope body - 2x optical zoom
                    { name: "scopeBody", shape: "cylinder", radiusTop: 0.025, radiusBottom: 0.025, height: 0.15,
                      color: "#222222", position: [0, 0.13, 0.05], rotation: [90, 0, 0], metalness: 0.4, roughness: 0.6 },
                    // Scope adjustment turrets
                    { name: "scopeElevation", shape: "cylinder", radiusTop: 0.012, radiusBottom: 0.012, height: 0.02,
                      color: "#2a2a2a", position: [0, 0.155, 0.05], metalness: 0.5, roughness: 0.5 },
                    { name: "scopeWindage", shape: "cylinder", radiusTop: 0.012, radiusBottom: 0.012, height: 0.02,
                      color: "#2a2a2a", position: [0.025, 0.13, 0.05], rotation: [0, 0, 90], metalness: 0.5, roughness: 0.5 },
                    // Scope lens front - blue tint
                    { name: "scopeLensFront", shape: "sphere", size: 0.02,
                      color: "#00aaff", position: [0, 0.13, 0.13], emissive: "#0066aa", metalness: 0.9, roughness: 0.1 },
                    // Scope lens back - orange for contrast
                    { name: "scopeLensBack", shape: "sphere", size: 0.015,
                      color: "#ff4400", position: [0, 0.13, -0.02], emissive: "#ff2200", metalness: 0.9, roughness: 0.1 },
                    // Muzzle brake with slots
                    { name: "muzzle", shape: "cylinder", radiusTop: 0.025, radiusBottom: 0.02, height: 0.04,
                      color: "#1a1a1a", position: [0, 0.03, 0.62], rotation: [90, 0, 0], metalness: 0.7, roughness: 0.3 },
                    // Muzzle brake slots
                    { name: "muzzleSlot1", shape: "box", width: 0.03, height: 0.01, depth: 0.01,
                      color: "#0a0a0a", position: [0, 0.045, 0.62], metalness: 0.8, roughness: 0.2 },
                    { name: "muzzleSlot2", shape: "box", width: 0.03, height: 0.01, depth: 0.01,
                      color: "#0a0a0a", position: [0, 0.015, 0.62], metalness: 0.8, roughness: 0.2 },
                    // Front sight post
                    { name: "frontSight", shape: "box", width: 0.008, height: 0.02, depth: 0.008,
                      color: "#1a1a1a", position: [0, 0.055, 0.55], metalness: 0.6, roughness: 0.4 },
                    // Ammo counter - digital display
                    { name: "ammoCounter", shape: "box", width: 0.02, height: 0.015, depth: 0.03,
                      color: "#00ff00", position: [0.04, 0.06, 0.02], emissive: "#00aa00", metalness: 0.3, roughness: 0.5 },
                    // Ammo counter frame
                    { name: "ammoCounterFrame", shape: "box", width: 0.025, height: 0.02, depth: 0.035,
                      color: "#1a1a1a", position: [0.04, 0.06, 0.02], metalness: 0.4, roughness: 0.6 }
                ]
            },

            SNIPER: {
                name: "SRS99C-S2 AM Sniper Rifle",
                bodyParts: [
                    { name: "stock", shape: "box", width: 0.05, height: 0.12, depth: 0.35,
                      color: "#1a1a1a", position: [0, -0.02, -0.35], metalness: 0.4, roughness: 0.6 },
                    { name: "grip", shape: "box", width: 0.035, height: 0.12, depth: 0.05,
                      color: "#1a1a1a", position: [0, -0.08, 0], rotation: [12, 0, 0], metalness: 0.2, roughness: 0.8 },
                    { name: "receiver", shape: "box", width: 0.08, height: 0.1, depth: 0.45,
                      color: "#2a2a2a", position: [0, 0.02, 0.1], metalness: 0.6, roughness: 0.4 },
                    { name: "magazine", shape: "box", width: 0.04, height: 0.15, depth: 0.06,
                      color: "#333333", position: [0, -0.08, 0.15], metalness: 0.5, roughness: 0.5 },
                    { name: "barrel", shape: "cylinder", radiusTop: 0.025, radiusBottom: 0.03, height: 0.6,
                      color: "#1a1a1a", position: [0, 0.02, 0.65], rotation: [90, 0, 0], metalness: 0.7, roughness: 0.3 },
                    { name: "scopeBody", shape: "cylinder", radiusTop: 0.035, radiusBottom: 0.04, height: 0.3,
                      color: "#1a1a2a", position: [0, 0.12, 0.1], rotation: [90, 0, 0], metalness: 0.5, roughness: 0.5 },
                    { name: "scopeLensFront", shape: "sphere", size: 0.03,
                      color: "#4488ff", position: [0, 0.12, 0.26], emissive: "#2266cc", metalness: 0.9, roughness: 0.1 },
                    { name: "bipodL", shape: "cylinder", radiusTop: 0.008, radiusBottom: 0.01, height: 0.12,
                      color: "#333333", position: [-0.03, -0.06, 0.4], rotation: [20, 0, -15], metalness: 0.7, roughness: 0.3 },
                    { name: "bipodR", shape: "cylinder", radiusTop: 0.008, radiusBottom: 0.01, height: 0.12,
                      color: "#333333", position: [0.03, -0.06, 0.4], rotation: [20, 0, 15], metalness: 0.7, roughness: 0.3 }
                ]
            },

            SMG: {
                name: "M7 SMG",
                bodyParts: [
                    { name: "receiver", shape: "box", width: 0.06, height: 0.12, depth: 0.2,
                      color: "#3a3a3a", position: [0, 0, 0], metalness: 0.5, roughness: 0.5 },
                    { name: "grip", shape: "box", width: 0.035, height: 0.1, depth: 0.045,
                      color: "#2a2a2a", position: [0, -0.08, -0.02], rotation: [10, 0, 0], metalness: 0.3, roughness: 0.7 },
                    { name: "magazine", shape: "box", width: 0.04, height: 0.15, depth: 0.03,
                      color: "#444444", position: [0, -0.1, 0.06], rotation: [-15, 0, 0], metalness: 0.5, roughness: 0.5 },
                    { name: "barrelShroud", shape: "cylinder", radiusTop: 0.03, radiusBottom: 0.035, height: 0.15,
                      color: "#2a2a2a", position: [0, 0, 0.18], rotation: [90, 0, 0], metalness: 0.6, roughness: 0.4 },
                    { name: "barrel", shape: "cylinder", radiusTop: 0.012, radiusBottom: 0.012, height: 0.1,
                      color: "#1a1a1a", position: [0, 0, 0.3], rotation: [90, 0, 0], metalness: 0.8, roughness: 0.2 },
                    { name: "flashlight", shape: "cylinder", radiusTop: 0.015, radiusBottom: 0.015, height: 0.06,
                      color: "#333333", position: [0, -0.04, 0.15], rotation: [90, 0, 0], metalness: 0.5, roughness: 0.5 },
                    { name: "flashlightLens", shape: "sphere", size: 0.012,
                      color: "#ffff88", position: [0, -0.04, 0.19], emissive: "#aaaa44", metalness: 0.8, roughness: 0.2 }
                ]
            },

            PISTOL: {
                name: "M6D Pistol",
                bodyParts: [
                    { name: "slide", shape: "box", width: 0.035, height: 0.045, depth: 0.18,
                      color: "#2a2a2a", position: [0, 0.025, 0.02], metalness: 0.7, roughness: 0.3 },
                    { name: "frame", shape: "box", width: 0.03, height: 0.035, depth: 0.12,
                      color: "#1a1a1a", position: [0, -0.005, -0.01], metalness: 0.5, roughness: 0.5 },
                    { name: "grip", shape: "box", width: 0.03, height: 0.1, depth: 0.04,
                      color: "#1a1a1a", position: [0, -0.06, -0.04], rotation: [15, 0, 0], metalness: 0.3, roughness: 0.8 },
                    { name: "magazine", shape: "box", width: 0.025, height: 0.08, depth: 0.03,
                      color: "#333333", position: [0, -0.06, -0.035], metalness: 0.5, roughness: 0.5 },
                    { name: "barrel", shape: "cylinder", radiusTop: 0.012, radiusBottom: 0.012, height: 0.08,
                      color: "#1a1a1a", position: [0, 0.015, 0.15], rotation: [90, 0, 0], metalness: 0.8, roughness: 0.2 },
                    { name: "scope", shape: "cylinder", radiusTop: 0.018, radiusBottom: 0.02, height: 0.08,
                      color: "#222222", position: [0, 0.065, 0.02], rotation: [90, 0, 0], metalness: 0.5, roughness: 0.5 },
                    { name: "scopeLens", shape: "sphere", size: 0.015,
                      color: "#ff4400", position: [0, 0.065, 0.065], emissive: "#ff2200", metalness: 0.9, roughness: 0.1 }
                ]
            },

            SHOTGUN: {
                name: "M90 Shotgun",
                bodyParts: [
                    { name: "stock", shape: "box", width: 0.05, height: 0.1, depth: 0.25,
                      color: "#1a1a1a", position: [0, 0, -0.25], metalness: 0.3, roughness: 0.8 },
                    { name: "receiver", shape: "box", width: 0.06, height: 0.1, depth: 0.25,
                      color: "#2a2a2a", position: [0, 0, 0.02], metalness: 0.5, roughness: 0.5 },
                    { name: "grip", shape: "box", width: 0.04, height: 0.12, depth: 0.05,
                      color: "#1a1a1a", position: [0, -0.08, -0.02], rotation: [15, 0, 0], metalness: 0.3, roughness: 0.8 },
                    { name: "barrel", shape: "cylinder", radiusTop: 0.025, radiusBottom: 0.025, height: 0.5,
                      color: "#1a1a1a", position: [0, 0.02, 0.4], rotation: [90, 0, 0], metalness: 0.7, roughness: 0.3 },
                    { name: "magTube", shape: "cylinder", radiusTop: 0.02, radiusBottom: 0.02, height: 0.35,
                      color: "#2a2a2a", position: [0, -0.03, 0.32], rotation: [90, 0, 0], metalness: 0.6, roughness: 0.4 },
                    { name: "pumpGrip", shape: "cylinder", radiusTop: 0.035, radiusBottom: 0.035, height: 0.12,
                      color: "#333333", position: [0, -0.015, 0.25], rotation: [90, 0, 0], metalness: 0.4, roughness: 0.7 },
                    { name: "frontSight", shape: "box", width: 0.01, height: 0.025, depth: 0.01,
                      color: "#ff4400", position: [0, 0.045, 0.6], emissive: "#ff2200", metalness: 0.5, roughness: 0.5 }
                ]
            },

            ROCKET: {
                name: "M41 Rocket Launcher",
                bodyParts: [
                    { name: "tubeLeft", shape: "cylinder", radiusTop: 0.06, radiusBottom: 0.06, height: 0.8,
                      color: "#3a4a3a", position: [-0.05, 0, 0.25], rotation: [90, 0, 0], metalness: 0.5, roughness: 0.6 },
                    { name: "tubeRight", shape: "cylinder", radiusTop: 0.06, radiusBottom: 0.06, height: 0.8,
                      color: "#3a4a3a", position: [0.05, 0, 0.25], rotation: [90, 0, 0], metalness: 0.5, roughness: 0.6 },
                    { name: "gripHousing", shape: "box", width: 0.08, height: 0.1, depth: 0.15,
                      color: "#2a2a2a", position: [0, -0.05, -0.05], metalness: 0.4, roughness: 0.6 },
                    { name: "grip", shape: "box", width: 0.04, height: 0.12, depth: 0.05,
                      color: "#1a1a1a", position: [0, -0.12, -0.08], rotation: [15, 0, 0], metalness: 0.3, roughness: 0.8 },
                    { name: "scopeHousing", shape: "box", width: 0.06, height: 0.08, depth: 0.12,
                      color: "#2a3a2a", position: [0, 0.08, 0.05], metalness: 0.5, roughness: 0.5 },
                    { name: "scopeScreen", shape: "box", width: 0.04, height: 0.04, depth: 0.01,
                      color: "#00ff44", position: [0, 0.1, -0.01], emissive: "#00aa22", metalness: 0.3, roughness: 0.3 }
                ]
            }
        };

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // ANIMATION QUEUE SYSTEM
        // Queue animations for players, enemies, and environment models
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        const AnimationQueue = {
            queues: new Map(), // Map<mesh, AnimationQueue[]>
            activeAnims: new Map(), // Map<mesh, CurrentAnimation[]>

            // Easing functions
            easings: {
                linear: t => t,
                easeIn: t => t * t,
                easeOut: t => 1 - (1 - t) * (1 - t),
                easeInOut: t => t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2,
                bounce: t => {
                    const n1 = 7.5625, d1 = 2.75;
                    if (t < 1 / d1) return n1 * t * t;
                    if (t < 2 / d1) return n1 * (t -= 1.5 / d1) * t + 0.75;
                    if (t < 2.5 / d1) return n1 * (t -= 2.25 / d1) * t + 0.9375;
                    return n1 * (t -= 2.625 / d1) * t + 0.984375;
                },
                elastic: t => t === 0 ? 0 : t === 1 ? 1 :
                    Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * (2 * Math.PI) / 3) + 1,
                spring: t => 1 - Math.cos(t * Math.PI * 4) * Math.exp(-t * 6)
            },

            /**
             * Add animation to queue
             * @param {THREE.Object3D} target - The mesh/group to animate
             * @param {Object} animation - Animation definition
             */
            queue(target, animation) {
                if (!this.queues.has(target)) {
                    this.queues.set(target, []);
                }
                this.queues.get(target).push({
                    ...animation,
                    startTime: null,
                    started: false
                });
            },

            /**
             * Play animation immediately (interrupts queue)
             */
            play(target, animation) {
                // Stop current animations for this property
                const currentAnims = this.activeAnims.get(target) || [];
                const filtered = currentAnims.filter(a => a.property !== animation.property);
                this.activeAnims.set(target, filtered);

                // Start new animation
                this.startAnimation(target, animation);
            },

            /**
             * Queue a sequence of animations
             */
            sequence(target, animations) {
                let totalDelay = 0;
                for (const anim of animations) {
                    this.queue(target, {
                        ...anim,
                        delay: (anim.delay || 0) + totalDelay
                    });
                    totalDelay += anim.duration || 0.5;
                }
            },

            /**
             * Animation presets for common actions
             */
            presets: {
                // Enemy hit reaction
                hitRecoil: (target, direction) => ({
                    property: 'position',
                    from: target.position.clone(),
                    to: target.position.clone().addScaledVector(direction, 0.3),
                    duration: 0.1,
                    easing: 'easeOut',
                    yoyo: true
                }),

                // Death fall
                deathFall: (target) => ({
                    property: 'rotation.x',
                    from: 0,
                    to: Math.PI / 2,
                    duration: 0.5,
                    easing: 'easeIn'
                }),

                // Attack wind-up
                attackWindup: (target, axis = 'z') => ({
                    property: `rotation.${axis}`,
                    from: 0,
                    to: -0.3,
                    duration: 0.2,
                    easing: 'easeOut'
                }),

                // Attack swing
                attackSwing: (target, axis = 'z') => ({
                    property: `rotation.${axis}`,
                    from: -0.3,
                    to: 0.5,
                    duration: 0.15,
                    easing: 'easeIn'
                }),

                // Idle bob
                idleBob: (target) => ({
                    property: 'position.y',
                    from: target.position.y,
                    to: target.position.y + 0.1,
                    duration: 1.5,
                    easing: 'easeInOut',
                    loop: true,
                    yoyo: true
                }),

                // Scale pulse
                pulse: (target, scale = 1.1) => ({
                    property: 'scale',
                    from: target.scale.clone(),
                    to: target.scale.clone().multiplyScalar(scale),
                    duration: 0.3,
                    easing: 'easeOut',
                    yoyo: true
                }),

                // Shake
                shake: (target, intensity = 0.1) => ({
                    property: 'position',
                    custom: (t) => {
                        const shake = Math.sin(t * 50) * intensity * (1 - t);
                        return new THREE.Vector3(shake, shake * 0.5, shake * 0.3);
                    },
                    duration: 0.3,
                    additive: true
                }),

                // Spin
                spin: (target, axis = 'y', rotations = 1) => ({
                    property: `rotation.${axis}`,
                    from: target.rotation[axis],
                    to: target.rotation[axis] + Math.PI * 2 * rotations,
                    duration: 0.5,
                    easing: 'easeInOut'
                }),

                // Teleport flash
                teleportFlash: (target) => [
                    { property: 'scale', from: target.scale.clone(), to: new THREE.Vector3(0.1, 2, 0.1), duration: 0.1, easing: 'easeIn' },
                    { property: 'scale', from: new THREE.Vector3(0.1, 2, 0.1), to: target.scale.clone(), duration: 0.2, easing: 'bounce' }
                ],

                // Damage flash (requires material)
                damageFlash: (target) => ({
                    property: 'material.emissiveIntensity',
                    from: 0,
                    to: 1,
                    duration: 0.1,
                    yoyo: true
                })
            },

            startAnimation(target, animation) {
                const active = {
                    target,
                    property: animation.property,
                    from: animation.from,
                    to: animation.to,
                    custom: animation.custom,
                    duration: animation.duration || 0.5,
                    easing: this.easings[animation.easing] || this.easings.linear,
                    elapsed: 0,
                    loop: animation.loop || false,
                    yoyo: animation.yoyo || false,
                    yoyoState: 0,
                    additive: animation.additive || false,
                    onComplete: animation.onComplete,
                    originalValue: this.getValue(target, animation.property)
                };

                if (!this.activeAnims.has(target)) {
                    this.activeAnims.set(target, []);
                }
                this.activeAnims.get(target).push(active);
            },

            getValue(target, property) {
                const props = property.split('.');
                let obj = target;
                for (let i = 0; i < props.length - 1; i++) {
                    obj = obj[props[i]];
                }
                const val = obj[props[props.length - 1]];
                return val?.clone ? val.clone() : val;
            },

            setValue(target, property, value) {
                const props = property.split('.');
                let obj = target;
                for (let i = 0; i < props.length - 1; i++) {
                    obj = obj[props[i]];
                }
                const finalProp = props[props.length - 1];
                if (obj[finalProp]?.copy) {
                    obj[finalProp].copy(value);
                } else {
                    obj[finalProp] = value;
                }
            },

            interpolate(from, to, t) {
                if (from instanceof THREE.Vector3) {
                    return new THREE.Vector3().lerpVectors(from, to, t);
                }
                if (from instanceof THREE.Euler) {
                    return new THREE.Euler(
                        from.x + (to.x - from.x) * t,
                        from.y + (to.y - from.y) * t,
                        from.z + (to.z - from.z) * t
                    );
                }
                if (from instanceof THREE.Color) {
                    return new THREE.Color().lerpColors(from, to, t);
                }
                return from + (to - from) * t;
            },

            update(deltaTime) {
                // Process animation queues
                for (const [target, queue] of this.queues) {
                    if (queue.length === 0) continue;

                    const anim = queue[0];
                    if (!anim.started) {
                        anim.startTime = performance.now();
                        anim.started = true;

                        // Wait for delay
                        if (anim.delay && anim.delay > 0) {
                            anim.delayRemaining = anim.delay;
                        } else {
                            this.startAnimation(target, anim);
                            queue.shift();
                        }
                    } else if (anim.delayRemaining) {
                        anim.delayRemaining -= deltaTime;
                        if (anim.delayRemaining <= 0) {
                            this.startAnimation(target, anim);
                            queue.shift();
                        }
                    }
                }

                // Update active animations
                for (const [target, anims] of this.activeAnims) {
                    for (let i = anims.length - 1; i >= 0; i--) {
                        const anim = anims[i];
                        anim.elapsed += deltaTime;

                        let t = Math.min(anim.elapsed / anim.duration, 1);

                        // Handle yoyo
                        if (anim.yoyo) {
                            if (anim.yoyoState === 1) {
                                t = 1 - t;
                            }
                        }

                        const easedT = anim.easing(t);

                        // Apply animation
                        if (anim.custom) {
                            const customValue = anim.custom(easedT);
                            if (anim.additive) {
                                const baseValue = anim.originalValue;
                                if (baseValue instanceof THREE.Vector3) {
                                    this.setValue(target, anim.property,
                                        baseValue.clone().add(customValue));
                                } else {
                                    this.setValue(target, anim.property, baseValue + customValue);
                                }
                            } else {
                                this.setValue(target, anim.property, customValue);
                            }
                        } else {
                            const value = this.interpolate(anim.from, anim.to, easedT);
                            this.setValue(target, anim.property, value);
                        }

                        // Check completion
                        if (anim.elapsed >= anim.duration) {
                            if (anim.yoyo && anim.yoyoState === 0) {
                                anim.yoyoState = 1;
                                anim.elapsed = 0;
                            } else if (anim.loop) {
                                anim.elapsed = 0;
                                anim.yoyoState = 0;
                            } else {
                                // Animation complete
                                if (anim.onComplete) anim.onComplete(target);
                                anims.splice(i, 1);
                            }
                        }
                    }

                    // Clean up empty animation arrays
                    if (anims.length === 0) {
                        this.activeAnims.delete(target);
                    }
                }
            },

            // Clear all animations for a target
            clear(target) {
                this.queues.delete(target);
                this.activeAnims.delete(target);
            },

            // Clear all animations
            clearAll() {
                this.queues.clear();
                this.activeAnims.clear();
            }
        };

        function buildEnemyFromModelData(modelData, scale = 1) {
            const group = new THREE.Group();
            const parts = {}; // Named references to body parts for animation
            const partOriginals = {}; // Store original positions/rotations for animation

            if (!modelData || !modelData.bodyParts) {
                // Fallback simple mesh
                const geometry = new THREE.BoxGeometry(1, 2, 0.5);
                const material = new THREE.MeshStandardMaterial({ color: 0xff4444 });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.y = 1;
                group.add(mesh);
                group.userData.parts = {};
                group.userData.partOriginals = {};
                return group;
            }

            const modelScale = (modelData.scale || 1) * scale;

            for (const part of modelData.bodyParts) {
                const mesh = buildMeshFromBodyPart(part);
                mesh.position.multiplyScalar(modelScale);
                mesh.scale.multiplyScalar(modelScale);
                group.add(mesh);

                // Store named reference for animation
                if (part.name) {
                    parts[part.name] = mesh;
                    partOriginals[part.name] = {
                        position: mesh.position.clone(),
                        rotation: mesh.rotation.clone(),
                        scale: mesh.scale.clone()
                    };
                }
            }

            group.userData.parts = parts;
            group.userData.partOriginals = partOriginals;
            return group;
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // GAME STATE
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        const GameState = {
            LOADING: 'loading',
            MENU: 'menu',
            PLAYING: 'playing',
            PAUSED: 'paused',
            UPGRADE: 'upgrade',
            GAMEOVER: 'gameover'
        };

        const InputMode = {
            KEYBOARD: 'keyboard',
            GAMEPAD: 'gamepad'
        };

        const state = {
            current: GameState.LOADING,
            wave: 1,
            score: 0,
            combo: 0,
            comboTimer: 0,
            highScore: parseInt(localStorage.getItem('apex_highscore') || '0'),

            player: {
                health: 100,
                maxHealth: 100,
                shields: 100,
                maxShields: 100,
                shieldRechargeDelay: 3.0,
                shieldRechargeRate: 20,
                lastDamageTime: 0,
                armor: 0,
                speed: 12,
                damage: 1,
                critChance: 0.1,
                critMultiplier: 2,
                position: new THREE.Vector3(0, 1.8, 0),
                velocity: new THREE.Vector3(),
                rotation: { x: 0, y: 0 },
                isGrounded: true,
                // Grenade inventory (Halo-style)
                grenades: {
                    frag: 2,
                    plasma: 2
                },
                maxGrenades: 4
            },

            weapons: [
                {
                    name: 'PLASMA RIFLE',
                    ammo: 30,
                    maxAmmo: 30,
                    damage: 25,
                    fireRate: 0.1,
                    reloadTime: 1.5,
                    spread: 0.02,
                    projectileSpeed: 150,
                    color: 0x00ffff,
                    sound: 'plasma'
                },
                {
                    name: 'SHOTGUN',
                    ammo: 8,
                    maxAmmo: 8,
                    damage: 15,
                    fireRate: 0.6,
                    reloadTime: 2.0,
                    spread: 0.15,
                    pellets: 8,
                    projectileSpeed: 100,
                    color: 0xffaa00,
                    sound: 'shotgun'
                },
                {
                    name: 'RAILGUN',
                    ammo: 5,
                    maxAmmo: 5,
                    damage: 150,
                    fireRate: 1.2,
                    reloadTime: 3.0,
                    spread: 0,
                    piercing: true,
                    projectileSpeed: 500,
                    color: 0xff00ff,
                    sound: 'railgun'
                },
                {
                    name: 'ROCKET LAUNCHER',
                    ammo: 3,
                    maxAmmo: 3,
                    damage: 100,
                    fireRate: 1.0,
                    reloadTime: 2.5,
                    spread: 0,
                    explosive: true,
                    explosionRadius: 8,
                    projectileSpeed: 40,
                    color: 0xff4400,
                    sound: 'rocket'
                }
            ],
            currentWeapon: 0,
            lastFire: 0,
            isReloading: false,
            reloadTimer: 0,
            scopeLevel: 0, // 0 = no scope, 1+ = zoom level (Halo-style toggle)

            enemies: [],
            projectiles: [],
            particles: [],
            pickups: [],
            weaponPickups: [], // Weapon pickups on the map

            arenaRadius: 50,
            maxCarriedWeapons: 2, // Player can only hold 2 weapons at a time

            // Input state
            inputMode: InputMode.GAMEPAD,
            preferredInputMode: localStorage.getItem('apex_input_mode') || 'gamepad',
            autoSwitchInput: localStorage.getItem('apex_auto_switch') !== 'false',
            lastInputTime: { keyboard: 0, gamepad: 0 },
            mouseSensitivity: parseFloat(localStorage.getItem('apex_mouse_sensitivity') || '2'),
            controllerSensitivity: parseFloat(localStorage.getItem('apex_controller_sensitivity') || '2.5'),

            input: {
                move: { x: 0, y: 0 },
                look: { x: 0, y: 0 },
                fire: false,
                aim: false,
                reload: false,
                jump: false,
                spacebarFire: false, // Alternative fire when ADS
                weapon1: false,
                weapon2: false,
                weapon3: false,
                weapon4: false,
                pause: false,
                select: false,
                back: false,
                menuMove: { x: 0, y: 0 }
            },

            gamepadConnected: false,
            lastGamepadInput: 0,
            menuSelection: 0,
            upgradeSelection: 0,

            upgrades: [],
            appliedUpgrades: [],

            screenShake: 0,
            damageFlash: 0,

            time: 0,
            deltaTime: 0,
            fps: 60,
            frameCount: 0,
            lastFpsUpdate: 0,

            pointerLocked: false
        };

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // THREE.JS SETUP
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        let scene, camera, renderer, composer;
        let clock = new THREE.Clock();

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // WEAPON VIEWMODEL SYSTEM (Halo-style)
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        let viewmodelScene, viewmodelCamera;
        let currentViewmodel = null;
        const viewmodelState = {
            bobTime: 0,
            bobAmount: 0,
            recoilOffset: new THREE.Vector3(),
            recoilRotation: new THREE.Euler(),
            recoilRecovery: 0.15,
            swayOffset: new THREE.Vector2(),
            targetSwayOffset: new THREE.Vector2(),
            isReloading: false,
            reloadProgress: 0,
            isSwitching: false,
            switchProgress: 0,
            basePosition: new THREE.Vector3(0.25, -0.2, -0.5),
            baseRotation: new THREE.Euler(0, 0, 0),
            // ADS (Aim Down Sights) state
            isAiming: false,
            adsProgress: 0,
            adsSpeed: 8, // How fast to transition to/from ADS
            adsPosition: new THREE.Vector3(0, -0.08, -0.35), // Centered position for ADS
            adsRotation: new THREE.Euler(0, 0, 0),
            adsFOV: 45, // Zoomed FOV when aiming
            normalFOV: 75 // Normal FOV
        };

        // Enhanced Weapon viewmodel definitions with layered components for dynamic appearance
        const WeaponViewmodels = {
            'PLASMA RIFLE': {
                build: () => {
                    const group = new THREE.Group();

                    // === LAYER 1: BASE MODEL ===
                    const base = ModelBuilder.buildFromDefinition(HaloWeaponModels.SMG);
                    base.scale.setScalar(0.9);
                    group.add(base);

                    // === LAYER 2: GLOWING ENERGY CORE ===
                    const coreGroup = new THREE.Group();
                    coreGroup.name = 'energyCore';

                    const coreGeom = new THREE.SphereGeometry(0.02, 16, 12);
                    const coreMat = new THREE.MeshBasicMaterial({
                        color: 0x00ffff,
                        transparent: true,
                        opacity: 0.8
                    });
                    const core = new THREE.Mesh(coreGeom, coreMat);
                    core.position.set(0, 0, 0.32);
                    core.name = 'corePulse';
                    coreGroup.add(core);

                    // Core glow aura
                    const auraGeom = new THREE.SphereGeometry(0.035, 12, 8);
                    const auraMat = new THREE.MeshBasicMaterial({
                        color: 0x00aaff,
                        transparent: true,
                        opacity: 0.25
                    });
                    const aura = new THREE.Mesh(auraGeom, auraMat);
                    aura.position.copy(core.position);
                    aura.name = 'coreAura';
                    coreGroup.add(aura);
                    group.add(coreGroup);

                    // === LAYER 3: ENERGY COILS (animated) ===
                    for (let side of [-1, 1]) {
                        const coilGroup = new THREE.Group();
                        coilGroup.name = `coils_${side > 0 ? 'right' : 'left'}`;

                        for (let i = 0; i < 4; i++) {
                            const coilGeom = new THREE.TorusGeometry(0.012, 0.004, 6, 12);
                            const coilMat = new THREE.MeshBasicMaterial({
                                color: 0x00ffff,
                                transparent: true,
                                opacity: 0.7 + i * 0.08
                            });
                            const coil = new THREE.Mesh(coilGeom, coilMat);
                            coil.position.set(side * 0.04, 0, 0.05 + i * 0.06);
                            coil.rotation.y = Math.PI / 2;
                            coil.name = `coil_${i}`;
                            coilGroup.add(coil);
                        }
                        group.add(coilGroup);
                    }

                    // === LAYER 4: MUZZLE HEAT EFFECT ===
                    const heatGeom = new THREE.CylinderGeometry(0.018, 0.025, 0.04, 8);
                    const heatMat = new THREE.MeshBasicMaterial({
                        color: 0x00ffff,
                        transparent: true,
                        opacity: 0.15
                    });
                    const heat = new THREE.Mesh(heatGeom, heatMat);
                    heat.rotation.x = Math.PI / 2;
                    heat.position.set(0, 0, 0.38);
                    heat.name = 'muzzleHeat';
                    group.add(heat);

                    // === LAYER 5: HOLOGRAPHIC AMMO DISPLAY ===
                    const displayGeom = new THREE.PlaneGeometry(0.025, 0.012);
                    const displayMat = new THREE.MeshBasicMaterial({
                        color: 0x00ffff,
                        transparent: true,
                        opacity: 0.9
                    });
                    const display = new THREE.Mesh(displayGeom, displayMat);
                    display.position.set(0.025, 0.065, 0.08);
                    display.rotation.y = -0.3;
                    display.name = 'ammoDisplay';
                    group.add(display);

                    // Store animation refs for later
                    group.userData.animParts = {
                        energyCore: coreGroup,
                        muzzleHeat: heat
                    };

                    return group;
                },
                // Halo-style display
                position: new THREE.Vector3(0.3, -0.2, -0.45),
                rotation: new THREE.Euler(0, Math.PI + 0.1, 0),
                scale: 1.2,
                recoilKick: 0.02,
                recoilRotation: 0.03
            },

            'SHOTGUN': {
                build: () => {
                    const group = new THREE.Group();

                    // === LAYER 1: BASE MODEL (Halo M90) ===
                    const base = ModelBuilder.buildFromDefinition(HaloWeaponModels.SHOTGUN);
                    base.scale.setScalar(0.85);
                    group.add(base);

                    // === LAYER 2: PUMP MECHANISM (animated) ===
                    const pumpGroup = new THREE.Group();
                    pumpGroup.name = 'pumpMechanism';

                    // Inner pump slide
                    const slideGeom = new THREE.CylinderGeometry(0.022, 0.022, 0.1, 8);
                    const slideMat = new THREE.MeshStandardMaterial({
                        color: 0x444444, metalness: 0.9, roughness: 0.2
                    });
                    const slide = new THREE.Mesh(slideGeom, slideMat);
                    slide.rotation.x = Math.PI / 2;
                    slide.position.set(0, -0.015, 0.25);
                    slide.name = 'pumpSlide';
                    pumpGroup.add(slide);
                    group.add(pumpGroup);

                    // === LAYER 3: SHELL EJECTION DETAIL ===
                    const portGroup = new THREE.Group();
                    portGroup.name = 'ejectionPort';

                    const portGeom = new THREE.BoxGeometry(0.025, 0.035, 0.06);
                    const portMat = new THREE.MeshStandardMaterial({
                        color: 0x1a1a1a, metalness: 0.3, roughness: 0.8
                    });
                    const port = new THREE.Mesh(portGeom, portMat);
                    port.position.set(0.04, 0.03, 0.05);
                    portGroup.add(port);

                    // Shell visible inside
                    const shellGeom = new THREE.CylinderGeometry(0.008, 0.008, 0.04, 8);
                    const shellMat = new THREE.MeshStandardMaterial({
                        color: 0xff4400, metalness: 0.5, roughness: 0.5
                    });
                    const shell = new THREE.Mesh(shellGeom, shellMat);
                    shell.rotation.z = Math.PI / 2;
                    shell.position.set(0.04, 0.015, 0.05);
                    shell.name = 'loadedShell';
                    portGroup.add(shell);
                    group.add(portGroup);

                    // === LAYER 4: MUZZLE HEAT RINGS ===
                    const muzzleGroup = new THREE.Group();
                    muzzleGroup.name = 'muzzleEffects';

                    for (let i = 0; i < 3; i++) {
                        const ringGeom = new THREE.TorusGeometry(0.025 + i * 0.005, 0.003, 8, 16);
                        const ringMat = new THREE.MeshBasicMaterial({
                            color: 0xffaa00,
                            transparent: true,
                            opacity: 0.2 - i * 0.05
                        });
                        const ring = new THREE.Mesh(ringGeom, ringMat);
                        ring.position.set(0, 0.02, 0.66 + i * 0.01);
                        ring.name = `heatRing_${i}`;
                        muzzleGroup.add(ring);
                    }
                    group.add(muzzleGroup);

                    // === LAYER 5: TACTICAL RAIL DETAIL ===
                    const railGeom = new THREE.BoxGeometry(0.025, 0.01, 0.12);
                    const railMat = new THREE.MeshStandardMaterial({
                        color: 0x222222, metalness: 0.7, roughness: 0.3
                    });
                    const rail = new THREE.Mesh(railGeom, railMat);
                    rail.position.set(0, 0.06, 0.15);
                    group.add(rail);

                    // Rail grooves
                    for (let i = 0; i < 5; i++) {
                        const grooveGeom = new THREE.BoxGeometry(0.028, 0.005, 0.008);
                        const grooveMat = new THREE.MeshStandardMaterial({
                            color: 0x1a1a1a, metalness: 0.8, roughness: 0.2
                        });
                        const groove = new THREE.Mesh(grooveGeom, grooveMat);
                        groove.position.set(0, 0.065, 0.1 + i * 0.025);
                        group.add(groove);
                    }

                    group.userData.animParts = {
                        pump: pumpGroup,
                        muzzle: muzzleGroup
                    };

                    return group;
                },
                // Halo-style display
                position: new THREE.Vector3(0.32, -0.22, -0.45),
                rotation: new THREE.Euler(0, Math.PI + 0.1, 0),
                scale: 1.2,
                recoilKick: 0.08,
                recoilRotation: 0.12
            },

            'RAILGUN': {
                build: () => {
                    const group = new THREE.Group();

                    // Main chassis
                    const chassisGeom = new THREE.BoxGeometry(0.1, 0.15, 0.6);
                    const chassisMat = new THREE.MeshStandardMaterial({
                        color: 0x333344, metalness: 0.9, roughness: 0.2
                    });
                    const chassis = new THREE.Mesh(chassisGeom, chassisMat);
                    group.add(chassis);

                    // Rail tracks (top and bottom)
                    for (let y of [-1, 1]) {
                        const railGeom = new THREE.BoxGeometry(0.015, 0.02, 0.65);
                        const railMat = new THREE.MeshStandardMaterial({
                            color: 0xff00ff, metalness: 1, roughness: 0,
                            emissive: 0xff00ff, emissiveIntensity: 0.5
                        });
                        const rail = new THREE.Mesh(railGeom, railMat);
                        rail.position.set(0, y * 0.08, -0.02);
                        group.add(rail);
                    }

                    // Capacitor banks (sides)
                    for (let x of [-1, 1]) {
                        const capGeom = new THREE.CylinderGeometry(0.025, 0.025, 0.15, 8);
                        const capMat = new THREE.MeshStandardMaterial({
                            color: 0x9900ff, metalness: 0.7, roughness: 0.3,
                            emissive: 0x9900ff, emissiveIntensity: 0.2
                        });
                        for (let i = 0; i < 2; i++) {
                            const cap = new THREE.Mesh(capGeom, capMat);
                            cap.position.set(x * 0.07, 0, -0.1 + i * 0.2);
                            cap.rotation.x = Math.PI / 2;
                            group.add(cap);
                        }
                    }

                    // Scope
                    const scopeGeom = new THREE.CylinderGeometry(0.02, 0.025, 0.12, 8);
                    const scopeMat = new THREE.MeshStandardMaterial({
                        color: 0x222233, metalness: 0.8, roughness: 0.3
                    });
                    const scope = new THREE.Mesh(scopeGeom, scopeMat);
                    scope.position.set(0, 0.1, 0.05);
                    scope.rotation.x = Math.PI / 2;
                    group.add(scope);

                    // Scope lens
                    const lensGeom = new THREE.CircleGeometry(0.018, 16);
                    const lensMat = new THREE.MeshBasicMaterial({ color: 0xff00ff });
                    const lens = new THREE.Mesh(lensGeom, lensMat);
                    lens.position.set(0, 0.1, -0.01);
                    group.add(lens);

                    // Handle
                    const gripGeom = new THREE.BoxGeometry(0.04, 0.12, 0.06);
                    const gripMat = new THREE.MeshStandardMaterial({
                        color: 0x222222, metalness: 0.3, roughness: 0.8
                    });
                    const grip = new THREE.Mesh(gripGeom, gripMat);
                    grip.position.set(0, -0.12, 0.15);
                    grip.rotation.x = -0.2;
                    group.add(grip);

                    return group;
                },
                // Halo-style display
                position: new THREE.Vector3(0.3, -0.22, -0.5),
                rotation: new THREE.Euler(0, Math.PI + 0.1, 0),
                scale: 1.1,
                recoilKick: 0.1,
                recoilRotation: 0.08
            },

            'ROCKET LAUNCHER': {
                build: () => {
                    const group = new THREE.Group();

                    // Main tube
                    const tubeGeom = new THREE.CylinderGeometry(0.06, 0.06, 0.6, 12);
                    const tubeMat = new THREE.MeshStandardMaterial({
                        color: 0x445544, metalness: 0.6, roughness: 0.4
                    });
                    const tube = new THREE.Mesh(tubeGeom, tubeMat);
                    tube.rotation.x = Math.PI / 2;
                    group.add(tube);

                    // Front sight
                    const sightGeom = new THREE.BoxGeometry(0.01, 0.04, 0.02);
                    const sightMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
                    const frontSight = new THREE.Mesh(sightGeom, sightMat);
                    frontSight.position.set(0, 0.08, -0.25);
                    group.add(frontSight);

                    // Rear sight
                    const rearSightGeom = new THREE.BoxGeometry(0.04, 0.03, 0.02);
                    const rearSight = new THREE.Mesh(rearSightGeom, sightMat);
                    rearSight.position.set(0, 0.08, 0.1);
                    group.add(rearSight);

                    // Handle/grip
                    const gripGeom = new THREE.BoxGeometry(0.04, 0.15, 0.06);
                    const gripMat = new THREE.MeshStandardMaterial({
                        color: 0x333322, metalness: 0.2, roughness: 0.9
                    });
                    const grip = new THREE.Mesh(gripGeom, gripMat);
                    grip.position.set(0, -0.1, 0.05);
                    group.add(grip);

                    // Trigger guard
                    const guardGeom = new THREE.TorusGeometry(0.03, 0.008, 8, 12, Math.PI);
                    const guard = new THREE.Mesh(guardGeom, sightMat);
                    guard.position.set(0, -0.05, 0.02);
                    guard.rotation.x = Math.PI / 2;
                    group.add(guard);

                    // Exhaust vents (back)
                    for (let i = 0; i < 4; i++) {
                        const ventGeom = new THREE.BoxGeometry(0.02, 0.015, 0.01);
                        const vent = new THREE.Mesh(ventGeom, new THREE.MeshBasicMaterial({ color: 0x222222 }));
                        const angle = (i / 4) * Math.PI * 2;
                        vent.position.set(Math.cos(angle) * 0.05, Math.sin(angle) * 0.05, 0.3);
                        group.add(vent);
                    }

                    // Loaded rocket (visible tip)
                    const rocketGeom = new THREE.ConeGeometry(0.04, 0.1, 8);
                    const rocketMat = new THREE.MeshStandardMaterial({
                        color: 0xff4400, metalness: 0.6, roughness: 0.3,
                        emissive: 0xff2200, emissiveIntensity: 0.2
                    });
                    const rocket = new THREE.Mesh(rocketGeom, rocketMat);
                    rocket.position.set(0, 0, -0.35);
                    rocket.rotation.x = -Math.PI / 2;
                    rocket.name = 'rocket';
                    group.add(rocket);

                    return group;
                },
                // Halo-style display
                position: new THREE.Vector3(0.32, -0.25, -0.45),
                rotation: new THREE.Euler(0, Math.PI + 0.1, 0),
                scale: 1.0,
                recoilKick: 0.15,
                recoilRotation: 0.1
            },

            'BR55': {
                build: () => {
                    const group = new THREE.Group();

                    // === LAYER 1: BASE MODEL (Halo BR55) ===
                    // Build at 1.5x scale like the original Halo multiplayer
                    const base = ModelBuilder.buildFromDefinition(HaloWeaponModels.BR55, 1.5);
                    group.add(base);

                    // === LAYER 2: SCOPE LENS GLOW ===
                    const lensGlow = new THREE.Mesh(
                        new THREE.SphereGeometry(0.04, 12, 8),
                        new THREE.MeshBasicMaterial({
                            color: 0x00aaff,
                            transparent: true,
                            opacity: 0.6
                        })
                    );
                    lensGlow.position.set(0, 0.195, 0.195); // Scaled position
                    lensGlow.name = 'scopeGlow';
                    group.add(lensGlow);

                    // === LAYER 3: AMMO COUNTER DISPLAY ===
                    const displayGeom = new THREE.PlaneGeometry(0.03, 0.015);
                    const displayMat = new THREE.MeshBasicMaterial({
                        color: 0x00ff88,
                        transparent: true,
                        opacity: 0.9
                    });
                    const display = new THREE.Mesh(displayGeom, displayMat);
                    display.position.set(0.06, 0.09, 0.03);
                    display.rotation.y = -0.5;
                    display.name = 'ammoDisplay';
                    group.add(display);

                    // === LAYER 4: BARREL HEAT SHIMMER ===
                    const heatGeom = new THREE.CylinderGeometry(0.027, 0.03, 0.18, 8);
                    const heatMat = new THREE.MeshBasicMaterial({
                        color: 0xffaa44,
                        transparent: true,
                        opacity: 0.08
                    });
                    const heat = new THREE.Mesh(heatGeom, heatMat);
                    heat.rotation.x = Math.PI / 2;
                    heat.position.set(0, 0.045, 0.87);
                    heat.name = 'barrelHeat';
                    group.add(heat);

                    // === LAYER 5: CHARGING HANDLE DETAIL ===
                    const handleGeom = new THREE.BoxGeometry(0.022, 0.03, 0.06);
                    const handleMat = new THREE.MeshStandardMaterial({
                        color: 0x222222,
                        metalness: 0.8,
                        roughness: 0.3
                    });
                    const handle = new THREE.Mesh(handleGeom, handleMat);
                    handle.position.set(0.075, 0.075, 0.03);
                    handle.name = 'chargingHandle';
                    group.add(handle);

                    group.userData.animParts = {
                        scopeGlow: lensGlow,
                        barrelHeat: heat,
                        chargingHandle: handle
                    };

                    return group;
                },
                // Halo multiplayer viewmodel settings - adjusted for APEX viewmodel system
                position: new THREE.Vector3(0.3, -0.18, -0.45),
                rotation: new THREE.Euler(0, Math.PI + 0.1, 0), // 180¬∞ + slight angle toward player
                scale: 1.0, // Model already built at 1.5x
                recoilKick: 0.04,
                recoilRotation: 0.05
            },

            'SMG': {
                build: () => {
                    const group = new THREE.Group();

                    // === LAYER 1: BASE MODEL (Halo SMG) ===
                    // Build at 1.5x scale like original Halo multiplayer
                    const base = ModelBuilder.buildFromDefinition(HaloWeaponModels.SMG, 1.5);
                    group.add(base);

                    // === LAYER 2: FLASHLIGHT GLOW ===
                    const flashlightGlow = new THREE.Mesh(
                        new THREE.SphereGeometry(0.015, 8, 6),
                        new THREE.MeshBasicMaterial({
                            color: 0xffff88,
                            transparent: true,
                            opacity: 0.5
                        })
                    );
                    flashlightGlow.position.set(0, -0.04, 0.2);
                    flashlightGlow.name = 'flashlightGlow';
                    group.add(flashlightGlow);

                    // === LAYER 3: MUZZLE FLASH POINT ===
                    const muzzlePoint = new THREE.Mesh(
                        new THREE.SphereGeometry(0.01, 6, 4),
                        new THREE.MeshBasicMaterial({
                            color: 0xffaa00,
                            transparent: true,
                            opacity: 0
                        })
                    );
                    muzzlePoint.position.set(0, 0, 0.35);
                    muzzlePoint.name = 'muzzleFlash';
                    group.add(muzzlePoint);

                    group.userData.animParts = {
                        flashlight: flashlightGlow,
                        muzzle: muzzlePoint
                    };

                    return group;
                },
                // Halo-style SMG display
                position: new THREE.Vector3(0.28, -0.2, -0.42),
                rotation: new THREE.Euler(0, Math.PI + 0.1, 0),
                scale: 1.0, // Model already built at 1.5x
                recoilKick: 0.015,
                recoilRotation: 0.02
            }
        };

        function initViewmodelSystem() {
            // Create separate scene for weapon viewmodel (renders on top)
            viewmodelScene = new THREE.Scene();

            // Viewmodel camera with narrower FOV for weapon
            viewmodelCamera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.01, 10);
            viewmodelCamera.position.set(0, 0, 0);

            // Lighting for viewmodel
            const vmAmbient = new THREE.AmbientLight(0xffffff, 0.6);
            viewmodelScene.add(vmAmbient);

            const vmLight = new THREE.DirectionalLight(0xffffff, 0.8);
            vmLight.position.set(1, 1, 1);
            viewmodelScene.add(vmLight);

            const vmRimLight = new THREE.DirectionalLight(0x00ffff, 0.3);
            vmRimLight.position.set(-1, 0.5, -1);
            viewmodelScene.add(vmRimLight);

            // Build initial weapon viewmodel
            switchViewmodel(state.weapons[state.currentWeapon].name);
        }

        function switchViewmodel(weaponName) {
            // Remove current viewmodel
            if (currentViewmodel) {
                viewmodelScene.remove(currentViewmodel);
            }

            // Get viewmodel definition
            const vmDef = WeaponViewmodels[weaponName];
            if (!vmDef) return;

            // Build new viewmodel
            currentViewmodel = vmDef.build();
            viewmodelState.basePosition.copy(vmDef.position);
            viewmodelState.baseRotation.copy(vmDef.rotation);

            // Apply scale if defined
            const scale = vmDef.scale || 1;
            currentViewmodel.scale.set(scale, scale, scale);

            // Position viewmodel
            currentViewmodel.position.copy(vmDef.position);
            currentViewmodel.rotation.copy(vmDef.rotation);

            viewmodelScene.add(currentViewmodel);

            // Start switch animation
            viewmodelState.isSwitching = true;
            viewmodelState.switchProgress = 0;
        }

        function updateViewmodel(deltaTime) {
            if (!currentViewmodel) return;

            const weapon = state.weapons[state.currentWeapon];
            const vmDef = WeaponViewmodels[weapon.name];
            if (!vmDef) return;

            // === SCOPE ZOOM UPDATE (Halo-style) ===
            const isScoped = state.scopeLevel > 0;
            const scopeZoom = weapon.scopeZoom || 1;

            // Update camera FOV for scope zoom
            if (camera && isScoped) {
                const targetFOV = 75 / scopeZoom;
                camera.fov += (targetFOV - camera.fov) * deltaTime * 10;
                camera.updateProjectionMatrix();
            }

            // Track aiming state for reduced sway
            viewmodelState.isAiming = isScoped;

            // === WEAPON BOB (walking animation) ===
            const isMoving = state.input.moveForward || state.input.moveBackward ||
                            state.input.moveLeft || state.input.moveRight;

            if (isMoving && state.current === GameState.PLAYING) {
                viewmodelState.bobTime += deltaTime * 10;
                viewmodelState.bobAmount = Math.min(viewmodelState.bobAmount + deltaTime * 5, 1);
            } else {
                viewmodelState.bobAmount = Math.max(viewmodelState.bobAmount - deltaTime * 3, 0);
            }

            // Reduce bob when scoped (viewmodel hidden anyway, but for consistency)
            const scopeReducer = isScoped ? 0.1 : 1.0;
            const bobX = Math.sin(viewmodelState.bobTime) * 0.008 * viewmodelState.bobAmount * scopeReducer;
            const bobY = Math.abs(Math.cos(viewmodelState.bobTime * 2)) * 0.006 * viewmodelState.bobAmount * scopeReducer;

            // === WEAPON SWAY (mouse movement) ===
            // Reduce sway intensity when scoped
            const swayMultiplier = 0.0003 * scopeReducer;
            viewmodelState.targetSwayOffset.x = -mouseMovement.x * swayMultiplier;
            viewmodelState.targetSwayOffset.y = -mouseMovement.y * swayMultiplier;
            viewmodelState.swayOffset.x += (viewmodelState.targetSwayOffset.x - viewmodelState.swayOffset.x) * 0.1;
            viewmodelState.swayOffset.y += (viewmodelState.targetSwayOffset.y - viewmodelState.swayOffset.y) * 0.1;
            viewmodelState.swayOffset.x *= 0.95;
            viewmodelState.swayOffset.y *= 0.95;

            // === RECOIL RECOVERY ===
            viewmodelState.recoilOffset.multiplyScalar(1 - viewmodelState.recoilRecovery);
            viewmodelState.recoilRotation.x *= (1 - viewmodelState.recoilRecovery);
            viewmodelState.recoilRotation.y *= (1 - viewmodelState.recoilRecovery);

            // === RELOAD ANIMATION ===
            let reloadOffset = new THREE.Vector3();
            let reloadRotation = new THREE.Euler();

            if (state.isReloading) {
                const reloadPhase = (state.reloadTimer / weapon.reloadTime);
                // Phase 1: Lower weapon
                if (reloadPhase > 0.7) {
                    const t = (reloadPhase - 0.7) / 0.3;
                    reloadOffset.y = -0.15 * t;
                    reloadRotation.x = 0.5 * t;
                }
                // Phase 2: Hold low (mag change)
                else if (reloadPhase > 0.3) {
                    reloadOffset.y = -0.15;
                    reloadRotation.x = 0.5;
                }
                // Phase 3: Raise weapon
                else {
                    const t = reloadPhase / 0.3;
                    reloadOffset.y = -0.15 * t;
                    reloadRotation.x = 0.5 * t;
                }
            }

            // === WEAPON SWITCH ANIMATION ===
            let switchOffset = new THREE.Vector3();

            if (viewmodelState.isSwitching) {
                viewmodelState.switchProgress += deltaTime * 4;
                if (viewmodelState.switchProgress >= 1) {
                    viewmodelState.isSwitching = false;
                    viewmodelState.switchProgress = 1;
                }
                // Smooth ease-out for weapon raise
                const t = 1 - Math.pow(1 - viewmodelState.switchProgress, 3);
                switchOffset.y = -0.3 * (1 - t);
            }

            // === APPLY ALL TRANSFORMS ===
            // Use base position (viewmodel is hidden when scoped, so no ADS interpolation needed)
            currentViewmodel.position.copy(viewmodelState.basePosition);
            currentViewmodel.position.x += bobX + viewmodelState.swayOffset.x + viewmodelState.recoilOffset.x;
            currentViewmodel.position.y += bobY + viewmodelState.swayOffset.y + viewmodelState.recoilOffset.y + reloadOffset.y + switchOffset.y;
            currentViewmodel.position.z += viewmodelState.recoilOffset.z;

            // Apply rotation with recoil
            currentViewmodel.rotation.set(
                viewmodelState.baseRotation.x + viewmodelState.recoilRotation.x + reloadRotation.x,
                viewmodelState.baseRotation.y + viewmodelState.recoilRotation.y,
                viewmodelState.baseRotation.z
            );
        }

        function applyViewmodelRecoil() {
            const weapon = state.weapons[state.currentWeapon];
            const vmDef = WeaponViewmodels[weapon.name];
            if (!vmDef) return;

            // Apply recoil kick
            viewmodelState.recoilOffset.z = vmDef.recoilKick;
            viewmodelState.recoilOffset.y = vmDef.recoilKick * 0.3;
            viewmodelState.recoilRotation.x = -vmDef.recoilRotation;
            viewmodelState.recoilRotation.y = (Math.random() - 0.5) * vmDef.recoilRotation * 0.3;
        }

        function renderViewmodel() {
            if (!viewmodelScene || !viewmodelCamera) return;

            // Disable auto-clear so we don't wipe the main scene
            renderer.autoClear = false;

            // Clear only depth buffer so viewmodel renders on top
            renderer.clearDepth();

            // Render viewmodel scene on top of main scene
            renderer.render(viewmodelScene, viewmodelCamera);

            // Re-enable auto-clear for next frame
            renderer.autoClear = true;
        }

        const canvas = document.getElementById('game-canvas');
        const minimapCanvas = document.getElementById('minimap-canvas');
        const minimapCtx = minimapCanvas.getContext('2d');

        function initThreeJS() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050510);
            scene.fog = new THREE.FogExp2(0x050510, 0.015);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.copy(state.player.position);

            renderer = new THREE.WebGLRenderer({
                canvas: canvas,
                antialias: true,
                powerPreference: 'high-performance'
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;

            composer = new EffectComposer(renderer);
            composer.addPass(new RenderPass(scene, camera));

            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                0.8, 0.4, 0.85
            );
            composer.addPass(bloomPass);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404060, 0.4);
            scene.add(ambientLight);

            const mainLight = new THREE.DirectionalLight(0xffffff, 1);
            mainLight.position.set(20, 40, 20);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.width = 2048;
            mainLight.shadow.mapSize.height = 2048;
            mainLight.shadow.camera.near = 1;
            mainLight.shadow.camera.far = 100;
            mainLight.shadow.camera.left = -60;
            mainLight.shadow.camera.right = 60;
            mainLight.shadow.camera.top = 60;
            mainLight.shadow.camera.bottom = -60;
            scene.add(mainLight);

            const rimLight1 = new THREE.DirectionalLight(0x00ffff, 0.5);
            rimLight1.position.set(-30, 20, -30);
            scene.add(rimLight1);

            const rimLight2 = new THREE.DirectionalLight(0xff00ff, 0.3);
            rimLight2.position.set(30, 15, -30);
            scene.add(rimLight2);

            createArena();

            minimapCanvas.width = 180;
            minimapCanvas.height = 180;

            window.addEventListener('resize', onResize);
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);

            // Update viewmodel camera
            if (viewmodelCamera) {
                viewmodelCamera.aspect = window.innerWidth / window.innerHeight;
                viewmodelCamera.updateProjectionMatrix();
            }
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // ARENA CREATION
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function createArena() {
            const groundGeometry = new THREE.CircleGeometry(state.arenaRadius, 64);
            const groundMaterial = new THREE.MeshStandardMaterial({
                color: 0x3a3a5e,
                metalness: 0.6,
                roughness: 0.5,
                emissive: 0x101020,
                emissiveIntensity: 0.3
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            const gridHelper = new THREE.GridHelper(state.arenaRadius * 2, 40, 0x00ffff88, 0x00ffff44);
            gridHelper.position.y = 0.01;
            scene.add(gridHelper);

            const wallGeometry = new THREE.CylinderGeometry(
                state.arenaRadius, state.arenaRadius, 20, 64, 1, true
            );
            const wallMaterial = new THREE.MeshStandardMaterial({
                color: 0x2a2a4a,
                metalness: 0.7,
                roughness: 0.3,
                side: THREE.BackSide,
                transparent: true,
                opacity: 0.9,
                emissive: 0x101030,
                emissiveIntensity: 0.2
            });
            const walls = new THREE.Mesh(wallGeometry, wallMaterial);
            walls.position.y = 10;
            scene.add(walls);

            const ringGeometry = new THREE.TorusGeometry(state.arenaRadius, 0.3, 8, 64);
            const ringMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.8
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.rotation.x = Math.PI / 2;
            ring.position.y = 0.1;
            scene.add(ring);

            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const x = Math.cos(angle) * (state.arenaRadius - 5);
                const z = Math.sin(angle) * (state.arenaRadius - 5);
                createPillar(x, z);
            }

            const platformGeometry = new THREE.CylinderGeometry(8, 8, 0.5, 32);
            const platformMaterial = new THREE.MeshStandardMaterial({
                color: 0x2a2a4e,
                metalness: 0.9,
                roughness: 0.3,
                emissive: 0x00ffff,
                emissiveIntensity: 0.1
            });
            const platform = new THREE.Mesh(platformGeometry, platformMaterial);
            platform.position.y = 0.25;
            platform.receiveShadow = true;
            scene.add(platform);

            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2 + Math.PI / 6;
                const radius = 20 + Math.random() * 10;
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                createCover(x, z);
            }
        }

        function createPillar(x, z) {
            const pillarGroup = new THREE.Group();

            const pillarGeometry = new THREE.CylinderGeometry(1.5, 2, 15, 8);
            const pillarMaterial = new THREE.MeshStandardMaterial({
                color: 0x4a4a7e,
                metalness: 0.7,
                roughness: 0.3,
                emissive: 0x101030,
                emissiveIntensity: 0.2
            });
            const pillar = new THREE.Mesh(pillarGeometry, pillarMaterial);
            pillar.position.y = 7.5;
            pillar.castShadow = true;
            pillarGroup.add(pillar);

            const glowRing = new THREE.Mesh(
                new THREE.TorusGeometry(1.8, 0.2, 8, 16),
                new THREE.MeshBasicMaterial({ color: 0x00ffff })
            );
            glowRing.rotation.x = Math.PI / 2;
            glowRing.position.y = 12;
            pillarGroup.add(glowRing);

            const light = new THREE.PointLight(0x00ffff, 3, 25);
            light.position.y = 12;
            pillarGroup.add(light);

            pillarGroup.position.set(x, 0, z);
            scene.add(pillarGroup);
        }

        function createCover(x, z) {
            const coverGeometry = new THREE.BoxGeometry(
                2 + Math.random() * 2,
                2 + Math.random() * 2,
                2 + Math.random() * 2
            );
            const coverMaterial = new THREE.MeshStandardMaterial({
                color: 0x5a5a8e,
                metalness: 0.6,
                roughness: 0.4,
                emissive: 0x151525,
                emissiveIntensity: 0.2
            });
            const cover = new THREE.Mesh(coverGeometry, coverMaterial);
            cover.position.set(x, coverGeometry.parameters.height / 2, z);
            cover.rotation.y = Math.random() * Math.PI;
            cover.castShadow = true;
            cover.receiveShadow = true;
            cover.userData.isCover = true;
            scene.add(cover);
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // ENEMY SYSTEM
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        // Fallback enemy types (used if manifest fails to load)
        const FallbackEnemyTypes = {
            GRUNT: { name: 'Grunt', health: 50, damage: 10, speed: 6, score: 100, color: 0xff4444, size: 1, attackRange: 3, attackRate: 1 },
            RUSHER: { name: 'Rusher', health: 30, damage: 15, speed: 12, score: 150, color: 0xff8800, size: 0.8, attackRange: 2, attackRate: 0.5 },
            TANK: { name: 'Tank', health: 200, damage: 25, speed: 3, score: 300, color: 0x8844ff, size: 1.5, attackRange: 4, attackRate: 2 },
            SNIPER: { name: 'Sniper', health: 40, damage: 30, speed: 4, score: 200, color: 0x44ff44, size: 1, attackRange: 40, attackRate: 2.5, ranged: true },
            BOSS: { name: 'OVERLORD', health: 1000, damage: 40, speed: 5, score: 2000, color: 0xff00ff, size: 3, attackRange: 6, attackRate: 1.5, isBoss: true }
        };

        // Maps manifest enemy keys to game enemy types
        const EnemyTypeMapping = {
            grunt: 'GRUNT',
            stalker: 'RUSHER',
            commander: 'SNIPER',
            tank: 'TANK',
            boss_warden: 'BOSS'
        };

        // Populated from manifest or fallback
        let EnemyTypes = { ...FallbackEnemyTypes };

        function initEnemyTypesFromManifest() {
            if (!gameAssets.loaded || !gameAssets.enemies) return;

            // Map manifest enemies to game enemy types
            for (const [manifestKey, gameKey] of Object.entries(EnemyTypeMapping)) {
                if (gameAssets.enemies[manifestKey]) {
                    const manifestEnemy = gameAssets.enemies[manifestKey];
                    const attackRange = manifestEnemy.attackRange || FallbackEnemyTypes[gameKey].attackRange;
                    EnemyTypes[gameKey] = {
                        name: manifestEnemy.modelData?.name || gameKey,
                        health: manifestEnemy.health || FallbackEnemyTypes[gameKey].health,
                        damage: manifestEnemy.damage || FallbackEnemyTypes[gameKey].damage,
                        speed: manifestEnemy.speed || FallbackEnemyTypes[gameKey].speed,
                        score: manifestEnemy.points || FallbackEnemyTypes[gameKey].score,
                        attackRange: attackRange,
                        attackRate: manifestEnemy.fireRate || FallbackEnemyTypes[gameKey].attackRate,
                        size: manifestEnemy.modelData?.scale || FallbackEnemyTypes[gameKey].size,
                        color: FallbackEnemyTypes[gameKey].color,
                        modelData: manifestEnemy.modelData,
                        ranged: attackRange >= 8, // Enemies with attackRange >= 8 shoot projectiles
                        isBoss: gameKey === 'BOSS',
                        shield: manifestEnemy.shield || 0
                    };
                    console.log(`[APEX] Configured ${gameKey} from manifest:`, EnemyTypes[gameKey].name);
                }
            }
        }

        function createFallbackEnemyMesh(config) {
            const group = new THREE.Group();
            const s = config.size;

            // Store animated parts for later updates
            group.userData.animParts = {};

            // Determine enemy archetype based on config properties
            const isRusher = config.speed >= 10;
            const isTank = config.health >= 150 && !config.isBoss;
            const isSniper = config.ranged;
            const isBoss = config.isBoss;

            // === LAYER 1: INNER SKELETON/FRAME ===
            const frameGroup = new THREE.Group();
            frameGroup.name = 'frame';
            const frameMat = new THREE.MeshStandardMaterial({
                color: 0x111111, metalness: 0.9, roughness: 0.1
            });

            // Spine
            const spineGeom = new THREE.CylinderGeometry(s * 0.08, s * 0.1, s * 1.5, 6);
            const spine = new THREE.Mesh(spineGeom, frameMat);
            spine.position.y = s * 0.75;
            frameGroup.add(spine);
            group.add(frameGroup);

            // === LAYER 2: BODY CORE ===
            let bodyGeom, bodyHeight;
            if (isRusher) {
                bodyGeom = new THREE.ConeGeometry(s * 0.5, s * 1.8, 6);
                bodyHeight = s * 0.9;
            } else if (isTank) {
                bodyGeom = new THREE.BoxGeometry(s * 1.6, s * 1.8, s * 1.2);
                bodyHeight = s * 0.9;
            } else if (isSniper) {
                bodyGeom = new THREE.BoxGeometry(s * 0.8, s * 2.4, s * 0.5);
                bodyHeight = s * 1.2;
            } else {
                bodyGeom = new THREE.BoxGeometry(s * 1.2, s * 2, s * 0.8);
                bodyHeight = s;
            }

            const bodyMat = new THREE.MeshStandardMaterial({
                color: config.color,
                metalness: isTank ? 0.8 : 0.6,
                roughness: isTank ? 0.2 : 0.3,
                emissive: config.color,
                emissiveIntensity: 0.2
            });
            const body = new THREE.Mesh(bodyGeom, bodyMat);
            body.position.y = bodyHeight;
            body.castShadow = true;
            body.name = 'body';
            group.add(body);
            group.userData.animParts.body = body;

            // === LAYER 3: ENERGY CORE (glowing internal) ===
            const coreGroup = new THREE.Group();
            coreGroup.name = 'energyCore';

            const coreGeom = new THREE.SphereGeometry(s * 0.2, 12, 8);
            const coreMat = new THREE.MeshBasicMaterial({
                color: config.color,
                transparent: true,
                opacity: 0.9
            });
            const core = new THREE.Mesh(coreGeom, coreMat);
            core.position.y = bodyHeight;
            core.name = 'corePulse';
            coreGroup.add(core);

            // Core glow aura
            const coreAuraGeom = new THREE.SphereGeometry(s * 0.35, 8, 6);
            const coreAuraMat = new THREE.MeshBasicMaterial({
                color: config.color,
                transparent: true,
                opacity: 0.2
            });
            const coreAura = new THREE.Mesh(coreAuraGeom, coreAuraMat);
            coreAura.position.y = bodyHeight;
            coreAura.name = 'coreAura';
            coreGroup.add(coreAura);
            group.add(coreGroup);
            group.userData.animParts.energyCore = coreGroup;

            // === LAYER 4: HEAD WITH ANIMATED PARTS ===
            const headGroup = new THREE.Group();
            headGroup.name = 'headGroup';
            headGroup.position.y = bodyHeight + s * 1.2;

            let headGeom;
            if (isRusher) {
                headGeom = new THREE.ConeGeometry(s * 0.3, s * 0.6, 4);
            } else if (isTank) {
                headGeom = new THREE.BoxGeometry(s * 0.6, s * 0.5, s * 0.6);
            } else if (isSniper) {
                headGeom = new THREE.CylinderGeometry(s * 0.25, s * 0.3, s * 0.5, 8);
            } else {
                headGeom = new THREE.SphereGeometry(s * 0.4, 16, 12);
            }

            const headMat = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                metalness: 0.9,
                roughness: 0.1,
                emissive: config.color,
                emissiveIntensity: 0.5
            });
            const head = new THREE.Mesh(headGeom, headMat);
            head.name = 'head';
            if (isRusher) head.rotation.x = Math.PI;
            headGroup.add(head);
            group.add(headGroup);
            group.userData.animParts.headGroup = headGroup;

            // === LAYER 5: EYES WITH GLOW EFFECT ===
            const eyeGroup = new THREE.Group();
            eyeGroup.name = 'eyeGroup';

            const eyeGeom = new THREE.SphereGeometry(s * 0.12, 8, 6);
            const eyeColor = isSniper ? 0x00ff00 : isRusher ? 0xffaa00 : 0xff0000;
            const eyeMat = new THREE.MeshBasicMaterial({ color: eyeColor });

            if (!isRusher) {
                // Eyes with glow halos
                const leftEye = new THREE.Mesh(eyeGeom, eyeMat);
                leftEye.position.set(-s * 0.15, s * 0.05, s * 0.3);
                leftEye.name = 'leftEye';
                eyeGroup.add(leftEye);

                const rightEye = new THREE.Mesh(eyeGeom, eyeMat);
                rightEye.position.set(s * 0.15, s * 0.05, s * 0.3);
                rightEye.name = 'rightEye';
                eyeGroup.add(rightEye);

                // Eye glow halos
                const haloGeom = new THREE.RingGeometry(s * 0.1, s * 0.18, 12);
                const haloMat = new THREE.MeshBasicMaterial({
                    color: eyeColor,
                    transparent: true,
                    opacity: 0.4,
                    side: THREE.DoubleSide
                });
                const leftHalo = new THREE.Mesh(haloGeom, haloMat);
                leftHalo.position.set(-s * 0.15, s * 0.05, s * 0.32);
                leftHalo.name = 'leftHalo';
                eyeGroup.add(leftHalo);

                const rightHalo = new THREE.Mesh(haloGeom, haloMat);
                rightHalo.position.set(s * 0.15, s * 0.05, s * 0.32);
                rightHalo.name = 'rightHalo';
                eyeGroup.add(rightHalo);
            } else {
                // Rusher visor with scanline effect
                const visorGeom = new THREE.BoxGeometry(s * 0.4, s * 0.08, s * 0.1);
                const visorMat = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
                const visor = new THREE.Mesh(visorGeom, visorMat);
                visor.position.set(0, -s * 0.1, s * 0.25);
                visor.name = 'visor';
                eyeGroup.add(visor);

                // Scanline overlay
                const scanGeom = new THREE.BoxGeometry(s * 0.42, s * 0.02, s * 0.01);
                const scanMat = new THREE.MeshBasicMaterial({
                    color: 0xff6600,
                    transparent: true,
                    opacity: 0.8
                });
                const scanline = new THREE.Mesh(scanGeom, scanMat);
                scanline.position.set(0, -s * 0.1, s * 0.31);
                scanline.name = 'scanline';
                eyeGroup.add(scanline);
            }
            eyeGroup.position.y = bodyHeight + s * 1.2;
            group.add(eyeGroup);
            group.userData.animParts.eyeGroup = eyeGroup;

            // === LAYER 6: CABLES/CONDUITS (animated secondary motion) ===
            const cablesGroup = new THREE.Group();
            cablesGroup.name = 'cables';

            // Create organic-looking cables connecting body to head
            for (let side of [-1, 1]) {
                for (let i = 0; i < 2; i++) {
                    const cableGeom = new THREE.CylinderGeometry(s * 0.03, s * 0.025, s * 0.4, 6);
                    const cableMat = new THREE.MeshStandardMaterial({
                        color: 0x333333,
                        metalness: 0.7,
                        roughness: 0.4
                    });
                    const cable = new THREE.Mesh(cableGeom, cableMat);
                    cable.position.set(side * (s * 0.3 + i * 0.1), bodyHeight + s * 0.5, -s * 0.2);
                    cable.rotation.z = side * 0.3;
                    cable.rotation.x = 0.2;
                    cable.name = `cable_${side > 0 ? 'r' : 'l'}_${i}`;
                    cablesGroup.add(cable);
                }
            }
            group.add(cablesGroup);
            group.userData.animParts.cables = cablesGroup;

            // === LAYER 7: THRUSTERS/VENTS (animated glow) ===
            const thrustersGroup = new THREE.Group();
            thrustersGroup.name = 'thrusters';

            for (let side of [-1, 1]) {
                // Back thrusters
                const thrusterGeom = new THREE.CylinderGeometry(s * 0.08, s * 0.12, s * 0.15, 8);
                const thrusterMat = new THREE.MeshStandardMaterial({
                    color: 0x222222, metalness: 0.8, roughness: 0.3
                });
                const thruster = new THREE.Mesh(thrusterGeom, thrusterMat);
                thruster.position.set(side * s * 0.4, bodyHeight * 0.8, -s * 0.4);
                thruster.rotation.x = -Math.PI / 6;
                thruster.name = `thruster_${side > 0 ? 'r' : 'l'}`;
                thrustersGroup.add(thruster);

                // Thruster glow
                const glowGeom = new THREE.CylinderGeometry(s * 0.06, s * 0.01, s * 0.1, 8);
                const glowMat = new THREE.MeshBasicMaterial({
                    color: config.color,
                    transparent: true,
                    opacity: 0.6
                });
                const glow = new THREE.Mesh(glowGeom, glowMat);
                glow.position.set(side * s * 0.4, bodyHeight * 0.7, -s * 0.5);
                glow.rotation.x = -Math.PI / 6;
                glow.name = `thrusterGlow_${side > 0 ? 'r' : 'l'}`;
                thrustersGroup.add(glow);
            }
            group.add(thrustersGroup);
            group.userData.animParts.thrusters = thrustersGroup;

            // === LAYER 8: ANTENNAE (bouncy secondary motion) ===
            if (!isTank) { // Tanks don't have antennae
                const antennaeGroup = new THREE.Group();
                antennaeGroup.name = 'antennae';

                for (let i = 0; i < (isSniper ? 1 : 2); i++) {
                    const side = i === 0 ? 1 : -1;
                    const antennaGeom = new THREE.CylinderGeometry(s * 0.02, s * 0.015, s * 0.4, 6);
                    const antennaMat = new THREE.MeshStandardMaterial({
                        color: 0x444444, metalness: 0.8, roughness: 0.2
                    });
                    const antenna = new THREE.Mesh(antennaGeom, antennaMat);
                    antenna.position.set(side * s * 0.2, bodyHeight + s * 1.5, -s * 0.1);
                    antenna.rotation.z = side * 0.3;
                    antenna.name = `antenna_${i}`;
                    antennaeGroup.add(antenna);

                    // Antenna tip glow
                    const tipGeom = new THREE.SphereGeometry(s * 0.04, 8, 6);
                    const tipMat = new THREE.MeshBasicMaterial({
                        color: config.color,
                        transparent: true,
                        opacity: 0.9
                    });
                    const tip = new THREE.Mesh(tipGeom, tipMat);
                    tip.position.set(side * s * 0.28, bodyHeight + s * 1.68, -s * 0.12);
                    tip.name = `antennaTip_${i}`;
                    antennaeGroup.add(tip);
                }
                group.add(antennaeGroup);
                group.userData.animParts.antennae = antennaeGroup;
            }

            // === LEGS ===
            const legHeight = isRusher ? s * 1.0 : s * 0.8;
            const legWidth = isTank ? s * 0.4 : s * 0.3;
            const legGeom = new THREE.BoxGeometry(legWidth, legHeight, legWidth);
            const legMat = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.8, roughness: 0.2 });

            const leftLeg = new THREE.Mesh(legGeom, legMat);
            leftLeg.position.set(-s * 0.35, -legHeight * 0.5, 0);
            group.add(leftLeg);

            const rightLeg = new THREE.Mesh(legGeom, legMat);
            rightLeg.position.set(s * 0.35, -legHeight * 0.5, 0);
            group.add(rightLeg);

            // === TYPE-SPECIFIC FEATURES ===

            // RUSHER: Blade arms
            if (isRusher) {
                for (let side of [-1, 1]) {
                    const bladeGeom = new THREE.BoxGeometry(s * 0.1, s * 1.2, s * 0.05);
                    const bladeMat = new THREE.MeshStandardMaterial({
                        color: 0xffaa00, emissive: 0xff6600, emissiveIntensity: 0.5
                    });
                    const blade = new THREE.Mesh(bladeGeom, bladeMat);
                    blade.position.set(side * s * 0.6, bodyHeight * 0.5, s * 0.2);
                    blade.rotation.z = side * 0.3;
                    group.add(blade);
                }
            }

            // TANK: Shoulder armor and cannon
            if (isTank) {
                for (let side of [-1, 1]) {
                    const shoulderGeom = new THREE.BoxGeometry(s * 0.8, s * 0.5, s * 0.6);
                    const shoulderMat = new THREE.MeshStandardMaterial({
                        color: 0x555577, metalness: 0.9, roughness: 0.2
                    });
                    const shoulder = new THREE.Mesh(shoulderGeom, shoulderMat);
                    shoulder.position.set(side * s * 0.9, bodyHeight + s * 0.5, 0);
                    group.add(shoulder);
                }

                // Back cannon
                const cannonGeom = new THREE.CylinderGeometry(s * 0.2, s * 0.25, s * 1.0, 8);
                const cannonMat = new THREE.MeshStandardMaterial({ color: 0x444466, metalness: 0.9, roughness: 0.2 });
                const cannon = new THREE.Mesh(cannonGeom, cannonMat);
                cannon.position.set(0, bodyHeight + s * 0.8, -s * 0.4);
                cannon.rotation.x = Math.PI / 4;
                group.add(cannon);
            }

            // SNIPER: Scope visor and antenna
            if (isSniper) {
                // Scope visor
                const scopeGeom = new THREE.BoxGeometry(s * 0.5, s * 0.15, s * 0.1);
                const scopeMat = new THREE.MeshStandardMaterial({
                    color: 0x00ff44, emissive: 0x00ff44, emissiveIntensity: 0.8
                });
                const scope = new THREE.Mesh(scopeGeom, scopeMat);
                scope.position.set(0, bodyHeight + s * 1.4, s * 0.25);
                group.add(scope);

                // Antenna
                const antennaGeom = new THREE.CylinderGeometry(s * 0.03, s * 0.03, s * 0.6, 6);
                const antennaMat = new THREE.MeshStandardMaterial({ color: 0x44ff44 });
                const antenna = new THREE.Mesh(antennaGeom, antennaMat);
                antenna.position.set(s * 0.2, bodyHeight + s * 1.6, 0);
                group.add(antenna);

                // Rifle
                const rifleGeom = new THREE.BoxGeometry(s * 0.1, s * 0.1, s * 1.5);
                const rifleMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
                const rifle = new THREE.Mesh(rifleGeom, rifleMat);
                rifle.position.set(s * 0.5, bodyHeight * 0.7, s * 0.5);
                group.add(rifle);
            }

            // BOSS: Horns, shoulders, and aura
            if (isBoss) {
                for (let i = 0; i < 3; i++) {
                    const hornGeom = new THREE.ConeGeometry(0.3, 1.5, 4);
                    const hornMat = new THREE.MeshStandardMaterial({
                        color: 0xffaa00, emissive: 0xffaa00, emissiveIntensity: 0.5
                    });
                    const horn = new THREE.Mesh(hornGeom, hornMat);
                    horn.position.set((i - 1) * 0.8, bodyHeight + s * 1.6, 0);
                    group.add(horn);
                }

                for (let side of [-1, 1]) {
                    const shoulderGeom = new THREE.BoxGeometry(1.5, 0.8, 1);
                    const shoulderMat = new THREE.MeshStandardMaterial({
                        color: 0x666666, metalness: 0.9, roughness: 0.2
                    });
                    const shoulder = new THREE.Mesh(shoulderGeom, shoulderMat);
                    shoulder.position.set(side * 1.5, bodyHeight + s * 0.8, 0);
                    group.add(shoulder);
                }

                // Energy aura (transparent sphere)
                const auraGeom = new THREE.SphereGeometry(s * 2.5, 16, 12);
                const auraMat = new THREE.MeshStandardMaterial({
                    color: config.color,
                    emissive: config.color,
                    emissiveIntensity: 0.3,
                    transparent: true,
                    opacity: 0.15
                });
                const aura = new THREE.Mesh(auraGeom, auraMat);
                aura.position.y = bodyHeight;
                group.add(aura);
            }

            return group;
        }

        function createEnemy(type, position) {
            const config = type;
            let group;

            // Use manifest model data if available, otherwise fallback
            if (config.modelData && config.modelData.bodyParts) {
                group = buildEnemyFromModelData(config.modelData, 1);
            } else {
                group = createFallbackEnemyMesh(config);
            }

            group.position.copy(position);
            scene.add(group);

            const enemy = {
                mesh: group,
                type: config,
                health: config.health,
                maxHealth: config.health,
                shield: config.shield || 0,
                maxShield: config.shield || 0,
                lastAttack: 0,
                velocity: new THREE.Vector3(),
                targetPosition: new THREE.Vector3(),
                state: 'chase',
                stateTimer: 0,
                // Animation state
                animState: 'idle',
                animTime: Math.random() * Math.PI * 2, // Randomize start phase
                attackAnimTime: 0,
                isAttacking: false,
                walkCycle: 0,
                // Hit reaction state
                isHit: false,
                hitTime: 0,
                hitDirection: new THREE.Vector3(),
                // Death animation state
                isDying: false,
                deathTime: 0,
                // Secondary motion
                velocitySmooth: new THREE.Vector3(),
                previousY: 0,
                squashStretch: 1,
                // Store animation config from modelData
                animConfig: config.modelData?.animations || {
                    idle: { sway: true, swaySpeed: 2.0, swayAmount: 0.05 },
                    walk: { bob: true, bobSpeed: 4.0, bobAmount: 0.1, legSwing: true },
                    attack: { recoil: true, duration: 0.3 }
                }
            };

            state.enemies.push(enemy);
            return enemy;
        }

        // Squad compositions for diverse gameplay
        const SquadTemplates = {
            // Basic squads (wave 1+)
            grunt_patrol: { enemies: ['GRUNT', 'GRUNT', 'GRUNT'], pattern: 'line' },
            grunt_squad: { enemies: ['GRUNT', 'GRUNT', 'GRUNT', 'GRUNT'], pattern: 'cluster' },

            // Mixed squads (wave 2+)
            assault_team: { enemies: ['GRUNT', 'GRUNT', 'RUSHER'], pattern: 'wedge' },
            flankers: { enemies: ['RUSHER', 'RUSHER'], pattern: 'pincer' },
            hunter_pack: { enemies: ['RUSHER', 'RUSHER', 'RUSHER'], pattern: 'surround' },

            // Tactical squads (wave 3+)
            fire_team: { enemies: ['GRUNT', 'GRUNT', 'SNIPER'], pattern: 'line' },
            sniper_pair: { enemies: ['SNIPER', 'SNIPER'], pattern: 'flanking' },
            heavy_support: { enemies: ['GRUNT', 'GRUNT', 'TANK'], pattern: 'wedge' },

            // Elite squads (wave 5+)
            elite_squad: { enemies: ['SNIPER', 'RUSHER', 'RUSHER'], pattern: 'surround' },
            armored_assault: { enemies: ['TANK', 'GRUNT', 'GRUNT', 'GRUNT'], pattern: 'wedge' },
            death_squad: { enemies: ['TANK', 'SNIPER', 'RUSHER'], pattern: 'triangle' },

            // Heavy squads (wave 7+)
            tank_column: { enemies: ['TANK', 'TANK'], pattern: 'line' },
            combined_arms: { enemies: ['TANK', 'SNIPER', 'RUSHER', 'GRUNT', 'GRUNT'], pattern: 'cluster' },
            shock_troops: { enemies: ['RUSHER', 'RUSHER', 'RUSHER', 'RUSHER'], pattern: 'surround' },

            // Boss support (boss waves)
            boss_guard: { enemies: ['SNIPER', 'SNIPER', 'TANK'], pattern: 'triangle' },
            elite_guard: { enemies: ['RUSHER', 'RUSHER', 'SNIPER', 'SNIPER'], pattern: 'surround' }
        };

        function getAvailableSquads(waveNumber) {
            // Wave 1: Mix of grunts with some rushers for immediate variety
            const squads = ['grunt_patrol', 'grunt_squad', 'assault_team', 'flankers'];

            if (waveNumber >= 2) {
                squads.push('hunter_pack', 'fire_team');
            }
            if (waveNumber >= 3) {
                squads.push('sniper_pair', 'heavy_support');
            }
            if (waveNumber >= 4) {
                squads.push('elite_squad', 'armored_assault');
            }
            if (waveNumber >= 5) {
                squads.push('death_squad', 'tank_column');
            }
            if (waveNumber >= 6) {
                squads.push('combined_arms', 'shock_troops');
            }

            return squads;
        }

        function spawnSquad(squadName, centerAngle, baseRadius, waveNumber, delay) {
            const squad = SquadTemplates[squadName];
            if (!squad) return;

            const enemies = squad.enemies;
            const pattern = squad.pattern;

            enemies.forEach((enemyKey, index) => {
                setTimeout(() => {
                    let pos;
                    const radius = baseRadius + Math.random() * 8;

                    switch (pattern) {
                        case 'line':
                            // Enemies in a line perpendicular to player
                            const lineOffset = (index - (enemies.length - 1) / 2) * 4;
                            const perpAngle = centerAngle + Math.PI / 2;
                            pos = new THREE.Vector3(
                                Math.cos(centerAngle) * radius + Math.cos(perpAngle) * lineOffset,
                                0,
                                Math.sin(centerAngle) * radius + Math.sin(perpAngle) * lineOffset
                            );
                            break;

                        case 'wedge':
                            // V-formation pointing at player
                            const wedgeAngle = centerAngle + (index - (enemies.length - 1) / 2) * 0.3;
                            const wedgeRadius = radius - index * 2;
                            pos = new THREE.Vector3(
                                Math.cos(wedgeAngle) * wedgeRadius,
                                0,
                                Math.sin(wedgeAngle) * wedgeRadius
                            );
                            break;

                        case 'cluster':
                            // Tight group
                            const clusterOffset = index * 0.15;
                            pos = new THREE.Vector3(
                                Math.cos(centerAngle + clusterOffset) * (radius + Math.random() * 3),
                                0,
                                Math.sin(centerAngle + clusterOffset) * (radius + Math.random() * 3)
                            );
                            break;

                        case 'surround':
                            // Spread around the arena
                            const surroundAngle = centerAngle + (index / enemies.length) * Math.PI * 2;
                            pos = new THREE.Vector3(
                                Math.cos(surroundAngle) * radius,
                                0,
                                Math.sin(surroundAngle) * radius
                            );
                            break;

                        case 'pincer':
                            // Two groups from opposite sides
                            const pincerSide = index % 2 === 0 ? -1 : 1;
                            const pincerAngle = centerAngle + pincerSide * Math.PI / 3;
                            pos = new THREE.Vector3(
                                Math.cos(pincerAngle) * radius,
                                0,
                                Math.sin(pincerAngle) * radius
                            );
                            break;

                        case 'flanking':
                            // Wide flanking positions
                            const flankAngle = centerAngle + (index === 0 ? -1 : 1) * Math.PI / 2;
                            pos = new THREE.Vector3(
                                Math.cos(flankAngle) * radius,
                                0,
                                Math.sin(flankAngle) * radius
                            );
                            break;

                        case 'triangle':
                            // Triangle formation
                            const triAngle = centerAngle + (index / 3) * Math.PI * 2;
                            pos = new THREE.Vector3(
                                Math.cos(triAngle) * radius,
                                0,
                                Math.sin(triAngle) * radius
                            );
                            break;

                        default:
                            pos = new THREE.Vector3(
                                Math.cos(centerAngle) * radius,
                                0,
                                Math.sin(centerAngle) * radius
                            );
                    }

                    const type = EnemyTypes[enemyKey] || EnemyTypes.GRUNT;
                    const scaledType = { ...type };
                    scaledType.health = type.health * (1 + waveNumber * 0.1);
                    scaledType.damage = type.damage * (1 + waveNumber * 0.05);

                    // Preserve modelData for JSON-based enemies
                    if (type.modelData) {
                        scaledType.modelData = type.modelData;
                    }

                    createEnemy(scaledType, pos);
                }, delay + index * 200);
            });
        }

        function spawnWave(waveNumber) {
            const isBossWave = waveNumber % 5 === 0;

            // Determine number of squads based on wave
            const baseSquads = Math.min(2 + Math.floor(waveNumber / 2), 6);
            const numSquads = isBossWave ? Math.ceil(baseSquads / 2) : baseSquads;

            // Get available squad types for this wave
            const availableSquads = getAvailableSquads(waveNumber);

            // Spawn squads at different angles around the arena
            for (let i = 0; i < numSquads; i++) {
                const angle = (i / numSquads) * Math.PI * 2 + Math.random() * 0.5;
                const squadName = availableSquads[Math.floor(Math.random() * availableSquads.length)];
                const delay = i * 800; // Stagger squad spawns

                spawnSquad(squadName, angle, 35, waveNumber, delay);
            }

            // Boss wave - spawn boss after squads with elite guard
            if (isBossWave) {
                showBossWarning();
                setTimeout(() => {
                    const bossAngle = Math.random() * Math.PI * 2;
                    const bossPos = new THREE.Vector3(
                        Math.cos(bossAngle) * 30,
                        0,
                        Math.sin(bossAngle) * 30
                    );

                    const bossType = { ...EnemyTypes.BOSS };
                    bossType.health = EnemyTypes.BOSS.health * (1 + (waveNumber / 5 - 1) * 0.5);
                    if (EnemyTypes.BOSS.modelData) {
                        bossType.modelData = EnemyTypes.BOSS.modelData;
                    }

                    createEnemy(bossType, bossPos);

                    // Spawn elite guard around boss
                    setTimeout(() => {
                        spawnSquad('elite_guard', bossAngle + Math.PI, 38, waveNumber, 0);
                    }, 1000);
                }, 2500);
            }

            // Every 3rd wave, add a surprise flanking squad
            if (waveNumber >= 3 && waveNumber % 3 === 0 && !isBossWave) {
                setTimeout(() => {
                    const flankAngle = Math.random() * Math.PI * 2;
                    const flankSquads = ['flankers', 'hunter_pack', 'shock_troops'];
                    const validSquads = flankSquads.filter(s => availableSquads.includes(s));
                    if (validSquads.length > 0) {
                        const squadName = validSquads[Math.floor(Math.random() * validSquads.length)];
                        spawnSquad(squadName, flankAngle, 40, waveNumber, 0);
                    }
                }, 5000); // Surprise reinforcements mid-wave
            }

            showWaveAnnouncement(waveNumber);
            updateEnemyCount();

            // Spawn weapon pickups (more on later waves)
            const weaponCount = Math.min(2 + Math.floor(waveNumber / 3), 5);
            spawnWeaponPickups(weaponCount);
        }

        function updateEnemies(deltaTime) {
            for (let i = state.enemies.length - 1; i >= 0; i--) {
                const enemy = state.enemies[i];

                const dirToPlayer = new THREE.Vector3()
                    .subVectors(state.player.position, enemy.mesh.position)
                    .setY(0).normalize();

                const distToPlayer = enemy.mesh.position.distanceTo(state.player.position);

                if (enemy.type.ranged) {
                    if (distToPlayer < 15) {
                        enemy.velocity.copy(dirToPlayer).multiplyScalar(-enemy.type.speed);
                    } else if (distToPlayer > 25) {
                        enemy.velocity.copy(dirToPlayer).multiplyScalar(enemy.type.speed);
                    } else {
                        const strafeDir = new THREE.Vector3(-dirToPlayer.z, 0, dirToPlayer.x);
                        enemy.velocity.copy(strafeDir).multiplyScalar(enemy.type.speed * 0.5);
                    }
                } else {
                    if (distToPlayer > enemy.type.attackRange) {
                        enemy.velocity.copy(dirToPlayer).multiplyScalar(enemy.type.speed);
                    } else {
                        enemy.velocity.multiplyScalar(0.9);
                    }
                }

                enemy.mesh.position.addScaledVector(enemy.velocity, deltaTime);

                const distFromCenter = Math.sqrt(enemy.mesh.position.x ** 2 + enemy.mesh.position.z ** 2);
                if (distFromCenter > state.arenaRadius - 3) {
                    const pushBack = enemy.mesh.position.clone().normalize().multiplyScalar(-1);
                    enemy.mesh.position.addScaledVector(pushBack, deltaTime * 10);
                }

                enemy.mesh.lookAt(state.player.position.x, enemy.mesh.position.y, state.player.position.z);

                // Animate enemy using skeletal animation system
                animateEnemy(enemy, deltaTime);

                if (distToPlayer <= enemy.type.attackRange) {
                    if (state.time - enemy.lastAttack > enemy.type.attackRate) {
                        attackPlayer(enemy);
                        enemy.lastAttack = state.time;
                    }
                }
            }
        }

        function animateEnemy(enemy, deltaTime) {
            const parts = enemy.mesh.userData.parts || {};
            const originals = enemy.mesh.userData.partOriginals || {};
            const anim = enemy.animConfig;

            // Update animation timers
            enemy.animTime += deltaTime;

            // Determine animation state based on velocity
            const speed = enemy.velocity.length();
            const isMoving = speed > 0.5;
            const speedFactor = Math.min(speed / (enemy.type.speed || 6), 1.5); // Scale animations by movement speed
            enemy.animState = isMoving ? 'walk' : 'idle';

            // Smooth velocity for secondary motion (lerp)
            enemy.velocitySmooth.lerp(enemy.velocity, deltaTime * 8);

            // === HIT REACTION ===
            let hitOffset = { x: 0, y: 0, z: 0, rotX: 0, rotY: 0, rotZ: 0 };
            if (enemy.isHit) {
                enemy.hitTime += deltaTime;
                const hitDuration = 0.2;
                const hitProgress = enemy.hitTime / hitDuration;

                if (hitProgress < 1) {
                    // Elastic recoil curve
                    const recoil = Math.sin(hitProgress * Math.PI) * Math.exp(-hitProgress * 3);
                    const knockback = recoil * 0.3;

                    hitOffset.x = enemy.hitDirection.x * knockback;
                    hitOffset.z = enemy.hitDirection.z * knockback;
                    hitOffset.rotX = -recoil * 0.2;
                    hitOffset.rotZ = (Math.random() - 0.5) * recoil * 0.15;

                    // Squash on impact
                    enemy.squashStretch = 1 - recoil * 0.15;
                } else {
                    enemy.isHit = false;
                    enemy.squashStretch = 1;
                }
            }

            // Update attack animation
            if (enemy.isAttacking) {
                enemy.attackAnimTime += deltaTime;
                const attackDuration = anim.attack?.duration || 0.3;
                if (enemy.attackAnimTime >= attackDuration) {
                    enemy.isAttacking = false;
                    enemy.attackAnimTime = 0;
                }
            }

            // Walk cycle - speed affects animation rate
            if (isMoving) {
                const walkSpeed = (anim.walk?.bobSpeed || 4.0) * speedFactor;
                enemy.walkCycle += deltaTime * walkSpeed;
            }

            // === SQUASH & STRETCH ===
            const squash = enemy.squashStretch;
            const stretch = 1 + (1 - squash) * 0.5; // Inverse on Y axis

            // === BODY BOB (vertical movement) ===
            let bodyBob = 0;
            if (isMoving && anim.walk?.bob) {
                const bobAmount = (anim.walk.bobAmount || 0.1) * speedFactor;
                bodyBob = Math.sin(enemy.walkCycle * 2) * bobAmount;

                // Add secondary motion - body follows velocity with slight delay
                const velocityBob = enemy.velocitySmooth.y * 0.02;
                bodyBob += velocityBob;
            } else if (!isMoving && anim.idle?.sway) {
                const swaySpeed = anim.idle.swaySpeed || 2.0;
                const swayAmount = anim.idle.swayAmount || 0.05;
                bodyBob = Math.sin(enemy.animTime * swaySpeed) * swayAmount;
            }
            enemy.mesh.position.y = bodyBob + hitOffset.y;

            // Apply squash/stretch to mesh scale
            enemy.mesh.scale.set(squash, stretch, squash);

            // === LEG ANIMATION ===
            if (parts.leftLeg && parts.rightLeg && originals.leftLeg && originals.rightLeg) {
                const legSwingAmount = (anim.walk?.legSwingAmount || 0.6) * speedFactor;

                if (isMoving && anim.walk?.legSwing) {
                    const legPhase = enemy.walkCycle;

                    // Left leg swings forward when right leg swings back
                    parts.leftLeg.rotation.x = originals.leftLeg.rotation.x + Math.sin(legPhase) * legSwingAmount;
                    parts.rightLeg.rotation.x = originals.rightLeg.rotation.x + Math.sin(legPhase + Math.PI) * legSwingAmount;

                    // Add knee bend at peak of swing (secondary motion)
                    const leftKneeBend = Math.max(0, Math.sin(legPhase)) * 0.2;
                    const rightKneeBend = Math.max(0, Math.sin(legPhase + Math.PI)) * 0.2;
                    parts.leftLeg.rotation.x += leftKneeBend;
                    parts.rightLeg.rotation.x += rightKneeBend;
                } else {
                    // Smooth return to original rotation when idle
                    parts.leftLeg.rotation.x += (originals.leftLeg.rotation.x - parts.leftLeg.rotation.x) * deltaTime * 8;
                    parts.rightLeg.rotation.x += (originals.rightLeg.rotation.x - parts.rightLeg.rotation.x) * deltaTime * 8;
                }
            }

            // === ARM ANIMATION ===
            const armSwingAmount = (anim.walk?.armSwingAmount || 0.3) * speedFactor;

            if (parts.leftArm && originals.leftArm) {
                if (enemy.isHit) {
                    // Arms flail on hit
                    parts.leftArm.rotation.z = originals.leftArm.rotation.z + hitOffset.rotZ * 2;
                } else if (enemy.isAttacking && (anim.attack?.lunge || anim.attack?.slash)) {
                    // Left arm pulls back during melee attack
                    const attackProgress = enemy.attackAnimTime / (anim.attack?.duration || 0.3);
                    const swingCurve = Math.sin(attackProgress * Math.PI);
                    parts.leftArm.rotation.x = originals.leftArm.rotation.x - swingCurve * 0.5;
                } else if (isMoving) {
                    parts.leftArm.rotation.x = originals.leftArm.rotation.x + Math.sin(enemy.walkCycle + Math.PI) * armSwingAmount;
                } else {
                    // Idle breathing
                    parts.leftArm.rotation.z = originals.leftArm.rotation.z + Math.sin(enemy.animTime * 1.5) * 0.05;
                }
            }

            if (parts.rightArm && originals.rightArm) {
                if (enemy.isHit) {
                    parts.rightArm.rotation.z = originals.rightArm.rotation.z - hitOffset.rotZ * 2;
                } else if (enemy.isAttacking) {
                    const attackProgress = enemy.attackAnimTime / (anim.attack?.duration || 0.3);
                    // Anticipation (wind-up) then follow-through
                    const anticipation = attackProgress < 0.3 ? -attackProgress / 0.3 : 0;
                    const followThrough = attackProgress >= 0.3 ? (attackProgress - 0.3) / 0.7 : 0;
                    const swingCurve = anticipation * 0.3 + Math.sin(followThrough * Math.PI) * 1.0;

                    if (anim.attack?.recoil) {
                        parts.rightArm.rotation.x = originals.rightArm.rotation.x - swingCurve * 0.5;
                    } else if (anim.attack?.lunge || anim.attack?.slash) {
                        parts.rightArm.rotation.x = originals.rightArm.rotation.x + swingCurve * 1.2;
                        parts.rightArm.rotation.z = originals.rightArm.rotation.z - Math.sin(followThrough * Math.PI) * 0.3;
                    }
                } else if (isMoving) {
                    parts.rightArm.rotation.x = originals.rightArm.rotation.x + Math.sin(enemy.walkCycle) * armSwingAmount;
                } else {
                    parts.rightArm.rotation.z = originals.rightArm.rotation.z - Math.sin(enemy.animTime * 1.5) * 0.05;
                }
            }

            // === WEAPON ANIMATION ===
            if (parts.weapon && originals.weapon) {
                if (enemy.isAttacking && anim.attack?.recoil) {
                    const attackProgress = enemy.attackAnimTime / (anim.attack?.duration || 0.3);
                    // Sharp recoil with follow-through
                    const recoilCurve = attackProgress < 0.2
                        ? Math.sin(attackProgress / 0.2 * Math.PI / 2) // Quick snap back
                        : Math.cos((attackProgress - 0.2) / 0.8 * Math.PI / 2); // Slow return
                    parts.weapon.position.z = originals.weapon.position.z - recoilCurve * 0.2;
                    parts.weapon.rotation.x = originals.weapon.rotation.x - recoilCurve * 0.25;
                } else if (enemy.isHit) {
                    // Weapon jerks on hit
                    parts.weapon.rotation.z = originals.weapon.rotation.z + hitOffset.rotZ;
                } else {
                    // Smooth return
                    parts.weapon.position.z += (originals.weapon.position.z - parts.weapon.position.z) * deltaTime * 10;
                    parts.weapon.rotation.x += (originals.weapon.rotation.x - parts.weapon.rotation.x) * deltaTime * 10;
                    parts.weapon.rotation.z += (originals.weapon.rotation.z - parts.weapon.rotation.z) * deltaTime * 10;
                }
            }

            // === HEAD TRACKING ===
            if (parts.head && originals.head) {
                if (enemy.isHit) {
                    // Head snaps back on hit
                    parts.head.rotation.x = originals.head.rotation.x + hitOffset.rotX * 1.5;
                    parts.head.rotation.z = originals.head.rotation.z + hitOffset.rotZ * 2;
                } else {
                    // Smooth head tracking with idle motion
                    const idleMotion = Math.sin(enemy.animTime * 0.5) * 0.1;
                    const targetRotY = idleMotion;
                    parts.head.rotation.y += (targetRotY - parts.head.rotation.y) * deltaTime * 5;
                    parts.head.rotation.x += (originals.head.rotation.x - parts.head.rotation.x) * deltaTime * 8;
                    parts.head.rotation.z += (originals.head.rotation.z - parts.head.rotation.z) * deltaTime * 8;
                }
            }

            // === TORSO LEAN ===
            if (parts.torso && originals.torso) {
                if (enemy.isHit) {
                    parts.torso.rotation.x = originals.torso.rotation.x + hitOffset.rotX;
                    parts.torso.rotation.z = originals.torso.rotation.z + hitOffset.rotZ;
                } else if (isMoving) {
                    // Lean into movement direction (anticipation)
                    const leanAmount = 0.1 * speedFactor;
                    parts.torso.rotation.x = originals.torso.rotation.x + leanAmount;

                    // Slight torso twist during walk
                    const twist = Math.sin(enemy.walkCycle) * 0.05 * speedFactor;
                    parts.torso.rotation.y = originals.torso.rotation.y + twist;
                } else {
                    // Idle breathing sway
                    const breathSway = Math.sin(enemy.animTime * 1.2) * 0.03;
                    parts.torso.rotation.z = originals.torso.rotation.z + breathSway;
                    parts.torso.rotation.x += (originals.torso.rotation.x - parts.torso.rotation.x) * deltaTime * 5;
                    parts.torso.rotation.y += (originals.torso.rotation.y - parts.torso.rotation.y) * deltaTime * 5;
                }
            }

            // === BACKPACK / EQUIPMENT JIGGLE ===
            if (parts.backpack && originals.backpack) {
                // Secondary motion - follows body movement with delay
                const jiggle = Math.sin(enemy.walkCycle * 2 + 0.5) * 0.08 * speedFactor;
                parts.backpack.rotation.x = originals.backpack.rotation.x + jiggle;
                if (enemy.isHit) {
                    parts.backpack.rotation.z = originals.backpack.rotation.z - hitOffset.rotZ;
                }
            }

            // === VISOR / MASK EFFECTS ===
            if (parts.visor && parts.visor.material) {
                // Visor flicker effect
                const baseGlow = 0.8;
                const flicker = Math.random() > 0.95 ? 0.3 : 0; // Occasional flicker
                const pulse = Math.sin(enemy.animTime * 3) * 0.2;
                if (parts.visor.material.emissiveIntensity !== undefined) {
                    parts.visor.material.emissiveIntensity = baseGlow + pulse + flicker;
                }

                // Brighter when attacking
                if (enemy.isAttacking && parts.visor.material.emissiveIntensity !== undefined) {
                    parts.visor.material.emissiveIntensity = 1.5;
                }
            }

            if (parts.mask && originals.mask) {
                // Mask follows head with slight delay (if separate from head)
                if (parts.head) {
                    parts.mask.rotation.x = parts.head.rotation.x * 0.8;
                    parts.mask.rotation.y = parts.head.rotation.y * 0.8;
                }
            }

            // === SPECIAL ANIMATIONS (from manifest) ===
            // Shield pulse for commander
            if (parts.shield && anim.idle?.shieldPulse) {
                const pulse = 0.9 + Math.sin(enemy.animTime * 3) * 0.1;
                parts.shield.scale.setScalar(pulse * squash); // Include squash
                if (parts.shield.material) {
                    parts.shield.material.opacity = 0.4 + Math.sin(enemy.animTime * 2) * 0.2;
                    // Shield flares on hit
                    if (enemy.isHit) {
                        parts.shield.material.opacity = 0.9;
                        parts.shield.scale.setScalar(1.2);
                    }
                }
            }

            // Eye glow pulsing (for bosses)
            if (anim.idle?.eyeGlow) {
                ['leftEye', 'rightEye', 'eye'].forEach(eyeName => {
                    if (parts[eyeName] && parts[eyeName].material && parts[eyeName].material.emissiveIntensity !== undefined) {
                        let intensity = 0.5 + Math.sin(enemy.animTime * 4) * 0.5;
                        if (enemy.isAttacking) intensity = 2.0; // Eyes flare when attacking
                        if (enemy.isHit) intensity = 0.1; // Dim on hit
                        parts[eyeName].material.emissiveIntensity = intensity;
                    }
                });
            }

            // Core glow for boss
            if (parts.core && anim.idle?.coreGlow) {
                if (parts.core.material && parts.core.material.emissiveIntensity !== undefined) {
                    let intensity = 0.8 + Math.sin(enemy.animTime * 2) * 0.4;
                    if (enemy.isAttacking) intensity = 1.5;
                    parts.core.material.emissiveIntensity = intensity;
                }
                // Core rotation
                if (parts.core.rotation) {
                    parts.core.rotation.y += deltaTime * 0.5;
                }
            }

            // Fuel tank glow for tank enemies
            if (anim.idle?.fuelGlow) {
                ['fuelTank', 'fuelCell', 'fuelTankLeft', 'fuelTankRight'].forEach(tankName => {
                    if (parts[tankName] && parts[tankName].material && parts[tankName].material.emissiveIntensity !== undefined) {
                        let intensity = 0.6 + Math.sin(enemy.animTime * 1.5) * 0.4;
                        // Tank rumbles - increased glow
                        if (isMoving) intensity += 0.3;
                        if (enemy.isHit) intensity = 1.5; // Danger flash on hit
                        parts[tankName].material.emissiveIntensity = intensity;
                    }
                });
            }

            // === CAPE / CLOTH PHYSICS ===
            if (parts.cape && originals.cape) {
                // Simple cloth simulation
                const windSway = Math.sin(enemy.animTime * 2) * 0.1;
                const movementBillow = isMoving ? Math.sin(enemy.walkCycle * 0.5) * 0.15 * speedFactor : 0;
                parts.cape.rotation.x = originals.cape.rotation.x + windSway + movementBillow;
                parts.cape.rotation.z = originals.cape.rotation.z + Math.sin(enemy.animTime * 1.5) * 0.05;

                // Cape reacts to hits
                if (enemy.isHit) {
                    parts.cape.rotation.x = originals.cape.rotation.x - hitOffset.rotX * 2;
                }
            }

            // === BLADE / CLAW EFFECTS ===
            ['leftBlade', 'rightBlade', 'blade', 'leftClaw', 'rightClaw'].forEach(bladeName => {
                if (parts[bladeName] && originals[bladeName]) {
                    if (enemy.isAttacking) {
                        // Blades extend/ready during attack
                        const attackProgress = enemy.attackAnimTime / (anim.attack?.duration || 0.3);
                        const readyOffset = Math.sin(attackProgress * Math.PI) * 0.2;
                        parts[bladeName].rotation.x = originals[bladeName].rotation.x - readyOffset;
                    }

                    // Blade shimmer effect
                    if (parts[bladeName].material && parts[bladeName].material.emissiveIntensity !== undefined) {
                        const shimmer = 0.3 + Math.sin(enemy.animTime * 5 + Math.random()) * 0.2;
                        parts[bladeName].material.emissiveIntensity = enemy.isAttacking ? 1.5 : shimmer;
                    }
                }
            });

            // === CANNON / HEAVY WEAPON ===
            if (parts.cannon && originals.cannon) {
                if (enemy.isAttacking && anim.attack?.chargeUp) {
                    // Charging animation
                    const attackProgress = enemy.attackAnimTime / (anim.attack?.duration || 0.3);
                    const chargePhase = attackProgress < 0.6 ? attackProgress / 0.6 : 1;
                    const firePhase = attackProgress >= 0.6 ? (attackProgress - 0.6) / 0.4 : 0;

                    // Cannon glows during charge
                    if (parts.cannon.material && parts.cannon.material.emissiveIntensity !== undefined) {
                        parts.cannon.material.emissiveIntensity = chargePhase * 2;
                    }

                    // Recoil on fire
                    if (firePhase > 0) {
                        parts.cannon.position.z = originals.cannon.position.z - Math.sin(firePhase * Math.PI) * 0.3;
                    }
                } else {
                    // Idle cannon scan
                    const scan = Math.sin(enemy.animTime * 0.3) * 0.1;
                    parts.cannon.rotation.y = originals.cannon.rotation.y + scan;

                    // Return to position
                    parts.cannon.position.z += (originals.cannon.position.z - parts.cannon.position.z) * deltaTime * 5;
                }
            }
        }

        function attackPlayer(enemy) {
            // Trigger attack animation
            enemy.isAttacking = true;
            enemy.attackAnimTime = 0;

            if (enemy.type.ranged) {
                const dir = new THREE.Vector3().subVectors(state.player.position, enemy.mesh.position).normalize();
                createEnemyProjectile(enemy.mesh.position.clone().add(new THREE.Vector3(0, 1.5, 0)), dir, enemy.type.damage, enemy.type.color);
            } else {
                damagePlayer(enemy.type.damage);
            }
        }

        function damageEnemy(enemy, damage, isCrit = false) {
            enemy.health -= damage;

            // Trigger hit reaction animation
            enemy.isHit = true;
            enemy.hitTime = 0;
            // Calculate hit direction from player to enemy
            enemy.hitDirection.subVectors(enemy.mesh.position, state.player.position).setY(0).normalize();

            enemy.mesh.children.forEach(child => {
                if (child.material) {
                    child.material.emissiveIntensity = 1;
                    setTimeout(() => { if (child.material) child.material.emissiveIntensity = 0.2; }, 100);
                }
            });

            createDamageNumber(enemy.mesh.position.clone().add(new THREE.Vector3(0, 2, 0)), damage, isCrit);

            if (isCrit) state.screenShake = 0.3;

            if (enemy.health <= 0) killEnemy(enemy);
        }

        function killEnemy(enemy) {
            const comboMultiplier = 1 + state.combo * 0.1;
            const score = Math.floor(enemy.type.score * comboMultiplier);
            state.score += score;
            state.combo++;
            state.comboTimer = 3;

            // Health on kill - scales with enemy difficulty
            const healAmount = Math.ceil(enemy.type.score / 25);
            const actualHeal = Math.min(healAmount, state.player.maxHealth - state.player.health);
            if (actualHeal > 0) {
                state.player.health += actualHeal;
                updateHealth();
                const healPos = state.player.position.clone().add(new THREE.Vector3(0, 2.5, 0));
                createHealNumber(healPos, actualHeal);
            }

            updateScore();
            updateCombo();
            addKillFeed(enemy.type.name, score);
            createExplosion(enemy.mesh.position.clone(), enemy.type.color, enemy.type.size);

            if (Math.random() < 0.3) createPickup(enemy.mesh.position.clone());

            scene.remove(enemy.mesh);
            const idx = state.enemies.indexOf(enemy);
            if (idx > -1) state.enemies.splice(idx, 1);

            updateEnemyCount();

            if (state.enemies.length === 0) {
                setTimeout(() => { if (state.current === GameState.PLAYING) showUpgradeScreen(); }, 1500);
            }

            vibrateController(0.5, 0.5, 150);
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // WEAPON & PROJECTILE SYSTEM
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function fireWeapon() {
            const weapon = state.weapons[state.currentWeapon];

            if (state.isReloading) return;
            if (weapon.ammo <= 0) { startReload(); return; }
            if (state.time - state.lastFire < weapon.fireRate) return;

            weapon.ammo--;
            state.lastFire = state.time;
            updateAmmo();

            const forward = new THREE.Vector3(0, 0, -1);
            forward.applyQuaternion(camera.quaternion);

            const pelletCount = weapon.pellets || 1;

            for (let i = 0; i < pelletCount; i++) {
                // Reduce spread significantly when scoped (Halo-style)
                const scopeSpreadReduction = state.scopeLevel > 0 ? 0.3 : 1.0;
                const spread = weapon.spread * scopeSpreadReduction;
                const spreadDir = forward.clone();
                spreadDir.x += (Math.random() - 0.5) * spread;
                spreadDir.y += (Math.random() - 0.5) * spread;
                spreadDir.z += (Math.random() - 0.5) * spread;
                spreadDir.normalize();

                createProjectile(camera.position.clone().add(spreadDir.clone().multiplyScalar(1)), spreadDir, weapon);
            }

            createMuzzleFlash();
            applyViewmodelRecoil();

            // Enhanced audio and haptics
            ProceduralAudio.playWeaponFire(weapon.name);
            HapticFeedback.weaponFire(weapon.name);

            state.screenShake = 0.1 * (weapon.damage / 25);

            const vibIntensity = Math.min(weapon.damage / 100, 1);
            vibrateController(vibIntensity, vibIntensity * 0.5, 100);

            if (weapon.ammo <= 0) startReload();
        }

        function createProjectile(position, direction, weapon) {
            const projectileGeometry = new THREE.SphereGeometry(0.15, 8, 6);
            const projectileMaterial = new THREE.MeshBasicMaterial({ color: weapon.color });
            const projectile = new THREE.Mesh(projectileGeometry, projectileMaterial);
            projectile.position.copy(position);
            scene.add(projectile);

            const trailGeometry = new THREE.CylinderGeometry(0.05, 0.15, 1, 8);
            const trailMaterial = new THREE.MeshBasicMaterial({ color: weapon.color, transparent: true, opacity: 0.5 });
            const trail = new THREE.Mesh(trailGeometry, trailMaterial);
            trail.rotation.x = Math.PI / 2;
            projectile.add(trail);

            const glowLight = new THREE.PointLight(weapon.color, 1, 5);
            projectile.add(glowLight);

            state.projectiles.push({
                mesh: projectile,
                velocity: direction.clone().multiplyScalar(weapon.projectileSpeed),
                damage: weapon.damage * state.player.damage,
                piercing: weapon.piercing || false,
                explosive: weapon.explosive || false,
                explosionRadius: weapon.explosionRadius || 0,
                color: weapon.color,
                isPlayer: true,
                lifetime: 3
            });
        }

        function createEnemyProjectile(position, direction, damage, color) {
            // Larger, more visible projectile core
            const projectileGeometry = new THREE.SphereGeometry(0.4, 12, 8);
            const projectileMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff }); // White hot core
            const projectile = new THREE.Mesh(projectileGeometry, projectileMaterial);
            projectile.position.copy(position);
            scene.add(projectile);

            // Colored outer shell
            const shellGeometry = new THREE.SphereGeometry(0.55, 12, 8);
            const shellMaterial = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.7
            });
            const shell = new THREE.Mesh(shellGeometry, shellMaterial);
            projectile.add(shell);

            // Long glowing trail behind projectile
            const trailGeometry = new THREE.CylinderGeometry(0.15, 0.4, 3.0, 8);
            const trailMaterial = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.8
            });
            const trail = new THREE.Mesh(trailGeometry, trailMaterial);
            trail.rotation.x = Math.PI / 2;
            trail.position.z = 1.5;
            projectile.add(trail);

            // Bright point light for dramatic glow
            const glowLight = new THREE.PointLight(color, 5, 15);
            projectile.add(glowLight);

            // Large outer glow sphere
            const glowGeometry = new THREE.SphereGeometry(0.9, 12, 8);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.4
            });
            const glowSphere = new THREE.Mesh(glowGeometry, glowMaterial);
            projectile.add(glowSphere);

            // Create tracer line from shooter position
            createTracerLine(position, direction, color, 25);

            // Enemy muzzle flash at origin
            createEnemyMuzzleFlash(position, color);

            state.projectiles.push({
                mesh: projectile,
                velocity: direction.clone().multiplyScalar(40), // Slightly faster for visibility
                damage: damage,
                color: color,
                isPlayer: false,
                lifetime: 5,
                origin: position.clone() // Track origin for tracer updates
            });
        }

        function createTracerLine(startPos, direction, color, length) {
            // Create a thick, visible beam showing the shot path
            const endPos = startPos.clone().addScaledVector(direction, length);

            // Calculate beam orientation
            const beamDir = new THREE.Vector3().subVectors(endPos, startPos);
            const beamLength = beamDir.length();
            const beamCenter = startPos.clone().add(endPos).multiplyScalar(0.5);

            // Create cylinder for thick beam
            const beamGeometry = new THREE.CylinderGeometry(0.08, 0.15, beamLength, 8);
            const beamMaterial = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.9
            });
            const beam = new THREE.Mesh(beamGeometry, beamMaterial);

            // Orient beam along direction
            beam.position.copy(beamCenter);
            beam.quaternion.setFromUnitVectors(
                new THREE.Vector3(0, 1, 0),
                beamDir.normalize()
            );
            scene.add(beam);

            // Outer glow cylinder
            const glowGeometry = new THREE.CylinderGeometry(0.2, 0.35, beamLength, 8);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.4
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.position.copy(beamCenter);
            glow.quaternion.copy(beam.quaternion);
            scene.add(glow);

            // Fade out and remove tracer
            let opacity = 0.9;
            const fadeInterval = setInterval(() => {
                opacity -= 0.08;
                beamMaterial.opacity = opacity;
                glowMaterial.opacity = opacity * 0.4;
                if (opacity <= 0) {
                    clearInterval(fadeInterval);
                    scene.remove(beam);
                    scene.remove(glow);
                    beamGeometry.dispose();
                    beamMaterial.dispose();
                    glowGeometry.dispose();
                    glowMaterial.dispose();
                }
            }, 25);
        }

        function createEnemyMuzzleFlash(position, color) {
            // Bright flash at enemy position when they shoot
            const flash = new THREE.PointLight(color, 8, 15);
            flash.position.copy(position);
            scene.add(flash);

            // Flash particles
            for (let i = 0; i < 5; i++) {
                const sparkGeom = new THREE.SphereGeometry(0.1);
                const sparkMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                const spark = new THREE.Mesh(sparkGeom, sparkMat);
                spark.position.copy(position);
                scene.add(spark);

                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 8,
                    Math.random() * 4,
                    (Math.random() - 0.5) * 8
                );
                state.particles.push({ mesh: spark, velocity, lifetime: 0.15, gravity: false });
            }

            setTimeout(() => scene.remove(flash), 80);
        }

        function createImpactEffect(position, color, isOnPlayer = false) {
            // Spark burst at impact point
            const particleCount = isOnPlayer ? 20 : 12;

            for (let i = 0; i < particleCount; i++) {
                const sparkGeom = new THREE.SphereGeometry(0.08 + Math.random() * 0.1);
                const sparkMat = new THREE.MeshBasicMaterial({
                    color: i % 3 === 0 ? 0xffffff : color,
                    transparent: true
                });
                const spark = new THREE.Mesh(sparkGeom, sparkMat);
                spark.position.copy(position);
                scene.add(spark);

                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 15,
                    Math.random() * 10,
                    (Math.random() - 0.5) * 15
                );
                state.particles.push({ mesh: spark, velocity, lifetime: 0.3 + Math.random() * 0.2, gravity: true });
            }

            // Impact flash
            const impactFlash = new THREE.PointLight(color, 5, 10);
            impactFlash.position.copy(position);
            scene.add(impactFlash);
            setTimeout(() => scene.remove(impactFlash), 60);
        }

        function updateProjectiles(deltaTime) {
            for (let i = state.projectiles.length - 1; i >= 0; i--) {
                const proj = state.projectiles[i];

                proj.mesh.position.addScaledVector(proj.velocity, deltaTime);
                proj.lifetime -= deltaTime;

                const distFromCenter = Math.sqrt(proj.mesh.position.x ** 2 + proj.mesh.position.z ** 2);

                if (proj.lifetime <= 0 || distFromCenter > state.arenaRadius + 10 ||
                    proj.mesh.position.y < -5 || proj.mesh.position.y > 50) {
                    scene.remove(proj.mesh);
                    state.projectiles.splice(i, 1);
                    continue;
                }

                if (proj.isPlayer) {
                    for (const enemy of state.enemies) {
                        const dist = proj.mesh.position.distanceTo(enemy.mesh.position);
                        if (dist < enemy.type.size * 1.5) {
                            const isCrit = Math.random() < state.player.critChance;
                            const damage = isCrit ? proj.damage * state.player.critMultiplier : proj.damage;

                            damageEnemy(enemy, damage, isCrit);
                            showHitMarker();

                            // Create impact effect on enemy
                            createImpactEffect(proj.mesh.position.clone(), proj.color, false);

                            if (proj.explosive) {
                                createExplosion(proj.mesh.position.clone(), proj.color, 2);
                                for (const nearEnemy of state.enemies) {
                                    const blastDist = proj.mesh.position.distanceTo(nearEnemy.mesh.position);
                                    if (blastDist < proj.explosionRadius) {
                                        const falloff = 1 - (blastDist / proj.explosionRadius);
                                        damageEnemy(nearEnemy, proj.damage * falloff * 0.5, false);
                                    }
                                }
                            }

                            if (!proj.piercing) {
                                scene.remove(proj.mesh);
                                state.projectiles.splice(i, 1);
                                break;
                            }
                        }
                    }
                } else {
                    // Enemy projectile hitting player
                    const dist = proj.mesh.position.distanceTo(state.player.position);
                    if (dist < 1.2) {
                        // Create impact effect at hit location
                        createImpactEffect(proj.mesh.position.clone(), proj.color, true);

                        // Pass projectile position for directional damage indicator
                        damagePlayer(proj.damage, proj.mesh.position.clone());

                        scene.remove(proj.mesh);
                        state.projectiles.splice(i, 1);
                    }
                }
            }
        }

        function startReload() {
            if (state.isReloading) return;
            const weapon = state.weapons[state.currentWeapon];
            if (weapon.ammo === weapon.maxAmmo) return;

            // Descope when reloading (Halo-style)
            descope();

            state.isReloading = true;
            state.reloadTimer = weapon.reloadTime;

            playSound('reload');
            document.getElementById('weapon-name').textContent = 'RELOADING...';
        }

        function updateReload(deltaTime) {
            if (!state.isReloading) return;

            state.reloadTimer -= deltaTime;
            if (state.reloadTimer <= 0) {
                const weapon = state.weapons[state.currentWeapon];
                weapon.ammo = weapon.maxAmmo;
                state.isReloading = false;
                updateAmmo();
            }
        }

        function switchWeapon(index) {
            if (index === state.currentWeapon) return;
            if (index < 0 || index >= state.weapons.length) return;

            // Descope when switching weapons
            descope();

            state.currentWeapon = index;
            state.isReloading = false;
            updateAmmo();
            playSound('switch');

            // Switch viewmodel
            switchViewmodel(state.weapons[index].name);
        }

        // Halo-style toggle scope
        function toggleScope() {
            const weapon = state.weapons[state.currentWeapon];
            const scopeZoom = weapon.scopeZoom || 0;

            // No scope on this weapon
            if (scopeZoom === 0) return;

            // Toggle scope level
            if (state.scopeLevel === 0) {
                state.scopeLevel = 1;
                // Show scope overlay
                const scopeOverlay = document.getElementById('scope-overlay');
                if (scopeOverlay) {
                    scopeOverlay.classList.add('active');
                    // Update zoom indicator
                    const zoomIndicator = scopeOverlay.querySelector('.scope-zoom-indicator');
                    if (zoomIndicator) zoomIndicator.textContent = scopeZoom + 'X';
                }
                // Hide viewmodel when scoped
                if (currentViewmodel) currentViewmodel.visible = false;
                // Play scope sound
                playSound('switch');
            } else {
                descope();
            }
        }

        // Exit scope
        function descope() {
            if (state.scopeLevel === 0) return;

            state.scopeLevel = 0;
            // Hide scope overlay
            const scopeOverlay = document.getElementById('scope-overlay');
            if (scopeOverlay) scopeOverlay.classList.remove('active');
            // Show viewmodel
            if (currentViewmodel) currentViewmodel.visible = true;
            // Reset FOV
            if (camera) {
                camera.fov = 75;
                camera.updateProjectionMatrix();
            }
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // VISUAL EFFECTS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function createExplosion(position, color, size = 1) {
            const particleCount = 30 * size;

            for (let i = 0; i < particleCount; i++) {
                const geometry = new THREE.SphereGeometry(0.1 + Math.random() * 0.2);
                const material = new THREE.MeshBasicMaterial({ color: i % 2 === 0 ? color : 0xffffff, transparent: true });
                const particle = new THREE.Mesh(geometry, material);
                particle.position.copy(position);
                scene.add(particle);

                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 20 * size,
                    Math.random() * 15 * size,
                    (Math.random() - 0.5) * 20 * size
                );

                state.particles.push({ mesh: particle, velocity: velocity, lifetime: 0.5 + Math.random() * 0.5, gravity: true });
            }

            const flash = new THREE.PointLight(color, 5, 20);
            flash.position.copy(position);
            scene.add(flash);
            setTimeout(() => scene.remove(flash), 100);

            playSound('explosion');
        }

        function createMuzzleFlash() {
            const flash = new THREE.PointLight(0xffff00, 3, 10);
            flash.position.copy(camera.position);
            const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
            flash.position.addScaledVector(forward, 1);
            scene.add(flash);
            setTimeout(() => scene.remove(flash), 50);
        }

        function createDamageNumber(position, damage, isCrit) {
            const geometry = new THREE.PlaneGeometry(1, 0.5);
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = isCrit ? '#ffff00' : '#ffffff';
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(Math.floor(damage).toString(), 64, 48);

            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide });
            const number = new THREE.Mesh(geometry, material);
            number.position.copy(position);
            number.lookAt(camera.position);
            scene.add(number);

            state.particles.push({ mesh: number, velocity: new THREE.Vector3(0, 3, 0), lifetime: 1, gravity: false, fadeOut: true, billboard: true });
        }

        function createHealNumber(position, amount) {
            const geometry = new THREE.PlaneGeometry(1, 0.5);
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#44ff44';
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('+' + Math.floor(amount).toString(), 64, 48);

            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide });
            const number = new THREE.Mesh(geometry, material);
            number.position.copy(position);
            number.lookAt(camera.position);
            scene.add(number);

            state.particles.push({ mesh: number, velocity: new THREE.Vector3(0, 4, 0), lifetime: 1.2, gravity: false, fadeOut: true, billboard: true });
        }

        function updateParticles(deltaTime) {
            for (let i = state.particles.length - 1; i >= 0; i--) {
                const particle = state.particles[i];

                particle.mesh.position.addScaledVector(particle.velocity, deltaTime);
                if (particle.gravity) particle.velocity.y -= 30 * deltaTime;
                particle.lifetime -= deltaTime;
                if (particle.fadeOut && particle.mesh.material) particle.mesh.material.opacity = particle.lifetime;
                if (particle.billboard) particle.mesh.lookAt(camera.position);

                if (particle.lifetime <= 0) {
                    scene.remove(particle.mesh);
                    state.particles.splice(i, 1);
                }
            }
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // PICKUPS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function createPickup(position) {
            const types = ['health', 'ammo', 'damage'];
            const type = types[Math.floor(Math.random() * types.length)];
            const colors = { health: 0x44ff44, ammo: 0x4444ff, damage: 0xff4444 };

            const geometry = new THREE.OctahedronGeometry(0.5);
            const material = new THREE.MeshStandardMaterial({
                color: colors[type], emissive: colors[type], emissiveIntensity: 0.5, metalness: 0.8, roughness: 0.2
            });
            const pickup = new THREE.Mesh(geometry, material);
            pickup.position.copy(position);
            pickup.position.y = 1;
            scene.add(pickup);

            state.pickups.push({ mesh: pickup, type: type, lifetime: 15 });
        }

        function updatePickups(deltaTime) {
            for (let i = state.pickups.length - 1; i >= 0; i--) {
                const pickup = state.pickups[i];

                pickup.mesh.rotation.y += deltaTime * 2;
                pickup.mesh.position.y = 1 + Math.sin(state.time * 3) * 0.3;
                pickup.lifetime -= deltaTime;

                const dist = pickup.mesh.position.distanceTo(state.player.position);
                if (dist < 2) {
                    collectPickup(pickup);
                    scene.remove(pickup.mesh);
                    state.pickups.splice(i, 1);
                    continue;
                }

                if (pickup.lifetime <= 0) {
                    scene.remove(pickup.mesh);
                    state.pickups.splice(i, 1);
                }
            }
        }

        function collectPickup(pickup) {
            switch (pickup.type) {
                case 'health':
                    state.player.health = Math.min(state.player.maxHealth, state.player.health + 25);
                    updateHealth();
                    break;
                case 'ammo':
                    state.weapons.forEach(w => w.ammo = w.maxAmmo);
                    updateAmmo();
                    break;
                case 'damage':
                    state.player.damage *= 1.1;
                    break;
            }
            playSound('pickup');
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // WEAPON PICKUP SYSTEM (Halo-style 2-weapon limit)
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        const AllWeapons = {
            'PLASMA RIFLE': {
                name: 'PLASMA RIFLE',
                ammo: 30, maxAmmo: 30,
                damage: 25, fireRate: 0.1, reloadTime: 1.5, spread: 0.02,
                projectileSpeed: 150, color: 0x00ffff, sound: 'plasma'
            },
            'SHOTGUN': {
                name: 'SHOTGUN',
                ammo: 8, maxAmmo: 8,
                damage: 15, fireRate: 0.6, reloadTime: 2.0, spread: 0.15,
                pellets: 8, projectileSpeed: 100, color: 0xffaa00, sound: 'shotgun'
            },
            'RAILGUN': {
                name: 'RAILGUN',
                ammo: 5, maxAmmo: 5,
                damage: 150, fireRate: 1.2, reloadTime: 3.0, spread: 0,
                piercing: true, projectileSpeed: 500, color: 0xff00ff, sound: 'railgun'
            },
            'ROCKET LAUNCHER': {
                name: 'ROCKET LAUNCHER',
                ammo: 3, maxAmmo: 3,
                damage: 100, fireRate: 1.0, reloadTime: 2.5, spread: 0,
                explosive: true, explosionRadius: 8, projectileSpeed: 40, color: 0xff4400, sound: 'rocket'
            },
            'BR55': {
                name: 'BR55',
                ammo: 36, maxAmmo: 36,
                damage: 35, fireRate: 0.5, reloadTime: 2.0, spread: 0.01,
                burst: 3, burstDelay: 0.05, projectileSpeed: 200, color: 0xaaaaff, sound: 'plasma',
                scopeZoom: 2 // Halo-style 2x scope
            },
            'SMG': {
                name: 'SMG',
                ammo: 60, maxAmmo: 60,
                damage: 12, fireRate: 0.05, reloadTime: 1.8, spread: 0.06,
                projectileSpeed: 180, color: 0xffff00, sound: 'plasma'
            }
        };

        function createWeaponPickup(position, weaponName = null) {
            let selectedName = weaponName;

            // Choose random weapon if not specified
            if (!selectedName) {
                const weaponNames = Object.keys(AllWeapons).filter(w =>
                    !state.weapons.some(sw => sw.name === w) // Don't spawn weapons player already has
                );
                if (weaponNames.length === 0) return; // All weapons acquired
                selectedName = weaponNames[Math.floor(Math.random() * weaponNames.length)];
            }

            const weaponDef = AllWeapons[selectedName];
            if (!weaponDef) return;

            const group = new THREE.Group();
            group.name = 'weaponPickup_' + selectedName;

            // Create weapon model
            const viewmodelDef = WeaponViewmodels[selectedName];
            if (viewmodelDef && viewmodelDef.build) {
                const model = viewmodelDef.build();
                model.scale.setScalar(viewmodelDef.scale || 1);
                group.add(model);
            } else {
                // Fallback box representation
                const boxGeom = new THREE.BoxGeometry(0.3, 0.15, 0.8);
                const boxMat = new THREE.MeshStandardMaterial({
                    color: weaponDef.color,
                    metalness: 0.7,
                    roughness: 0.3
                });
                const box = new THREE.Mesh(boxGeom, boxMat);
                group.add(box);
            }

            // Floating platform/glow effect
            const platformGeom = new THREE.CylinderGeometry(0.6, 0.7, 0.1, 16);
            const platformMat = new THREE.MeshStandardMaterial({
                color: weaponDef.color,
                emissive: weaponDef.color,
                emissiveIntensity: 0.3,
                transparent: true,
                opacity: 0.6
            });
            const platform = new THREE.Mesh(platformGeom, platformMat);
            platform.position.y = -0.3;
            group.add(platform);

            // Holographic ring
            const ringGeom = new THREE.TorusGeometry(0.5, 0.03, 8, 24);
            const ringMat = new THREE.MeshBasicMaterial({
                color: weaponDef.color,
                transparent: true,
                opacity: 0.5
            });
            const ring = new THREE.Mesh(ringGeom, ringMat);
            ring.rotation.x = Math.PI / 2;
            ring.position.y = 0.3;
            ring.name = 'holoRing';
            group.add(ring);

            group.position.copy(position);
            group.position.y = 1.2;
            scene.add(group);

            state.weaponPickups.push({
                mesh: group,
                weapon: { ...weaponDef },
                lifetime: 60 // 60 seconds
            });
        }

        function updateWeaponPickups(deltaTime) {
            for (let i = state.weaponPickups.length - 1; i >= 0; i--) {
                const pickup = state.weaponPickups[i];

                // Rotate and bob
                pickup.mesh.rotation.y += deltaTime * 1.5;
                pickup.mesh.position.y = 1.2 + Math.sin(state.time * 2) * 0.15;

                // Rotate holo ring
                const ring = pickup.mesh.getObjectByName('holoRing');
                if (ring) {
                    ring.rotation.z += deltaTime * 3;
                }

                pickup.lifetime -= deltaTime;

                // Check player proximity
                const dist = pickup.mesh.position.distanceTo(state.player.position);
                if (dist < 2.5) {
                    pickupWeapon(pickup);
                    scene.remove(pickup.mesh);
                    state.weaponPickups.splice(i, 1);
                    continue;
                }

                if (pickup.lifetime <= 0) {
                    scene.remove(pickup.mesh);
                    state.weaponPickups.splice(i, 1);
                }
            }
        }

        function pickupWeapon(pickup) {
            const newWeapon = pickup.weapon;

            // Check if we already have this weapon - just refill ammo
            const existingWeapon = state.weapons.find(w => w.name === newWeapon.name);
            if (existingWeapon) {
                existingWeapon.ammo = existingWeapon.maxAmmo;
                playSound('pickup');
                addKillFeedEntry(`${newWeapon.name} AMMO`, newWeapon.color);
                updateAmmo();
                return;
            }

            // If we have room, add the weapon
            if (state.weapons.length < state.maxCarriedWeapons) {
                state.weapons.push({ ...newWeapon });
                switchWeapon(state.weapons.length - 1);
                playSound('pickup');
                addKillFeedEntry(`PICKED UP ${newWeapon.name}`, newWeapon.color);
                updateAmmo();
                return;
            }

            // Swap current weapon - drop it on the ground (outside pickup range of 2.5)
            const droppedWeapon = state.weapons[state.currentWeapon];
            const dropPos = state.player.position.clone();
            // Drop 3-4 units away so player doesn't immediately pick it back up
            const dropAngle = Math.random() * Math.PI * 2;
            dropPos.x += Math.cos(dropAngle) * (3 + Math.random());
            dropPos.z += Math.sin(dropAngle) * (3 + Math.random());

            // Create pickup for dropped weapon
            createWeaponPickup(dropPos, droppedWeapon.name);

            // Replace current weapon
            state.weapons[state.currentWeapon] = { ...newWeapon };
            switchWeapon(state.currentWeapon);
            playSound('pickup');
            addKillFeedEntry(`SWAPPED TO ${newWeapon.name}`, newWeapon.color);
            updateAmmo();
        }

        function spawnWeaponPickups(count = 3) {
            for (let i = 0; i < count; i++) {
                const angle = (i / count) * Math.PI * 2 + Math.random() * 0.5;
                const radius = 15 + Math.random() * 20;
                const pos = new THREE.Vector3(
                    Math.cos(angle) * radius,
                    0,
                    Math.sin(angle) * radius
                );
                createWeaponPickup(pos);
            }
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // PLAYER CONTROLLER
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function updatePlayer(deltaTime) {
            const moveSpeed = state.player.speed;
            const forward = new THREE.Vector3(0, 0, -1).applyAxisAngle(new THREE.Vector3(0, 1, 0), state.player.rotation.y);
            const right = new THREE.Vector3(1, 0, 0).applyAxisAngle(new THREE.Vector3(0, 1, 0), state.player.rotation.y);

            const moveVec = new THREE.Vector3();
            moveVec.addScaledVector(forward, state.input.move.y);
            moveVec.addScaledVector(right, state.input.move.x);

            if (moveVec.length() > 0) moveVec.normalize().multiplyScalar(moveSpeed);

            state.player.velocity.x = moveVec.x;
            state.player.velocity.z = moveVec.z;

            state.player.position.addScaledVector(state.player.velocity, deltaTime);

            const distFromCenter = Math.sqrt(state.player.position.x ** 2 + state.player.position.z ** 2);
            if (distFromCenter > state.arenaRadius - 2) {
                const pushBack = new THREE.Vector3(state.player.position.x, 0, state.player.position.z).normalize();
                state.player.position.x = pushBack.x * (state.arenaRadius - 2);
                state.player.position.z = pushBack.z * (state.arenaRadius - 2);
            }

            // Look - different sensitivity for controller vs mouse
            const lookSensitivity = state.inputMode === InputMode.GAMEPAD ? 2.5 : 1;
            state.player.rotation.y -= state.input.look.x * lookSensitivity * deltaTime;
            state.player.rotation.x -= state.input.look.y * lookSensitivity * deltaTime;
            state.player.rotation.x = Math.max(-Math.PI / 2.5, Math.min(Math.PI / 2.5, state.player.rotation.x));

            camera.position.copy(state.player.position);
            camera.rotation.order = 'YXZ';
            camera.rotation.y = state.player.rotation.y;
            camera.rotation.x = state.player.rotation.x;

            if (state.screenShake > 0) {
                camera.position.x += (Math.random() - 0.5) * state.screenShake;
                camera.position.y += (Math.random() - 0.5) * state.screenShake;
                state.screenShake *= 0.9;
                if (state.screenShake < 0.01) state.screenShake = 0;
            }

            // Halo-style shield recharge
            const timeSinceLastDamage = state.time - state.player.lastDamageTime;
            if (state.player.shields < state.player.maxShields && timeSinceLastDamage >= state.player.shieldRechargeDelay) {
                state.player.shields = Math.min(
                    state.player.maxShields,
                    state.player.shields + state.player.shieldRechargeRate * deltaTime
                );
                updateHealth(); // Update shield bar
            }

            // Fire with mouse OR spacebar when scoped (Halo-style)
            if (state.input.fire || (state.input.spacebarFire && state.scopeLevel > 0)) fireWeapon();
            if (state.input.reload) startReload();

            if (state.input.weapon1) switchWeapon(0);
            if (state.input.weapon2) switchWeapon(1);
            if (state.input.weapon3) switchWeapon(2);
            if (state.input.weapon4) switchWeapon(3);
        }

        function damagePlayer(damage, hitPosition = null) {
            let effectiveDamage = Math.max(1, damage - state.player.armor);

            // Halo-style descope on damage
            descope();

            // Halo-style shield system
            state.player.lastDamageTime = state.time;

            if (state.player.shields > 0) {
                // Shields absorb damage first
                if (effectiveDamage >= state.player.shields) {
                    // Shield break!
                    effectiveDamage -= state.player.shields;
                    state.player.shields = 0;

                    // Shield break effects
                    ProceduralAudio.playHit(); // Shield break sound
                    HapticFeedback.damage(damage);
                    state.screenShake = 0.8;

                    // Flash shield break indicator
                    const damageOverlay = document.getElementById('damage-overlay');
                    if (damageOverlay) {
                        damageOverlay.style.opacity = '0.8';
                        damageOverlay.style.background = 'radial-gradient(circle, rgba(0,150,255,0.3), transparent)';
                        setTimeout(() => {
                            damageOverlay.style.opacity = '0';
                            damageOverlay.style.background = '';
                        }, 300);
                    }

                    // Apply remaining damage to health
                    state.player.health -= effectiveDamage;
                } else {
                    // Shields absorb all damage
                    state.player.shields -= effectiveDamage;
                    ProceduralAudio.playHit(); // Shield hit sound
                    HapticFeedback.damage(damage * 0.5);
                    state.damageFlash = 0.3;
                    state.screenShake = 0.3;

                    // Shield hit flash
                    const damageOverlay = document.getElementById('damage-overlay');
                    if (damageOverlay) {
                        damageOverlay.style.opacity = '0.4';
                        damageOverlay.style.background = 'radial-gradient(circle, rgba(0,200,255,0.2), transparent)';
                        setTimeout(() => {
                            damageOverlay.style.opacity = '0';
                            damageOverlay.style.background = '';
                        }, 150);
                    }
                    effectiveDamage = 0; // No health damage
                }
            } else {
                // No shields - direct health damage
                state.player.health -= effectiveDamage;
                state.damageFlash = 0.5;
                ProceduralAudio.playHit();
                HapticFeedback.damage(damage);
                state.screenShake = 0.5;

                const damageOverlay = document.getElementById('damage-overlay');
                if (damageOverlay) {
                    damageOverlay.style.opacity = '0.6';
                    setTimeout(() => { damageOverlay.style.opacity = '0'; }, 200);
                }
            }

            updateHealth();

            // Show directional damage indicator if hit position provided
            if (hitPosition) {
                showDamageDirection(hitPosition);
            }

            vibrateController(0.8, 0.4, 200);

            if (state.player.health <= 0) gameOver();
        }

        function showDamageDirection(hitPosition) {
            // Calculate direction from player to hit source
            const dir = new THREE.Vector3()
                .subVectors(hitPosition, state.player.position)
                .setY(0)
                .normalize();

            // Get camera forward direction
            const cameraForward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
            cameraForward.y = 0;
            cameraForward.normalize();

            // Get camera right direction
            const cameraRight = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
            cameraRight.y = 0;
            cameraRight.normalize();

            // Calculate angle relative to camera
            const dotForward = dir.dot(cameraForward);
            const dotRight = dir.dot(cameraRight);
            const angle = Math.atan2(dotRight, dotForward) * (180 / Math.PI);

            // Create directional damage indicator
            const indicator = document.createElement('div');
            indicator.className = 'damage-direction';
            indicator.style.cssText = `
                position: absolute;
                width: 100px;
                height: 100px;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%) rotate(${angle + 180}deg);
                pointer-events: none;
                z-index: 1000;
            `;
            indicator.innerHTML = `
                <svg viewBox="0 0 100 100" style="width:100%;height:100%;">
                    <polygon points="50,10 35,40 65,40" fill="rgba(255,0,0,0.8)" />
                    <polygon points="50,10 40,35 60,35" fill="rgba(255,100,100,0.9)" />
                </svg>
            `;
            document.getElementById('game-container').appendChild(indicator);

            // Fade out and remove
            setTimeout(() => {
                indicator.style.transition = 'opacity 0.3s';
                indicator.style.opacity = '0';
                setTimeout(() => indicator.remove(), 300);
            }, 200);
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // INPUT HANDLING - DUAL SUPPORT (Controller + Keyboard/Mouse)
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        const keys = {};
        let mouseMovement = { x: 0, y: 0 };
        let lastKeyboardTime = 0;
        let lastGamepadTime = 0;

        function setInputMode(mode, savePreference = false) {
            if (state.inputMode !== mode) {
                state.inputMode = mode;
                document.body.classList.toggle('keyboard-active', mode === InputMode.KEYBOARD);

                const icon = document.getElementById('input-mode-icon');
                const text = document.getElementById('input-mode-text');
                if (mode === InputMode.KEYBOARD) {
                    icon.textContent = '‚å®Ô∏è';
                    text.textContent = 'Keyboard + Mouse';
                } else {
                    icon.textContent = 'üéÆ';
                    text.textContent = 'Controller';
                }

                // Update toggle UI
                updateInputModeToggleUI(mode);
            }

            if (savePreference) {
                state.preferredInputMode = mode;
                localStorage.setItem('apex_input_mode', mode);
            }
        }

        function updateInputModeToggleUI(mode) {
            const gamepadToggle = document.getElementById('toggle-gamepad');
            const keyboardToggle = document.getElementById('toggle-keyboard');
            if (gamepadToggle && keyboardToggle) {
                gamepadToggle.classList.toggle('active', mode === InputMode.GAMEPAD);
                keyboardToggle.classList.toggle('active', mode === InputMode.KEYBOARD);
            }
        }

        function updateInput() {
            const gamepads = navigator.getGamepads();
            let gamepadActive = false;

            for (const gamepad of gamepads) {
                if (!gamepad) continue;

                state.gamepadConnected = true;

                const deadzone = 0.15;
                const applyDeadzone = (val) => Math.abs(val) < deadzone ? 0 : val;

                const leftX = applyDeadzone(gamepad.axes[0]);
                const leftY = applyDeadzone(gamepad.axes[1]);
                const rightX = applyDeadzone(gamepad.axes[2]);
                const rightY = applyDeadzone(gamepad.axes[3]);

                // Detect if gamepad is being used
                if (Math.abs(leftX) > 0.1 || Math.abs(leftY) > 0.1 ||
                    Math.abs(rightX) > 0.1 || Math.abs(rightY) > 0.1 ||
                    gamepad.buttons.some(b => b.pressed)) {
                    lastGamepadTime = performance.now();
                    gamepadActive = true;
                }

                // Only apply gamepad input if it was used more recently (or if auto-switch is disabled and gamepad is preferred)
                const useGamepad = state.autoSwitchInput
                    ? lastGamepadTime > lastKeyboardTime
                    : state.preferredInputMode === 'gamepad';

                if (useGamepad) {
                    if (state.autoSwitchInput) setInputMode(InputMode.GAMEPAD);

                    state.input.move.x = leftX;
                    state.input.move.y = -leftY;
                    state.input.look.x = rightX * state.controllerSensitivity;
                    state.input.look.y = rightY * state.controllerSensitivity;

                    state.input.fire = gamepad.buttons[7]?.pressed || false;
                    state.input.aim = gamepad.buttons[6]?.pressed || false;
                    state.input.reload = gamepad.buttons[2]?.pressed || false;
                    state.input.jump = gamepad.buttons[0]?.pressed || false;

                    // Weapon switching with bumpers
                    if (gamepad.buttons[4]?.pressed) {
                        const prev = (state.currentWeapon - 1 + state.weapons.length) % state.weapons.length;
                        if (!state.input.prevWeaponHeld) switchWeapon(prev);
                        state.input.prevWeaponHeld = true;
                    } else {
                        state.input.prevWeaponHeld = false;
                    }

                    if (gamepad.buttons[5]?.pressed) {
                        const next = (state.currentWeapon + 1) % state.weapons.length;
                        if (!state.input.nextWeaponHeld) switchWeapon(next);
                        state.input.nextWeaponHeld = true;
                    } else {
                        state.input.nextWeaponHeld = false;
                    }

                    // D-pad for quick weapon select
                    state.input.weapon1 = gamepad.buttons[12]?.pressed || false;
                    state.input.weapon2 = gamepad.buttons[13]?.pressed || false;
                    state.input.weapon3 = gamepad.buttons[14]?.pressed || false;
                    state.input.weapon4 = gamepad.buttons[15]?.pressed || false;

                    // Pause
                    if (gamepad.buttons[9]?.pressed) {
                        if (!state.input.pauseHeld) state.input.pause = true;
                        state.input.pauseHeld = true;
                    } else {
                        state.input.pauseHeld = false;
                        state.input.pause = false;
                    }

                    // Menu navigation
                    state.input.select = gamepad.buttons[0]?.pressed || false;
                    state.input.back = gamepad.buttons[1]?.pressed || false;

                    const now = performance.now();
                    if (now - state.lastGamepadInput > 200) {
                        if (Math.abs(gamepad.axes[1]) > 0.5) {
                            state.input.menuMove.y = gamepad.axes[1] > 0 ? 1 : -1;
                            state.lastGamepadInput = now;
                        } else if (Math.abs(gamepad.axes[0]) > 0.5) {
                            state.input.menuMove.x = gamepad.axes[0] > 0 ? 1 : -1;
                            state.lastGamepadInput = now;
                        } else if (gamepad.buttons[12]?.pressed) {
                            state.input.menuMove.y = -1;
                            state.lastGamepadInput = now;
                        } else if (gamepad.buttons[13]?.pressed) {
                            state.input.menuMove.y = 1;
                            state.lastGamepadInput = now;
                        } else if (gamepad.buttons[14]?.pressed) {
                            state.input.menuMove.x = -1;
                            state.lastGamepadInput = now;
                        } else if (gamepad.buttons[15]?.pressed) {
                            state.input.menuMove.x = 1;
                            state.lastGamepadInput = now;
                        } else {
                            state.input.menuMove.x = 0;
                            state.input.menuMove.y = 0;
                        }
                    }
                }

                break;
            }

            // Apply keyboard/mouse input if it was used more recently (or if auto-switch is disabled and keyboard is preferred)
            const useKeyboard = state.autoSwitchInput
                ? lastKeyboardTime >= lastGamepadTime
                : state.preferredInputMode === 'keyboard';

            if (useKeyboard) {
                if (state.autoSwitchInput) setInputMode(InputMode.KEYBOARD);
                applyKeyboardInput();
            }
        }

        function applyKeyboardInput() {
            // Movement
            state.input.move.x = (keys['KeyD'] ? 1 : 0) - (keys['KeyA'] ? 1 : 0);
            state.input.move.y = (keys['KeyW'] ? 1 : 0) - (keys['KeyS'] ? 1 : 0);

            // Look - apply mouse movement with sensitivity
            state.input.look.x = mouseMovement.x * state.mouseSensitivity * 50;
            state.input.look.y = mouseMovement.y * state.mouseSensitivity * 50;
            mouseMovement.x = 0;
            mouseMovement.y = 0;
        }

        function vibrateController(leftIntensity, rightIntensity, duration) {
            const gamepads = navigator.getGamepads();
            for (const gamepad of gamepads) {
                if (gamepad?.vibrationActuator) {
                    gamepad.vibrationActuator.playEffect('dual-rumble', {
                        startDelay: 0, duration: duration,
                        weakMagnitude: leftIntensity, strongMagnitude: rightIntensity
                    }).catch(() => {});
                }
            }
        }

        // Keyboard events
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            lastKeyboardTime = performance.now();

            // Weapon switching
            if (e.code === 'Digit1') { switchWeapon(0); state.input.weapon1 = true; }
            if (e.code === 'Digit2') { switchWeapon(1); state.input.weapon2 = true; }
            if (e.code === 'Digit3') { switchWeapon(2); state.input.weapon3 = true; }
            if (e.code === 'Digit4') { switchWeapon(3); state.input.weapon4 = true; }

            if (e.code === 'Escape') {
                e.preventDefault();
                state.input.pause = true;
                state.input.back = true;
            }
            if (e.code === 'KeyR') state.input.reload = true;
            if (e.code === 'Enter') state.input.select = true;
            // Spacebar: menu select OR fire when aiming down sights
            if (e.code === 'Space') {
                state.input.select = true;
                state.input.spacebarFire = true;
            }

            // Grenade throwing (Halo-style)
            if (e.code === 'KeyG' && state.current === GameState.PLAYING) {
                GrenadeSystem.throw('frag');
            }
            if (e.code === 'KeyF' && state.current === GameState.PLAYING) {
                GrenadeSystem.throw('plasma');
            }

            // Menu navigation
            if (e.code === 'ArrowUp' || e.code === 'KeyW') {
                state.input.menuMove.y = -1;
            }
            if (e.code === 'ArrowDown' || e.code === 'KeyS') {
                state.input.menuMove.y = 1;
            }
            if (e.code === 'ArrowLeft' || e.code === 'KeyA') {
                state.input.menuMove.x = -1;
            }
            if (e.code === 'ArrowRight' || e.code === 'KeyD') {
                state.input.menuMove.x = 1;
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;

            if (e.code === 'KeyR') state.input.reload = false;
            if (e.code === 'Digit1') state.input.weapon1 = false;
            if (e.code === 'Digit2') state.input.weapon2 = false;
            if (e.code === 'Digit3') state.input.weapon3 = false;
            if (e.code === 'Digit4') state.input.weapon4 = false;
            if (e.code === 'Enter') state.input.select = false;
            if (e.code === 'Space') {
                state.input.select = false;
                state.input.spacebarFire = false;
            }
            if (e.code === 'Escape') state.input.back = false;

            state.input.menuMove.x = 0;
            state.input.menuMove.y = 0;
        });

        // Mouse events
        document.addEventListener('mousemove', (e) => {
            lastKeyboardTime = performance.now();
            if (document.pointerLockElement === canvas) {
                mouseMovement.x += e.movementX * 0.002;
                mouseMovement.y += e.movementY * 0.002;
            }
        });

        document.addEventListener('mousedown', (e) => {
            lastKeyboardTime = performance.now();

            if (e.button === 0) {
                state.input.fire = true;
                state.input.select = true;
            }
            // Right-click: Halo-style toggle scope (not hold-to-aim)
            if (e.button === 2 && state.current === GameState.PLAYING) {
                toggleScope();
            }

            // Request pointer lock when clicking in game
            if (state.current === GameState.PLAYING && !document.pointerLockElement) {
                canvas.requestPointerLock();
            }
        });

        document.addEventListener('mouseup', (e) => {
            if (e.button === 0) {
                state.input.fire = false;
                state.input.select = false;
            }
            // Scope is toggle, not hold - no action needed on mouseup
        });

        // Mouse wheel for weapon switching
        document.addEventListener('wheel', (e) => {
            lastKeyboardTime = performance.now();
            if (state.current === GameState.PLAYING) {
                if (e.deltaY > 0) {
                    const next = (state.currentWeapon + 1) % state.weapons.length;
                    switchWeapon(next);
                } else {
                    const prev = (state.currentWeapon - 1 + state.weapons.length) % state.weapons.length;
                    switchWeapon(prev);
                }
            }
        });

        // Pointer lock change
        document.addEventListener('pointerlockchange', () => {
            state.pointerLocked = document.pointerLockElement === canvas;

            if (state.current === GameState.PLAYING) {
                if (!state.pointerLocked && state.inputMode === InputMode.KEYBOARD) {
                    document.getElementById('click-to-play').style.display = 'block';
                } else {
                    document.getElementById('click-to-play').style.display = 'none';
                }
            }
        });

        // Global function for click-to-play overlay
        window.requestPointerLockAndResume = function() {
            canvas.requestPointerLock();
            document.getElementById('click-to-play').style.display = 'none';
        };

        // Input mode toggle buttons
        document.getElementById('toggle-gamepad').addEventListener('click', () => {
            setInputMode(InputMode.GAMEPAD, true);
        });

        document.getElementById('toggle-keyboard').addEventListener('click', () => {
            setInputMode(InputMode.KEYBOARD, true);
        });

        // Auto-switch toggle
        document.getElementById('auto-switch-input').addEventListener('change', (e) => {
            state.autoSwitchInput = e.target.checked;
            localStorage.setItem('apex_auto_switch', state.autoSwitchInput.toString());
        });

        // Mouse sensitivity slider
        document.getElementById('mouse-sensitivity').addEventListener('input', (e) => {
            state.mouseSensitivity = parseFloat(e.target.value);
            document.getElementById('mouse-sensitivity-value').textContent = state.mouseSensitivity.toFixed(1);
            localStorage.setItem('apex_mouse_sensitivity', state.mouseSensitivity.toString());
        });

        // Controller sensitivity slider
        document.getElementById('controller-sensitivity').addEventListener('input', (e) => {
            state.controllerSensitivity = parseFloat(e.target.value);
            document.getElementById('controller-sensitivity-value').textContent = state.controllerSensitivity.toFixed(1);
            localStorage.setItem('apex_controller_sensitivity', state.controllerSensitivity.toString());
        });

        // Initialize all settings UI from saved state
        function initializeSettingsUI() {
            // Input mode toggles
            updateInputModeToggleUI(state.inputMode);

            // Auto-switch checkbox
            document.getElementById('auto-switch-input').checked = state.autoSwitchInput;

            // Mouse sensitivity
            document.getElementById('mouse-sensitivity').value = state.mouseSensitivity;
            document.getElementById('mouse-sensitivity-value').textContent = state.mouseSensitivity.toFixed(1);

            // Controller sensitivity
            document.getElementById('controller-sensitivity').value = state.controllerSensitivity;
            document.getElementById('controller-sensitivity-value').textContent = state.controllerSensitivity.toFixed(1);
        }

        initializeSettingsUI();

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // HAPTIC FEEDBACK SYSTEM
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        const HapticFeedback = {
            supported: 'vibrate' in navigator,

            vibrate(pattern) {
                if (!this.supported) return;
                try {
                    navigator.vibrate(pattern);
                } catch (e) {
                    // Ignore errors on unsupported devices
                }
            },

            weaponFire(weaponName) {
                const patterns = {
                    'PLASMA RIFLE': 15,
                    'SHOTGUN': 40,
                    'RAILGUN': 25,
                    'ROCKET LAUNCHER': 50,
                    'SMG': 8,
                    'PISTOL': 12,
                    'BR55': 15,
                    'SNIPER': 25
                };
                this.vibrate(patterns[weaponName] || 15);
            },

            damage(amount) {
                const intensity = Math.min(50, Math.floor(amount / 2));
                this.vibrate([intensity, 20, intensity / 2]);
            },

            kill() {
                this.vibrate([30, 50, 50, 50, 30]);
            }
        };

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // PROCEDURAL AUDIO SYSTEM (Enhanced from Halo)
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        const ProceduralAudio = {
            context: null,
            masterGain: null,

            init() {
                try {
                    this.context = new (window.AudioContext || window.webkitAudioContext)();
                    this.masterGain = this.context.createGain();
                    this.masterGain.connect(this.context.destination);
                    this.masterGain.gain.value = 0.5;
                } catch (e) {
                    console.warn('Audio not supported');
                }
            },

            createNoise(duration) {
                if (!this.context) return null;
                const bufferSize = this.context.sampleRate * duration;
                const buffer = this.context.createBuffer(1, bufferSize, this.context.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                const noise = this.context.createBufferSource();
                noise.buffer = buffer;
                const gain = this.context.createGain();
                gain.gain.setValueAtTime(0.15, this.context.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + duration);
                noise.connect(gain);
                noise.start();
                noise.stop(this.context.currentTime + duration);
                return gain;
            },

            playWeaponFire(weaponName) {
                if (!this.context) return;
                if (this.context.state === 'suspended') this.context.resume();

                const now = this.context.currentTime;

                // Map APEX weapons to Halo-style sounds
                let weaponType = weaponName;
                if (weaponName === 'PLASMA RIFLE') weaponType = 'SMG';
                if (weaponName === 'RAILGUN') weaponType = 'SNIPER';

                switch (weaponType) {
                    case 'SNIPER':
                        const sniperOsc = this.context.createOscillator();
                        const sniperGain = this.context.createGain();
                        const sniperFilter = this.context.createBiquadFilter();

                        sniperFilter.type = 'lowpass';
                        sniperFilter.frequency.value = 800;

                        sniperOsc.frequency.setValueAtTime(100, now);
                        sniperOsc.frequency.exponentialRampToValueAtTime(25, now + 0.4);
                        sniperGain.gain.setValueAtTime(0.5, now);
                        sniperGain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);

                        sniperOsc.connect(sniperFilter);
                        sniperFilter.connect(sniperGain);
                        sniperGain.connect(this.masterGain);

                        sniperOsc.start(now);
                        sniperOsc.stop(now + 0.6);

                        const noise1 = this.createNoise(0.2);
                        if (noise1) noise1.connect(this.masterGain);
                        return;

                    case 'SMG':
                        const smgOsc = this.context.createOscillator();
                        const smgGain = this.context.createGain();
                        const smgFilter = this.context.createBiquadFilter();

                        smgFilter.type = 'bandpass';
                        smgFilter.frequency.value = 2500;
                        smgFilter.Q.value = 1.5;

                        smgOsc.frequency.setValueAtTime(250, now);
                        smgOsc.frequency.exponentialRampToValueAtTime(100, now + 0.04);
                        smgGain.gain.setValueAtTime(0.18, now);
                        smgGain.gain.exponentialRampToValueAtTime(0.01, now + 0.06);

                        smgOsc.connect(smgFilter);
                        smgFilter.connect(smgGain);
                        smgGain.connect(this.masterGain);

                        smgOsc.start(now);
                        smgOsc.stop(now + 0.08);

                        const noise2 = this.createNoise(0.05);
                        if (noise2) noise2.connect(this.masterGain);
                        return;

                    case 'SHOTGUN':
                        const shotgunOsc = this.context.createOscillator();
                        const shotgunGain = this.context.createGain();
                        const shotgunFilter = this.context.createBiquadFilter();

                        shotgunOsc.type = 'sawtooth';
                        shotgunFilter.type = 'lowpass';
                        shotgunFilter.frequency.value = 600;

                        shotgunOsc.frequency.setValueAtTime(60, now);
                        shotgunOsc.frequency.exponentialRampToValueAtTime(25, now + 0.25);
                        shotgunGain.gain.setValueAtTime(0.5, now);
                        shotgunGain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);

                        shotgunOsc.connect(shotgunFilter);
                        shotgunFilter.connect(shotgunGain);
                        shotgunGain.connect(this.masterGain);

                        shotgunOsc.start(now);
                        shotgunOsc.stop(now + 0.35);

                        const noise3 = this.createNoise(0.2);
                        if (noise3) noise3.connect(this.masterGain);
                        return;

                    case 'ROCKET':
                    case 'ROCKET LAUNCHER':
                        const rocketOsc = this.context.createOscillator();
                        const rocketGain = this.context.createGain();
                        const rocketFilter = this.context.createBiquadFilter();

                        rocketOsc.type = 'sawtooth';
                        rocketFilter.type = 'lowpass';
                        rocketFilter.frequency.value = 400;

                        rocketOsc.frequency.setValueAtTime(40, now);
                        rocketOsc.frequency.exponentialRampToValueAtTime(15, now + 0.5);
                        rocketGain.gain.setValueAtTime(0.6, now);
                        rocketGain.gain.exponentialRampToValueAtTime(0.01, now + 0.6);

                        rocketOsc.connect(rocketFilter);
                        rocketFilter.connect(rocketGain);
                        rocketGain.connect(this.masterGain);

                        rocketOsc.start(now);
                        rocketOsc.stop(now + 0.7);

                        const noise4 = this.createNoise(0.3);
                        if (noise4) noise4.connect(this.masterGain);
                        return;

                    default:
                        // Generic gunshot
                        const osc = this.context.createOscillator();
                        const gain = this.context.createGain();
                        const filter = this.context.createBiquadFilter();

                        filter.type = 'lowpass';
                        filter.frequency.value = 2000;

                        osc.frequency.setValueAtTime(150, now);
                        osc.frequency.exponentialRampToValueAtTime(50, now + 0.1);
                        gain.gain.setValueAtTime(0.3, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);

                        osc.connect(filter);
                        filter.connect(gain);
                        gain.connect(this.masterGain);

                        osc.start(now);
                        osc.stop(now + 0.2);

                        const noise5 = this.createNoise(0.1);
                        if (noise5) noise5.connect(this.masterGain);
                        return;
                }
            },

            playExplosion() {
                if (!this.context) return;
                const now = this.context.currentTime;

                const osc = this.context.createOscillator();
                const gain = this.context.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(60, now);
                osc.frequency.exponentialRampToValueAtTime(20, now + 0.5);
                gain.gain.setValueAtTime(0.5, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.6);

                osc.connect(gain);
                gain.connect(this.masterGain);

                osc.start(now);
                osc.stop(now + 0.7);

                const noise = this.createNoise(0.4);
                if (noise) noise.connect(this.masterGain);
            },

            playPickup() {
                if (!this.context) return;
                const now = this.context.currentTime;

                const osc = this.context.createOscillator();
                const gain = this.context.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(440, now);
                osc.frequency.setValueAtTime(660, now + 0.05);
                osc.frequency.setValueAtTime(880, now + 0.1);
                gain.gain.setValueAtTime(0.2, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);

                osc.connect(gain);
                gain.connect(this.masterGain);

                osc.start(now);
                osc.stop(now + 0.2);
            },

            playReload() {
                if (!this.context) return;
                const now = this.context.currentTime;

                const osc = this.context.createOscillator();
                const gain = this.context.createGain();
                osc.type = 'square';
                osc.frequency.setValueAtTime(300, now);
                osc.frequency.setValueAtTime(400, now + 0.05);
                osc.frequency.setValueAtTime(300, now + 0.1);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);

                osc.connect(gain);
                gain.connect(this.masterGain);

                osc.start(now);
                osc.stop(now + 0.2);
            },

            playHit() {
                if (!this.context) return;
                const now = this.context.currentTime;

                const osc = this.context.createOscillator();
                const gain = this.context.createGain();
                osc.type = 'square';
                osc.frequency.setValueAtTime(200, now);
                osc.frequency.setValueAtTime(100, now + 0.05);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);

                osc.connect(gain);
                gain.connect(this.masterGain);

                osc.start(now);
                osc.stop(now + 0.15);
            },

            playGrenadeThrow() {
                if (!this.context) return;
                const now = this.context.currentTime;
                const osc = this.context.createOscillator();
                const gain = this.context.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(300, now);
                osc.frequency.exponentialRampToValueAtTime(600, now + 0.1);
                gain.gain.setValueAtTime(0.15, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.start(now);
                osc.stop(now + 0.2);
            },

            playGrenadeBounce() {
                if (!this.context) return;
                const now = this.context.currentTime;
                const osc = this.context.createOscillator();
                const gain = this.context.createGain();
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(400, now);
                osc.frequency.exponentialRampToValueAtTime(200, now + 0.03);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.start(now);
                osc.stop(now + 0.08);
            },

            playGrenadeExplosion(type) {
                if (!this.context) return;
                const now = this.context.currentTime;

                // Main explosion
                const osc = this.context.createOscillator();
                const gain = this.context.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(type === 'plasma' ? 80 : 60, now);
                osc.frequency.exponentialRampToValueAtTime(20, now + 0.4);
                gain.gain.setValueAtTime(0.6, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.start(now);
                osc.stop(now + 0.6);

                // High crack
                const crack = this.context.createOscillator();
                const crackGain = this.context.createGain();
                crack.type = 'square';
                crack.frequency.setValueAtTime(type === 'plasma' ? 2000 : 1500, now);
                crack.frequency.exponentialRampToValueAtTime(500, now + 0.1);
                crackGain.gain.setValueAtTime(0.15, now);
                crackGain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                crack.connect(crackGain);
                crackGain.connect(this.masterGain);
                crack.start(now);
                crack.stop(now + 0.2);

                const noise = this.createNoise(0.3);
                if (noise) noise.connect(this.masterGain);
            },

            playPlasmaStick() {
                if (!this.context) return;
                const now = this.context.currentTime;
                // Electrical sizzle for plasma stick
                const osc = this.context.createOscillator();
                const gain = this.context.createGain();
                osc.type = 'square';
                osc.frequency.setValueAtTime(2500, now);
                osc.frequency.exponentialRampToValueAtTime(1000, now + 0.1);
                gain.gain.setValueAtTime(0.12, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.start(now);
                osc.stop(now + 0.2);
            }
        };

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // GRENADE SYSTEM (Halo-style Frag & Plasma)
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        const GrenadeSystem = {
            activeGrenades: [],
            grenadePool: [],
            GRENADE_GRAVITY: 20,
            GRENADE_THROW_FORCE: 25,
            GRENADE_FUSE_TIME: 3.0,
            GRENADE_DAMAGE_RADIUS: 10,
            GRENADE_MAX_DAMAGE: 150,

            init() {
                // Pre-create grenade mesh pool
                for (let i = 0; i < 10; i++) {
                    this.grenadePool.push(this.createGrenadeMesh('frag'));
                    this.grenadePool.push(this.createGrenadeMesh('plasma'));
                }
            },

            createGrenadeMesh(type) {
                const group = new THREE.Group();
                group.userData.type = type;

                if (type === 'frag') {
                    // Frag grenade - cylindrical with segments
                    const body = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.08, 0.08, 0.15, 8),
                        new THREE.MeshStandardMaterial({ color: 0x3a5a3a, metalness: 0.6, roughness: 0.4 })
                    );
                    body.rotation.x = Math.PI / 2;
                    group.add(body);

                    // Top cap
                    const cap = new THREE.Mesh(
                        new THREE.SphereGeometry(0.08, 8, 8, 0, Math.PI * 2, 0, Math.PI / 2),
                        new THREE.MeshStandardMaterial({ color: 0x4a6a4a, metalness: 0.5, roughness: 0.5 })
                    );
                    cap.position.z = 0.075;
                    cap.rotation.x = Math.PI / 2;
                    group.add(cap);

                    // Spoon/handle
                    const spoon = new THREE.Mesh(
                        new THREE.BoxGeometry(0.02, 0.12, 0.04),
                        new THREE.MeshStandardMaterial({ color: 0x666666, metalness: 0.7, roughness: 0.3 })
                    );
                    spoon.position.set(0.06, 0, 0);
                    group.add(spoon);
                } else {
                    // Plasma grenade - glowing blue sphere with fins
                    const core = new THREE.Mesh(
                        new THREE.SphereGeometry(0.1, 16, 16),
                        new THREE.MeshStandardMaterial({
                            color: 0x00aaff,
                            emissive: 0x0066aa,
                            emissiveIntensity: 0.8,
                            metalness: 0.3,
                            roughness: 0.7
                        })
                    );
                    group.add(core);

                    // Fins
                    for (let i = 0; i < 4; i++) {
                        const fin = new THREE.Mesh(
                            new THREE.BoxGeometry(0.02, 0.08, 0.15),
                            new THREE.MeshStandardMaterial({ color: 0x0088cc, metalness: 0.5, roughness: 0.5 })
                        );
                        const finAngle = i * Math.PI / 2;
                        fin.rotation.y = finAngle;
                        fin.position.set(
                            Math.cos(finAngle) * 0.08,
                            0,
                            Math.sin(finAngle) * 0.08
                        );
                        group.add(fin);
                    }
                }

                group.visible = false;
                scene.add(group);
                return group;
            },

            getMesh(type) {
                const mesh = this.grenadePool.find(g => g.userData.type === type && !g.visible);
                if (mesh) {
                    mesh.visible = true;
                    return mesh;
                }
                // Create new if pool exhausted
                const newMesh = this.createGrenadeMesh(type);
                newMesh.visible = true;
                this.grenadePool.push(newMesh);
                return newMesh;
            },

            throw(type) {
                if (state.current !== GameState.PLAYING) return false;
                if (state.player.grenades[type] <= 0) {
                    // Flash grenade count red
                    const grenadeEl = document.getElementById(`grenade-${type}`);
                    if (grenadeEl) {
                        grenadeEl.style.animation = 'pulse 0.2s ease';
                        setTimeout(() => grenadeEl.style.animation = '', 200);
                    }
                    return false;
                }

                // Decrease inventory
                state.player.grenades[type]--;
                this.updateHUD();

                // Calculate throw origin and direction
                const origin = state.player.position.clone();
                origin.y += 1.4; // Eye height

                const direction = new THREE.Vector3(0, 0, -1);
                direction.applyAxisAngle(new THREE.Vector3(0, 1, 0), state.player.rotation.y);
                direction.applyAxisAngle(new THREE.Vector3(1, 0, 0), state.player.rotation.x);
                direction.y += 0.15; // Slight upward arc

                // Add player velocity
                const velocity = direction.clone().multiplyScalar(this.GRENADE_THROW_FORCE);
                velocity.add(state.player.velocity.clone().multiplyScalar(0.3));

                const grenade = {
                    type: type,
                    mesh: this.getMesh(type),
                    position: origin.clone(),
                    velocity: velocity,
                    rotation: new THREE.Euler(Math.random() * Math.PI, Math.random() * Math.PI, 0),
                    rotationSpeed: new THREE.Vector3(
                        (Math.random() - 0.5) * 10,
                        (Math.random() - 0.5) * 10,
                        (Math.random() - 0.5) * 10
                    ),
                    fuseTime: type === 'frag' ? this.GRENADE_FUSE_TIME : 10.0,
                    isStuck: false,
                    stuckTo: null,
                    stuckOffset: null,
                    bounces: 0
                };

                grenade.mesh.position.copy(origin);
                this.activeGrenades.push(grenade);

                // Play throw sound
                ProceduralAudio.playGrenadeThrow();
                HapticFeedback.vibrate(20);

                return true;
            },

            update(delta) {
                for (let i = this.activeGrenades.length - 1; i >= 0; i--) {
                    const grenade = this.activeGrenades[i];

                    // Update fuse timer
                    grenade.fuseTime -= delta;

                    if (grenade.fuseTime <= 0) {
                        this.explode(grenade);
                        this.activeGrenades.splice(i, 1);
                        continue;
                    }

                    // If stuck (plasma), follow target
                    if (grenade.isStuck && grenade.stuckTo) {
                        grenade.position.copy(grenade.stuckTo.mesh.position);
                        grenade.position.add(grenade.stuckOffset);
                        grenade.mesh.position.copy(grenade.position);
                        continue;
                    }

                    // Apply physics
                    grenade.velocity.y -= this.GRENADE_GRAVITY * delta;

                    // Move grenade
                    grenade.position.addScaledVector(grenade.velocity, delta);

                    // Rotate grenade
                    grenade.rotation.x += grenade.rotationSpeed.x * delta;
                    grenade.rotation.y += grenade.rotationSpeed.y * delta;
                    grenade.rotation.z += grenade.rotationSpeed.z * delta;

                    // Ground collision
                    if (grenade.position.y < 0.1) {
                        grenade.position.y = 0.1;

                        if (grenade.type === 'frag') {
                            // Frag bounces
                            grenade.velocity.y = -grenade.velocity.y * 0.4;
                            grenade.velocity.x *= 0.7;
                            grenade.velocity.z *= 0.7;
                            grenade.rotationSpeed.multiplyScalar(0.7);
                            grenade.bounces++;

                            if (Math.abs(grenade.velocity.y) < 0.5) {
                                grenade.velocity.y = 0;
                            }

                            if (grenade.bounces === 1 || Math.abs(grenade.velocity.y) > 1) {
                                ProceduralAudio.playGrenadeBounce();
                            }
                        } else {
                            // Plasma sticks to ground
                            grenade.velocity.set(0, 0, 0);
                            grenade.rotationSpeed.set(0, 0, 0);
                            grenade.fuseTime = Math.min(grenade.fuseTime, 2.0);
                        }
                    }

                    // Arena wall collision
                    const distFromCenter = Math.sqrt(grenade.position.x ** 2 + grenade.position.z ** 2);
                    if (distFromCenter > state.arenaRadius - 0.5) {
                        // Push back inside
                        const pushDir = new THREE.Vector3(grenade.position.x, 0, grenade.position.z).normalize();
                        grenade.position.x = pushDir.x * (state.arenaRadius - 0.6);
                        grenade.position.z = pushDir.z * (state.arenaRadius - 0.6);

                        if (grenade.type === 'frag') {
                            // Reflect velocity
                            const dot = grenade.velocity.dot(pushDir);
                            grenade.velocity.sub(pushDir.multiplyScalar(2 * dot));
                            grenade.velocity.multiplyScalar(0.5);
                        } else {
                            grenade.velocity.set(0, 0, 0);
                            grenade.rotationSpeed.set(0, 0, 0);
                            grenade.fuseTime = Math.min(grenade.fuseTime, 2.0);
                        }
                    }

                    // Check enemy collision (for plasma sticky)
                    if (grenade.type === 'plasma' && !grenade.isStuck) {
                        this.checkEnemyStick(grenade);
                    }

                    // Update mesh
                    grenade.mesh.position.copy(grenade.position);
                    grenade.mesh.rotation.copy(grenade.rotation);
                }
            },

            checkEnemyStick(grenade) {
                const STICK_RADIUS_SQ = 1.0; // 1.0 * 1.0

                for (const enemy of state.enemies) {
                    if (grenade.isStuck) break;

                    const dx = grenade.position.x - enemy.mesh.position.x;
                    const dy = grenade.position.y - enemy.mesh.position.y - 1;
                    const dz = grenade.position.z - enemy.mesh.position.z;
                    const distSq = dx * dx + dy * dy + dz * dz;

                    if (distSq < STICK_RADIUS_SQ) {
                        grenade.isStuck = true;
                        grenade.stuckTo = enemy;
                        grenade.stuckOffset = new THREE.Vector3(dx, dy, dz);
                        grenade.fuseTime = 2.0; // 2 second fuse after stick

                        ProceduralAudio.playPlasmaStick();

                        // Visual feedback
                        addKillFeedEntry('Plasma stuck!', 0x00aaff);
                    }
                }
            },

            explode(grenade) {
                const pos = grenade.position;
                const damageRadiusSq = this.GRENADE_DAMAGE_RADIUS * this.GRENADE_DAMAGE_RADIUS;

                // Create explosion effect
                this.createExplosionEffect(pos, grenade.type);

                // Apply damage to enemies in radius
                for (const enemy of state.enemies) {
                    const dx = pos.x - enemy.mesh.position.x;
                    const dy = pos.y - enemy.mesh.position.y - 1;
                    const dz = pos.z - enemy.mesh.position.z;
                    const distSq = dx * dx + dy * dy + dz * dz;

                    if (distSq < damageRadiusSq) {
                        const dist = Math.sqrt(distSq);
                        const damagePercent = 1 - (dist / this.GRENADE_DAMAGE_RADIUS);
                        const damage = Math.floor(this.GRENADE_MAX_DAMAGE * damagePercent);

                        enemy.health -= damage * state.player.damage;

                        // Show damage number
                        createDamageNumber(enemy.mesh.position.clone().add(new THREE.Vector3(0, 2, 0)), damage, false);

                        // Knockback
                        const knockbackDir = new THREE.Vector3(-dx, 0.5, -dz).normalize();
                        enemy.velocity.addScaledVector(knockbackDir, damagePercent * 10);
                    }
                }

                // Apply self-damage to player
                const playerDx = pos.x - state.player.position.x;
                const playerDy = pos.y - state.player.position.y;
                const playerDz = pos.z - state.player.position.z;
                const playerDistSq = playerDx * playerDx + playerDy * playerDy + playerDz * playerDz;

                if (playerDistSq < damageRadiusSq) {
                    const dist = Math.sqrt(playerDistSq);
                    const damagePercent = 1 - (dist / this.GRENADE_DAMAGE_RADIUS);
                    const damage = Math.floor(this.GRENADE_MAX_DAMAGE * damagePercent * 0.5); // 50% self damage
                    damagePlayer(damage);
                }

                // Hide mesh
                grenade.mesh.visible = false;

                // Play explosion sound
                ProceduralAudio.playGrenadeExplosion(grenade.type);
                HapticFeedback.vibrate([50, 30, 30]);
            },

            createExplosionEffect(pos, type) {
                const color = type === 'plasma' ? 0x00aaff : 0xff6600;
                const secondaryColor = type === 'plasma' ? 0x0066aa : 0xffaa00;

                // Main explosion sphere
                const explosionGeom = new THREE.SphereGeometry(0.5, 16, 16);
                const explosionMat = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.8
                });
                const explosion = new THREE.Mesh(explosionGeom, explosionMat);
                explosion.position.copy(pos);
                scene.add(explosion);

                // Animate explosion
                const startTime = performance.now();
                const animateExplosion = () => {
                    const elapsed = (performance.now() - startTime) / 1000;
                    const progress = elapsed / 0.4;

                    if (progress >= 1) {
                        scene.remove(explosion);
                        explosionGeom.dispose();
                        explosionMat.dispose();
                        return;
                    }

                    explosion.scale.setScalar(1 + progress * 15);
                    explosion.material.opacity = 0.8 * (1 - progress);
                    requestAnimationFrame(animateExplosion);
                };
                animateExplosion();

                // Particles
                for (let i = 0; i < 20; i++) {
                    const particleGeom = new THREE.SphereGeometry(0.1, 4, 4);
                    const particleMat = new THREE.MeshBasicMaterial({
                        color: Math.random() > 0.5 ? color : secondaryColor,
                        transparent: true
                    });
                    const particle = new THREE.Mesh(particleGeom, particleMat);
                    particle.position.copy(pos);

                    const vel = new THREE.Vector3(
                        (Math.random() - 0.5) * 15,
                        Math.random() * 10 + 5,
                        (Math.random() - 0.5) * 15
                    );

                    scene.add(particle);
                    state.particles.push({
                        mesh: particle,
                        velocity: vel,
                        lifetime: 0.8 + Math.random() * 0.4
                    });
                }

                // Point light flash
                const light = new THREE.PointLight(color, 10, 20);
                light.position.copy(pos);
                scene.add(light);

                setTimeout(() => {
                    scene.remove(light);
                    light.dispose();
                }, 100);
            },

            updateHUD() {
                const fragEl = document.getElementById('grenade-frag-count');
                const plasmaEl = document.getElementById('grenade-plasma-count');
                if (fragEl) fragEl.textContent = state.player.grenades.frag;
                if (plasmaEl) plasmaEl.textContent = state.player.grenades.plasma;
            },

            reset() {
                // Clear active grenades
                for (const grenade of this.activeGrenades) {
                    grenade.mesh.visible = false;
                }
                this.activeGrenades = [];

                // Reset player grenade inventory
                state.player.grenades.frag = 2;
                state.player.grenades.plasma = 2;
                this.updateHUD();
            }
        };

        // Legacy audio system compatibility
        let audioContext;
        function initAudio() {
            ProceduralAudio.init();
            audioContext = ProceduralAudio.context;
        }

        function playSound(type) {
            if (!ProceduralAudio.context) ProceduralAudio.init();

            switch (type) {
                case 'plasma':
                case 'shotgun':
                case 'railgun':
                case 'rocket':
                    ProceduralAudio.playWeaponFire(type.toUpperCase());
                    break;
                case 'explosion':
                    ProceduralAudio.playExplosion();
                    break;
                case 'pickup':
                    ProceduralAudio.playPickup();
                    break;
                case 'reload':
                    ProceduralAudio.playReload();
                    break;
                case 'hit':
                    ProceduralAudio.playHit();
                    break;
            }
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // UI UPDATES
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function updateHealth() {
            // Update health bar
            const healthPercent = (state.player.health / state.player.maxHealth) * 100;
            document.getElementById('health-bar-inner').style.width = `${healthPercent}%`;
            document.getElementById('health-text').textContent = Math.ceil(state.player.health);

            // Update shield bar (Halo-style)
            const shieldPercent = (state.player.shields / state.player.maxShields) * 100;
            const shieldBar = document.getElementById('shield-bar-inner');
            if (shieldBar) {
                shieldBar.style.width = `${shieldPercent}%`;
            }
        }

        function updateAmmo() {
            const weapon = state.weapons[state.currentWeapon];
            document.getElementById('ammo-count').textContent = weapon.ammo;
            document.getElementById('ammo-max').textContent = `/ ${weapon.maxAmmo}`;
            document.getElementById('weapon-name').textContent = weapon.name;
        }

        function updateScore() {
            document.getElementById('score-display').textContent = state.score.toLocaleString();
        }

        function updateCombo() {
            const comboDisplay = document.getElementById('combo-display');
            const comboCount = document.getElementById('combo-count');
            const comboMultiplier = document.getElementById('combo-multiplier');

            if (state.combo > 1) {
                comboDisplay.classList.add('active');
                comboCount.textContent = state.combo;
                comboMultiplier.textContent = `x${(1 + state.combo * 0.1).toFixed(1)}`;
            } else {
                comboDisplay.classList.remove('active');
            }
        }

        function updateEnemyCount() {
            document.getElementById('enemy-count').textContent = `ENEMIES: ${state.enemies.length}`;
        }

        function showHitMarker() {
            const hitMarker = document.getElementById('hit-marker');
            hitMarker.style.opacity = '1';
            playSound('hit');
            setTimeout(() => { hitMarker.style.opacity = '0'; }, 100);
        }

        function showWaveAnnouncement(waveNum) {
            const announce = document.getElementById('wave-announce');
            document.getElementById('wave-number').textContent = waveNum;
            document.getElementById('wave-display').textContent = `WAVE ${waveNum}`;
            announce.classList.remove('show');
            void announce.offsetWidth;
            announce.classList.add('show');
        }

        function showBossWarning() {
            const warning = document.getElementById('boss-warning');
            warning.classList.remove('show');
            void warning.offsetWidth;
            warning.classList.add('show');
            vibrateController(1, 1, 2000);
        }

        function addKillFeed(enemyName, score) {
            const feed = document.getElementById('kill-feed');
            const entry = document.createElement('div');
            entry.className = 'kill-entry';
            entry.textContent = `${enemyName} +${score}`;
            feed.appendChild(entry);
            setTimeout(() => { if (entry.parentNode) entry.parentNode.removeChild(entry); }, 3000);
        }

        function addKillFeedEntry(message, color = 0x00ffff) {
            const feed = document.getElementById('kill-feed');
            const entry = document.createElement('div');
            entry.className = 'kill-entry';
            entry.textContent = message;
            entry.style.color = '#' + color.toString(16).padStart(6, '0');
            feed.appendChild(entry);
            setTimeout(() => { if (entry.parentNode) entry.parentNode.removeChild(entry); }, 3000);
        }

        function updateMinimap() {
            minimapCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            minimapCtx.fillRect(0, 0, 180, 180);

            const scale = 180 / (state.arenaRadius * 2);
            const centerX = 90;
            const centerY = 90;

            minimapCtx.strokeStyle = '#00ffff44';
            minimapCtx.lineWidth = 2;
            minimapCtx.beginPath();
            minimapCtx.arc(centerX, centerY, state.arenaRadius * scale, 0, Math.PI * 2);
            minimapCtx.stroke();

            minimapCtx.fillStyle = '#ff4444';
            for (const enemy of state.enemies) {
                const x = centerX + enemy.mesh.position.x * scale;
                const y = centerY + enemy.mesh.position.z * scale;
                minimapCtx.beginPath();
                minimapCtx.arc(x, y, enemy.type.isBoss ? 6 : 3, 0, Math.PI * 2);
                minimapCtx.fill();
            }

            minimapCtx.fillStyle = '#00ffff';
            const px = centerX + state.player.position.x * scale;
            const py = centerY + state.player.position.z * scale;
            minimapCtx.beginPath();
            minimapCtx.arc(px, py, 4, 0, Math.PI * 2);
            minimapCtx.fill();

            const dirX = Math.sin(state.player.rotation.y) * 10;
            const dirY = -Math.cos(state.player.rotation.y) * 10;
            minimapCtx.strokeStyle = '#00ffff';
            minimapCtx.lineWidth = 2;
            minimapCtx.beginPath();
            minimapCtx.moveTo(px, py);
            minimapCtx.lineTo(px + dirX, py + dirY);
            minimapCtx.stroke();
        }

        function setCursorMode(isPlaying) {
            document.body.classList.toggle('playing', isPlaying);
            document.body.classList.toggle('menu', !isPlaying);
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // UPGRADE SYSTEM
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        const UpgradePool = [
            { name: 'Health Boost', icon: '‚ù§Ô∏è', desc: '+25 Max Health', apply: () => { state.player.maxHealth += 25; state.player.health += 25; updateHealth(); }},
            { name: 'Damage Up', icon: '‚öîÔ∏è', desc: '+15% Damage', apply: () => { state.player.damage *= 1.15; }},
            { name: 'Speed Boost', icon: '‚ö°', desc: '+10% Move Speed', apply: () => { state.player.speed *= 1.1; }},
            { name: 'Critical Hit', icon: 'üí•', desc: '+5% Crit Chance', apply: () => { state.player.critChance += 0.05; }},
            { name: 'Armor', icon: 'üõ°Ô∏è', desc: '+5 Armor', apply: () => { state.player.armor += 5; }},
            { name: 'Rapid Fire', icon: 'üî•', desc: 'Faster Fire Rate', apply: () => { state.weapons.forEach(w => w.fireRate *= 0.9); }},
            { name: 'Extended Mag', icon: 'üì¶', desc: '+50% Ammo Capacity', apply: () => { state.weapons.forEach(w => { w.maxAmmo = Math.floor(w.maxAmmo * 1.5); w.ammo = w.maxAmmo; }); updateAmmo(); }},
            { name: 'Quick Reload', icon: 'üîÑ', desc: '-25% Reload Time', apply: () => { state.weapons.forEach(w => w.reloadTime *= 0.75); }}
        ];

        function showUpgradeScreen() {
            state.current = GameState.UPGRADE;
            document.getElementById('upgrade-screen').classList.remove('hidden');
            setCursorMode(false);

            const available = [...UpgradePool];
            state.upgrades = [];
            for (let i = 0; i < 3 && available.length > 0; i++) {
                const idx = Math.floor(Math.random() * available.length);
                state.upgrades.push(available.splice(idx, 1)[0]);
            }

            const grid = document.getElementById('upgrade-grid');
            grid.innerHTML = '';
            state.upgrades.forEach((upgrade, i) => {
                const card = document.createElement('div');
                card.className = `upgrade-card ${i === 0 ? 'selected' : ''}`;
                card.innerHTML = `
                    <div class="upgrade-icon">${upgrade.icon}</div>
                    <div class="upgrade-name">${upgrade.name}</div>
                    <div class="upgrade-desc">${upgrade.desc}</div>
                `;
                card.onclick = () => selectUpgrade(i);
                grid.appendChild(card);
            });

            state.upgradeSelection = 0;
        }

        function selectUpgrade(index) {
            const upgrade = state.upgrades[index];
            upgrade.apply();
            state.appliedUpgrades.push(upgrade);

            document.getElementById('upgrade-screen').classList.add('hidden');

            state.wave++;
            state.current = GameState.PLAYING;
            setCursorMode(true);
            spawnWave(state.wave);

            if (state.inputMode === InputMode.KEYBOARD) {
                canvas.requestPointerLock();
            }
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // MENU SYSTEM
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        let lastMenuInput = 0;

        function updateMenu(deltaTime) {
            const now = performance.now();
            const menuDebounce = 150;

            if (state.current === GameState.MENU) {
                const buttons = document.querySelectorAll('#title-screen .menu-button');

                if (state.input.menuMove.y !== 0 && now - lastMenuInput > menuDebounce) {
                    state.menuSelection += state.input.menuMove.y > 0 ? 1 : -1;
                    state.menuSelection = Math.max(0, Math.min(buttons.length - 1, state.menuSelection));
                    buttons.forEach((btn, i) => btn.classList.toggle('selected', i === state.menuSelection));
                    lastMenuInput = now;
                }

                if (state.input.select && !state.input.selectHeld) {
                    state.input.selectHeld = true;
                    if (state.menuSelection === 0) startGame();
                    else if (state.menuSelection === 1) loadGame();
                }
                if (!state.input.select) state.input.selectHeld = false;
            }

            if (state.current === GameState.PAUSED) {
                const buttons = document.querySelectorAll('#pause-screen .menu-button');

                if (state.input.menuMove.y !== 0 && now - lastMenuInput > menuDebounce) {
                    state.menuSelection += state.input.menuMove.y > 0 ? 1 : -1;
                    state.menuSelection = Math.max(0, Math.min(buttons.length - 1, state.menuSelection));
                    buttons.forEach((btn, i) => btn.classList.toggle('selected', i === state.menuSelection));
                    lastMenuInput = now;
                }

                if (state.input.select && !state.input.selectHeld) {
                    state.input.selectHeld = true;
                    if (state.menuSelection === 0) resumeGame();
                    else if (state.menuSelection === 1) restartGame();
                    else if (state.menuSelection === 2) quitToMenu();
                }
                if (!state.input.select) state.input.selectHeld = false;

                if (state.input.back && !state.input.backHeld) {
                    state.input.backHeld = true;
                    resumeGame();
                }
                if (!state.input.back) state.input.backHeld = false;
            }

            if (state.current === GameState.UPGRADE) {
                const cards = document.querySelectorAll('.upgrade-card');

                if (state.input.menuMove.x !== 0 && now - lastMenuInput > menuDebounce) {
                    state.upgradeSelection += state.input.menuMove.x > 0 ? 1 : -1;
                    state.upgradeSelection = Math.max(0, Math.min(cards.length - 1, state.upgradeSelection));
                    cards.forEach((card, i) => card.classList.toggle('selected', i === state.upgradeSelection));
                    lastMenuInput = now;
                }

                if (state.input.select && !state.input.selectHeld) {
                    state.input.selectHeld = true;
                    selectUpgrade(state.upgradeSelection);
                }
                if (!state.input.select) state.input.selectHeld = false;

                // Number keys for quick select
                if (state.input.weapon1) selectUpgrade(0);
                if (state.input.weapon2) selectUpgrade(1);
                if (state.input.weapon3) selectUpgrade(2);
            }

            if (state.current === GameState.GAMEOVER) {
                const buttons = document.querySelectorAll('#gameover-screen .menu-button');

                if (state.input.menuMove.y !== 0 && now - lastMenuInput > menuDebounce) {
                    state.menuSelection += state.input.menuMove.y > 0 ? 1 : -1;
                    state.menuSelection = Math.max(0, Math.min(buttons.length - 1, state.menuSelection));
                    buttons.forEach((btn, i) => btn.classList.toggle('selected', i === state.menuSelection));
                    lastMenuInput = now;
                }

                if (state.input.select && !state.input.selectHeld) {
                    state.input.selectHeld = true;
                    if (state.menuSelection === 0) restartGame();
                    else if (state.menuSelection === 1) quitToMenu();
                }
                if (!state.input.select) state.input.selectHeld = false;
            }

            // Pause toggle
            if (state.current === GameState.PLAYING && state.input.pause && !state.input.pauseHeld) {
                state.input.pauseHeld = true;
                pauseGame();
            }
            if (!state.input.pause) state.input.pauseHeld = false;
        }

        function showMenu() {
            state.current = GameState.MENU;
            document.getElementById('title-screen').classList.remove('hidden');
            document.getElementById('loading-screen').classList.add('hidden');
            state.menuSelection = 0;
            setCursorMode(false);
        }

        function startGame() {
            state.current = GameState.PLAYING;
            document.getElementById('title-screen').classList.add('hidden');
            setCursorMode(true);

            state.wave = 1;
            state.score = 0;
            state.combo = 0;
            state.player.health = state.player.maxHealth = 100;
            state.player.armor = 0;
            state.player.speed = 12;
            state.player.damage = 1;
            state.player.critChance = 0.1;
            state.player.position.set(0, 1.8, 0);
            state.player.rotation = { x: 0, y: 0 };
            state.appliedUpgrades = [];

            // Reset to 2-weapon loadout (Halo-style)
            state.weapons = [
                { ...AllWeapons['BR55'] },
                { ...AllWeapons['PLASMA RIFLE'] }
            ];
            state.currentWeapon = 0;

            state.enemies.forEach(e => scene.remove(e.mesh));
            state.enemies = [];
            state.projectiles.forEach(p => scene.remove(p.mesh));
            state.projectiles = [];
            state.particles.forEach(p => scene.remove(p.mesh));
            state.particles = [];
            state.pickups.forEach(p => scene.remove(p.mesh));
            state.pickups = [];
            state.weaponPickups.forEach(p => scene.remove(p.mesh));
            state.weaponPickups = [];

            // Reset player shields
            state.player.shields = state.player.maxShields;

            // Reset grenades
            GrenadeSystem.reset();

            updateHealth();
            updateAmmo();
            updateScore();
            updateEnemyCount();

            spawnWave(1);

            // Request pointer lock for keyboard/mouse users
            if (state.inputMode === InputMode.KEYBOARD) {
                canvas.requestPointerLock();
            }
        }

        function loadGame() {
            const save = localStorage.getItem('apex_save');
            if (save) {
                const data = JSON.parse(save);
                state.wave = data.wave;
                state.score = data.score;
            }
            startGame();
        }

        function pauseGame() {
            state.current = GameState.PAUSED;
            document.getElementById('pause-screen').classList.remove('hidden');
            state.menuSelection = 0;
            setCursorMode(false);
            document.exitPointerLock();
        }

        function resumeGame() {
            state.current = GameState.PLAYING;
            document.getElementById('pause-screen').classList.add('hidden');
            setCursorMode(true);

            if (state.inputMode === InputMode.KEYBOARD) {
                canvas.requestPointerLock();
            }
        }

        function restartGame() {
            document.getElementById('pause-screen').classList.add('hidden');
            document.getElementById('gameover-screen').classList.add('hidden');
            startGame();
        }

        function quitToMenu() {
            document.getElementById('pause-screen').classList.add('hidden');
            document.getElementById('gameover-screen').classList.add('hidden');

            state.enemies.forEach(e => scene.remove(e.mesh));
            state.enemies = [];
            state.projectiles.forEach(p => scene.remove(p.mesh));
            state.projectiles = [];

            showMenu();
        }

        function gameOver() {
            state.current = GameState.GAMEOVER;
            setCursorMode(false);

            if (state.score > state.highScore) {
                state.highScore = state.score;
                localStorage.setItem('apex_highscore', state.score.toString());
            }

            document.getElementById('final-wave').textContent = state.wave;
            document.getElementById('final-score').textContent = state.score.toLocaleString();
            document.getElementById('gameover-screen').classList.remove('hidden');

            state.menuSelection = 0;

            document.exitPointerLock();
            vibrateController(1, 1, 500);
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // MAIN GAME LOOP
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function gameLoop() {
            requestAnimationFrame(gameLoop);

            const deltaTime = Math.min(clock.getDelta(), 0.1);
            state.time += deltaTime;
            state.deltaTime = deltaTime;

            state.frameCount++;
            if (state.time - state.lastFpsUpdate > 0.5) {
                state.fps = Math.round(state.frameCount / (state.time - state.lastFpsUpdate));
                document.getElementById('fps-counter').textContent = `${state.fps} FPS`;
                state.frameCount = 0;
                state.lastFpsUpdate = state.time;
            }

            updateInput();

            if (state.current === GameState.PLAYING) {
                updatePlayer(deltaTime);
                updateEnemies(deltaTime);
                updateProjectiles(deltaTime);
                updateParticles(deltaTime);
                updatePickups(deltaTime);
                updateReload(deltaTime);
                updateViewmodel(deltaTime);
                updateMinimap();
                GrenadeSystem.update(deltaTime);
                updateWeaponPickups(deltaTime);
                AnimationQueue.update(deltaTime);

                if (state.combo > 0) {
                    state.comboTimer -= deltaTime;
                    if (state.comboTimer <= 0) {
                        state.combo = 0;
                        updateCombo();
                    }
                }
            }

            updateMenu(deltaTime);

            // Render main scene with post-processing
            composer.render();

            // Render weapon viewmodel on top (only during gameplay)
            if (state.current === GameState.PLAYING) {
                renderViewmodel();
            }
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // INITIALIZATION
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        async function init() {
            initThreeJS();
            initAudio();
            initViewmodelSystem();
            GrenadeSystem.init();

            // Set initial input mode based on saved preference (defaults to gamepad)
            const preferredMode = state.preferredInputMode === 'keyboard' ? InputMode.KEYBOARD : InputMode.GAMEPAD;
            setInputMode(preferredMode);

            // Load game assets from manifest
            console.log('[APEX] Loading game assets...');
            const manifestLoaded = await loadManifest();
            if (manifestLoaded) {
                initEnemyTypesFromManifest();
                console.log('[APEX] Game assets loaded successfully');
            } else {
                console.log('[APEX] Using fallback enemy types');
            }

            await new Promise(resolve => setTimeout(resolve, 2000));

            showMenu();
            gameLoop();
        }

        // Button click handlers
        document.getElementById('btn-start').onclick = startGame;
        document.getElementById('btn-continue').onclick = loadGame;
        document.getElementById('btn-resume').onclick = resumeGame;
        document.getElementById('btn-restart').onclick = restartGame;
        document.getElementById('btn-quit').onclick = quitToMenu;
        document.getElementById('btn-retry').onclick = restartGame;
        document.getElementById('btn-menu').onclick = quitToMenu;

        document.addEventListener('contextmenu', e => e.preventDefault());

        document.addEventListener('visibilitychange', () => {
            if (document.hidden && state.current === GameState.PLAYING) pauseGame();
        });

        init();
    </script>
</body>
</html>
