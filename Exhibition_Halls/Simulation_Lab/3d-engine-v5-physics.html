<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Physics Engine - Multiplayer P2P</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: #1a1a2e;
            color: #eee;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #menu-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(26, 26, 46, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        #menu-overlay.hidden {
            display: none;
        }

        .menu-title {
            font-size: 3em;
            margin-bottom: 30px;
            color: #00d4ff;
            text-shadow: 0 0 20px rgba(0, 212, 255, 0.5);
        }

        .menu-section {
            background: rgba(255, 255, 255, 0.1);
            padding: 30px;
            border-radius: 10px;
            margin: 10px;
            min-width: 400px;
        }

        .menu-section h3 {
            margin-bottom: 15px;
            color: #00d4ff;
        }

        input, button, select {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 5px;
            font-size: 1em;
        }

        input {
            background: rgba(255, 255, 255, 0.9);
            color: #1a1a2e;
            width: calc(100% - 10px);
        }

        button {
            background: #00d4ff;
            color: #1a1a2e;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }

        button:hover {
            background: #00a8cc;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 212, 255, 0.3);
        }

        button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }

        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            border-radius: 8px;
            font-family: monospace;
            font-size: 14px;
        }

        #chat-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 350px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 8px;
            z-index: 100;
        }

        #chat-messages {
            height: 150px;
            overflow-y: auto;
            padding: 10px;
            font-size: 12px;
        }

        .chat-message {
            margin: 5px 0;
            padding: 3px;
        }

        .chat-message.system {
            color: #00d4ff;
            font-style: italic;
        }

        #chat-input-container {
            display: flex;
            padding: 10px;
            gap: 5px;
        }

        #chat-input {
            flex: 1;
            padding: 8px;
            background: rgba(255, 255, 255, 0.9);
            border: none;
            border-radius: 4px;
            color: #1a1a2e;
        }

        #controls-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            border-radius: 8px;
            z-index: 100;
            max-width: 300px;
        }

        .control-group {
            margin: 10px 0;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            color: #00d4ff;
        }

        .slider {
            width: 100%;
        }

        #level-editor {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(26, 26, 46, 0.98);
            padding: 30px;
            border-radius: 10px;
            z-index: 200;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            display: none;
        }

        #level-editor.active {
            display: block;
        }

        .object-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }

        .object-item {
            background: rgba(0, 212, 255, 0.2);
            padding: 15px;
            border-radius: 5px;
            cursor: pointer;
            text-align: center;
            transition: all 0.3s;
        }

        .object-item:hover {
            background: rgba(0, 212, 255, 0.4);
            transform: scale(1.05);
        }

        .tab-container {
            display: flex;
            gap: 5px;
            margin-bottom: 20px;
        }

        .tab {
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            cursor: pointer;
        }

        .tab.active {
            background: #00d4ff;
            color: #1a1a2e;
        }

        #replay-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            z-index: 100;
            display: none;
        }

        #replay-controls.active {
            display: block;
        }

        .replay-button {
            margin: 5px;
            padding: 8px 15px;
            font-size: 12px;
        }

        #physics-debug {
            position: absolute;
            top: 150px;
            left: 20px;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px;
            border-radius: 8px;
            z-index: 100;
            font-family: monospace;
            font-size: 11px;
            max-width: 250px;
        }

        .physics-value {
            color: #00ff88;
        }

        .connection-status {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 20px;
            z-index: 100;
        }

        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-indicator.connected {
            background: #00ff88;
            box-shadow: 0 0 10px #00ff88;
        }

        .status-indicator.disconnected {
            background: #ff4444;
        }

        .material-selector {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
            margin: 10px 0;
        }

        .material-option {
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            text-align: center;
        }

        .material-option:hover {
            background: rgba(0, 212, 255, 0.3);
        }

        .material-option.selected {
            background: #00d4ff;
            color: #1a1a2e;
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
        }

        ::-webkit-scrollbar-thumb {
            background: #00d4ff;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <div id="menu-overlay">
        <h1 class="menu-title">3D Physics Engine</h1>

        <div class="menu-section">
            <h3>Multiplayer</h3>
            <input type="text" id="room-code" placeholder="Enter room code (leave empty to create)">
            <button id="join-room">Join/Create Room</button>
            <div id="peer-id-display"></div>
        </div>

        <div class="menu-section">
            <h3>Quick Start</h3>
            <button id="start-solo">Start Solo Mode</button>
            <button id="open-editor">Level Editor</button>
            <button id="load-level">Load Level</button>
        </div>
    </div>

    <div id="hud">
        <div>FPS: <span id="fps">60</span></div>
        <div>Physics Steps: <span id="physics-steps">0</span></div>
        <div>Objects: <span id="object-count">0</span></div>
        <div>Players: <span id="player-count">1</span></div>
        <div>Network Latency: <span id="latency">0ms</span></div>
    </div>

    <div id="physics-debug">
        <div><strong>Physics Debug</strong></div>
        <div>Timestep: <span class="physics-value">16.67ms</span></div>
        <div>Gravity: <span class="physics-value" id="gravity-val">-9.82</span></div>
        <div>Contacts: <span class="physics-value" id="contacts">0</span></div>
        <div>Constraints: <span class="physics-value" id="constraints">0</span></div>
        <div>Ragdolls: <span class="physics-value" id="ragdolls">0</span></div>
        <div>Vehicles: <span class="physics-value" id="vehicles">0</span></div>
    </div>

    <div class="connection-status">
        <span class="status-indicator disconnected" id="connection-indicator"></span>
        <span id="connection-text">Offline</span>
    </div>

    <div id="chat-panel">
        <div id="chat-messages"></div>
        <div id="chat-input-container">
            <input type="text" id="chat-input" placeholder="Type message...">
            <button onclick="sendChatMessage()">Send</button>
        </div>
    </div>

    <div id="controls-panel">
        <h3 style="margin-bottom: 15px;">Controls</h3>
        <div style="font-size: 11px; line-height: 1.6;">
            <strong>Movement:</strong> WASD<br>
            <strong>Jump:</strong> Space<br>
            <strong>Sprint:</strong> Shift<br>
            <strong>Look:</strong> Mouse<br>
            <strong>Spawn Object:</strong> E<br>
            <strong>Spawn Ragdoll:</strong> R<br>
            <strong>Spawn Vehicle:</strong> V<br>
            <strong>Grab/Throw:</strong> Left Click<br>
            <strong>Delete:</strong> Right Click<br>
            <strong>Editor:</strong> Tab<br>
        </div>
        <div class="control-group">
            <label>Gravity: <span id="gravity-display">-9.82</span></label>
            <input type="range" class="slider" id="gravity-slider" min="-20" max="0" step="0.1" value="-9.82">
        </div>
        <div class="control-group">
            <label>Time Scale: <span id="timescale-display">1.0</span></label>
            <input type="range" class="slider" id="timescale-slider" min="0.1" max="2" step="0.1" value="1">
        </div>
    </div>

    <div id="level-editor">
        <h2 style="margin-bottom: 20px;">Level Editor</h2>

        <div class="tab-container">
            <div class="tab active" onclick="switchEditorTab('objects')">Objects</div>
            <div class="tab" onclick="switchEditorTab('materials')">Materials</div>
            <div class="tab" onclick="switchEditorTab('save')">Save/Load</div>
        </div>

        <div id="editor-objects" class="editor-tab">
            <h3>Spawn Objects</h3>
            <div class="object-list">
                <div class="object-item" onclick="spawnEditorObject('cube')">
                    <div>üì¶</div>
                    <div>Cube</div>
                </div>
                <div class="object-item" onclick="spawnEditorObject('sphere')">
                    <div>‚öΩ</div>
                    <div>Sphere</div>
                </div>
                <div class="object-item" onclick="spawnEditorObject('cylinder')">
                    <div>üõ¢Ô∏è</div>
                    <div>Cylinder</div>
                </div>
                <div class="object-item" onclick="spawnEditorObject('platform')">
                    <div>üìã</div>
                    <div>Platform</div>
                </div>
                <div class="object-item" onclick="spawnEditorObject('ramp')">
                    <div>üìê</div>
                    <div>Ramp</div>
                </div>
                <div class="object-item" onclick="spawnEditorObject('ragdoll')">
                    <div>üßç</div>
                    <div>Ragdoll</div>
                </div>
                <div class="object-item" onclick="spawnEditorObject('vehicle')">
                    <div>üöó</div>
                    <div>Vehicle</div>
                </div>
                <div class="object-item" onclick="spawnEditorObject('destructible')">
                    <div>üí•</div>
                    <div>Destructible</div>
                </div>
            </div>
        </div>

        <div id="editor-materials" class="editor-tab" style="display: none;">
            <h3>Material Properties</h3>
            <div class="material-selector">
                <div class="material-option selected" onclick="selectMaterial('default')">Default</div>
                <div class="material-option" onclick="selectMaterial('bouncy')">Bouncy</div>
                <div class="material-option" onclick="selectMaterial('slippery')">Slippery</div>
                <div class="material-option" onclick="selectMaterial('sticky')">Sticky</div>
                <div class="material-option" onclick="selectMaterial('heavy')">Heavy</div>
                <div class="material-option" onclick="selectMaterial('light')">Light</div>
            </div>
            <div class="control-group">
                <label>Friction: <span id="friction-display">0.5</span></label>
                <input type="range" class="slider" id="friction-slider" min="0" max="1" step="0.05" value="0.5">
            </div>
            <div class="control-group">
                <label>Restitution: <span id="restitution-display">0.3</span></label>
                <input type="range" class="slider" id="restitution-slider" min="0" max="1" step="0.05" value="0.3">
            </div>
            <div class="control-group">
                <label>Density: <span id="density-display">1.0</span></label>
                <input type="range" class="slider" id="density-slider" min="0.1" max="10" step="0.1" value="1">
            </div>
        </div>

        <div id="editor-save" class="editor-tab" style="display: none;">
            <h3>Save Level</h3>
            <input type="text" id="level-name" placeholder="Level name">
            <button onclick="saveLevel()">Save to Browser</button>
            <button onclick="exportLevel()">Export JSON</button>

            <h3 style="margin-top: 20px;">Load Level</h3>
            <select id="saved-levels" style="width: calc(100% - 10px);">
                <option>No saved levels</option>
            </select>
            <button onclick="loadSavedLevel()">Load Selected</button>
            <button onclick="importLevel()">Import JSON</button>
            <input type="file" id="level-file-input" accept=".json" style="display: none;">
        </div>

        <button onclick="closeEditor()" style="margin-top: 20px; width: 100%;">Close Editor</button>
    </div>

    <div id="replay-controls">
        <h4>Replay Controls</h4>
        <button class="replay-button" onclick="toggleReplayPlayback()">Play/Pause</button>
        <button class="replay-button" onclick="stopReplay()">Stop</button>
        <button class="replay-button" onclick="exportReplay()">Export</button>
        <div style="margin-top: 10px;">
            <input type="range" id="replay-slider" min="0" max="100" value="0" style="width: 100%;">
        </div>
        <div style="margin-top: 5px; font-size: 11px;">
            Time: <span id="replay-time">0.00s</span> / <span id="replay-duration">0.00s</span>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cannon@0.6.2/build/cannon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/peerjs@1.4.7/dist/peerjs.min.js"></script>

    <script>
        // ===== CORE ENGINE =====
        class PhysicsEngine {
            constructor() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.getElementById('canvas-container').appendChild(this.renderer.domElement);

                // Physics world with deterministic settings
                this.world = new CANNON.World();
                this.world.gravity.set(0, -9.82, 0);
                this.world.broadphase = new CANNON.NaiveBroadphase();
                this.world.solver.iterations = 20; // High iteration count for accuracy
                this.world.solver.tolerance = 0.001;
                this.world.defaultContactMaterial.friction = 0.5;
                this.world.defaultContactMaterial.restitution = 0.3;
                this.world.allowSleep = true;

                // Fixed timestep for deterministic physics
                this.fixedTimeStep = 1.0 / 60.0;
                this.maxSubSteps = 10;
                this.timeScale = 1.0;

                this.objects = [];
                this.ragdolls = [];
                this.vehicles = [];
                this.materials = {};
                this.physicsMaterials = {};

                this.initMaterials();
                this.initLighting();
                this.initGround();

                // Player physics
                this.playerBody = new CANNON.Body({
                    mass: 70, // Realistic human mass
                    shape: new CANNON.Cylinder(0.3, 0.3, 1.8, 8),
                    fixedRotation: true,
                    linearDamping: 0.9,
                    angularDamping: 0.9
                });
                this.playerBody.position.set(0, 5, 10);
                this.world.addBody(this.playerBody);

                this.camera.position.set(0, 6.6, 10);

                this.keys = {};
                this.mouse = { x: 0, y: 0, grabbed: null };
                this.yaw = 0;
                this.pitch = 0;

                this.setupControls();
                this.setupPhysicsDebug();

                // Replay system
                this.isRecording = true;
                this.replayData = [];
                this.replayStartTime = Date.now();
                this.isReplaying = false;
                this.replayIndex = 0;

                // Network
                this.peer = null;
                this.connections = [];
                this.remotePlayers = {};
                this.roomCode = null;

                // Performance tracking
                this.lastTime = performance.now();
                this.frames = 0;
                this.physicsSteps = 0;

                window.addEventListener('resize', () => this.onResize());
            }

            initMaterials() {
                // Define physics materials with realistic properties
                const materialDefs = {
                    default: { friction: 0.5, restitution: 0.3 },
                    bouncy: { friction: 0.3, restitution: 0.9 },
                    slippery: { friction: 0.05, restitution: 0.1 },
                    sticky: { friction: 0.95, restitution: 0.1 },
                    heavy: { friction: 0.7, restitution: 0.2 },
                    light: { friction: 0.4, restitution: 0.5 }
                };

                for (const [name, props] of Object.entries(materialDefs)) {
                    this.physicsMaterials[name] = new CANNON.Material(name);

                    // Create contact material with ground
                    const contactMaterial = new CANNON.ContactMaterial(
                        this.physicsMaterials[name],
                        this.physicsMaterials.default || this.physicsMaterials[name],
                        {
                            friction: props.friction,
                            restitution: props.restitution,
                            contactEquationStiffness: 1e8,
                            contactEquationRelaxation: 3
                        }
                    );
                    this.world.addContactMaterial(contactMaterial);
                }

                // Three.js materials
                this.materials = {
                    default: new THREE.MeshStandardMaterial({ color: 0x4488ff }),
                    bouncy: new THREE.MeshStandardMaterial({ color: 0xff4488 }),
                    slippery: new THREE.MeshStandardMaterial({ color: 0x44ff88 }),
                    sticky: new THREE.MeshStandardMaterial({ color: 0xffaa44 }),
                    heavy: new THREE.MeshStandardMaterial({ color: 0x333333 }),
                    light: new THREE.MeshStandardMaterial({ color: 0xffffaa })
                };
            }

            initLighting() {
                const ambient = new THREE.AmbientLight(0xffffff, 0.4);
                this.scene.add(ambient);

                const directional = new THREE.DirectionalLight(0xffffff, 0.6);
                directional.position.set(50, 100, 50);
                directional.castShadow = true;
                directional.shadow.camera.left = -50;
                directional.shadow.camera.right = 50;
                directional.shadow.camera.top = 50;
                directional.shadow.camera.bottom = -50;
                directional.shadow.mapSize.width = 2048;
                directional.shadow.mapSize.height = 2048;
                this.scene.add(directional);

                this.scene.background = new THREE.Color(0x87ceeb);
                this.scene.fog = new THREE.Fog(0x87ceeb, 50, 200);
            }

            initGround() {
                const groundGeometry = new THREE.PlaneGeometry(200, 200);
                const groundMaterial = new THREE.MeshStandardMaterial({
                    color: 0x228822,
                    roughness: 0.8
                });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.receiveShadow = true;
                this.scene.add(ground);

                const groundShape = new CANNON.Plane();
                const groundBody = new CANNON.Body({
                    mass: 0,
                    material: this.physicsMaterials.default
                });
                groundBody.addShape(groundShape);
                groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
                this.world.addBody(groundBody);
            }

            setupControls() {
                document.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;

                    if (e.code === 'KeyE') this.spawnRandomObject();
                    if (e.code === 'KeyR') this.spawnRagdoll();
                    if (e.code === 'KeyV') this.spawnVehicle();
                    if (e.code === 'Tab') {
                        e.preventDefault();
                        this.toggleEditor();
                    }
                });

                document.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                });

                document.addEventListener('mousemove', (e) => {
                    if (document.pointerLockElement) {
                        this.yaw -= e.movementX * 0.002;
                        this.pitch -= e.movementY * 0.002;
                        this.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.pitch));
                    }
                });

                this.renderer.domElement.addEventListener('click', () => {
                    if (!document.pointerLockElement) {
                        this.renderer.domElement.requestPointerLock();
                    }
                });

                document.addEventListener('mousedown', (e) => {
                    if (e.button === 0) this.grabObject();
                    if (e.button === 2) this.deleteObject();
                });

                document.addEventListener('mouseup', (e) => {
                    if (e.button === 0 && this.mouse.grabbed) {
                        this.throwObject();
                    }
                });

                document.addEventListener('contextmenu', (e) => e.preventDefault());
            }

            setupPhysicsDebug() {
                document.getElementById('gravity-slider').addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    this.world.gravity.y = value;
                    document.getElementById('gravity-display').textContent = value.toFixed(2);
                    document.getElementById('gravity-val').textContent = value.toFixed(2);
                });

                document.getElementById('timescale-slider').addEventListener('input', (e) => {
                    this.timeScale = parseFloat(e.target.value);
                    document.getElementById('timescale-display').textContent = this.timeScale.toFixed(1);
                });

                document.getElementById('friction-slider').addEventListener('input', (e) => {
                    document.getElementById('friction-display').textContent = e.target.value;
                });

                document.getElementById('restitution-slider').addEventListener('input', (e) => {
                    document.getElementById('restitution-display').textContent = e.target.value;
                });

                document.getElementById('density-slider').addEventListener('input', (e) => {
                    document.getElementById('density-display').textContent = e.target.value;
                });
            }

            spawnRandomObject() {
                const types = ['cube', 'sphere', 'cylinder'];
                const type = types[Math.floor(Math.random() * types.length)];

                const position = this.camera.position.clone();
                const direction = new THREE.Vector3(0, 0, -1);
                direction.applyQuaternion(this.camera.quaternion);
                position.add(direction.multiplyScalar(3));

                this.spawnObject(type, position);
            }

            spawnObject(type, position, material = 'default') {
                let mesh, body, shape;
                const size = 0.5 + Math.random() * 0.5;

                const materialProps = this.physicsMaterials[material] || this.physicsMaterials.default;

                switch(type) {
                    case 'cube':
                        mesh = new THREE.Mesh(
                            new THREE.BoxGeometry(size, size, size),
                            this.materials[material]
                        );
                        shape = new CANNON.Box(new CANNON.Vec3(size/2, size/2, size/2));
                        break;
                    case 'sphere':
                        mesh = new THREE.Mesh(
                            new THREE.SphereGeometry(size/2, 16, 16),
                            this.materials[material]
                        );
                        shape = new CANNON.Sphere(size/2);
                        break;
                    case 'cylinder':
                        mesh = new THREE.Mesh(
                            new THREE.CylinderGeometry(size/2, size/2, size, 16),
                            this.materials[material]
                        );
                        shape = new CANNON.Cylinder(size/2, size/2, size, 16);
                        break;
                    case 'platform':
                        mesh = new THREE.Mesh(
                            new THREE.BoxGeometry(4, 0.2, 4),
                            this.materials[material]
                        );
                        shape = new CANNON.Box(new CANNON.Vec3(2, 0.1, 2));
                        break;
                    case 'ramp':
                        const rampGeom = new THREE.BoxGeometry(4, 0.2, 4);
                        mesh = new THREE.Mesh(rampGeom, this.materials[material]);
                        mesh.rotation.z = Math.PI / 6;
                        shape = new CANNON.Box(new CANNON.Vec3(2, 0.1, 2));
                        break;
                }

                mesh.castShadow = true;
                mesh.receiveShadow = true;
                this.scene.add(mesh);

                const density = parseFloat(document.getElementById('density-slider').value);
                const volume = size * size * size;
                const mass = volume * density;

                body = new CANNON.Body({
                    mass: mass,
                    material: materialProps,
                    linearDamping: 0.1,
                    angularDamping: 0.1
                });
                body.addShape(shape);
                body.position.set(position.x, position.y, position.z);

                // Add initial rotation for variety
                body.quaternion.setFromAxisAngle(
                    new CANNON.Vec3(Math.random(), Math.random(), Math.random()).unit(),
                    Math.random() * Math.PI
                );

                this.world.addBody(body);

                const obj = { mesh, body, type, material };
                this.objects.push(obj);

                this.broadcastObjectSpawn(obj);

                return obj;
            }

            spawnRagdoll() {
                const position = this.camera.position.clone();
                const direction = new THREE.Vector3(0, 0, -1);
                direction.applyQuaternion(this.camera.quaternion);
                position.add(direction.multiplyScalar(5));

                const ragdoll = this.createRagdoll(position);
                this.ragdolls.push(ragdoll);

                addChatMessage('Ragdoll spawned with realistic physics', 'system');
            }

            createRagdoll(position) {
                const parts = {
                    head: this.createRagdollPart('sphere', 0.15, 0.5, position, { y: 1.6 }),
                    torso: this.createRagdollPart('box', [0.4, 0.6, 0.25], 8, position, { y: 1.0 }),
                    pelvis: this.createRagdollPart('box', [0.35, 0.25, 0.25], 6, position, { y: 0.5 }),

                    leftUpperArm: this.createRagdollPart('cylinder', [0.08, 0.3], 1, position, { x: -0.35, y: 1.3 }),
                    rightUpperArm: this.createRagdollPart('cylinder', [0.08, 0.3], 1, position, { x: 0.35, y: 1.3 }),
                    leftLowerArm: this.createRagdollPart('cylinder', [0.06, 0.3], 0.8, position, { x: -0.35, y: 0.85 }),
                    rightLowerArm: this.createRagdollPart('cylinder', [0.06, 0.3], 0.8, position, { x: 0.35, y: 0.85 }),

                    leftUpperLeg: this.createRagdollPart('cylinder', [0.1, 0.4], 2, position, { x: -0.15, y: 0.15 }),
                    rightUpperLeg: this.createRagdollPart('cylinder', [0.1, 0.4], 2, position, { x: 0.15, y: 0.15 }),
                    leftLowerLeg: this.createRagdollPart('cylinder', [0.08, 0.4], 1.5, position, { x: -0.15, y: -0.3 }),
                    rightLowerLeg: this.createRagdollPart('cylinder', [0.08, 0.4], 1.5, position, { x: 0.15, y: -0.3 })
                };

                // Realistic joint constraints
                const constraints = [];

                // Head to torso (neck)
                constraints.push(this.createConstraint(parts.head.body, parts.torso.body,
                    { x: 0, y: -0.1, z: 0 }, { x: 0, y: 0.35, z: 0 },
                    { x: Math.PI/6, y: Math.PI/4, z: 0 }));

                // Torso to pelvis (spine)
                constraints.push(this.createConstraint(parts.torso.body, parts.pelvis.body,
                    { x: 0, y: -0.35, z: 0 }, { x: 0, y: 0.15, z: 0 },
                    { x: Math.PI/8, y: Math.PI/8, z: Math.PI/8 }));

                // Arms
                constraints.push(this.createConstraint(parts.torso.body, parts.leftUpperArm.body,
                    { x: -0.25, y: 0.25, z: 0 }, { x: 0, y: 0.15, z: 0 },
                    { x: Math.PI/3, y: Math.PI/2, z: Math.PI/3 }));
                constraints.push(this.createConstraint(parts.torso.body, parts.rightUpperArm.body,
                    { x: 0.25, y: 0.25, z: 0 }, { x: 0, y: 0.15, z: 0 },
                    { x: Math.PI/3, y: Math.PI/2, z: Math.PI/3 }));

                // Elbows
                constraints.push(this.createConstraint(parts.leftUpperArm.body, parts.leftLowerArm.body,
                    { x: 0, y: -0.15, z: 0 }, { x: 0, y: 0.15, z: 0 },
                    { x: 0, y: 0, z: Math.PI/2 }));
                constraints.push(this.createConstraint(parts.rightUpperArm.body, parts.rightLowerArm.body,
                    { x: 0, y: -0.15, z: 0 }, { x: 0, y: 0.15, z: 0 },
                    { x: 0, y: 0, z: Math.PI/2 }));

                // Legs
                constraints.push(this.createConstraint(parts.pelvis.body, parts.leftUpperLeg.body,
                    { x: -0.15, y: -0.15, z: 0 }, { x: 0, y: 0.2, z: 0 },
                    { x: Math.PI/3, y: Math.PI/6, z: Math.PI/6 }));
                constraints.push(this.createConstraint(parts.pelvis.body, parts.rightUpperLeg.body,
                    { x: 0.15, y: -0.15, z: 0 }, { x: 0, y: 0.2, z: 0 },
                    { x: Math.PI/3, y: Math.PI/6, z: Math.PI/6 }));

                // Knees
                constraints.push(this.createConstraint(parts.leftUpperLeg.body, parts.leftLowerLeg.body,
                    { x: 0, y: -0.2, z: 0 }, { x: 0, y: 0.2, z: 0 },
                    { x: Math.PI/2, y: 0, z: 0 }));
                constraints.push(this.createConstraint(parts.rightUpperLeg.body, parts.rightLowerLeg.body,
                    { x: 0, y: -0.2, z: 0 }, { x: 0, y: 0.2, z: 0 },
                    { x: Math.PI/2, y: 0, z: 0 }));

                return { parts, constraints };
            }

            createRagdollPart(type, size, mass, basePos, offset) {
                let mesh, shape;

                if (type === 'sphere') {
                    mesh = new THREE.Mesh(
                        new THREE.SphereGeometry(size, 16, 16),
                        new THREE.MeshStandardMaterial({ color: 0xffcc99 })
                    );
                    shape = new CANNON.Sphere(size);
                } else if (type === 'cylinder') {
                    const [radius, height] = size;
                    mesh = new THREE.Mesh(
                        new THREE.CylinderGeometry(radius, radius, height, 8),
                        new THREE.MeshStandardMaterial({ color: 0xffcc99 })
                    );
                    shape = new CANNON.Cylinder(radius, radius, height, 8);
                } else {
                    const [w, h, d] = size;
                    mesh = new THREE.Mesh(
                        new THREE.BoxGeometry(w, h, d),
                        new THREE.MeshStandardMaterial({ color: 0xffcc99 })
                    );
                    shape = new CANNON.Box(new CANNON.Vec3(w/2, h/2, d/2));
                }

                mesh.castShadow = true;
                this.scene.add(mesh);

                const body = new CANNON.Body({
                    mass: mass,
                    linearDamping: 0.3,
                    angularDamping: 0.3
                });
                body.addShape(shape);
                body.position.set(
                    basePos.x + (offset.x || 0),
                    basePos.y + (offset.y || 0),
                    basePos.z + (offset.z || 0)
                );
                this.world.addBody(body);

                return { mesh, body };
            }

            createConstraint(bodyA, bodyB, pivotA, pivotB, maxAngles) {
                const constraint = new CANNON.ConeTwistConstraint(bodyA, bodyB, {
                    pivotA: new CANNON.Vec3(pivotA.x, pivotA.y, pivotA.z),
                    pivotB: new CANNON.Vec3(pivotB.x, pivotB.y, pivotB.z),
                    axisA: new CANNON.Vec3(0, 1, 0),
                    axisB: new CANNON.Vec3(0, 1, 0),
                    angle: maxAngles.x,
                    twistAngle: maxAngles.z
                });
                this.world.addConstraint(constraint);
                return constraint;
            }

            spawnVehicle() {
                const position = this.camera.position.clone();
                const direction = new THREE.Vector3(0, 0, -1);
                direction.applyQuaternion(this.camera.quaternion);
                position.add(direction.multiplyScalar(8));

                const vehicle = this.createVehicle(position);
                this.vehicles.push(vehicle);

                addChatMessage('Vehicle spawned with realistic suspension', 'system');
            }

            createVehicle(position) {
                // Chassis
                const chassisMesh = new THREE.Mesh(
                    new THREE.BoxGeometry(2, 0.6, 4),
                    new THREE.MeshStandardMaterial({ color: 0xff4444 })
                );
                chassisMesh.castShadow = true;
                this.scene.add(chassisMesh);

                const chassisShape = new CANNON.Box(new CANNON.Vec3(1, 0.3, 2));
                const chassisBody = new CANNON.Body({ mass: 500 });
                chassisBody.addShape(chassisShape);
                chassisBody.position.set(position.x, position.y + 1, position.z);
                this.world.addBody(chassisBody);

                // Vehicle setup
                const vehicle = new CANNON.RaycastVehicle({
                    chassisBody: chassisBody,
                    indexRightAxis: 0,
                    indexUpAxis: 1,
                    indexForwardAxis: 2
                });

                // Wheel configuration with realistic physics
                const wheelOptions = {
                    radius: 0.4,
                    directionLocal: new CANNON.Vec3(0, -1, 0),
                    suspensionStiffness: 30,
                    suspensionRestLength: 0.3,
                    frictionSlip: 5,
                    dampingRelaxation: 2.3,
                    dampingCompression: 4.4,
                    maxSuspensionForce: 100000,
                    rollInfluence: 0.01,
                    axleLocal: new CANNON.Vec3(-1, 0, 0),
                    chassisConnectionPointLocal: new CANNON.Vec3(1, 0, 1),
                    maxSuspensionTravel: 0.3,
                    customSlidingRotationalSpeed: -30,
                    useCustomSlidingRotationalSpeed: true
                };

                // Add 4 wheels
                wheelOptions.chassisConnectionPointLocal.set(1, 0, 1.5);
                vehicle.addWheel(wheelOptions);

                wheelOptions.chassisConnectionPointLocal.set(-1, 0, 1.5);
                vehicle.addWheel(wheelOptions);

                wheelOptions.chassisConnectionPointLocal.set(1, 0, -1.5);
                vehicle.addWheel(wheelOptions);

                wheelOptions.chassisConnectionPointLocal.set(-1, 0, -1.5);
                vehicle.addWheel(wheelOptions);

                vehicle.addToWorld(this.world);

                // Wheel meshes
                const wheelMeshes = [];
                const wheelGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.3, 16);
                wheelGeometry.rotateZ(Math.PI / 2);

                for (let i = 0; i < 4; i++) {
                    const wheelMesh = new THREE.Mesh(
                        wheelGeometry,
                        new THREE.MeshStandardMaterial({ color: 0x333333 })
                    );
                    wheelMesh.castShadow = true;
                    this.scene.add(wheelMesh);
                    wheelMeshes.push(wheelMesh);
                }

                return {
                    vehicle,
                    chassisMesh,
                    wheelMeshes,
                    chassisBody
                };
            }

            grabObject() {
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera({ x: 0, y: 0 }, this.camera);

                for (const obj of this.objects) {
                    const intersects = raycaster.intersectObject(obj.mesh);
                    if (intersects.length > 0) {
                        this.mouse.grabbed = obj;
                        obj.body.wakeUp();
                        return;
                    }
                }
            }

            throwObject() {
                if (this.mouse.grabbed) {
                    const direction = new THREE.Vector3(0, 0, -1);
                    direction.applyQuaternion(this.camera.quaternion);

                    const force = direction.multiplyScalar(50 * this.mouse.grabbed.body.mass);
                    this.mouse.grabbed.body.velocity.set(force.x, force.y, force.z);
                    this.mouse.grabbed.body.angularVelocity.set(
                        (Math.random() - 0.5) * 10,
                        (Math.random() - 0.5) * 10,
                        (Math.random() - 0.5) * 10
                    );

                    this.mouse.grabbed = null;
                }
            }

            deleteObject() {
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera({ x: 0, y: 0 }, this.camera);

                for (let i = this.objects.length - 1; i >= 0; i--) {
                    const obj = this.objects[i];
                    const intersects = raycaster.intersectObject(obj.mesh);
                    if (intersects.length > 0) {
                        this.scene.remove(obj.mesh);
                        this.world.removeBody(obj.body);
                        this.objects.splice(i, 1);
                        return;
                    }
                }
            }

            updatePlayer(deltaTime) {
                const moveSpeed = this.keys['ShiftLeft'] ? 10 : 5;
                const jumpForce = 400;

                const forward = new THREE.Vector3(
                    -Math.sin(this.yaw),
                    0,
                    -Math.cos(this.yaw)
                );
                const right = new THREE.Vector3(
                    Math.cos(this.yaw),
                    0,
                    -Math.sin(this.yaw)
                );

                const velocity = new CANNON.Vec3(0, this.playerBody.velocity.y, 0);

                if (this.keys['KeyW']) {
                    velocity.x += forward.x * moveSpeed;
                    velocity.z += forward.z * moveSpeed;
                }
                if (this.keys['KeyS']) {
                    velocity.x -= forward.x * moveSpeed;
                    velocity.z -= forward.z * moveSpeed;
                }
                if (this.keys['KeyA']) {
                    velocity.x -= right.x * moveSpeed;
                    velocity.z -= right.z * moveSpeed;
                }
                if (this.keys['KeyD']) {
                    velocity.x += right.x * moveSpeed;
                    velocity.z += right.z * moveSpeed;
                }

                // Ground check for jumping
                const ray = new CANNON.Ray(
                    this.playerBody.position,
                    new CANNON.Vec3(this.playerBody.position.x, this.playerBody.position.y - 1, this.playerBody.position.z)
                );
                const result = new CANNON.RaycastResult();
                ray.intersectWorld(this.world, { result });

                if (this.keys['Space'] && result.hasHit && result.distance < 1.1) {
                    velocity.y = jumpForce / this.playerBody.mass;
                }

                this.playerBody.velocity.copy(velocity);

                // Update camera
                this.camera.position.set(
                    this.playerBody.position.x,
                    this.playerBody.position.y + 1.6,
                    this.playerBody.position.z
                );

                this.camera.quaternion.setFromEuler(new THREE.Euler(
                    this.pitch,
                    this.yaw,
                    0,
                    'YXZ'
                ));

                // Update grabbed object
                if (this.mouse.grabbed) {
                    const holdPos = this.camera.position.clone();
                    const direction = new THREE.Vector3(0, 0, -2);
                    direction.applyQuaternion(this.camera.quaternion);
                    holdPos.add(direction);

                    const force = new CANNON.Vec3(
                        (holdPos.x - this.mouse.grabbed.body.position.x) * 10,
                        (holdPos.y - this.mouse.grabbed.body.position.y) * 10,
                        (holdPos.z - this.mouse.grabbed.body.position.z) * 10
                    );
                    this.mouse.grabbed.body.applyForce(force, this.mouse.grabbed.body.position);
                }
            }

            updatePhysics(deltaTime) {
                const scaledDelta = deltaTime * this.timeScale;
                this.world.step(this.fixedTimeStep, scaledDelta, this.maxSubSteps);
                this.physicsSteps++;

                // Sync Three.js meshes with Cannon.js bodies
                for (const obj of this.objects) {
                    obj.mesh.position.copy(obj.body.position);
                    obj.mesh.quaternion.copy(obj.body.quaternion);
                }

                // Update ragdolls
                for (const ragdoll of this.ragdolls) {
                    for (const [name, part] of Object.entries(ragdoll.parts)) {
                        part.mesh.position.copy(part.body.position);
                        part.mesh.quaternion.copy(part.body.quaternion);
                    }
                }

                // Update vehicles
                for (const veh of this.vehicles) {
                    veh.chassisMesh.position.copy(veh.chassisBody.position);
                    veh.chassisMesh.quaternion.copy(veh.chassisBody.quaternion);

                    for (let i = 0; i < veh.vehicle.wheelInfos.length; i++) {
                        veh.vehicle.updateWheelTransform(i);
                        const transform = veh.vehicle.wheelInfos[i].worldTransform;
                        veh.wheelMeshes[i].position.copy(transform.position);
                        veh.wheelMeshes[i].quaternion.copy(transform.quaternion);
                    }
                }

                // Update physics debug
                document.getElementById('contacts').textContent = this.world.contacts.length;
                document.getElementById('constraints').textContent = this.world.constraints.length;
                document.getElementById('ragdolls').textContent = this.ragdolls.length;
                document.getElementById('vehicles').textContent = this.vehicles.length;
            }

            recordFrame() {
                if (!this.isRecording || this.isReplaying) return;

                const frame = {
                    time: (Date.now() - this.replayStartTime) / 1000,
                    player: {
                        position: this.playerBody.position.clone(),
                        quaternion: this.playerBody.quaternion.clone()
                    },
                    objects: this.objects.map(obj => ({
                        position: obj.body.position.clone(),
                        quaternion: obj.body.quaternion.clone(),
                        velocity: obj.body.velocity.clone(),
                        angularVelocity: obj.body.angularVelocity.clone()
                    }))
                };

                this.replayData.push(frame);
            }

            toggleEditor() {
                const editor = document.getElementById('level-editor');
                editor.classList.toggle('active');
            }

            broadcastObjectSpawn(obj) {
                if (this.connections.length === 0) return;

                const data = {
                    type: 'object_spawn',
                    objectType: obj.type,
                    material: obj.material,
                    position: obj.body.position,
                    quaternion: obj.body.quaternion
                };

                for (const conn of this.connections) {
                    if (conn.open) {
                        conn.send(data);
                    }
                }
            }

            broadcastPlayerPosition() {
                if (this.connections.length === 0) return;

                const data = {
                    type: 'player_position',
                    position: this.playerBody.position,
                    rotation: { yaw: this.yaw, pitch: this.pitch }
                };

                for (const conn of this.connections) {
                    if (conn.open) {
                        conn.send(data);
                    }
                }
            }

            onResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }

            update() {
                const currentTime = performance.now();
                const deltaTime = (currentTime - this.lastTime) / 1000;
                this.lastTime = currentTime;

                this.updatePlayer(deltaTime);
                this.updatePhysics(deltaTime);
                this.recordFrame();

                // Broadcast position periodically
                if (this.frames % 3 === 0) {
                    this.broadcastPlayerPosition();
                }

                this.renderer.render(this.scene, this.camera);

                // Update HUD
                this.frames++;
                if (this.frames % 60 === 0) {
                    document.getElementById('fps').textContent = Math.round(1 / deltaTime);
                    document.getElementById('physics-steps').textContent = this.physicsSteps;
                    document.getElementById('object-count').textContent = this.objects.length;
                    document.getElementById('player-count').textContent = 1 + this.connections.length;
                }

                requestAnimationFrame(() => this.update());
            }

            start() {
                document.getElementById('menu-overlay').classList.add('hidden');
                this.lastTime = performance.now();
                this.update();
            }
        }

        // ===== NETWORK =====
        class NetworkManager {
            constructor(engine) {
                this.engine = engine;
                this.peer = null;
                this.connections = [];
                this.roomCode = null;
            }

            async initPeer(roomCode) {
                return new Promise((resolve, reject) => {
                    const peerId = roomCode || 'physics-' + Math.random().toString(36).substr(2, 9);
                    this.peer = new Peer(peerId);
                    this.roomCode = peerId;

                    this.peer.on('open', (id) => {
                        addChatMessage(`Connected to network. Room code: ${id}`, 'system');
                        document.getElementById('peer-id-display').textContent = `Room Code: ${id}`;

                        updateConnectionStatus(true, 'Connected');

                        this.engine.peer = this.peer;
                        this.engine.roomCode = this.roomCode;

                        resolve(id);
                    });

                    this.peer.on('connection', (conn) => {
                        this.handleConnection(conn);
                    });

                    this.peer.on('error', (err) => {
                        console.error('Peer error:', err);
                        addChatMessage(`Network error: ${err.type}`, 'system');
                        reject(err);
                    });

                    // If roomCode provided, try to connect
                    if (roomCode && roomCode !== peerId) {
                        const conn = this.peer.connect(roomCode);
                        this.handleConnection(conn);
                    }
                });
            }

            handleConnection(conn) {
                conn.on('open', () => {
                    this.connections.push(conn);
                    this.engine.connections = this.connections;
                    addChatMessage(`Player connected: ${conn.peer}`, 'system');

                    // Send current world state
                    this.sendWorldState(conn);
                });

                conn.on('data', (data) => {
                    this.handleData(data, conn);
                });

                conn.on('close', () => {
                    const index = this.connections.indexOf(conn);
                    if (index > -1) {
                        this.connections.splice(index, 1);
                        this.engine.connections = this.connections;
                    }
                    addChatMessage(`Player disconnected: ${conn.peer}`, 'system');

                    // Remove remote player
                    if (this.engine.remotePlayers[conn.peer]) {
                        this.engine.scene.remove(this.engine.remotePlayers[conn.peer].mesh);
                        delete this.engine.remotePlayers[conn.peer];
                    }
                });
            }

            sendWorldState(conn) {
                const state = {
                    type: 'world_state',
                    objects: this.engine.objects.map(obj => ({
                        type: obj.type,
                        material: obj.material,
                        position: obj.body.position,
                        quaternion: obj.body.quaternion,
                        velocity: obj.body.velocity,
                        angularVelocity: obj.body.angularVelocity
                    }))
                };
                conn.send(state);
            }

            handleData(data, conn) {
                switch(data.type) {
                    case 'chat':
                        addChatMessage(data.message, data.sender);
                        break;

                    case 'player_position':
                        this.updateRemotePlayer(conn.peer, data);
                        break;

                    case 'object_spawn':
                        this.spawnRemoteObject(data);
                        break;

                    case 'world_state':
                        this.loadWorldState(data);
                        break;
                }
            }

            updateRemotePlayer(peerId, data) {
                if (!this.engine.remotePlayers[peerId]) {
                    // Create remote player mesh
                    const geometry = new THREE.CylinderGeometry(0.3, 0.3, 1.8, 8);
                    const material = new THREE.MeshStandardMaterial({ color: 0xff00ff });
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.castShadow = true;
                    this.engine.scene.add(mesh);

                    this.engine.remotePlayers[peerId] = { mesh };
                }

                const player = this.engine.remotePlayers[peerId];
                player.mesh.position.copy(data.position);

                const euler = new THREE.Euler(data.rotation.pitch, data.rotation.yaw, 0, 'YXZ');
                player.mesh.quaternion.setFromEuler(euler);
            }

            spawnRemoteObject(data) {
                const pos = new THREE.Vector3(data.position.x, data.position.y, data.position.z);
                this.engine.spawnObject(data.objectType, pos, data.material);
            }

            loadWorldState(data) {
                // Clear current objects
                for (const obj of this.engine.objects) {
                    this.engine.scene.remove(obj.mesh);
                    this.engine.world.removeBody(obj.body);
                }
                this.engine.objects = [];

                // Recreate objects from state
                for (const objData of data.objects) {
                    const pos = new THREE.Vector3(objData.position.x, objData.position.y, objData.position.z);
                    const obj = this.engine.spawnObject(objData.type, pos, objData.material);
                    obj.body.quaternion.copy(objData.quaternion);
                    obj.body.velocity.copy(objData.velocity);
                    obj.body.angularVelocity.copy(objData.angularVelocity);
                }
            }
        }

        // ===== LEVEL EDITOR =====
        function switchEditorTab(tab) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.editor-tab').forEach(t => t.style.display = 'none');

            event.target.classList.add('active');
            document.getElementById(`editor-${tab}`).style.display = 'block';
        }

        function spawnEditorObject(type) {
            const position = engine.camera.position.clone();
            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyQuaternion(engine.camera.quaternion);
            position.add(direction.multiplyScalar(5));

            const material = document.querySelector('.material-option.selected')?.textContent.toLowerCase() || 'default';

            if (type === 'ragdoll') {
                engine.spawnRagdoll();
            } else if (type === 'vehicle') {
                engine.spawnVehicle();
            } else if (type === 'destructible') {
                // Create destructible object (cluster of connected pieces)
                for (let i = 0; i < 8; i++) {
                    const offset = new THREE.Vector3(
                        (Math.random() - 0.5) * 2,
                        (Math.random() - 0.5) * 2,
                        (Math.random() - 0.5) * 2
                    );
                    engine.spawnObject('cube', position.clone().add(offset), material);
                }
            } else {
                engine.spawnObject(type, position, material);
            }
        }

        function selectMaterial(material) {
            document.querySelectorAll('.material-option').forEach(opt => opt.classList.remove('selected'));
            event.target.classList.add('selected');
        }

        function closeEditor() {
            document.getElementById('level-editor').classList.remove('active');
        }

        function saveLevel() {
            const name = document.getElementById('level-name').value || 'Untitled';

            const levelData = {
                name: name,
                timestamp: Date.now(),
                objects: engine.objects.map(obj => ({
                    type: obj.type,
                    material: obj.material,
                    position: {
                        x: obj.body.position.x,
                        y: obj.body.position.y,
                        z: obj.body.position.z
                    },
                    quaternion: {
                        x: obj.body.quaternion.x,
                        y: obj.body.quaternion.y,
                        z: obj.body.quaternion.z,
                        w: obj.body.quaternion.w
                    }
                }))
            };

            const levels = JSON.parse(localStorage.getItem('physics_levels') || '[]');
            levels.push(levelData);
            localStorage.setItem('physics_levels', JSON.stringify(levels));

            updateLevelList();
            addChatMessage(`Level "${name}" saved!`, 'system');
        }

        function exportLevel() {
            const name = document.getElementById('level-name').value || 'Untitled';

            const levelData = {
                name: name,
                timestamp: Date.now(),
                objects: engine.objects.map(obj => ({
                    type: obj.type,
                    material: obj.material,
                    position: {
                        x: obj.body.position.x,
                        y: obj.body.position.y,
                        z: obj.body.position.z
                    },
                    quaternion: {
                        x: obj.body.quaternion.x,
                        y: obj.body.quaternion.y,
                        z: obj.body.quaternion.z,
                        w: obj.body.quaternion.w
                    }
                }))
            };

            const blob = new Blob([JSON.stringify(levelData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${name}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function loadSavedLevel() {
            const select = document.getElementById('saved-levels');
            const index = select.selectedIndex;

            if (index < 0) return;

            const levels = JSON.parse(localStorage.getItem('physics_levels') || '[]');
            const level = levels[index];

            loadLevel(level);
        }

        function importLevel() {
            const input = document.getElementById('level-file-input');
            input.click();

            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    const level = JSON.parse(event.target.result);
                    loadLevel(level);
                };
                reader.readAsText(file);
            };
        }

        function loadLevel(levelData) {
            // Clear existing objects
            for (const obj of engine.objects) {
                engine.scene.remove(obj.mesh);
                engine.world.removeBody(obj.body);
            }
            engine.objects = [];

            // Spawn objects from level data
            for (const objData of levelData.objects) {
                const pos = new THREE.Vector3(objData.position.x, objData.position.y, objData.position.z);
                const obj = engine.spawnObject(objData.type, pos, objData.material);
                obj.body.quaternion.set(
                    objData.quaternion.x,
                    objData.quaternion.y,
                    objData.quaternion.z,
                    objData.quaternion.w
                );
            }

            addChatMessage(`Level "${levelData.name}" loaded!`, 'system');
        }

        function updateLevelList() {
            const levels = JSON.parse(localStorage.getItem('physics_levels') || '[]');
            const select = document.getElementById('saved-levels');

            select.innerHTML = '';

            if (levels.length === 0) {
                select.innerHTML = '<option>No saved levels</option>';
            } else {
                levels.forEach((level, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = level.name;
                    select.appendChild(option);
                });
            }
        }

        // ===== REPLAY SYSTEM =====
        function toggleReplayPlayback() {
            if (!engine.isReplaying) {
                startReplay();
            } else {
                pauseReplay();
            }
        }

        function startReplay() {
            if (engine.replayData.length === 0) {
                addChatMessage('No replay data available', 'system');
                return;
            }

            engine.isReplaying = true;
            engine.replayIndex = 0;
            document.getElementById('replay-controls').classList.add('active');

            addChatMessage('Replay started', 'system');
        }

        function pauseReplay() {
            engine.isReplaying = false;
            addChatMessage('Replay paused', 'system');
        }

        function stopReplay() {
            engine.isReplaying = false;
            engine.replayIndex = 0;
            document.getElementById('replay-controls').classList.remove('active');
            addChatMessage('Replay stopped', 'system');
        }

        function exportReplay() {
            const blob = new Blob([JSON.stringify(engine.replayData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `replay_${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // ===== CHAT =====
        function addChatMessage(message, sender = 'You') {
            const messagesDiv = document.getElementById('chat-messages');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'chat-message' + (sender === 'system' ? ' system' : '');
            messageDiv.textContent = `${sender}: ${message}`;
            messagesDiv.appendChild(messageDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        function sendChatMessage() {
            const input = document.getElementById('chat-input');
            const message = input.value.trim();

            if (!message) return;

            addChatMessage(message, 'You');

            // Broadcast to peers
            if (engine.connections.length > 0) {
                for (const conn of engine.connections) {
                    if (conn.open) {
                        conn.send({
                            type: 'chat',
                            message: message,
                            sender: engine.roomCode
                        });
                    }
                }
            }

            input.value = '';
        }

        function updateConnectionStatus(connected, text) {
            const indicator = document.getElementById('connection-indicator');
            const textEl = document.getElementById('connection-text');

            if (connected) {
                indicator.classList.add('connected');
                indicator.classList.remove('disconnected');
            } else {
                indicator.classList.remove('connected');
                indicator.classList.add('disconnected');
            }

            textEl.textContent = text;
        }

        // Allow Enter key to send messages
        document.getElementById('chat-input').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendChatMessage();
            }
        });

        // ===== INITIALIZATION =====
        let engine;
        let networkManager;

        document.getElementById('start-solo').addEventListener('click', () => {
            engine = new PhysicsEngine();
            networkManager = new NetworkManager(engine);
            engine.start();
            updateLevelList();
        });

        document.getElementById('join-room').addEventListener('click', async () => {
            const roomCode = document.getElementById('room-code').value.trim() || null;

            engine = new PhysicsEngine();
            networkManager = new NetworkManager(engine);

            try {
                await networkManager.initPeer(roomCode);
                engine.start();
                updateLevelList();
            } catch (err) {
                alert('Failed to connect: ' + err.message);
            }
        });

        document.getElementById('open-editor').addEventListener('click', () => {
            if (!engine) {
                engine = new PhysicsEngine();
                networkManager = new NetworkManager(engine);
                engine.start();
                updateLevelList();
            }
            engine.toggleEditor();
        });

        document.getElementById('load-level').addEventListener('click', () => {
            if (!engine) {
                engine = new PhysicsEngine();
                networkManager = new NetworkManager(engine);
                engine.start();
                updateLevelList();
            }

            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    const level = JSON.parse(event.target.result);
                    loadLevel(level);
                };
                reader.readAsText(file);
            };
            input.click();
        });

        // Initial message
        addChatMessage('Physics Engine initialized. Press E to spawn objects, R for ragdolls, V for vehicles.', 'system');
    </script>
</body>
</html>