<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Multiplayer Game Engine - Minimal MVP</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #fff;
            overflow: hidden;
        }

        #app {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        #header {
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #0f3460;
        }

        #header h1 {
            font-size: 20px;
            color: #00d4ff;
        }

        #controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        button {
            background: #0f3460;
            color: #fff;
            border: 1px solid #00d4ff;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }

        button:hover {
            background: #00d4ff;
            color: #1a1a2e;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        input {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #00d4ff;
            color: #fff;
            padding: 8px;
            border-radius: 4px;
            font-size: 14px;
        }

        #mainContent {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        #gameArea {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        #canvas {
            flex: 1;
            background: #0a0a0a;
            cursor: crosshair;
        }

        #sidebar {
            width: 300px;
            background: rgba(0, 0, 0, 0.7);
            border-left: 2px solid #0f3460;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .tab-buttons {
            display: flex;
            background: rgba(0, 0, 0, 0.5);
        }

        .tab-btn {
            flex: 1;
            padding: 10px;
            background: transparent;
            border: none;
            border-bottom: 2px solid transparent;
            color: #888;
        }

        .tab-btn.active {
            color: #00d4ff;
            border-bottom-color: #00d4ff;
        }

        .tab-content {
            display: none;
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }

        .tab-content.active {
            display: flex;
            flex-direction: column;
        }

        #chatMessages {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 10px;
            font-size: 12px;
            line-height: 1.6;
        }

        .chat-message {
            margin-bottom: 5px;
            padding: 5px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }

        .chat-input-area {
            display: flex;
            gap: 5px;
        }

        #chatInput {
            flex: 1;
        }

        #editorTools {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .tool-group {
            background: rgba(255, 255, 255, 0.05);
            padding: 10px;
            border-radius: 4px;
        }

        .tool-group h3 {
            font-size: 14px;
            margin-bottom: 10px;
            color: #00d4ff;
        }

        .tool-row {
            display: flex;
            gap: 5px;
            margin-bottom: 5px;
        }

        .tool-row label {
            flex: 1;
            font-size: 12px;
        }

        .tool-row input,
        .tool-row select {
            width: 100px;
        }

        #replayControls {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        #replayList {
            max-height: 200px;
            overflow-y: auto;
        }

        .replay-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 8px;
            margin-bottom: 5px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .replay-item:hover {
            background: rgba(0, 212, 255, 0.2);
        }

        #networkInfo {
            font-size: 12px;
            line-height: 1.8;
        }

        .info-item {
            margin-bottom: 10px;
            padding: 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }

        .info-label {
            color: #00d4ff;
            font-weight: bold;
        }

        #modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        #modal.active {
            display: flex;
        }

        .modal-content {
            background: #1a1a2e;
            padding: 30px;
            border-radius: 8px;
            border: 2px solid #00d4ff;
            max-width: 400px;
            width: 90%;
        }

        .modal-content h2 {
            margin-bottom: 20px;
            color: #00d4ff;
        }

        .modal-content input {
            width: 100%;
            margin-bottom: 15px;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        #gameInfo {
            position: absolute;
            top: 60px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
        }

        .color-picker {
            width: 50px !important;
            height: 30px;
            border: 1px solid #00d4ff;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="app">
        <div id="header">
            <h1>3D Multiplayer Game Engine - MVP</h1>
            <div id="controls">
                <button id="createRoomBtn">Create Room</button>
                <button id="joinRoomBtn">Join Room</button>
                <button id="exportBtn">Export Level</button>
                <button id="importBtn">Import Level</button>
                <span id="roomCode" style="margin-left: 10px; color: #00d4ff;"></span>
            </div>
        </div>

        <div id="mainContent">
            <div id="gameArea">
                <canvas id="canvas"></canvas>
                <div id="gameInfo">
                    <div>Controls: Arrow Keys to Move, Space to Jump</div>
                    <div>Editor: Click to Place Objects</div>
                    <div id="posInfo">Position: 0, 0, 0</div>
                    <div id="playerCount">Players: 1</div>
                </div>
            </div>

            <div id="sidebar">
                <div class="tab-buttons">
                    <button class="tab-btn active" data-tab="chat">Chat</button>
                    <button class="tab-btn" data-tab="editor">Editor</button>
                    <button class="tab-btn" data-tab="replay">Replay</button>
                    <button class="tab-btn" data-tab="network">Network</button>
                </div>

                <div id="chatTab" class="tab-content active">
                    <div id="chatMessages"></div>
                    <div class="chat-input-area">
                        <input type="text" id="chatInput" placeholder="Type message...">
                        <button id="sendChatBtn">Send</button>
                    </div>
                </div>

                <div id="editorTab" class="tab-content">
                    <div id="editorTools">
                        <div class="tool-group">
                            <h3>Object Properties</h3>
                            <div class="tool-row">
                                <label>Type:</label>
                                <select id="objType">
                                    <option value="cube">Cube</option>
                                    <option value="sphere">Sphere</option>
                                    <option value="platform">Platform</option>
                                </select>
                            </div>
                            <div class="tool-row">
                                <label>Size:</label>
                                <input type="number" id="objSize" value="1" min="0.5" max="5" step="0.5">
                            </div>
                            <div class="tool-row">
                                <label>Color:</label>
                                <input type="color" id="objColor" value="#ff6b6b" class="color-picker">
                            </div>
                            <div class="tool-row">
                                <label>Static:</label>
                                <input type="checkbox" id="objStatic" checked>
                            </div>
                        </div>

                        <div class="tool-group">
                            <h3>Actions</h3>
                            <button id="clearLevelBtn" style="width: 100%; margin-bottom: 5px;">Clear Level</button>
                            <button id="saveSnapshotBtn" style="width: 100%;">Save Snapshot</button>
                        </div>
                    </div>
                </div>

                <div id="replayTab" class="tab-content">
                    <div id="replayControls">
                        <div class="tool-group">
                            <h3>Recording</h3>
                            <button id="startRecordBtn" style="width: 100%; margin-bottom: 5px;">Start Recording</button>
                            <button id="stopRecordBtn" style="width: 100%;" disabled>Stop Recording</button>
                        </div>

                        <div class="tool-group">
                            <h3>Saved Replays</h3>
                            <div id="replayList"></div>
                        </div>
                    </div>
                </div>

                <div id="networkTab" class="tab-content">
                    <div id="networkInfo">
                        <div class="info-item">
                            <div class="info-label">Status:</div>
                            <div id="netStatus">Offline</div>
                        </div>
                        <div class="info-item">
                            <div class="info-label">Room Code:</div>
                            <div id="netRoomCode">-</div>
                        </div>
                        <div class="info-item">
                            <div class="info-label">Connected Peers:</div>
                            <div id="netPeers">0</div>
                        </div>
                        <div class="info-item">
                            <div class="info-label">Your ID:</div>
                            <div id="netPeerId">-</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="modal">
        <div class="modal-content">
            <h2 id="modalTitle">Room Code</h2>
            <input type="text" id="modalInput" placeholder="Enter room code...">
            <div class="modal-buttons">
                <button id="modalCancel">Cancel</button>
                <button id="modalConfirm">Confirm</button>
            </div>
        </div>
    </div>

    <input type="file" id="importFile" accept=".json" style="display: none;">

    <script>
        // ==================== SIMPLE 3D ENGINE ====================
        class Simple3DEngine {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.camera = { x: 0, y: 5, z: -10, rx: 0.3, ry: 0 };
                this.objects = [];
                this.fov = 500;

                this.resize();
                window.addEventListener('resize', () => this.resize());
            }

            resize() {
                this.canvas.width = this.canvas.offsetWidth;
                this.canvas.height = this.canvas.offsetHeight;
                this.centerX = this.canvas.width / 2;
                this.centerY = this.canvas.height / 2;
            }

            project(point) {
                // Translate relative to camera
                let x = point.x - this.camera.x;
                let y = point.y - this.camera.y;
                let z = point.z - this.camera.z;

                // Rotate around Y axis (camera yaw)
                let cosY = Math.cos(-this.camera.ry);
                let sinY = Math.sin(-this.camera.ry);
                let tempX = x * cosY - z * sinY;
                let tempZ = x * sinY + z * cosY;
                x = tempX;
                z = tempZ;

                // Rotate around X axis (camera pitch)
                let cosX = Math.cos(-this.camera.rx);
                let sinX = Math.sin(-this.camera.rx);
                let tempY = y * cosX - z * sinX;
                tempZ = y * sinX + z * cosX;
                y = tempY;
                z = tempZ;

                // Perspective projection
                if (z <= 0.1) z = 0.1; // Prevent division by zero

                let scale = this.fov / z;
                let x2d = x * scale + this.centerX;
                let y2d = -y * scale + this.centerY;

                return { x: x2d, y: y2d, scale, z };
            }

            clear() {
                this.ctx.fillStyle = '#0a0a0a';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Draw grid
                this.drawGrid();
            }

            drawGrid() {
                this.ctx.strokeStyle = 'rgba(0, 212, 255, 0.1)';
                this.ctx.lineWidth = 1;

                for (let i = -10; i <= 10; i++) {
                    let p1 = this.project({ x: i, y: 0, z: -10 });
                    let p2 = this.project({ x: i, y: 0, z: 10 });

                    if (p1.z > 0 && p2.z > 0) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(p1.x, p1.y);
                        this.ctx.lineTo(p2.x, p2.y);
                        this.ctx.stroke();
                    }

                    p1 = this.project({ x: -10, y: 0, z: i });
                    p2 = this.project({ x: 10, y: 0, z: i });

                    if (p1.z > 0 && p2.z > 0) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(p1.x, p1.y);
                        this.ctx.lineTo(p2.x, p2.y);
                        this.ctx.stroke();
                    }
                }
            }

            drawCube(obj) {
                const s = obj.size / 2;
                const vertices = [
                    { x: obj.x - s, y: obj.y - s, z: obj.z - s },
                    { x: obj.x + s, y: obj.y - s, z: obj.z - s },
                    { x: obj.x + s, y: obj.y + s, z: obj.z - s },
                    { x: obj.x - s, y: obj.y + s, z: obj.z - s },
                    { x: obj.x - s, y: obj.y - s, z: obj.z + s },
                    { x: obj.x + s, y: obj.y - s, z: obj.z + s },
                    { x: obj.x + s, y: obj.y + s, z: obj.z + s },
                    { x: obj.x - s, y: obj.y + s, z: obj.z + s },
                ];

                const projected = vertices.map(v => this.project(v));
                const faces = [
                    [0, 1, 2, 3], [4, 5, 6, 7], // front, back
                    [0, 1, 5, 4], [2, 3, 7, 6], // bottom, top
                    [0, 3, 7, 4], [1, 2, 6, 5]  // left, right
                ];

                // Calculate average Z for sorting
                const avgZ = projected.reduce((sum, p) => sum + p.z, 0) / projected.length;

                faces.forEach(face => {
                    const faceProjected = face.map(i => projected[i]);

                    this.ctx.fillStyle = obj.color || '#ff6b6b';
                    this.ctx.strokeStyle = '#fff';
                    this.ctx.lineWidth = 2;

                    this.ctx.beginPath();
                    this.ctx.moveTo(faceProjected[0].x, faceProjected[0].y);
                    for (let i = 1; i < faceProjected.length; i++) {
                        this.ctx.lineTo(faceProjected[i].x, faceProjected[i].y);
                    }
                    this.ctx.closePath();
                    this.ctx.globalAlpha = 0.7;
                    this.ctx.fill();
                    this.ctx.globalAlpha = 1;
                    this.ctx.stroke();
                });

                return avgZ;
            }

            drawSphere(obj) {
                const center = this.project(obj);
                if (center.z <= 0) return center.z;

                const radius = obj.size * center.scale * 0.5;

                this.ctx.fillStyle = obj.color || '#4ecdc4';
                this.ctx.strokeStyle = '#fff';
                this.ctx.lineWidth = 2;

                this.ctx.beginPath();
                this.ctx.arc(center.x, center.y, radius, 0, Math.PI * 2);
                this.ctx.globalAlpha = 0.7;
                this.ctx.fill();
                this.ctx.globalAlpha = 1;
                this.ctx.stroke();

                return center.z;
            }

            render() {
                this.clear();

                // Sort objects by distance (painter's algorithm)
                const renderList = this.objects.map(obj => {
                    const dx = obj.x - this.camera.x;
                    const dy = obj.y - this.camera.y;
                    const dz = obj.z - this.camera.z;
                    const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                    return { obj, distance };
                });

                renderList.sort((a, b) => b.distance - a.distance);

                // Render objects
                renderList.forEach(({ obj }) => {
                    if (obj.type === 'cube' || obj.type === 'platform') {
                        this.drawCube(obj);
                    } else if (obj.type === 'sphere') {
                        this.drawSphere(obj);
                    }
                });
            }

            addObject(obj) {
                this.objects.push(obj);
            }

            removeObject(obj) {
                const index = this.objects.indexOf(obj);
                if (index > -1) {
                    this.objects.splice(index, 1);
                }
            }

            clearObjects() {
                this.objects = [];
            }
        }

        // ==================== SIMPLE PHYSICS ====================
        class SimplePhysics {
            constructor() {
                this.gravity = -9.8;
                this.entities = [];
            }

            addEntity(entity) {
                if (!entity.velocity) entity.velocity = { x: 0, y: 0, z: 0 };
                if (entity.static === undefined) entity.static = false;
                this.entities.push(entity);
            }

            removeEntity(entity) {
                const index = this.entities.indexOf(entity);
                if (index > -1) {
                    this.entities.splice(index, 1);
                }
            }

            update(dt) {
                this.entities.forEach(entity => {
                    if (entity.static) return;

                    // Apply gravity
                    entity.velocity.y += this.gravity * dt;

                    // Update position
                    entity.x += entity.velocity.x * dt;
                    entity.y += entity.velocity.y * dt;
                    entity.z += entity.velocity.z * dt;

                    // Simple ground collision
                    if (entity.y < entity.size / 2) {
                        entity.y = entity.size / 2;
                        entity.velocity.y = 0;
                    }

                    // Friction
                    entity.velocity.x *= 0.9;
                    entity.velocity.z *= 0.9;
                });
            }

            checkCollision(a, b) {
                const dx = Math.abs(a.x - b.x);
                const dy = Math.abs(a.y - b.y);
                const dz = Math.abs(a.z - b.z);

                const minDist = (a.size + b.size) / 2;

                return dx < minDist && dy < minDist && dz < minDist;
            }
        }

        // ==================== WEBRTC P2P NETWORK ====================
        class P2PNetwork {
            constructor() {
                this.peers = new Map();
                this.hostPeer = null;
                this.roomCode = null;
                this.isHost = false;
                this.localId = this.generateId();
                this.onMessage = null;
                this.onPeerJoin = null;
                this.onPeerLeave = null;
            }

            generateId() {
                return Math.random().toString(36).substr(2, 9);
            }

            generateRoomCode() {
                return Math.random().toString(36).substr(2, 6).toUpperCase();
            }

            createRoom() {
                this.roomCode = this.generateRoomCode();
                this.isHost = true;

                // Simulate signaling server with localStorage
                const rooms = JSON.parse(localStorage.getItem('p2p_rooms') || '{}');
                rooms[this.roomCode] = {
                    host: this.localId,
                    created: Date.now()
                };
                localStorage.setItem('p2p_rooms', JSON.stringify(rooms));

                return this.roomCode;
            }

            joinRoom(roomCode) {
                this.roomCode = roomCode;
                this.isHost = false;

                const rooms = JSON.parse(localStorage.getItem('p2p_rooms') || '{}');
                if (!rooms[roomCode]) {
                    throw new Error('Room not found');
                }

                // In a real implementation, this would establish WebRTC connection
                // For MVP, we'll use localStorage for local multiplayer simulation
                this.simulateLocalConnection(roomCode);
            }

            simulateLocalConnection(roomCode) {
                // This is a simplified local-only multiplayer
                // In production, this would use actual WebRTC
                console.log(`Connected to room ${roomCode}`);
            }

            broadcast(data) {
                const message = {
                    from: this.localId,
                    data: data,
                    timestamp: Date.now()
                };

                // Store in localStorage for other tabs to read (basic local multiplayer)
                const messages = JSON.parse(localStorage.getItem(`room_${this.roomCode}_messages`) || '[]');
                messages.push(message);
                if (messages.length > 100) messages.shift();
                localStorage.setItem(`room_${this.roomCode}_messages`, JSON.stringify(messages));

                // Trigger storage event for other tabs
                window.dispatchEvent(new StorageEvent('storage', {
                    key: `room_${this.roomCode}_messages`
                }));
            }

            disconnect() {
                if (this.isHost && this.roomCode) {
                    const rooms = JSON.parse(localStorage.getItem('p2p_rooms') || '{}');
                    delete rooms[this.roomCode];
                    localStorage.setItem('p2p_rooms', JSON.stringify(rooms));
                }
                this.peers.clear();
                this.roomCode = null;
            }
        }

        // ==================== GAME ENGINE ====================
        class GameEngine {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.renderer = new Simple3DEngine(this.canvas);
                this.physics = new SimplePhysics();
                this.network = new P2PNetwork();

                this.player = {
                    id: this.network.localId,
                    x: 0,
                    y: 2,
                    z: 0,
                    size: 1,
                    color: '#00d4ff',
                    type: 'cube',
                    velocity: { x: 0, y: 0, z: 0 }
                };

                this.remotePlayers = new Map();
                this.levelObjects = [];

                this.keys = {};
                this.running = false;
                this.recording = false;
                this.replayFrames = [];
                this.replays = JSON.parse(localStorage.getItem('replays') || '[]');

                this.init();
            }

            init() {
                // Add player to renderer and physics
                this.renderer.addObject(this.player);
                this.physics.addEntity(this.player);

                // Create default level
                this.createDefaultLevel();

                // Setup input
                this.setupInput();

                // Setup network
                this.setupNetwork();

                // Start game loop
                this.running = true;
                this.lastTime = performance.now();
                this.gameLoop();
            }

            createDefaultLevel() {
                const platforms = [
                    { x: 0, y: -0.5, z: 0, size: 20, type: 'platform', color: '#2d4a3e', static: true },
                    { x: 5, y: 1, z: 5, size: 2, type: 'cube', color: '#ff6b6b', static: true },
                    { x: -5, y: 2, z: -5, size: 2, type: 'cube', color: '#4ecdc4', static: true },
                ];

                platforms.forEach(obj => this.addLevelObject(obj));
            }

            addLevelObject(obj) {
                this.levelObjects.push(obj);
                this.renderer.addObject(obj);
                this.physics.addEntity(obj);
            }

            removeLevelObject(obj) {
                const index = this.levelObjects.indexOf(obj);
                if (index > -1) {
                    this.levelObjects.splice(index, 1);
                    this.renderer.removeObject(obj);
                    this.physics.removeEntity(obj);
                }
            }

            clearLevel() {
                this.levelObjects.forEach(obj => {
                    this.renderer.removeObject(obj);
                    this.physics.removeEntity(obj);
                });
                this.levelObjects = [];
            }

            setupInput() {
                window.addEventListener('keydown', (e) => {
                    this.keys[e.key] = true;

                    if (e.key === ' ') {
                        e.preventDefault();
                        if (this.player.y <= this.player.size / 2 + 0.1) {
                            this.player.velocity.y = 5;
                        }
                    }
                });

                window.addEventListener('keyup', (e) => {
                    this.keys[e.key] = false;
                });

                // Canvas click for editor
                this.canvas.addEventListener('click', (e) => {
                    this.handleEditorClick(e);
                });
            }

            handleEditorClick(e) {
                const rect = this.canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                // Simple raycast - place object in front of camera
                const distance = 5;
                const x = this.renderer.camera.x + Math.sin(this.renderer.camera.ry) * distance;
                const z = this.renderer.camera.z + Math.cos(this.renderer.camera.ry) * distance;
                const y = this.renderer.camera.y - 2;

                const objType = document.getElementById('objType').value;
                const objSize = parseFloat(document.getElementById('objSize').value);
                const objColor = document.getElementById('objColor').value;
                const objStatic = document.getElementById('objStatic').checked;

                const newObj = {
                    x, y, z,
                    size: objSize,
                    type: objType,
                    color: objColor,
                    static: objStatic,
                    velocity: { x: 0, y: 0, z: 0 }
                };

                this.addLevelObject(newObj);
                this.broadcastState();
            }

            setupNetwork() {
                this.network.onMessage = (data) => {
                    this.handleNetworkMessage(data);
                };
            }

            handleNetworkMessage(data) {
                if (data.type === 'playerUpdate') {
                    let remotePlayer = this.remotePlayers.get(data.playerId);

                    if (!remotePlayer) {
                        remotePlayer = {
                            id: data.playerId,
                            x: data.x,
                            y: data.y,
                            z: data.z,
                            size: 1,
                            color: '#ff6b6b',
                            type: 'cube'
                        };
                        this.remotePlayers.set(data.playerId, remotePlayer);
                        this.renderer.addObject(remotePlayer);
                    } else {
                        remotePlayer.x = data.x;
                        remotePlayer.y = data.y;
                        remotePlayer.z = data.z;
                    }
                }
            }

            update(dt) {
                // Player movement
                const speed = 5;

                if (this.keys['ArrowLeft'] || this.keys['a']) {
                    this.player.velocity.x = -speed;
                }
                if (this.keys['ArrowRight'] || this.keys['d']) {
                    this.player.velocity.x = speed;
                }
                if (this.keys['ArrowUp'] || this.keys['w']) {
                    this.player.velocity.z = speed;
                }
                if (this.keys['ArrowDown'] || this.keys['s']) {
                    this.player.velocity.z = -speed;
                }

                // Update physics
                this.physics.update(dt);

                // Update camera to follow player
                this.renderer.camera.x = this.player.x;
                this.renderer.camera.y = this.player.y + 5;
                this.renderer.camera.z = this.player.z - 10;

                // Broadcast player position
                if (this.network.roomCode) {
                    this.network.broadcast({
                        type: 'playerUpdate',
                        playerId: this.player.id,
                        x: this.player.x,
                        y: this.player.y,
                        z: this.player.z
                    });
                }

                // Record frame
                if (this.recording) {
                    this.replayFrames.push(this.captureFrame());
                }

                // Update UI
                document.getElementById('posInfo').textContent =
                    `Position: ${this.player.x.toFixed(1)}, ${this.player.y.toFixed(1)}, ${this.player.z.toFixed(1)}`;
                document.getElementById('playerCount').textContent =
                    `Players: ${1 + this.remotePlayers.size}`;
            }

            render() {
                this.renderer.render();
            }

            gameLoop() {
                if (!this.running) return;

                const now = performance.now();
                const dt = Math.min((now - this.lastTime) / 1000, 0.1);
                this.lastTime = now;

                this.update(dt);
                this.render();

                requestAnimationFrame(() => this.gameLoop());
            }

            captureFrame() {
                return {
                    player: { ...this.player },
                    objects: this.levelObjects.map(obj => ({ ...obj })),
                    timestamp: Date.now()
                };
            }

            startRecording() {
                this.recording = true;
                this.replayFrames = [];
            }

            stopRecording() {
                this.recording = false;

                if (this.replayFrames.length > 0) {
                    const replay = {
                        id: Date.now(),
                        name: `Replay ${new Date().toLocaleString()}`,
                        frames: this.replayFrames,
                        duration: this.replayFrames.length
                    };

                    this.replays.push(replay);
                    localStorage.setItem('replays', JSON.stringify(this.replays));
                    this.updateReplayList();
                }

                this.replayFrames = [];
            }

            playReplay(replay) {
                if (!replay.frames || replay.frames.length === 0) return;

                let frameIndex = 0;
                const playInterval = setInterval(() => {
                    if (frameIndex >= replay.frames.length) {
                        clearInterval(playInterval);
                        return;
                    }

                    const frame = replay.frames[frameIndex];

                    // Restore player position
                    this.player.x = frame.player.x;
                    this.player.y = frame.player.y;
                    this.player.z = frame.player.z;

                    frameIndex++;
                }, 16); // ~60fps
            }

            updateReplayList() {
                const list = document.getElementById('replayList');
                list.innerHTML = '';

                this.replays.forEach(replay => {
                    const item = document.createElement('div');
                    item.className = 'replay-item';
                    item.textContent = `${replay.name} (${replay.duration} frames)`;
                    item.addEventListener('click', () => this.playReplay(replay));
                    list.appendChild(item);
                });
            }

            exportLevel() {
                const data = {
                    objects: this.levelObjects,
                    metadata: {
                        created: Date.now(),
                        version: '1.0'
                    }
                };

                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `level_${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
            }

            importLevel(file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        this.clearLevel();
                        data.objects.forEach(obj => this.addLevelObject(obj));
                    } catch (err) {
                        alert('Failed to import level: ' + err.message);
                    }
                };
                reader.readAsText(file);
            }

            broadcastState() {
                if (this.network.roomCode) {
                    this.network.broadcast({
                        type: 'levelUpdate',
                        objects: this.levelObjects
                    });
                }
            }
        }

        // ==================== UI CONTROLLER ====================
        class UIController {
            constructor(game) {
                this.game = game;
                this.modal = document.getElementById('modal');
                this.chatMessages = document.getElementById('chatMessages');
                this.messages = [];

                this.init();
            }

            init() {
                // Tab switching
                document.querySelectorAll('.tab-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const tab = btn.dataset.tab;
                        this.switchTab(tab);
                    });
                });

                // Create room
                document.getElementById('createRoomBtn').addEventListener('click', () => {
                    const roomCode = this.game.network.createRoom();
                    document.getElementById('roomCode').textContent = `Room: ${roomCode}`;
                    document.getElementById('netRoomCode').textContent = roomCode;
                    document.getElementById('netStatus').textContent = 'Host (Online)';
                    document.getElementById('netPeerId').textContent = this.game.network.localId;
                    this.addChatMessage('System', `Room created: ${roomCode}`);
                });

                // Join room
                document.getElementById('joinRoomBtn').addEventListener('click', () => {
                    this.showModal('Join Room', 'Enter room code:', (code) => {
                        try {
                            this.game.network.joinRoom(code);
                            document.getElementById('roomCode').textContent = `Room: ${code}`;
                            document.getElementById('netRoomCode').textContent = code;
                            document.getElementById('netStatus').textContent = 'Connected';
                            document.getElementById('netPeerId').textContent = this.game.network.localId;
                            this.addChatMessage('System', `Joined room: ${code}`);
                        } catch (err) {
                            alert(err.message);
                        }
                    });
                });

                // Export/Import
                document.getElementById('exportBtn').addEventListener('click', () => {
                    this.game.exportLevel();
                });

                document.getElementById('importBtn').addEventListener('click', () => {
                    document.getElementById('importFile').click();
                });

                document.getElementById('importFile').addEventListener('change', (e) => {
                    if (e.target.files.length > 0) {
                        this.game.importLevel(e.target.files[0]);
                    }
                });

                // Chat
                document.getElementById('sendChatBtn').addEventListener('click', () => {
                    this.sendChat();
                });

                document.getElementById('chatInput').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        this.sendChat();
                    }
                });

                // Editor
                document.getElementById('clearLevelBtn').addEventListener('click', () => {
                    if (confirm('Clear all level objects?')) {
                        this.game.clearLevel();
                        this.game.createDefaultLevel();
                    }
                });

                document.getElementById('saveSnapshotBtn').addEventListener('click', () => {
                    const snapshot = this.game.captureFrame();
                    localStorage.setItem('levelSnapshot', JSON.stringify(snapshot));
                    this.addChatMessage('System', 'Snapshot saved');
                });

                // Replay
                document.getElementById('startRecordBtn').addEventListener('click', () => {
                    this.game.startRecording();
                    document.getElementById('startRecordBtn').disabled = true;
                    document.getElementById('stopRecordBtn').disabled = false;
                    this.addChatMessage('System', 'Recording started');
                });

                document.getElementById('stopRecordBtn').addEventListener('click', () => {
                    this.game.stopRecording();
                    document.getElementById('startRecordBtn').disabled = false;
                    document.getElementById('stopRecordBtn').disabled = true;
                    this.addChatMessage('System', 'Recording stopped');
                });

                // Modal
                document.getElementById('modalCancel').addEventListener('click', () => {
                    this.hideModal();
                });

                // Initialize replay list
                this.game.updateReplayList();
            }

            switchTab(tab) {
                document.querySelectorAll('.tab-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.remove('active');
                });

                document.querySelector(`[data-tab="${tab}"]`).classList.add('active');
                document.getElementById(`${tab}Tab`).classList.add('active');
            }

            showModal(title, placeholder, callback) {
                document.getElementById('modalTitle').textContent = title;
                document.getElementById('modalInput').placeholder = placeholder;
                document.getElementById('modalInput').value = '';
                this.modal.classList.add('active');

                document.getElementById('modalConfirm').onclick = () => {
                    const value = document.getElementById('modalInput').value;
                    if (value) {
                        callback(value);
                        this.hideModal();
                    }
                };

                document.getElementById('modalInput').focus();
            }

            hideModal() {
                this.modal.classList.remove('active');
            }

            sendChat() {
                const input = document.getElementById('chatInput');
                const message = input.value.trim();

                if (message) {
                    this.addChatMessage('You', message);

                    if (this.game.network.roomCode) {
                        this.game.network.broadcast({
                            type: 'chat',
                            message: message,
                            from: this.game.network.localId
                        });
                    }

                    input.value = '';
                }
            }

            addChatMessage(sender, message) {
                const div = document.createElement('div');
                div.className = 'chat-message';
                div.innerHTML = `<strong>${sender}:</strong> ${message}`;
                this.chatMessages.appendChild(div);
                this.chatMessages.scrollTop = this.chatMessages.scrollHeight;
            }
        }

        // ==================== INITIALIZE ====================
        let game, ui;

        window.addEventListener('DOMContentLoaded', () => {
            game = new GameEngine();
            ui = new UIController(game);

            // Welcome message
            ui.addChatMessage('System', 'Welcome to 3D Multiplayer Game Engine!');
            ui.addChatMessage('System', 'Use Arrow Keys to move, Space to jump');
            ui.addChatMessage('System', 'Click canvas to place objects');
        });
    </script>
</body>
</html>