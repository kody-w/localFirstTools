<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Pokemon TCG GBA - Remastered</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');

        :root {
            --case-color: #3b2063;
            --case-shadow: #21103d;
            --screen-bg: #8bac0f;
        }

        body {
            background-color: #1a1a1a;
            color: #eee;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'VT323', monospace;
            overflow: hidden;
            user-select: none;
            /* Subtle floor texture */
            background-image: radial-gradient(#333 1px, transparent 1px);
            background-size: 20px 20px;
        }

        /* --- THE HARDWARE --- */
        #gba-case {
            background: linear-gradient(135deg, #462875 0%, #3b2063 100%);
            width: 600px;
            height: 380px;
            border-radius: 40px 40px 140px 140px;
            box-shadow: 
                0 20px 50px rgba(0,0,0,0.8), 
                inset 2px 2px 5px rgba(255,255,255,0.2),
                inset -5px -5px 15px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
            z-index: 1;
        }

        /* Shoulder Buttons */
        .shoulder-btn {
            position: absolute;
            top: -10px;
            width: 180px;
            height: 30px;
            background: #ccc;
            border-radius: 10px 10px 0 0;
            z-index: -1;
            box-shadow: inset 0 -5px 10px rgba(0,0,0,0.2);
        }
        .shoulder-left { left: 40px; }
        .shoulder-right { right: 40px; }

        #screen-lens {
            background-color: #2e2e33;
            margin-top: 30px;
            padding: 15px 40px 35px 40px; /* Extra bottom padding for text */
            border-radius: 15px 15px 50px 50px;
            box-shadow: inset 0 2px 8px rgba(0,0,0,0.8), 0 2px 5px rgba(255,255,255,0.05);
            position: relative;
        }

        .lens-logo {
            color: #a0a0a0;
            font-family: sans-serif;
            font-style: italic;
            font-weight: 800;
            font-size: 16px;
            position: absolute;
            bottom: 12px;
            right: 45px;
            letter-spacing: 1px;
            text-shadow: 1px 1px 2px #000;
        }
        .lens-logo span { color: #ce3655; }
        .lens-logo::before {
            content: 'NINTENDO';
            position: absolute;
            left: -320px; /* Rough positioning to left side */
            color: #555;
            font-size: 10px;
            font-weight: normal;
            border: 1px solid #555;
            padding: 1px 4px;
            border-radius: 10px;
        }

        .power-led {
            position: absolute;
            top: 40%;
            left: 15px;
            width: 8px;
            height: 8px;
            background-color: #333;
            border-radius: 50%;
            box-shadow: inset 1px 1px 2px #000;
        }
        .power-led.on {
            background-color: #0f0;
            box-shadow: 0 0 5px #0f0;
        }
        .power-label {
            position: absolute;
            top: 55%;
            left: 5px;
            font-family: sans-serif;
            font-size: 8px;
            color: #666;
            font-weight: bold;
        }

        /* --- THE SCREEN --- */
        .screen-container {
            position: relative;
            background: #000;
            border: 4px solid #111;
            border-radius: 4px;
            overflow: hidden;
        }

        canvas {
            display: block;
            background-color: #000;
            image-rendering: pixelated; /* Crucial for GBA look */
        }

        /* LCD Grid / Scanlines Effect */
        .scanlines {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(
                to bottom,
                rgba(255,255,255,0),
                rgba(255,255,255,0) 50%,
                rgba(0,0,0,0.1) 50%,
                rgba(0,0,0,0.1)
            );
            background-size: 100% 2px;
            pointer-events: none;
            opacity: 0.6;
        }

        /* --- CONTROLS GUIDE --- */
        .controls-guide {
            margin-top: 30px;
            color: #888;
            font-size: 14px;
            text-shadow: 0 2px 2px rgba(0,0,0,0.5);
        }
        .key {
            display: inline-block;
            background: #eee;
            color: #333;
            padding: 2px 6px;
            border-radius: 3px;
            font-weight: bold;
            font-family: sans-serif;
            font-size: 10px;
            box-shadow: 0 2px 0 #999;
            transform: translateY(-1px);
        }

        /* START/SELECT decoration */
        .start-select {
            display: flex;
            gap: 15px;
            margin-top: 10px;
        }
        .btn-pill {
            width: 40px;
            height: 12px;
            background: #555;
            border-radius: 10px;
            transform: rotate(-15deg);
            box-shadow: 1px 1px 2px #000;
        }
    </style>
</head>
<body>

    <div class="shoulder-btn shoulder-left"></div>
    <div class="shoulder-btn shoulder-right"></div>

    <div id="gba-case">
        <div id="screen-lens">
            <div class="power-led on"></div>
            <div class="power-label">POWER</div>
            
            <div class="screen-container">
                <canvas id="gameCanvas" width="240" height="160" style="width: 480px; height: 320px;"></canvas>
                <div class="scanlines"></div>
            </div>
            
            <div class="lens-logo">GAME BOY <span>ADVANCE</span></div>
        </div>

        <div class="start-select">
            <div class="btn-pill"></div>
            <div class="btn-pill"></div>
        </div>

        <div class="controls-guide">
            <span class="key">ARROWS</span> Move &nbsp; <span class="key">Z</span> A &nbsp; <span class="key">X</span> B &nbsp; <span class="key">ENTER</span> Start
        </div>
    </div>

<script>
/**
 * POKEMON TCG ENGINE - REMASTERED
 * Improved Architecture, Visuals, and Juice
 */

// --- ENGINE CONSTANTS & SETUP ---
const CANVAS = document.getElementById('gameCanvas');
const CTX = CANVAS.getContext('2d');
const SCREEN_W = 240;
const SCREEN_H = 160;

// Palette
const PAL = {
    FIRE: '#F08030', WATER: '#6890F0', GRASS: '#78C850', 
    LIGHTNING: '#F8D030', PSYCHIC: '#F85888', FIGHTING: '#C03028',
    NORMAL: '#A8A878', DARK: '#705848',
    BG_DARK: '#183848', BG_LIGHT: '#285870',
    CARD_BORDER: '#F8F818', CARD_BG: '#F8F8F8',
    UI_BASE: '#204060', UI_BORDER: '#A0B0C0', UI_TEXT: '#FFFFFF'
};

// --- DATA ---
const DB = {
    1:  { n:"Bulbasaur", hp:40, t:"GRASS", w:"FIRE", r:1, m:[["Tackle",1,10], ["Leech Seed",2,20]] },
    2:  { n:"Ivysaur", hp:60, t:"GRASS", w:"FIRE", r:2, m:[["Vine Whip",2,30], ["Poison Pwd",3,20]] },
    3:  { n:"Venusaur", hp:100, t:"GRASS", w:"FIRE", r:2, m:[["Solarbeam",4,60]] },
    4:  { n:"Charmander", hp:50, t:"FIRE", w:"WATER", r:1, m:[["Scratch",1,10], ["Ember",2,30]] },
    5:  { n:"Charmeleon", hp:80, t:"FIRE", w:"WATER", r:2, m:[["Slash",2,30], ["Flamethrower",3,50]] },
    6:  { n:"Charizard", hp:120, t:"FIRE", w:"WATER", r:3, m:[["Fire Spin",4,100]] },
    7:  { n:"Squirtle", hp:40, t:"WATER", w:"LIGHTNING", r:1, m:[["Bubble",1,10], ["Water Gun",2,20]] },
    8:  { n:"Wartortle", hp:70, t:"WATER", w:"LIGHTNING", r:2, m:[["Bite",2,20], ["Hydro Pump",3,40]] },
    9:  { n:"Blastoise", hp:100, t:"WATER", w:"LIGHTNING", r:3, m:[["Rain Dance",0,0], ["Hydro Pump",3,50]] },
    25: { n:"Pikachu", hp:40, t:"LIGHTNING", w:"FIGHTING", r:1, m:[["Gnaw",1,10], ["Thunder Jolt",2,30]] },
    26: { n:"Raichu", hp:80, t:"LIGHTNING", w:"FIGHTING", r:1, m:[["Agility",3,20], ["Thunder",4,60]] },
    150:{ n:"Mewtwo", hp:70, t:"PSYCHIC", w:"PSYCHIC", r:2, m:[["Psychic",2,20], ["Barrier",3,0]] },
    74: { n:"Geodude", hp:50, t:"FIGHTING", w:"GRASS", r:1, m:[["Rock Throw",1,10], ["Gravel",2,20]] },
    19: { n:"Rattata", hp:30, t:"NORMAL", w:"FIGHTING", r:0, m:[["Bite",1,20]] }
};

// --- INPUT SYSTEM ---
const Input = {
    keys: { Up:0, Down:0, Left:0, Right:0, A:0, B:0, Start:0 },
    prev: { Up:0, Down:0, Left:0, Right:0, A:0, B:0, Start:0 },
    
    update() {
        this.pressed = {};
        for(let k in this.keys) {
            this.pressed[k] = this.keys[k] && !this.prev[k];
            this.prev[k] = this.keys[k];
        }
    }
};

window.addEventListener('keydown', e => setKey(e.key, 1));
window.addEventListener('keyup', e => setKey(e.key, 0));

function setKey(k, s) {
    if(k==='ArrowUp') Input.keys.Up = s;
    if(k==='ArrowDown') Input.keys.Down = s;
    if(k==='ArrowLeft') Input.keys.Left = s;
    if(k==='ArrowRight') Input.keys.Right = s;
    if(k==='z' || k==='Z') Input.keys.A = s;
    if(k==='x' || k==='X') Input.keys.B = s;
    if(k==='Enter') Input.keys.Start = s;
}

// --- VISUAL FX SYSTEM ---
const FX = {
    shake: 0,
    flash: 0,
    particles: [],
    
    addDamage(x, y, dmg) {
        this.particles.push({x, y, txt: "-"+dmg, life: 60, vy: -1});
    },
    
    update() {
        if(this.shake > 0) this.shake--;
        if(this.flash > 0) this.flash--;
        
        for(let i=this.particles.length-1; i>=0; i--) {
            let p = this.particles[i];
            p.y += p.vy;
            p.life--;
            if(p.life <= 0) this.particles.splice(i, 1);
        }
    },
    
    draw(ctx) {
        ctx.save();
        // Flash overlay
        if(this.flash > 0) {
            ctx.fillStyle = `rgba(255,255,255,${this.flash/10})`;
            ctx.fillRect(0,0,SCREEN_W,SCREEN_H);
        }
        
        // Damage Text
        ctx.font = "14px VT323";
        ctx.shadowColor = "#000";
        ctx.shadowBlur = 0;
        ctx.shadowOffsetX = 1; ctx.shadowOffsetY = 1;
        
        this.particles.forEach(p => {
            ctx.fillStyle = `rgba(255,50,50,${p.life/20})`;
            ctx.fillText(p.txt, p.x, p.y);
        });
        
        ctx.restore();
    }
};

// --- GAME LOGIC ---
const STATE = { TITLE:0, BATTLE_MENU:1, BATTLE_MOVE:2, BATTLE_ANIM:3, GAMEOVER:4 };
let gameState = STATE.TITLE;
let frame = 0;
let bgOffset = 0;

let battle = {
    turn: 0, // 0: Player, 1: Enemy
    player: null,
    enemy: null,
    msg: "",
    msgTimer: 0,
    cursor: 0
};

function createPlayer() {
    return {
        active: generateCard(),
        bench: [generateCard(), generateCard()],
        prizes: 4
    };
}

function generateCard() {
    const keys = Object.keys(DB);
    const id = keys[Math.floor(Math.random() * keys.length)];
    const t = DB[id];
    return { id, ...t, curHp: t.hp, maxHp: t.hp, energy: 0 };
}

// --- MAIN LOOP ---
function loop() {
    Input.update();
    FX.update();
    bgOffset = (bgOffset + 0.5) % 20;
    
    update();
    
    // Rendering with Shake Offset
    CTX.save();
    if(FX.shake > 0) {
        let dx = (Math.random()*4-2) * (FX.shake/10);
        let dy = (Math.random()*4-2) * (FX.shake/10);
        CTX.translate(dx, dy);
    }
    
    draw();
    CTX.restore();
    
    // Draw FX on top of everything (ignores shake transform usually, but here mapped inside)
    FX.draw(CTX);
    
    frame++;
    requestAnimationFrame(loop);
}

function update() {
    if(battle.msgTimer > 0) battle.msgTimer--;

    switch(gameState) {
        case STATE.TITLE:
            if(Input.pressed.Start || Input.pressed.A) {
                battle.player = createPlayer();
                battle.enemy = createPlayer();
                battle.turn = 0;
                battle.cursor = 0;
                setMsg("Battle Start!", 60);
                gameState = STATE.BATTLE_MENU;
            }
            break;
            
        case STATE.BATTLE_MENU:
            if(battle.msgTimer > 0) return;
            
            if(battle.turn === 1) {
                // AI Turn
                setMsg("Enemy is thinking...", 40);
                gameState = STATE.BATTLE_ANIM;
                setTimeout(() => executeMove(battle.enemy, battle.player, 0), 1000);
                return;
            }

            if(Input.pressed.Up) battle.cursor = 0;
            if(Input.pressed.Down) battle.cursor = 1;
            
            if(Input.pressed.A) {
                if(battle.cursor === 0) { // Attack
                    gameState = STATE.BATTLE_MOVE;
                    battle.cursor = 0;
                } else { // End
                   endTurn();
                }
            }
            break;

        case STATE.BATTLE_MOVE:
            let moves = battle.player.active.m;
            if(Input.pressed.Up) battle.cursor = Math.max(0, battle.cursor-1);
            if(Input.pressed.Down) battle.cursor = Math.min(moves.length-1, battle.cursor+1);
            
            if(Input.pressed.B) {
                gameState = STATE.BATTLE_MENU;
                battle.cursor = 0;
            }
            
            if(Input.pressed.A) {
                executeMove(battle.player, battle.enemy, battle.cursor);
            }
            break;
            
        case STATE.GAMEOVER:
            if(Input.pressed.Start || Input.pressed.A) gameState = STATE.TITLE;
            break;
    }
}

function executeMove(attacker, defender, moveIdx) {
    gameState = STATE.BATTLE_ANIM;
    
    // Simple AI random move
    if(!attacker.active.m[moveIdx]) moveIdx = 0;
    
    let move = attacker.active.m[moveIdx];
    setMsg(`${attacker.active.n} used ${move[0]}!`, 60);
    
    setTimeout(() => {
        let dmg = move[2];
        let typeMod = "";
        
        // Weakness
        if(defender.active.w === attacker.active.t) {
            dmg *= 2;
            typeMod = " (Weakness!)";
            FX.flash = 15;
        }
        
        // Apply Damage
        defender.active.curHp -= dmg;
        FX.addDamage(
            battle.turn === 0 ? 160 : 60, // X pos based on target
            battle.turn === 0 ? 50 : 100, // Y pos
            dmg
        );
        FX.shake = 20;

        // Visual feedback based on result
        setTimeout(() => {
            if(defender.active.curHp <= 0) {
                defender.active.curHp = 0;
                handleFaint(attacker, defender);
            } else {
                endTurn();
            }
        }, 800);
        
    }, 800);
}

function handleFaint(winner, loser) {
    setMsg(`${loser.active.n} Fainted!`, 80);
    winner.prizes--;
    
    setTimeout(() => {
        if(winner.prizes === 0) {
            setMsg(winner === battle.player ? "YOU WON!" : "YOU LOST...", 9999);
            gameState = STATE.GAMEOVER;
        } else if(loser.bench.length === 0) {
            setMsg(winner === battle.player ? "Opponent has no Pokemon!" : "You have no Pokemon!", 9999);
            gameState = STATE.GAMEOVER;
        } else {
            // Swap
            loser.active = loser.bench.shift();
            endTurn();
        }
    }, 1500);
}

function endTurn() {
    battle.turn = battle.turn === 0 ? 1 : 0;
    battle.cursor = 0;
    setMsg(battle.turn === 0 ? "Your Turn" : "Enemy Turn", 40);
    gameState = STATE.BATTLE_MENU;
}

function setMsg(txt, time) {
    battle.msg = txt;
    battle.msgTimer = time;
}

// --- DRAWING ---

function draw() {
    // 1. Background (Scrolling Grid)
    CTX.fillStyle = PAL.BG_DARK;
    CTX.fillRect(0,0,SCREEN_W, SCREEN_H);
    
    CTX.strokeStyle = PAL.BG_LIGHT;
    CTX.lineWidth = 1;
    CTX.beginPath();
    for(let x=0; x<=SCREEN_W; x+=20) {
        CTX.moveTo(x, 0); CTX.lineTo(x-bgOffset, SCREEN_H); // Slanted
    }
    for(let y=0; y<=SCREEN_H; y+=20) {
        CTX.moveTo(0, y+bgOffset); CTX.lineTo(SCREEN_W, y+bgOffset);
    }
    CTX.stroke();

    if(gameState === STATE.TITLE) {
        drawTitle();
    } else {
        drawBattle();
    }
    
    // Message Bar
    if(battle.msgTimer > 0 || gameState === STATE.GAMEOVER) {
        CTX.fillStyle = "rgba(0,0,0,0.8)";
        CTX.fillRect(0, 130, SCREEN_W, 30);
        CTX.fillStyle = "#fff";
        CTX.textAlign = "center";
        CTX.fillText(battle.msg, SCREEN_W/2, 150);
    }
}

function drawTitle() {
    // Gradient BG
    let g = CTX.createLinearGradient(0,0,0,SCREEN_H);
    g.addColorStop(0,"#248"); g.addColorStop(1,"#002");
    CTX.fillStyle = g;
    CTX.fillRect(0,0,SCREEN_W, SCREEN_H);
    
    CTX.fillStyle = "#FFD700";
    CTX.font = "28px VT323";
    CTX.textAlign = "center";
    CTX.shadowColor = "#3a5eff";
    CTX.shadowBlur = 0;
    CTX.shadowOffsetX = 3; CTX.shadowOffsetY = 3;
    CTX.fillText("POKEMON TCG", SCREEN_W/2, 60);
    
    CTX.shadowColor = "transparent";
    CTX.fillStyle = "#FFF";
    CTX.font = "16px VT323";
    CTX.fillText("GBA REMASTER", SCREEN_W/2, 85);
    
    if(Math.floor(frame/30)%2===0) {
        CTX.fillStyle = "#FFFF00";
        CTX.fillText("PRESS START", SCREEN_W/2, 130);
    }
}

function drawBattle() {
    // Enemy
    drawCard(battle.enemy.active, 160, 20, false);
    drawBench(battle.enemy, 10, 10);
    drawHUD(battle.enemy.active, 10, 30);

    // Player
    drawCard(battle.player.active, 40, 70, true);
    drawBench(battle.player, 160, 135);
    drawHUD(battle.player.active, 130, 90);
    
    // Menus
    if(gameState === STATE.BATTLE_MENU || gameState === STATE.BATTLE_MOVE) {
        drawMenuBox();
    }
}

function drawMenuBox() {
    if(battle.turn !== 0) return;
    
    const x = 120, y = 100, w = 115, h = 55;
    
    // Box Body
    CTX.fillStyle = PAL.UI_BASE;
    CTX.strokeStyle = PAL.UI_BORDER;
    CTX.lineWidth = 2;
    CTX.fillRect(x, y, w, h);
    CTX.strokeRect(x, y, w, h);
    
    CTX.fillStyle = PAL.UI_TEXT;
    CTX.textAlign = "left";
    CTX.font = "14px VT323";
    CTX.shadowColor = "#000";
    CTX.shadowOffsetX = 1; CTX.shadowOffsetY = 1;
    
    let options = [];
    if(gameState === STATE.BATTLE_MENU) {
        options = ["ATTACK", "END TURN"];
    } else {
        options = battle.player.active.m.map(m => m[0]);
    }
    
    options.forEach((opt, i) => {
        let prefix = (battle.cursor === i) ? "> " : "  ";
        let color = (battle.cursor === i) ? "#FFF" : "#AAA";
        CTX.fillStyle = color;
        CTX.fillText(prefix + opt, x + 8, y + 20 + (i*15));
        
        // Draw Energy Cost circles for attacks
        if(gameState === STATE.BATTLE_MOVE && battle.player.active.m[i]) {
            let cost = battle.player.active.m[i][1];
            for(let e=0; e<cost; e++) {
                CTX.beginPath();
                CTX.arc(x + 95 + (e*6), y + 16 + (i*15), 2.5, 0, Math.PI*2);
                CTX.fillStyle = PAL[battle.player.active.t];
                CTX.fill();
            }
        }
    });
    CTX.shadowColor = "transparent";
}

function drawCard(card, x, y, isPlayer) {
    if(!card) return;
    const W = 48, H = 64;
    
    // Float Animation
    let floatY = isPlayer ? Math.sin(frame/20)*2 : Math.cos(frame/20)*2;
    y += floatY;

    // Shadow
    CTX.fillStyle = "rgba(0,0,0,0.5)";
    CTX.beginPath();
    CTX.ellipse(x+W/2, y+H+4, W/2, 4, 0, 0, Math.PI*2);
    CTX.fill();

    // Card Body
    CTX.fillStyle = PAL.CARD_BORDER;
    CTX.fillRect(x, y, W, H);
    
    // Inner Color (Type)
    CTX.fillStyle = PAL[card.t] || "#ccc";
    CTX.fillRect(x+2, y+2, W-4, H-4);
    
    // Art Box
    CTX.fillStyle = "#FFF";
    CTX.fillRect(x+4, y+10, W-8, 30);
    
    // Procedural Sprite (Symmetric Mirroring)
    drawSprite(card.id, x+W/2, y+25);
    
    // UI overlay on card
    CTX.fillStyle = "rgba(0,0,0,0.3)";
    CTX.fillRect(x+4, y+45, W-8, 14); // Text bg
    
    // HP Digits roughly on card
    CTX.fillStyle = "#FFF";
    CTX.font = "10px VT323";
    CTX.textAlign = "center";
    CTX.fillText(card.hp, x+W-10, y+10);
    
    // Type Icon
    CTX.beginPath();
    CTX.arc(x+8, y+8, 4, 0, Math.PI*2);
    CTX.fillStyle = PAL[card.t];
    CTX.fill();
    CTX.strokeStyle = "#000";
    CTX.stroke();
}

function drawSprite(id, cx, cy) {
    CTX.fillStyle = "#000";
    let seed = id * 12345;
    const blockSize = 3;
    
    // 5x5 grid mirrored to 10x5 (making a little monster)
    for(let y=-3; y<=3; y++) {
        for(let x=0; x<=3; x++) {
            seed = (seed * 9301 + 49297) % 233280;
            if(seed % 2 === 0) {
                // Draw Left
                CTX.fillRect(cx - (x*blockSize) - blockSize/2, cy + (y*blockSize), blockSize, blockSize);
                // Draw Right
                CTX.fillRect(cx + (x*blockSize) - blockSize/2, cy + (y*blockSize), blockSize, blockSize);
            }
        }
    }
}

function drawHUD(card, x, y) {
    if(!card) return;
    
    // Name Tag Background
    CTX.fillStyle = "rgba(0,0,0,0.6)";
    CTX.roundRect(x, y, 90, 25, 5);
    CTX.fill();
    
    // Name
    CTX.fillStyle = "#FFF";
    CTX.textAlign = "left";
    CTX.font = "12px VT323";
    CTX.fillText(card.n, x+5, y+12);
    
    // HP Bar Container
    CTX.fillStyle = "#333";
    CTX.fillRect(x+25, y+16, 60, 4);
    
    // HP Bar Fill
    let pct = card.curHp / card.maxHp;
    CTX.fillStyle = pct > 0.5 ? "#50e050" : (pct > 0.2 ? "#e0b020" : "#e03030");
    CTX.fillRect(x+25, y+16, 60*pct, 4);
    
    CTX.fillStyle = "#FFF";
    CTX.fillText("HP", x+5, y+19);
}

function drawBench(player, x, y) {
    player.bench.forEach((c, i) => {
        let bx = x + (i*14);
        CTX.fillStyle = PAL[c.t];
        CTX.fillRect(bx, y, 10, 14);
        CTX.strokeStyle = "#FFF";
        CTX.strokeRect(bx, y, 10, 14);
    });
    
    // Prizes
    for(let p=0; p<player.prizes; p++) {
        CTX.fillStyle = PAL.CARD_BORDER;
        let px = x + (p*8);
        let py = y + 20; 
        CTX.beginPath(); CTX.arc(px, py, 3, 0, Math.PI*2); CTX.fill();
    }
}

// Polyfill for roundRect if needed, though most browsers have it.
if (!CTX.roundRect) {
    CTX.roundRect = function(x, y, w, h, r) { CTX.fillRect(x,y,w,h); };
}

// Start
loop();

</script>
</body>
</html>