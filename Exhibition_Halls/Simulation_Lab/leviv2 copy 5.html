<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="description" content="LEVIATHAN OMNIVERSE - A 3D space exploration game with procedural galaxies, planets, combat, and RPG progression">
    <title>LEVIATHAN: OMNIVERSE v2.1</title>
    <style>
        /* ============================================
         * LEVIATHAN v2.0 - STREAMLINED CSS
         * Clean design token system
         * ============================================ */
        :root {
            /* Colors */
            --bg-dark: rgba(10, 15, 20, 0.95);
            --bg-panel: rgba(15, 20, 30, 0.95);
            --border-default: #445;
            --border-active: #0ff;
            --border-gold: #fb0;
            --text-primary: #fff;
            --text-muted: #aaa;
            --accent-cyan: #0ff;
            --accent-gold: #fb0;
            --accent-green: #0f8;
            --accent-red: #f44;
            --accent-purple: #bf00ff;

            /* Spacing */
            --space-1: 4px;
            --space-2: 8px;
            --space-3: 12px;
            --space-4: 16px;

            /* Typography */
            --font-sm: 12px;
            --font-base: 14px;
            --font-lg: 18px;

            /* Layout */
            --touch-min: 44px;
            --radius: 8px;
            --transition: 0.2s ease;

            /* Z-Index layers */
            --z-ui: 100;
            --z-panel: 200;
            --z-modal: 1000;
            --z-toast: 2000;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            position: fixed;
            overscroll-behavior: none;
        }

        body {
            font-family: 'Segoe UI', -apple-system, system-ui, sans-serif;
            background: #000;
            color: var(--text-primary);
            touch-action: none;
            -webkit-tap-highlight-color: transparent;
        }

        #container { position: absolute; inset: 0; }

        /* Loading Screen */
        .loading {
            position: fixed; inset: 0;
            background: #000;
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            z-index: 9999;
        }
        .loading-text { font-size: 24px; color: var(--accent-green); margin-bottom: 20px; }
        .loading-bar { width: 300px; height: 4px; background: #222; border-radius: 2px; overflow: hidden; }
        .loading-progress { height: 100%; background: var(--accent-green); animation: loadPulse 1s infinite; }
        @keyframes loadPulse { 0%, 100% { width: 20%; margin-left: 0; } 50% { width: 40%; margin-left: 60%; } }

        /* HUD */
        .hud { position: fixed; inset: 0; pointer-events: none; z-index: var(--z-ui); }
        .hud > * { pointer-events: auto; }

        .hud-top {
            position: absolute; top: 0; left: 0; right: 0;
            background: linear-gradient(to bottom, rgba(0,10,20,0.9), transparent);
            padding: var(--space-3);
            display: flex; justify-content: space-between; align-items: flex-start;
        }

        .game-title {
            font-family: Georgia, serif;
            font-size: clamp(18px, 4vw, 28px);
            color: var(--accent-cyan);
            text-shadow: 0 0 10px rgba(0,255,255,0.5);
            letter-spacing: 3px;
        }
        .subtitle { font-size: 11px; color: var(--text-muted); }

        .stats-box { display: flex; gap: 15px; text-align: right; }
        .stat-entry { display: flex; flex-direction: column; }
        .stat-val { font-size: 18px; color: var(--accent-green); font-weight: bold; }
        .stat-lbl { font-size: 10px; color: var(--text-muted); text-transform: uppercase; }

        /* Data Controls */
        .data-controls {
            position: fixed; top: 8px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 4px; z-index: var(--z-panel);
        }
        .data-controls button {
            background: rgba(0,255,255,0.15);
            border: 1px solid var(--accent-cyan);
            color: var(--accent-cyan);
            padding: 5px 10px;
            font-size: 11px;
            cursor: pointer;
            border-radius: var(--radius);
            transition: all var(--transition);
        }
        .data-controls button:hover { background: rgba(0,255,255,0.3); }

        /* Health Bar */
        /* v2.1: Enhanced Health/Energy Bar Container */
        .health-bar {
            position: fixed; top: 45px; left: 50%; transform: translateX(-50%);
            width: clamp(200px, 35vw, 320px);
            background: var(--bg-dark);
            border: 2px solid var(--accent-cyan);
            border-radius: var(--radius);
            padding: 8px 12px;
            display: none;
        }
        .health-fill {
            height: 8px;
            background: linear-gradient(to right, var(--accent-cyan), var(--accent-green));
            border-radius: 4px;
            transition: width 0.3s ease;
        }
        .health-text { text-align: right; font-size: 11px; margin-top: 4px; }

        /* v2.1: Energy Bar */
        .energy-container {
            margin-top: 6px;
        }
        .energy-fill {
            height: 6px;
            background: linear-gradient(to right, var(--accent-purple), #ff00ff);
            border-radius: 3px;
            transition: width 0.3s ease;
        }
        .energy-text { text-align: right; font-size: 10px; margin-top: 2px; color: var(--accent-purple); }

        /* v2.1: Style Meter */
        .style-meter {
            position: fixed; top: 130px; right: 20px;
            text-align: center;
            z-index: var(--z-ui);
            display: none;
            pointer-events: none;
        }
        .style-meter.visible { display: block; }
        .style-grade {
            font-size: 48px;
            font-weight: bold;
            font-family: Georgia, serif;
            text-shadow: 0 0 20px currentColor, 0 0 40px currentColor;
            animation: stylePulse 0.5s ease-out;
        }
        .style-grade.D { color: #888; }
        .style-grade.C { color: #fff; }
        .style-grade.B { color: #0ff; }
        .style-grade.A { color: #0f8; }
        .style-grade.S { color: #fb0; }
        .style-grade.SS { color: #f80; text-shadow: 0 0 30px #f80, 0 0 60px #f80; }
        .style-grade.SSS { color: #f0f; text-shadow: 0 0 40px #f0f, 0 0 80px #f0f; animation: stylePulse 0.3s infinite; }
        .style-label { font-size: 12px; color: var(--text-muted); letter-spacing: 2px; }
        .style-bar {
            width: 80px; height: 4px;
            background: #333;
            border-radius: 2px;
            margin: 5px auto;
            overflow: hidden;
        }
        .style-bar-fill {
            height: 100%;
            background: linear-gradient(to right, #888, var(--accent-gold));
            transition: width 0.2s;
        }
        @keyframes stylePulse {
            0% { transform: scale(1.3); }
            100% { transform: scale(1); }
        }

        /* v2.1: Combo Counter */
        .combo-display {
            position: fixed; top: 180px; left: 20px;
            z-index: var(--z-ui);
            display: none;
            pointer-events: none;
        }
        .combo-display.visible { display: block; }
        .combo-count {
            font-size: 42px;
            font-weight: bold;
            color: var(--accent-gold);
            text-shadow: 2px 2px 0 #000, -2px -2px 0 #000, 2px -2px 0 #000, -2px 2px 0 #000;
        }
        .combo-label { font-size: 14px; color: var(--accent-cyan); letter-spacing: 3px; }
        .combo-multiplier { font-size: 16px; color: var(--accent-green); margin-top: 2px; }

        /* v2.1: Kill Streak Display */
        .streak-display {
            position: fixed; top: 50%; right: 20px;
            transform: translateY(-50%);
            z-index: var(--z-ui);
            text-align: right;
            display: none;
            pointer-events: none;
        }
        .streak-display.visible { display: block; animation: streakSlide 0.3s ease-out; }
        .streak-count { font-size: 28px; color: var(--accent-red); font-weight: bold; }
        .streak-label { font-size: 11px; color: var(--text-muted); letter-spacing: 2px; }
        .streak-bonus { font-size: 14px; color: var(--accent-green); }
        @keyframes streakSlide {
            0% { transform: translateY(-50%) translateX(50px); opacity: 0; }
            100% { transform: translateY(-50%) translateX(0); opacity: 1; }
        }

        /* v2.1: Screen Shake */
        .screen-shake {
            animation: shake 0.15s ease-out;
        }
        @keyframes shake {
            0%, 100% { transform: translate(0, 0); }
            25% { transform: translate(-5px, 3px); }
            50% { transform: translate(5px, -3px); }
            75% { transform: translate(-3px, 5px); }
        }
        .screen-shake-heavy {
            animation: shakeHeavy 0.25s ease-out;
        }
        @keyframes shakeHeavy {
            0%, 100% { transform: translate(0, 0); }
            10% { transform: translate(-10px, 5px); }
            20% { transform: translate(10px, -5px); }
            30% { transform: translate(-8px, 8px); }
            40% { transform: translate(8px, -8px); }
            50% { transform: translate(-5px, 5px); }
            60% { transform: translate(5px, -5px); }
            70% { transform: translate(-3px, 3px); }
            80% { transform: translate(3px, -3px); }
        }

        /* v2.1: Hit Flash Overlay */
        .hit-flash {
            position: fixed; inset: 0;
            pointer-events: none;
            z-index: 998;
            opacity: 0;
            background: radial-gradient(ellipse at center, rgba(255,255,255,0.3) 0%, transparent 70%);
        }
        .hit-flash.active {
            animation: hitFlash 0.1s ease-out;
        }
        @keyframes hitFlash {
            0% { opacity: 1; }
            100% { opacity: 0; }
        }

        /* Panels */
        .panel {
            background: var(--bg-dark);
            border: 2px solid var(--border-default);
            border-radius: var(--radius);
            padding: var(--space-2);
        }
        .panel-title {
            color: var(--accent-gold);
            font-size: var(--font-sm);
            border-bottom: 1px solid var(--border-default);
            padding-bottom: var(--space-1);
            margin-bottom: var(--space-2);
        }

        /* Inventory */
        .inventory-panel {
            position: fixed; bottom: var(--space-3); left: 50%;
            transform: translateX(-50%) translateY(100%);
            width: 200px;
            opacity: 0;
            transition: all var(--transition);
        }
        .inventory-panel.visible { transform: translateX(-50%) translateY(0); opacity: 1; }
        .inv-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 4px; }
        .inv-slot {
            background: #1a1a1a;
            border: 1px solid #333;
            aspect-ratio: 1;
            display: flex; align-items: center; justify-content: center;
            font-size: 14px;
            cursor: pointer;
            border-radius: 3px;
            transition: all 0.1s;
        }
        .inv-slot:hover { border-color: var(--accent-gold); background: #2a2a2a; }
        .inv-count {
            position: absolute; bottom: 1px; right: 2px;
            font-size: 9px; font-weight: bold;
            text-shadow: 1px 1px 1px #000;
        }

        /* Skills Panel */
        .skills-panel {
            position: fixed; bottom: 60px; left: 0;
            width: 160px;
            transform: translateX(-100%);
            opacity: 0;
            border-left: none;
            border-radius: 0 var(--radius) var(--radius) 0;
            transition: all var(--transition);
        }
        .skills-panel.visible { transform: translateX(0); opacity: 1; }
        .skill-row { display: flex; justify-content: space-between; padding: 4px 0; font-size: 11px; }
        .skill-name { color: var(--text-muted); }
        .skill-level { color: var(--accent-gold); font-weight: bold; }

        /* RTS Toggle Buttons */
        .rts-toggles {
            position: fixed; bottom: var(--space-3); left: var(--space-3);
            display: flex; gap: var(--space-1);
            z-index: var(--z-panel);
        }
        .rts-btn {
            width: var(--touch-min); height: var(--touch-min);
            background: var(--bg-dark);
            border: 2px solid var(--border-default);
            border-radius: var(--radius);
            color: var(--accent-gold);
            font-size: 16px;
            cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            transition: all var(--transition);
        }
        .rts-btn:hover { border-color: var(--accent-gold); transform: translateY(-2px); }
        .rts-btn.active { border-color: var(--accent-cyan); background: rgba(0,255,255,0.1); }

        /* Ability Bar */
        .ability-bar {
            position: fixed; bottom: 100px; left: 50%; transform: translateX(-50%);
            display: none; gap: 8px;
        }
        .ability-bar.visible { display: flex; }
        .ability-btn {
            width: 50px; height: 50px;
            background: var(--bg-dark);
            border: 2px solid var(--border-default);
            border-radius: var(--radius);
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            cursor: pointer;
            position: relative;
            transition: all var(--transition);
        }
        .ability-btn:hover:not(.cooldown) { border-color: var(--accent-cyan); }
        .ability-btn.cooldown { opacity: 0.5; }
        .ability-icon { font-size: 20px; }
        .ability-key { font-size: 10px; color: var(--text-muted); }
        .ability-cd {
            position: absolute; inset: 0;
            background: rgba(0,0,0,0.7);
            border-radius: var(--radius);
            display: flex; align-items: center; justify-content: center;
            font-size: 14px; font-weight: bold;
            opacity: 0;
        }
        .ability-btn.cooldown .ability-cd { opacity: 1; }

        /* Minimap */
        .minimap {
            position: fixed; bottom: var(--space-3); right: var(--space-3);
            width: 120px; height: 120px;
            background: rgba(0,0,0,0.8);
            border: 2px solid rgba(0,255,255,0.3);
            border-radius: var(--radius);
            display: none;
            overflow: hidden;
        }
        .minimap.visible { display: block; }
        .minimap-canvas { width: 100%; height: 100%; }

        /* Notifications */
        .notification {
            position: fixed; top: 120px; left: 50%; transform: translateX(-50%);
            background: var(--bg-panel);
            border: 1px solid var(--accent-green);
            padding: var(--space-3) var(--space-4);
            border-radius: var(--radius);
            color: var(--accent-green);
            font-size: var(--font-base);
            z-index: var(--z-toast);
            animation: notifySlide 3s forwards;
            pointer-events: none;
        }
        @keyframes notifySlide {
            0% { opacity: 0; transform: translateX(-50%) translateY(-20px); }
            10% { opacity: 1; transform: translateX(-50%) translateY(0); }
            80% { opacity: 1; }
            100% { opacity: 0; }
        }

        /* Floating Damage Numbers */
        .floater {
            position: absolute;
            font-weight: bold;
            text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000, 0 0 8px #000;
            pointer-events: none;
            animation: floatUp 1.5s forwards;
            font-size: 16px;
            z-index: 1000;
        }
        @keyframes floatUp {
            0% { transform: translateY(0) scale(1.5); opacity: 1; }
            10% { transform: translateY(-5px) scale(1); opacity: 1; }
            70% { opacity: 1; }
            100% { transform: translateY(-70px) scale(0.85); opacity: 0; }
        }

        /* Modal */
        .modal-overlay {
            position: fixed; inset: 0;
            background: rgba(0,0,0,0.8);
            display: none; justify-content: center; align-items: center;
            z-index: var(--z-modal);
        }
        .modal-overlay.active { display: flex; }
        .modal-content {
            background: #1a1a2e;
            border: 2px solid var(--accent-cyan);
            border-radius: var(--radius);
            padding: 25px;
            max-width: 400px; width: 90%;
            max-height: 90vh;
            overflow-y: auto;
        }
        .modal-title { color: var(--accent-cyan); font-size: 20px; margin-bottom: 20px; }
        .modal-close {
            float: right;
            background: none; border: none;
            color: #fff; font-size: 24px;
            cursor: pointer;
        }

        /* Touch Controls */
        .touch-controls {
            display: none;
            position: fixed;
            z-index: var(--z-panel);
        }
        .virtual-joystick {
            position: fixed; bottom: 30px; left: 30px;
            width: 120px; height: 120px;
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 50%;
        }
        .joystick-knob {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 50px; height: 50px;
            background: rgba(255,255,255,0.3);
            border: 2px solid rgba(255,255,255,0.5);
            border-radius: 50%;
        }
        .touch-action-btn {
            position: fixed; bottom: 40px; right: 30px;
            width: 70px; height: 70px;
            background: rgba(0,255,136,0.3);
            border: 3px solid var(--accent-green);
            border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            font-size: 24px;
        }

        /* Low HP Warning */
        .low-hp-vignette {
            position: fixed; inset: 0;
            pointer-events: none;
            z-index: 999;
            opacity: 0;
            transition: opacity 0.3s;
            background: radial-gradient(ellipse at center, transparent 40%, rgba(180,0,0,0.4) 100%);
        }
        .low-hp-vignette.active { opacity: 1; animation: lowHpPulse 1.2s infinite; }
        @keyframes lowHpPulse { 0%, 100% { opacity: 0.6; } 50% { opacity: 1; } }

        /* Screen Reader */
        .sr-only {
            position: absolute; width: 1px; height: 1px;
            padding: 0; margin: -1px; overflow: hidden;
            clip: rect(0,0,0,0); white-space: nowrap; border: 0;
        }

        /* Instructions */
        .instructions {
            position: fixed; bottom: 80px; left: 50%; transform: translateX(-50%);
            background: var(--bg-dark);
            border: 1px solid var(--accent-cyan);
            padding: var(--space-2) var(--space-4);
            border-radius: var(--radius);
            z-index: var(--z-panel);
            text-align: center;
        }
        .instruction-text {
            color: var(--accent-cyan);
            font-size: var(--font-base);
        }
        .planet-name {
            color: var(--accent-gold);
            font-weight: bold;
            margin-top: 4px;
        }

        /* Planet Approach Overlay */
        .approach-overlay {
            position: fixed; inset: 0;
            pointer-events: none;
            z-index: var(--z-modal);
            opacity: 0;
            transition: opacity 0.5s;
        }
        .approach-overlay.active { opacity: 1; pointer-events: auto; }

        .letterbox-top, .letterbox-bottom {
            position: absolute; left: 0; right: 0;
            height: 0;
            background: #000;
            transition: height 0.8s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .letterbox-top { top: 0; }
        .letterbox-bottom { bottom: 0; }
        .approach-overlay.active .letterbox-top,
        .approach-overlay.active .letterbox-bottom { height: 60px; }

        .approach-info {
            position: absolute; bottom: 80px; left: 50%;
            transform: translateX(-50%);
            background: var(--bg-dark);
            border: 2px solid var(--accent-cyan);
            border-radius: var(--radius);
            padding: 20px 30px;
            min-width: 300px;
            text-align: center;
            opacity: 0;
            transform: translateX(-50%) translateY(20px);
            transition: all 0.5s 0.3s;
        }
        .approach-overlay.active .approach-info {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        .approach-planet-name {
            font-size: 24px;
            color: var(--accent-gold);
            margin-bottom: 8px;
            text-shadow: 0 0 10px rgba(255,187,0,0.5);
        }
        .approach-planet-type {
            font-size: 14px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        .approach-stats {
            display: flex; gap: 20px;
            justify-content: center;
            margin: 15px 0;
            padding: 10px;
            background: rgba(0,0,0,0.3);
            border-radius: 4px;
        }
        .approach-stat {
            text-align: center;
        }
        .approach-stat-val {
            font-size: 18px;
            color: var(--accent-cyan);
            font-weight: bold;
        }
        .approach-stat-lbl {
            font-size: 10px;
            color: var(--text-muted);
        }

        .approach-btn {
            background: linear-gradient(135deg, rgba(0,255,255,0.2), rgba(0,200,200,0.1));
            border: 2px solid var(--accent-cyan);
            color: var(--accent-cyan);
            padding: 12px 40px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            border-radius: var(--radius);
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-top: 10px;
        }
        .approach-btn:hover {
            background: linear-gradient(135deg, rgba(0,255,255,0.4), rgba(0,200,200,0.2));
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(0,255,255,0.3);
        }
        .approach-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .approach-skip {
            position: absolute; top: 80px; right: 20px;
            background: none;
            border: 1px solid rgba(255,255,255,0.3);
            color: var(--text-muted);
            padding: 8px 16px;
            font-size: 12px;
            cursor: pointer;
            border-radius: var(--radius);
            transition: all 0.2s;
        }
        .approach-skip:hover {
            border-color: var(--accent-cyan);
            color: var(--accent-cyan);
        }

        .approach-progress {
            position: absolute; bottom: 70px; left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 3px;
            background: rgba(255,255,255,0.2);
            border-radius: 2px;
            overflow: hidden;
        }
        .approach-progress-bar {
            height: 100%;
            background: var(--accent-cyan);
            width: 0%;
            transition: width 0.1s;
        }

        /* Focus visible */
        *:focus-visible { outline: 2px solid var(--accent-cyan); outline-offset: 2px; }

        /* Reduced motion */
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* Mobile */
        @media (pointer: coarse) {
            button, .interactive { min-height: var(--touch-min); min-width: var(--touch-min); }
            .touch-controls { display: block; }
        }
    </style>
</head>
<body>
    <!-- Accessibility -->
    <a href="#main-game" class="sr-only">Skip to game</a>
    <div id="sr-announcements" aria-live="polite" aria-atomic="true" class="sr-only"></div>

    <!-- Loading Screen -->
    <div class="loading" id="loading">
        <div class="loading-text">INITIALIZING LEVIATHAN...</div>
        <div class="loading-bar"><div class="loading-progress"></div></div>
    </div>

    <!-- Main Game Container -->
    <div id="container" role="application" aria-label="LEVIATHAN Game"></div>

    <!-- HUD -->
    <div class="hud" id="hud">
        <div class="hud-top">
            <div>
                <div class="game-title">LEVIATHAN</div>
                <div class="subtitle">OMNIVERSE v2.0</div>
            </div>
            <div class="stats-box">
                <div class="stat-entry">
                    <span class="stat-val" id="stat-gold">0</span>
                    <span class="stat-lbl">Gold</span>
                </div>
                <div class="stat-entry">
                    <span class="stat-val" id="stat-level">1</span>
                    <span class="stat-lbl">Level</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Data Controls -->
    <div class="data-controls">
        <button onclick="exportSave()" aria-label="Export save data">Export</button>
        <button onclick="importSave()" aria-label="Import save data">Import</button>
        <button onclick="resetGame()" aria-label="Reset game">Reset</button>
    </div>

    <!-- Health Bar + Energy Bar v2.1 -->
    <div class="health-bar panel" id="health-bar">
        <div class="health-fill" id="health-fill" style="width: 100%"></div>
        <div class="health-text"><span id="health-text">100 / 100</span></div>
        <div class="energy-container">
            <div class="energy-fill" id="energy-fill" style="width: 100%"></div>
            <div class="energy-text"><span id="energy-text">100 / 100</span></div>
        </div>
    </div>

    <!-- v2.1: Style Meter -->
    <div class="style-meter" id="style-meter">
        <div class="style-grade D" id="style-grade">D</div>
        <div class="style-label">STYLE</div>
        <div class="style-bar"><div class="style-bar-fill" id="style-bar-fill"></div></div>
    </div>

    <!-- v2.1: Combo Counter -->
    <div class="combo-display" id="combo-display">
        <div class="combo-count" id="combo-count">0</div>
        <div class="combo-label">COMBO</div>
        <div class="combo-multiplier" id="combo-multiplier">x1.0</div>
    </div>

    <!-- v2.1: Kill Streak -->
    <div class="streak-display" id="streak-display">
        <div class="streak-count" id="streak-count">0</div>
        <div class="streak-label">KILL STREAK</div>
        <div class="streak-bonus" id="streak-bonus">+0% XP</div>
    </div>

    <!-- v2.1: Hit Flash -->
    <div class="hit-flash" id="hit-flash"></div>

    <!-- RTS Panel Toggles -->
    <div class="rts-toggles">
        <button class="rts-btn" id="btn-skills" aria-label="Toggle skills panel" title="Skills (S)">S</button>
        <button class="rts-btn" id="btn-inventory" aria-label="Toggle inventory" title="Inventory (I)">I</button>
        <button class="rts-btn nav-btn" id="btn-galaxy" aria-label="Go to galaxy" title="Galaxy (G)">G</button>
    </div>

    <!-- Skills Panel -->
    <div class="panel skills-panel" id="skills-panel">
        <div class="panel-title">SKILLS</div>
        <div id="skills-list"></div>
    </div>

    <!-- Inventory Panel -->
    <div class="panel inventory-panel" id="inventory-panel">
        <div class="panel-title">INVENTORY</div>
        <div class="inv-grid" id="inv-grid"></div>
    </div>

    <!-- Ability Bar -->
    <div class="ability-bar" id="ability-bar">
        <div class="ability-btn" data-ability="powerStrike" tabindex="0">
            <span class="ability-icon">&#x2694;&#xFE0F;</span>
            <span class="ability-key">Q</span>
            <div class="ability-cd" id="cd-powerStrike"></div>
        </div>
        <div class="ability-btn" data-ability="whirlwind" tabindex="0">
            <span class="ability-icon">&#x1F300;</span>
            <span class="ability-key">E</span>
            <div class="ability-cd" id="cd-whirlwind"></div>
        </div>
        <div class="ability-btn" data-ability="heal" tabindex="0">
            <span class="ability-icon">&#x1F49A;</span>
            <span class="ability-key">R</span>
            <div class="ability-cd" id="cd-heal"></div>
        </div>
        <div class="ability-btn" data-ability="dash" tabindex="0">
            <span class="ability-icon">&#x1F4A8;</span>
            <span class="ability-key">F</span>
            <div class="ability-cd" id="cd-dash"></div>
        </div>
    </div>

    <!-- Minimap -->
    <div class="minimap" id="minimap">
        <canvas class="minimap-canvas" id="minimap-canvas"></canvas>
    </div>

    <!-- Touch Controls -->
    <div class="touch-controls" id="touch-controls">
        <div class="virtual-joystick" id="virtual-joystick">
            <div class="joystick-knob" id="joystick-knob"></div>
        </div>
        <div class="touch-action-btn" id="touch-action">&#x2694;&#xFE0F;</div>
    </div>

    <!-- Low HP Vignette -->
    <div class="low-hp-vignette" id="low-hp-vignette"></div>

    <!-- Instructions -->
    <div class="instructions" id="instructions">
        <div class="instruction-text" id="instruction-text">Click on a planet to land</div>
    </div>

    <!-- Planet Approach Overlay -->
    <div class="approach-overlay" id="approach-overlay">
        <div class="letterbox-top"></div>
        <div class="letterbox-bottom"></div>
        <button class="approach-skip" id="approach-skip">SKIP [ESC]</button>
        <div class="approach-info" id="approach-info">
            <div class="approach-planet-name" id="approach-name">Planet Name</div>
            <div class="approach-planet-type" id="approach-type">Type</div>
            <div class="approach-stats">
                <div class="approach-stat">
                    <div class="approach-stat-val" id="approach-size">--</div>
                    <div class="approach-stat-lbl">Size</div>
                </div>
                <div class="approach-stat">
                    <div class="approach-stat-val" id="approach-danger">--</div>
                    <div class="approach-stat-lbl">Danger</div>
                </div>
                <div class="approach-stat">
                    <div class="approach-stat-val" id="approach-resources">--</div>
                    <div class="approach-stat-lbl">Resources</div>
                </div>
            </div>
            <button class="approach-btn" id="approach-land" disabled>Approaching...</button>
        </div>
        <div class="approach-progress">
            <div class="approach-progress-bar" id="approach-progress-bar"></div>
        </div>
    </div>

    <!-- Stats Modal -->
    <div class="modal-overlay" id="stats-modal">
        <div class="modal-content">
            <button class="modal-close" onclick="closeModal('stats-modal')">&times;</button>
            <h2 class="modal-title">STATISTICS</h2>
            <div id="stats-content"></div>
        </div>
    </div>

    <!-- Hidden file input for import -->
    <input type="file" id="import-input" accept=".json" style="display:none">

    <!-- Three.js (inline for local-first) -->
    <script>
    // ============================================
    // THREE.JS MINIMAL BUILD (r150 core)
    // ============================================
    </script>
    <script src="https://unpkg.com/three@0.150.0/build/three.min.js"></script>

    <script>
    // ============================================
    // LEVIATHAN: OMNIVERSE v2.1
    // Streamlined 3D Space Exploration Game
    // v2.1: Added Style Meter, Combo System, Kill Streaks, Hit Effects
    // ============================================
    'use strict';

    const VERSION = '2.1';
    const STORAGE_KEY = 'leviathan_save_v2';

    // ============================================
    // GAME STATE
    // ============================================
    let gameData = {
        version: VERSION,
        playtime: 0,
        gold: 100,
        inventory: [],
        skills: {
            combat: { level: 1, xp: 0 },
            mining: { level: 1, xp: 0 },
            exploration: { level: 1, xp: 0 }
        },
        player: {
            hp: 100,
            maxHp: 100,
            energy: 100,
            maxEnergy: 100
        },
        equipment: {
            weapon: null,
            armor: null,
            accessory: null
        },
        settings: {
            musicVolume: 0.5,
            sfxVolume: 0.7,
            particles: true
        },
        planets: {},
        currentGalaxy: 0,
        galaxySeed: Date.now()
    };

    let worldState = {
        player: null,
        terrain: [],
        mobs: [],
        resources: [],
        interactTarget: null
    };

    // ============================================
    // THREE.JS SETUP
    // ============================================
    let scene, camera, renderer;
    let galaxyGroup, planetGroup;
    let mode = 'galaxy'; // 'galaxy' or 'world'
    let lastTime = 0;
    let keys = {};
    let isTouchDevice = 'ontouchstart' in window;

    // Joystick state
    let joystickActive = false;
    let joystickInput = { x: 0, y: 0 };
    let joystickCenter = { x: 0, y: 0 };

    // Abilities
    const abilities = {
        powerStrike: { cooldown: 8000, lastUsed: 0, damage: 3, energyCost: 10 },
        whirlwind: { cooldown: 12000, lastUsed: 0, damage: 1.5, radius: 8, energyCost: 15 },
        heal: { cooldown: 15000, lastUsed: 0, healPercent: 0.3, energyCost: 20 },
        dash: { cooldown: 6000, lastUsed: 0, distance: 8, energyCost: 5 }
    };

    // Floater pool
    const floaterPool = [];
    const MAX_FLOATERS = 20;

    // v2.1: Combat Feedback Systems
    let combatState = {
        // Combo system
        comboCount: 0,
        comboTimer: 0,
        comboDecayTime: 2000, // ms before combo resets
        lastHitTime: 0,

        // Style meter (DMC-style)
        stylePoints: 0,
        styleGrade: 'D',
        styleDecayRate: 5, // points per second
        lastActionType: null,
        actionVariety: new Set(),

        // Kill streak
        killStreak: 0,
        killStreakTimer: 0,
        killStreakDecayTime: 5000, // ms before streak resets

        // Hit effects
        hitStopFrames: 0,
        screenShakeIntensity: 0
    };

    // Style grade thresholds
    const STYLE_GRADES = [
        { grade: 'D', threshold: 0, color: '#888' },
        { grade: 'C', threshold: 100, color: '#fff' },
        { grade: 'B', threshold: 250, color: '#0ff' },
        { grade: 'A', threshold: 500, color: '#0f8' },
        { grade: 'S', threshold: 800, color: '#fb0' },
        { grade: 'SS', threshold: 1200, color: '#f80' },
        { grade: 'SSS', threshold: 2000, color: '#f0f' }
    ];

    // Planet approach state
    let planetApproachState = {
        active: false,
        targetPlanet: null,
        phase: 'idle', // idle, approaching, orbiting, ready
        orbitAngle: 0,
        orbitRadius: 20,
        approachProgress: 0,
        startCameraPos: null,
        startCameraLookAt: null,
        animationStartTime: 0
    };

    // ============================================
    // SEEDED RANDOM NUMBER GENERATOR
    // ============================================
    class SeededRNG {
        constructor(seed) {
            this.seed = seed;
        }
        next() {
            this.seed = (this.seed * 16807) % 2147483647;
            return (this.seed - 1) / 2147483646;
        }
        range(min, max) {
            return min + this.next() * (max - min);
        }
        int(min, max) {
            return Math.floor(this.range(min, max + 1));
        }
    }

    // ============================================
    // AUDIO SYSTEM
    // ============================================
    const Audio = {
        ctx: null,
        masterGain: null,

        init() {
            try {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.masterGain = this.ctx.createGain();
                this.masterGain.connect(this.ctx.destination);
                this.masterGain.gain.value = gameData.settings.sfxVolume;
            } catch (e) {
                console.warn('Audio not available');
            }
        },

        play(freq, duration = 0.1, type = 'sine', volume = 0.3) {
            if (!this.ctx) return;
            try {
                if (this.ctx.state === 'suspended') this.ctx.resume();
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.value = freq;
                gain.gain.setValueAtTime(volume * gameData.settings.sfxVolume, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            } catch (e) {}
        },

        hit() { this.play(200, 0.1, 'square', 0.4); },
        collect() { this.play(800, 0.15, 'sine', 0.3); },
        levelUp() {
            [400, 500, 600, 800].forEach((f, i) =>
                setTimeout(() => this.play(f, 0.2, 'sine', 0.4), i * 100)
            );
        },
        warp() { this.play(100, 0.5, 'sawtooth', 0.3); }
    };

    // ============================================
    // PARTICLE SYSTEM
    // ============================================
    class ParticleSystem {
        constructor() {
            this.particles = [];
        }

        emit(position, count, color, options = {}) {
            const { spread = 2, lifetime = 1000, size = 0.1 } = options;

            for (let i = 0; i < count; i++) {
                const geo = new THREE.SphereGeometry(size, 4, 4);
                const mat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 1 });
                const mesh = new THREE.Mesh(geo, mat);

                mesh.position.copy(position);
                mesh.userData = {
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * spread,
                        Math.random() * spread * 0.5,
                        (Math.random() - 0.5) * spread
                    ),
                    lifetime,
                    age: 0
                };

                scene.add(mesh);
                this.particles.push(mesh);
            }
        }

        update(dt) {
            for (let i = this.particles.length - 1; i >= 0; i--) {
                const p = this.particles[i];
                p.userData.age += dt;

                if (p.userData.age >= p.userData.lifetime) {
                    scene.remove(p);
                    p.geometry.dispose();
                    p.material.dispose();
                    this.particles.splice(i, 1);
                    continue;
                }

                p.position.add(p.userData.velocity.clone().multiplyScalar(dt * 0.01));
                p.userData.velocity.y -= 0.02;
                p.material.opacity = 1 - (p.userData.age / p.userData.lifetime);
            }
        }
    }

    let particles;

    // ============================================
    // SAVE/LOAD SYSTEM
    // ============================================
    function saveGame() {
        gameData.lastSaved = Date.now();
        try {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(gameData));
        } catch (e) {
            console.warn('Could not save to localStorage');
        }
    }

    function loadGame() {
        try {
            const saved = localStorage.getItem(STORAGE_KEY);
            if (saved) {
                const data = JSON.parse(saved);
                gameData = { ...gameData, ...data };
            }
        } catch (e) {
            console.warn('Could not load from localStorage');
        }
    }

    function exportSave() {
        saveGame();
        const blob = new Blob([JSON.stringify(gameData, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `leviathan_save_${new Date().toISOString().split('T')[0]}.json`;
        a.click();
        URL.revokeObjectURL(url);
        notify('Save exported!');
    }

    function importSave() {
        document.getElementById('import-input').click();
    }

    document.getElementById('import-input').addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (ev) => {
            try {
                const data = JSON.parse(ev.target.result);
                gameData = { ...gameData, ...data };
                saveGame();
                notify('Save imported! Reloading...');
                setTimeout(() => location.reload(), 1000);
            } catch (err) {
                notify('Invalid save file!', 'error');
            }
        };
        reader.readAsText(file);
        e.target.value = '';
    });

    function resetGame() {
        if (confirm('Are you sure you want to reset all progress?')) {
            localStorage.removeItem(STORAGE_KEY);
            location.reload();
        }
    }

    // ============================================
    // UI HELPERS
    // ============================================
    function notify(message, type = 'success') {
        const el = document.createElement('div');
        el.className = 'notification';
        el.textContent = message;
        if (type === 'error') {
            el.style.borderColor = 'var(--accent-red)';
            el.style.color = 'var(--accent-red)';
        }
        document.body.appendChild(el);
        setTimeout(() => el.remove(), 3000);

        // Screen reader announcement
        document.getElementById('sr-announcements').textContent = message;
    }

    function spawnFloater(position, text, color = '#fff') {
        // Find inactive floater
        let floater = floaterPool.find(f => !f.active);
        if (!floater) {
            if (floaterPool.length < MAX_FLOATERS) {
                const el = document.createElement('div');
                el.className = 'floater';
                document.body.appendChild(el);
                floater = { el, active: false };
                floaterPool.push(floater);
            } else {
                return;
            }
        }

        // Convert 3D position to screen
        const pos = position.clone().project(camera);
        const x = (pos.x * 0.5 + 0.5) * window.innerWidth;
        const y = (-pos.y * 0.5 + 0.5) * window.innerHeight;

        floater.el.style.display = 'block';
        floater.el.style.left = x + 'px';
        floater.el.style.top = y + 'px';
        floater.el.style.color = color;
        floater.el.textContent = text;
        floater.el.style.animation = 'none';
        floater.el.offsetHeight; // Trigger reflow
        floater.el.style.animation = 'floatUp 1.5s forwards';
        floater.active = true;

        setTimeout(() => {
            floater.el.style.display = 'none';
            floater.active = false;
        }, 1500);
    }

    function updateUI() {
        // Stats
        document.getElementById('stat-gold').textContent = gameData.gold;
        document.getElementById('stat-level').textContent = gameData.skills.combat.level;

        // Health and Energy (v2.1)
        if (mode === 'world') {
            const hp = gameData.player.hp;
            const maxHp = gameData.player.maxHp;
            const pct = (hp / maxHp) * 100;

            document.getElementById('health-fill').style.width = pct + '%';
            document.getElementById('health-text').textContent = `${Math.floor(hp)} / ${maxHp}`;

            // v2.1: Energy bar
            const energy = gameData.player.energy;
            const maxEnergy = gameData.player.maxEnergy;
            const energyPct = (energy / maxEnergy) * 100;

            document.getElementById('energy-fill').style.width = energyPct + '%';
            document.getElementById('energy-text').textContent = `${Math.floor(energy)} / ${maxEnergy}`;

            // Low HP warning
            const vignette = document.getElementById('low-hp-vignette');
            vignette.classList.toggle('active', pct < 30);
        }

        // Skills
        const skillsList = document.getElementById('skills-list');
        skillsList.innerHTML = Object.entries(gameData.skills).map(([name, skill]) => `
            <div class="skill-row">
                <span class="skill-name">${name.charAt(0).toUpperCase() + name.slice(1)}</span>
                <span class="skill-level">Lv.${skill.level}</span>
            </div>
        `).join('');

        // Inventory
        const invGrid = document.getElementById('inv-grid');
        invGrid.innerHTML = '';
        for (let i = 0; i < 15; i++) {
            const slot = document.createElement('div');
            slot.className = 'inv-slot';
            slot.tabIndex = 0;

            const item = gameData.inventory[i];
            if (item) {
                slot.textContent = item.icon || '?';
                slot.title = item.name;
                if (item.count > 1) {
                    const count = document.createElement('span');
                    count.className = 'inv-count';
                    count.textContent = item.count;
                    slot.appendChild(count);
                }
            }
            invGrid.appendChild(slot);
        }

        // Abilities cooldown
        const now = performance.now();
        Object.entries(abilities).forEach(([id, ability]) => {
            const btn = document.querySelector(`[data-ability="${id}"]`);
            const cdEl = document.getElementById(`cd-${id}`);
            if (!btn || !cdEl) return;

            const elapsed = now - ability.lastUsed;
            const remaining = Math.max(0, ability.cooldown - elapsed);

            if (remaining > 0) {
                btn.classList.add('cooldown');
                cdEl.textContent = Math.ceil(remaining / 1000);
            } else {
                btn.classList.remove('cooldown');
                cdEl.textContent = '';
            }
        });
    }

    function closeModal(id) {
        document.getElementById(id).classList.remove('active');
    }

    // ============================================
    // v2.1: COMBAT FEEDBACK SYSTEMS
    // ============================================

    // Increment combo and add style points
    function registerHit(actionType = 'basic', damage = 10) {
        const now = performance.now();
        combatState.comboCount++;
        combatState.comboTimer = combatState.comboDecayTime;
        combatState.lastHitTime = now;

        // Style points based on action variety
        let styleGain = 10;
        if (actionType !== combatState.lastActionType) {
            styleGain = 25; // Bonus for variety
            combatState.actionVariety.add(actionType);
        }
        // Bonus for using different attacks
        styleGain += combatState.actionVariety.size * 5;
        combatState.stylePoints += styleGain;
        combatState.lastActionType = actionType;

        // Update style grade
        updateStyleGrade();

        // Trigger hit effects
        triggerHitEffect();
    }

    // Register a kill for streak
    function registerKill() {
        combatState.killStreak++;
        combatState.killStreakTimer = combatState.killStreakDecayTime;

        // Big style bonus for kills
        combatState.stylePoints += 50 + (combatState.killStreak * 10);
        updateStyleGrade();

        // Heavy screen shake on kill
        triggerScreenShake('heavy');

        // Show death particles
        if (particles && worldState.player) {
            // Extra particles on kill streaks
            const particleCount = 15 + combatState.killStreak * 3;
            particles.emit(worldState.player.position, Math.min(particleCount, 40), 0xff4444, { spread: 3, lifetime: 1000, size: 0.2 });
        }

        updateStreakUI();
    }

    // Get XP multiplier from kill streak
    function getStreakXPMultiplier() {
        if (combatState.killStreak < 3) return 1.0;
        if (combatState.killStreak < 5) return 1.25;
        if (combatState.killStreak < 10) return 1.5;
        if (combatState.killStreak < 15) return 2.0;
        return 2.5;
    }

    // Get damage multiplier from combo
    function getComboMultiplier() {
        if (combatState.comboCount < 5) return 1.0;
        if (combatState.comboCount < 10) return 1.1;
        if (combatState.comboCount < 20) return 1.25;
        if (combatState.comboCount < 30) return 1.4;
        return 1.5;
    }

    // Update style grade based on points
    function updateStyleGrade() {
        let newGrade = 'D';
        for (let i = STYLE_GRADES.length - 1; i >= 0; i--) {
            if (combatState.stylePoints >= STYLE_GRADES[i].threshold) {
                newGrade = STYLE_GRADES[i].grade;
                break;
            }
        }

        if (newGrade !== combatState.styleGrade) {
            combatState.styleGrade = newGrade;
            updateStyleUI(true); // Animate grade change
            // Play sound on grade up
            if (newGrade !== 'D') {
                Audio.play(400 + STYLE_GRADES.findIndex(g => g.grade === newGrade) * 100, 0.15, 'sine', 0.4);
            }
        } else {
            updateStyleUI(false);
        }
    }

    // Update style meter UI
    function updateStyleUI(animate = false) {
        const gradeEl = document.getElementById('style-grade');
        const barEl = document.getElementById('style-bar-fill');
        const meterEl = document.getElementById('style-meter');

        if (!gradeEl || !barEl || !meterEl) return;

        // Show/hide based on mode and style
        if (mode === 'world' && combatState.stylePoints > 0) {
            meterEl.classList.add('visible');
        } else {
            meterEl.classList.remove('visible');
        }

        // Update grade display
        gradeEl.textContent = combatState.styleGrade;
        gradeEl.className = 'style-grade ' + combatState.styleGrade;

        if (animate) {
            gradeEl.style.animation = 'none';
            gradeEl.offsetHeight; // Reflow
            gradeEl.style.animation = 'stylePulse 0.5s ease-out';
        }

        // Update bar (show progress to next grade)
        const currentIdx = STYLE_GRADES.findIndex(g => g.grade === combatState.styleGrade);
        const nextIdx = Math.min(currentIdx + 1, STYLE_GRADES.length - 1);
        const currentThreshold = STYLE_GRADES[currentIdx].threshold;
        const nextThreshold = STYLE_GRADES[nextIdx].threshold;
        const progress = nextIdx === currentIdx ? 100 :
            ((combatState.stylePoints - currentThreshold) / (nextThreshold - currentThreshold)) * 100;
        barEl.style.width = Math.min(100, progress) + '%';
    }

    // Update combo UI
    function updateComboUI() {
        const countEl = document.getElementById('combo-count');
        const multiplierEl = document.getElementById('combo-multiplier');
        const displayEl = document.getElementById('combo-display');

        if (!countEl || !multiplierEl || !displayEl) return;

        if (combatState.comboCount > 1) {
            displayEl.classList.add('visible');
            countEl.textContent = combatState.comboCount;
            multiplierEl.textContent = 'x' + getComboMultiplier().toFixed(1);
        } else {
            displayEl.classList.remove('visible');
        }
    }

    // Update kill streak UI
    function updateStreakUI() {
        const countEl = document.getElementById('streak-count');
        const bonusEl = document.getElementById('streak-bonus');
        const displayEl = document.getElementById('streak-display');

        if (!countEl || !bonusEl || !displayEl) return;

        if (combatState.killStreak >= 3) {
            displayEl.classList.add('visible');
            countEl.textContent = combatState.killStreak;
            const bonus = Math.round((getStreakXPMultiplier() - 1) * 100);
            bonusEl.textContent = '+' + bonus + '% XP';
        } else {
            displayEl.classList.remove('visible');
        }
    }

    // Trigger hit effect (flash, shake)
    function triggerHitEffect() {
        // Hit flash
        const flashEl = document.getElementById('hit-flash');
        if (flashEl) {
            flashEl.classList.remove('active');
            flashEl.offsetHeight; // Reflow
            flashEl.classList.add('active');
        }

        // Screen shake
        triggerScreenShake('light');

        // Brief hitstop
        combatState.hitStopFrames = 2;
    }

    // Screen shake
    function triggerScreenShake(intensity = 'light') {
        const container = document.getElementById('container');
        if (!container) return;

        container.classList.remove('screen-shake', 'screen-shake-heavy');
        container.offsetHeight; // Reflow

        if (intensity === 'heavy') {
            container.classList.add('screen-shake-heavy');
        } else {
            container.classList.add('screen-shake');
        }
    }

    // Apply knockback to mob
    function applyKnockback(mob, fromPos, force = 2) {
        if (!mob || !mob.position) return;

        const dir = mob.position.clone().sub(fromPos).normalize();
        dir.y = 0;
        mob.position.add(dir.multiplyScalar(force));
    }

    // Update combat timers (called every frame)
    function updateCombatSystems(dt) {
        // Decay combo timer
        if (combatState.comboTimer > 0) {
            combatState.comboTimer -= dt;
            if (combatState.comboTimer <= 0) {
                combatState.comboCount = 0;
                combatState.actionVariety.clear();
                updateComboUI();
            }
        }

        // Decay style points
        if (combatState.stylePoints > 0) {
            combatState.stylePoints -= combatState.styleDecayRate * (dt / 1000);
            if (combatState.stylePoints < 0) combatState.stylePoints = 0;
            updateStyleGrade();
        }

        // Decay kill streak timer
        if (combatState.killStreakTimer > 0) {
            combatState.killStreakTimer -= dt;
            if (combatState.killStreakTimer <= 0) {
                combatState.killStreak = 0;
                updateStreakUI();
            }
        }

        // Update combo UI
        updateComboUI();
    }

    // ============================================
    // GALAXY GENERATION
    // ============================================
    function generateGalaxy() {
        galaxyGroup = new THREE.Group();
        const rng = new SeededRNG(gameData.galaxySeed);

        // Central black hole
        const blackHoleGeo = new THREE.SphereGeometry(5, 32, 32);
        const blackHoleMat = new THREE.MeshBasicMaterial({
            color: 0x000000,
            transparent: true,
            opacity: 0.9
        });
        const blackHole = new THREE.Mesh(blackHoleGeo, blackHoleMat);
        galaxyGroup.add(blackHole);

        // Accretion disk
        const diskGeo = new THREE.RingGeometry(6, 15, 64);
        const diskMat = new THREE.MeshBasicMaterial({
            color: 0xff6600,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.6
        });
        const disk = new THREE.Mesh(diskGeo, diskMat);
        disk.rotation.x = Math.PI / 2;
        galaxyGroup.add(disk);

        // Stars/Planets
        const planetCount = 8 + rng.int(0, 4);
        const planetTypes = ['Terra', 'Desert', 'Ice', 'Volcanic', 'Ocean', 'Gas', 'Alien'];
        const planetColors = [0x44aa44, 0xddaa44, 0x88ccff, 0xff4400, 0x4488ff, 0xffaa88, 0xaa44ff];

        for (let i = 0; i < planetCount; i++) {
            const angle = (i / planetCount) * Math.PI * 2 + rng.range(0, 0.3);
            const dist = 25 + rng.range(0, 60);
            const typeIdx = rng.int(0, planetTypes.length - 1);

            const size = 1.5 + rng.range(0, 2);
            const geo = new THREE.SphereGeometry(size, 16, 16);
            const mat = new THREE.MeshStandardMaterial({
                color: planetColors[typeIdx],
                emissive: planetColors[typeIdx],
                emissiveIntensity: 0.3,
                roughness: 0.7,
                metalness: 0.1
            });
            const planet = new THREE.Mesh(geo, mat);

            planet.position.set(
                Math.cos(angle) * dist,
                rng.range(-5, 5),
                Math.sin(angle) * dist
            );

            planet.userData = {
                id: i,
                type: planetTypes[typeIdx],
                name: `${planetTypes[typeIdx]}-${i + 1}`,
                size,
                seed: rng.int(1, 999999),
                discovered: false
            };

            // Ring for visual feedback
            const ringGeo = new THREE.RingGeometry(size + 0.5, size + 0.8, 32);
            const ringMat = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0
            });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.rotation.x = Math.PI / 2;
            planet.add(ring);
            planet.userData.ring = ring;

            galaxyGroup.add(planet);
        }

        // Background stars
        const starGeo = new THREE.BufferGeometry();
        const starPositions = [];
        for (let i = 0; i < 2000; i++) {
            starPositions.push(
                (Math.random() - 0.5) * 500,
                (Math.random() - 0.5) * 500,
                (Math.random() - 0.5) * 500
            );
        }
        starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
        const starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.5 });
        const stars = new THREE.Points(starGeo, starMat);
        galaxyGroup.add(stars);

        // Galaxy lighting (so planets are visible)
        const galaxyLight = new THREE.PointLight(0xffffff, 2, 200);
        galaxyLight.position.set(0, 20, 0);
        galaxyGroup.add(galaxyLight);

        const galaxyAmbient = new THREE.AmbientLight(0x404060, 0.8);
        galaxyGroup.add(galaxyAmbient);

        scene.add(galaxyGroup);
    }

    // ============================================
    // PLANET APPROACH SYSTEM
    // ============================================
    function initiatePlanetApproach(planetData, planetMesh) {
        if (planetApproachState.active) return;

        planetApproachState = {
            active: true,
            targetPlanet: planetData,
            targetMesh: planetMesh,
            phase: 'approaching',
            orbitAngle: 0,
            orbitRadius: planetData.size * 8 + 10,
            approachProgress: 0,
            startCameraPos: camera.position.clone(),
            startCameraLookAt: new THREE.Vector3(0, 0, 0),
            animationStartTime: performance.now()
        };

        // Update UI
        const overlay = document.getElementById('approach-overlay');
        overlay.classList.add('active');

        document.getElementById('approach-name').textContent = planetData.name;
        document.getElementById('approach-type').textContent = planetData.type;
        document.getElementById('approach-size').textContent = ['Small', 'Medium', 'Large'][Math.floor(planetData.size)];
        document.getElementById('approach-danger').textContent = ['Low', 'Medium', 'High'][Math.floor(Math.random() * 3)];
        document.getElementById('approach-resources').textContent = ['Scarce', 'Moderate', 'Rich'][Math.floor(Math.random() * 3)];

        document.getElementById('approach-land').disabled = true;
        document.getElementById('approach-land').textContent = 'Approaching...';
        document.getElementById('approach-progress-bar').style.width = '0%';

        document.getElementById('instructions').style.display = 'none';

        Audio.play(200, 0.3, 'sine', 0.3);
    }

    function updatePlanetApproach(dt, time) {
        if (!planetApproachState.active) return;

        const state = planetApproachState;
        const elapsed = time - state.animationStartTime;
        const planetPos = state.targetMesh.position.clone();

        if (state.phase === 'approaching') {
            // Approach phase - fly towards planet (2 seconds)
            const approachDuration = 2000;
            state.approachProgress = Math.min(1, elapsed / approachDuration);

            // Interpolate camera position towards orbit starting point
            const startPos = state.startCameraPos;
            const orbitStartPos = new THREE.Vector3(
                planetPos.x + state.orbitRadius,
                planetPos.y + 5,
                planetPos.z
            );

            camera.position.lerpVectors(startPos, orbitStartPos, easeOutCubic(state.approachProgress));
            camera.lookAt(planetPos);

            // Update progress bar
            document.getElementById('approach-progress-bar').style.width = (state.approachProgress * 50) + '%';

            if (state.approachProgress >= 1) {
                state.phase = 'orbiting';
                state.animationStartTime = time;
                state.orbitAngle = 0;
            }
        } else if (state.phase === 'orbiting') {
            // Orbit phase - swing around planet (3 seconds)
            const orbitDuration = 3000;
            const orbitProgress = Math.min(1, (time - state.animationStartTime) / orbitDuration);

            // Orbit around planet
            state.orbitAngle = orbitProgress * Math.PI * 1.5; // Swing 270 degrees

            const orbitX = planetPos.x + Math.cos(state.orbitAngle) * state.orbitRadius;
            const orbitZ = planetPos.z + Math.sin(state.orbitAngle) * state.orbitRadius;
            const orbitY = planetPos.y + 5 + Math.sin(state.orbitAngle * 0.5) * 3;

            camera.position.set(orbitX, orbitY, orbitZ);
            camera.lookAt(planetPos);

            // Update progress bar
            document.getElementById('approach-progress-bar').style.width = (50 + orbitProgress * 50) + '%';

            if (orbitProgress >= 1) {
                state.phase = 'ready';
                document.getElementById('approach-land').disabled = false;
                document.getElementById('approach-land').textContent = 'LAND ON PLANET';
                Audio.play(600, 0.2, 'sine', 0.4);
            }
        } else if (state.phase === 'ready') {
            // Continue slow orbit while waiting for player decision
            state.orbitAngle += dt * 0.0003;

            const orbitX = planetPos.x + Math.cos(state.orbitAngle) * state.orbitRadius;
            const orbitZ = planetPos.z + Math.sin(state.orbitAngle) * state.orbitRadius;
            const orbitY = planetPos.y + 5 + Math.sin(state.orbitAngle * 0.5) * 2;

            camera.position.set(orbitX, orbitY, orbitZ);
            camera.lookAt(planetPos);
        }
    }

    function completePlanetApproach() {
        if (!planetApproachState.active || !planetApproachState.targetPlanet) return;

        const planetData = planetApproachState.targetPlanet;

        // Hide overlay
        document.getElementById('approach-overlay').classList.remove('active');

        // Reset state
        planetApproachState = {
            active: false,
            targetPlanet: null,
            targetMesh: null,
            phase: 'idle',
            orbitAngle: 0,
            orbitRadius: 20,
            approachProgress: 0,
            startCameraPos: null,
            startCameraLookAt: null,
            animationStartTime: 0
        };

        // Land on planet
        landOnPlanet(planetData);
    }

    function skipPlanetApproach() {
        if (!planetApproachState.active) return;

        if (planetApproachState.phase === 'ready') {
            completePlanetApproach();
        } else {
            // Cancel approach and return to galaxy view
            document.getElementById('approach-overlay').classList.remove('active');

            planetApproachState = {
                active: false,
                targetPlanet: null,
                targetMesh: null,
                phase: 'idle',
                orbitAngle: 0,
                orbitRadius: 20,
                approachProgress: 0,
                startCameraPos: null,
                startCameraLookAt: null,
                animationStartTime: 0
            };

            // Reset camera to galaxy view
            camera.position.set(0, 80, 80);
            camera.lookAt(0, 0, 0);
            document.getElementById('instructions').style.display = 'block';
        }
    }

    function easeOutCubic(t) {
        return 1 - Math.pow(1 - t, 3);
    }

    // ============================================
    // WORLD GENERATION
    // ============================================
    function generateWorld(planetData) {
        console.log('=== GENERATING WORLD ===');
        console.log('Planet:', planetData.name, 'Type:', planetData.type, 'Seed:', planetData.seed);

        try {

        if (planetGroup) {
            scene.remove(planetGroup);
            disposeGroup(planetGroup);
        }

        planetGroup = new THREE.Group();
        const rng = new SeededRNG(planetData.seed);

        // Terrain colors by biome
        const terrainColors = {
            Terra: 0x3d8c40,
            Desert: 0xc9a227,
            Ice: 0x8ecae6,
            Volcanic: 0x5c3317,
            Ocean: 0x1e6091,
            Gas: 0xd4a373,
            Alien: 0x7b2cbf
        };

        // Sky colors by biome
        const skyColors = {
            Terra: 0x87ceeb,
            Desert: 0xf4a460,
            Ice: 0xc4d4e0,
            Volcanic: 0x2d1b14,
            Ocean: 0x4a90a4,
            Gas: 0xe8d4b8,
            Alien: 0x1a0a2e
        };

        const biomeColor = terrainColors[planetData.type] || 0x448844;
        const skyColor = skyColors[planetData.type] || 0x87ceeb;

        // Create terrain using simple heightmap
        const terrainSize = 150;
        const segments = 80;
        const terrainGeo = new THREE.PlaneGeometry(terrainSize, terrainSize, segments, segments);

        // Generate procedural height
        const positions = terrainGeo.attributes.position.array;
        for (let i = 0; i < positions.length; i += 3) {
            const x = positions[i];
            const y = positions[i + 1];
            // Multi-octave noise for varied terrain
            let height = 0;
            height += Math.sin(x * 0.03 + rng.next() * 10) * Math.cos(y * 0.03 + rng.next() * 10) * 6;
            height += Math.sin(x * 0.08) * Math.cos(y * 0.08) * 3;
            height += (rng.next() - 0.5) * 2;
            positions[i + 2] = height;
        }
        terrainGeo.computeVertexNormals();

        const terrainMat = new THREE.MeshStandardMaterial({
            color: biomeColor,
            roughness: 0.85,
            metalness: 0.1,
            flatShading: true
        });

        const terrain = new THREE.Mesh(terrainGeo, terrainMat);
        terrain.rotation.x = -Math.PI / 2;
        terrain.receiveShadow = true;
        terrain.name = 'terrain';
        planetGroup.add(terrain);
        worldState.terrain = [terrain];

        // Sky dome
        const skyGeo = new THREE.SphereGeometry(300, 32, 32);
        const skyMat = new THREE.MeshBasicMaterial({
            color: skyColor,
            side: THREE.BackSide
        });
        const sky = new THREE.Mesh(skyGeo, skyMat);
        planetGroup.add(sky);

        // Sun/directional light
        const sunColor = planetData.type === 'Volcanic' ? 0xff6b35 : 0xffffff;
        const sun = new THREE.DirectionalLight(sunColor, 1.2);
        sun.position.set(50, 80, 30);
        sun.castShadow = true;
        sun.shadow.mapSize.width = 2048;
        sun.shadow.mapSize.height = 2048;
        sun.shadow.camera.near = 0.5;
        sun.shadow.camera.far = 200;
        sun.shadow.camera.left = -60;
        sun.shadow.camera.right = 60;
        sun.shadow.camera.top = 60;
        sun.shadow.camera.bottom = -60;
        planetGroup.add(sun);

        // Ambient light (tinted by biome)
        const ambient = new THREE.AmbientLight(biomeColor, 0.4);
        planetGroup.add(ambient);

        // Hemisphere light for natural lighting
        const hemi = new THREE.HemisphereLight(skyColor, biomeColor, 0.5);
        planetGroup.add(hemi);

        // Player
        createPlayer();

        // Resources
        worldState.resources = [];
        const resourceTypes = [
            { icon: '&#x1FAA8;', name: 'Stone', color: 0x888888, emissive: 0x222222 },
            { icon: '&#x1FAB5;', name: 'Wood', color: 0x8b4513, emissive: 0x3d2009 },
            { icon: '&#x1F48E;', name: 'Crystal', color: 0x00ffff, emissive: 0x00aaaa },
            { icon: '&#x1F3B5;', name: 'Metal', color: 0xcccccc, emissive: 0x444444 }
        ];

        for (let i = 0; i < 25; i++) {
            const type = resourceTypes[rng.int(0, resourceTypes.length - 1)];
            const x = rng.range(-50, 50);
            const z = rng.range(-50, 50);
            // Calculate approximate Y based on terrain noise function
            const approxY = Math.sin(x * 0.03) * Math.cos(z * 0.03) * 6 + 1;

            const geo = new THREE.BoxGeometry(1, 1, 1);
            const mat = new THREE.MeshStandardMaterial({
                color: type.color,
                emissive: type.emissive,
                emissiveIntensity: 0.3,
                roughness: 0.7
            });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, approxY, z);
            mesh.rotation.set(rng.range(0, 0.3), rng.range(0, Math.PI * 2), rng.range(0, 0.3));
            mesh.userData = { type: 'resource', ...type };
            mesh.castShadow = true;

            planetGroup.add(mesh);
            worldState.resources.push(mesh);
        }

        // Mobs
        worldState.mobs = [];
        const mobCount = 5 + rng.int(0, 5);
        for (let i = 0; i < mobCount; i++) {
            const x = rng.range(-35, 35);
            const z = rng.range(-35, 35);

            // Create mob mesh
            const mobGroup = new THREE.Group();
            const mobBodyGeo = new THREE.ConeGeometry(0.6, 1.5, 8);
            const mobMat = new THREE.MeshStandardMaterial({
                color: 0xff4444,
                emissive: 0x330000,
                emissiveIntensity: 0.3
            });
            const mobBody = new THREE.Mesh(mobBodyGeo, mobMat);
            mobBody.rotation.x = Math.PI; // Point cone up
            mobBody.position.y = 0.75;
            mobBody.castShadow = true;
            mobGroup.add(mobBody);

            // Eyes
            const eyeGeo = new THREE.SphereGeometry(0.15, 8, 8);
            const eyeMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const eye1 = new THREE.Mesh(eyeGeo, eyeMat);
            const eye2 = new THREE.Mesh(eyeGeo, eyeMat);
            eye1.position.set(-0.2, 1.2, 0.3);
            eye2.position.set(0.2, 1.2, 0.3);
            mobGroup.add(eye1);
            mobGroup.add(eye2);

            // Position mob - use simple height calculation since terrain not in scene yet
            const approxY = Math.sin(x * 0.03) * Math.cos(z * 0.03) * 6 + 2;
            mobGroup.position.set(x, approxY, z);

            mobGroup.userData = {
                type: 'mob',
                hp: 30,
                maxHp: 30,
                damage: 5,
                speed: 2,
                xp: 10
            };

            planetGroup.add(mobGroup);
            worldState.mobs.push(mobGroup);
        }

        // Add planetGroup to scene
        scene.add(planetGroup);
        console.log('Planet group added to scene');

        // v2.1: Position player after terrain is in scene - raised higher for visibility
        if (worldState.player) {
            terrain.updateMatrixWorld(true);
            const y = getTerrainHeight(0, 0, terrain);
            worldState.player.position.y = y + 1; // Match the updateWorld positioning
            console.log('Player repositioned to Y:', y + 1);
        }

        console.log('=== WORLD GENERATION COMPLETE ===');

        } catch (error) {
            console.error('World generation failed:', error);
            // Create a simple fallback world
            planetGroup = new THREE.Group();

            const fallbackGround = new THREE.Mesh(
                new THREE.PlaneGeometry(200, 200),
                new THREE.MeshBasicMaterial({ color: 0x333333, side: THREE.DoubleSide })
            );
            fallbackGround.rotation.x = -Math.PI / 2;
            planetGroup.add(fallbackGround);

            const fallbackLight = new THREE.AmbientLight(0xffffff, 1);
            planetGroup.add(fallbackLight);

            scene.add(planetGroup);
        }
    }

    // v2.1: Enhanced player creation with better visibility
    function createPlayer() {
        // Robot body
        const bodyGroup = new THREE.Group();
        bodyGroup.name = 'player';

        // Main body (capsule) - larger and more visible
        const bodyGeo = new THREE.CapsuleGeometry(0.6, 1.4, 8, 16);
        const bodyMat = new THREE.MeshStandardMaterial({
            color: 0x00aaff,
            metalness: 0.6,
            roughness: 0.4,
            emissive: 0x0066ff,
            emissiveIntensity: 0.4
        });
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        body.position.y = 1.0;
        body.castShadow = true;
        body.receiveShadow = true;
        bodyGroup.add(body);

        // Head (sphere with visor) - larger
        const headGeo = new THREE.SphereGeometry(0.45, 16, 16);
        const headMat = new THREE.MeshStandardMaterial({
            color: 0x00ddff,
            metalness: 0.7,
            roughness: 0.3,
            emissive: 0x00ffff,
            emissiveIntensity: 0.5
        });
        const head = new THREE.Mesh(headGeo, headMat);
        head.position.y = 2.2;
        head.castShadow = true;
        bodyGroup.add(head);

        // Visor glow - brighter
        const visorGeo = new THREE.SphereGeometry(0.25, 8, 8, 0, Math.PI);
        const visorMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
        const visor = new THREE.Mesh(visorGeo, visorMat);
        visor.position.set(0, 2.2, 0.25);
        visor.rotation.x = -Math.PI / 2;
        bodyGroup.add(visor);

        // v2.1: Add arms for better visual presence
        const armGeo = new THREE.CapsuleGeometry(0.15, 0.8, 4, 8);
        const armMat = new THREE.MeshStandardMaterial({
            color: 0x0088dd,
            metalness: 0.5,
            roughness: 0.5
        });
        const leftArm = new THREE.Mesh(armGeo, armMat);
        leftArm.position.set(-0.8, 1.0, 0);
        leftArm.rotation.z = 0.3;
        leftArm.castShadow = true;
        bodyGroup.add(leftArm);

        const rightArm = new THREE.Mesh(armGeo, armMat);
        rightArm.position.set(0.8, 1.0, 0);
        rightArm.rotation.z = -0.3;
        rightArm.castShadow = true;
        bodyGroup.add(rightArm);

        // v2.1: Add a point light on the player for visibility
        const playerLight = new THREE.PointLight(0x00aaff, 0.5, 10);
        playerLight.position.set(0, 2, 0);
        bodyGroup.add(playerLight);

        // Position player at origin, elevated initially
        bodyGroup.position.set(0, 10, 0); // Start elevated, will be corrected by terrain

        planetGroup.add(bodyGroup);
        worldState.player = bodyGroup;

        console.log('Player created with enhanced visibility');
    }

    function noise(x, y, rng) {
        // Simple noise function
        const X = Math.floor(x) & 255;
        const Y = Math.floor(y) & 255;
        return Math.sin(X * 12.9898 + Y * 78.233) * 0.5 + 0.5;
    }

    function getTerrainHeight(x, z, terrain) {
        if (!terrain) return 0;
        try {
            const raycaster = new THREE.Raycaster();
            raycaster.set(new THREE.Vector3(x, 100, z), new THREE.Vector3(0, -1, 0));
            const intersects = raycaster.intersectObject(terrain, true);
            if (intersects.length > 0) {
                return intersects[0].point.y;
            }
        } catch (e) {
            console.warn('Terrain raycast failed:', e);
        }
        return 0;
    }

    function disposeGroup(group) {
        group.traverse((obj) => {
            if (obj.geometry) obj.geometry.dispose();
            if (obj.material) {
                if (Array.isArray(obj.material)) {
                    obj.material.forEach(m => m.dispose());
                } else {
                    obj.material.dispose();
                }
            }
        });
    }

    // ============================================
    // GAME MODES
    // ============================================
    function enterGalaxyMode() {
        mode = 'galaxy';

        if (planetGroup) {
            scene.remove(planetGroup);
            disposeGroup(planetGroup);
            planetGroup = null;
        }

        if (!galaxyGroup) {
            generateGalaxy();
        } else {
            scene.add(galaxyGroup);
        }

        camera.position.set(0, 80, 80);
        camera.lookAt(0, 0, 0);

        // Hide world UI
        document.getElementById('health-bar').style.display = 'none';
        document.getElementById('ability-bar').classList.remove('visible');
        document.getElementById('minimap').classList.remove('visible');

        // Show galaxy instructions
        document.getElementById('instructions').style.display = 'block';
        document.getElementById('instruction-text').textContent = 'Click on a planet to land';

        Audio.warp();
        notify('Entered galaxy view');
    }

    function landOnPlanet(planetData) {
        mode = 'world';

        if (galaxyGroup) {
            scene.remove(galaxyGroup);
        }

        generateWorld(planetData);

        // Position camera behind and above player
        const playerY = getTerrainHeight(0, 0, worldState.terrain[0]);
        camera.position.set(0, playerY + 15, 25);
        camera.lookAt(0, playerY, 0);

        console.log('Camera positioned at:', camera.position, 'Player Y:', playerY);

        // Show world UI
        document.getElementById('health-bar').style.display = 'block';
        document.getElementById('ability-bar').classList.add('visible');
        document.getElementById('minimap').classList.add('visible');

        // Show world instructions
        document.getElementById('instructions').style.display = 'block';
        document.getElementById('instruction-text').innerHTML =
            '<b>WASD</b> Move | <b>Click</b> Attack | <b>Space</b> Collect | <b>G</b> Galaxy';
        document.body.style.cursor = 'default';

        Audio.warp();
        notify(`Landed on ${planetData.name}`);

        // Mark discovered
        if (!gameData.planets[planetData.id]) {
            gameData.planets[planetData.id] = { discovered: true };
            addXP('exploration', 20);
        }
    }

    // ============================================
    // COMBAT SYSTEM (v2.1 Enhanced)
    // ============================================
    function attack(target, actionType = 'basic') {
        if (!target || target.userData.hp <= 0) return;

        const baseDamage = 10;
        const levelBonus = gameData.skills.combat.level * 2;
        // v2.1: Apply combo multiplier
        const comboMult = getComboMultiplier();
        const rawDamage = baseDamage + levelBonus + Math.floor(Math.random() * 5);
        const damage = Math.floor(rawDamage * comboMult);

        target.userData.hp -= damage;

        // v2.1: Register hit for combo/style systems
        registerHit(actionType, damage);

        // v2.1: Apply knockback
        if (worldState.player) {
            applyKnockback(target, worldState.player.position, 1.5);
        }

        // Damage number color based on combo
        const damageColor = comboMult > 1.2 ? '#ffaa00' : comboMult > 1 ? '#ff8800' : '#ff4444';
        spawnFloater(target.position, `-${damage}`, damageColor);
        Audio.hit();

        // v2.1: Enhanced hit particles
        if (particles) {
            // Hit sparks
            particles.emit(target.position, 8, 0xffaa00, { spread: 1.5, lifetime: 400, size: 0.12 });
            // Blood/damage particles
            particles.emit(target.position, 5, 0xff4444, { spread: 1, lifetime: 600, size: 0.15 });
        }

        if (target.userData.hp <= 0) {
            onMobKill(target);
        }
    }

    function onMobKill(mob) {
        // v2.1: Register kill for streak system
        registerKill();

        // v2.1: XP with streak multiplier
        const xpMult = getStreakXPMultiplier();
        const baseXP = mob.userData.xp || 10;
        const totalXP = Math.floor(baseXP * xpMult);
        addXP('combat', totalXP);

        // Gold
        const goldDrop = Math.floor(Math.random() * 10) + 5;
        gameData.gold += goldDrop;
        spawnFloater(mob.position, `+${goldDrop}g`, '#ffd700');

        // v2.1: Show XP bonus if streak active
        if (xpMult > 1) {
            setTimeout(() => {
                spawnFloater(mob.position.clone().add(new THREE.Vector3(0, 1, 0)), `+${totalXP} XP (x${xpMult.toFixed(1)})`, '#00ff88');
            }, 200);
        }

        // v2.1: Death explosion particles
        if (particles) {
            // Main explosion
            particles.emit(mob.position, 20, 0xff4444, { spread: 3, lifetime: 800, size: 0.25 });
            // Secondary burst
            particles.emit(mob.position, 10, 0xffaa00, { spread: 2, lifetime: 600, size: 0.15 });
            // Smoke
            particles.emit(mob.position, 5, 0x444444, { spread: 1.5, lifetime: 1000, size: 0.3 });
        }

        // Remove mob
        const idx = worldState.mobs.indexOf(mob);
        if (idx !== -1) worldState.mobs.splice(idx, 1);

        planetGroup.remove(mob);
        mob.geometry.dispose();
        mob.material.dispose();

        if (particles) {
            particles.emit(mob.position, 15, 0xff4444, { spread: 2, lifetime: 800 });
        }
    }

    // v2.1: Enhanced ability system with style integration
    function useAbility(id) {
        const ability = abilities[id];
        if (!ability) return;

        const now = performance.now();
        if (now - ability.lastUsed < ability.cooldown) return;
        if (gameData.player.energy < ability.energyCost) {
            notify('Not enough energy!', 'error');
            return;
        }

        gameData.player.energy -= ability.energyCost;
        ability.lastUsed = now;

        const player = worldState.player;
        if (!player) return;

        // v2.1: Apply combo multiplier to ability damage
        const comboMult = getComboMultiplier();

        switch (id) {
            case 'powerStrike':
                // Hit nearest mob in range with heavy damage
                let powerStrikeHits = 0;
                worldState.mobs.forEach(mob => {
                    if (player.position.distanceTo(mob.position) < 5) {
                        const baseDamage = ability.damage * (10 + gameData.skills.combat.level * 2);
                        const damage = Math.floor(baseDamage * comboMult);
                        mob.userData.hp -= damage;
                        spawnFloater(mob.position, `-${damage}`, '#ff4400');
                        // v2.1: Register as power attack for style variety
                        registerHit('powerStrike', damage);
                        applyKnockback(mob, player.position, 3); // Heavy knockback
                        powerStrikeHits++;
                        if (mob.userData.hp <= 0) onMobKill(mob);
                    }
                });
                // v2.1: Ability particles
                if (particles) {
                    particles.emit(player.position.clone().add(new THREE.Vector3(0, 1, 0)), 15, 0xff4400, { spread: 2, lifetime: 400, size: 0.2 });
                }
                triggerScreenShake('heavy');
                Audio.play(150, 0.2, 'sawtooth', 0.5);
                break;

            case 'whirlwind':
                // AoE attack around player
                let whirlwindHits = 0;
                worldState.mobs.forEach(mob => {
                    if (player.position.distanceTo(mob.position) < ability.radius) {
                        const baseDamage = ability.damage * (10 + gameData.skills.combat.level);
                        const damage = Math.floor(baseDamage * comboMult);
                        mob.userData.hp -= damage;
                        spawnFloater(mob.position, `-${damage}`, '#00ffff');
                        // v2.1: Register as AoE attack for style variety
                        registerHit('whirlwind', damage);
                        applyKnockback(mob, player.position, 2);
                        whirlwindHits++;
                        if (mob.userData.hp <= 0) onMobKill(mob);
                    }
                });
                // v2.1: Enhanced whirlwind particles
                if (particles) {
                    // Ring of particles
                    for (let i = 0; i < 16; i++) {
                        const angle = (i / 16) * Math.PI * 2;
                        const pos = player.position.clone().add(new THREE.Vector3(
                            Math.cos(angle) * 3,
                            0.5,
                            Math.sin(angle) * 3
                        ));
                        particles.emit(pos, 3, 0x00ffff, { spread: 0.5, lifetime: 500, size: 0.15 });
                    }
                }
                triggerScreenShake('heavy');
                Audio.play(200, 0.3, 'triangle', 0.4);
                break;

            case 'heal':
                const healAmount = gameData.player.maxHp * ability.healPercent;
                gameData.player.hp = Math.min(gameData.player.maxHp, gameData.player.hp + healAmount);
                spawnFloater(player.position, `+${Math.floor(healAmount)}`, '#00ff88');
                // v2.1: Enhanced healing particles
                if (particles) {
                    // Rising healing particles
                    particles.emit(player.position, 15, 0x00ff88, { spread: 1.5, lifetime: 800, size: 0.15 });
                    particles.emit(player.position, 8, 0x88ffaa, { spread: 0.8, lifetime: 600, size: 0.1 });
                }
                Audio.play(600, 0.3, 'sine', 0.3);
                break;

            case 'dash':
                const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                forward.y = 0;
                forward.normalize();
                // v2.1: Dash trail particles
                const startPos = player.position.clone();
                player.position.add(forward.multiplyScalar(ability.distance));
                if (particles) {
                    // Trail particles along dash path
                    for (let i = 0; i < 5; i++) {
                        const trailPos = startPos.clone().lerp(player.position, i / 5);
                        trailPos.y += 1;
                        particles.emit(trailPos, 3, 0x00aaff, { spread: 0.3, lifetime: 300, size: 0.1 });
                    }
                }
                // v2.1: Register dash for style
                registerHit('dash', 0);
                Audio.play(300, 0.1, 'square', 0.3);
                break;
        }
    }

    // ============================================
    // PROGRESSION SYSTEM
    // ============================================
    function addXP(skill, amount) {
        if (!gameData.skills[skill]) return;

        gameData.skills[skill].xp += amount;
        const xpNeeded = getXPForLevel(gameData.skills[skill].level);

        if (gameData.skills[skill].xp >= xpNeeded) {
            gameData.skills[skill].xp -= xpNeeded;
            gameData.skills[skill].level++;

            // Level up bonuses
            if (skill === 'combat') {
                gameData.player.maxHp += 10;
                gameData.player.hp = gameData.player.maxHp;
            }

            notify(`${skill.charAt(0).toUpperCase() + skill.slice(1)} level ${gameData.skills[skill].level}!`);
            Audio.levelUp();
        }
    }

    function getXPForLevel(level) {
        return Math.floor(50 * Math.pow(1.5, level - 1));
    }

    // ============================================
    // INPUT HANDLING
    // ============================================
    function onKeyDown(e) {
        keys[e.key.toLowerCase()] = true;

        // Abilities
        if (mode === 'world') {
            switch (e.key.toLowerCase()) {
                case 'q': useAbility('powerStrike'); break;
                case 'e': useAbility('whirlwind'); break;
                case 'r': useAbility('heal'); break;
                case 'f': useAbility('dash'); break;
            }
        }

        // UI toggles
        switch (e.key.toLowerCase()) {
            case 's':
                if (!e.ctrlKey) {
                    document.getElementById('skills-panel').classList.toggle('visible');
                    document.getElementById('btn-skills').classList.toggle('active');
                }
                break;
            case 'i':
                document.getElementById('inventory-panel').classList.toggle('visible');
                document.getElementById('btn-inventory').classList.toggle('active');
                break;
            case 'g':
                if (mode === 'world') enterGalaxyMode();
                break;
            case 'escape':
                if (planetApproachState.active) {
                    skipPlanetApproach();
                } else {
                    closeAllPanels();
                }
                break;
        }
    }

    function onKeyUp(e) {
        keys[e.key.toLowerCase()] = false;
    }

    function closeAllPanels() {
        document.getElementById('skills-panel').classList.remove('visible');
        document.getElementById('inventory-panel').classList.remove('visible');
        document.getElementById('btn-skills').classList.remove('active');
        document.getElementById('btn-inventory').classList.remove('active');
    }

    function onMouseDown(e) {
        if (mode === 'galaxy' && !planetApproachState.active) {
            // Check for planet click
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2(
                (e.clientX / window.innerWidth) * 2 - 1,
                -(e.clientY / window.innerHeight) * 2 + 1
            );
            raycaster.setFromCamera(mouse, camera);

            const planets = galaxyGroup.children.filter(c => c.userData && c.userData.type);
            const intersects = raycaster.intersectObjects(planets);

            if (intersects.length > 0) {
                const planet = intersects[0].object;
                initiatePlanetApproach(planet.userData, planet);
            }
        } else if (mode === 'world') {
            // Attack nearest mob
            if (worldState.player && worldState.mobs.length > 0) {
                let nearest = null;
                let nearestDist = 5;

                worldState.mobs.forEach(mob => {
                    const dist = worldState.player.position.distanceTo(mob.position);
                    if (dist < nearestDist) {
                        nearest = mob;
                        nearestDist = dist;
                    }
                });

                if (nearest) attack(nearest);
            }
        }
    }

    let hoveredPlanet = null;

    function onMouseMove(e) {
        // Camera rotation in galaxy mode
        if (mode === 'galaxy' && e.buttons === 2) {
            const sensitivity = 0.01;
            camera.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), -e.movementX * sensitivity);
        }

        // Planet hover detection in galaxy mode
        if (mode === 'galaxy' && galaxyGroup) {
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2(
                (e.clientX / window.innerWidth) * 2 - 1,
                -(e.clientY / window.innerHeight) * 2 + 1
            );
            raycaster.setFromCamera(mouse, camera);

            const planets = galaxyGroup.children.filter(c => c.userData && c.userData.type);
            const intersects = raycaster.intersectObjects(planets);

            // Reset previous hover
            if (hoveredPlanet && hoveredPlanet.userData.ring) {
                hoveredPlanet.userData.ring.material.opacity = 0;
            }

            if (intersects.length > 0) {
                hoveredPlanet = intersects[0].object;
                // Highlight ring
                if (hoveredPlanet.userData.ring) {
                    hoveredPlanet.userData.ring.material.opacity = 0.8;
                }
                // Update instruction text
                document.getElementById('instruction-text').innerHTML =
                    `Click to land on <span class="planet-name">${hoveredPlanet.userData.name}</span>`;
                document.body.style.cursor = 'pointer';
            } else {
                hoveredPlanet = null;
                document.getElementById('instruction-text').textContent = 'Click on a planet to land';
                document.body.style.cursor = 'default';
            }
        }
    }

    // Touch controls
    function setupTouchControls() {
        const joystick = document.getElementById('virtual-joystick');
        const knob = document.getElementById('joystick-knob');
        const actionBtn = document.getElementById('touch-action');

        joystick.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const rect = joystick.getBoundingClientRect();
            joystickCenter = { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
            joystickActive = true;
        }, { passive: false });

        joystick.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!joystickActive) return;

            const touch = e.touches[0];
            let dx = touch.clientX - joystickCenter.x;
            let dy = touch.clientY - joystickCenter.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const maxDist = 40;

            if (dist > maxDist) {
                dx = (dx / dist) * maxDist;
                dy = (dy / dist) * maxDist;
            }

            knob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
            joystickInput = { x: dx / maxDist, y: dy / maxDist };
        }, { passive: false });

        joystick.addEventListener('touchend', () => {
            joystickActive = false;
            joystickInput = { x: 0, y: 0 };
            knob.style.transform = 'translate(-50%, -50%)';
        });

        actionBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (mode === 'world' && worldState.mobs.length > 0) {
                let nearest = null;
                let nearestDist = 5;
                worldState.mobs.forEach(mob => {
                    const dist = worldState.player.position.distanceTo(mob.position);
                    if (dist < nearestDist) {
                        nearest = mob;
                        nearestDist = dist;
                    }
                });
                if (nearest) attack(nearest);
            }
        }, { passive: false });
    }

    // ============================================
    // GAME LOOP
    // ============================================
    function update(dt, time) {
        // v2.1: Handle hitstop
        if (combatState.hitStopFrames > 0) {
            combatState.hitStopFrames--;
            // During hitstop, skip most updates but still render
            updateUI();
            return;
        }

        // Handle planet approach animation
        if (planetApproachState.active) {
            updatePlanetApproach(dt, time);
        }

        if (mode === 'galaxy' && !planetApproachState.active) {
            updateGalaxy(dt, time);
        } else if (mode === 'world') {
            updateWorld(dt, time);
            // v2.1: Update combat feedback systems
            updateCombatSystems(dt);
        }

        // Regenerate energy
        if (gameData.player.energy < gameData.player.maxEnergy) {
            gameData.player.energy = Math.min(gameData.player.maxEnergy, gameData.player.energy + dt * 0.005);
        }

        // Particles
        if (particles) {
            particles.update(dt);
        }

        // UI
        updateUI();

        // Auto-save every 30 seconds
        gameData.playtime += dt;
        if (Math.floor(gameData.playtime / 30000) > Math.floor((gameData.playtime - dt) / 30000)) {
            saveGame();
        }
    }

    function updateGalaxy(dt, time) {
        // Rotate galaxy slowly
        if (galaxyGroup) {
            galaxyGroup.rotation.y += dt * 0.00005;
        }

        // Camera zoom with scroll
        // Handled in wheel event

        // Highlight hoverable planets
        // Could add raycasting here
    }

    function updateWorld(dt, time) {
        const player = worldState.player;
        if (!player) return;

        // Movement
        const moveSpeed = keys['shift'] ? 0.15 : 0.08;
        const moveVec = new THREE.Vector3();

        // Keyboard
        if (keys['w'] || keys['arrowup']) moveVec.z -= 1;
        if (keys['s'] || keys['arrowdown']) moveVec.z += 1;
        if (keys['a'] || keys['arrowleft']) moveVec.x -= 1;
        if (keys['d'] || keys['arrowright']) moveVec.x += 1;

        // Joystick
        if (joystickActive) {
            moveVec.x += joystickInput.x;
            moveVec.z += joystickInput.y;
        }

        if (moveVec.length() > 0) {
            moveVec.normalize();

            // Apply camera rotation
            const camForward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
            camForward.y = 0;
            camForward.normalize();
            const camRight = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
            camRight.y = 0;
            camRight.normalize();

            const finalMove = new THREE.Vector3()
                .addScaledVector(camRight, moveVec.x)
                .addScaledVector(camForward, -moveVec.z);

            player.position.add(finalMove.multiplyScalar(moveSpeed * dt));

            // Rotate player to face movement
            player.rotation.y = Math.atan2(finalMove.x, finalMove.z);
        }

        // Keep on terrain
        if (worldState.terrain[0]) {
            const y = getTerrainHeight(player.position.x, player.position.z, worldState.terrain[0]);
            player.position.y = y + 1;
        }

        // Boundary
        const boundary = 45;
        player.position.x = Math.max(-boundary, Math.min(boundary, player.position.x));
        player.position.z = Math.max(-boundary, Math.min(boundary, player.position.z));

        // Camera follow
        const camOffset = new THREE.Vector3(0, 12, 18);
        const targetCamPos = player.position.clone().add(camOffset);
        camera.position.lerp(targetCamPos, 0.05);
        camera.lookAt(player.position);

        // Mob AI
        worldState.mobs.forEach(mob => {
            if (!mob.userData || mob.userData.hp <= 0) return;

            const dist = player.position.distanceTo(mob.position);

            if (dist < 15 && dist > 2) {
                // Chase player
                const dir = player.position.clone().sub(mob.position).normalize();
                mob.position.add(dir.multiplyScalar(mob.userData.speed * dt * 0.01));
                mob.lookAt(player.position);
            } else if (dist <= 2) {
                // Attack player
                if (!mob.userData.lastAttack || time - mob.userData.lastAttack > 1500) {
                    gameData.player.hp -= mob.userData.damage;
                    mob.userData.lastAttack = time;
                    spawnFloater(player.position, `-${mob.userData.damage}`, '#ff4444');

                    if (gameData.player.hp <= 0) {
                        // Death
                        notify('You died! Respawning...', 'error');
                        gameData.player.hp = gameData.player.maxHp * 0.5;
                        player.position.set(0, 2, 0);
                    }
                }
            }
        });

        // Resource interaction
        worldState.interactTarget = null;
        worldState.resources.forEach(res => {
            if (player.position.distanceTo(res.position) < 2) {
                worldState.interactTarget = res;
            }
        });

        // Collect resource on space
        if (keys[' '] && worldState.interactTarget) {
            collectResource(worldState.interactTarget);
            keys[' '] = false;
        }

        // Update minimap
        updateMinimap();
    }

    function collectResource(resource) {
        const item = {
            name: resource.userData.name,
            icon: resource.userData.icon,
            count: 1
        };

        // Add to inventory
        const existing = gameData.inventory.find(i => i && i.name === item.name);
        if (existing) {
            existing.count++;
        } else {
            const emptySlot = gameData.inventory.findIndex(i => !i);
            if (emptySlot === -1) {
                gameData.inventory.push(item);
            } else {
                gameData.inventory[emptySlot] = item;
            }
        }

        // XP
        addXP('mining', 5);

        // Remove from world
        const idx = worldState.resources.indexOf(resource);
        if (idx !== -1) worldState.resources.splice(idx, 1);

        planetGroup.remove(resource);
        resource.geometry.dispose();
        resource.material.dispose();

        Audio.collect();
        spawnFloater(resource.position, `+1 ${item.name}`, '#00ff88');
    }

    function updateMinimap() {
        const canvas = document.getElementById('minimap-canvas');
        const ctx = canvas.getContext('2d');

        if (!ctx) return;

        canvas.width = 120;
        canvas.height = 120;

        ctx.fillStyle = '#001122';
        ctx.fillRect(0, 0, 120, 120);

        const scale = 1.2;
        const offset = 60;

        // Player
        if (worldState.player) {
            const px = worldState.player.position.x * scale + offset;
            const pz = worldState.player.position.z * scale + offset;
            ctx.fillStyle = '#00ff00';
            ctx.beginPath();
            ctx.arc(px, pz, 4, 0, Math.PI * 2);
            ctx.fill();
        }

        // Mobs
        ctx.fillStyle = '#ff4444';
        worldState.mobs.forEach(mob => {
            const mx = mob.position.x * scale + offset;
            const mz = mob.position.z * scale + offset;
            ctx.beginPath();
            ctx.arc(mx, mz, 3, 0, Math.PI * 2);
            ctx.fill();
        });

        // Resources
        ctx.fillStyle = '#00ffff';
        worldState.resources.forEach(res => {
            const rx = res.position.x * scale + offset;
            const rz = res.position.z * scale + offset;
            ctx.beginPath();
            ctx.arc(rx, rz, 2, 0, Math.PI * 2);
            ctx.fill();
        });
    }

    function animate(time) {
        requestAnimationFrame(animate);

        const dt = lastTime ? time - lastTime : 16;
        lastTime = time;

        update(dt, time);

        renderer.render(scene, camera);
    }

    function onResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // ============================================
    // INITIALIZATION
    // ============================================
    function init() {
        // Load saved data
        loadGame();

        // Three.js setup
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000011);
        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);

        const isMobile = /iphone|ipad|ipod|android/i.test(navigator.userAgent);
        renderer = new THREE.WebGLRenderer({
            antialias: !isMobile,
            powerPreference: isMobile ? 'low-power' : 'high-performance',
            alpha: false
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, isMobile ? 1.5 : 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        // r150+ uses outputColorSpace instead of outputEncoding
        if (renderer.outputColorSpace !== undefined) {
            renderer.outputColorSpace = THREE.SRGBColorSpace;
        } else if (renderer.outputEncoding !== undefined) {
            renderer.outputEncoding = THREE.sRGBEncoding;
        }
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        document.getElementById('container').appendChild(renderer.domElement);
        console.log('Renderer initialized');

        // Systems
        Audio.init();
        particles = new ParticleSystem();

        // Event listeners
        window.addEventListener('resize', onResize);
        window.addEventListener('keydown', onKeyDown);
        window.addEventListener('keyup', onKeyUp);
        renderer.domElement.addEventListener('mousedown', onMouseDown);
        renderer.domElement.addEventListener('mousemove', onMouseMove);
        renderer.domElement.addEventListener('contextmenu', e => e.preventDefault());

        // Camera zoom
        window.addEventListener('wheel', (e) => {
            if (mode === 'galaxy') {
                camera.position.y += e.deltaY * 0.1;
                camera.position.y = Math.max(30, Math.min(200, camera.position.y));
                camera.position.z = camera.position.y;
            }
        });

        // Touch controls
        if (isTouchDevice) {
            document.getElementById('touch-controls').style.display = 'block';
            setupTouchControls();
        }

        // UI buttons
        document.getElementById('btn-skills').addEventListener('click', () => {
            document.getElementById('skills-panel').classList.toggle('visible');
            document.getElementById('btn-skills').classList.toggle('active');
        });
        document.getElementById('btn-inventory').addEventListener('click', () => {
            document.getElementById('inventory-panel').classList.toggle('visible');
            document.getElementById('btn-inventory').classList.toggle('active');
        });
        document.getElementById('btn-galaxy').addEventListener('click', () => {
            if (mode === 'world') enterGalaxyMode();
        });

        // Ability buttons
        document.querySelectorAll('.ability-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                useAbility(btn.dataset.ability);
            });
        });

        // Planet approach buttons
        document.getElementById('approach-skip').addEventListener('click', skipPlanetApproach);
        document.getElementById('approach-land').addEventListener('click', completePlanetApproach);

        // Audio unlock on first interaction
        const unlockAudio = () => {
            if (Audio.ctx && Audio.ctx.state === 'suspended') {
                Audio.ctx.resume();
            }
            document.removeEventListener('click', unlockAudio);
            document.removeEventListener('touchstart', unlockAudio);
        };
        document.addEventListener('click', unlockAudio);
        document.addEventListener('touchstart', unlockAudio);

        // Hide loading screen
        document.getElementById('loading').style.display = 'none';

        // Start in galaxy mode
        enterGalaxyMode();

        // Start game loop
        animate(0);

        console.log('LEVIATHAN v2.0 initialized');
    }

    // Start game when DOM ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
    } else {
        init();
    }
    </script>
</body>
</html>
