<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Primordial Soup - Emergence Simulator</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: #0a0a12;
            color: #e0e0e0;
            overflow: hidden;
            height: 100vh;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        canvas {
            display: block;
        }

        /* UI Overlay */
        .ui-layer {
            position: fixed;
            z-index: 100;
            pointer-events: none;
        }

        .ui-layer > * {
            pointer-events: auto;
        }

        /* Title */
        .title-bar {
            top: 20px;
            left: 20px;
        }

        .title {
            font-size: 28px;
            font-weight: 300;
            color: #fff;
            text-shadow: 0 0 30px rgba(100, 200, 255, 0.5);
            letter-spacing: 4px;
        }

        .subtitle {
            font-size: 12px;
            color: #667;
            letter-spacing: 2px;
            margin-top: 5px;
        }

        /* Stats Panel */
        .stats-panel {
            top: 20px;
            right: 20px;
            background: rgba(10, 15, 25, 0.9);
            border: 1px solid rgba(100, 200, 255, 0.2);
            border-radius: 12px;
            padding: 20px;
            min-width: 280px;
            backdrop-filter: blur(10px);
        }

        .stats-header {
            font-size: 11px;
            color: #68f;
            letter-spacing: 2px;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(100, 200, 255, 0.1);
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 13px;
        }

        .stat-label {
            color: #889;
        }

        .stat-value {
            color: #fff;
            font-family: 'Consolas', monospace;
        }

        .stat-value.highlight {
            color: #4f8;
            text-shadow: 0 0 10px rgba(80, 255, 130, 0.5);
        }

        .stat-value.warning {
            color: #f84;
        }

        .stat-bar {
            height: 4px;
            background: rgba(255,255,255,0.1);
            border-radius: 2px;
            margin-top: 4px;
            overflow: hidden;
        }

        .stat-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #48f, #4f8);
            border-radius: 2px;
            transition: width 0.3s;
        }

        /* Milestone Alert */
        .milestone-alert {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10, 20, 40, 0.95);
            border: 2px solid #4f8;
            border-radius: 16px;
            padding: 30px 50px;
            text-align: center;
            z-index: 1000;
            animation: milestoneIn 0.5s ease-out;
            box-shadow: 0 0 60px rgba(80, 255, 130, 0.3);
        }

        .milestone-alert.hidden {
            display: none;
        }

        @keyframes milestoneIn {
            from { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            to { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        .milestone-icon {
            font-size: 48px;
            margin-bottom: 15px;
        }

        .milestone-title {
            font-size: 24px;
            color: #4f8;
            margin-bottom: 10px;
            text-shadow: 0 0 20px rgba(80, 255, 130, 0.5);
        }

        .milestone-desc {
            color: #aab;
            font-size: 14px;
        }

        /* Controls Panel */
        .controls-panel {
            bottom: 20px;
            left: 20px;
            background: rgba(10, 15, 25, 0.9);
            border: 1px solid rgba(100, 200, 255, 0.2);
            border-radius: 12px;
            padding: 20px;
            backdrop-filter: blur(10px);
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        .control-label {
            font-size: 11px;
            color: #68f;
            letter-spacing: 1px;
            margin-bottom: 8px;
            display: block;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 150px;
            height: 4px;
            background: rgba(255,255,255,0.1);
            border-radius: 2px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #48f;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(68, 136, 255, 0.5);
        }

        .slider-value {
            font-size: 12px;
            color: #fff;
            font-family: 'Consolas', monospace;
            min-width: 40px;
        }

        .btn {
            background: linear-gradient(180deg, rgba(68, 136, 255, 0.3), rgba(68, 136, 255, 0.1));
            border: 1px solid rgba(68, 136, 255, 0.4);
            color: #fff;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            letter-spacing: 1px;
            transition: all 0.2s;
            margin-right: 8px;
        }

        .btn:hover {
            background: linear-gradient(180deg, rgba(68, 136, 255, 0.5), rgba(68, 136, 255, 0.2));
            box-shadow: 0 0 20px rgba(68, 136, 255, 0.3);
        }

        .btn.danger {
            background: linear-gradient(180deg, rgba(255, 100, 100, 0.3), rgba(255, 100, 100, 0.1));
            border-color: rgba(255, 100, 100, 0.4);
        }

        .btn.danger:hover {
            background: linear-gradient(180deg, rgba(255, 100, 100, 0.5), rgba(255, 100, 100, 0.2));
            box-shadow: 0 0 20px rgba(255, 100, 100, 0.3);
        }

        .btn.success {
            background: linear-gradient(180deg, rgba(80, 255, 130, 0.3), rgba(80, 255, 130, 0.1));
            border-color: rgba(80, 255, 130, 0.4);
        }

        /* Legend */
        .legend {
            bottom: 20px;
            right: 20px;
            background: rgba(10, 15, 25, 0.9);
            border: 1px solid rgba(100, 200, 255, 0.2);
            border-radius: 12px;
            padding: 15px 20px;
            backdrop-filter: blur(10px);
        }

        .legend-title {
            font-size: 11px;
            color: #68f;
            letter-spacing: 2px;
            margin-bottom: 12px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
            font-size: 12px;
        }

        .legend-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        /* Timeline */
        .timeline {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            z-index: 100;
        }

        .timeline-event {
            display: flex;
            flex-direction: column;
            align-items: center;
            opacity: 0.3;
            transition: opacity 0.3s;
        }

        .timeline-event.achieved {
            opacity: 1;
        }

        .timeline-icon {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(30, 40, 60, 0.9);
            border: 2px solid rgba(100, 200, 255, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            margin-bottom: 5px;
        }

        .timeline-event.achieved .timeline-icon {
            border-color: #4f8;
            box-shadow: 0 0 15px rgba(80, 255, 130, 0.4);
        }

        .timeline-label {
            font-size: 10px;
            color: #667;
            text-align: center;
        }

        .timeline-event.achieved .timeline-label {
            color: #4f8;
        }

        /* Info tooltip */
        .info-btn {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(10, 15, 25, 0.9);
            border: 1px solid rgba(100, 200, 255, 0.2);
            border-radius: 20px;
            padding: 8px 20px;
            color: #68f;
            font-size: 12px;
            cursor: pointer;
            z-index: 100;
            transition: all 0.2s;
        }

        .info-btn:hover {
            background: rgba(68, 136, 255, 0.2);
        }

        /* Data controls */
        .data-controls {
            position: fixed;
            top: 20px;
            right: 320px;
            z-index: 100;
            display: flex;
            gap: 8px;
        }

        .data-controls button {
            background: rgba(10, 15, 25, 0.9);
            border: 1px solid rgba(100, 200, 255, 0.2);
            color: #68f;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
        }

        .data-controls button:hover {
            background: rgba(68, 136, 255, 0.2);
        }

        /* Speed indicator */
        .speed-indicator {
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 200, 50, 0.2);
            border: 1px solid rgba(255, 200, 50, 0.4);
            border-radius: 20px;
            padding: 5px 15px;
            color: #fc8;
            font-size: 11px;
            z-index: 100;
            display: none;
        }

        .speed-indicator.visible {
            display: block;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <!-- Title -->
    <div class="ui-layer title-bar">
        <div class="title">PRIMORDIAL SOUP</div>
        <div class="subtitle">EMERGENCE SIMULATOR</div>
    </div>

    <!-- Data Controls -->
    <div class="data-controls">
        <button onclick="exportData()">Export</button>
        <button onclick="document.getElementById('importFile').click()">Import</button>
        <input type="file" id="importFile" accept=".json" style="display:none" onchange="importData(event)">
    </div>

    <!-- Stats Panel -->
    <div class="ui-layer stats-panel">
        <div class="stats-header">SIMULATION METRICS</div>

        <div class="stat-row">
            <span class="stat-label">Generation</span>
            <span class="stat-value" id="stat-generation">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Time Elapsed</span>
            <span class="stat-value" id="stat-time">0:00</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Total Particles</span>
            <span class="stat-value" id="stat-particles">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Free Particles</span>
            <span class="stat-value" id="stat-free">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Bonded Structures</span>
            <span class="stat-value highlight" id="stat-structures">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Largest Structure</span>
            <span class="stat-value highlight" id="stat-largest">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Replicators Detected</span>
            <span class="stat-value highlight" id="stat-replicators">0</span>
        </div>

        <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(100,200,255,0.1);">
            <div class="stat-row">
                <span class="stat-label">System Energy</span>
                <span class="stat-value" id="stat-energy">0</span>
            </div>
            <div class="stat-bar">
                <div class="stat-bar-fill" id="energy-bar" style="width: 50%"></div>
            </div>
        </div>

        <div style="margin-top: 15px;">
            <div class="stat-row">
                <span class="stat-label">Complexity Index</span>
                <span class="stat-value" id="stat-complexity">0.00</span>
            </div>
            <div class="stat-bar">
                <div class="stat-bar-fill" id="complexity-bar" style="width: 0%; background: linear-gradient(90deg, #f48, #f84, #ff4);"></div>
            </div>
        </div>
    </div>

    <!-- Controls Panel -->
    <div class="ui-layer controls-panel">
        <div class="control-group">
            <label class="control-label">TEMPERATURE</label>
            <div class="slider-container">
                <input type="range" id="temperature" min="0" max="100" value="50">
                <span class="slider-value" id="temp-value">50</span>
            </div>
        </div>

        <div class="control-group">
            <label class="control-label">BOND STRENGTH</label>
            <div class="slider-container">
                <input type="range" id="bondStrength" min="1" max="100" value="40">
                <span class="slider-value" id="bond-value">40</span>
            </div>
        </div>

        <div class="control-group">
            <label class="control-label">PARTICLE DENSITY</label>
            <div class="slider-container">
                <input type="range" id="density" min="50" max="500" value="200">
                <span class="slider-value" id="density-value">200</span>
            </div>
        </div>

        <div class="control-group">
            <label class="control-label">SIMULATION SPEED</label>
            <div class="slider-container">
                <input type="range" id="simSpeed" min="1" max="5" value="1">
                <span class="slider-value" id="speed-value">1x</span>
            </div>
        </div>

        <div class="control-group" style="margin-top: 20px;">
            <button class="btn" id="pauseBtn" onclick="togglePause()">‚è∏ PAUSE</button>
            <button class="btn danger" onclick="resetSimulation()">‚Üª RESET</button>
        </div>

        <div class="control-group">
            <button class="btn success" onclick="injectEnergy()">‚ö° INJECT ENERGY</button>
        </div>
    </div>

    <!-- Legend -->
    <div class="ui-layer legend">
        <div class="legend-title">PARTICLE TYPES</div>
        <div class="legend-item">
            <div class="legend-dot" style="background: #ff6b6b;"></div>
            <span>Type A - Attracts B, Repels A</span>
        </div>
        <div class="legend-item">
            <div class="legend-dot" style="background: #4ecdc4;"></div>
            <span>Type B - Attracts A & C</span>
        </div>
        <div class="legend-item">
            <div class="legend-dot" style="background: #ffe66d;"></div>
            <span>Type C - Catalyzes bonds</span>
        </div>
        <div class="legend-item">
            <div class="legend-dot" style="background: #a855f7;"></div>
            <span>Type D - Energy carrier</span>
        </div>
        <div class="legend-item" style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.1);">
            <div class="legend-dot" style="background: linear-gradient(45deg, #4f8, #8f4); box-shadow: 0 0 10px #4f8;"></div>
            <span style="color: #4f8;">Replicating Structure</span>
        </div>
    </div>

    <!-- Evolution Timeline -->
    <div class="timeline">
        <div class="timeline-event achieved" id="milestone-particles">
            <div class="timeline-icon">üîµ</div>
            <div class="timeline-label">Particles</div>
        </div>
        <div class="timeline-event" id="milestone-bonds">
            <div class="timeline-icon">üîó</div>
            <div class="timeline-label">First Bond</div>
        </div>
        <div class="timeline-event" id="milestone-chains">
            <div class="timeline-icon">‚õìÔ∏è</div>
            <div class="timeline-label">Chains</div>
        </div>
        <div class="timeline-event" id="milestone-loops">
            <div class="timeline-icon">‚≠ï</div>
            <div class="timeline-label">Loops</div>
        </div>
        <div class="timeline-event" id="milestone-complex">
            <div class="timeline-icon">üß¨</div>
            <div class="timeline-label">Complex</div>
        </div>
        <div class="timeline-event" id="milestone-replicator">
            <div class="timeline-icon">‚ú®</div>
            <div class="timeline-label">Replicator!</div>
        </div>
    </div>

    <!-- Info Button -->
    <div class="info-btn" onclick="showInfo()">
        ‚ÑπÔ∏è HOW LIFE EMERGES
    </div>

    <!-- Speed Indicator -->
    <div class="speed-indicator" id="speedIndicator">‚ö° 2x SPEED</div>

    <!-- Milestone Alert -->
    <div class="milestone-alert hidden" id="milestoneAlert">
        <div class="milestone-icon">üéâ</div>
        <div class="milestone-title">MILESTONE REACHED!</div>
        <div class="milestone-desc" id="milestoneDesc">Description here</div>
    </div>

    <script>
        // ============================================
        // PRIMORDIAL SOUP - EMERGENCE SIMULATOR
        // ============================================
        // Particles with simple physics rules spontaneously
        // evolve into self-replicating structures.
        // No DNA, no genetics - just thermodynamics.
        // ============================================

        const APP_NAME = 'primordial-soup';

        // Simulation state
        let canvas, ctx;
        let width, height;
        let particles = [];
        let bonds = [];
        let structures = [];
        let paused = false;
        let generation = 0;
        let startTime = Date.now();
        let lastTime = 0;
        let simSpeed = 1;

        // Milestones
        const milestones = {
            particles: true,
            bonds: false,
            chains: false,
            loops: false,
            complex: false,
            replicator: false
        };

        // Statistics
        let stats = {
            totalBondsFormed: 0,
            totalReplicators: 0,
            maxStructureSize: 0,
            replicationEvents: 0
        };

        // Configuration
        let config = {
            temperature: 50,
            bondStrength: 40,
            particleCount: 200,
            friction: 0.98,
            bondDistance: 30,
            repulsionDistance: 50,
            attractionDistance: 100
        };

        // Particle types with interaction rules
        const PARTICLE_TYPES = {
            A: {
                color: '#ff6b6b',
                glowColor: 'rgba(255, 107, 107, 0.5)',
                mass: 1.0,
                // Interaction matrix: positive = attract, negative = repel
                interactions: { A: -0.8, B: 1.2, C: 0.3, D: 0.5 },
                canBond: ['B', 'C'],
                maxBonds: 2
            },
            B: {
                color: '#4ecdc4',
                glowColor: 'rgba(78, 205, 196, 0.5)',
                mass: 1.2,
                interactions: { A: 1.2, B: -0.5, C: 0.8, D: 0.3 },
                canBond: ['A', 'C', 'D'],
                maxBonds: 3
            },
            C: {
                color: '#ffe66d',
                glowColor: 'rgba(255, 230, 109, 0.5)',
                mass: 0.8,
                interactions: { A: 0.3, B: 0.8, C: 0.1, D: 1.0 },
                canBond: ['A', 'B', 'D'],
                maxBonds: 4,  // Catalyst - can form many bonds
                catalyzes: true
            },
            D: {
                color: '#a855f7',
                glowColor: 'rgba(168, 85, 247, 0.5)',
                mass: 0.6,
                interactions: { A: 0.5, B: 0.3, C: 1.0, D: -1.0 },
                canBond: ['B', 'C'],
                maxBonds: 2,
                energyCarrier: true
            }
        };

        // Initialize
        function init() {
            canvas = document.createElement('canvas');
            document.getElementById('canvas-container').appendChild(canvas);
            ctx = canvas.getContext('2d');

            resize();
            window.addEventListener('resize', resize);

            // Set up controls
            setupControls();

            // Spawn initial particles
            spawnParticles(config.particleCount);

            // Start simulation
            requestAnimationFrame(loop);
        }

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
        }

        function setupControls() {
            const tempSlider = document.getElementById('temperature');
            const bondSlider = document.getElementById('bondStrength');
            const densitySlider = document.getElementById('density');
            const speedSlider = document.getElementById('simSpeed');

            tempSlider.addEventListener('input', (e) => {
                config.temperature = parseInt(e.target.value);
                document.getElementById('temp-value').textContent = config.temperature;
            });

            bondSlider.addEventListener('input', (e) => {
                config.bondStrength = parseInt(e.target.value);
                document.getElementById('bond-value').textContent = config.bondStrength;
            });

            densitySlider.addEventListener('input', (e) => {
                const newCount = parseInt(e.target.value);
                document.getElementById('density-value').textContent = newCount;
                adjustParticleCount(newCount);
            });

            speedSlider.addEventListener('input', (e) => {
                simSpeed = parseInt(e.target.value);
                document.getElementById('speed-value').textContent = simSpeed + 'x';
                const indicator = document.getElementById('speedIndicator');
                if (simSpeed > 1) {
                    indicator.textContent = '‚ö° ' + simSpeed + 'x SPEED';
                    indicator.classList.add('visible');
                } else {
                    indicator.classList.remove('visible');
                }
            });
        }

        // Particle class
        class Particle {
            constructor(x, y, type) {
                this.id = Math.random().toString(36).substr(2, 9);
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.type = type;
                this.config = PARTICLE_TYPES[type];
                this.bonds = [];
                this.energy = 50 + Math.random() * 50;
                this.age = 0;
                this.structureId = null;
                this.isReplicator = false;
                this.pulsePhase = Math.random() * Math.PI * 2;
            }

            get bondCount() {
                return this.bonds.length;
            }

            canBondWith(other) {
                if (this.bondCount >= this.config.maxBonds) return false;
                if (other.bondCount >= other.config.maxBonds) return false;
                if (!this.config.canBond.includes(other.type)) return false;
                // Check if already bonded
                if (this.bonds.some(b => b.other === other)) return false;
                return true;
            }
        }

        // Bond class
        class Bond {
            constructor(p1, p2) {
                this.p1 = p1;
                this.p2 = p2;
                this.strength = config.bondStrength / 100;
                this.restLength = config.bondDistance;
                this.age = 0;
                this.energy = 100;
            }

            get length() {
                const dx = this.p2.x - this.p1.x;
                const dy = this.p2.y - this.p1.y;
                return Math.sqrt(dx * dx + dy * dy);
            }
        }

        function spawnParticles(count) {
            const types = ['A', 'B', 'C', 'D'];
            const weights = [0.35, 0.35, 0.2, 0.1]; // Distribution

            for (let i = 0; i < count; i++) {
                // Weighted random type selection
                let r = Math.random();
                let type = 'A';
                let cumulative = 0;
                for (let j = 0; j < types.length; j++) {
                    cumulative += weights[j];
                    if (r < cumulative) {
                        type = types[j];
                        break;
                    }
                }

                const margin = 100;
                const x = margin + Math.random() * (width - margin * 2);
                const y = margin + Math.random() * (height - margin * 2);

                particles.push(new Particle(x, y, type));
            }
        }

        function adjustParticleCount(targetCount) {
            const diff = targetCount - particles.length;

            if (diff > 0) {
                // Add particles
                const types = ['A', 'B', 'C', 'D'];
                for (let i = 0; i < diff; i++) {
                    const type = types[Math.floor(Math.random() * types.length)];
                    const x = Math.random() * width;
                    const y = Math.random() * height;
                    particles.push(new Particle(x, y, type));
                }
            } else if (diff < 0) {
                // Remove unbonded particles first
                const unbonded = particles.filter(p => p.bondCount === 0);
                const toRemove = Math.min(-diff, unbonded.length);
                for (let i = 0; i < toRemove; i++) {
                    const idx = particles.indexOf(unbonded[i]);
                    if (idx > -1) particles.splice(idx, 1);
                }
            }

            config.particleCount = particles.length;
        }

        // Physics simulation
        function simulate(dt) {
            const tempFactor = config.temperature / 50;
            const bondStr = config.bondStrength / 100;

            // Update particles
            for (const p of particles) {
                p.age += dt;
                p.pulsePhase += dt * 3;

                // Apply random thermal motion
                p.vx += (Math.random() - 0.5) * tempFactor * 0.5;
                p.vy += (Math.random() - 0.5) * tempFactor * 0.5;

                // Particle-particle interactions
                for (const other of particles) {
                    if (p === other) continue;

                    const dx = other.x - p.x;
                    const dy = other.y - p.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < 1) continue;
                    if (dist > config.attractionDistance) continue;

                    const nx = dx / dist;
                    const ny = dy / dist;

                    // Get interaction strength from matrix
                    const interaction = p.config.interactions[other.type] || 0;

                    // Apply force based on distance and interaction type
                    let force = 0;

                    if (dist < config.repulsionDistance) {
                        // Close range - repulsion dominates
                        force = -2 / (dist * dist) + interaction * 0.1;
                    } else {
                        // Medium range - interaction rules apply
                        force = interaction * 0.3 / dist;
                    }

                    p.vx += nx * force * dt * 10;
                    p.vy += ny * force * dt * 10;

                    // Bonding logic
                    if (dist < config.bondDistance && p.canBondWith(other)) {
                        // Check if bonding conditions are met
                        const bondChance = calculateBondChance(p, other, dist);

                        if (Math.random() < bondChance * dt) {
                            createBond(p, other);
                        }
                    }
                }

                // Apply friction
                p.vx *= config.friction;
                p.vy *= config.friction;

                // Update position
                p.x += p.vx * dt * 60;
                p.y += p.vy * dt * 60;

                // Boundary wrapping
                if (p.x < 0) p.x = width;
                if (p.x > width) p.x = 0;
                if (p.y < 0) p.y = height;
                if (p.y > height) p.y = 0;

                // Energy decay
                p.energy *= 0.9999;
            }

            // Update bonds
            for (let i = bonds.length - 1; i >= 0; i--) {
                const bond = bonds[i];
                bond.age += dt;

                // Spring force to maintain bond length
                const dx = bond.p2.x - bond.p1.x;
                const dy = bond.p2.y - bond.p1.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist > 0) {
                    const displacement = dist - bond.restLength;
                    const force = displacement * bondStr * 0.5;

                    const nx = dx / dist;
                    const ny = dy / dist;

                    bond.p1.vx += nx * force * dt * 10;
                    bond.p1.vy += ny * force * dt * 10;
                    bond.p2.vx -= nx * force * dt * 10;
                    bond.p2.vy -= ny * force * dt * 10;
                }

                // Bond breaking from high temperature or strain
                const strain = Math.abs(dist - bond.restLength) / bond.restLength;
                const breakChance = strain * tempFactor * 0.01;

                if (Math.random() < breakChance * dt || dist > bond.restLength * 3) {
                    breakBond(bond);
                }
            }

            // Analyze structures
            analyzeStructures();

            // Check for replication
            checkReplication();

            generation++;
        }

        function calculateBondChance(p1, p2, dist) {
            // Base chance based on distance
            let chance = 1 - (dist / config.bondDistance);

            // Catalyst bonus
            if (p1.config.catalyzes || p2.config.catalyzes) {
                chance *= 2;
            }

            // Energy bonus
            if (p1.config.energyCarrier || p2.config.energyCarrier) {
                chance *= 1.5;
            }

            // Temperature effect - higher temp = fewer stable bonds
            chance *= (100 - config.temperature) / 100;

            // Bond strength effect
            chance *= config.bondStrength / 100;

            return Math.max(0, Math.min(1, chance * 0.1));
        }

        function createBond(p1, p2) {
            const bond = new Bond(p1, p2);
            bonds.push(bond);

            p1.bonds.push({ bond, other: p2 });
            p2.bonds.push({ bond, other: p1 });

            stats.totalBondsFormed++;

            // Check milestone
            if (!milestones.bonds) {
                milestones.bonds = true;
                achieveMilestone('bonds', 'üîó First Bond Formed!', 'Particles have begun connecting. Chemistry begins.');
            }
        }

        function breakBond(bond) {
            // Remove from particles
            bond.p1.bonds = bond.p1.bonds.filter(b => b.bond !== bond);
            bond.p2.bonds = bond.p2.bonds.filter(b => b.bond !== bond);

            // Remove from bonds array
            const idx = bonds.indexOf(bond);
            if (idx > -1) bonds.splice(idx, 1);
        }

        function analyzeStructures() {
            // Find connected components (structures)
            const visited = new Set();
            structures = [];

            for (const p of particles) {
                if (visited.has(p.id)) continue;
                if (p.bondCount === 0) continue;

                // BFS to find all connected particles
                const structure = [];
                const queue = [p];

                while (queue.length > 0) {
                    const current = queue.shift();
                    if (visited.has(current.id)) continue;

                    visited.add(current.id);
                    structure.push(current);

                    for (const bondInfo of current.bonds) {
                        if (!visited.has(bondInfo.other.id)) {
                            queue.push(bondInfo.other);
                        }
                    }
                }

                if (structure.length >= 2) {
                    const structureId = structure.map(p => p.id).sort().join('-');
                    structure.forEach(p => p.structureId = structureId);

                    structures.push({
                        id: structureId,
                        particles: structure,
                        size: structure.length,
                        hasLoop: detectLoop(structure),
                        typeSignature: getTypeSignature(structure),
                        isComplex: structure.length >= 6,
                        isReplicator: false
                    });
                }
            }

            // Update milestones
            const maxSize = Math.max(0, ...structures.map(s => s.size));
            stats.maxStructureSize = Math.max(stats.maxStructureSize, maxSize);

            if (maxSize >= 4 && !milestones.chains) {
                milestones.chains = true;
                achieveMilestone('chains', '‚õìÔ∏è Chain Formed!', 'A chain of 4+ particles. Polymers emerge.');
            }

            if (structures.some(s => s.hasLoop) && !milestones.loops) {
                milestones.loops = true;
                achieveMilestone('loops', '‚≠ï Ring Structure!', 'A closed loop detected. Cyclic molecules appear.');
            }

            if (structures.some(s => s.isComplex) && !milestones.complex) {
                milestones.complex = true;
                achieveMilestone('complex', 'üß¨ Complex Structure!', 'A structure of 6+ particles. Macromolecules form.');
            }
        }

        function detectLoop(structure) {
            // Check if structure contains a cycle
            if (structure.length < 3) return false;

            for (const p of structure) {
                if (p.bondCount >= 2) {
                    // Try to find a cycle starting from this particle
                    const visited = new Set();
                    const stack = [{ particle: p, parent: null }];

                    while (stack.length > 0) {
                        const { particle, parent } = stack.pop();

                        if (visited.has(particle.id)) {
                            return true; // Found a cycle
                        }

                        visited.add(particle.id);

                        for (const bondInfo of particle.bonds) {
                            if (bondInfo.other !== parent) {
                                stack.push({ particle: bondInfo.other, parent: particle });
                            }
                        }
                    }
                }
            }

            return false;
        }

        function getTypeSignature(structure) {
            const counts = { A: 0, B: 0, C: 0, D: 0 };
            for (const p of structure) {
                counts[p.type]++;
            }
            return `${counts.A}A${counts.B}B${counts.C}C${counts.D}D`;
        }

        function checkReplication() {
            // Look for structures that might be replicating
            // A replicator needs: enough particles nearby, the right structure

            for (const structure of structures) {
                if (structure.size < 4) continue;
                if (!structure.hasLoop) continue;

                // Check for nearby free particles that match the structure's needs
                const center = getStructureCenter(structure);
                const nearbyFree = particles.filter(p => {
                    if (p.bondCount > 0) return false;
                    const dx = p.x - center.x;
                    const dy = p.y - center.y;
                    return Math.sqrt(dx * dx + dy * dy) < 100;
                });

                // Check if we have enough material to replicate
                const typeCounts = {};
                for (const p of structure.particles) {
                    typeCounts[p.type] = (typeCounts[p.type] || 0) + 1;
                }

                const freeCounts = {};
                for (const p of nearbyFree) {
                    freeCounts[p.type] = (freeCounts[p.type] || 0) + 1;
                }

                // Can replicate if we have enough of each type nearby
                let canReplicate = true;
                for (const type in typeCounts) {
                    if ((freeCounts[type] || 0) < typeCounts[type]) {
                        canReplicate = false;
                        break;
                    }
                }

                // Attempt replication with low probability
                if (canReplicate && Math.random() < 0.0001) {
                    attemptReplication(structure, nearbyFree);
                }

                structure.isReplicator = canReplicate && structure.hasLoop && structure.size >= 4;

                if (structure.isReplicator) {
                    structure.particles.forEach(p => p.isReplicator = true);

                    if (!milestones.replicator) {
                        milestones.replicator = true;
                        achieveMilestone('replicator', '‚ú® REPLICATOR DETECTED!',
                            'A self-replicating structure has emerged! Life begins.');
                    }
                }
            }
        }

        function getStructureCenter(structure) {
            let x = 0, y = 0;
            for (const p of structure.particles) {
                x += p.x;
                y += p.y;
            }
            return { x: x / structure.particles.length, y: y / structure.particles.length };
        }

        function attemptReplication(structure, nearbyFree) {
            const center = getStructureCenter(structure);
            const offset = 80;

            // Get type counts needed
            const needed = {};
            for (const p of structure.particles) {
                needed[p.type] = (needed[p.type] || 0) + 1;
            }

            // Gather particles for new structure
            const newStructureParticles = [];
            const used = new Set();

            for (const type in needed) {
                let count = needed[type];
                for (const p of nearbyFree) {
                    if (count <= 0) break;
                    if (used.has(p.id)) continue;
                    if (p.type !== type) continue;

                    // Move particle toward replication site
                    p.x = center.x + offset + (Math.random() - 0.5) * 40;
                    p.y = center.y + (Math.random() - 0.5) * 40;
                    p.vx = 0;
                    p.vy = 0;

                    newStructureParticles.push(p);
                    used.add(p.id);
                    count--;
                }
            }

            // Trigger bonding between new particles
            if (newStructureParticles.length >= structure.size * 0.8) {
                stats.replicationEvents++;
                stats.totalReplicators++;

                // Force bonds to form in similar pattern
                for (let i = 0; i < newStructureParticles.length - 1; i++) {
                    const p1 = newStructureParticles[i];
                    const p2 = newStructureParticles[i + 1];
                    if (p1.canBondWith(p2)) {
                        createBond(p1, p2);
                    }
                }

                // Try to close the loop
                const first = newStructureParticles[0];
                const last = newStructureParticles[newStructureParticles.length - 1];
                if (first.canBondWith(last)) {
                    createBond(first, last);
                }
            }
        }

        function achieveMilestone(id, title, description) {
            // Update timeline
            const el = document.getElementById('milestone-' + id);
            if (el) el.classList.add('achieved');

            // Show alert
            const alert = document.getElementById('milestoneAlert');
            document.getElementById('milestoneDesc').textContent = description;
            document.querySelector('.milestone-title').textContent = title;
            alert.classList.remove('hidden');

            setTimeout(() => {
                alert.classList.add('hidden');
            }, 4000);
        }

        // Rendering
        function render() {
            // Clear with fade effect for trails
            ctx.fillStyle = 'rgba(10, 10, 18, 0.3)';
            ctx.fillRect(0, 0, width, height);

            // Draw bonds
            for (const bond of bonds) {
                const p1 = bond.p1;
                const p2 = bond.p2;

                // Bond color based on connected types
                const gradient = ctx.createLinearGradient(p1.x, p1.y, p2.x, p2.y);
                gradient.addColorStop(0, p1.config.color);
                gradient.addColorStop(1, p2.config.color);

                ctx.strokeStyle = gradient;
                ctx.lineWidth = 2 + Math.sin(bond.age * 3) * 0.5;
                ctx.globalAlpha = 0.6;

                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();

                ctx.globalAlpha = 1;
            }

            // Draw particles
            for (const p of particles) {
                const pulse = Math.sin(p.pulsePhase) * 0.3 + 1;
                const baseRadius = 4 + (p.bondCount * 1.5);
                const radius = baseRadius * pulse;

                // Glow for bonded particles
                if (p.bondCount > 0) {
                    const glowRadius = radius * 3;
                    const glow = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, glowRadius);
                    glow.addColorStop(0, p.config.glowColor);
                    glow.addColorStop(1, 'transparent');

                    ctx.fillStyle = glow;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, glowRadius, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Special glow for replicators
                if (p.isReplicator) {
                    const replicatorGlow = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, radius * 5);
                    replicatorGlow.addColorStop(0, 'rgba(80, 255, 130, 0.4)');
                    replicatorGlow.addColorStop(0.5, 'rgba(80, 255, 130, 0.1)');
                    replicatorGlow.addColorStop(1, 'transparent');

                    ctx.fillStyle = replicatorGlow;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, radius * 5, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Particle body
                ctx.fillStyle = p.isReplicator ? '#4f8' : p.config.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
                ctx.fill();

                // Inner highlight
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.beginPath();
                ctx.arc(p.x - radius * 0.3, p.y - radius * 0.3, radius * 0.4, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function updateUI() {
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;

            document.getElementById('stat-generation').textContent = generation.toLocaleString();
            document.getElementById('stat-time').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            document.getElementById('stat-particles').textContent = particles.length;
            document.getElementById('stat-free').textContent = particles.filter(p => p.bondCount === 0).length;
            document.getElementById('stat-structures').textContent = structures.length;
            document.getElementById('stat-largest').textContent = stats.maxStructureSize;
            document.getElementById('stat-replicators').textContent = structures.filter(s => s.isReplicator).length;

            // Energy (average kinetic energy)
            const avgEnergy = particles.reduce((sum, p) => {
                return sum + Math.sqrt(p.vx * p.vx + p.vy * p.vy);
            }, 0) / particles.length;
            document.getElementById('stat-energy').textContent = avgEnergy.toFixed(2);
            document.getElementById('energy-bar').style.width = Math.min(100, avgEnergy * 20) + '%';

            // Complexity index (based on structure count and sizes)
            const complexity = structures.reduce((sum, s) => {
                let score = s.size;
                if (s.hasLoop) score *= 2;
                if (s.isComplex) score *= 1.5;
                if (s.isReplicator) score *= 3;
                return sum + score;
            }, 0) / Math.max(1, particles.length) * 10;

            document.getElementById('stat-complexity').textContent = complexity.toFixed(2);
            document.getElementById('complexity-bar').style.width = Math.min(100, complexity * 10) + '%';
        }

        // Main loop
        function loop(time) {
            const dt = Math.min(0.05, (time - lastTime) / 1000);
            lastTime = time;

            if (!paused) {
                for (let i = 0; i < simSpeed; i++) {
                    simulate(dt / simSpeed);
                }
            }

            render();
            updateUI();

            requestAnimationFrame(loop);
        }

        // Controls
        function togglePause() {
            paused = !paused;
            document.getElementById('pauseBtn').textContent = paused ? '‚ñ∂ PLAY' : '‚è∏ PAUSE';
        }

        function resetSimulation() {
            particles = [];
            bonds = [];
            structures = [];
            generation = 0;
            startTime = Date.now();
            stats = {
                totalBondsFormed: 0,
                totalReplicators: 0,
                maxStructureSize: 0,
                replicationEvents: 0
            };

            // Reset milestones (except particles)
            milestones.bonds = false;
            milestones.chains = false;
            milestones.loops = false;
            milestones.complex = false;
            milestones.replicator = false;

            document.querySelectorAll('.timeline-event').forEach(el => {
                if (el.id !== 'milestone-particles') {
                    el.classList.remove('achieved');
                }
            });

            spawnParticles(config.particleCount);
        }

        function injectEnergy() {
            // Add kinetic energy to all particles
            for (const p of particles) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 3 + Math.random() * 3;
                p.vx += Math.cos(angle) * speed;
                p.vy += Math.sin(angle) * speed;
                p.energy += 50;
            }

            // Visual flash
            ctx.fillStyle = 'rgba(255, 255, 100, 0.3)';
            ctx.fillRect(0, 0, width, height);
        }

        function showInfo() {
            alert(`PRIMORDIAL SOUP - How Life Emerges

This simulation demonstrates abiogenesis - the emergence of life from non-living matter.

RULES:
‚Ä¢ Particles attract or repel based on type
‚Ä¢ Bonds form when compatible particles get close
‚Ä¢ High temperature breaks bonds, low temperature stabilizes them
‚Ä¢ Structures can self-replicate when enough free particles are nearby

PARTICLE TYPES:
üî¥ Type A - Building blocks, attract Type B
üîµ Type B - Connectors, can bond with most types
üü° Type C - Catalysts, speed up reactions
üü£ Type D - Energy carriers, activate processes

MILESTONES:
1. First Bond - Chemistry begins
2. Chains - Polymers form
3. Loops - Cyclic structures appear
4. Complex - Macromolecules emerge
5. Replicator - LIFE BEGINS!

Watch as simple physics creates complexity.
No DNA. No genetics. Just thermodynamics.`);
        }

        // Data export/import
        function exportData() {
            const data = {
                config,
                stats,
                milestones,
                particles: particles.map(p => ({
                    x: p.x, y: p.y, vx: p.vx, vy: p.vy,
                    type: p.type, energy: p.energy
                })),
                timestamp: Date.now()
            };

            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `primordial-soup-${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);

                    // Restore config
                    if (data.config) {
                        Object.assign(config, data.config);
                        document.getElementById('temperature').value = config.temperature;
                        document.getElementById('temp-value').textContent = config.temperature;
                        document.getElementById('bondStrength').value = config.bondStrength;
                        document.getElementById('bond-value').textContent = config.bondStrength;
                        document.getElementById('density').value = config.particleCount;
                        document.getElementById('density-value').textContent = config.particleCount;
                    }

                    // Restore particles
                    if (data.particles) {
                        particles = [];
                        bonds = [];
                        structures = [];

                        for (const pData of data.particles) {
                            const p = new Particle(pData.x, pData.y, pData.type);
                            p.vx = pData.vx;
                            p.vy = pData.vy;
                            p.energy = pData.energy;
                            particles.push(p);
                        }
                    }

                    // Restore milestones
                    if (data.milestones) {
                        Object.assign(milestones, data.milestones);
                        for (const [key, achieved] of Object.entries(milestones)) {
                            const el = document.getElementById('milestone-' + key);
                            if (el) {
                                if (achieved) el.classList.add('achieved');
                                else el.classList.remove('achieved');
                            }
                        }
                    }

                    if (data.stats) {
                        Object.assign(stats, data.stats);
                    }

                    startTime = Date.now() - (data.timestamp ? Date.now() - data.timestamp : 0);

                } catch (err) {
                    alert('Error loading save file: ' + err.message);
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        // Initialize on load
        window.addEventListener('load', init);
    </script>
</body>
</html>
