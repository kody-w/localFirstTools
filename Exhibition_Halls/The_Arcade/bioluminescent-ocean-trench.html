<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bioluminescent Deep Ocean Trench</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
            position: relative;
        }

        #canvas {
            width: 100vw;
            height: 100vh;
            display: block;
            background: linear-gradient(180deg, #001122 0%, #000511 50%, #000000 100%);
        }

        /* HUD Elements */
        .hud {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            pointer-events: none;
        }

        .depth-meter {
            background: rgba(0, 20, 40, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            margin-bottom: 10px;
            backdrop-filter: blur(10px);
        }

        .depth-meter h3 {
            font-size: 14px;
            color: #00ffff;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .depth-value {
            font-size: 28px;
            font-weight: bold;
            color: #00ffff;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        .discovery-counter {
            background: rgba(0, 20, 40, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            backdrop-filter: blur(10px);
        }

        .discovery-counter h3 {
            font-size: 14px;
            color: #00ff88;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .discovery-value {
            font-size: 20px;
            color: #00ff88;
        }

        /* Discovery Notification */
        .discovery-notification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 40, 80, 0.9);
            padding: 30px;
            border-radius: 15px;
            border: 2px solid rgba(0, 255, 255, 0.5);
            display: none;
            z-index: 200;
            text-align: center;
            backdrop-filter: blur(15px);
            animation: glow 2s ease-in-out infinite;
        }

        @keyframes glow {
            0%, 100% { box-shadow: 0 0 30px rgba(0, 255, 255, 0.5); }
            50% { box-shadow: 0 0 50px rgba(0, 255, 255, 0.8); }
        }

        .discovery-notification h2 {
            font-size: 24px;
            color: #00ffff;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 3px;
        }

        .discovery-notification p {
            color: #88ffff;
            font-size: 16px;
            margin-bottom: 5px;
        }

        /* Controls Panel */
        .controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 20, 40, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            z-index: 100;
            backdrop-filter: blur(10px);
        }

        .controls h3 {
            font-size: 14px;
            color: #00ffff;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .controls p {
            font-size: 12px;
            color: #88ffff;
            margin: 3px 0;
        }

        /* Journal/Map */
        .journal {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 300px;
            max-height: 400px;
            background: rgba(0, 20, 40, 0.9);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            z-index: 100;
            overflow-y: auto;
            display: none;
            backdrop-filter: blur(10px);
        }

        .journal.open {
            display: block;
        }

        .journal h2 {
            font-size: 18px;
            color: #00ffff;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .species-entry {
            background: rgba(0, 40, 60, 0.5);
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 5px;
            border-left: 3px solid #00ff88;
        }

        .species-entry h4 {
            color: #00ff88;
            margin-bottom: 5px;
        }

        .species-entry p {
            font-size: 12px;
            color: #88ffff;
        }

        /* Data Controls */
        .data-controls {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1000;
        }

        .data-controls button {
            margin-left: 10px;
            padding: 10px 20px;
            cursor: pointer;
            background: rgba(0, 40, 80, 0.9);
            color: #00ffff;
            border: 1px solid #00ffff;
            border-radius: 5px;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            backdrop-filter: blur(10px);
            transition: all 0.3s;
        }

        .data-controls button:hover {
            background: rgba(0, 60, 100, 0.9);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        #importFile {
            display: none;
        }

        /* Loading Screen */
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 1000;
        }

        .loading h1 {
            font-size: 32px;
            color: #00ffff;
            margin-bottom: 20px;
            text-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }

        .loading-bar {
            width: 300px;
            height: 4px;
            background: rgba(0, 40, 80, 0.5);
            border-radius: 2px;
            overflow: hidden;
        }

        .loading-progress {
            height: 100%;
            background: linear-gradient(90deg, #00ffff, #00ff88);
            animation: loading 1.5s ease-in-out infinite;
        }

        @keyframes loading {
            0% { width: 0%; }
            100% { width: 100%; }
        }

        /* Toggle Journal Button */
        .toggle-journal {
            position: absolute;
            top: 20px;
            right: 340px;
            padding: 10px 20px;
            background: rgba(0, 40, 80, 0.9);
            color: #00ffff;
            border: 1px solid #00ffff;
            border-radius: 5px;
            cursor: pointer;
            z-index: 100;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            backdrop-filter: blur(10px);
            transition: all 0.3s;
        }

        .toggle-journal:hover {
            background: rgba(0, 60, 100, 0.9);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        /* Custom scrollbar for journal */
        .journal::-webkit-scrollbar {
            width: 8px;
        }

        .journal::-webkit-scrollbar-track {
            background: rgba(0, 20, 40, 0.5);
            border-radius: 4px;
        }

        .journal::-webkit-scrollbar-thumb {
            background: rgba(0, 255, 255, 0.5);
            border-radius: 4px;
        }

        .journal::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 255, 255, 0.7);
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div class="loading" id="loading">
        <h1>Descending into the Abyss</h1>
        <div class="loading-bar">
            <div class="loading-progress"></div>
        </div>
    </div>

    <!-- Canvas for 3D Scene -->
    <canvas id="canvas"></canvas>

    <!-- HUD Elements -->
    <div class="hud">
        <div class="depth-meter">
            <h3>Depth</h3>
            <div class="depth-value" id="depthValue">0m</div>
        </div>
        <div class="discovery-counter">
            <h3>Species Discovered</h3>
            <div class="discovery-value" id="discoveryValue">0 / 12</div>
        </div>
    </div>

    <!-- Controls Guide -->
    <div class="controls">
        <h3>Controls</h3>
        <p>WASD - Move Forward/Back/Strafe</p>
        <p>Space/Shift - Ascend/Descend</p>
        <p>Mouse - Look Around</p>
        <p>Click - Scan Creature</p>
        <p>J - Toggle Journal</p>
    </div>

    <!-- Discovery Notification -->
    <div class="discovery-notification" id="discoveryNotification">
        <h2>New Species Discovered!</h2>
        <p id="speciesName"></p>
        <p id="speciesDesc"></p>
    </div>

    <!-- Toggle Journal Button -->
    <button class="toggle-journal" onclick="toggleJournal()">Journal [J]</button>

    <!-- Species Journal -->
    <div class="journal" id="journal">
        <h2>Species Journal</h2>
        <div id="journalContent"></div>
    </div>

    <!-- Data Controls -->
    <div class="data-controls">
        <button onclick="exportData()">Export Data</button>
        <button onclick="document.getElementById('importFile').click()">Import Data</button>
        <input type="file" id="importFile" accept=".json" onchange="importData(event)">
    </div>

    <script>
        // Application state
        const APP_NAME = 'bioluminescent-ocean-trench';
        let appData = {
            discoveries: [],
            totalDepthReached: 0,
            playTime: 0,
            lastPlayed: new Date().toISOString()
        };

        // Load saved data
        const savedData = localStorage.getItem(APP_NAME);
        if (savedData) {
            appData = JSON.parse(savedData);
        }

        // Game variables
        let scene, camera, renderer;
        let player = {
            position: { x: 0, y: 0, z: 0 },
            velocity: { x: 0, y: 0, z: 0 },
            rotation: { x: 0, y: 0 }
        };
        let creatures = [];
        let particles = [];
        let bubbles = [];
        let ruins = [];
        let currentDepth = 0;
        let isJournalOpen = false;

        // Species database
        const speciesDatabase = [
            {
                id: 'giant-jellyfish',
                name: 'Aurelia Gigantis',
                description: 'Colossal jellyfish with trailing tentacles that glow like aurora',
                color: 0x00ffff,
                size: 50,
                depth: 100,
                type: 'jellyfish'
            },
            {
                id: 'crystal-squid',
                name: 'Crystalline Cephalopod',
                description: 'Transparent squid with crystalline organs visible through its skin',
                color: 0xff00ff,
                size: 15,
                depth: 200,
                type: 'squid'
            },
            {
                id: 'void-whale',
                name: 'Abyssal Leviathan',
                description: 'Ancient whale-like creature that feeds on thermal energy',
                color: 0x0088ff,
                size: 80,
                depth: 500,
                type: 'whale'
            },
            {
                id: 'light-fish',
                name: 'Photonic Minnow',
                description: 'Small schooling fish that create light patterns for communication',
                color: 0xffff00,
                size: 2,
                depth: 150,
                type: 'fish'
            },
            {
                id: 'coral-dragon',
                name: 'Coral Serpent',
                description: 'Eel-like creature covered in living bioluminescent coral',
                color: 0x00ff88,
                size: 25,
                depth: 300,
                type: 'eel'
            },
            {
                id: 'phantom-ray',
                name: 'Ghost Manta',
                description: 'Ethereal ray that phases in and out of visibility',
                color: 0x8800ff,
                size: 30,
                depth: 400,
                type: 'ray'
            },
            {
                id: 'thermal-worm',
                name: 'Hydrothermal Annelid',
                description: 'Giant tube worm that thrives near volcanic vents',
                color: 0xff8800,
                size: 10,
                depth: 600,
                type: 'worm'
            },
            {
                id: 'glass-shark',
                name: 'Vitrum Predator',
                description: 'Transparent shark with visible bioluminescent organs',
                color: 0x00ffcc,
                size: 20,
                depth: 350,
                type: 'shark'
            },
            {
                id: 'spiral-nautilus',
                name: 'Fibonacci Nautilus',
                description: 'Ancient shelled creature with hypnotic spiral patterns',
                color: 0xff00aa,
                size: 8,
                depth: 250,
                type: 'nautilus'
            },
            {
                id: 'electric-medusa',
                name: 'Tesla Medusa',
                description: 'Jellyfish that generates bioelectric fields',
                color: 0x00ccff,
                size: 12,
                depth: 450,
                type: 'jellyfish'
            },
            {
                id: 'prism-octopus',
                name: 'Rainbow Octopus',
                description: 'Color-shifting cephalopod that refracts light',
                color: 0xffffff,
                size: 18,
                depth: 550,
                type: 'octopus'
            },
            {
                id: 'void-angler',
                name: 'Abyssal Angler',
                description: 'Deep sea predator with hypnotic bioluminescent lure',
                color: 0xff4400,
                size: 22,
                depth: 700,
                type: 'angler'
            }
        ];

        // Input handling
        const keys = {};
        let mouseX = 0, mouseY = 0;
        let isPointerLocked = false;

        // Simple 3D engine setup
        function init() {
            // Setup canvas and context
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            // Initialize game world
            initializeCreatures();
            initializeEnvironment();

            // Hide loading screen
            setTimeout(() => {
                document.getElementById('loading').style.display = 'none';
            }, 2000);

            // Start game loop
            gameLoop(ctx);

            // Setup input handlers
            setupInputHandlers(canvas);

            // Update journal
            updateJournal();
        }

        function initializeCreatures() {
            // Create creatures at various depths
            speciesDatabase.forEach(species => {
                const creature = {
                    ...species,
                    x: (Math.random() - 0.5) * 1000,
                    y: -species.depth + (Math.random() - 0.5) * 50,
                    z: (Math.random() - 0.5) * 1000,
                    discovered: appData.discoveries.includes(species.id),
                    animation: Math.random() * Math.PI * 2,
                    speed: Math.random() * 0.5 + 0.5
                };
                creatures.push(creature);
            });
        }

        function initializeEnvironment() {
            // Create hydrothermal vents
            for (let i = 0; i < 5; i++) {
                const vent = {
                    x: (Math.random() - 0.5) * 800,
                    y: -600 - Math.random() * 200,
                    z: (Math.random() - 0.5) * 800
                };

                // Create bubble streams
                for (let j = 0; j < 20; j++) {
                    bubbles.push({
                        x: vent.x + (Math.random() - 0.5) * 20,
                        y: vent.y + Math.random() * 200,
                        z: vent.z + (Math.random() - 0.5) * 20,
                        size: Math.random() * 3 + 1,
                        speed: Math.random() * 2 + 1,
                        baseY: vent.y
                    });
                }
            }

            // Create ancient ruins
            for (let i = 0; i < 8; i++) {
                ruins.push({
                    x: (Math.random() - 0.5) * 1200,
                    y: -300 - Math.random() * 400,
                    z: (Math.random() - 0.5) * 1200,
                    size: Math.random() * 50 + 30,
                    rotation: Math.random() * Math.PI * 2
                });
            }

            // Create ambient particles
            for (let i = 0; i < 200; i++) {
                particles.push({
                    x: (Math.random() - 0.5) * 500,
                    y: (Math.random() - 0.5) * 500,
                    z: (Math.random() - 0.5) * 500,
                    size: Math.random() * 2,
                    speed: Math.random() * 0.5
                });
            }
        }

        function gameLoop(ctx) {
            // Clear canvas with deep ocean gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            const depthFactor = Math.min(Math.abs(player.position.y) / 1000, 1);
            gradient.addColorStop(0, `rgba(0, ${20 - depthFactor * 20}, ${40 - depthFactor * 40}, 1)`);
            gradient.addColorStop(1, `rgba(0, ${5 - depthFactor * 5}, ${10 - depthFactor * 10}, 1)`);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Update player physics
            updatePlayer();

            // Update environment
            updateEnvironment();

            // Render 3D scene (simplified projection)
            render3D(ctx);

            // Update HUD
            updateHUD();

            // Continue loop
            requestAnimationFrame(() => gameLoop(ctx));
        }

        function updatePlayer() {
            // Apply movement based on input
            const speed = 0.8;
            const lookSpeed = 0.002;

            // Forward/backward movement
            if (keys['w']) {
                player.velocity.z += Math.cos(player.rotation.y) * speed;
                player.velocity.x += Math.sin(player.rotation.y) * speed;
            }
            if (keys['s']) {
                player.velocity.z -= Math.cos(player.rotation.y) * speed;
                player.velocity.x -= Math.sin(player.rotation.y) * speed;
            }

            // Strafe movement
            if (keys['a']) {
                player.velocity.x += Math.cos(player.rotation.y) * speed;
                player.velocity.z -= Math.sin(player.rotation.y) * speed;
            }
            if (keys['d']) {
                player.velocity.x -= Math.cos(player.rotation.y) * speed;
                player.velocity.z += Math.sin(player.rotation.y) * speed;
            }

            // Vertical movement
            if (keys[' ']) player.velocity.y += speed;
            if (keys['shift']) player.velocity.y -= speed;

            // Apply velocity with water resistance
            player.position.x += player.velocity.x;
            player.position.y += player.velocity.y;
            player.position.z += player.velocity.z;

            // Water resistance (drag)
            player.velocity.x *= 0.92;
            player.velocity.y *= 0.92;
            player.velocity.z *= 0.92;

            // Update rotation based on mouse
            if (isPointerLocked) {
                player.rotation.y += mouseX * lookSpeed;
                player.rotation.x += mouseY * lookSpeed;
                player.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, player.rotation.x));
                mouseX = 0;
                mouseY = 0;
            }

            // Update current depth
            currentDepth = Math.max(0, Math.abs(player.position.y));
            if (currentDepth > appData.totalDepthReached) {
                appData.totalDepthReached = currentDepth;
                saveData();
            }
        }

        function updateEnvironment() {
            // Animate creatures
            creatures.forEach(creature => {
                creature.animation += 0.02 * creature.speed;

                // Different movement patterns based on type
                switch(creature.type) {
                    case 'jellyfish':
                        creature.y += Math.sin(creature.animation) * 0.3;
                        break;
                    case 'fish':
                    case 'squid':
                        creature.x += Math.cos(creature.animation) * creature.speed;
                        creature.z += Math.sin(creature.animation) * creature.speed;
                        break;
                    case 'whale':
                        creature.x += Math.cos(creature.animation * 0.3) * 0.5;
                        creature.y += Math.sin(creature.animation * 0.2) * 0.2;
                        break;
                    case 'ray':
                        creature.y += Math.sin(creature.animation) * 0.5;
                        creature.x += Math.cos(creature.animation * 0.5) * 2;
                        break;
                }

                // Wrap around world bounds
                if (Math.abs(creature.x) > 1500) creature.x *= -0.9;
                if (Math.abs(creature.z) > 1500) creature.z *= -0.9;
            });

            // Update bubbles
            bubbles.forEach(bubble => {
                bubble.y += bubble.speed;
                if (bubble.y > bubble.baseY + 300) {
                    bubble.y = bubble.baseY;
                }
                bubble.x += Math.sin(Date.now() * 0.001 + bubble.y) * 0.1;
            });

            // Update particles
            particles.forEach(particle => {
                particle.y += particle.speed * 0.1;
                particle.x += Math.sin(Date.now() * 0.0001 + particle.y) * 0.05;

                // Wrap particles
                if (particle.y > 250) particle.y = -250;
            });
        }

        function render3D(ctx) {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const fov = 800;

            // Render ruins (furthest back)
            ruins.forEach(ruin => {
                const dx = ruin.x - player.position.x;
                const dy = ruin.y - player.position.y;
                const dz = ruin.z - player.position.z;

                // Simple 3D projection
                const rotX = dx * Math.cos(-player.rotation.y) - dz * Math.sin(-player.rotation.y);
                const rotZ = dx * Math.sin(-player.rotation.y) + dz * Math.cos(-player.rotation.y);
                const rotY = dy * Math.cos(player.rotation.x) - rotZ * Math.sin(player.rotation.x);
                const finalZ = dy * Math.sin(player.rotation.x) + rotZ * Math.cos(player.rotation.x);

                if (finalZ > 0) {
                    const scale = fov / finalZ;
                    const screenX = centerX + rotX * scale;
                    const screenY = centerY - rotY * scale;
                    const size = ruin.size * scale;

                    // Draw ruin with glowing coral
                    ctx.save();
                    ctx.translate(screenX, screenY);
                    ctx.rotate(ruin.rotation);

                    // Ruin structure
                    ctx.fillStyle = `rgba(20, 30, 40, ${0.8 - finalZ / 1000})`;
                    ctx.fillRect(-size/2, -size, size, size * 1.5);

                    // Glowing coral accents
                    const glowIntensity = Math.sin(Date.now() * 0.001 + ruin.rotation) * 0.5 + 0.5;
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = `rgba(0, 255, 136, ${glowIntensity})`;
                    ctx.fillStyle = `rgba(0, 255, 136, ${0.3 * glowIntensity})`;
                    ctx.fillRect(-size/3, -size * 0.8, size/6, size * 0.3);
                    ctx.fillRect(size/6, -size * 0.6, size/6, size * 0.4);

                    ctx.restore();
                }
            });

            // Render bubbles
            ctx.shadowBlur = 10;
            bubbles.forEach(bubble => {
                const dx = bubble.x - player.position.x;
                const dy = bubble.y - player.position.y;
                const dz = bubble.z - player.position.z;

                const rotX = dx * Math.cos(-player.rotation.y) - dz * Math.sin(-player.rotation.y);
                const rotZ = dx * Math.sin(-player.rotation.y) + dz * Math.cos(-player.rotation.y);
                const rotY = dy * Math.cos(player.rotation.x) - rotZ * Math.sin(player.rotation.x);
                const finalZ = dy * Math.sin(player.rotation.x) + rotZ * Math.cos(player.rotation.x);

                if (finalZ > 0 && finalZ < 500) {
                    const scale = fov / finalZ;
                    const screenX = centerX + rotX * scale;
                    const screenY = centerY - rotY * scale;
                    const size = bubble.size * scale;

                    ctx.shadowColor = 'rgba(100, 200, 255, 0.5)';
                    ctx.fillStyle = `rgba(100, 200, 255, ${0.3 - finalZ / 1000})`;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, size, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            // Render creatures
            creatures.forEach(creature => {
                const dx = creature.x - player.position.x;
                const dy = creature.y - player.position.y;
                const dz = creature.z - player.position.z;

                const rotX = dx * Math.cos(-player.rotation.y) - dz * Math.sin(-player.rotation.y);
                const rotZ = dx * Math.sin(-player.rotation.y) + dz * Math.cos(-player.rotation.y);
                const rotY = dy * Math.cos(player.rotation.x) - rotZ * Math.sin(player.rotation.x);
                const finalZ = dy * Math.sin(player.rotation.x) + rotZ * Math.cos(player.rotation.x);

                if (finalZ > 0 && finalZ < 1000) {
                    const scale = fov / finalZ;
                    const screenX = centerX + rotX * scale;
                    const screenY = centerY - rotY * scale;
                    const size = creature.size * scale;

                    // Enhanced glow for discovered creatures
                    if (creature.discovered) {
                        const pulseIntensity = Math.sin(Date.now() * 0.002 + creature.animation) * 0.5 + 0.5;
                        ctx.shadowBlur = 30 + pulseIntensity * 20;
                        ctx.shadowColor = `rgba(${(creature.color >> 16) & 255}, ${(creature.color >> 8) & 255}, ${creature.color & 255}, ${pulseIntensity})`;
                    } else {
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = 'rgba(0, 100, 150, 0.3)';
                    }

                    // Draw creature shape based on type
                    ctx.save();
                    ctx.translate(screenX, screenY);

                    const alpha = creature.discovered ? 0.8 : 0.3;
                    const r = (creature.color >> 16) & 255;
                    const g = (creature.color >> 8) & 255;
                    const b = creature.color & 255;

                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;

                    switch(creature.type) {
                        case 'jellyfish':
                            // Bell shape
                            ctx.beginPath();
                            ctx.ellipse(0, 0, size, size * 0.7, 0, 0, Math.PI);
                            ctx.fill();
                            // Tentacles
                            for(let i = 0; i < 8; i++) {
                                const tentacleX = (i - 3.5) * size / 4;
                                const wave = Math.sin(creature.animation * 2 + i) * 5;
                                ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${alpha * 0.5})`;
                                ctx.lineWidth = 2;
                                ctx.beginPath();
                                ctx.moveTo(tentacleX, 0);
                                ctx.quadraticCurveTo(tentacleX + wave, size, tentacleX + wave * 2, size * 2);
                                ctx.stroke();
                            }
                            break;

                        case 'whale':
                            // Elongated body
                            ctx.beginPath();
                            ctx.ellipse(0, 0, size * 1.5, size * 0.5, 0, 0, Math.PI * 2);
                            ctx.fill();
                            // Tail
                            ctx.beginPath();
                            ctx.moveTo(size * 1.2, 0);
                            ctx.lineTo(size * 2, -size * 0.3);
                            ctx.lineTo(size * 2, size * 0.3);
                            ctx.closePath();
                            ctx.fill();
                            break;

                        case 'ray':
                            // Wing shape
                            ctx.beginPath();
                            ctx.moveTo(0, 0);
                            ctx.quadraticCurveTo(-size, -size/2, -size * 1.5, 0);
                            ctx.quadraticCurveTo(-size, size/2, 0, 0);
                            ctx.quadraticCurveTo(size, size/2, size * 1.5, 0);
                            ctx.quadraticCurveTo(size, -size/2, 0, 0);
                            ctx.fill();
                            break;

                        default:
                            // Default fish/creature shape
                            ctx.beginPath();
                            ctx.ellipse(0, 0, size, size * 0.6, 0, 0, Math.PI * 2);
                            ctx.fill();
                    }

                    ctx.restore();
                }
            });

            // Render particles (closest)
            ctx.shadowBlur = 5;
            particles.forEach(particle => {
                const dx = particle.x - player.position.x % 500;
                const dy = particle.y - player.position.y % 500;
                const dz = particle.z - player.position.z % 500;

                const rotX = dx * Math.cos(-player.rotation.y) - dz * Math.sin(-player.rotation.y);
                const rotZ = dx * Math.sin(-player.rotation.y) + dz * Math.cos(-player.rotation.y);
                const rotY = dy * Math.cos(player.rotation.x) - rotZ * Math.sin(player.rotation.x);
                const finalZ = dy * Math.sin(player.rotation.x) + rotZ * Math.cos(player.rotation.x);

                if (finalZ > 0 && finalZ < 300) {
                    const scale = fov / finalZ;
                    const screenX = centerX + rotX * scale;
                    const screenY = centerY - rotY * scale;
                    const size = particle.size * scale;

                    ctx.shadowColor = 'rgba(150, 200, 255, 0.5)';
                    ctx.fillStyle = `rgba(150, 200, 255, ${0.5 - finalZ / 600})`;
                    ctx.fillRect(screenX - size/2, screenY - size/2, size, size);
                }
            });

            ctx.shadowBlur = 0;
        }

        function setupInputHandlers(canvas) {
            // Keyboard input
            document.addEventListener('keydown', (e) => {
                keys[e.key.toLowerCase()] = true;

                if (e.key.toLowerCase() === 'j') {
                    toggleJournal();
                }
            });

            document.addEventListener('keyup', (e) => {
                keys[e.key.toLowerCase()] = false;
            });

            // Mouse input
            canvas.addEventListener('click', () => {
                if (!isPointerLocked) {
                    canvas.requestPointerLock();
                } else {
                    // Try to scan for nearby creatures
                    scanForCreatures();
                }
            });

            document.addEventListener('pointerlockchange', () => {
                isPointerLocked = document.pointerLockElement === canvas;
            });

            document.addEventListener('mousemove', (e) => {
                if (isPointerLocked) {
                    mouseX = e.movementX;
                    mouseY = e.movementY;
                }
            });

            // Window resize
            window.addEventListener('resize', () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            });
        }

        function scanForCreatures() {
            let closestCreature = null;
            let closestDistance = Infinity;

            creatures.forEach(creature => {
                const distance = Math.sqrt(
                    Math.pow(creature.x - player.position.x, 2) +
                    Math.pow(creature.y - player.position.y, 2) +
                    Math.pow(creature.z - player.position.z, 2)
                );

                if (distance < 100 && distance < closestDistance) {
                    closestDistance = distance;
                    closestCreature = creature;
                }
            });

            if (closestCreature && !closestCreature.discovered) {
                discoverCreature(closestCreature);
            }
        }

        function discoverCreature(creature) {
            creature.discovered = true;
            if (!appData.discoveries.includes(creature.id)) {
                appData.discoveries.push(creature.id);
                saveData();

                // Show discovery notification
                const notification = document.getElementById('discoveryNotification');
                document.getElementById('speciesName').textContent = creature.name;
                document.getElementById('speciesDesc').textContent = creature.description;
                notification.style.display = 'block';

                setTimeout(() => {
                    notification.style.display = 'none';
                }, 4000);

                updateJournal();
                updateHUD();
            }
        }

        function updateHUD() {
            document.getElementById('depthValue').textContent = `${Math.floor(currentDepth)}m`;
            document.getElementById('discoveryValue').textContent = `${appData.discoveries.length} / ${speciesDatabase.length}`;
        }

        function toggleJournal() {
            isJournalOpen = !isJournalOpen;
            document.getElementById('journal').classList.toggle('open', isJournalOpen);
        }

        function updateJournal() {
            const journalContent = document.getElementById('journalContent');
            journalContent.innerHTML = '';

            if (appData.discoveries.length === 0) {
                journalContent.innerHTML = '<p style="color: #88ffff; font-size: 14px;">No species discovered yet. Explore the depths and click on creatures to scan them.</p>';
                return;
            }

            appData.discoveries.forEach(discoveryId => {
                const species = speciesDatabase.find(s => s.id === discoveryId);
                if (species) {
                    const entry = document.createElement('div');
                    entry.className = 'species-entry';
                    entry.innerHTML = `
                        <h4>${species.name}</h4>
                        <p>${species.description}</p>
                        <p style="color: #00ff88; font-size: 10px; margin-top: 5px;">Found at depth: ~${species.depth}m</p>
                    `;
                    journalContent.appendChild(entry);
                }
            });
        }

        function saveData() {
            localStorage.setItem(APP_NAME, JSON.stringify(appData));
        }

        function exportData() {
            const dataStr = JSON.stringify(appData, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `${APP_NAME}-data-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);
        }

        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importedData = JSON.parse(e.target.result);
                    // Merge discoveries
                    if (importedData.discoveries) {
                        importedData.discoveries.forEach(id => {
                            if (!appData.discoveries.includes(id)) {
                                appData.discoveries.push(id);
                            }
                        });
                    }
                    // Update depth record
                    if (importedData.totalDepthReached > appData.totalDepthReached) {
                        appData.totalDepthReached = importedData.totalDepthReached;
                    }

                    // Update creature states
                    creatures.forEach(creature => {
                        if (appData.discoveries.includes(creature.id)) {
                            creature.discovered = true;
                        }
                    });

                    saveData();
                    updateJournal();
                    updateHUD();
                    alert('Data imported successfully!');
                } catch (error) {
                    alert('Error importing data: Invalid JSON file');
                }
            };
            reader.readAsText(file);
        }

        // Initialize the game when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>