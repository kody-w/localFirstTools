<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>⚛️ Particle Physics Playground</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #000;
            color: #00ff00;
            overflow: hidden;
            height: 100vh;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, #001122 0%, #000000 100%);
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00aaff;
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 0 20px rgba(0, 170, 255, 0.5);
            pointer-events: auto;
        }

        .hud-item {
            margin: 8px 0;
            font-size: 14px;
            color: #00ff00;
        }

        .hud-label {
            color: #00aaff;
            font-weight: bold;
        }

        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #ff00aa;
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 0 20px rgba(255, 0, 170, 0.5);
            pointer-events: auto;
            max-width: 300px;
        }

        .control-section {
            margin-bottom: 15px;
        }

        .control-title {
            color: #ff00aa;
            font-weight: bold;
            margin-bottom: 8px;
            font-size: 16px;
        }

        .control-text {
            color: #00ff00;
            font-size: 12px;
            line-height: 1.6;
        }

        button {
            background: linear-gradient(135deg, #00aaff, #0066aa);
            border: 2px solid #00ff00;
            color: #fff;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-family: inherit;
            font-size: 14px;
            transition: all 0.3s;
            pointer-events: auto;
            box-shadow: 0 0 10px rgba(0, 170, 255, 0.3);
        }

        button:hover {
            background: linear-gradient(135deg, #00ddff, #0088cc);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.6);
            transform: scale(1.05);
        }

        button.active {
            background: linear-gradient(135deg, #ff00aa, #aa0066);
            border-color: #ff00aa;
        }

        #menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 3px solid #00aaff;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 0 40px rgba(0, 170, 255, 0.7);
            pointer-events: auto;
            max-width: 600px;
        }

        #menu h1 {
            color: #00aaff;
            font-size: 36px;
            margin-bottom: 10px;
            text-shadow: 0 0 10px rgba(0, 170, 255, 0.8);
        }

        #menu p {
            color: #00ff00;
            margin: 15px 0;
            line-height: 1.6;
        }

        .particle-selector {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .particle-btn {
            padding: 15px 25px;
            font-size: 16px;
            min-width: 150px;
        }

        #infoPanel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #00ff00;
            padding: 15px;
            border-radius: 5px;
            max-width: 400px;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
            pointer-events: auto;
        }

        .info-title {
            color: #00aaff;
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 10px;
        }

        .info-text {
            color: #00ff00;
            font-size: 12px;
            line-height: 1.5;
        }

        #elementDisplay {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #ff00aa;
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 0 20px rgba(255, 0, 170, 0.5);
            pointer-events: auto;
            min-width: 250px;
        }

        .element-item {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            color: #00ff00;
            font-size: 12px;
        }

        .element-symbol {
            color: #ff00aa;
            font-weight: bold;
        }

        .hidden {
            display: none !important;
        }

        .toolbar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00aaff;
            padding: 10px;
            border-radius: 5px;
            display: flex;
            gap: 10px;
            box-shadow: 0 0 20px rgba(0, 170, 255, 0.5);
        }

        @media (max-width: 768px) {
            #hud, #controls, #infoPanel, #elementDisplay {
                font-size: 10px;
                padding: 10px;
            }

            #menu {
                width: 90%;
                padding: 20px;
            }

            #menu h1 {
                font-size: 24px;
            }

            button {
                padding: 8px 15px;
                font-size: 12px;
            }
        }

        .glow {
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from {
                text-shadow: 0 0 5px #00aaff, 0 0 10px #00aaff;
            }
            to {
                text-shadow: 0 0 10px #00aaff, 0 0 20px #00aaff, 0 0 30px #00aaff;
            }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <div id="ui">
        <!-- Main Menu -->
        <div id="menu">
            <h1 class="glow">⚛️ PARTICLE PHYSICS PLAYGROUND</h1>
            <p>Experience the quantum world as a subatomic particle!</p>
            <p>Race through accelerators, collide to create elements, and observe quantum phenomena.</p>

            <div class="control-section">
                <div class="control-title">SELECT YOUR PARTICLE:</div>
                <div class="particle-selector">
                    <button class="particle-btn" data-particle="electron">⚡ Electron<br><span style="font-size: 10px;">Fast & Light</span></button>
                    <button class="particle-btn" data-particle="proton">➕ Proton<br><span style="font-size: 10px;">Positive Charge</span></button>
                    <button class="particle-btn" data-particle="neutron">⚪ Neutron<br><span style="font-size: 10px;">Neutral Mass</span></button>
                </div>
            </div>

            <button id="startBtn">START EXPERIMENT</button>
            <button id="importBtn">IMPORT DATA</button>
            <button id="exportBtn">EXPORT DATA</button>
        </div>

        <!-- HUD -->
        <div id="hud" class="hidden">
            <div class="hud-item"><span class="hud-label">Particle:</span> <span id="particleType">Electron</span></div>
            <div class="hud-item"><span class="hud-label">Speed:</span> <span id="speedDisplay">0</span> c</div>
            <div class="hud-item"><span class="hud-label">Energy:</span> <span id="energyDisplay">100</span> MeV</div>
            <div class="hud-item"><span class="hud-label">Collisions:</span> <span id="collisionCount">0</span></div>
            <div class="hud-item"><span class="hud-label">Quantum State:</span> <span id="quantumState">Normal</span></div>
            <div class="hud-item"><span class="hud-label">Distance:</span> <span id="distanceDisplay">0</span> fm</div>
        </div>

        <!-- Controls Info -->
        <div id="controls" class="hidden">
            <div class="control-section">
                <div class="control-title">CONTROLS</div>
                <div class="control-text">
                    WASD / Arrow Keys - Move<br>
                    SPACE - Boost<br>
                    Q - Quantum Tunnel<br>
                    E - Superposition<br>
                    R - Reset Position<br>
                    ESC - Menu
                </div>
            </div>
            <div class="control-section">
                <div class="control-title">QUANTUM EFFECTS</div>
                <div class="control-text">
                    Blue Tubes - Accelerators<br>
                    Green Orbs - Particles<br>
                    Pink Barriers - Tunnel Through<br>
                    Yellow Fields - Magnetic
                </div>
            </div>
        </div>

        <!-- Info Panel -->
        <div id="infoPanel" class="hidden">
            <div class="info-title">PHYSICS INFO</div>
            <div class="info-text" id="infoText">
                Particle accelerators boost subatomic particles to near light speed.
                When particles collide with sufficient energy, they can create new elements and particles.
                Quantum tunneling allows particles to pass through barriers that classical physics would forbid.
            </div>
        </div>

        <!-- Element Display -->
        <div id="elementDisplay" class="hidden">
            <div class="info-title">ELEMENTS CREATED</div>
            <div id="elementList">
                <div class="element-item">
                    <span class="element-symbol">H</span>
                    <span id="hydrogen">0</span>
                </div>
                <div class="element-item">
                    <span class="element-symbol">He</span>
                    <span id="helium">0</span>
                </div>
                <div class="element-item">
                    <span class="element-symbol">Li</span>
                    <span id="lithium">0</span>
                </div>
                <div class="element-item">
                    <span class="element-symbol">Be</span>
                    <span id="beryllium">0</span>
                </div>
            </div>
        </div>

        <!-- Toolbar -->
        <div class="toolbar hidden" id="toolbar">
            <button id="resetBtn">RESET</button>
            <button id="toggleInfoBtn">TOGGLE INFO</button>
            <button id="menuBtn">MENU</button>
        </div>
    </div>

    <input type="file" id="fileInput" style="display: none;" accept=".json">

    <script>
        // ==================== GAME STATE ====================
        const GameState = {
            canvas: null,
            ctx: null,
            width: 0,
            height: 0,
            running: false,
            paused: false,
            particleType: 'electron',

            // Player state
            player: {
                x: 0,
                y: 0,
                z: 0,
                vx: 0,
                vy: 0,
                vz: 0,
                speed: 0,
                energy: 100,
                mass: 1,
                charge: -1,
                color: '#00aaff',
                radius: 5,
                trail: [],
                maxTrailLength: 50
            },

            // Game stats
            stats: {
                collisions: 0,
                distance: 0,
                elementsCreated: {
                    hydrogen: 0,
                    helium: 0,
                    lithium: 0,
                    beryllium: 0
                }
            },

            // Quantum effects
            quantum: {
                tunneling: false,
                superposition: false,
                superpositionClones: [],
                tunnelingCooldown: 0,
                superpositionCooldown: 0
            },

            // World objects
            accelerators: [],
            particles: [],
            barriers: [],
            magneticFields: [],

            // Camera
            camera: {
                x: 0,
                y: 0,
                z: 300,
                rotX: 0,
                rotY: 0
            },

            // Input
            keys: {},

            // Constants
            MAX_SPEED: 0.99, // Speed of light fraction
            BOOST_ACCELERATION: 0.02,
            FRICTION: 0.98,
            TUNNEL_DURATION: 60,
            SUPERPOSITION_DURATION: 120
        };

        // ==================== PARTICLE TYPES ====================
        const ParticleTypes = {
            electron: {
                mass: 1,
                charge: -1,
                color: '#00aaff',
                speed: 1.0,
                name: 'Electron'
            },
            proton: {
                mass: 1836,
                charge: 1,
                color: '#ff00aa',
                speed: 0.6,
                name: 'Proton'
            },
            neutron: {
                mass: 1839,
                charge: 0,
                color: '#ffffff',
                speed: 0.7,
                name: 'Neutron'
            }
        };

        // ==================== INITIALIZATION ====================
        function init() {
            GameState.canvas = document.getElementById('gameCanvas');
            GameState.ctx = GameState.canvas.getContext('2d');

            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            setupEventListeners();
            loadGameData();
            generateWorld();
        }

        function resizeCanvas() {
            GameState.canvas.width = window.innerWidth;
            GameState.canvas.height = window.innerHeight;
            GameState.width = GameState.canvas.width;
            GameState.height = GameState.canvas.height;
        }

        function setupEventListeners() {
            // Keyboard
            document.addEventListener('keydown', (e) => {
                GameState.keys[e.key.toLowerCase()] = true;

                if (e.key === 'Escape') {
                    toggleMenu();
                } else if (e.key.toLowerCase() === 'q') {
                    activateTunneling();
                } else if (e.key.toLowerCase() === 'e') {
                    activateSuperposition();
                } else if (e.key.toLowerCase() === 'r') {
                    resetPlayerPosition();
                }
            });

            document.addEventListener('keyup', (e) => {
                GameState.keys[e.key.toLowerCase()] = false;
            });

            // UI Buttons
            document.querySelectorAll('.particle-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const particle = e.currentTarget.dataset.particle;
                    selectParticle(particle);
                });
            });

            document.getElementById('startBtn').addEventListener('click', startGame);
            document.getElementById('importBtn').addEventListener('click', importData);
            document.getElementById('exportBtn').addEventListener('click', exportData);
            document.getElementById('resetBtn').addEventListener('click', resetGame);
            document.getElementById('toggleInfoBtn').addEventListener('click', toggleInfo);
            document.getElementById('menuBtn').addEventListener('click', toggleMenu);

            // File input
            document.getElementById('fileInput').addEventListener('change', handleFileImport);
        }

        // ==================== WORLD GENERATION ====================
        function generateWorld() {
            GameState.accelerators = [];
            GameState.particles = [];
            GameState.barriers = [];
            GameState.magneticFields = [];

            // Create circular accelerator ring
            const ringRadius = 400;
            const numSegments = 12;
            for (let i = 0; i < numSegments; i++) {
                const angle = (i / numSegments) * Math.PI * 2;
                const nextAngle = ((i + 1) / numSegments) * Math.PI * 2;

                GameState.accelerators.push({
                    x1: Math.cos(angle) * ringRadius,
                    y1: Math.sin(angle) * ringRadius,
                    z1: 0,
                    x2: Math.cos(nextAngle) * ringRadius,
                    y2: Math.sin(nextAngle) * ringRadius,
                    z2: 0,
                    radius: 30,
                    power: 2.0
                });
            }

            // Add vertical accelerator sections
            for (let i = 0; i < 4; i++) {
                const angle = (i / 4) * Math.PI * 2;
                const x = Math.cos(angle) * ringRadius;
                const y = Math.sin(angle) * ringRadius;

                GameState.accelerators.push({
                    x1: x,
                    y1: y,
                    z1: -200,
                    x2: x,
                    y2: y,
                    z2: 200,
                    radius: 30,
                    power: 1.5
                });
            }

            // Spawn random particles
            for (let i = 0; i < 30; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * 500 + 100;

                GameState.particles.push({
                    x: Math.cos(angle) * distance,
                    y: Math.sin(angle) * distance,
                    z: (Math.random() - 0.5) * 400,
                    vx: (Math.random() - 0.5) * 0.5,
                    vy: (Math.random() - 0.5) * 0.5,
                    vz: (Math.random() - 0.5) * 0.5,
                    type: ['proton', 'neutron', 'electron'][Math.floor(Math.random() * 3)],
                    radius: 5,
                    energy: Math.random() * 50 + 20
                });
            }

            // Create quantum barriers
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                GameState.barriers.push({
                    x: Math.cos(angle) * 300,
                    y: Math.sin(angle) * 300,
                    z: 0,
                    width: 100,
                    height: 100,
                    depth: 20,
                    color: '#ff00aa'
                });
            }

            // Create magnetic fields
            for (let i = 0; i < 8; i++) {
                GameState.magneticFields.push({
                    x: (Math.random() - 0.5) * 800,
                    y: (Math.random() - 0.5) * 800,
                    z: (Math.random() - 0.5) * 400,
                    radius: 80,
                    strength: Math.random() * 0.3 + 0.1,
                    direction: Math.random() > 0.5 ? 1 : -1
                });
            }
        }

        // ==================== PARTICLE SELECTION ====================
        function selectParticle(type) {
            GameState.particleType = type;
            const particleData = ParticleTypes[type];

            GameState.player.mass = particleData.mass;
            GameState.player.charge = particleData.charge;
            GameState.player.color = particleData.color;

            document.querySelectorAll('.particle-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`[data-particle="${type}"]`).classList.add('active');

            document.getElementById('particleType').textContent = particleData.name;
        }

        // ==================== GAME LOOP ====================
        function startGame() {
            document.getElementById('menu').classList.add('hidden');
            document.getElementById('hud').classList.remove('hidden');
            document.getElementById('controls').classList.remove('hidden');
            document.getElementById('infoPanel').classList.remove('hidden');
            document.getElementById('elementDisplay').classList.remove('hidden');
            document.getElementById('toolbar').classList.remove('hidden');

            GameState.running = true;
            GameState.paused = false;

            resetPlayerPosition();
            gameLoop();
        }

        function gameLoop() {
            if (!GameState.running) return;

            update();
            render();

            requestAnimationFrame(gameLoop);
        }

        // ==================== UPDATE ====================
        function update() {
            if (GameState.paused) return;

            handleInput();
            updatePlayer();
            updateParticles();
            updateQuantumEffects();
            checkCollisions();
            updateCamera();
            updateUI();
        }

        function handleInput() {
            const accel = 0.5 / GameState.player.mass;

            if (GameState.keys['w'] || GameState.keys['arrowup']) {
                GameState.player.vz -= accel;
            }
            if (GameState.keys['s'] || GameState.keys['arrowdown']) {
                GameState.player.vz += accel;
            }
            if (GameState.keys['a'] || GameState.keys['arrowleft']) {
                GameState.player.vx -= accel;
            }
            if (GameState.keys['d'] || GameState.keys['arrowright']) {
                GameState.player.vx += accel;
            }
            if (GameState.keys[' ']) {
                // Boost
                const speed = Math.sqrt(GameState.player.vx ** 2 + GameState.player.vy ** 2 + GameState.player.vz ** 2);
                if (speed > 0) {
                    const factor = 1 + GameState.BOOST_ACCELERATION;
                    GameState.player.vx *= factor;
                    GameState.player.vy *= factor;
                    GameState.player.vz *= factor;
                }
            }
        }

        function updatePlayer() {
            // Apply friction
            GameState.player.vx *= GameState.FRICTION;
            GameState.player.vy *= GameState.FRICTION;
            GameState.player.vz *= GameState.FRICTION;

            // Check accelerator tubes
            GameState.accelerators.forEach(acc => {
                const dist = pointToLineDistance(
                    GameState.player.x, GameState.player.y, GameState.player.z,
                    acc.x1, acc.y1, acc.z1,
                    acc.x2, acc.y2, acc.z2
                );

                if (dist < acc.radius) {
                    // Inside accelerator - boost speed
                    const dx = acc.x2 - acc.x1;
                    const dy = acc.y2 - acc.y1;
                    const dz = acc.z2 - acc.z1;
                    const len = Math.sqrt(dx * dx + dy * dy + dz * dz);

                    if (len > 0) {
                        const boostFactor = acc.power / GameState.player.mass;
                        GameState.player.vx += (dx / len) * boostFactor * 0.01;
                        GameState.player.vy += (dy / len) * boostFactor * 0.01;
                        GameState.player.vz += (dz / len) * boostFactor * 0.01;
                    }

                    GameState.player.energy += 0.5;
                }
            });

            // Apply magnetic fields
            GameState.magneticFields.forEach(field => {
                const dx = GameState.player.x - field.x;
                const dy = GameState.player.y - field.y;
                const dz = GameState.player.z - field.z;
                const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);

                if (dist < field.radius) {
                    // Magnetic force (perpendicular to velocity)
                    const force = field.strength * field.direction * GameState.player.charge;
                    GameState.player.vx += -GameState.player.vy * force;
                    GameState.player.vy += GameState.player.vx * force;
                }
            });

            // Limit speed to speed of light fraction
            const speed = Math.sqrt(GameState.player.vx ** 2 + GameState.player.vy ** 2 + GameState.player.vz ** 2);
            if (speed > GameState.MAX_SPEED) {
                const factor = GameState.MAX_SPEED / speed;
                GameState.player.vx *= factor;
                GameState.player.vy *= factor;
                GameState.player.vz *= factor;
            }

            // Update position
            GameState.player.x += GameState.player.vx;
            GameState.player.y += GameState.player.vy;
            GameState.player.z += GameState.player.vz;

            // Check barriers (unless tunneling)
            if (!GameState.quantum.tunneling) {
                GameState.barriers.forEach(barrier => {
                    const dx = Math.abs(GameState.player.x - barrier.x);
                    const dy = Math.abs(GameState.player.y - barrier.y);
                    const dz = Math.abs(GameState.player.z - barrier.z);

                    if (dx < barrier.width / 2 && dy < barrier.height / 2 && dz < barrier.depth / 2) {
                        // Bounce off barrier
                        if (dx > dy && dx > dz) {
                            GameState.player.vx *= -0.8;
                            GameState.player.x += GameState.player.x > barrier.x ? 5 : -5;
                        } else if (dy > dz) {
                            GameState.player.vy *= -0.8;
                            GameState.player.y += GameState.player.y > barrier.y ? 5 : -5;
                        } else {
                            GameState.player.vz *= -0.8;
                            GameState.player.z += GameState.player.z > barrier.z ? 5 : -5;
                        }
                    }
                });
            }

            // Update trail
            GameState.player.trail.push({
                x: GameState.player.x,
                y: GameState.player.y,
                z: GameState.player.z
            });

            if (GameState.player.trail.length > GameState.player.maxTrailLength) {
                GameState.player.trail.shift();
            }

            // Update stats
            GameState.player.speed = speed;
            GameState.stats.distance += speed;
        }

        function updateParticles() {
            GameState.particles.forEach(particle => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.z += particle.vz;

                // Wrap around world
                const maxDist = 1000;
                if (Math.abs(particle.x) > maxDist) particle.x *= -0.9;
                if (Math.abs(particle.y) > maxDist) particle.y *= -0.9;
                if (Math.abs(particle.z) > maxDist) particle.z *= -0.9;
            });
        }

        function updateQuantumEffects() {
            // Tunneling cooldown
            if (GameState.quantum.tunnelingCooldown > 0) {
                GameState.quantum.tunnelingCooldown--;
                if (GameState.quantum.tunnelingCooldown === 0) {
                    GameState.quantum.tunneling = false;
                }
            }

            // Superposition cooldown
            if (GameState.quantum.superpositionCooldown > 0) {
                GameState.quantum.superpositionCooldown--;
                if (GameState.quantum.superpositionCooldown === 0) {
                    GameState.quantum.superposition = false;
                    GameState.quantum.superpositionClones = [];
                }
            }

            // Update superposition clones
            if (GameState.quantum.superposition) {
                GameState.quantum.superpositionClones.forEach(clone => {
                    clone.x += clone.vx;
                    clone.y += clone.vy;
                    clone.z += clone.vz;
                });
            }
        }

        function checkCollisions() {
            for (let i = GameState.particles.length - 1; i >= 0; i--) {
                const particle = GameState.particles[i];
                const dx = GameState.player.x - particle.x;
                const dy = GameState.player.y - particle.y;
                const dz = GameState.player.z - particle.z;
                const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);

                if (dist < GameState.player.radius + particle.radius) {
                    // Collision detected!
                    handleCollision(particle, i);
                }
            }
        }

        function handleCollision(particle, index) {
            GameState.stats.collisions++;

            // Energy transfer
            const energyGain = particle.energy * 0.5;
            GameState.player.energy += energyGain;

            // Create element based on collision energy
            const totalEnergy = GameState.player.energy + particle.energy;

            if (totalEnergy > 200) {
                GameState.stats.elementsCreated.beryllium++;
                document.getElementById('beryllium').textContent = GameState.stats.elementsCreated.beryllium;
            } else if (totalEnergy > 150) {
                GameState.stats.elementsCreated.lithium++;
                document.getElementById('lithium').textContent = GameState.stats.elementsCreated.lithium;
            } else if (totalEnergy > 100) {
                GameState.stats.elementsCreated.helium++;
                document.getElementById('helium').textContent = GameState.stats.elementsCreated.helium;
            } else {
                GameState.stats.elementsCreated.hydrogen++;
                document.getElementById('hydrogen').textContent = GameState.stats.elementsCreated.hydrogen;
            }

            // Remove particle or respawn
            GameState.particles.splice(index, 1);

            // Spawn new particle elsewhere
            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * 500 + 300;

            GameState.particles.push({
                x: Math.cos(angle) * distance,
                y: Math.sin(angle) * distance,
                z: (Math.random() - 0.5) * 400,
                vx: (Math.random() - 0.5) * 0.5,
                vy: (Math.random() - 0.5) * 0.5,
                vz: (Math.random() - 0.5) * 0.5,
                type: ['proton', 'neutron', 'electron'][Math.floor(Math.random() * 3)],
                radius: 5,
                energy: Math.random() * 50 + 20
            });
        }

        function updateCamera() {
            // Follow player
            GameState.camera.x = GameState.player.x;
            GameState.camera.y = GameState.player.y;
            GameState.camera.z = GameState.player.z + 300;
        }

        // ==================== QUANTUM ABILITIES ====================
        function activateTunneling() {
            if (GameState.quantum.tunnelingCooldown === 0) {
                GameState.quantum.tunneling = true;
                GameState.quantum.tunnelingCooldown = GameState.TUNNEL_DURATION;
                updateInfoPanel('Quantum Tunneling Active! Pass through barriers.');
            }
        }

        function activateSuperposition() {
            if (GameState.quantum.superpositionCooldown === 0) {
                GameState.quantum.superposition = true;
                GameState.quantum.superpositionCooldown = GameState.SUPERPOSITION_DURATION;

                // Create clones at different positions
                GameState.quantum.superpositionClones = [
                    {
                        x: GameState.player.x + 100,
                        y: GameState.player.y,
                        z: GameState.player.z,
                        vx: GameState.player.vx,
                        vy: GameState.player.vy,
                        vz: GameState.player.vz
                    },
                    {
                        x: GameState.player.x - 100,
                        y: GameState.player.y,
                        z: GameState.player.z,
                        vx: GameState.player.vx,
                        vy: GameState.player.vy,
                        vz: GameState.player.vz
                    }
                ];

                updateInfoPanel('Superposition Active! You exist in multiple states.');
            }
        }

        function resetPlayerPosition() {
            GameState.player.x = 0;
            GameState.player.y = -400;
            GameState.player.z = 0;
            GameState.player.vx = 0;
            GameState.player.vy = 0;
            GameState.player.vz = 0;
            GameState.player.trail = [];
        }

        // ==================== RENDERING ====================
        function render() {
            const ctx = GameState.ctx;
            const width = GameState.width;
            const height = GameState.height;

            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);

            // Draw stars background
            drawStars(ctx, width, height);

            // Draw world objects
            drawAccelerators(ctx, width, height);
            drawBarriers(ctx, width, height);
            drawMagneticFields(ctx, width, height);
            drawParticles(ctx, width, height);

            // Draw player
            drawPlayer(ctx, width, height);

            // Draw superposition clones
            if (GameState.quantum.superposition) {
                drawSuperpositionClones(ctx, width, height);
            }

            // Draw effects
            drawEffects(ctx, width, height);
        }

        function project3D(x, y, z) {
            // Simple 3D to 2D projection
            const dx = x - GameState.camera.x;
            const dy = y - GameState.camera.y;
            const dz = z - GameState.camera.z;

            const scale = 400 / (400 + dz);

            return {
                x: GameState.width / 2 + dx * scale,
                y: GameState.height / 2 + dy * scale,
                scale: scale
            };
        }

        function drawStars(ctx, width, height) {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            for (let i = 0; i < 100; i++) {
                const x = (i * 137 + GameState.camera.x * 0.1) % width;
                const y = (i * 317 + GameState.camera.y * 0.1) % height;
                ctx.fillRect(x, y, 1, 1);
            }
        }

        function drawAccelerators(ctx, width, height) {
            GameState.accelerators.forEach(acc => {
                const p1 = project3D(acc.x1, acc.y1, acc.z1);
                const p2 = project3D(acc.x2, acc.y2, acc.z2);

                // Draw tube
                ctx.strokeStyle = '#00aaff';
                ctx.lineWidth = acc.radius * p1.scale * 0.5;
                ctx.globalAlpha = 0.3;
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();

                // Draw glow
                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.8;
                ctx.stroke();
                ctx.globalAlpha = 1;
            });
        }

        function drawBarriers(ctx, width, height) {
            GameState.barriers.forEach(barrier => {
                const p = project3D(barrier.x, barrier.y, barrier.z);

                const size = barrier.width * p.scale;

                // Draw barrier
                ctx.fillStyle = GameState.quantum.tunneling ? 'rgba(255, 0, 170, 0.2)' : 'rgba(255, 0, 170, 0.5)';
                ctx.fillRect(p.x - size / 2, p.y - size / 2, size, size);

                // Draw border
                ctx.strokeStyle = '#ff00aa';
                ctx.lineWidth = 2;
                ctx.strokeRect(p.x - size / 2, p.y - size / 2, size, size);
            });
        }

        function drawMagneticFields(ctx, width, height) {
            GameState.magneticFields.forEach(field => {
                const p = project3D(field.x, field.y, field.z);
                const radius = field.radius * p.scale;

                // Draw field
                ctx.strokeStyle = 'rgba(255, 255, 0, 0.3)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
                ctx.stroke();

                // Draw field lines
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const x1 = p.x + Math.cos(angle) * radius * 0.5;
                    const y1 = p.y + Math.sin(angle) * radius * 0.5;
                    const x2 = p.x + Math.cos(angle) * radius;
                    const y2 = p.y + Math.sin(angle) * radius;

                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                }
            });
        }

        function drawParticles(ctx, width, height) {
            GameState.particles.forEach(particle => {
                const p = project3D(particle.x, particle.y, particle.z);
                const radius = particle.radius * p.scale;

                const color = ParticleTypes[particle.type].color;

                // Draw glow
                const gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, radius * 3);
                gradient.addColorStop(0, color);
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                ctx.fillStyle = gradient;
                ctx.fillRect(p.x - radius * 3, p.y - radius * 3, radius * 6, radius * 6);

                // Draw particle
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function drawPlayer(ctx, width, height) {
            // Draw trail
            ctx.strokeStyle = GameState.player.color;
            ctx.lineWidth = 2;
            ctx.globalAlpha = 0.5;
            ctx.beginPath();

            for (let i = 0; i < GameState.player.trail.length; i++) {
                const point = GameState.player.trail[i];
                const p = project3D(point.x, point.y, point.z);

                if (i === 0) {
                    ctx.moveTo(p.x, p.y);
                } else {
                    ctx.lineTo(p.x, p.y);
                }
            }
            ctx.stroke();
            ctx.globalAlpha = 1;

            // Draw player
            const p = project3D(GameState.player.x, GameState.player.y, GameState.player.z);
            const radius = GameState.player.radius * 2;

            // Glow effect
            const gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, radius * 4);
            gradient.addColorStop(0, GameState.player.color);
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(p.x - radius * 4, p.y - radius * 4, radius * 8, radius * 8);

            // Particle core
            ctx.fillStyle = GameState.player.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
            ctx.fill();

            // Charge indicator
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 16px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(GameState.player.charge > 0 ? '+' : GameState.player.charge < 0 ? '-' : '0', p.x, p.y + 5);
        }

        function drawSuperpositionClones(ctx, width, height) {
            GameState.quantum.superpositionClones.forEach(clone => {
                const p = project3D(clone.x, clone.y, clone.z);
                const radius = GameState.player.radius * 2;

                ctx.globalAlpha = 0.4;

                // Glow
                const gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, radius * 4);
                gradient.addColorStop(0, GameState.player.color);
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                ctx.fillStyle = gradient;
                ctx.fillRect(p.x - radius * 4, p.y - radius * 4, radius * 8, radius * 8);

                // Clone
                ctx.fillStyle = GameState.player.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
                ctx.fill();

                ctx.globalAlpha = 1;
            });
        }

        function drawEffects(ctx, width, height) {
            // Speed lines when moving fast
            if (GameState.player.speed > 0.3) {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 1;

                for (let i = 0; i < 20; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = Math.random() * 300 + 100;
                    const x = width / 2 + Math.cos(angle) * distance;
                    const y = height / 2 + Math.sin(angle) * distance;
                    const length = Math.random() * 50 + 20;

                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + Math.cos(angle) * length, y + Math.sin(angle) * length);
                    ctx.stroke();
                }
            }
        }

        // ==================== UI UPDATES ====================
        function updateUI() {
            document.getElementById('speedDisplay').textContent = (GameState.player.speed * 100).toFixed(2);
            document.getElementById('energyDisplay').textContent = Math.floor(GameState.player.energy);
            document.getElementById('collisionCount').textContent = GameState.stats.collisions;
            document.getElementById('distanceDisplay').textContent = Math.floor(GameState.stats.distance);

            // Quantum state
            let state = 'Normal';
            if (GameState.quantum.tunneling) state = 'Tunneling';
            else if (GameState.quantum.superposition) state = 'Superposition';
            document.getElementById('quantumState').textContent = state;
        }

        function updateInfoPanel(text) {
            document.getElementById('infoText').textContent = text;
        }

        // ==================== UTILITY FUNCTIONS ====================
        function pointToLineDistance(px, py, pz, x1, y1, z1, x2, y2, z2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            const dz = z2 - z1;
            const length = Math.sqrt(dx * dx + dy * dy + dz * dz);

            if (length === 0) {
                return Math.sqrt((px - x1) ** 2 + (py - y1) ** 2 + (pz - z1) ** 2);
            }

            const t = Math.max(0, Math.min(1, ((px - x1) * dx + (py - y1) * dy + (pz - z1) * dz) / (length * length)));
            const projX = x1 + t * dx;
            const projY = y1 + t * dy;
            const projZ = z1 + t * dz;

            return Math.sqrt((px - projX) ** 2 + (py - projY) ** 2 + (pz - projZ) ** 2);
        }

        // ==================== GAME CONTROLS ====================
        function toggleMenu() {
            GameState.paused = !GameState.paused;
            document.getElementById('menu').classList.toggle('hidden');
        }

        function toggleInfo() {
            document.getElementById('infoPanel').classList.toggle('hidden');
        }

        function resetGame() {
            GameState.stats = {
                collisions: 0,
                distance: 0,
                elementsCreated: {
                    hydrogen: 0,
                    helium: 0,
                    lithium: 0,
                    beryllium: 0
                }
            };

            document.getElementById('hydrogen').textContent = '0';
            document.getElementById('helium').textContent = '0';
            document.getElementById('lithium').textContent = '0';
            document.getElementById('beryllium').textContent = '0';

            GameState.player.energy = 100;
            resetPlayerPosition();
            generateWorld();
        }

        // ==================== DATA PERSISTENCE ====================
        function saveGameData() {
            const data = {
                particleType: GameState.particleType,
                stats: GameState.stats,
                player: {
                    energy: GameState.player.energy,
                    x: GameState.player.x,
                    y: GameState.player.y,
                    z: GameState.player.z
                }
            };

            localStorage.setItem('particlePhysicsPlayground', JSON.stringify(data));
        }

        function loadGameData() {
            const saved = localStorage.getItem('particlePhysicsPlayground');
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    GameState.particleType = data.particleType || 'electron';
                    GameState.stats = data.stats || GameState.stats;

                    if (data.player) {
                        GameState.player.energy = data.player.energy;
                    }

                    selectParticle(GameState.particleType);
                } catch (e) {
                    console.error('Failed to load game data:', e);
                }
            }
        }

        function exportData() {
            const data = {
                particleType: GameState.particleType,
                stats: GameState.stats,
                player: {
                    energy: GameState.player.energy
                },
                exportDate: new Date().toISOString()
            };

            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'particle-physics-playground-data.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        function importData() {
            document.getElementById('fileInput').click();
        }

        function handleFileImport(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const data = JSON.parse(event.target.result);

                    if (data.particleType) {
                        GameState.particleType = data.particleType;
                        selectParticle(data.particleType);
                    }

                    if (data.stats) {
                        GameState.stats = data.stats;
                        document.getElementById('hydrogen').textContent = data.stats.elementsCreated.hydrogen || 0;
                        document.getElementById('helium').textContent = data.stats.elementsCreated.helium || 0;
                        document.getElementById('lithium').textContent = data.stats.elementsCreated.lithium || 0;
                        document.getElementById('beryllium').textContent = data.stats.elementsCreated.beryllium || 0;
                    }

                    if (data.player) {
                        GameState.player.energy = data.player.energy;
                    }

                    alert('Data imported successfully!');
                } catch (error) {
                    alert('Failed to import data: ' + error.message);
                }
            };
            reader.readAsText(file);
        }

        // Auto-save periodically
        setInterval(() => {
            if (GameState.running) {
                saveGameData();
            }
        }, 30000); // Save every 30 seconds

        // ==================== INITIALIZE ====================
        window.addEventListener('load', init);
    </script>
</body>
</html>