<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Slow Light Aquarium - Quantum World</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000a14;
            color: #00ffff;
            overflow: hidden;
            height: 100vh;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        #ui {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            pointer-events: none;
            z-index: 100;
        }

        #hud {
            display: flex;
            justify-content: space-between;
            padding: 20px;
            background: linear-gradient(180deg, rgba(0, 10, 20, 0.9) 0%, transparent 100%);
        }

        .panel {
            background: rgba(0, 20, 40, 0.85);
            border: 2px solid rgba(0, 200, 255, 0.5);
            border-radius: 12px;
            padding: 15px;
            min-width: 220px;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 30px rgba(0, 150, 255, 0.2);
        }

        .panel h3 {
            color: #00d4ff;
            margin-bottom: 10px;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 6px 0;
            font-size: 13px;
        }

        .stat-label {
            color: #80d4ff;
        }

        .stat-value {
            color: #ffffff;
            font-weight: bold;
            font-family: monospace;
        }

        .stat-value.red { color: #ff6b6b; }
        .stat-value.blue { color: #6b9fff; }
        .stat-value.green { color: #6bff9f; }
        .stat-value.yellow { color: #ffff6b; }

        #velocity-bar {
            height: 8px;
            background: rgba(0, 100, 150, 0.3);
            border-radius: 4px;
            margin-top: 8px;
            overflow: hidden;
        }

        #velocity-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff88, #ffff00, #ff4444);
            border-radius: 4px;
            transition: width 0.1s;
            width: 0%;
        }

        #lorentz-display {
            margin-top: 10px;
            padding: 10px;
            background: rgba(255, 100, 100, 0.1);
            border: 1px solid rgba(255, 100, 100, 0.3);
            border-radius: 8px;
            font-family: monospace;
            font-size: 12px;
        }

        #doppler-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 8px;
        }

        #doppler-spectrum {
            flex: 1;
            height: 20px;
            background: linear-gradient(90deg, #ff0000, #ffff00, #00ff00, #00ffff, #0000ff, #ff00ff);
            border-radius: 4px;
            position: relative;
        }

        #doppler-marker {
            position: absolute;
            top: -2px;
            width: 4px;
            height: 24px;
            background: white;
            border-radius: 2px;
            left: 50%;
            transform: translateX(-50%);
            transition: left 0.1s;
            box-shadow: 0 0 10px white;
        }

        #controls-panel {
            position: fixed;
            bottom: 20px;
            left: 20px;
            pointer-events: none;
        }

        .control-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
            font-size: 12px;
        }

        .control-key {
            display: inline-block;
            background: rgba(0, 200, 255, 0.2);
            border: 1px solid rgba(0, 200, 255, 0.4);
            padding: 3px 8px;
            border-radius: 4px;
            margin-right: 10px;
            font-weight: bold;
            min-width: 50px;
            text-align: center;
        }

        #menu-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 5, 15, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            pointer-events: all;
        }

        #menu-overlay.hidden {
            display: none;
        }

        .menu-content {
            background: linear-gradient(135deg, #001428 0%, #002040 100%);
            border: 3px solid #00d4ff;
            border-radius: 20px;
            padding: 40px;
            max-width: 500px;
            width: 90%;
            text-align: center;
            box-shadow: 0 0 60px rgba(0, 150, 255, 0.4);
        }

        .menu-content h1 {
            font-size: 28px;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #00ffff, #ff00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .menu-content p {
            color: #80d4ff;
            margin-bottom: 30px;
            line-height: 1.6;
        }

        .menu-button {
            display: block;
            width: 100%;
            padding: 15px;
            margin: 10px 0;
            background: linear-gradient(135deg, #003050, #005080);
            border: 2px solid #00d4ff;
            border-radius: 10px;
            color: #00ffff;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
            pointer-events: all;
        }

        .menu-button:hover {
            background: linear-gradient(135deg, #004060, #006090);
            box-shadow: 0 0 25px rgba(0, 200, 255, 0.5);
            transform: translateY(-2px);
        }

        #notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 20, 40, 0.95);
            border: 2px solid #00ff88;
            border-radius: 15px;
            padding: 25px 40px;
            text-align: center;
            pointer-events: none;
            box-shadow: 0 0 40px rgba(0, 255, 136, 0.4);
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 500;
        }

        #notification.visible {
            opacity: 1;
        }

        .notification-title {
            font-size: 18px;
            color: #00ff88;
            margin-bottom: 8px;
        }

        .notification-text {
            color: #80d4ff;
            font-size: 14px;
        }

        #light-pulse-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 50;
            background: radial-gradient(ellipse at center, transparent 0%, transparent 100%);
            mix-blend-mode: screen;
        }

        #aberration-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 51;
        }

        #mobile-controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: none;
            pointer-events: all;
            z-index: 200;
        }

        .joystick {
            width: 120px;
            height: 120px;
            background: rgba(0, 30, 60, 0.8);
            border: 2px solid #00d4ff;
            border-radius: 50%;
            position: relative;
        }

        .joystick-handle {
            width: 50px;
            height: 50px;
            background: radial-gradient(circle, #00ffff, #0080ff);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 20px rgba(0, 200, 255, 0.6);
        }

        @media (max-width: 768px) {
            #mobile-controls {
                display: block;
            }

            .panel {
                min-width: 160px;
                padding: 10px;
            }

            #controls-panel {
                display: none;
            }

            .menu-content {
                padding: 25px;
            }
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0, 20, 40, 0.5);
        }

        ::-webkit-scrollbar-thumb {
            background: #00d4ff;
            border-radius: 4px;
        }

        /* Light trail effect for moving objects */
        .light-trail {
            position: absolute;
            pointer-events: none;
            border-radius: 50%;
            animation: trailFade 2s ease-out forwards;
        }

        @keyframes trailFade {
            from { opacity: 0.8; transform: scale(1); }
            to { opacity: 0; transform: scale(0.5); }
        }

        /* Import/Export Modal */
        #modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 5, 15, 0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            pointer-events: all;
        }

        #modal-overlay.visible {
            display: flex;
        }

        .modal-content {
            background: linear-gradient(135deg, #001428 0%, #002040 100%);
            border: 3px solid #00d4ff;
            border-radius: 15px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-content h2 {
            color: #00d4ff;
            margin-bottom: 15px;
        }

        .modal-content textarea {
            width: 100%;
            min-height: 200px;
            background: rgba(0, 20, 40, 0.8);
            border: 2px solid rgba(0, 200, 255, 0.3);
            border-radius: 8px;
            color: #e0f0ff;
            padding: 12px;
            font-family: monospace;
            font-size: 12px;
            resize: vertical;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .modal-buttons button {
            flex: 1;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <div id="light-pulse-overlay"></div>
    <div id="aberration-overlay"></div>

    <div id="ui">
        <div id="hud">
            <div class="panel">
                <h3>Relativistic State</h3>
                <div class="stat-row">
                    <span class="stat-label">Velocity:</span>
                    <span class="stat-value" id="velocity">0.00c</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Speed of Light:</span>
                    <span class="stat-value" id="light-speed">3.0 m/s</span>
                </div>
                <div id="velocity-bar">
                    <div id="velocity-fill"></div>
                </div>
                <div id="lorentz-display">
                    <div class="stat-row">
                        <span class="stat-label">Lorentz Factor (γ):</span>
                        <span class="stat-value" id="lorentz-factor">1.000</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Time Dilation:</span>
                        <span class="stat-value yellow" id="time-dilation">1.00x</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Length Contraction:</span>
                        <span class="stat-value green" id="length-contraction">100%</span>
                    </div>
                </div>
            </div>

            <div class="panel">
                <h3>Doppler Shift</h3>
                <div class="stat-row">
                    <span class="stat-label">Approaching light:</span>
                    <span class="stat-value blue" id="approach-shift">Blueshift 0%</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Receding light:</span>
                    <span class="stat-value red" id="recede-shift">Redshift 0%</span>
                </div>
                <div id="doppler-indicator">
                    <span style="color: #ff6b6b;">RED</span>
                    <div id="doppler-spectrum">
                        <div id="doppler-marker"></div>
                    </div>
                    <span style="color: #6b9fff;">BLUE</span>
                </div>
                <div class="stat-row" style="margin-top: 10px;">
                    <span class="stat-label">Visual Aberration:</span>
                    <span class="stat-value" id="aberration">0.0°</span>
                </div>
            </div>

            <div class="panel">
                <h3>Environment</h3>
                <div class="stat-row">
                    <span class="stat-label">Depth:</span>
                    <span class="stat-value" id="depth">0m</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Light Sources:</span>
                    <span class="stat-value" id="light-count">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Photons Tracked:</span>
                    <span class="stat-value" id="photon-count">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Online Players:</span>
                    <span class="stat-value" id="player-count">1</span>
                </div>
            </div>
        </div>
    </div>

    <div id="controls-panel" class="panel">
        <h3>Controls</h3>
        <div class="control-item"><span class="control-key">WASD</span> Move (approach light speed!)</div>
        <div class="control-item"><span class="control-key">SPACE</span> Ascend</div>
        <div class="control-item"><span class="control-key">SHIFT</span> Descend</div>
        <div class="control-item"><span class="control-key">MOUSE</span> Look Around</div>
        <div class="control-item"><span class="control-key">E</span> Emit Light Pulse</div>
        <div class="control-item"><span class="control-key">ESC</span> Menu</div>
    </div>

    <div id="menu-overlay">
        <div class="menu-content">
            <h1>Slow Light Aquarium</h1>
            <p>Experience Einstein's relativity in an underwater world where light travels at walking speed.
            See Doppler shifting, time dilation, and visual distortion as you approach the speed of light.</p>
            <button class="menu-button" id="btn-start">Begin Exploration</button>
            <button class="menu-button" id="btn-export">Export World State</button>
            <button class="menu-button" id="btn-import">Import World State</button>
            <button class="menu-button" id="btn-reset">Reset World</button>
        </div>
    </div>

    <div id="notification">
        <div class="notification-title"></div>
        <div class="notification-text"></div>
    </div>

    <div id="modal-overlay">
        <div class="modal-content">
            <h2 id="modal-title">Modal</h2>
            <div id="modal-body"></div>
            <div class="modal-buttons">
                <button class="menu-button" id="modal-close">Close</button>
                <button class="menu-button" id="modal-action" style="display: none;">Action</button>
            </div>
        </div>
    </div>

    <div id="mobile-controls">
        <div class="joystick" id="joystick">
            <div class="joystick-handle" id="joystick-handle"></div>
        </div>
    </div>

    <script>
        // ===== VECTOR3 CLASS =====
        class Vec3 {
            constructor(x = 0, y = 0, z = 0) {
                this.x = x;
                this.y = y;
                this.z = z;
            }

            set(x, y, z) {
                this.x = x;
                this.y = y;
                this.z = z;
                return this;
            }

            add(v) {
                return new Vec3(this.x + v.x, this.y + v.y, this.z + v.z);
            }

            sub(v) {
                return new Vec3(this.x - v.x, this.y - v.y, this.z - v.z);
            }

            mul(s) {
                return new Vec3(this.x * s, this.y * s, this.z * s);
            }

            div(s) {
                return s !== 0 ? new Vec3(this.x / s, this.y / s, this.z / s) : new Vec3();
            }

            dot(v) {
                return this.x * v.x + this.y * v.y + this.z * v.z;
            }

            cross(v) {
                return new Vec3(
                    this.y * v.z - this.z * v.y,
                    this.z * v.x - this.x * v.z,
                    this.x * v.y - this.y * v.x
                );
            }

            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
            }

            normalize() {
                const len = this.length();
                return len > 0 ? this.mul(1 / len) : new Vec3();
            }

            clone() {
                return new Vec3(this.x, this.y, this.z);
            }

            lerp(v, t) {
                return new Vec3(
                    this.x + (v.x - this.x) * t,
                    this.y + (v.y - this.y) * t,
                    this.z + (v.z - this.z) * t
                );
            }

            distanceTo(v) {
                return this.sub(v).length();
            }
        }

        // ===== MATRIX4 CLASS =====
        class Matrix4 {
            constructor() {
                this.elements = new Float32Array(16);
                this.identity();
            }

            identity() {
                const e = this.elements;
                e[0] = 1; e[4] = 0; e[8] = 0; e[12] = 0;
                e[1] = 0; e[5] = 1; e[9] = 0; e[13] = 0;
                e[2] = 0; e[6] = 0; e[10] = 1; e[14] = 0;
                e[3] = 0; e[7] = 0; e[11] = 0; e[15] = 1;
                return this;
            }

            perspective(fov, aspect, near, far) {
                const f = 1.0 / Math.tan(fov / 2);
                const nf = 1 / (near - far);
                const e = this.elements;

                e[0] = f / aspect; e[4] = 0; e[8] = 0; e[12] = 0;
                e[1] = 0; e[5] = f; e[9] = 0; e[13] = 0;
                e[2] = 0; e[6] = 0; e[10] = (far + near) * nf; e[14] = 2 * far * near * nf;
                e[3] = 0; e[7] = 0; e[11] = -1; e[15] = 0;

                return this;
            }

            lookAt(eye, target, up) {
                const z = eye.sub(target).normalize();
                const x = up.cross(z).normalize();
                const y = z.cross(x);
                const e = this.elements;

                e[0] = x.x; e[4] = x.y; e[8] = x.z; e[12] = -x.dot(eye);
                e[1] = y.x; e[5] = y.y; e[9] = y.z; e[13] = -y.dot(eye);
                e[2] = z.x; e[6] = z.y; e[10] = z.z; e[14] = -z.dot(eye);
                e[3] = 0; e[7] = 0; e[11] = 0; e[15] = 1;

                return this;
            }

            multiply(m) {
                const ae = this.elements;
                const be = m.elements;
                const te = new Float32Array(16);

                for (let row = 0; row < 4; row++) {
                    for (let col = 0; col < 4; col++) {
                        let sum = 0;
                        for (let k = 0; k < 4; k++) {
                            sum += ae[row + k * 4] * be[k + col * 4];
                        }
                        te[row + col * 4] = sum;
                    }
                }

                const result = new Matrix4();
                result.elements = te;
                return result;
            }
        }

        // ===== WEBGL RENDERER =====
        class Renderer {
            constructor(canvas) {
                this.canvas = canvas;
                this.gl = canvas.getContext('webgl2') || canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

                if (!this.gl) {
                    alert('WebGL not supported. Please use a modern browser.');
                    return;
                }

                this.initShaders();
                this.gl.enable(this.gl.DEPTH_TEST);
                this.gl.enable(this.gl.BLEND);
                this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);

                this.resize();
                window.addEventListener('resize', () => this.resize());
            }

            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
            }

            initShaders() {
                // Vertex shader with relativistic distortion
                const vsSource = `
                    attribute vec3 aPosition;
                    attribute vec4 aColor;
                    attribute float aSize;
                    attribute float aEmissionTime;

                    uniform mat4 uProjection;
                    uniform mat4 uView;
                    uniform vec3 uPlayerPos;
                    uniform vec3 uPlayerVelocity;
                    uniform float uTime;
                    uniform float uLightSpeed;
                    uniform float uLorentzFactor;

                    varying vec4 vColor;
                    varying float vDopplerShift;

                    void main() {
                        // Calculate apparent position (light travel time delay)
                        vec3 toObject = aPosition - uPlayerPos;
                        float distance = length(toObject);
                        float lightTravelTime = distance / uLightSpeed;

                        // Relativistic aberration - objects appear shifted towards motion direction
                        vec3 velocityDir = normalize(uPlayerVelocity + vec3(0.0001)); // avoid zero
                        float beta = length(uPlayerVelocity) / uLightSpeed;
                        float cosTheta = dot(normalize(toObject), velocityDir);

                        // Aberration angle shift
                        float aberrationFactor = (1.0 - beta * beta) / (1.0 - beta * cosTheta);

                        // Apply Lorentz contraction in direction of motion
                        vec3 objectDir = normalize(toObject);
                        float parallelComponent = dot(toObject, velocityDir);
                        vec3 perpendicular = toObject - velocityDir * parallelComponent;
                        vec3 contracted = perpendicular + velocityDir * (parallelComponent / uLorentzFactor);

                        vec3 apparentPos = uPlayerPos + contracted;

                        gl_Position = uProjection * uView * vec4(apparentPos, 1.0);
                        gl_PointSize = (aSize * aberrationFactor) / (gl_Position.w * 0.1);
                        gl_PointSize = clamp(gl_PointSize, 1.0, 100.0);

                        // Doppler shift calculation
                        // Positive = blueshift (approaching), Negative = redshift (receding)
                        vDopplerShift = -beta * cosTheta * uLorentzFactor;

                        vColor = aColor;
                    }
                `;

                // Fragment shader with Doppler color shifting
                const fsSource = `
                    precision mediump float;

                    varying vec4 vColor;
                    varying float vDopplerShift;

                    vec3 shiftColor(vec3 color, float shift) {
                        // Simulate wavelength shift
                        // Positive shift = blueshift (shorter wavelength)
                        // Negative shift = redshift (longer wavelength)

                        float r = color.r;
                        float g = color.g;
                        float b = color.b;

                        // Shift spectrum
                        float shiftAmount = clamp(shift * 2.0, -1.0, 1.0);

                        if (shiftAmount > 0.0) {
                            // Blueshift - move towards blue/violet
                            r = mix(r, r * 0.5, shiftAmount);
                            g = mix(g, g * 0.7, shiftAmount);
                            b = mix(b, min(1.0, b + 0.5), shiftAmount);
                        } else {
                            // Redshift - move towards red/infrared
                            float absShift = abs(shiftAmount);
                            r = mix(r, min(1.0, r + 0.5), absShift);
                            g = mix(g, g * 0.7, absShift);
                            b = mix(b, b * 0.3, absShift);
                        }

                        // Relativistic intensity change (beaming)
                        float intensity = 1.0 + shiftAmount * 0.5;

                        return vec3(r, g, b) * intensity;
                    }

                    void main() {
                        float dist = length(gl_PointCoord - vec2(0.5));
                        if (dist > 0.5) discard;

                        float alpha = (1.0 - dist * 2.0) * vColor.a;
                        vec3 shiftedColor = shiftColor(vColor.rgb, vDopplerShift);

                        // Add glow effect
                        float glow = exp(-dist * 4.0) * 0.5;
                        shiftedColor += vec3(glow);

                        gl_FragColor = vec4(shiftedColor, alpha);
                    }
                `;

                this.program = this.createProgram(vsSource, fsSource);
                this.gl.useProgram(this.program);

                this.attributes = {
                    position: this.gl.getAttribLocation(this.program, 'aPosition'),
                    color: this.gl.getAttribLocation(this.program, 'aColor'),
                    size: this.gl.getAttribLocation(this.program, 'aSize'),
                    emissionTime: this.gl.getAttribLocation(this.program, 'aEmissionTime')
                };

                this.uniforms = {
                    projection: this.gl.getUniformLocation(this.program, 'uProjection'),
                    view: this.gl.getUniformLocation(this.program, 'uView'),
                    playerPos: this.gl.getUniformLocation(this.program, 'uPlayerPos'),
                    playerVelocity: this.gl.getUniformLocation(this.program, 'uPlayerVelocity'),
                    time: this.gl.getUniformLocation(this.program, 'uTime'),
                    lightSpeed: this.gl.getUniformLocation(this.program, 'uLightSpeed'),
                    lorentzFactor: this.gl.getUniformLocation(this.program, 'uLorentzFactor')
                };

                // Create buffers
                this.positionBuffer = this.gl.createBuffer();
                this.colorBuffer = this.gl.createBuffer();
                this.sizeBuffer = this.gl.createBuffer();
            }

            createProgram(vsSource, fsSource) {
                const vertexShader = this.compileShader(vsSource, this.gl.VERTEX_SHADER);
                const fragmentShader = this.compileShader(fsSource, this.gl.FRAGMENT_SHADER);

                const program = this.gl.createProgram();
                this.gl.attachShader(program, vertexShader);
                this.gl.attachShader(program, fragmentShader);
                this.gl.linkProgram(program);

                if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {
                    console.error('Program link error:', this.gl.getProgramInfoLog(program));
                }

                return program;
            }

            compileShader(source, type) {
                const shader = this.gl.createShader(type);
                this.gl.shaderSource(shader, source);
                this.gl.compileShader(shader);

                if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
                    console.error('Shader compile error:', this.gl.getShaderInfoLog(shader));
                    this.gl.deleteShader(shader);
                    return null;
                }

                return shader;
            }

            clear() {
                this.gl.clearColor(0.0, 0.02, 0.05, 1.0);
                this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
            }

            render(objects, camera, player, lightSpeed, lorentzFactor, time) {
                this.clear();

                const positions = [];
                const colors = [];
                const sizes = [];

                objects.forEach(obj => {
                    positions.push(obj.position.x, obj.position.y, obj.position.z);
                    colors.push(obj.color.r, obj.color.g, obj.color.b, obj.color.a || 1.0);
                    sizes.push(obj.size || 10);
                });

                if (positions.length === 0) return;

                // Update buffers
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(positions), this.gl.DYNAMIC_DRAW);
                this.gl.enableVertexAttribArray(this.attributes.position);
                this.gl.vertexAttribPointer(this.attributes.position, 3, this.gl.FLOAT, false, 0, 0);

                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorBuffer);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(colors), this.gl.DYNAMIC_DRAW);
                this.gl.enableVertexAttribArray(this.attributes.color);
                this.gl.vertexAttribPointer(this.attributes.color, 4, this.gl.FLOAT, false, 0, 0);

                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.sizeBuffer);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(sizes), this.gl.DYNAMIC_DRAW);
                this.gl.enableVertexAttribArray(this.attributes.size);
                this.gl.vertexAttribPointer(this.attributes.size, 1, this.gl.FLOAT, false, 0, 0);

                // Set uniforms
                this.gl.uniformMatrix4fv(this.uniforms.projection, false, camera.projectionMatrix.elements);
                this.gl.uniformMatrix4fv(this.uniforms.view, false, camera.viewMatrix.elements);
                this.gl.uniform3f(this.uniforms.playerPos, player.position.x, player.position.y, player.position.z);
                this.gl.uniform3f(this.uniforms.playerVelocity, player.velocity.x, player.velocity.y, player.velocity.z);
                this.gl.uniform1f(this.uniforms.time, time);
                this.gl.uniform1f(this.uniforms.lightSpeed, lightSpeed);
                this.gl.uniform1f(this.uniforms.lorentzFactor, lorentzFactor);

                // Draw
                this.gl.drawArrays(this.gl.POINTS, 0, positions.length / 3);
            }
        }

        // ===== CAMERA CLASS =====
        class Camera {
            constructor() {
                this.position = new Vec3(0, 0, 0);
                this.target = new Vec3(0, 0, -1);
                this.up = new Vec3(0, 1, 0);
                this.fov = Math.PI / 3;
                this.aspect = window.innerWidth / window.innerHeight;
                this.near = 0.1;
                this.far = 1000;

                this.projectionMatrix = new Matrix4();
                this.viewMatrix = new Matrix4();

                this.yaw = 0;
                this.pitch = 0;

                this.updateProjection();
            }

            updateProjection() {
                this.aspect = window.innerWidth / window.innerHeight;
                this.projectionMatrix.perspective(this.fov, this.aspect, this.near, this.far);
            }

            updateView() {
                // Calculate direction from yaw and pitch
                const direction = new Vec3(
                    Math.sin(this.yaw) * Math.cos(this.pitch),
                    Math.sin(this.pitch),
                    -Math.cos(this.yaw) * Math.cos(this.pitch)
                );

                this.target = this.position.add(direction);
                this.viewMatrix.lookAt(this.position, this.target, this.up);
            }

            getForward() {
                return new Vec3(
                    Math.sin(this.yaw) * Math.cos(this.pitch),
                    Math.sin(this.pitch),
                    -Math.cos(this.yaw) * Math.cos(this.pitch)
                ).normalize();
            }

            getRight() {
                return new Vec3(
                    Math.cos(this.yaw),
                    0,
                    Math.sin(this.yaw)
                ).normalize();
            }
        }

        // ===== PHOTON CLASS =====
        class Photon {
            constructor(position, direction, color, emissionTime, sourceId) {
                this.position = position.clone();
                this.direction = direction.normalize();
                this.color = { ...color };
                this.emissionTime = emissionTime;
                this.sourceId = sourceId;
                this.age = 0;
                this.maxAge = 30; // seconds
                this.size = 8;
                this.trail = [];
                this.trailMaxLength = 20;
            }

            update(dt, lightSpeed) {
                this.age += dt;

                // Store trail position
                if (this.trail.length < this.trailMaxLength) {
                    this.trail.push(this.position.clone());
                } else {
                    this.trail.shift();
                    this.trail.push(this.position.clone());
                }

                // Move at light speed
                this.position = this.position.add(this.direction.mul(lightSpeed * dt));

                return this.age < this.maxAge;
            }
        }

        // ===== LIGHT SOURCE CLASS =====
        class LightSource {
            constructor(position, color, pulseRate, id) {
                this.position = position.clone();
                this.baseColor = { ...color };
                this.color = { ...color };
                this.pulseRate = pulseRate; // pulses per second
                this.pulsePhase = Math.random() * Math.PI * 2;
                this.id = id;
                this.size = 20;
                this.lastEmitTime = 0;
                this.emitInterval = 0.5; // seconds between photon emissions
            }

            update(dt, time) {
                // Pulsing glow
                const pulse = 0.5 + 0.5 * Math.sin(time * this.pulseRate * Math.PI * 2 + this.pulsePhase);
                this.color.a = 0.5 + pulse * 0.5;
            }

            shouldEmit(time) {
                if (time - this.lastEmitTime > this.emitInterval) {
                    this.lastEmitTime = time;
                    return true;
                }
                return false;
            }

            emitPhoton(time) {
                // Emit in random direction
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const direction = new Vec3(
                    Math.sin(phi) * Math.cos(theta),
                    Math.sin(phi) * Math.sin(theta),
                    Math.cos(phi)
                );

                return new Photon(
                    this.position.clone(),
                    direction,
                    { ...this.baseColor, a: 0.9 },
                    time,
                    this.id
                );
            }
        }

        // ===== CREATURE CLASS =====
        class Creature {
            constructor(position, color, size, speed) {
                this.position = position.clone();
                this.velocity = new Vec3(
                    (Math.random() - 0.5) * speed,
                    (Math.random() - 0.5) * speed * 0.5,
                    (Math.random() - 0.5) * speed
                );
                this.color = { ...color };
                this.size = size;
                this.baseSpeed = speed;
                this.wanderAngle = Math.random() * Math.PI * 2;
                this.glowPhase = Math.random() * Math.PI * 2;
            }

            update(dt, time, bounds) {
                // Wander behavior
                this.wanderAngle += (Math.random() - 0.5) * 2 * dt;

                const wanderForce = new Vec3(
                    Math.cos(this.wanderAngle) * 0.1,
                    Math.sin(time * 0.5 + this.glowPhase) * 0.05,
                    Math.sin(this.wanderAngle) * 0.1
                );

                this.velocity = this.velocity.add(wanderForce.mul(dt));

                // Limit speed
                const speed = this.velocity.length();
                if (speed > this.baseSpeed) {
                    this.velocity = this.velocity.mul(this.baseSpeed / speed);
                }

                // Update position
                this.position = this.position.add(this.velocity.mul(dt));

                // Bounce off bounds
                if (Math.abs(this.position.x) > bounds) {
                    this.velocity.x *= -1;
                    this.position.x = Math.sign(this.position.x) * bounds;
                }
                if (this.position.y > 0) {
                    this.velocity.y *= -1;
                    this.position.y = 0;
                }
                if (this.position.y < -bounds * 2) {
                    this.velocity.y *= -1;
                    this.position.y = -bounds * 2;
                }
                if (Math.abs(this.position.z) > bounds) {
                    this.velocity.z *= -1;
                    this.position.z = Math.sign(this.position.z) * bounds;
                }

                // Glow animation
                const glow = 0.6 + 0.4 * Math.sin(time * 2 + this.glowPhase);
                this.color.a = glow;
            }
        }

        // ===== MAIN GAME CLASS =====
        class SlowLightAquarium {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.renderer = new Renderer(this.canvas);
                this.camera = new Camera();

                // Physics constants
                this.LIGHT_SPEED = 3.0; // meters per second (walking speed!)
                this.MAX_PLAYER_SPEED = 2.9; // Can approach but never reach light speed

                // Player state
                this.player = {
                    position: new Vec3(0, -10, 0),
                    velocity: new Vec3(0, 0, 0),
                    acceleration: 2.0,
                    friction: 0.95
                };

                // World objects
                this.lightSources = [];
                this.photons = [];
                this.creatures = [];
                this.particles = []; // Ambient particles
                this.worldBounds = 100;

                // Relativistic state
                this.lorentzFactor = 1.0;
                this.timeDilation = 1.0;
                this.properTime = 0; // Player's experienced time
                this.worldTime = 0;

                // Input
                this.keys = {};
                this.mouse = { locked: false, deltaX: 0, deltaY: 0 };
                this.mouseSensitivity = 0.002;

                // Game state
                this.isRunning = false;
                this.lastTime = 0;

                // P2P networking (simplified)
                this.peerId = 'player_' + Math.random().toString(36).substr(2, 9);
                this.peers = new Map();

                this.init();
            }

            init() {
                this.loadState();
                this.generateWorld();
                this.setupControls();
                this.setupUI();

                console.log('Slow Light Aquarium initialized');
            }

            generateWorld() {
                // Create light sources (bioluminescent creatures and plants)
                const lightColors = [
                    { r: 0.0, g: 1.0, b: 1.0, a: 1.0 },   // Cyan
                    { r: 0.0, g: 1.0, b: 0.5, a: 1.0 },   // Teal
                    { r: 0.5, g: 0.0, b: 1.0, a: 1.0 },   // Purple
                    { r: 1.0, g: 0.5, b: 0.0, a: 1.0 },   // Orange
                    { r: 0.0, g: 0.5, b: 1.0, a: 1.0 },   // Blue
                    { r: 1.0, g: 0.0, b: 0.5, a: 1.0 },   // Pink
                ];

                // Fixed light sources (coral, plants)
                for (let i = 0; i < 30; i++) {
                    const pos = new Vec3(
                        (Math.random() - 0.5) * this.worldBounds * 2,
                        -Math.random() * this.worldBounds * 2,
                        (Math.random() - 0.5) * this.worldBounds * 2
                    );
                    const color = { ...lightColors[Math.floor(Math.random() * lightColors.length)] };
                    const pulseRate = 0.2 + Math.random() * 0.5;

                    this.lightSources.push(new LightSource(pos, color, pulseRate, `light_${i}`));
                }

                // Bioluminescent creatures
                for (let i = 0; i < 50; i++) {
                    const pos = new Vec3(
                        (Math.random() - 0.5) * this.worldBounds * 2,
                        -Math.random() * this.worldBounds * 2,
                        (Math.random() - 0.5) * this.worldBounds * 2
                    );
                    const color = { ...lightColors[Math.floor(Math.random() * lightColors.length)] };
                    const size = 5 + Math.random() * 15;
                    const speed = 0.5 + Math.random() * 1.5;

                    this.creatures.push(new Creature(pos, color, size, speed));
                }

                // Ambient particles (dust, plankton)
                for (let i = 0; i < 500; i++) {
                    this.particles.push({
                        position: new Vec3(
                            (Math.random() - 0.5) * this.worldBounds * 3,
                            -Math.random() * this.worldBounds * 3,
                            (Math.random() - 0.5) * this.worldBounds * 3
                        ),
                        color: { r: 0.3, g: 0.5, b: 0.7, a: 0.3 },
                        size: 2 + Math.random() * 3,
                        drift: new Vec3(
                            (Math.random() - 0.5) * 0.1,
                            (Math.random() - 0.5) * 0.05,
                            (Math.random() - 0.5) * 0.1
                        )
                    });
                }
            }

            setupControls() {
                // Keyboard
                window.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;

                    if (e.code === 'Escape') {
                        this.toggleMenu();
                    }
                    if (e.code === 'KeyE' && this.isRunning) {
                        this.emitLightPulse();
                    }
                });

                window.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                });

                // Mouse
                this.canvas.addEventListener('click', () => {
                    if (this.isRunning && !this.mouse.locked) {
                        this.canvas.requestPointerLock();
                    }
                });

                document.addEventListener('pointerlockchange', () => {
                    this.mouse.locked = document.pointerLockElement === this.canvas;
                });

                document.addEventListener('mousemove', (e) => {
                    if (this.mouse.locked) {
                        this.mouse.deltaX = e.movementX;
                        this.mouse.deltaY = e.movementY;
                    }
                });

                // Touch controls
                this.setupTouchControls();

                // Resize
                window.addEventListener('resize', () => {
                    this.renderer.resize();
                    this.camera.updateProjection();
                });
            }

            setupTouchControls() {
                const joystick = document.getElementById('joystick');
                const handle = document.getElementById('joystick-handle');

                if (!joystick || !handle) return;

                let active = false;
                let startX = 0, startY = 0;

                const handleStart = (e) => {
                    active = true;
                    const rect = joystick.getBoundingClientRect();
                    startX = rect.left + rect.width / 2;
                    startY = rect.top + rect.height / 2;
                };

                const handleMove = (e) => {
                    if (!active) return;

                    const touch = e.touches[0];
                    const dx = touch.clientX - startX;
                    const dy = touch.clientY - startY;

                    const maxDist = 35;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const clampedDist = Math.min(dist, maxDist);
                    const angle = Math.atan2(dy, dx);

                    handle.style.left = `${50 + Math.cos(angle) * clampedDist}%`;
                    handle.style.top = `${50 + Math.sin(angle) * clampedDist}%`;

                    // Simulate key presses
                    const threshold = 10;
                    this.keys.KeyW = dy < -threshold;
                    this.keys.KeyS = dy > threshold;
                    this.keys.KeyA = dx < -threshold;
                    this.keys.KeyD = dx > threshold;
                };

                const handleEnd = () => {
                    active = false;
                    handle.style.left = '50%';
                    handle.style.top = '50%';
                    this.keys.KeyW = false;
                    this.keys.KeyS = false;
                    this.keys.KeyA = false;
                    this.keys.KeyD = false;
                };

                joystick.addEventListener('touchstart', handleStart);
                joystick.addEventListener('touchmove', handleMove);
                joystick.addEventListener('touchend', handleEnd);
            }

            setupUI() {
                document.getElementById('btn-start').addEventListener('click', () => this.startGame());
                document.getElementById('btn-export').addEventListener('click', () => this.exportData());
                document.getElementById('btn-import').addEventListener('click', () => this.showImportModal());
                document.getElementById('btn-reset').addEventListener('click', () => this.resetWorld());

                document.getElementById('modal-close').addEventListener('click', () => this.hideModal());
            }

            startGame() {
                document.getElementById('menu-overlay').classList.add('hidden');
                this.isRunning = true;
                this.lastTime = performance.now();
                this.gameLoop();
            }

            toggleMenu() {
                const menu = document.getElementById('menu-overlay');
                if (menu.classList.contains('hidden')) {
                    menu.classList.remove('hidden');
                    this.isRunning = false;
                    document.exitPointerLock();
                } else {
                    menu.classList.add('hidden');
                    this.isRunning = true;
                    this.lastTime = performance.now();
                    this.gameLoop();
                }
            }

            gameLoop() {
                if (!this.isRunning) return;

                const now = performance.now();
                const dt = Math.min((now - this.lastTime) / 1000, 0.1); // Cap delta time
                this.lastTime = now;

                this.update(dt);
                this.render();

                requestAnimationFrame(() => this.gameLoop());
            }

            update(dt) {
                // Update world time
                this.worldTime += dt;

                // Calculate player speed and Lorentz factor
                const speed = this.player.velocity.length();
                const beta = speed / this.LIGHT_SPEED;

                // Lorentz factor: γ = 1 / √(1 - v²/c²)
                if (beta < 0.999) {
                    this.lorentzFactor = 1 / Math.sqrt(1 - beta * beta);
                } else {
                    this.lorentzFactor = 22.4; // Cap for numerical stability
                }

                // Time dilation: moving clocks tick slower
                this.timeDilation = 1 / this.lorentzFactor;
                this.properTime += dt * this.timeDilation;

                // Update player
                this.updatePlayer(dt);

                // Update camera
                this.updateCamera();

                // Update light sources
                this.lightSources.forEach(source => {
                    source.update(dt, this.worldTime);

                    // Emit photons
                    if (source.shouldEmit(this.worldTime)) {
                        const photon = source.emitPhoton(this.worldTime);
                        this.photons.push(photon);
                    }
                });

                // Update creatures
                this.creatures.forEach(creature => {
                    creature.update(dt, this.worldTime, this.worldBounds);
                });

                // Update photons
                this.photons = this.photons.filter(photon => {
                    return photon.update(dt, this.LIGHT_SPEED);
                });

                // Update particles (ambient drift)
                this.particles.forEach(p => {
                    p.position = p.position.add(p.drift.mul(dt));

                    // Wrap around
                    const bounds = this.worldBounds * 1.5;
                    if (Math.abs(p.position.x) > bounds) p.position.x *= -0.9;
                    if (p.position.y > 0) p.position.y = -bounds * 2;
                    if (p.position.y < -bounds * 2) p.position.y = 0;
                    if (Math.abs(p.position.z) > bounds) p.position.z *= -0.9;
                });

                // Limit photon count
                if (this.photons.length > 2000) {
                    this.photons = this.photons.slice(-2000);
                }

                // Update UI
                this.updateUI();
            }

            updatePlayer(dt) {
                // Get movement input
                const moveDir = new Vec3(0, 0, 0);
                const forward = this.camera.getForward();
                const right = this.camera.getRight();

                if (this.keys.KeyW) moveDir.z -= 1;
                if (this.keys.KeyS) moveDir.z += 1;
                if (this.keys.KeyA) moveDir.x -= 1;
                if (this.keys.KeyD) moveDir.x += 1;
                if (this.keys.Space) moveDir.y += 1;
                if (this.keys.ShiftLeft || this.keys.ShiftRight) moveDir.y -= 1;

                // Transform to world space
                if (moveDir.length() > 0) {
                    const worldMove = new Vec3(
                        forward.x * -moveDir.z + right.x * moveDir.x,
                        moveDir.y,
                        forward.z * -moveDir.z + right.z * moveDir.x
                    ).normalize();

                    // Relativistic mass increase makes acceleration harder near light speed
                    const effectiveAccel = this.player.acceleration / this.lorentzFactor;
                    this.player.velocity = this.player.velocity.add(worldMove.mul(effectiveAccel * dt));
                }

                // Apply friction
                this.player.velocity = this.player.velocity.mul(Math.pow(this.player.friction, dt * 60));

                // Clamp to max speed (can approach but never reach light speed)
                const speed = this.player.velocity.length();
                if (speed > this.MAX_PLAYER_SPEED) {
                    this.player.velocity = this.player.velocity.mul(this.MAX_PLAYER_SPEED / speed);
                }

                // Update position (with time dilation - you move through space faster in proper time)
                this.player.position = this.player.position.add(this.player.velocity.mul(dt));

                // Boundary constraints
                const bounds = this.worldBounds;
                this.player.position.x = Math.max(-bounds, Math.min(bounds, this.player.position.x));
                this.player.position.y = Math.min(0, Math.max(-bounds * 2, this.player.position.y));
                this.player.position.z = Math.max(-bounds, Math.min(bounds, this.player.position.z));
            }

            updateCamera() {
                // Mouse look
                if (this.mouse.locked) {
                    this.camera.yaw += this.mouse.deltaX * this.mouseSensitivity;
                    this.camera.pitch -= this.mouse.deltaY * this.mouseSensitivity;
                    this.camera.pitch = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, this.camera.pitch));

                    this.mouse.deltaX = 0;
                    this.mouse.deltaY = 0;
                }

                // FOV changes with speed (relativistic aberration effect)
                const beta = this.player.velocity.length() / this.LIGHT_SPEED;
                const fovMultiplier = 1 + beta * 0.5; // Tunnel vision at high speeds
                this.camera.fov = (Math.PI / 3) * fovMultiplier;
                this.camera.updateProjection();

                this.camera.position = this.player.position.clone();
                this.camera.updateView();
            }

            emitLightPulse() {
                // Player emits a spherical light pulse
                const numPhotons = 50;
                for (let i = 0; i < numPhotons; i++) {
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    const direction = new Vec3(
                        Math.sin(phi) * Math.cos(theta),
                        Math.sin(phi) * Math.sin(theta),
                        Math.cos(phi)
                    );

                    const photon = new Photon(
                        this.player.position.clone(),
                        direction,
                        { r: 1.0, g: 1.0, b: 1.0, a: 1.0 },
                        this.worldTime,
                        'player'
                    );
                    this.photons.push(photon);
                }

                this.showNotification('Light Pulse Emitted', 'Watch it propagate at 3 m/s!');
            }

            render() {
                // Collect all renderable objects
                const objects = [];

                // Light sources
                this.lightSources.forEach(source => {
                    objects.push({
                        position: source.position,
                        color: source.color,
                        size: source.size
                    });
                });

                // Creatures
                this.creatures.forEach(creature => {
                    objects.push({
                        position: creature.position,
                        color: creature.color,
                        size: creature.size
                    });
                });

                // Photons
                this.photons.forEach(photon => {
                    objects.push({
                        position: photon.position,
                        color: photon.color,
                        size: photon.size
                    });

                    // Render trails
                    photon.trail.forEach((pos, i) => {
                        const alpha = (i / photon.trail.length) * 0.5;
                        objects.push({
                            position: pos,
                            color: { ...photon.color, a: alpha },
                            size: photon.size * 0.5
                        });
                    });
                });

                // Particles
                this.particles.forEach(p => {
                    objects.push({
                        position: p.position,
                        color: p.color,
                        size: p.size
                    });
                });

                // Render
                this.renderer.render(
                    objects,
                    this.camera,
                    this.player,
                    this.LIGHT_SPEED,
                    this.lorentzFactor,
                    this.worldTime
                );

                // Update visual overlays
                this.updateVisualEffects();
            }

            updateVisualEffects() {
                const beta = this.player.velocity.length() / this.LIGHT_SPEED;

                // Aberration overlay (tunnel vision effect)
                const aberrationOverlay = document.getElementById('aberration-overlay');
                const aberrationStrength = beta * 0.8;
                aberrationOverlay.style.background = `radial-gradient(ellipse at center,
                    transparent 0%,
                    transparent ${(1 - aberrationStrength) * 60}%,
                    rgba(0,0,0,${aberrationStrength * 0.7}) 100%)`;

                // Calculate direction-based effects
                const velDir = this.player.velocity.normalize();
                const forwardDir = this.camera.getForward();

                // Doppler marker position
                const dopplerMarker = document.getElementById('doppler-marker');
                const forwardDot = velDir.dot(forwardDir);
                const markerPos = 50 - forwardDot * beta * 40;
                dopplerMarker.style.left = `${Math.max(5, Math.min(95, markerPos))}%`;
            }

            updateUI() {
                const speed = this.player.velocity.length();
                const beta = speed / this.LIGHT_SPEED;

                // Velocity display
                document.getElementById('velocity').textContent = `${beta.toFixed(3)}c`;
                document.getElementById('velocity-fill').style.width = `${beta * 100}%`;

                // Light speed
                document.getElementById('light-speed').textContent = `${this.LIGHT_SPEED.toFixed(1)} m/s`;

                // Lorentz factor
                document.getElementById('lorentz-factor').textContent = this.lorentzFactor.toFixed(3);

                // Time dilation
                document.getElementById('time-dilation').textContent = `${this.timeDilation.toFixed(2)}x`;

                // Length contraction (in direction of motion)
                const contraction = (1 / this.lorentzFactor) * 100;
                document.getElementById('length-contraction').textContent = `${contraction.toFixed(1)}%`;

                // Doppler shift
                const blueshift = Math.max(0, beta * 100);
                const redshift = Math.max(0, beta * 100);
                document.getElementById('approach-shift').textContent = `Blueshift ${blueshift.toFixed(0)}%`;
                document.getElementById('recede-shift').textContent = `Redshift ${redshift.toFixed(0)}%`;

                // Aberration angle (in degrees)
                const aberration = Math.atan(beta) * (180 / Math.PI);
                document.getElementById('aberration').textContent = `${aberration.toFixed(1)}°`;

                // Environment
                document.getElementById('depth').textContent = `${Math.abs(this.player.position.y).toFixed(0)}m`;
                document.getElementById('light-count').textContent = this.lightSources.length;
                document.getElementById('photon-count').textContent = this.photons.length;
                document.getElementById('player-count').textContent = this.peers.size + 1;
            }

            showNotification(title, text) {
                const notification = document.getElementById('notification');
                notification.querySelector('.notification-title').textContent = title;
                notification.querySelector('.notification-text').textContent = text;
                notification.classList.add('visible');

                setTimeout(() => {
                    notification.classList.remove('visible');
                }, 3000);
            }

            // ===== DATA IMPORT/EXPORT =====

            exportData() {
                const data = {
                    version: '1.0',
                    timestamp: Date.now(),
                    player: {
                        position: { x: this.player.position.x, y: this.player.position.y, z: this.player.position.z },
                        properTime: this.properTime
                    },
                    lightSources: this.lightSources.map(s => ({
                        position: { x: s.position.x, y: s.position.y, z: s.position.z },
                        color: s.baseColor,
                        pulseRate: s.pulseRate,
                        id: s.id
                    })),
                    creatures: this.creatures.map(c => ({
                        position: { x: c.position.x, y: c.position.y, z: c.position.z },
                        color: c.color,
                        size: c.size,
                        speed: c.baseSpeed
                    })),
                    settings: {
                        lightSpeed: this.LIGHT_SPEED,
                        worldBounds: this.worldBounds
                    }
                };

                const json = JSON.stringify(data, null, 2);

                this.showModal('Export World State', `
                    <p style="margin-bottom: 15px; color: #80d4ff;">Copy this JSON to save your slow light aquarium:</p>
                    <textarea readonly>${json}</textarea>
                `);
            }

            showImportModal() {
                this.showModal('Import World State', `
                    <p style="margin-bottom: 15px; color: #80d4ff;">Paste JSON world data below:</p>
                    <textarea id="import-data" placeholder="Paste JSON here..."></textarea>
                `, () => {
                    const data = document.getElementById('import-data').value;
                    this.importData(data);
                });
            }

            importData(jsonStr) {
                try {
                    const data = JSON.parse(jsonStr);

                    if (!data.version) {
                        throw new Error('Invalid world data format');
                    }

                    // Clear existing world
                    this.lightSources = [];
                    this.creatures = [];
                    this.photons = [];

                    // Restore player
                    if (data.player) {
                        this.player.position = new Vec3(
                            data.player.position.x,
                            data.player.position.y,
                            data.player.position.z
                        );
                        this.properTime = data.player.properTime || 0;
                    }

                    // Restore light sources
                    if (data.lightSources) {
                        data.lightSources.forEach(s => {
                            this.lightSources.push(new LightSource(
                                new Vec3(s.position.x, s.position.y, s.position.z),
                                s.color,
                                s.pulseRate,
                                s.id
                            ));
                        });
                    }

                    // Restore creatures
                    if (data.creatures) {
                        data.creatures.forEach(c => {
                            this.creatures.push(new Creature(
                                new Vec3(c.position.x, c.position.y, c.position.z),
                                c.color,
                                c.size,
                                c.speed
                            ));
                        });
                    }

                    // Restore settings
                    if (data.settings) {
                        this.LIGHT_SPEED = data.settings.lightSpeed || 3.0;
                        this.worldBounds = data.settings.worldBounds || 100;
                    }

                    this.hideModal();
                    this.showNotification('World Imported', 'Successfully loaded world state!');

                } catch (error) {
                    console.error('Import error:', error);
                    alert('Failed to import world data. Please check the JSON format.');
                }
            }

            resetWorld() {
                if (confirm('Reset world to default state?')) {
                    this.lightSources = [];
                    this.creatures = [];
                    this.photons = [];
                    this.particles = [];
                    this.player.position = new Vec3(0, -10, 0);
                    this.player.velocity = new Vec3(0, 0, 0);
                    this.properTime = 0;
                    this.worldTime = 0;

                    this.generateWorld();
                    localStorage.removeItem('slow_light_aquarium');

                    this.showNotification('World Reset', 'Aquarium has been restored to default state.');
                }
            }

            showModal(title, bodyHTML, actionCallback = null) {
                document.getElementById('modal-title').textContent = title;
                document.getElementById('modal-body').innerHTML = bodyHTML;
                document.getElementById('modal-overlay').classList.add('visible');

                const actionBtn = document.getElementById('modal-action');
                if (actionCallback) {
                    actionBtn.style.display = 'block';
                    actionBtn.textContent = 'Import';
                    actionBtn.onclick = actionCallback;
                } else {
                    actionBtn.style.display = 'none';
                }
            }

            hideModal() {
                document.getElementById('modal-overlay').classList.remove('visible');
            }

            saveState() {
                const state = {
                    player: {
                        position: { x: this.player.position.x, y: this.player.position.y, z: this.player.position.z },
                        properTime: this.properTime
                    }
                };
                localStorage.setItem('slow_light_aquarium', JSON.stringify(state));
            }

            loadState() {
                const saved = localStorage.getItem('slow_light_aquarium');
                if (saved) {
                    try {
                        const state = JSON.parse(saved);
                        if (state.player) {
                            this.player.position = new Vec3(
                                state.player.position.x,
                                state.player.position.y,
                                state.player.position.z
                            );
                            this.properTime = state.player.properTime || 0;
                        }
                    } catch (e) {
                        console.error('Failed to load saved state:', e);
                    }
                }
            }
        }

        // ===== INITIALIZE =====
        let game = null;

        window.addEventListener('load', () => {
            game = new SlowLightAquarium();
        });

        window.addEventListener('beforeunload', () => {
            if (game) {
                game.saveState();
            }
        });
    </script>
</body>
</html>
