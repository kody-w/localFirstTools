<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pulse Garden - Quantum World</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000510;
            color: #00ffcc;
            overflow: hidden;
            height: 100vh;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #ui {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            pointer-events: none;
            z-index: 100;
        }

        #hud {
            display: flex;
            justify-content: space-between;
            padding: 20px;
            background: linear-gradient(180deg, rgba(0, 5, 20, 0.9) 0%, transparent 100%);
        }

        .panel {
            background: rgba(0, 20, 40, 0.85);
            border: 2px solid rgba(0, 255, 200, 0.4);
            border-radius: 15px;
            padding: 15px;
            min-width: 220px;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 30px rgba(0, 255, 150, 0.15);
        }

        .panel h3 {
            color: #00ffd0;
            margin-bottom: 12px;
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            font-size: 13px;
        }

        .stat-label {
            color: #80ffe0;
        }

        .stat-value {
            color: #ffffff;
            font-weight: bold;
            font-family: monospace;
        }

        /* Heart rate visualization */
        #heart-container {
            display: flex;
            align-items: center;
            gap: 15px;
            margin: 15px 0;
        }

        #heart-icon {
            font-size: 32px;
            animation: heartbeat 1s ease-in-out infinite;
            filter: drop-shadow(0 0 10px #ff4466);
        }

        @keyframes heartbeat {
            0%, 100% { transform: scale(1); }
            15% { transform: scale(1.15); }
            30% { transform: scale(1); }
            45% { transform: scale(1.1); }
        }

        #bpm-display {
            font-size: 36px;
            font-weight: bold;
            color: #ff6688;
            text-shadow: 0 0 20px rgba(255, 100, 130, 0.6);
        }

        #bpm-label {
            font-size: 12px;
            color: #ff99aa;
        }

        /* ECG-style waveform */
        #ecg-container {
            height: 50px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            overflow: hidden;
            margin-top: 10px;
        }

        #ecg-canvas {
            width: 100%;
            height: 100%;
        }

        /* Creature stats */
        #creature-info {
            margin-top: 10px;
            padding: 10px;
            background: rgba(0, 255, 200, 0.1);
            border-radius: 8px;
        }

        .creature-preview {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            margin: 0 auto 10px;
            background: radial-gradient(circle, rgba(0, 255, 200, 0.6) 0%, transparent 70%);
            animation: pulse-glow 2s ease-in-out infinite;
        }

        @keyframes pulse-glow {
            0%, 100% { box-shadow: 0 0 20px rgba(0, 255, 200, 0.4); }
            50% { box-shadow: 0 0 40px rgba(0, 255, 200, 0.8); }
        }

        /* Synchronization indicator */
        #sync-panel {
            margin-top: 15px;
            padding: 12px;
            background: rgba(255, 100, 200, 0.1);
            border: 1px solid rgba(255, 100, 200, 0.3);
            border-radius: 10px;
        }

        #sync-bar {
            height: 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 8px;
        }

        #sync-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff66aa, #aa66ff, #66aaff);
            border-radius: 4px;
            width: 0%;
            transition: width 0.3s;
        }

        /* Webcam preview */
        #webcam-container {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 160px;
            border-radius: 12px;
            overflow: hidden;
            border: 2px solid rgba(0, 255, 200, 0.4);
            box-shadow: 0 0 20px rgba(0, 255, 200, 0.2);
            pointer-events: all;
            z-index: 200;
        }

        #webcam-video {
            width: 100%;
            display: block;
            transform: scaleX(-1);
        }

        #webcam-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(180deg, transparent 60%, rgba(0, 255, 200, 0.2) 100%);
            pointer-events: none;
        }

        #webcam-status {
            position: absolute;
            bottom: 5px;
            left: 5px;
            font-size: 10px;
            color: #00ffd0;
            background: rgba(0, 0, 0, 0.5);
            padding: 2px 6px;
            border-radius: 4px;
        }

        #detection-canvas {
            display: none;
        }

        /* Controls */
        #controls-panel {
            position: fixed;
            bottom: 20px;
            right: 20px;
            pointer-events: all;
            z-index: 200;
        }

        .control-btn {
            display: block;
            width: 100%;
            padding: 12px 20px;
            margin: 8px 0;
            background: linear-gradient(135deg, #004040, #006060);
            border: 2px solid rgba(0, 255, 200, 0.5);
            border-radius: 10px;
            color: #00ffd0;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .control-btn:hover {
            background: linear-gradient(135deg, #005050, #007070);
            box-shadow: 0 0 20px rgba(0, 255, 200, 0.4);
            transform: translateY(-2px);
        }

        .control-btn.active {
            background: linear-gradient(135deg, #006666, #008888);
            border-color: #00ffd0;
        }

        .control-btn.tether {
            background: linear-gradient(135deg, #400040, #600060);
            border-color: rgba(255, 100, 200, 0.5);
        }

        .control-btn.tether:hover {
            box-shadow: 0 0 20px rgba(255, 100, 200, 0.4);
        }

        .control-btn.tether.active {
            background: linear-gradient(135deg, #660066, #880088);
            border-color: #ff66cc;
            animation: tether-pulse 1s ease-in-out infinite;
        }

        @keyframes tether-pulse {
            0%, 100% { box-shadow: 0 0 20px rgba(255, 100, 200, 0.4); }
            50% { box-shadow: 0 0 40px rgba(255, 100, 200, 0.8); }
        }

        /* Menu overlay */
        #menu-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 5, 20, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            pointer-events: all;
        }

        #menu-overlay.hidden {
            display: none;
        }

        .menu-content {
            background: linear-gradient(135deg, #001020 0%, #002030 100%);
            border: 3px solid #00ffd0;
            border-radius: 20px;
            padding: 40px;
            max-width: 550px;
            width: 90%;
            text-align: center;
            box-shadow: 0 0 60px rgba(0, 255, 200, 0.3);
        }

        .menu-content h1 {
            font-size: 32px;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #00ffcc, #ff66aa);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .menu-content .subtitle {
            color: #80ffe0;
            margin-bottom: 25px;
            font-style: italic;
        }

        .menu-content p {
            color: #80c0b0;
            margin-bottom: 30px;
            line-height: 1.7;
            text-align: left;
        }

        .feature-list {
            text-align: left;
            margin: 20px 0;
            padding: 15px;
            background: rgba(0, 255, 200, 0.05);
            border-radius: 10px;
        }

        .feature-item {
            margin: 10px 0;
            color: #a0ffe0;
        }

        .feature-item span {
            color: #00ffd0;
            margin-right: 10px;
        }

        .menu-button {
            display: block;
            width: 100%;
            padding: 15px;
            margin: 10px 0;
            background: linear-gradient(135deg, #003040, #005060);
            border: 2px solid #00ffd0;
            border-radius: 12px;
            color: #00ffcc;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
            pointer-events: all;
        }

        .menu-button:hover {
            background: linear-gradient(135deg, #004050, #006070);
            box-shadow: 0 0 30px rgba(0, 255, 200, 0.5);
            transform: translateY(-2px);
        }

        .menu-button.primary {
            background: linear-gradient(135deg, #005050, #007070);
            font-size: 18px;
        }

        /* Notification */
        #notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 20, 40, 0.95);
            border: 2px solid #00ffd0;
            border-radius: 15px;
            padding: 25px 40px;
            text-align: center;
            pointer-events: none;
            box-shadow: 0 0 40px rgba(0, 255, 200, 0.4);
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 500;
        }

        #notification.visible {
            opacity: 1;
        }

        .notification-title {
            font-size: 20px;
            color: #00ffd0;
            margin-bottom: 8px;
        }

        .notification-text {
            color: #80ffe0;
            font-size: 14px;
        }

        /* Hybrid creature birth celebration */
        #hybrid-celebration {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 400;
            display: none;
        }

        #hybrid-celebration.active {
            display: block;
            animation: celebration-flash 2s ease-out;
        }

        @keyframes celebration-flash {
            0% { background: rgba(255, 100, 200, 0.3); }
            100% { background: transparent; }
        }

        /* Modal */
        #modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 5, 20, 0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            pointer-events: all;
        }

        #modal-overlay.visible {
            display: flex;
        }

        .modal-content {
            background: linear-gradient(135deg, #001020 0%, #002030 100%);
            border: 3px solid #00ffd0;
            border-radius: 15px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-content h2 {
            color: #00ffd0;
            margin-bottom: 15px;
        }

        .modal-content textarea {
            width: 100%;
            min-height: 200px;
            background: rgba(0, 20, 40, 0.8);
            border: 2px solid rgba(0, 255, 200, 0.3);
            border-radius: 8px;
            color: #e0fff0;
            padding: 12px;
            font-family: monospace;
            font-size: 12px;
            resize: vertical;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .modal-buttons button {
            flex: 1;
        }

        /* Mobile */
        @media (max-width: 768px) {
            .panel {
                min-width: 150px;
                padding: 10px;
            }

            #webcam-container {
                width: 120px;
            }

            #controls-panel {
                bottom: 10px;
                right: 10px;
            }

            .control-btn {
                padding: 10px 15px;
                font-size: 12px;
            }
        }

        /* Creature collection */
        #collection-panel {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
        }

        .creature-entry {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            margin: 5px 0;
            background: rgba(0, 255, 200, 0.1);
            border-radius: 8px;
            font-size: 12px;
        }

        .creature-entry .creature-dot {
            width: 20px;
            height: 20px;
            border-radius: 50%;
        }

        .creature-entry .creature-name {
            flex: 1;
            color: #a0ffe0;
        }

        .creature-entry .creature-type {
            color: #60c0a0;
            font-size: 10px;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <canvas id="detection-canvas"></canvas>

    <div id="hybrid-celebration"></div>

    <div id="ui">
        <div id="hud">
            <div class="panel">
                <h3>Your Heartbeat</h3>
                <div id="heart-container">
                    <div id="heart-icon">‚ù§Ô∏è</div>
                    <div>
                        <div id="bpm-display">--</div>
                        <div id="bpm-label">BPM</div>
                    </div>
                </div>
                <div id="ecg-container">
                    <canvas id="ecg-canvas"></canvas>
                </div>
                <div id="creature-info">
                    <div class="creature-preview" id="my-creature-preview"></div>
                    <div class="stat-row">
                        <span class="stat-label">Creature Type:</span>
                        <span class="stat-value" id="creature-type">Waiting...</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Emotional State:</span>
                        <span class="stat-value" id="emotional-state">Unknown</span>
                    </div>
                </div>
            </div>

            <div class="panel">
                <h3>Garden Status</h3>
                <div class="stat-row">
                    <span class="stat-label">Your Creatures:</span>
                    <span class="stat-value" id="my-creature-count">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Hybrid Creatures:</span>
                    <span class="stat-value" id="hybrid-count">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Online Players:</span>
                    <span class="stat-value" id="player-count">1</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Total Creatures:</span>
                    <span class="stat-value" id="total-creatures">0</span>
                </div>
                <div id="sync-panel">
                    <div class="stat-row">
                        <span class="stat-label">Heart Sync:</span>
                        <span class="stat-value" id="sync-percent">0%</span>
                    </div>
                    <div id="sync-bar">
                        <div id="sync-fill"></div>
                    </div>
                </div>
            </div>

            <div class="panel">
                <h3>Creature Collection</h3>
                <div id="collection-panel"></div>
            </div>
        </div>
    </div>

    <div id="webcam-container">
        <video id="webcam-video" autoplay playsinline></video>
        <div id="webcam-overlay"></div>
        <div id="webcam-status">Initializing...</div>
    </div>

    <div id="controls-panel" class="panel">
        <button class="control-btn tether" id="btn-tether">Hold to Tether Hearts</button>
        <button class="control-btn" id="btn-spawn">Spawn Creature</button>
        <button class="control-btn" id="btn-menu">Menu</button>
    </div>

    <div id="menu-overlay">
        <div class="menu-content">
            <h1>Pulse Garden</h1>
            <div class="subtitle">Where Hearts Grow Life</div>
            <p>
                Your heartbeat creates living creatures in a shared bioluminescent ecosystem.
                Calm hearts grow vast, serene jellyfish. Anxious hearts spawn swarms of flickering fireflies.
                When players synchronize their heartbeats, their creatures merge into rare hybrid lifeforms.
            </p>
            <div class="feature-list">
                <div class="feature-item"><span>‚ù§Ô∏è</span> Webcam detects your pulse via photoplethysmography</div>
                <div class="feature-item"><span>üåä</span> Heart rate determines creature type and behavior</div>
                <div class="feature-item"><span>üí´</span> Synchronize hearts to birth hybrid creatures</div>
                <div class="feature-item"><span>üîó</span> P2P multiplayer - no server needed</div>
            </div>
            <button class="menu-button primary" id="btn-start">Enable Camera & Enter Garden</button>
            <button class="menu-button" id="btn-simulate">Enter Without Camera (Simulated)</button>
            <button class="menu-button" id="btn-export">Export Collection</button>
            <button class="menu-button" id="btn-import">Import Collection</button>
        </div>
    </div>

    <div id="notification">
        <div class="notification-title"></div>
        <div class="notification-text"></div>
    </div>

    <div id="modal-overlay">
        <div class="modal-content">
            <h2 id="modal-title">Modal</h2>
            <div id="modal-body"></div>
            <div class="modal-buttons">
                <button class="menu-button" id="modal-close">Close</button>
                <button class="menu-button" id="modal-action" style="display: none;">Action</button>
            </div>
        </div>
    </div>

    <script>
        // ===== VECTOR3 CLASS =====
        class Vec3 {
            constructor(x = 0, y = 0, z = 0) {
                this.x = x;
                this.y = y;
                this.z = z;
            }

            add(v) { return new Vec3(this.x + v.x, this.y + v.y, this.z + v.z); }
            sub(v) { return new Vec3(this.x - v.x, this.y - v.y, this.z - v.z); }
            mul(s) { return new Vec3(this.x * s, this.y * s, this.z * s); }
            length() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z); }
            normalize() { const l = this.length(); return l > 0 ? this.mul(1/l) : new Vec3(); }
            clone() { return new Vec3(this.x, this.y, this.z); }
            distanceTo(v) { return this.sub(v).length(); }
            lerp(v, t) { return new Vec3(this.x + (v.x - this.x) * t, this.y + (v.y - this.y) * t, this.z + (v.z - this.z) * t); }
        }

        // ===== HEART RATE DETECTOR =====
        class HeartRateDetector {
            constructor() {
                this.video = document.getElementById('webcam-video');
                this.canvas = document.getElementById('detection-canvas');
                this.ctx = this.canvas.getContext('2d', { willReadFrequently: true });

                this.samples = [];
                this.maxSamples = 256;
                this.bpm = 0;
                this.confidence = 0;
                this.lastPeakTime = 0;
                this.peaks = [];
                this.isRunning = false;
                this.useSimulation = false;

                // Signal processing
                this.signalBuffer = [];
                this.filteredSignal = [];

                // Callbacks
                this.onBPMUpdate = null;
                this.onPulse = null;
            }

            async start(useSimulation = false) {
                this.useSimulation = useSimulation;

                if (useSimulation) {
                    this.isRunning = true;
                    this.simulateHeartbeat();
                    return true;
                }

                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: { facingMode: 'user', width: 320, height: 240 }
                    });

                    this.video.srcObject = stream;
                    await this.video.play();

                    this.canvas.width = 64;
                    this.canvas.height = 64;

                    this.isRunning = true;
                    this.detectLoop();

                    document.getElementById('webcam-status').textContent = 'Detecting pulse...';
                    return true;
                } catch (err) {
                    console.error('Camera access denied:', err);
                    document.getElementById('webcam-status').textContent = 'Camera denied';
                    return false;
                }
            }

            simulateHeartbeat() {
                if (!this.isRunning) return;

                // Simulate natural heart rate variation (60-100 BPM)
                const baseRate = 72;
                const variation = Math.sin(Date.now() / 10000) * 15; // Slow breathing variation
                const noise = (Math.random() - 0.5) * 5;
                this.bpm = Math.round(baseRate + variation + noise);
                this.confidence = 0.85 + Math.random() * 0.1;

                // Simulate pulse events
                const interval = 60000 / this.bpm;
                const now = Date.now();
                if (now - this.lastPeakTime > interval) {
                    this.lastPeakTime = now;
                    if (this.onPulse) this.onPulse();
                }

                if (this.onBPMUpdate) this.onBPMUpdate(this.bpm, this.confidence);

                setTimeout(() => this.simulateHeartbeat(), 100);
            }

            detectLoop() {
                if (!this.isRunning || this.useSimulation) return;

                // Capture frame
                this.ctx.drawImage(this.video, 0, 0, this.canvas.width, this.canvas.height);
                const frame = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);

                // Extract average red channel (best for PPG)
                let redSum = 0;
                let greenSum = 0;
                const pixels = frame.data;
                const numPixels = pixels.length / 4;

                // Focus on center region (forehead/cheek area)
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                const radius = 20;
                let count = 0;

                for (let y = 0; y < this.canvas.height; y++) {
                    for (let x = 0; x < this.canvas.width; x++) {
                        const dx = x - centerX;
                        const dy = y - centerY;
                        if (dx * dx + dy * dy < radius * radius) {
                            const i = (y * this.canvas.width + x) * 4;
                            redSum += pixels[i];
                            greenSum += pixels[i + 1];
                            count++;
                        }
                    }
                }

                const avgRed = redSum / count;
                const avgGreen = greenSum / count;

                // Use red-green difference for better signal
                const signal = avgRed - avgGreen * 0.5;

                this.signalBuffer.push(signal);
                if (this.signalBuffer.length > this.maxSamples) {
                    this.signalBuffer.shift();
                }

                // Apply bandpass filter (0.7-4 Hz for 42-240 BPM)
                if (this.signalBuffer.length >= 30) {
                    this.processSignal();
                }

                requestAnimationFrame(() => this.detectLoop());
            }

            processSignal() {
                // Simple moving average filter
                const windowSize = 5;
                this.filteredSignal = [];

                for (let i = windowSize; i < this.signalBuffer.length; i++) {
                    let sum = 0;
                    for (let j = 0; j < windowSize; j++) {
                        sum += this.signalBuffer[i - j];
                    }
                    this.filteredSignal.push(sum / windowSize);
                }

                // Detect peaks
                const peaks = [];
                const threshold = this.calculateThreshold();

                for (let i = 2; i < this.filteredSignal.length - 2; i++) {
                    const prev2 = this.filteredSignal[i - 2];
                    const prev1 = this.filteredSignal[i - 1];
                    const curr = this.filteredSignal[i];
                    const next1 = this.filteredSignal[i + 1];
                    const next2 = this.filteredSignal[i + 2];

                    if (curr > prev1 && curr > prev2 && curr > next1 && curr > next2 && curr > threshold) {
                        peaks.push(i);
                    }
                }

                // Calculate BPM from peak intervals
                if (peaks.length >= 2) {
                    const intervals = [];
                    for (let i = 1; i < peaks.length; i++) {
                        intervals.push(peaks[i] - peaks[i - 1]);
                    }

                    // Average interval in samples, convert to BPM
                    // Assuming ~30 FPS detection
                    const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
                    const fps = 30;
                    const bpm = (60 * fps) / avgInterval;

                    if (bpm >= 40 && bpm <= 200) {
                        this.bpm = Math.round(bpm);
                        this.confidence = Math.min(1, intervals.length / 5);

                        // Trigger pulse on peak
                        const now = Date.now();
                        const expectedInterval = 60000 / this.bpm;
                        if (now - this.lastPeakTime > expectedInterval * 0.8) {
                            this.lastPeakTime = now;
                            if (this.onPulse) this.onPulse();
                        }

                        if (this.onBPMUpdate) this.onBPMUpdate(this.bpm, this.confidence);
                    }
                }
            }

            calculateThreshold() {
                if (this.filteredSignal.length === 0) return 0;
                const mean = this.filteredSignal.reduce((a, b) => a + b, 0) / this.filteredSignal.length;
                const variance = this.filteredSignal.reduce((sum, val) => sum + (val - mean) ** 2, 0) / this.filteredSignal.length;
                return mean + Math.sqrt(variance) * 0.5;
            }

            getSignalForDisplay() {
                return this.filteredSignal.slice(-100);
            }

            stop() {
                this.isRunning = false;
                if (this.video.srcObject) {
                    this.video.srcObject.getTracks().forEach(track => track.stop());
                }
            }
        }

        // ===== CREATURE TYPES =====
        const CREATURE_TYPES = {
            // Calm (< 65 BPM)
            ETHEREAL_JELLYFISH: {
                name: 'Ethereal Jellyfish',
                minBPM: 0,
                maxBPM: 65,
                baseColor: { r: 0.3, g: 0.8, b: 1.0 },
                size: 40,
                tentacles: 8,
                pulseSpeed: 0.5,
                movement: 'drift',
                description: 'Born from deep tranquility'
            },
            // Relaxed (65-75 BPM)
            LUMINOUS_MANTA: {
                name: 'Luminous Manta',
                minBPM: 65,
                maxBPM: 75,
                baseColor: { r: 0.2, g: 1.0, b: 0.8 },
                size: 35,
                wingspan: 60,
                pulseSpeed: 0.7,
                movement: 'glide',
                description: 'Graceful and serene'
            },
            // Normal (75-90 BPM)
            PULSE_ANEMONE: {
                name: 'Pulse Anemone',
                minBPM: 75,
                maxBPM: 90,
                baseColor: { r: 0.5, g: 0.9, b: 0.5 },
                size: 25,
                fronds: 12,
                pulseSpeed: 1.0,
                movement: 'sway',
                description: 'Balanced life force'
            },
            // Elevated (90-110 BPM)
            SPARK_SCHOOL: {
                name: 'Spark School',
                minBPM: 90,
                maxBPM: 110,
                baseColor: { r: 1.0, g: 0.8, b: 0.3 },
                size: 8,
                count: 15,
                pulseSpeed: 1.5,
                movement: 'swarm',
                description: 'Energetic collective'
            },
            // Anxious (> 110 BPM)
            FLUTTER_SWARM: {
                name: 'Flutter Swarm',
                minBPM: 110,
                maxBPM: 999,
                baseColor: { r: 1.0, g: 0.4, b: 0.4 },
                size: 5,
                count: 30,
                pulseSpeed: 2.5,
                movement: 'flutter',
                description: 'Restless energy made visible'
            }
        };

        // ===== CREATURE CLASS =====
        class Creature {
            constructor(type, position, ownerId, bpmAtBirth, isHybrid = false, parentTypes = null) {
                this.id = Math.random().toString(36).substr(2, 9);
                this.type = type;
                this.typeData = CREATURE_TYPES[type] || CREATURE_TYPES.PULSE_ANEMONE;
                this.position = position.clone();
                this.velocity = new Vec3(
                    (Math.random() - 0.5) * 0.5,
                    (Math.random() - 0.5) * 0.2,
                    (Math.random() - 0.5) * 0.5
                );
                this.ownerId = ownerId;
                this.bpmAtBirth = bpmAtBirth;
                this.birthTime = Date.now();
                this.age = 0;
                this.phase = Math.random() * Math.PI * 2;
                this.isHybrid = isHybrid;
                this.parentTypes = parentTypes;

                // Visual properties
                this.size = this.typeData.size * (0.8 + Math.random() * 0.4);
                this.color = { ...this.typeData.baseColor };
                this.glowIntensity = 0.5;
                this.pulsePhase = 0;

                // Behavior
                this.targetPosition = null;
                this.wanderAngle = Math.random() * Math.PI * 2;

                // Hybrid creatures have mixed colors
                if (isHybrid && parentTypes) {
                    const p1 = CREATURE_TYPES[parentTypes[0]];
                    const p2 = CREATURE_TYPES[parentTypes[1]];
                    this.color = {
                        r: (p1.baseColor.r + p2.baseColor.r) / 2,
                        g: (p1.baseColor.g + p2.baseColor.g) / 2,
                        b: (p1.baseColor.b + p2.baseColor.b) / 2
                    };
                    this.size *= 1.3; // Hybrids are larger
                }
            }

            update(dt, time, bounds, nearbyCreatures) {
                this.age = (Date.now() - this.birthTime) / 1000;
                this.pulsePhase += dt * this.typeData.pulseSpeed * Math.PI * 2;

                // Movement based on type
                switch (this.typeData.movement) {
                    case 'drift':
                        this.driftMovement(dt, time);
                        break;
                    case 'glide':
                        this.glideMovement(dt, time);
                        break;
                    case 'sway':
                        this.swayMovement(dt, time);
                        break;
                    case 'swarm':
                    case 'flutter':
                        this.swarmMovement(dt, time, nearbyCreatures);
                        break;
                }

                // Apply velocity
                this.position = this.position.add(this.velocity.mul(dt));

                // Boundary constraints
                const margin = 10;
                if (this.position.x < -bounds + margin) this.velocity.x += 0.1;
                if (this.position.x > bounds - margin) this.velocity.x -= 0.1;
                if (this.position.y < -bounds + margin) this.velocity.y += 0.1;
                if (this.position.y > bounds / 2 - margin) this.velocity.y -= 0.1;
                if (this.position.z < -bounds + margin) this.velocity.z += 0.1;
                if (this.position.z > bounds - margin) this.velocity.z -= 0.1;

                // Damping
                this.velocity = this.velocity.mul(0.98);

                // Glow pulsing
                this.glowIntensity = 0.5 + 0.3 * Math.sin(this.pulsePhase);
            }

            driftMovement(dt, time) {
                // Slow, graceful vertical bobbing
                this.velocity.y += Math.sin(time * 0.5 + this.phase) * 0.01;
                this.wanderAngle += (Math.random() - 0.5) * 0.1;
                this.velocity.x += Math.cos(this.wanderAngle) * 0.005;
                this.velocity.z += Math.sin(this.wanderAngle) * 0.005;
            }

            glideMovement(dt, time) {
                // Swooping circular patterns
                const radius = 20;
                const speed = 0.3;
                this.wanderAngle += dt * speed;
                this.velocity.x = Math.cos(this.wanderAngle) * speed * 0.5;
                this.velocity.z = Math.sin(this.wanderAngle) * speed * 0.5;
                this.velocity.y += Math.sin(time + this.phase) * 0.02;
            }

            swayMovement(dt, time) {
                // Anchored swaying
                this.velocity.x = Math.sin(time * 0.8 + this.phase) * 0.1;
                this.velocity.y = Math.sin(time * 0.5 + this.phase) * 0.05;
                this.velocity.z = Math.cos(time * 0.6 + this.phase) * 0.1;
            }

            swarmMovement(dt, time, nearbyCreatures) {
                // Flocking behavior
                const separation = new Vec3();
                const alignment = new Vec3();
                const cohesion = new Vec3();
                let neighborCount = 0;

                nearbyCreatures.forEach(other => {
                    if (other.id === this.id) return;
                    const dist = this.position.distanceTo(other.position);

                    if (dist < 15 && dist > 0) {
                        // Separation
                        const diff = this.position.sub(other.position).normalize().mul(1 / dist);
                        separation.x += diff.x;
                        separation.y += diff.y;
                        separation.z += diff.z;

                        // Alignment
                        alignment.x += other.velocity.x;
                        alignment.y += other.velocity.y;
                        alignment.z += other.velocity.z;

                        // Cohesion
                        cohesion.x += other.position.x;
                        cohesion.y += other.position.y;
                        cohesion.z += other.position.z;

                        neighborCount++;
                    }
                });

                if (neighborCount > 0) {
                    alignment.x /= neighborCount;
                    alignment.y /= neighborCount;
                    alignment.z /= neighborCount;

                    cohesion.x = cohesion.x / neighborCount - this.position.x;
                    cohesion.y = cohesion.y / neighborCount - this.position.y;
                    cohesion.z = cohesion.z / neighborCount - this.position.z;
                }

                // Apply forces
                const separationWeight = 1.5;
                const alignmentWeight = 1.0;
                const cohesionWeight = 0.5;

                this.velocity.x += separation.x * separationWeight + alignment.x * alignmentWeight * 0.1 + cohesion.x * cohesionWeight * 0.01;
                this.velocity.y += separation.y * separationWeight + alignment.y * alignmentWeight * 0.1 + cohesion.y * cohesionWeight * 0.01;
                this.velocity.z += separation.z * separationWeight + alignment.z * alignmentWeight * 0.1 + cohesion.z * cohesionWeight * 0.01;

                // Add flutter for anxious creatures
                if (this.typeData.movement === 'flutter') {
                    this.velocity.x += (Math.random() - 0.5) * 0.5;
                    this.velocity.y += (Math.random() - 0.5) * 0.3;
                    this.velocity.z += (Math.random() - 0.5) * 0.5;
                }

                // Speed limit
                const speed = this.velocity.length();
                const maxSpeed = this.typeData.movement === 'flutter' ? 3 : 1.5;
                if (speed > maxSpeed) {
                    this.velocity = this.velocity.mul(maxSpeed / speed);
                }
            }
        }

        // ===== WEBGL RENDERER =====
        class GardenRenderer {
            constructor(canvas) {
                this.canvas = canvas;
                this.gl = canvas.getContext('webgl2') || canvas.getContext('webgl');

                if (!this.gl) {
                    alert('WebGL not supported');
                    return;
                }

                this.initShaders();
                this.gl.enable(this.gl.DEPTH_TEST);
                this.gl.enable(this.gl.BLEND);
                this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);

                this.resize();
                window.addEventListener('resize', () => this.resize());
            }

            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
            }

            initShaders() {
                const vsSource = `
                    attribute vec3 aPosition;
                    attribute vec4 aColor;
                    attribute float aSize;
                    attribute float aGlow;

                    uniform mat4 uProjection;
                    uniform mat4 uView;
                    uniform float uTime;

                    varying vec4 vColor;
                    varying float vGlow;

                    void main() {
                        gl_Position = uProjection * uView * vec4(aPosition, 1.0);
                        gl_PointSize = aSize * (300.0 / gl_Position.w);
                        gl_PointSize = clamp(gl_PointSize, 2.0, 150.0);
                        vColor = aColor;
                        vGlow = aGlow;
                    }
                `;

                const fsSource = `
                    precision mediump float;

                    varying vec4 vColor;
                    varying float vGlow;

                    void main() {
                        float dist = length(gl_PointCoord - vec2(0.5));
                        if (dist > 0.5) discard;

                        // Soft glow falloff
                        float alpha = 1.0 - smoothstep(0.0, 0.5, dist);
                        alpha *= vColor.a;

                        // Inner glow
                        float innerGlow = exp(-dist * 6.0) * vGlow;

                        vec3 finalColor = vColor.rgb + vec3(innerGlow * 0.5);

                        gl_FragColor = vec4(finalColor, alpha);
                    }
                `;

                this.program = this.createProgram(vsSource, fsSource);
                this.gl.useProgram(this.program);

                this.attributes = {
                    position: this.gl.getAttribLocation(this.program, 'aPosition'),
                    color: this.gl.getAttribLocation(this.program, 'aColor'),
                    size: this.gl.getAttribLocation(this.program, 'aSize'),
                    glow: this.gl.getAttribLocation(this.program, 'aGlow')
                };

                this.uniforms = {
                    projection: this.gl.getUniformLocation(this.program, 'uProjection'),
                    view: this.gl.getUniformLocation(this.program, 'uView'),
                    time: this.gl.getUniformLocation(this.program, 'uTime')
                };

                this.positionBuffer = this.gl.createBuffer();
                this.colorBuffer = this.gl.createBuffer();
                this.sizeBuffer = this.gl.createBuffer();
                this.glowBuffer = this.gl.createBuffer();
            }

            createProgram(vsSource, fsSource) {
                const vs = this.compileShader(vsSource, this.gl.VERTEX_SHADER);
                const fs = this.compileShader(fsSource, this.gl.FRAGMENT_SHADER);

                const program = this.gl.createProgram();
                this.gl.attachShader(program, vs);
                this.gl.attachShader(program, fs);
                this.gl.linkProgram(program);

                return program;
            }

            compileShader(source, type) {
                const shader = this.gl.createShader(type);
                this.gl.shaderSource(shader, source);
                this.gl.compileShader(shader);

                if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
                    console.error('Shader error:', this.gl.getShaderInfoLog(shader));
                }

                return shader;
            }

            render(creatures, particles, camera, time) {
                // Deep ocean gradient
                this.gl.clearColor(0.0, 0.02, 0.05, 1.0);
                this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);

                const positions = [];
                const colors = [];
                const sizes = [];
                const glows = [];

                // Add creatures
                creatures.forEach(creature => {
                    positions.push(creature.position.x, creature.position.y, creature.position.z);
                    colors.push(
                        creature.color.r,
                        creature.color.g,
                        creature.color.b,
                        0.8
                    );
                    sizes.push(creature.size * (1 + creature.glowIntensity * 0.3));
                    glows.push(creature.glowIntensity);

                    // Add glow halo
                    positions.push(creature.position.x, creature.position.y, creature.position.z);
                    colors.push(
                        creature.color.r,
                        creature.color.g,
                        creature.color.b,
                        0.2
                    );
                    sizes.push(creature.size * 2.5);
                    glows.push(creature.glowIntensity * 0.5);
                });

                // Add particles
                particles.forEach(p => {
                    positions.push(p.position.x, p.position.y, p.position.z);
                    colors.push(p.color.r, p.color.g, p.color.b, p.color.a);
                    sizes.push(p.size);
                    glows.push(0.3);
                });

                if (positions.length === 0) return;

                // Update buffers
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(positions), this.gl.DYNAMIC_DRAW);
                this.gl.enableVertexAttribArray(this.attributes.position);
                this.gl.vertexAttribPointer(this.attributes.position, 3, this.gl.FLOAT, false, 0, 0);

                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorBuffer);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(colors), this.gl.DYNAMIC_DRAW);
                this.gl.enableVertexAttribArray(this.attributes.color);
                this.gl.vertexAttribPointer(this.attributes.color, 4, this.gl.FLOAT, false, 0, 0);

                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.sizeBuffer);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(sizes), this.gl.DYNAMIC_DRAW);
                this.gl.enableVertexAttribArray(this.attributes.size);
                this.gl.vertexAttribPointer(this.attributes.size, 1, this.gl.FLOAT, false, 0, 0);

                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.glowBuffer);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(glows), this.gl.DYNAMIC_DRAW);
                this.gl.enableVertexAttribArray(this.attributes.glow);
                this.gl.vertexAttribPointer(this.attributes.glow, 1, this.gl.FLOAT, false, 0, 0);

                // Set uniforms
                this.gl.uniformMatrix4fv(this.uniforms.projection, false, camera.projectionMatrix);
                this.gl.uniformMatrix4fv(this.uniforms.view, false, camera.viewMatrix);
                this.gl.uniform1f(this.uniforms.time, time);

                // Draw
                this.gl.drawArrays(this.gl.POINTS, 0, positions.length / 3);
            }
        }

        // ===== CAMERA =====
        class Camera {
            constructor() {
                this.position = new Vec3(0, 0, 80);
                this.target = new Vec3(0, 0, 0);
                this.fov = Math.PI / 3;
                this.aspect = window.innerWidth / window.innerHeight;

                this.projectionMatrix = new Float32Array(16);
                this.viewMatrix = new Float32Array(16);

                this.orbitAngle = 0;
                this.orbitSpeed = 0.1;
                this.orbitRadius = 80;
                this.orbitHeight = 20;

                this.updateProjection();
            }

            updateProjection() {
                this.aspect = window.innerWidth / window.innerHeight;
                const f = 1.0 / Math.tan(this.fov / 2);
                const near = 0.1, far = 500;
                const nf = 1 / (near - far);

                this.projectionMatrix[0] = f / this.aspect;
                this.projectionMatrix[5] = f;
                this.projectionMatrix[10] = (far + near) * nf;
                this.projectionMatrix[11] = -1;
                this.projectionMatrix[14] = 2 * far * near * nf;
                this.projectionMatrix[15] = 0;
            }

            update(dt) {
                // Gentle orbit
                this.orbitAngle += dt * this.orbitSpeed;

                this.position.x = Math.sin(this.orbitAngle) * this.orbitRadius;
                this.position.z = Math.cos(this.orbitAngle) * this.orbitRadius;
                this.position.y = this.orbitHeight + Math.sin(this.orbitAngle * 0.5) * 10;

                this.updateView();
            }

            updateView() {
                const z = this.position.sub(this.target).normalize();
                const up = new Vec3(0, 1, 0);
                const x = up.cross(z).normalize();
                const y = z.cross(x);

                this.viewMatrix[0] = x.x;
                this.viewMatrix[1] = y.x;
                this.viewMatrix[2] = z.x;
                this.viewMatrix[3] = 0;
                this.viewMatrix[4] = x.y;
                this.viewMatrix[5] = y.y;
                this.viewMatrix[6] = z.y;
                this.viewMatrix[7] = 0;
                this.viewMatrix[8] = x.z;
                this.viewMatrix[9] = y.z;
                this.viewMatrix[10] = z.z;
                this.viewMatrix[11] = 0;
                this.viewMatrix[12] = -x.x * this.position.x - x.y * this.position.y - x.z * this.position.z;
                this.viewMatrix[13] = -y.x * this.position.x - y.y * this.position.y - y.z * this.position.z;
                this.viewMatrix[14] = -z.x * this.position.x - z.y * this.position.y - z.z * this.position.z;
                this.viewMatrix[15] = 1;
            }
        }

        // ===== ECG DISPLAY =====
        class ECGDisplay {
            constructor() {
                this.canvas = document.getElementById('ecg-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.data = [];
                this.maxPoints = 100;

                this.resize();
                window.addEventListener('resize', () => this.resize());
            }

            resize() {
                const container = this.canvas.parentElement;
                this.canvas.width = container.clientWidth;
                this.canvas.height = container.clientHeight;
            }

            addPulse() {
                // Add ECG-like waveform
                const pulseData = [0, 0.1, 0.15, 0.1, 0, -0.1, 0.8, -0.2, 0, 0.05, 0.1, 0.05, 0];
                pulseData.forEach(v => {
                    this.data.push(v);
                    if (this.data.length > this.maxPoints) {
                        this.data.shift();
                    }
                });
            }

            addBaseline() {
                this.data.push(0 + (Math.random() - 0.5) * 0.05);
                if (this.data.length > this.maxPoints) {
                    this.data.shift();
                }
            }

            draw() {
                const ctx = this.ctx;
                const w = this.canvas.width;
                const h = this.canvas.height;

                ctx.fillStyle = 'rgba(0, 20, 30, 0.3)';
                ctx.fillRect(0, 0, w, h);

                if (this.data.length < 2) return;

                ctx.strokeStyle = '#00ffd0';
                ctx.lineWidth = 2;
                ctx.shadowColor = '#00ffd0';
                ctx.shadowBlur = 10;

                ctx.beginPath();
                const stepX = w / this.maxPoints;

                for (let i = 0; i < this.data.length; i++) {
                    const x = i * stepX;
                    const y = h / 2 - this.data[i] * h * 0.4;

                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }

                ctx.stroke();
                ctx.shadowBlur = 0;
            }
        }

        // ===== MAIN GAME =====
        class PulseGarden {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.renderer = new GardenRenderer(this.canvas);
                this.camera = new Camera();
                this.heartDetector = new HeartRateDetector();
                this.ecgDisplay = new ECGDisplay();

                this.creatures = [];
                this.particles = [];
                this.myCreatures = [];
                this.hybridCreatures = [];
                this.collection = [];

                this.worldBounds = 60;
                this.isRunning = false;
                this.lastTime = 0;
                this.worldTime = 0;

                this.currentBPM = 0;
                this.currentCreatureType = null;
                this.emotionalState = 'Unknown';

                // Tethering
                this.isTethering = false;
                this.tetherPartner = null;
                this.syncScore = 0;
                this.syncHistory = [];

                // P2P (simplified)
                this.peerId = 'player_' + Math.random().toString(36).substr(2, 9);
                this.peers = new Map();

                // Auto-spawn timer
                this.lastSpawnTime = 0;
                this.spawnInterval = 5000; // Spawn every 5 seconds based on current heart rate

                this.init();
            }

            init() {
                this.loadState();
                this.generateParticles();
                this.setupUI();
                this.setupHeartDetector();
            }

            generateParticles() {
                // Ambient bioluminescent particles
                for (let i = 0; i < 300; i++) {
                    this.particles.push({
                        position: new Vec3(
                            (Math.random() - 0.5) * this.worldBounds * 2,
                            (Math.random() - 0.5) * this.worldBounds,
                            (Math.random() - 0.5) * this.worldBounds * 2
                        ),
                        velocity: new Vec3(
                            (Math.random() - 0.5) * 0.1,
                            (Math.random() - 0.5) * 0.05,
                            (Math.random() - 0.5) * 0.1
                        ),
                        color: {
                            r: 0.1 + Math.random() * 0.2,
                            g: 0.3 + Math.random() * 0.3,
                            b: 0.4 + Math.random() * 0.3,
                            a: 0.2 + Math.random() * 0.3
                        },
                        size: 2 + Math.random() * 4
                    });
                }
            }

            setupUI() {
                document.getElementById('btn-start').addEventListener('click', () => this.start(false));
                document.getElementById('btn-simulate').addEventListener('click', () => this.start(true));
                document.getElementById('btn-export').addEventListener('click', () => this.exportData());
                document.getElementById('btn-import').addEventListener('click', () => this.showImportModal());
                document.getElementById('btn-menu').addEventListener('click', () => this.toggleMenu());
                document.getElementById('btn-spawn').addEventListener('click', () => this.spawnCreature());

                // Tether button
                const tetherBtn = document.getElementById('btn-tether');
                tetherBtn.addEventListener('mousedown', () => this.startTethering());
                tetherBtn.addEventListener('mouseup', () => this.stopTethering());
                tetherBtn.addEventListener('mouseleave', () => this.stopTethering());
                tetherBtn.addEventListener('touchstart', (e) => { e.preventDefault(); this.startTethering(); });
                tetherBtn.addEventListener('touchend', () => this.stopTethering());

                document.getElementById('modal-close').addEventListener('click', () => this.hideModal());
            }

            setupHeartDetector() {
                this.heartDetector.onBPMUpdate = (bpm, confidence) => {
                    this.currentBPM = bpm;
                    this.updateHeartDisplay(bpm, confidence);
                    this.updateCreatureType(bpm);
                    this.updateEmotionalState(bpm);

                    // Sync detection when tethering
                    if (this.isTethering) {
                        this.updateSyncScore();
                    }
                };

                this.heartDetector.onPulse = () => {
                    this.onHeartbeat();
                };
            }

            async start(useSimulation) {
                const success = await this.heartDetector.start(useSimulation);

                if (success || useSimulation) {
                    document.getElementById('menu-overlay').classList.add('hidden');
                    this.isRunning = true;
                    this.lastTime = performance.now();
                    this.gameLoop();

                    if (useSimulation) {
                        document.getElementById('webcam-status').textContent = 'Simulated';
                        document.getElementById('webcam-container').style.opacity = '0.5';
                    }
                }
            }

            toggleMenu() {
                const menu = document.getElementById('menu-overlay');
                menu.classList.toggle('hidden');
                this.isRunning = menu.classList.contains('hidden');

                if (this.isRunning) {
                    this.lastTime = performance.now();
                    this.gameLoop();
                }
            }

            gameLoop() {
                if (!this.isRunning) return;

                const now = performance.now();
                const dt = Math.min((now - this.lastTime) / 1000, 0.1);
                this.lastTime = now;
                this.worldTime += dt;

                this.update(dt);
                this.render();

                requestAnimationFrame(() => this.gameLoop());
            }

            update(dt) {
                // Update camera
                this.camera.update(dt);

                // Update creatures
                this.creatures.forEach(creature => {
                    creature.update(dt, this.worldTime, this.worldBounds, this.creatures);
                });

                // Update particles
                this.particles.forEach(p => {
                    p.position = p.position.add(p.velocity.mul(dt));

                    // Gentle boundary wrap
                    const bounds = this.worldBounds;
                    if (Math.abs(p.position.x) > bounds) p.position.x *= -0.9;
                    if (Math.abs(p.position.y) > bounds * 0.5) p.position.y *= -0.9;
                    if (Math.abs(p.position.z) > bounds) p.position.z *= -0.9;
                });

                // Auto-spawn based on heartbeat
                const now = Date.now();
                if (this.currentBPM > 0 && now - this.lastSpawnTime > this.spawnInterval) {
                    this.spawnCreature();
                    this.lastSpawnTime = now;
                }

                // ECG baseline
                if (Math.random() < 0.3) {
                    this.ecgDisplay.addBaseline();
                }
                this.ecgDisplay.draw();

                // Update UI
                this.updateUI();
            }

            render() {
                this.renderer.render(this.creatures, this.particles, this.camera, this.worldTime);
            }

            updateHeartDisplay(bpm, confidence) {
                document.getElementById('bpm-display').textContent = bpm;

                // Update heart animation speed
                const heartIcon = document.getElementById('heart-icon');
                const duration = 60 / bpm;
                heartIcon.style.animationDuration = `${duration}s`;

                // Update webcam status
                const status = confidence > 0.5 ? 'Good signal' : 'Weak signal';
                document.getElementById('webcam-status').textContent = status;
            }

            updateCreatureType(bpm) {
                for (const [typeName, typeData] of Object.entries(CREATURE_TYPES)) {
                    if (bpm >= typeData.minBPM && bpm < typeData.maxBPM) {
                        this.currentCreatureType = typeName;
                        document.getElementById('creature-type').textContent = typeData.name;

                        // Update creature preview color
                        const preview = document.getElementById('my-creature-preview');
                        preview.style.background = `radial-gradient(circle, rgba(${typeData.baseColor.r * 255}, ${typeData.baseColor.g * 255}, ${typeData.baseColor.b * 255}, 0.8) 0%, transparent 70%)`;
                        break;
                    }
                }
            }

            updateEmotionalState(bpm) {
                if (bpm < 60) this.emotionalState = 'Deep Calm';
                else if (bpm < 70) this.emotionalState = 'Relaxed';
                else if (bpm < 80) this.emotionalState = 'At Ease';
                else if (bpm < 90) this.emotionalState = 'Alert';
                else if (bpm < 100) this.emotionalState = 'Energized';
                else if (bpm < 110) this.emotionalState = 'Excited';
                else this.emotionalState = 'Intense';

                document.getElementById('emotional-state').textContent = this.emotionalState;
            }

            onHeartbeat() {
                // Visual pulse feedback
                this.ecgDisplay.addPulse();

                // Could add screen flash or other feedback here
            }

            spawnCreature() {
                if (!this.currentCreatureType || this.currentBPM === 0) return;

                const position = new Vec3(
                    (Math.random() - 0.5) * this.worldBounds,
                    (Math.random() - 0.5) * this.worldBounds * 0.5,
                    (Math.random() - 0.5) * this.worldBounds
                );

                const creature = new Creature(
                    this.currentCreatureType,
                    position,
                    this.peerId,
                    this.currentBPM
                );

                this.creatures.push(creature);
                this.myCreatures.push(creature);

                // Add to collection if new type
                if (!this.collection.find(c => c.type === this.currentCreatureType && !c.isHybrid)) {
                    this.collection.push({
                        type: this.currentCreatureType,
                        name: creature.typeData.name,
                        color: { ...creature.typeData.baseColor },
                        discoveredAt: Date.now(),
                        isHybrid: false
                    });
                    this.showNotification('New Species!', `Discovered: ${creature.typeData.name}`);
                }

                this.updateCollectionDisplay();
            }

            startTethering() {
                this.isTethering = true;
                this.syncScore = 0;
                this.syncHistory = [];
                document.getElementById('btn-tether').classList.add('active');

                // In real P2P, this would broadcast tether request
                // For demo, simulate a partner
                this.simulateTetherPartner();
            }

            stopTethering() {
                // Check if sync was achieved
                if (this.syncScore > 80) {
                    this.birthHybridCreature();
                }

                this.isTethering = false;
                this.tetherPartner = null;
                document.getElementById('btn-tether').classList.remove('active');
                document.getElementById('sync-fill').style.width = '0%';
                document.getElementById('sync-percent').textContent = '0%';
            }

            simulateTetherPartner() {
                // Simulate another player's heartbeat
                this.tetherPartner = {
                    bpm: this.currentBPM + (Math.random() - 0.5) * 20,
                    creatureType: this.currentCreatureType
                };
            }

            updateSyncScore() {
                if (!this.tetherPartner) return;

                // Gradually sync partner to player (simulating real heart sync)
                this.tetherPartner.bpm += (this.currentBPM - this.tetherPartner.bpm) * 0.05;

                // Calculate sync percentage
                const bpmDiff = Math.abs(this.currentBPM - this.tetherPartner.bpm);
                const sync = Math.max(0, 100 - bpmDiff * 5);

                this.syncHistory.push(sync);
                if (this.syncHistory.length > 30) this.syncHistory.shift();

                // Average sync over time
                this.syncScore = this.syncHistory.reduce((a, b) => a + b, 0) / this.syncHistory.length;

                document.getElementById('sync-fill').style.width = `${this.syncScore}%`;
                document.getElementById('sync-percent').textContent = `${Math.round(this.syncScore)}%`;
            }

            birthHybridCreature() {
                if (!this.tetherPartner) return;

                const position = new Vec3(
                    (Math.random() - 0.5) * this.worldBounds * 0.5,
                    (Math.random() - 0.5) * this.worldBounds * 0.25,
                    (Math.random() - 0.5) * this.worldBounds * 0.5
                );

                const parentTypes = [this.currentCreatureType, this.tetherPartner.creatureType || this.currentCreatureType];

                const hybrid = new Creature(
                    this.currentCreatureType,
                    position,
                    this.peerId,
                    this.currentBPM,
                    true,
                    parentTypes
                );

                this.creatures.push(hybrid);
                this.hybridCreatures.push(hybrid);

                // Celebration effect
                document.getElementById('hybrid-celebration').classList.add('active');
                setTimeout(() => {
                    document.getElementById('hybrid-celebration').classList.remove('active');
                }, 2000);

                // Add to collection
                const hybridName = `${CREATURE_TYPES[parentTypes[0]].name} √ó ${CREATURE_TYPES[parentTypes[1]].name}`;
                if (!this.collection.find(c => c.name === hybridName)) {
                    this.collection.push({
                        type: 'HYBRID',
                        name: hybridName,
                        color: hybrid.color,
                        discoveredAt: Date.now(),
                        isHybrid: true,
                        parents: parentTypes
                    });
                }

                this.showNotification('Hybrid Born!', `Hearts synchronized! Created: ${hybridName}`);
                this.updateCollectionDisplay();
            }

            updateUI() {
                document.getElementById('my-creature-count').textContent = this.myCreatures.length;
                document.getElementById('hybrid-count').textContent = this.hybridCreatures.length;
                document.getElementById('total-creatures').textContent = this.creatures.length;
                document.getElementById('player-count').textContent = this.peers.size + 1;
            }

            updateCollectionDisplay() {
                const container = document.getElementById('collection-panel');
                container.innerHTML = '';

                this.collection.forEach(entry => {
                    const div = document.createElement('div');
                    div.className = 'creature-entry';
                    div.innerHTML = `
                        <div class="creature-dot" style="background: radial-gradient(circle, rgba(${entry.color.r * 255}, ${entry.color.g * 255}, ${entry.color.b * 255}, 0.9) 0%, transparent 70%);"></div>
                        <span class="creature-name">${entry.name}</span>
                        <span class="creature-type">${entry.isHybrid ? 'Hybrid' : 'Species'}</span>
                    `;
                    container.appendChild(div);
                });
            }

            showNotification(title, text) {
                const notification = document.getElementById('notification');
                notification.querySelector('.notification-title').textContent = title;
                notification.querySelector('.notification-text').textContent = text;
                notification.classList.add('visible');

                setTimeout(() => {
                    notification.classList.remove('visible');
                }, 3000);
            }

            // ===== DATA PERSISTENCE =====

            exportData() {
                const data = {
                    version: '1.0',
                    timestamp: Date.now(),
                    collection: this.collection,
                    stats: {
                        totalCreaturesSpawned: this.myCreatures.length,
                        hybridsCreated: this.hybridCreatures.length
                    }
                };

                const json = JSON.stringify(data, null, 2);

                this.showModal('Export Collection', `
                    <p style="margin-bottom: 15px; color: #80ffe0;">Your creature collection data:</p>
                    <textarea readonly>${json}</textarea>
                `);
            }

            showImportModal() {
                this.showModal('Import Collection', `
                    <p style="margin-bottom: 15px; color: #80ffe0;">Paste your collection JSON:</p>
                    <textarea id="import-data" placeholder="Paste JSON here..."></textarea>
                `, () => {
                    const data = document.getElementById('import-data').value;
                    this.importData(data);
                });
            }

            importData(jsonStr) {
                try {
                    const data = JSON.parse(jsonStr);

                    if (data.collection) {
                        this.collection = data.collection;
                        this.updateCollectionDisplay();
                        this.hideModal();
                        this.showNotification('Imported!', `Loaded ${this.collection.length} species`);
                    }
                } catch (err) {
                    alert('Invalid JSON format');
                }
            }

            showModal(title, bodyHTML, actionCallback = null) {
                document.getElementById('modal-title').textContent = title;
                document.getElementById('modal-body').innerHTML = bodyHTML;
                document.getElementById('modal-overlay').classList.add('visible');

                const actionBtn = document.getElementById('modal-action');
                if (actionCallback) {
                    actionBtn.style.display = 'block';
                    actionBtn.textContent = 'Import';
                    actionBtn.onclick = actionCallback;
                } else {
                    actionBtn.style.display = 'none';
                }
            }

            hideModal() {
                document.getElementById('modal-overlay').classList.remove('visible');
            }

            saveState() {
                const state = {
                    collection: this.collection
                };
                localStorage.setItem('pulse_garden', JSON.stringify(state));
            }

            loadState() {
                const saved = localStorage.getItem('pulse_garden');
                if (saved) {
                    try {
                        const state = JSON.parse(saved);
                        this.collection = state.collection || [];
                        this.updateCollectionDisplay();
                    } catch (e) {
                        console.error('Failed to load state:', e);
                    }
                }
            }
        }

        // ===== INITIALIZE =====
        let game = null;

        window.addEventListener('load', () => {
            game = new PulseGarden();
        });

        window.addEventListener('beforeunload', () => {
            if (game) {
                game.saveState();
                game.heartDetector.stop();
            }
        });
    </script>
</body>
</html>
