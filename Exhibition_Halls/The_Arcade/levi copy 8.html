<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>LEVIATHAN: OMNIVERSE</title>
    <style>
        /* System fonts - local-first compliant, no external dependencies */
        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; }

        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, system-ui, Roboto, sans-serif;
            background: #000;
            color: #fff;
            touch-action: none;
        }

        #container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }

        /* UI OVERLAY */
        .ui-layer {
            position: fixed;
            pointer-events: none;
            width: 100%;
            height: 100%;
            z-index: 10;
        }

        /* GALAXY HUD */
        .hud-top {
            position: absolute;
            top: 0; left: 0; right: 0;
            background: linear-gradient(to bottom, rgba(0,10,20,0.95), transparent);
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            border-bottom: 1px solid rgba(0, 255, 255, 0.1);
            pointer-events: auto;
            flex-wrap: wrap;
            gap: 10px;
        }

        .game-title {
            font-family: Georgia, 'Times New Roman', serif;
            font-size: clamp(20px, 4vw, 32px);
            color: #00ffff;
            text-shadow: 0 0 10px rgba(0,255,255,0.5);
            letter-spacing: 4px;
            font-weight: bold;
        }

        .subtitle {
            color: #666;
            font-size: clamp(10px, 2vw, 12px);
        }

        .stats-box {
            display: flex;
            gap: 15px;
            text-align: right;
            flex-wrap: wrap;
        }

        .stat-entry {
            display: flex;
            flex-direction: column;
        }
        .stat-val { font-size: clamp(14px, 3vw, 20px); color: #00ff00; font-weight: bold; }
        .stat-lbl { font-size: clamp(8px, 1.5vw, 10px); color: #666; text-transform: uppercase; }

        /* Data Controls - Import/Export */
        .data-controls {
            position: fixed;
            top: 8px;
            left: 220px;
            right: 180px;
            z-index: 1000;
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            pointer-events: auto;
            justify-content: center;
            align-items: flex-start;
        }

        .data-controls button {
            background: rgba(0, 255, 255, 0.15);
            border: 1px solid #0ff;
            color: #0ff;
            padding: 5px 10px;
            font-size: 11px;
            cursor: pointer;
            border-radius: 4px;
            font-family: inherit;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .data-controls button:hover {
            background: rgba(0, 255, 255, 0.3);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            transform: translateY(-1px);
        }

        /* v5.7: Menu toggle for dropdown */
        .data-controls .menu-toggle {
            background: rgba(255, 255, 255, 0.15) !important;
            border: 1px solid #fff !important;
            color: #fff !important;
        }

        .data-controls .menu-toggle:hover {
            background: rgba(255, 255, 255, 0.3) !important;
        }

        .data-controls .menu-secondary {
            display: none;
            position: fixed;
            top: 40px;
            right: 180px;
            background: rgba(10, 10, 30, 0.98);
            border: 1px solid #0ff;
            border-radius: 8px;
            padding: 8px;
            flex-direction: column;
            gap: 5px;
            min-width: 130px;
            box-shadow: 0 4px 20px rgba(0, 255, 255, 0.3);
            z-index: 1001;
        }

        .data-controls .menu-secondary.show {
            display: flex;
        }

        .data-controls .menu-secondary button {
            width: 100%;
            text-align: left;
            padding: 8px 12px;
        }

        /* v5.7: AI Companion Settings Modal - Tabbed Interface */
        .ai-settings-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 10000;
            justify-content: center;
            align-items: center;
        }
        .ai-settings-modal.active { display: flex; }
        .ai-settings-content {
            background: linear-gradient(135deg, #1a1a2e 0%, #0d0d1a 100%);
            border: 2px solid #7b2cbf;
            border-radius: 20px;
            width: 94%;
            max-width: 580px;
            max-height: 90vh;
            overflow: hidden;
            box-shadow: 0 0 60px rgba(123, 44, 191, 0.5), inset 0 0 100px rgba(123, 44, 191, 0.1);
            position: relative;
        }
        .ai-settings-content::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(123, 44, 191, 0.1) 0%, transparent 50%);
            animation: ai-glow-rotate 20s linear infinite;
            pointer-events: none;
        }
        @keyframes ai-glow-rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        .ai-settings-header {
            padding: 25px 25px 20px;
            text-align: center;
            position: relative;
            z-index: 1;
        }
        .ai-settings-header h2 {
            margin: 0;
            font-size: 28px;
            font-weight: bold;
            font-style: italic;
            background: linear-gradient(135deg, #06ffa5, #7b2cbf);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .ai-settings-close {
            position: absolute;
            top: 20px;
            right: 20px;
            background: none;
            border: none;
            color: #fff;
            font-size: 28px;
            cursor: pointer;
            opacity: 0.7;
            transition: all 0.2s;
            z-index: 2;
        }
        .ai-settings-close:hover { opacity: 1; transform: scale(1.1); }

        /* Tabs */
        .ai-settings-tabs {
            display: flex;
            justify-content: center;
            gap: 8px;
            padding: 0 20px 20px;
            position: relative;
            z-index: 1;
        }
        .ai-settings-tab {
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            color: #888;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .ai-settings-tab:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
        }
        .ai-settings-tab.active {
            background: linear-gradient(135deg, #06ffa5, #00cc88);
            border-color: #06ffa5;
            color: #000;
            font-weight: bold;
        }

        /* Tab Content */
        .ai-settings-body {
            padding: 0 25px 20px;
            max-height: calc(90vh - 250px);
            overflow-y: auto;
            position: relative;
            z-index: 1;
        }
        .ai-tab-content {
            display: none;
        }
        .ai-tab-content.active {
            display: block;
            animation: fadeIn 0.3s ease;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Sections */
        .ai-section {
            margin-bottom: 20px;
            padding: 20px;
            background: rgba(30, 30, 50, 0.6);
            border-radius: 12px;
            border: 1px solid rgba(123, 44, 191, 0.2);
        }
        .ai-section h3 {
            margin: 0 0 15px 0;
            font-size: 16px;
            font-weight: bold;
            color: #06ffa5;
        }

        /* Form Elements */
        .ai-form-group {
            margin-bottom: 15px;
        }
        .ai-form-group label {
            display: block;
            font-size: 12px;
            color: #aaa;
            margin-bottom: 6px;
        }
        .ai-input {
            width: 100%;
            padding: 12px 15px;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            color: #fff;
            font-size: 14px;
            font-family: inherit;
            transition: all 0.2s;
            box-sizing: border-box;
        }
        .ai-input:focus {
            outline: none;
            border-color: #06ffa5;
            box-shadow: 0 0 10px rgba(6, 255, 165, 0.2);
        }
        .ai-input::placeholder {
            color: #555;
        }
        .ai-select {
            width: 100%;
            padding: 12px 15px;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            color: #fff;
            font-size: 14px;
            font-family: inherit;
            cursor: pointer;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='%23888' viewBox='0 0 16 16'%3E%3Cpath d='M8 11L3 6h10l-5 5z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 15px center;
        }
        .ai-select:focus {
            outline: none;
            border-color: #06ffa5;
        }

        /* Toggle Switch */
        .ai-toggle-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
        }
        .ai-toggle-label {
            font-size: 14px;
            color: #ddd;
        }
        .ai-toggle {
            position: relative;
            width: 50px;
            height: 26px;
        }
        .ai-toggle input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .ai-toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 26px;
            transition: 0.3s;
        }
        .ai-toggle-slider::before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 3px;
            bottom: 3px;
            background: #fff;
            border-radius: 50%;
            transition: 0.3s;
        }
        .ai-toggle input:checked + .ai-toggle-slider {
            background: linear-gradient(135deg, #06ffa5, #00cc88);
        }
        .ai-toggle input:checked + .ai-toggle-slider::before {
            transform: translateX(24px);
        }

        /* Endpoint Cards */
        .ai-endpoint-card {
            padding: 15px;
            background: rgba(6, 255, 165, 0.05);
            border: 1px solid rgba(6, 255, 165, 0.2);
            border-radius: 10px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .ai-endpoint-card:hover {
            background: rgba(6, 255, 165, 0.1);
            border-color: rgba(6, 255, 165, 0.4);
        }
        .ai-endpoint-card.active {
            background: rgba(6, 255, 165, 0.15);
            border-color: #06ffa5;
            box-shadow: 0 0 20px rgba(6, 255, 165, 0.2);
        }
        .ai-endpoint-name {
            font-weight: bold;
            color: #06ffa5;
            font-size: 14px;
            margin-bottom: 4px;
        }
        .ai-endpoint-url {
            font-size: 11px;
            color: #666;
            word-break: break-all;
        }
        .ai-endpoint-badge {
            display: inline-block;
            padding: 3px 10px;
            border-radius: 12px;
            font-size: 10px;
            margin-top: 8px;
            font-weight: bold;
        }
        .ai-endpoint-badge.active {
            background: rgba(6, 255, 165, 0.2);
            color: #06ffa5;
        }
        .ai-endpoint-badge.inactive {
            background: rgba(255, 255, 255, 0.1);
            color: #888;
        }

        /* Color Picker Row */
        .ai-color-row {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .ai-color-preview {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }
        .ai-color-input {
            flex: 1;
        }

        /* Actions Footer */
        .ai-settings-footer {
            display: flex;
            gap: 15px;
            padding: 20px 25px;
            border-top: 1px solid rgba(123, 44, 191, 0.3);
            position: relative;
            z-index: 1;
        }
        .ai-btn {
            flex: 1;
            padding: 14px 20px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.2s;
            font-family: inherit;
        }
        .ai-btn-save {
            background: linear-gradient(135deg, #06ffa5, #00cc88);
            color: #000;
        }
        .ai-btn-save:hover {
            box-shadow: 0 0 25px rgba(6, 255, 165, 0.5);
            transform: translateY(-2px);
        }
        .ai-btn-cancel {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #aaa;
        }
        .ai-btn-cancel:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
        }
        .ai-btn-import {
            background: linear-gradient(135deg, #7b2cbf, #3a0ca3);
            color: #fff;
        }
        .ai-btn-import:hover {
            box-shadow: 0 0 20px rgba(123, 44, 191, 0.5);
        }

        /* Status Message */
        .ai-status-msg {
            text-align: center;
            padding: 10px;
            font-size: 12px;
            color: #888;
            margin-top: 10px;
        }
        .ai-status-msg.success { color: #06ffa5; }
        .ai-status-msg.error { color: #f44; }

        /* Player Health Bar */
        .player-health-bar {
            position: fixed;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            width: clamp(150px, 30vw, 250px);
            height: 20px;
            background: rgba(0,0,0,0.7);
            border: 2px solid #f44;
            border-radius: 10px;
            overflow: hidden;
            display: none;
            pointer-events: none;
        }

        .player-health-fill {
            height: 100%;
            background: linear-gradient(to right, #f44, #ff6666);
            width: 100%;
            transition: width 0.3s;
        }

        .player-health-text {
            position: absolute;
            width: 100%;
            text-align: center;
            font-size: 11px;
            font-weight: bold;
            line-height: 20px;
            text-shadow: 1px 1px 2px #000;
        }

        /* RPG INTERFACE (Bottom) */
        .rpg-ui {
            position: absolute;
            bottom: 0; left: 0; right: 0;
            background: linear-gradient(to top, rgba(5,5,5,0.95), transparent);
            display: none;
            padding: 10px;
            pointer-events: none;
            flex-wrap: wrap;
            justify-content: space-between;
            align-items: flex-end;
            gap: 10px;
        }

        .inventory-panel {
            background: rgba(10, 15, 20, 0.9);
            border: 2px solid #445;
            border-radius: 8px;
            padding: 10px;
            pointer-events: auto;
            width: clamp(200px, 40vw, 300px);
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
        }

        .panel-title {
            color: #fb0;
            font-family: Georgia, serif;
            border-bottom: 1px solid #445;
            margin-bottom: 10px;
            padding-bottom: 5px;
            font-size: clamp(12px, 2vw, 14px);
        }

        .inv-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 6px;
        }

        .inv-slot {
            background: #1a1a1a;
            border: 1px solid #333;
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(14px, 3vw, 20px);
            position: relative;
            cursor: pointer;
            transition: all 0.1s;
            min-width: 35px;
            min-height: 35px;
        }

        .inv-slot:hover { border-color: #fb0; background: #2a2a2a; }
        .inv-count {
            position: absolute;
            bottom: 2px; right: 4px;
            font-size: clamp(9px, 1.5vw, 12px);
            color: #fff;
            font-weight: bold;
            text-shadow: 1px 1px 1px #000;
        }

        /* v5.1: Equipment Slots */
        .equip-slot {
            background: #1a1a2a;
            border: 2px solid #334;
            border-radius: 6px;
            padding: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            transition: all 0.2s;
        }
        .equip-slot:hover { border-color: #fb0; background: #2a2a3a; }
        .equip-slot.equipped { border-color: #4a4; background: rgba(68, 170, 68, 0.15); }
        .equip-icon { font-size: 20px; margin-bottom: 4px; }
        .equip-name { font-size: 10px; color: #aaa; text-align: center; }
        .equip-slot.equipped .equip-name { color: #4f4; }

        .player-stats {
            pointer-events: auto;
            background: rgba(10, 15, 20, 0.9);
            border: 2px solid #445;
            border-radius: 8px;
            padding: 12px;
            width: clamp(180px, 35vw, 250px);
        }

        .xp-bar-container {
            margin-bottom: 6px;
        }
        .xp-label { font-size: clamp(10px, 1.5vw, 12px); color: #aaa; display: flex; justify-content: space-between; }
        .xp-bar-bg { height: 6px; background: #222; border-radius: 3px; overflow: hidden; margin-top: 3px; }
        .xp-bar-fill { height: 100%; width: 0%; transition: width 0.3s; }

        /* Crafting Panel */
        .crafting-panel {
            background: rgba(10, 15, 20, 0.9);
            border: 2px solid #445;
            border-radius: 8px;
            padding: 10px;
            pointer-events: auto;
            width: clamp(150px, 25vw, 200px);
        }

        .craft-btn {
            display: block;
            width: 100%;
            background: #333;
            border: 1px solid #555;
            color: #fff;
            padding: 8px;
            margin-bottom: 5px;
            cursor: pointer;
            border-radius: 4px;
            font-size: clamp(10px, 1.5vw, 12px);
            transition: all 0.2s;
        }

        .craft-btn:hover:not(:disabled) { background: #555; border-color: #fb0; }
        .craft-btn:disabled { opacity: 0.4; cursor: not-allowed; }

        /* Action Buttons */
        .action-btn {
            background: #fb0;
            color: #000;
            border: none;
            padding: 8px 16px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 4px;
            font-family: Georgia, serif;
            pointer-events: auto;
            font-size: clamp(11px, 2vw, 14px);
        }
        .action-btn:hover { background: #fff; box-shadow: 0 0 15px #fb0; }

        /* Floating Text */
        .floater {
            position: absolute;
            font-weight: bold;
            text-shadow: 0 0 4px #000;
            pointer-events: none;
            animation: floatUp 1.5s forwards;
            font-size: clamp(12px, 2vw, 16px);
        }

        @keyframes floatUp {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-50px) scale(1.2); opacity: 0; }
        }

        /* Tooltip context menu */
        .context-tooltip {
            position: absolute;
            background: rgba(0,0,0,0.9);
            border: 1px solid #0ff;
            padding: 8px 12px;
            color: #0ff;
            font-size: clamp(10px, 1.5vw, 12px);
            pointer-events: none;
            display: none;
            z-index: 100;
            border-radius: 4px;
            max-width: 200px;
        }

        .loading {
            position: fixed; top:0; left:0; right:0; bottom:0;
            background: #000; color: #0f0;
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            z-index: 999;
            font-family: Georgia, serif;
        }

        .loading-text {
            font-size: clamp(18px, 4vw, 24px);
            margin-bottom: 20px;
        }

        .loading-bar {
            width: clamp(200px, 50vw, 300px);
            height: 4px;
            background: #222;
            border-radius: 2px;
            overflow: hidden;
        }

        .loading-progress {
            height: 100%;
            background: #0f0;
            animation: loadPulse 1s ease-in-out infinite;
        }

        @keyframes loadPulse {
            0%, 100% { width: 20%; margin-left: 0; }
            50% { width: 40%; margin-left: 60%; }
        }

        /* Minimap */
        .minimap {
            position: fixed;
            bottom: 200px;
            right: 10px;
            width: clamp(80px, 15vw, 120px);
            height: clamp(80px, 15vw, 120px);
            background: rgba(0,0,0,0.7);
            border: 2px solid #445;
            border-radius: 8px;
            display: none;
            pointer-events: auto;
            overflow: hidden;
        }

        .minimap-canvas {
            width: 100%;
            height: 100%;
        }

        /* v4.8: Combat Abilities (v4.9: Enhanced styling) */
        @keyframes ability-ready-pulse {
            0%, 100% { box-shadow: 0 0 5px rgba(0, 255, 255, 0.3); }
            50% { box-shadow: 0 0 15px rgba(0, 255, 255, 0.6); }
        }
        @keyframes berserk-pulse {
            0%, 100% { box-shadow: 0 0 10px rgba(255, 68, 0, 0.5); }
            50% { box-shadow: 0 0 25px rgba(255, 68, 0, 0.9); }
        }
        .ability-slot {
            width: 50px;
            height: 50px;
            background: rgba(40, 40, 60, 0.9);
            border: 2px solid #555;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            transition: all 0.2s;
        }
        .ability-slot:hover:not(.locked):not(.on-cooldown) {
            border-color: #0ff;
            transform: scale(1.1);
        }
        .ability-slot.locked {
            opacity: 0.35;
            cursor: not-allowed;
            filter: grayscale(0.8);
        }
        .ability-slot.locked::after {
            content: 'ðŸ”’';
            position: absolute;
            font-size: 12px;
            top: 2px;
            right: 2px;
        }
        .ability-slot.on-cooldown {
            border-color: #444;
            opacity: 0.7;
        }
        .ability-slot:not(.locked):not(.on-cooldown) {
            animation: ability-ready-pulse 2s infinite;
            border-color: #0aa;
        }
        .ability-slot.active-buff {
            border-color: #ff8800;
            box-shadow: 0 0 10px #ff8800;
            animation: none;
        }
        .ability-slot.active-buff[id="ability-c"] {
            animation: berserk-pulse 0.5s infinite;
        }
        .ability-icon {
            font-size: 20px;
        }
        .ability-key {
            font-size: 10px;
            color: #888;
            margin-top: 2px;
        }
        .ability-cooldown {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 0;
            background: rgba(0, 0, 0, 0.7);
            transition: height 0.1s linear;
            border-radius: 0 0 6px 6px;
        }

        /* Touch Controls */
        .touch-controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            display: none;
            pointer-events: auto;
            gap: 10px;
        }

        .touch-btn {
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            color: #fff;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }

        .touch-btn:active {
            background: rgba(255, 255, 255, 0.4);
        }

        /* v4.3: Virtual Joystick */
        .virtual-joystick {
            position: fixed;
            bottom: 30px;
            left: 30px;
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: none;
            touch-action: none;
        }

        .joystick-knob {
            position: absolute;
            width: 50px;
            height: 50px;
            background: rgba(0, 255, 255, 0.5);
            border: 2px solid rgba(0, 255, 255, 0.8);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        .touch-action-btn {
            position: fixed;
            bottom: 50px;
            right: 30px;
            width: 70px;
            height: 70px;
            background: rgba(255, 100, 0, 0.4);
            border: 3px solid rgba(255, 150, 0, 0.7);
            border-radius: 50%;
            color: #fff;
            font-size: 24px;
            font-weight: bold;
            display: none;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }

        .touch-action-btn:active {
            background: rgba(255, 150, 0, 0.7);
        }

        /* v4.5: Mobile Dodge Button */
        .touch-dodge-btn {
            position: fixed;
            bottom: 140px;
            right: 30px;
            width: 60px;
            height: 60px;
            background: rgba(100, 200, 255, 0.4);
            border: 3px solid rgba(150, 220, 255, 0.7);
            border-radius: 50%;
            color: #fff;
            font-size: 18px;
            font-weight: bold;
            display: none;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }

        .touch-dodge-btn:active {
            background: rgba(150, 220, 255, 0.7);
        }

        /* Notification Toast */
        .notification {
            position: fixed;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 100, 0, 0.9);
            border: 1px solid #0f0;
            padding: 10px 20px;
            border-radius: 4px;
            color: #0f0;
            font-size: 14px;
            z-index: 500;
            animation: notifySlide 3s forwards;
            pointer-events: none;
        }

        @keyframes notifySlide {
            0% { opacity: 0; transform: translateX(-50%) translateY(-20px); }
            10% { opacity: 1; transform: translateX(-50%) translateY(0); }
            80% { opacity: 1; }
            100% { opacity: 0; }
        }

        /* Achievement Popup */
        .achievement-popup {
            position: fixed;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(30, 30, 50, 0.95), rgba(50, 40, 80, 0.95));
            border: 2px solid #ffd700;
            border-radius: 12px;
            padding: 15px 25px;
            display: flex;
            align-items: center;
            gap: 15px;
            z-index: 600;
            animation: achievementSlide 4s forwards;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.4);
        }

        .achievement-popup .ach-icon { font-size: 36px; }
        .achievement-popup .ach-title { color: #ffd700; font-size: 11px; text-transform: uppercase; letter-spacing: 2px; }
        .achievement-popup .ach-name { color: #fff; font-size: 16px; font-weight: bold; margin: 3px 0; }
        .achievement-popup .ach-desc { color: #aaa; font-size: 12px; }

        @keyframes achievementSlide {
            0% { opacity: 0; transform: translateX(-50%) translateY(-30px); }
            10% { opacity: 1; transform: translateX(-50%) translateY(0); }
            85% { opacity: 1; transform: translateX(-50%) translateY(0); }
            100% { opacity: 0; transform: translateX(-50%) translateY(-20px); }
        }

        /* Daily Challenge Box */
        .daily-challenge-box {
            position: fixed;
            top: 120px;
            right: 10px;
            background: rgba(20, 20, 40, 0.9);
            border: 1px solid #ffd700;
            border-radius: 8px;
            padding: 12px 15px;
            width: 180px;
            z-index: 100;
        }

        .daily-challenge-box.completed {
            border-color: #44ff44;
            background: rgba(20, 40, 20, 0.9);
        }

        .daily-title { color: #ffd700; font-size: 11px; text-transform: uppercase; margin-bottom: 8px; }
        .daily-desc { color: #fff; font-size: 12px; margin-bottom: 8px; }
        .daily-progress-bar { background: #333; border-radius: 4px; height: 8px; overflow: hidden; }
        .daily-progress-fill { background: linear-gradient(90deg, #ffd700, #ffaa00); height: 100%; transition: width 0.3s; }
        .daily-progress-text { color: #aaa; font-size: 10px; margin-top: 5px; }
        .daily-streak { color: #ff8800; font-size: 10px; margin-top: 3px; }

        /* Stats Modal */
        .stats-section { margin-bottom: 20px; }
        .stat-row { display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px solid rgba(255,255,255,0.1); color: #ccc; font-size: 13px; }
        .stat-row span:last-child { color: #0ff; font-weight: bold; }

        .achievements-grid { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 10px; }
        .ach-item {
            display: flex; align-items: center; gap: 6px;
            background: rgba(40,40,60,0.8);
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 11px;
            color: #666;
        }
        .ach-item.unlocked { color: #fff; background: rgba(50, 50, 80, 0.9); border: 1px solid #ffd700; }
        .ach-item.locked .ach-badge { filter: grayscale(1); opacity: 0.4; }
        .ach-badge { font-size: 16px; }

        /* Settings Modal */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            pointer-events: auto;
        }

        .modal-content {
            background: #1a1a2e;
            border: 2px solid #0ff;
            border-radius: 12px;
            padding: 25px;
            max-width: 400px;
            width: 90%;
        }

        .modal-title {
            color: #0ff;
            font-size: 20px;
            margin-bottom: 20px;
            font-family: Georgia, serif;
        }

        .modal-close {
            float: right;
            background: none;
            border: none;
            color: #fff;
            font-size: 24px;
            cursor: pointer;
        }

        /* v4.9: Collection Codex Styles */
        .codex-tab {
            background: rgba(40, 40, 60, 0.8);
            border: 1px solid #444;
            color: #aaa;
            padding: 8px 14px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }
        .codex-tab:hover { border-color: #0ff; color: #fff; }
        .codex-tab.active {
            background: linear-gradient(135deg, #0aa, #088);
            border-color: #0ff;
            color: #fff;
        }
        .codex-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 10px;
        }
        .codex-entry {
            background: rgba(30, 30, 50, 0.9);
            border: 1px solid #333;
            border-radius: 8px;
            padding: 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }
        .codex-entry:hover { border-color: #0ff; transform: translateY(-2px); }
        .codex-entry.discovered { border-color: #4a4; }
        .codex-entry.undiscovered {
            filter: grayscale(1);
            opacity: 0.5;
        }
        .codex-entry .entry-icon {
            font-size: 28px;
            margin-bottom: 5px;
            display: block;
        }
        .codex-entry .entry-name {
            font-size: 11px;
            color: #ccc;
            display: block;
        }
        .codex-entry.undiscovered .entry-name { color: #666; }
        .codex-entry .entry-count {
            font-size: 10px;
            color: #888;
            margin-top: 3px;
        }

        /* v5.0: Quest System Styles */
        .quest-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .quest-item {
            background: rgba(30, 30, 50, 0.9);
            border: 1px solid #444;
            border-radius: 8px;
            padding: 12px;
            transition: all 0.2s;
        }
        .quest-item:hover { border-color: #ff8c00; }
        .quest-item.completed {
            border-color: #4a4;
            background: rgba(40, 80, 40, 0.3);
        }
        .quest-item.claimed {
            opacity: 0.5;
            border-color: #333;
        }
        .quest-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        .quest-title {
            font-size: 14px;
            color: #fff;
            font-weight: bold;
        }
        .quest-reward {
            font-size: 12px;
            color: #ffd700;
        }
        .quest-desc {
            font-size: 12px;
            color: #aaa;
            margin-bottom: 8px;
        }
        .quest-progress-bar {
            height: 6px;
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
            overflow: hidden;
        }
        .quest-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff8c00, #ffd700);
            transition: width 0.3s;
        }
        .quest-progress-text {
            font-size: 11px;
            color: #888;
            margin-top: 4px;
            text-align: right;
        }
        .quest-claim-btn {
            margin-top: 8px;
            padding: 6px 12px;
            background: linear-gradient(135deg, #4a4, #2a2);
            border: none;
            border-radius: 4px;
            color: #fff;
            cursor: pointer;
            font-size: 12px;
            width: 100%;
        }
        .quest-claim-btn:hover { background: linear-gradient(135deg, #5b5, #3b3); }
        .quest-claim-btn:disabled {
            background: #333;
            cursor: not-allowed;
            opacity: 0.5;
        }

        /* v4.6: Settings Panel Styles */
        .settings-section {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .settings-section:last-child { border-bottom: none; }
        .settings-section h4 {
            margin: 0 0 12px 0;
            font-size: 14px;
        }
        .setting-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            font-size: 13px;
            color: #ccc;
        }
        .setting-row input[type="range"] {
            width: 100px;
            margin: 0 10px;
            accent-color: #0ff;
        }
        .setting-row select {
            background: #222;
            border: 1px solid #445;
            color: #fff;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
        }
        .toggle-btn {
            background: rgba(0,100,0,0.5);
            border: 1px solid #0f0;
            color: #0f0;
            padding: 4px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            min-width: 50px;
        }
        .toggle-btn.off {
            background: rgba(100,0,0,0.5);
            border-color: #f44;
            color: #f44;
        }

        /* v5.3: Mastery System Styles */
        .mastery-card {
            background: rgba(30, 30, 50, 0.9);
            border: 1px solid #444;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
            transition: all 0.2s;
        }
        .mastery-card:hover { border-color: #ffd700; }
        .mastery-card.mastered { border-color: #ffd700; background: rgba(50, 45, 30, 0.9); }
        .mastery-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
        .mastery-skill { font-size: 16px; font-weight: bold; }
        .mastery-level { color: #ffd700; font-size: 14px; }
        .mastery-progress-bar { height: 8px; background: rgba(255,255,255,0.1); border-radius: 4px; overflow: hidden; margin-bottom: 8px; }
        .mastery-progress-fill { height: 100%; background: linear-gradient(90deg, #8844ff, #ff44ff); transition: width 0.3s; }
        .mastery-milestones { display: flex; gap: 8px; flex-wrap: wrap; }
        .milestone { padding: 4px 8px; border-radius: 4px; font-size: 11px; background: rgba(0,0,0,0.3); border: 1px solid #333; }
        .milestone.achieved { background: rgba(255, 215, 0, 0.2); border-color: #ffd700; color: #ffd700; }
        .milestone.next { background: rgba(136, 68, 255, 0.2); border-color: #8844ff; color: #aaf; }

        /* v5.3: Realm Portal Styles */
        .portal-card {
            background: linear-gradient(135deg, rgba(40, 20, 60, 0.95), rgba(20, 40, 60, 0.95));
            border: 2px solid #8844ff;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 12px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .portal-card:hover { transform: translateY(-2px); box-shadow: 0 5px 20px rgba(136, 68, 255, 0.4); }
        .portal-card.locked { opacity: 0.5; cursor: not-allowed; filter: grayscale(0.5); }
        .portal-card.active { border-color: #ff4400; animation: portal-pulse 1.5s infinite; }
        @keyframes portal-pulse {
            0%, 100% { box-shadow: 0 0 10px rgba(255, 68, 0, 0.3); }
            50% { box-shadow: 0 0 25px rgba(255, 68, 0, 0.6); }
        }
        .portal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .portal-name { font-size: 18px; font-weight: bold; color: #fff; }
        .portal-tier { padding: 4px 10px; border-radius: 12px; font-size: 11px; background: linear-gradient(135deg, #8844ff, #4488ff); }
        .portal-desc { color: #aaa; font-size: 12px; margin-bottom: 10px; }
        .portal-rewards { display: flex; gap: 10px; flex-wrap: wrap; }
        .portal-reward { padding: 4px 8px; background: rgba(0,0,0,0.3); border-radius: 4px; font-size: 11px; color: #adf; }
        .portal-requirement { color: #888; font-size: 11px; margin-top: 8px; }

        /* v5.3: Loot Rarity Styles */
        .rarity-common { color: #aaaaaa; }
        .rarity-uncommon { color: #44ff44; }
        .rarity-rare { color: #4488ff; }
        .rarity-epic { color: #aa44ff; }
        .rarity-legendary { color: #ff8800; text-shadow: 0 0 5px rgba(255, 136, 0, 0.5); }
        .rarity-mythic { color: #ff4488; text-shadow: 0 0 8px rgba(255, 68, 136, 0.6); animation: mythic-glow 2s infinite; }
        @keyframes mythic-glow {
            0%, 100% { text-shadow: 0 0 5px rgba(255, 68, 136, 0.4); }
            50% { text-shadow: 0 0 15px rgba(255, 68, 136, 0.8); }
        }
        .item-modifiers { font-size: 10px; color: #88ff88; margin-top: 4px; }
        .loot-drop-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 20, 40, 0.95);
            border: 2px solid #ffd700;
            border-radius: 12px;
            padding: 20px;
            z-index: 1000;
            min-width: 250px;
            text-align: center;
            animation: loot-appear 0.3s ease-out;
        }
        @keyframes loot-appear {
            0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        /* v5.4: Companion Evolution Styles */
        .evolution-card {
            background: linear-gradient(135deg, rgba(40, 30, 60, 0.95), rgba(60, 40, 80, 0.95));
            border: 2px solid #aa44ff;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 12px;
            transition: all 0.3s;
        }
        .evolution-card:hover { box-shadow: 0 0 20px rgba(170, 68, 255, 0.4); }
        .evolution-card.can-evolve { border-color: #ffd700; animation: evolve-pulse 1.5s infinite; }
        @keyframes evolve-pulse {
            0%, 100% { box-shadow: 0 0 10px rgba(255, 215, 0, 0.3); }
            50% { box-shadow: 0 0 25px rgba(255, 215, 0, 0.6); }
        }
        .evolution-header { display: flex; align-items: center; gap: 12px; margin-bottom: 10px; }
        .evolution-icon { font-size: 40px; }
        .evolution-info { flex: 1; }
        .evolution-name { font-size: 16px; font-weight: bold; color: #fff; }
        .evolution-stage { font-size: 12px; color: #aa88ff; }
        .evolution-bond { margin: 10px 0; }
        .bond-bar { height: 8px; background: rgba(255,255,255,0.1); border-radius: 4px; overflow: hidden; }
        .bond-fill { height: 100%; background: linear-gradient(90deg, #ff44aa, #aa44ff); transition: width 0.3s; }
        .evolution-abilities { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 8px; }
        .evolution-ability { padding: 4px 8px; background: rgba(0,0,0,0.3); border-radius: 4px; font-size: 11px; color: #adf; }
        .evolution-ability.locked { opacity: 0.4; }
        .evolve-btn {
            display: block; width: 100%; margin-top: 10px; padding: 10px;
            background: linear-gradient(135deg, #ffd700, #ff8800);
            border: none; border-radius: 6px; color: #000; font-weight: bold;
            cursor: pointer; font-size: 14px; transition: all 0.2s;
        }
        .evolve-btn:hover { transform: scale(1.02); box-shadow: 0 0 15px rgba(255, 215, 0, 0.5); }
        .evolve-btn:disabled { opacity: 0.4; cursor: not-allowed; transform: none; box-shadow: none; }

        /* v5.4: World Events Styles */
        .event-notification {
            position: fixed; top: 100px; left: 50%; transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(255, 100, 0, 0.95), rgba(200, 50, 0, 0.95));
            border: 2px solid #ffd700; border-radius: 12px; padding: 15px 25px;
            z-index: 1500; text-align: center; animation: event-slide 0.5s ease-out;
            box-shadow: 0 0 30px rgba(255, 136, 0, 0.5);
        }
        @keyframes event-slide {
            0% { transform: translateX(-50%) translateY(-50px); opacity: 0; }
            100% { transform: translateX(-50%) translateY(0); opacity: 1; }
        }
        .event-title { font-size: 18px; font-weight: bold; color: #fff; margin-bottom: 5px; }
        .event-desc { font-size: 12px; color: #ffd700; }
        .event-timer { font-size: 14px; color: #fff; margin-top: 8px; }
        .world-event-marker {
            position: absolute; pointer-events: none;
            animation: event-marker-pulse 1s infinite;
        }
        @keyframes event-marker-pulse {
            0%, 100% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.2); opacity: 1; }
        }
        .event-indicator {
            position: fixed; top: 130px; right: 10px;
            background: rgba(0,0,0,0.8); border: 2px solid #ff8800;
            border-radius: 8px; padding: 10px; z-index: 100;
            display: none; min-width: 150px;
        }
        .event-indicator.active { display: block; animation: event-pulse 2s infinite; }
        @keyframes event-pulse {
            0%, 100% { border-color: #ff8800; }
            50% { border-color: #ffd700; box-shadow: 0 0 15px rgba(255, 136, 0, 0.5); }
        }
        .event-indicator-icon { font-size: 24px; text-align: center; margin-bottom: 5px; }
        .event-indicator-name { font-size: 12px; color: #ffd700; text-align: center; }
        .event-indicator-time { font-size: 11px; color: #fff; text-align: center; margin-top: 4px; }
        .event-indicator-progress { height: 4px; background: rgba(255,255,255,0.2); border-radius: 2px; margin-top: 6px; overflow: hidden; }
        .event-indicator-fill { height: 100%; background: #ff8800; transition: width 0.5s; }

        /* v5.4: Achievement Showcase Styles */
        .showcase-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 10px; margin-top: 15px; }
        .showcase-badge {
            background: rgba(30, 30, 50, 0.9); border: 2px solid #333;
            border-radius: 8px; padding: 10px; text-align: center;
            cursor: pointer; transition: all 0.2s;
        }
        .showcase-badge:hover { border-color: #ffd700; transform: translateY(-2px); }
        .showcase-badge.earned { border-color: #4a4; background: rgba(68, 170, 68, 0.15); }
        .showcase-badge.rare { border-color: #4488ff; background: rgba(68, 136, 255, 0.15); }
        .showcase-badge.legendary { border-color: #ff8800; background: rgba(255, 136, 0, 0.15); animation: legendary-badge 2s infinite; }
        @keyframes legendary-badge {
            0%, 100% { box-shadow: 0 0 5px rgba(255, 136, 0, 0.3); }
            50% { box-shadow: 0 0 15px rgba(255, 136, 0, 0.6); }
        }
        .showcase-badge-icon { font-size: 28px; margin-bottom: 5px; }
        .showcase-badge-name { font-size: 10px; color: #aaa; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .showcase-badge.earned .showcase-badge-name { color: #4f4; }
        .achievement-points-display {
            text-align: center; padding: 15px; margin-bottom: 15px;
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.1), rgba(255, 136, 0, 0.1));
            border: 1px solid #ffd700; border-radius: 8px;
        }
        .ap-value { font-size: 32px; font-weight: bold; color: #ffd700; }
        .ap-label { font-size: 12px; color: #aaa; }
        .ap-milestone { margin-top: 10px; padding: 8px; background: rgba(0,0,0,0.3); border-radius: 4px; }
        .ap-milestone-progress { height: 6px; background: rgba(255,255,255,0.1); border-radius: 3px; overflow: hidden; margin-top: 5px; }
        .ap-milestone-fill { height: 100%; background: linear-gradient(90deg, #ffd700, #ff8800); }
        .cosmetic-effect { position: absolute; pointer-events: none; z-index: 5; }
        .cosmetic-aura { animation: aura-rotate 3s linear infinite; }
        @keyframes aura-rotate { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Mobile responsiveness */
        @media (max-width: 768px) {
            .hud-top {
                padding: 10px;
            }

            .rpg-ui {
                flex-direction: column;
                align-items: center;
                max-height: 50vh;
                overflow-y: auto;
            }

            .inventory-panel, .player-stats, .crafting-panel {
                width: 95%;
                max-width: none;
            }

            .touch-controls {
                display: flex;
            }

            .data-controls {
                top: auto;
                bottom: 60px;
                right: 10px;
                left: 10px;
                justify-content: center;
            }

            .data-controls button {
                padding: 4px 8px;
                font-size: 9px;
            }

            .data-controls .menu-secondary {
                top: auto;
                bottom: 40px;
                right: 10px;
                left: auto;
                transform: none;
            }

            .minimap {
                bottom: auto;
                top: 70px;
                right: 10px;
            }
        }

        @media (max-width: 480px) {
            .game-title {
                font-size: 18px;
                letter-spacing: 2px;
            }

            .inv-grid {
                grid-template-columns: repeat(4, 1fr);
            }

            .rpg-ui {
                padding: 5px;
            }

            .data-controls button {
                padding: 3px 6px;
                font-size: 8px;
            }
        }

        /* v5.6: Copilot Companion System Styles */
        .copilot-button {
            position: fixed;
            bottom: 100px;
            right: 20px;
            width: 60px;
            height: 60px;
            background: rgba(138, 43, 226, 0.3);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(138, 43, 226, 0.6);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 1002;
            pointer-events: auto;
            box-shadow: 0 0 20px rgba(138, 43, 226, 0.4);
            animation: copilot-pulse 3s infinite;
        }

        .copilot-button:hover {
            background: rgba(138, 43, 226, 0.5);
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(138, 43, 226, 0.6);
        }

        .copilot-button.active {
            background: rgba(6, 255, 165, 0.4);
            border-color: rgba(6, 255, 165, 0.8);
            box-shadow: 0 0 25px rgba(6, 255, 165, 0.5);
        }

        .copilot-button svg {
            width: 30px;
            height: 30px;
            color: white;
        }

        @keyframes copilot-pulse {
            0%, 100% { box-shadow: 0 0 20px rgba(138, 43, 226, 0.4); }
            50% { box-shadow: 0 0 30px rgba(138, 43, 226, 0.7); }
        }

        .copilot-chat-interface {
            position: fixed;
            bottom: 180px;
            right: 20px;
            width: 340px;
            height: 420px;
            background: rgba(10, 15, 25, 0.95);
            border: 2px solid rgba(138, 43, 226, 0.5);
            border-radius: 16px;
            display: none;
            flex-direction: column;
            z-index: 1003;
            pointer-events: auto;
            box-shadow: 0 0 40px rgba(138, 43, 226, 0.3);
            backdrop-filter: blur(10px);
        }

        .copilot-chat-interface.active {
            display: flex;
        }

        .copilot-chat-header {
            padding: 14px 16px;
            border-bottom: 1px solid rgba(138, 43, 226, 0.3);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.2), rgba(6, 255, 165, 0.1));
            border-radius: 14px 14px 0 0;
        }

        .copilot-chat-title {
            font-weight: bold;
            color: #06ffa5;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .copilot-chat-title::before {
            content: 'ðŸŒŸ';
        }

        .copilot-close-btn {
            background: none;
            border: none;
            color: #fff;
            font-size: 22px;
            cursor: pointer;
            opacity: 0.7;
            transition: all 0.2s;
            padding: 0 5px;
        }

        .copilot-close-btn:hover {
            opacity: 1;
            color: #ff6a88;
            transform: rotate(90deg);
        }

        .copilot-chat-messages {
            flex: 1;
            padding: 14px;
            overflow-y: auto;
            scroll-behavior: smooth;
        }

        .copilot-message {
            margin: 10px 0;
            padding: 10px 14px;
            border-radius: 12px;
            max-width: 85%;
            word-wrap: break-word;
            font-size: 13px;
            line-height: 1.5;
            animation: message-slide 0.3s ease;
        }

        @keyframes message-slide {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .copilot-message.user {
            background: rgba(138, 43, 226, 0.3);
            margin-left: auto;
            text-align: right;
            border: 1px solid rgba(138, 43, 226, 0.4);
        }

        .copilot-message.ai {
            background: rgba(6, 255, 165, 0.15);
            margin-right: auto;
            border: 1px solid rgba(6, 255, 165, 0.3);
        }

        .copilot-typing {
            padding: 10px 14px;
            border-radius: 12px;
            background: rgba(6, 255, 165, 0.15);
            display: flex;
            align-items: center;
            gap: 5px;
            width: fit-content;
            margin: 10px 0;
        }

        .copilot-typing-dot {
            width: 7px;
            height: 7px;
            background: rgba(6, 255, 165, 0.7);
            border-radius: 50%;
            animation: typing-pulse 1.4s infinite ease-in-out;
        }

        .copilot-typing-dot:nth-child(1) { animation-delay: -0.32s; }
        .copilot-typing-dot:nth-child(2) { animation-delay: -0.16s; }

        @keyframes typing-pulse {
            0%, 80%, 100% { transform: scale(0.7); opacity: 0.4; }
            40% { transform: scale(1); opacity: 1; }
        }

        .copilot-chat-input-container {
            padding: 12px;
            border-top: 1px solid rgba(138, 43, 226, 0.3);
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .copilot-chat-input {
            flex: 1;
            padding: 10px 14px;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(138, 43, 226, 0.4);
            border-radius: 20px;
            color: white;
            font-size: 13px;
            outline: none;
            transition: all 0.2s;
        }

        .copilot-chat-input:focus {
            border-color: #06ffa5;
            box-shadow: 0 0 10px rgba(6, 255, 165, 0.2);
        }

        .copilot-chat-send {
            background: linear-gradient(135deg, #8a2be2, #06ffa5);
            color: white;
            border: none;
            padding: 10px 18px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            font-size: 12px;
            transition: all 0.2s;
        }

        .copilot-chat-send:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(6, 255, 165, 0.4);
        }

        .copilot-quick-actions {
            display: flex;
            gap: 6px;
            padding: 0 12px 10px;
            flex-wrap: wrap;
        }

        .copilot-quick-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 14px;
            padding: 5px 10px;
            font-size: 11px;
            color: #aaa;
            cursor: pointer;
            transition: all 0.2s;
        }

        .copilot-quick-btn:hover {
            background: rgba(138, 43, 226, 0.3);
            border-color: rgba(138, 43, 226, 0.5);
            color: #fff;
        }

        .copilot-voice-btn {
            background: linear-gradient(135deg, #ff006e, #ff4488);
            border: none;
            width: 38px;
            height: 38px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .copilot-voice-btn:hover {
            transform: scale(1.1);
        }

        .copilot-voice-btn.recording {
            background: linear-gradient(135deg, #ff0000, #ff4444);
            animation: voice-record-pulse 1.5s infinite;
        }

        @keyframes voice-record-pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0.6); }
            70% { box-shadow: 0 0 0 12px rgba(255, 0, 0, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0); }
        }

        .copilot-voice-btn svg {
            width: 18px;
            height: 18px;
            color: white;
        }

        /* v5.9: Real-time transcription overlay */
        .stt-transcription-overlay {
            position: fixed;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #ff006e;
            border-radius: 16px;
            padding: 16px 24px;
            min-width: 300px;
            max-width: 500px;
            z-index: 10001;
            display: none;
            flex-direction: column;
            gap: 12px;
            box-shadow: 0 8px 32px rgba(255, 0, 110, 0.3);
        }

        .stt-transcription-overlay.active {
            display: flex;
        }

        .stt-header {
            display: flex;
            align-items: center;
            gap: 10px;
            color: #ff006e;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stt-header .recording-dot {
            width: 10px;
            height: 10px;
            background: #ff0000;
            border-radius: 50%;
            animation: stt-pulse 1s infinite;
        }

        @keyframes stt-pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(0.8); }
        }

        .stt-waveform {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 3px;
            height: 30px;
        }

        .stt-waveform .bar {
            width: 4px;
            background: linear-gradient(to top, #ff006e, #ff4488);
            border-radius: 2px;
            animation: stt-wave 0.5s ease-in-out infinite;
        }

        .stt-waveform .bar:nth-child(1) { animation-delay: 0s; }
        .stt-waveform .bar:nth-child(2) { animation-delay: 0.1s; }
        .stt-waveform .bar:nth-child(3) { animation-delay: 0.2s; }
        .stt-waveform .bar:nth-child(4) { animation-delay: 0.3s; }
        .stt-waveform .bar:nth-child(5) { animation-delay: 0.4s; }
        .stt-waveform .bar:nth-child(6) { animation-delay: 0.3s; }
        .stt-waveform .bar:nth-child(7) { animation-delay: 0.2s; }

        @keyframes stt-wave {
            0%, 100% { height: 8px; }
            50% { height: 25px; }
        }

        .stt-transcript-text {
            color: #fff;
            font-size: 16px;
            line-height: 1.5;
            min-height: 24px;
            text-align: center;
        }

        .stt-transcript-text.interim {
            color: #aaa;
            font-style: italic;
        }

        .stt-transcript-text.final {
            color: #06ffa5;
        }

        .stt-actions {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .stt-actions button {
            padding: 8px 20px;
            border-radius: 20px;
            border: none;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.2s;
        }

        .stt-actions .stt-send {
            background: linear-gradient(135deg, #06ffa5, #00cc88);
            color: #000;
        }

        .stt-actions .stt-send:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(6, 255, 165, 0.4);
        }

        .stt-actions .stt-cancel {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .stt-actions .stt-cancel:hover {
            background: rgba(255, 0, 0, 0.3);
            border-color: #ff4444;
        }

        .stt-actions .stt-retry {
            background: rgba(255, 0, 110, 0.3);
            color: #ff006e;
            border: 1px solid #ff006e;
        }

        .stt-actions .stt-retry:hover {
            background: rgba(255, 0, 110, 0.5);
        }

        /* Copilot Companion 3D Indicator */
        .copilot-3d-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.85);
            color: #06ffa5;
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 11px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            white-space: nowrap;
            z-index: 1010;
            border: 1px solid rgba(6, 255, 165, 0.4);
        }

        .copilot-3d-tooltip.visible {
            opacity: 1;
        }

        /* Voice Status Indicator */
        .copilot-voice-indicator {
            position: fixed;
            top: 80px;
            right: 20px;
            background: rgba(138, 43, 226, 0.9);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            display: none;
            align-items: center;
            gap: 8px;
            z-index: 1004;
            font-size: 12px;
            animation: fade-in 0.3s ease;
        }

        .copilot-voice-indicator.active {
            display: flex;
        }

        .copilot-voice-indicator svg {
            width: 16px;
            height: 16px;
            animation: voice-wave 1s infinite;
        }

        @keyframes voice-wave {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        @keyframes fade-in {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @media (max-width: 768px) {
            .copilot-chat-interface {
                width: calc(100% - 40px);
                right: 20px;
                left: 20px;
                height: 350px;
                bottom: 170px;
            }

            .copilot-button {
                width: 55px;
                height: 55px;
                bottom: 95px;
            }
        }
    </style>
</head>
<body>

    <div id="loading" class="loading">
        <div class="loading-text">INITIALIZING OMNIVERSE ENGINE...</div>
        <div class="loading-bar"><div class="loading-progress"></div></div>
    </div>

    <div id="container"></div>

    <div class="ui-layer">
        <!-- Data Controls - Two rows for better organization -->
        <div class="data-controls">
            <!-- Row 1: Game Features -->
            <button onclick="showStatsPanel()">Stats</button>
            <button onclick="openCodexModal()" style="background: linear-gradient(135deg, #ffd700, #ff8c00);">Codex</button>
            <button onclick="openQuestModal()" style="background: linear-gradient(135deg, #ff8c00, #ff4400);">Quests</button>
            <button onclick="openMasteryModal()" style="background: linear-gradient(135deg, #ff44ff, #8844ff);">Mastery</button>
            <button onclick="openPortalModal()" style="background: linear-gradient(135deg, #8844ff, #4488ff);">Portals</button>
            <button onclick="openEvolutionModal()" style="background: linear-gradient(135deg, #aa44ff, #ff44aa);">Evolve</button>
            <button onclick="showSettingsModal()">Settings</button>
            <!-- RAPPID prominently visible -->
            <button onclick="openRappidModal()" style="background: linear-gradient(135deg, #7b2cbf, #3a0ca3); border-color: #7b2cbf; color: #fff;">RAPPID</button>
            <!-- More menu for less used features -->
            <button class="menu-toggle" onclick="toggleSecondaryMenu()" style="background: rgba(255,255,255,0.1); border-color: #fff; color: #fff;">More â–¾</button>
            <!-- Secondary dropdown menu -->
            <div class="menu-secondary" id="menu-secondary">
                <button onclick="openShowcaseModal()" style="background: linear-gradient(135deg, #ffd700, #ffaa00);">Showcase</button>
                <button onclick="quickSave()">Save</button>
                <button onclick="exportData()">Export Game</button>
                <button onclick="document.getElementById('importFile').click()">Import Game</button>
            </div>
            <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importData(event)">
            <input type="file" id="rappidImportFile" accept=".json" style="display: none;" onchange="importRappidSettings(event)">
        </div>

        <div class="hud-top">
            <div>
                <div class="game-title">LEVIATHAN</div>
                <div class="subtitle">GALAXY SIMULATION v5.9</div>
            </div>

            <div id="galaxy-controls" class="stats-box">
                <div class="stat-entry">
                    <span class="stat-val" id="civ-count">0</span>
                    <span class="stat-lbl">Civilizations</span>
                </div>
                <div class="stat-entry">
                    <span class="stat-val" id="cycle-count">0</span>
                    <span class="stat-lbl">Cycle</span>
                </div>
                <div class="stat-entry">
                    <span class="stat-val" id="total-playtime">0:00</span>
                    <span class="stat-lbl">Playtime</span>
                </div>
            </div>

            <div id="world-controls" class="stats-box" style="display:none;">
                <div class="stat-entry">
                    <span class="stat-val" id="world-name">Terra</span>
                    <span class="stat-lbl">Planet</span>
                </div>
                <button class="action-btn" onclick="returnToGalaxy()">LEAVE PLANET</button>
                <!-- v5.5: Autopilot Toggle -->
                <button id="auto-explore-btn" class="action-btn" onclick="toggleAutoExplore()" style="background: #00ff88; color: #000; margin-top: 5px;">Take Manual Control</button>
                <div id="auto-explore-indicator" style="text-align: center; margin-top: 5px; font-size: 12px; color: #00ff88;">ðŸ¤– AUTOPILOT</div>
            </div>
        </div>

        <!-- Player Health Bar -->
        <div id="player-health-bar" class="player-health-bar">
            <div class="player-health-text"><span id="health-text">100 / 100</span></div>
            <div id="player-health-fill" class="player-health-fill"></div>
        </div>

        <div id="tooltip" class="context-tooltip">Target</div>

        <!-- Minimap -->
        <div id="minimap" class="minimap">
            <canvas id="minimap-canvas" class="minimap-canvas"></canvas>
        </div>

        <!-- v5.0: Weather Indicator -->
        <div id="weather-indicator" style="position: fixed; bottom: 325px; right: 10px; display: none; z-index: 100;
            background: rgba(0,0,0,0.7); padding: 8px 12px; border-radius: 8px; border: 1px solid #445;
            font-size: 14px; min-width: 100px; text-align: center;">
            <div style="font-size: 24px; margin-bottom: 4px;" id="weather-icon">â˜€ï¸</div>
            <div id="weather-name" style="color: #aaa; font-size: 12px;">Clear</div>
            <div id="weather-effect" style="color: #666; font-size: 10px; margin-top: 4px;"></div>
        </div>

        <!-- v4.8: Combat Abilities Bar (v4.9: Extended with Tier 2) -->
        <div id="ability-bar" style="position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); display: none; z-index: 100;">
            <div style="display: flex; gap: 8px; background: rgba(0,0,0,0.7); padding: 8px 12px; border-radius: 8px; border: 1px solid #333;">
                <!-- Tier 1 Abilities -->
                <div id="ability-q" class="ability-slot" onclick="useAbility('powerStrike')" title="Power Strike (Q) - 3x damage">
                    <span class="ability-icon">âš”ï¸</span>
                    <span class="ability-key">Q</span>
                    <div class="ability-cooldown" id="cooldown-q"></div>
                </div>
                <div id="ability-e" class="ability-slot" onclick="useAbility('whirlwind')" title="Whirlwind (E) - AoE damage">
                    <span class="ability-icon">ðŸŒ€</span>
                    <span class="ability-key">E</span>
                    <div class="ability-cooldown" id="cooldown-e"></div>
                </div>
                <div id="ability-r" class="ability-slot" onclick="useAbility('warcry')" title="War Cry (R) - +50% damage">
                    <span class="ability-icon">ðŸ“¢</span>
                    <span class="ability-key">R</span>
                    <div class="ability-cooldown" id="cooldown-r"></div>
                </div>
                <!-- v4.9: Tier 2 Abilities -->
                <div style="width: 1px; background: #444; margin: 0 4px;"></div>
                <div id="ability-t" class="ability-slot" onclick="useAbility('heal')" title="Battle Heal (T) - Restore 30% HP">
                    <span class="ability-icon">ðŸ’š</span>
                    <span class="ability-key">T</span>
                    <div class="ability-cooldown" id="cooldown-t"></div>
                </div>
                <div id="ability-f" class="ability-slot" onclick="useAbility('dash')" title="Combat Dash (F) - Dash forward">
                    <span class="ability-icon">ðŸ’¨</span>
                    <span class="ability-key">F</span>
                    <div class="ability-cooldown" id="cooldown-f"></div>
                </div>
                <div id="ability-z" class="ability-slot" onclick="useAbility('shieldWall')" title="Shield Wall (Z) - 70% damage reduction">
                    <span class="ability-icon">ðŸ›¡ï¸</span>
                    <span class="ability-key">Z</span>
                    <div class="ability-cooldown" id="cooldown-z"></div>
                </div>
                <div id="ability-x" class="ability-slot" onclick="useAbility('execute')" title="Execute (X) - 5x damage to low HP">
                    <span class="ability-icon">ðŸ’€</span>
                    <span class="ability-key">X</span>
                    <div class="ability-cooldown" id="cooldown-x"></div>
                </div>
                <div id="ability-c" class="ability-slot" onclick="useAbility('berserk')" title="Berserker Rage (C) - ULTIMATE">
                    <span class="ability-icon">ðŸ”¥</span>
                    <span class="ability-key">C</span>
                    <div class="ability-cooldown" id="cooldown-c"></div>
                </div>
            </div>
        </div>

        <div id="rpg-ui" class="rpg-ui">
            <div class="player-stats">
                <div class="panel-title">Skills</div>
                <div class="xp-bar-container">
                    <div class="xp-label"><span>Mining</span> <span id="lvl-mining">1</span></div>
                    <div class="xp-bar-bg"><div id="bar-mining" class="xp-bar-fill" style="background:#888"></div></div>
                </div>
                <div class="xp-bar-container">
                    <div class="xp-label"><span>Woodcutting</span> <span id="lvl-wood">1</span></div>
                    <div class="xp-bar-bg"><div id="bar-wood" class="xp-bar-fill" style="background:#da5"></div></div>
                </div>
                <div class="xp-bar-container">
                    <div class="xp-label"><span>Combat</span> <span id="lvl-combat">1</span></div>
                    <div class="xp-bar-bg"><div id="bar-combat" class="xp-bar-fill" style="background:#d00"></div></div>
                </div>
                <div class="xp-bar-container">
                    <div class="xp-label"><span>Fishing</span> <span id="lvl-fishing">1</span></div>
                    <div class="xp-bar-bg"><div id="bar-fishing" class="xp-bar-fill" style="background:#44f"></div></div>
                </div>
                <div class="xp-bar-container">
                    <div class="xp-label"><span>Cooking</span> <span id="lvl-cooking">1</span></div>
                    <div class="xp-bar-bg"><div id="bar-cooking" class="xp-bar-fill" style="background:#f80"></div></div>
                </div>
                <div class="xp-bar-container">
                    <div class="xp-label"><span>Crafting</span> <span id="lvl-crafting">1</span></div>
                    <div class="xp-bar-bg"><div id="bar-crafting" class="xp-bar-fill" style="background:#a0f"></div></div>
                </div>
                <!-- v5.2: Talent Tree Button -->
                <button onclick="showTalentModal()" style="width: 100%; margin-top: 10px; padding: 8px; cursor: pointer;
                    background: linear-gradient(135deg, #664, #442); border: 1px solid #ffd700; border-radius: 4px; color: #ffd700;">
                    ðŸŒŸ Talents (<span id="talent-points-btn">0</span>)
                </button>
            </div>

            <div class="crafting-panel" style="max-height: 280px; overflow-y: auto;">
                <div class="panel-title">Crafting</div>
                <!-- Basic Recipes -->
                <button class="craft-btn" id="craft-pickaxe" onclick="craft('pickaxe')">Pickaxe (3 Ore, 2 Log)</button>
                <button class="craft-btn" id="craft-sword" onclick="craft('sword')">Sword (5 Ore, 1 Log)</button>
                <button class="craft-btn" id="craft-rod" onclick="craft('rod')">Fishing Rod (2 Log)</button>
                <button class="craft-btn" id="craft-cookedFish" onclick="craft('cookedFish')">Cook Fish (1 Raw Fish)</button>
                <button class="craft-btn" id="craft-potion" onclick="craft('potion')">Health Potion (2 Slime)</button>
                <!-- v4.2: Advanced Recipes -->
                <div style="border-top: 1px solid #333; margin: 8px 0; padding-top: 8px;">
                    <small style="color: #888;">Advanced Crafting</small>
                </div>
                <button class="craft-btn" id="craft-chitinArmor" onclick="craft('chitinArmor')">Chitin Armor (Lvl 4)</button>
                <button class="craft-btn" id="craft-frostBlade" onclick="craft('frostBlade')">Frost Blade (Lvl 5)</button>
                <button class="craft-btn" id="craft-crystalPickaxe" onclick="craft('crystalPickaxe')">Crystal Pickaxe (Lvl 6)</button>
                <button class="craft-btn" id="craft-magmaSword" onclick="craft('magmaSword')">Magma Sword (Lvl 7)</button>
                <button class="craft-btn" id="craft-superPotion" onclick="craft('superPotion')">Super Potion (Lvl 8)</button>
                <button class="craft-btn" id="craft-voidDagger" onclick="craft('voidDagger')">Void Dagger (Lvl 10)</button>
                <!-- v4.3: Legendary Recipes (requires boss materials) -->
                <div style="border-top: 1px solid #664400; margin: 8px 0; padding-top: 8px;">
                    <small style="color: #ffd700;">âš”ï¸ Legendary Crafting</small>
                </div>
                <button class="craft-btn" id="craft-guardianArmor" onclick="craft('guardianArmor')" style="border-color: #664400;">Guardian Armor (Lvl 12)</button>
                <button class="craft-btn" id="craft-legendaryBlade" onclick="craft('legendaryBlade')" style="border-color: #ffd700;">Legendary Blade (Lvl 15)</button>
                <!-- v5.1: New Equipment Recipes -->
                <div style="border-top: 1px solid #448844; margin: 8px 0; padding-top: 8px;">
                    <small style="color: #88ff88;">ðŸ›¡ï¸ Equipment Crafting</small>
                </div>
                <button class="craft-btn" id="craft-ironArmor" onclick="craft('ironArmor')" style="border-color: #448844;">Iron Armor (Lvl 2)</button>
                <button class="craft-btn" id="craft-swiftBoots" onclick="craft('swiftBoots')" style="border-color: #448844;">Swift Boots (Lvl 5)</button>
                <button class="craft-btn" id="craft-luckyCharm" onclick="craft('luckyCharm')" style="border-color: #448844;">Lucky Charm (Lvl 6)</button>
                <button class="craft-btn" id="craft-powerRing" onclick="craft('powerRing')" style="border-color: #448844;">Power Ring (Lvl 7)</button>
                <button class="craft-btn" id="craft-steelArmor" onclick="craft('steelArmor')" style="border-color: #448844;">Steel Armor (Lvl 8)</button>
                <button class="craft-btn" id="craft-masterRod" onclick="craft('masterRod')" style="border-color: #448844;">Master Rod (Lvl 9)</button>
            </div>

            <div class="inventory-panel">
                <div class="panel-title">Backpack (<span id="inv-count">0</span>/20)</div>
                <div class="inv-grid" id="inventory-grid"></div>
            </div>

            <!-- v5.1: Equipment Panel -->
            <div class="inventory-panel" style="margin-top: 10px;">
                <div class="panel-title">âš”ï¸ Equipment</div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 10px;">
                    <div id="equip-slot-weapon" class="equip-slot" onclick="unequipItem('weapon')" title="Click to unequip">
                        <span class="equip-icon">âš”ï¸</span>
                        <span class="equip-name">Empty</span>
                    </div>
                    <div id="equip-slot-armor" class="equip-slot" onclick="unequipItem('armor')" title="Click to unequip">
                        <span class="equip-icon">ðŸ›¡ï¸</span>
                        <span class="equip-name">Empty</span>
                    </div>
                    <div id="equip-slot-accessory" class="equip-slot" onclick="unequipItem('accessory')" title="Click to unequip">
                        <span class="equip-icon">ðŸ’</span>
                        <span class="equip-name">Empty</span>
                    </div>
                    <div id="equip-slot-tool" class="equip-slot" onclick="unequipItem('tool')" title="Click to unequip">
                        <span class="equip-icon">ðŸ”§</span>
                        <span class="equip-name">Empty</span>
                    </div>
                </div>
                <div id="equipment-stats" style="font-size: 11px; padding: 8px; background: rgba(0,0,0,0.3); border-radius: 4px;">
                    <div style="color: #f44;">âš”ï¸ +0 DMG</div>
                    <div style="color: #4af;">ðŸ›¡ï¸ +0 DEF</div>
                </div>
                <button onclick="showEnchantModal()" style="width: 100%; margin-top: 8px; padding: 6px; cursor: pointer;
                    background: linear-gradient(135deg, #448, #226); border: 1px solid #66a; border-radius: 4px; color: #adf;">
                    âœ¨ Enchant Gear
                </button>
            </div>
        </div>

        <!-- Touch Controls -->
        <div id="touch-controls" class="touch-controls">
            <div class="touch-btn" id="touch-action">A</div>
        </div>

        <!-- v4.3: Virtual Joystick for Mobile -->
        <div id="virtual-joystick" class="virtual-joystick">
            <div id="joystick-knob" class="joystick-knob"></div>
        </div>
        <div id="touch-action-btn" class="touch-action-btn">ACT</div>
        <div id="touch-dodge-btn" class="touch-dodge-btn">DODGE</div>

    </div>

    <!-- Damage Overlay -->
    <div id="damage-overlay" style="
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        pointer-events: none; z-index: 50;
        background: radial-gradient(transparent 30%, rgba(255,0,0,0.6));
        opacity: 0; transition: opacity 0.1s;
    "></div>

    <!-- v4.9: Berserk Rage Overlay -->
    <div id="berserk-overlay" style="
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        pointer-events: none; z-index: 49;
        background: radial-gradient(transparent 40%, rgba(255,68,0,0.25));
        border: 4px solid rgba(255,68,0,0.5);
        box-shadow: inset 0 0 50px rgba(255,68,0,0.3);
        opacity: 0; transition: opacity 0.3s;
    "></div>

    <!-- v4.9: Shield Wall Overlay -->
    <div id="shield-overlay" style="
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        pointer-events: none; z-index: 49;
        background: radial-gradient(transparent 50%, rgba(68,136,255,0.2));
        border: 4px solid rgba(68,136,255,0.6);
        box-shadow: inset 0 0 40px rgba(68,136,255,0.2);
        opacity: 0; transition: opacity 0.3s;
    "></div>

    <!-- Tutorial Overlay -->
    <div id="tutorial-overlay" class="modal-overlay" style="display: none;">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-title">Welcome to LEVIATHAN</div>
            <div style="color: #aaa; line-height: 1.8; margin-bottom: 20px;">
                <p style="margin-bottom: 15px;"><strong style="color: #0ff;">Galaxy Mode:</strong></p>
                <ul style="margin-left: 20px; margin-bottom: 15px;">
                    <li>Click on star systems to explore planets</li>
                    <li>Visited planets show a green ring</li>
                </ul>
                <p style="margin-bottom: 15px;"><strong style="color: #fb0;">Planet Mode:</strong></p>
                <ul style="margin-left: 20px; margin-bottom: 15px;">
                    <li><strong>Click</strong> to move or interact with objects</li>
                    <li><strong>WASD</strong> keys for movement</li>
                    <li><strong>E</strong> to eat food and heal</li>
                    <li><strong>1-9</strong> to use inventory items</li>
                </ul>
                <p style="margin-bottom: 15px;"><strong style="color: #0f0;">Tips:</strong></p>
                <ul style="margin-left: 20px;">
                    <li>Gather logs and ore to craft tools</li>
                    <li>Tools increase resource yield</li>
                    <li>Green slimes are aggressive!</li>
                    <li>Fish for food, cook it to heal more</li>
                </ul>
            </div>
            <button class="action-btn" onclick="closeTutorial()" style="width: 100%;">START EXPLORING</button>
        </div>
    </div>

    <!-- v5.6: Copilot Companion UI -->
    <div id="copilot-button" class="copilot-button" onclick="toggleCopilotChat()">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"></path>
        </svg>
    </div>

    <!-- Copilot Voice Indicator -->
    <div id="copilot-voice-indicator" class="copilot-voice-indicator">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path>
            <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
        </svg>
        <span>Speaking...</span>
    </div>

    <!-- v5.9: Real-time STT Transcription Overlay -->
    <div id="stt-transcription-overlay" class="stt-transcription-overlay">
        <div class="stt-header">
            <div class="recording-dot"></div>
            <span id="stt-status">Listening...</span>
        </div>
        <div class="stt-waveform" id="stt-waveform">
            <div class="bar"></div>
            <div class="bar"></div>
            <div class="bar"></div>
            <div class="bar"></div>
            <div class="bar"></div>
            <div class="bar"></div>
            <div class="bar"></div>
        </div>
        <div id="stt-transcript-text" class="stt-transcript-text interim">Speak now...</div>
        <div class="stt-actions" id="stt-actions" style="display: none;">
            <button class="stt-cancel" onclick="cancelSTTMessage()">Cancel</button>
            <button class="stt-retry" onclick="retrySTT()">ðŸŽ¤ Retry</button>
            <button class="stt-send" onclick="sendSTTMessage()">Send âœ“</button>
        </div>
    </div>

    <!-- Copilot 3D Tooltip -->
    <div id="copilot-3d-tooltip" class="copilot-3d-tooltip">Click to chat</div>

    <!-- Copilot Chat Interface -->
    <div id="copilot-chat-interface" class="copilot-chat-interface">
        <div class="copilot-chat-header">
            <div class="copilot-chat-title">Copilot Companion</div>
            <button class="copilot-close-btn" onclick="toggleCopilotChat()">Ã—</button>
        </div>
        <div class="copilot-quick-actions">
            <button class="copilot-quick-btn" onclick="sendCopilotQuickMessage('What should I do next?')">What next?</button>
            <button class="copilot-quick-btn" onclick="sendCopilotQuickMessage('Give me a tip')">Tips</button>
            <button class="copilot-quick-btn" onclick="sendCopilotQuickMessage('Where are the enemies?')">Enemies</button>
            <button class="copilot-quick-btn" onclick="sendCopilotQuickMessage('How do I get stronger?')">Get Stronger</button>
        </div>
        <div id="copilot-chat-messages" class="copilot-chat-messages">
            <div class="copilot-message ai">Hello, Explorer! I'm your Copilot Companion. I'll follow you on your journey and help with advice. What would you like to know?</div>
        </div>
        <div class="copilot-chat-input-container">
            <input type="text" id="copilot-chat-input" class="copilot-chat-input" placeholder="Ask your Copilot..." onkeypress="if(event.key==='Enter') sendCopilotMessage()">
            <button id="copilot-voice-btn" class="copilot-voice-btn" onclick="toggleCopilotVoice()">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path>
                    <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
                </svg>
            </button>
            <button class="copilot-chat-send" onclick="sendCopilotMessage()">Send</button>
        </div>
    </div>

    <!-- v5.7: AI Companion Settings Modal - Tabbed Interface -->
    <div id="ai-settings-modal" class="ai-settings-modal">
        <div class="ai-settings-content">
            <div class="ai-settings-header">
                <h2>AI Companion Settings</h2>
                <button class="ai-settings-close" onclick="closeAISettingsModal()">&times;</button>
            </div>

            <!-- Tabs -->
            <div class="ai-settings-tabs">
                <button class="ai-settings-tab active" onclick="switchAITab('general')">General</button>
                <button class="ai-settings-tab" onclick="switchAITab('voice')">Voice</button>
                <button class="ai-settings-tab" onclick="switchAITab('3dview')">3D View</button>
                <button class="ai-settings-tab" onclick="switchAITab('import')">Import/Export</button>
            </div>

            <div class="ai-settings-body">
                <!-- General Tab -->
                <div id="ai-tab-general" class="ai-tab-content active">
                    <div class="ai-section">
                        <h3>API Configuration</h3>
                        <div class="ai-form-group">
                            <label>API Key</label>
                            <input type="password" id="ai-api-key" class="ai-input" placeholder="Enter your API key">
                        </div>
                        <div class="ai-form-group">
                            <label>API Endpoint</label>
                            <input type="text" id="ai-api-endpoint" class="ai-input" placeholder="http://localhost:7071/api/businessinsightbot_function">
                        </div>
                        <div id="ai-endpoints-list"></div>
                    </div>
                    <div class="ai-section">
                        <h3>World Settings</h3>
                        <div class="ai-form-group">
                            <label>Companion Name</label>
                            <input type="text" id="ai-companion-name" class="ai-input" value="Copilot" placeholder="AI Companion">
                        </div>
                        <div class="ai-form-group">
                            <label>Companion Personality</label>
                            <select id="ai-companion-personality" class="ai-select">
                                <option value="helpful">Helpful & Friendly</option>
                                <option value="adventurous">Adventurous Explorer</option>
                                <option value="wise">Wise Sage</option>
                                <option value="playful">Playful Companion</option>
                            </select>
                        </div>
                    </div>
                </div>

                <!-- Voice Tab -->
                <div id="ai-tab-voice" class="ai-tab-content">
                    <div class="ai-section">
                        <h3>Voice Output</h3>
                        <div class="ai-toggle-row">
                            <span class="ai-toggle-label">Enable Voice Response</span>
                            <label class="ai-toggle">
                                <input type="checkbox" id="ai-voice-enabled" checked>
                                <span class="ai-toggle-slider"></span>
                            </label>
                        </div>
                        <div class="ai-toggle-row">
                            <span class="ai-toggle-label">Auto-speak Responses</span>
                            <label class="ai-toggle">
                                <input type="checkbox" id="ai-auto-speak">
                                <span class="ai-toggle-slider"></span>
                            </label>
                        </div>
                        <div class="ai-form-group">
                            <label>Azure TTS API Key</label>
                            <input type="password" id="ai-tts-key" class="ai-input" placeholder="Enter Azure TTS key for premium voices">
                        </div>
                        <div class="ai-form-group">
                            <label>Azure Region</label>
                            <input type="text" id="ai-tts-region" class="ai-input" placeholder="eastus2">
                        </div>
                        <div class="ai-form-group">
                            <label>TTS Voice</label>
                            <select id="ai-tts-voice" class="ai-select">
                                <option value="en-US-JennyNeural">Jenny (Female)</option>
                                <option value="en-US-GuyNeural">Guy (Male)</option>
                                <option value="en-US-AriaNeural">Aria (Female)</option>
                                <option value="en-US-DavisNeural">Davis (Male)</option>
                                <option value="en-US-AmberNeural">Amber (Female)</option>
                                <option value="en-US-AnaNeural">Ana (Female - Child)</option>
                                <option value="en-US-BrandonNeural">Brandon (Male)</option>
                                <option value="en-US-ChristopherNeural">Christopher (Male)</option>
                                <option value="en-US-CoraNeural">Cora (Female)</option>
                                <option value="en-US-ElizabethNeural">Elizabeth (Female)</option>
                            </select>
                        </div>
                    </div>
                    <div class="ai-section">
                        <h3>Voice Input</h3>
                        <div class="ai-toggle-row">
                            <span class="ai-toggle-label">Enable Voice Input</span>
                            <label class="ai-toggle">
                                <input type="checkbox" id="ai-voice-input-enabled" checked>
                                <span class="ai-toggle-slider"></span>
                            </label>
                        </div>
                        <div class="ai-toggle-row">
                            <span class="ai-toggle-label">Continuous Conversation Mode</span>
                            <label class="ai-toggle">
                                <input type="checkbox" id="ai-continuous-mode">
                                <span class="ai-toggle-slider"></span>
                            </label>
                        </div>
                        <div class="ai-form-group">
                            <label>Push-to-Talk Key</label>
                            <select id="ai-ptt-key" class="ai-select">
                                <option value="Space">Space</option>
                                <option value="KeyV">V</option>
                                <option value="KeyT">T</option>
                                <option value="KeyC">C</option>
                            </select>
                        </div>
                    </div>
                </div>

                <!-- 3D View Tab -->
                <div id="ai-tab-3dview" class="ai-tab-content">
                    <div class="ai-section">
                        <h3>Companion Appearance</h3>
                        <div class="ai-form-group">
                            <label>Primary Color</label>
                            <div class="ai-color-row">
                                <input type="color" id="ai-primary-color" class="ai-color-preview" value="#8a2be2">
                                <input type="text" id="ai-primary-color-hex" class="ai-input ai-color-input" value="#8a2be2">
                            </div>
                        </div>
                        <div class="ai-form-group">
                            <label>Glow Color</label>
                            <div class="ai-color-row">
                                <input type="color" id="ai-glow-color" class="ai-color-preview" value="#06ffa5">
                                <input type="text" id="ai-glow-color-hex" class="ai-input ai-color-input" value="#06ffa5">
                            </div>
                        </div>
                        <div class="ai-form-group">
                            <label>Companion Size</label>
                            <select id="ai-companion-size" class="ai-select">
                                <option value="small">Small</option>
                                <option value="medium" selected>Medium</option>
                                <option value="large">Large</option>
                            </select>
                        </div>
                        <div class="ai-toggle-row">
                            <span class="ai-toggle-label">Show Particles</span>
                            <label class="ai-toggle">
                                <input type="checkbox" id="ai-show-particles" checked>
                                <span class="ai-toggle-slider"></span>
                            </label>
                        </div>
                        <div class="ai-toggle-row">
                            <span class="ai-toggle-label">Enable Glow Effect</span>
                            <label class="ai-toggle">
                                <input type="checkbox" id="ai-enable-glow" checked>
                                <span class="ai-toggle-slider"></span>
                            </label>
                        </div>
                    </div>
                    <div class="ai-section">
                        <h3>Behavior</h3>
                        <div class="ai-form-group">
                            <label>Follow Distance</label>
                            <select id="ai-follow-distance" class="ai-select">
                                <option value="2">Close (2m)</option>
                                <option value="3" selected>Normal (3m)</option>
                                <option value="5">Far (5m)</option>
                            </select>
                        </div>
                        <div class="ai-form-group">
                            <label>Float Height</label>
                            <select id="ai-float-height" class="ai-select">
                                <option value="1.5">Low (1.5m)</option>
                                <option value="2.5" selected>Normal (2.5m)</option>
                                <option value="3.5">High (3.5m)</option>
                            </select>
                        </div>
                    </div>
                </div>

                <!-- Import/Export Tab -->
                <div id="ai-tab-import" class="ai-tab-content">
                    <div class="ai-section">
                        <h3>RAPPID Settings</h3>
                        <p style="color: #888; font-size: 13px; margin-bottom: 15px;">
                            Import your RAPPID configuration file to automatically configure API endpoints and Azure TTS settings.
                        </p>
                        <div id="ai-endpoints-preview"></div>
                        <div style="display: flex; gap: 10px; margin-top: 15px;">
                            <button class="ai-btn ai-btn-import" onclick="document.getElementById('rappidImportFile').click()" style="flex: 1;">
                                Import RAPPID Config
                            </button>
                            <button class="ai-btn ai-btn-cancel" onclick="exportRappidSettings()" style="flex: 1;">
                                Export Settings
                            </button>
                        </div>
                    </div>
                    <div class="ai-section">
                        <h3>Connection Status</h3>
                        <div id="ai-connection-status" style="padding: 15px; background: rgba(0,0,0,0.3); border-radius: 8px; text-align: center;">
                            <span style="color: #888;">No endpoint configured</span>
                        </div>
                        <button class="ai-btn ai-btn-cancel" onclick="testRappidConnection()" style="width: 100%; margin-top: 15px;">
                            Test Connection
                        </button>
                    </div>
                    <div class="ai-section">
                        <h3>Reset</h3>
                        <button class="ai-btn" onclick="clearRappidSettings()" style="width: 100%; background: rgba(255,68,68,0.1); border: 1px solid #f44; color: #f44;">
                            Clear All Settings
                        </button>
                    </div>
                    <div id="ai-status-message" class="ai-status-msg"></div>
                </div>
            </div>

            <div class="ai-settings-footer">
                <button class="ai-btn ai-btn-save" onclick="saveAISettings()">Save Changes</button>
                <button class="ai-btn ai-btn-cancel" onclick="closeAISettingsModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Daily Challenge Box -->
    <div id="daily-challenge" class="daily-challenge-box" style="display: none;">
        <div class="daily-title">Daily Challenge</div>
        <div id="daily-desc" class="daily-desc">Loading...</div>
        <div class="daily-progress-bar">
            <div id="daily-progress-fill" class="daily-progress-fill" style="width: 0%"></div>
        </div>
        <div id="daily-progress-text" class="daily-progress-text">0/0</div>
        <div id="daily-streak" class="daily-streak">Streak: 0 days</div>
    </div>

    <!-- v4.6: Full Settings Panel -->
    <div id="settings-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 380px;">
            <button class="modal-close" onclick="closeSettingsModal()">&times;</button>
            <div class="modal-title">Settings</div>

            <!-- Audio Section -->
            <div class="settings-section">
                <h4 style="color: #0ff;">Audio</h4>
                <div class="setting-row">
                    <span>Master Volume</span>
                    <input type="range" id="volume-slider" min="0" max="100" value="30" oninput="setMasterVolume(this.value)">
                    <span id="volume-display" style="width: 35px; text-align: right;">30%</span>
                </div>
                <div class="setting-row">
                    <span>Sound Effects</span>
                    <button id="sfx-toggle" class="toggle-btn" onclick="toggleSFX()">ON</button>
                </div>
                <div class="setting-row">
                    <span>Ambient Audio</span>
                    <button id="ambient-toggle" class="toggle-btn" onclick="toggleAmbient()">ON</button>
                </div>
            </div>

            <!-- Graphics Section -->
            <div class="settings-section">
                <h4 style="color: #fb0;">Graphics</h4>
                <div class="setting-row">
                    <span>Particle Quality</span>
                    <select id="particle-quality" onchange="setParticleQuality(this.value)">
                        <option value="high">High</option>
                        <option value="medium">Medium</option>
                        <option value="low">Low</option>
                    </select>
                </div>
                <div class="setting-row">
                    <span>Shadows</span>
                    <button id="shadow-toggle" class="toggle-btn" onclick="toggleShadows()">ON</button>
                </div>
                <div class="setting-row">
                    <span>Screen Shake</span>
                    <button id="shake-toggle" class="toggle-btn" onclick="toggleScreenShake()">ON</button>
                </div>
            </div>

            <!-- Game Section -->
            <div class="settings-section">
                <h4 style="color: #0f0;">Game</h4>
                <div class="setting-row">
                    <span>Show Hints</span>
                    <button id="hints-toggle" class="toggle-btn" onclick="toggleHints()">ON</button>
                </div>
                <button class="action-btn" onclick="showTutorial(); closeSettingsModal();" style="width: 100%; margin-top: 10px;">Show Tutorial</button>
            </div>

            <!-- Save Info -->
            <p style="color: #666; font-size: 11px; margin-top: 10px; text-align: center;">
                Last saved: <span id="last-save-time">Never</span>
            </p>
        </div>
    </div>

    <!-- v4.7: Welcome Back Modal -->
    <div id="welcome-back-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 400px; text-align: center;">
            <div class="modal-title" style="color: #ffd700;">Welcome Back!</div>
            <p id="welcome-back-message" style="color: #0ff; font-size: 16px; margin: 15px 0;"></p>
            <p id="welcome-back-time" style="color: #888; font-size: 12px; margin-bottom: 20px;"></p>

            <div id="welcome-back-rewards" style="background: rgba(0,255,255,0.1); border: 1px solid #0ff; border-radius: 8px; padding: 15px; margin-bottom: 20px;">
                <h4 style="color: #0ff; margin: 0 0 10px;">Your Rewards:</h4>
                <div id="welcome-back-rewards-list" style="text-align: left;"></div>
            </div>

            <button class="action-btn" onclick="claimWelcomeBackRewards()" style="width: 100%; padding: 12px; font-size: 16px; background: linear-gradient(135deg, #ffd700, #ff8800);">
                Claim Rewards!
            </button>
        </div>
    </div>

    <!-- Stats Modal -->
    <div id="stats-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 450px; max-height: 80vh; overflow-y: auto;">
            <button class="modal-close" onclick="closeStatsModal()">&times;</button>
            <div class="modal-title">Player Statistics</div>

            <!-- v4.2: Player Rank Section -->
            <div class="stats-section" style="background: linear-gradient(135deg, rgba(255,215,0,0.1), rgba(0,255,255,0.1)); border: 1px solid #ffd700; border-radius: 8px; padding: 12px; margin-bottom: 15px;">
                <h3 style="color: #ffd700; margin: 0 0 10px; font-size: 16px;">Player Rank</h3>
                <div class="stat-row"><span>Current Rank</span><span id="stat-rank" style="font-weight: bold;">Novice Explorer</span></div>
                <div class="stat-row"><span>Total Points</span><span id="stat-points">0</span></div>
                <div style="margin-top: 10px; font-size: 11px; color: #888;">
                    <span style="color: #aaa;">Special Titles: </span><span id="special-titles">None yet</span>
                </div>
            </div>

            <div class="stats-section">
                <h3 style="color: #0ff; margin: 15px 0 10px; font-size: 14px;">Exploration</h3>
                <div class="stat-row"><span>Planets Visited</span><span id="stat-planets">0 / 60</span></div>
                <div class="stat-row"><span>POIs Discovered</span><span id="stat-pois">0</span></div>
                <div class="stat-row"><span>Total Playtime</span><span id="stat-playtime">0h 0m</span></div>
            </div>

            <div class="stats-section">
                <h3 style="color: #fb0; margin: 15px 0 10px; font-size: 14px;">Gathering</h3>
                <div class="stat-row"><span>Trees Chopped</span><span id="stat-trees">0</span></div>
                <div class="stat-row"><span>Ore Mined</span><span id="stat-ore">0</span></div>
                <div class="stat-row"><span>Fish Caught</span><span id="stat-fish">0</span></div>
            </div>

            <div class="stats-section">
                <h3 style="color: #f44; margin: 15px 0 10px; font-size: 14px;">Combat</h3>
                <div class="stat-row"><span>Enemies Defeated</span><span id="stat-mobs">0</span></div>
            </div>

            <div class="stats-section">
                <h3 style="color: #a0f; margin: 15px 0 10px; font-size: 14px;">Crafting</h3>
                <div class="stat-row"><span>Items Crafted</span><span id="stat-crafted">0</span></div>
            </div>

            <div class="stats-section">
                <h3 style="color: #ffd700; margin: 15px 0 10px; font-size: 14px;">Achievements</h3>
                <div id="achievements-list" class="achievements-grid"></div>
            </div>

            <!-- v4.4: Leaderboard Section -->
            <div class="stats-section" style="background: linear-gradient(135deg, rgba(255,100,0,0.1), rgba(255,200,0,0.1)); border: 1px solid #ff8800; border-radius: 8px; padding: 12px; margin-top: 15px;">
                <h3 style="color: #ff8800; margin: 0 0 10px; font-size: 14px;">Leaderboard</h3>
                <div id="leaderboard-list" style="font-size: 12px;"></div>
            </div>

            <!-- v4.4: Prestige Section -->
            <div class="stats-section" style="background: linear-gradient(135deg, rgba(150,0,255,0.1), rgba(0,200,255,0.1)); border: 1px solid #aa44ff; border-radius: 8px; padding: 12px; margin-top: 15px;">
                <h3 style="color: #aa44ff; margin: 0 0 10px; font-size: 14px;">Prestige System</h3>
                <div class="stat-row"><span>Prestige Level</span><span id="prestige-level" style="color: #aa44ff; font-weight: bold;">0</span></div>
                <div class="stat-row"><span>XP Multiplier</span><span id="prestige-xp">x1.0</span></div>
                <div class="stat-row"><span>Lifetime Points</span><span id="prestige-lifetime">0</span></div>
                <div id="prestige-progress" style="margin-top: 10px; font-size: 11px; color: #888;"></div>
                <button id="prestige-btn" onclick="performPrestige()" style="display: none; margin-top: 10px; padding: 8px 16px; background: linear-gradient(135deg, #aa44ff, #6644ff); border: none; border-radius: 4px; color: #fff; cursor: pointer; width: 100%;">PRESTIGE NOW</button>
            </div>
        </div>
    </div>

    <!-- v4.9: Collection Codex Modal -->
    <div id="codex-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 600px; max-height: 85vh; overflow-y: auto;">
            <button class="modal-close" onclick="closeCodexModal()">&times;</button>
            <div class="modal-title" style="color: #ffd700;">Collection Codex</div>

            <!-- Codex Tabs -->
            <div style="display: flex; gap: 5px; margin-bottom: 15px; flex-wrap: wrap;">
                <button class="codex-tab active" data-tab="creatures" onclick="switchCodexTab('creatures')">Creatures</button>
                <button class="codex-tab" data-tab="items" onclick="switchCodexTab('items')">Items</button>
                <button class="codex-tab" data-tab="biomes" onclick="switchCodexTab('biomes')">Biomes</button>
                <button class="codex-tab" data-tab="abilities" onclick="switchCodexTab('abilities')">Abilities</button>
                <button class="codex-tab" data-tab="pets" onclick="switchCodexTab('pets')" style="background: linear-gradient(135deg, rgba(255,136,0,0.3), rgba(255,68,0,0.3));">Pets</button>
            </div>

            <!-- Creatures Tab -->
            <div id="codex-creatures" class="codex-content">
                <div style="color: #aaa; margin-bottom: 10px; font-size: 12px;">
                    Discovered: <span id="codex-creatures-count">0</span> / <span id="codex-creatures-total">0</span>
                </div>
                <div id="codex-creatures-grid" class="codex-grid"></div>
            </div>

            <!-- Items Tab -->
            <div id="codex-items" class="codex-content" style="display: none;">
                <div style="color: #aaa; margin-bottom: 10px; font-size: 12px;">
                    Discovered: <span id="codex-items-count">0</span> / <span id="codex-items-total">0</span>
                </div>
                <div id="codex-items-grid" class="codex-grid"></div>
            </div>

            <!-- Biomes Tab -->
            <div id="codex-biomes" class="codex-content" style="display: none;">
                <div style="color: #aaa; margin-bottom: 10px; font-size: 12px;">
                    Explored: <span id="codex-biomes-count">0</span> / <span id="codex-biomes-total">0</span>
                </div>
                <div id="codex-biomes-grid" class="codex-grid"></div>
            </div>

            <!-- Abilities Tab -->
            <div id="codex-abilities" class="codex-content" style="display: none;">
                <div style="color: #aaa; margin-bottom: 10px; font-size: 12px;">
                    Unlocked: <span id="codex-abilities-count">0</span> / <span id="codex-abilities-total">0</span>
                </div>
                <div id="codex-abilities-grid" class="codex-grid"></div>
            </div>

            <!-- v5.0: Pets Tab -->
            <div id="codex-pets" class="codex-content" style="display: none;">
                <div style="color: #aaa; margin-bottom: 10px; font-size: 12px;">
                    Collected: <span id="codex-pets-count">0</span> / <span id="codex-pets-total">0</span>
                    <span style="margin-left: 15px;">Active: <span id="active-pet-name" style="color: #ff8c00;">None</span></span>
                </div>
                <div id="codex-pets-grid" class="codex-grid"></div>
            </div>
        </div>
    </div>

    <!-- v5.0: Quest System Modal -->
    <div id="quest-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 550px; max-height: 85vh; overflow-y: auto;">
            <button class="modal-close" onclick="closeQuestModal()">&times;</button>
            <div class="modal-title" style="color: #ff8c00;">Quest Board</div>

            <!-- Quest Tabs -->
            <div style="display: flex; gap: 5px; margin-bottom: 15px;">
                <button class="codex-tab active" data-tab="daily" onclick="switchQuestTab('daily')">Daily</button>
                <button class="codex-tab" data-tab="weekly" onclick="switchQuestTab('weekly')">Weekly</button>
                <button class="codex-tab" data-tab="story" onclick="switchQuestTab('story')">Story</button>
            </div>

            <!-- Daily Quests -->
            <div id="quest-daily" class="quest-content">
                <div style="color: #aaa; margin-bottom: 10px; font-size: 12px;">
                    Resets in: <span id="daily-reset-timer" style="color: #ff8c00;">--:--:--</span>
                </div>
                <div id="daily-quests-list" class="quest-list"></div>
            </div>

            <!-- Weekly Quests -->
            <div id="quest-weekly" class="quest-content" style="display: none;">
                <div style="color: #aaa; margin-bottom: 10px; font-size: 12px;">
                    Resets in: <span id="weekly-reset-timer" style="color: #ff8c00;">--:--:--</span>
                </div>
                <div id="weekly-quests-list" class="quest-list"></div>
            </div>

            <!-- Story Quests -->
            <div id="quest-story" class="quest-content" style="display: none;">
                <div style="color: #aaa; margin-bottom: 10px; font-size: 12px;">
                    Progress through the story to unlock rewards!
                </div>
                <div id="story-quests-list" class="quest-list"></div>
            </div>
        </div>
    </div>

    <!-- v5.1: Enchantment Modal -->
    <div id="enchant-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 500px; max-height: 80vh; overflow-y: auto;">
            <button class="modal-close" onclick="closeEnchantModal()">&times;</button>
            <div class="modal-title" style="color: #8af;">âœ¨ Enchanting Table</div>
            <div style="color: #aaa; font-size: 12px; margin-bottom: 15px;">
                Add magical enhancements to your equipped gear!
            </div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                <div>
                    <div style="font-weight: bold; margin-bottom: 8px; color: #fb0;">Your Gear:</div>
                    <div id="enchant-items"></div>
                </div>
                <div>
                    <div style="font-weight: bold; margin-bottom: 8px; color: #fb0;">Enchantments:</div>
                    <div id="enchant-options"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- v5.2: Talent Tree Modal -->
    <div id="talent-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 700px; max-height: 85vh; overflow-y: auto;">
            <button class="modal-close" onclick="closeTalentModal()">&times;</button>
            <div class="modal-title" style="color: #ffd700;">ðŸŒŸ Talent Trees</div>
            <div id="talent-points-display" style="color: #aaa; font-size: 14px; margin-bottom: 15px; text-align: center;">
                Talent Points: 0/0
            </div>
            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px;">
                <div>
                    <div style="text-align: center; font-weight: bold; color: #ff4444; margin-bottom: 10px;">âš”ï¸ Combat</div>
                    <div id="talent-tree-combat"></div>
                </div>
                <div>
                    <div style="text-align: center; font-weight: bold; color: #44aaff; margin-bottom: 10px;">ðŸ›¡ï¸ Survival</div>
                    <div id="talent-tree-survival"></div>
                </div>
                <div>
                    <div style="text-align: center; font-weight: bold; color: #44ff44; margin-bottom: 10px;">ðŸ€ Fortune</div>
                    <div id="talent-tree-fortune"></div>
                </div>
            </div>
            <div style="text-align: center; margin-top: 15px; font-size: 11px; color: #666;">
                Earn 1 talent point per 5 combined skill levels
            </div>
        </div>
    </div>

    <!-- v5.3: Mastery System Modal -->
    <div id="mastery-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 600px; max-height: 85vh; overflow-y: auto;">
            <button class="modal-close" onclick="closeMasteryModal()">&times;</button>
            <div class="modal-title" style="color: #ff44ff;">Skill Mastery</div>
            <div style="color: #aaa; font-size: 12px; margin-bottom: 15px; text-align: center;">
                Reach skill milestones to unlock permanent bonuses!
            </div>
            <div id="mastery-list"></div>
        </div>
    </div>

    <!-- v5.3: Realm Portal Modal -->
    <div id="portal-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 550px; max-height: 85vh; overflow-y: auto;">
            <button class="modal-close" onclick="closePortalModal()">&times;</button>
            <div class="modal-title" style="color: #8844ff;">Realm Portals</div>
            <div style="color: #aaa; font-size: 12px; margin-bottom: 15px; text-align: center;">
                Enter challenging realms for exclusive rewards!
            </div>
            <div id="portal-status" style="text-align: center; margin-bottom: 15px; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 8px;">
                <span style="color: #888;">Current Realm:</span>
                <span id="current-realm" style="color: #ff8844; font-weight: bold; margin-left: 8px;">None</span>
            </div>
            <div id="portal-list"></div>
        </div>
    </div>

    <!-- v5.4: Companion Evolution Modal -->
    <div id="evolution-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 550px; max-height: 85vh; overflow-y: auto;">
            <button class="modal-close" onclick="closeEvolutionModal()">&times;</button>
            <div class="modal-title" style="color: #aa44ff;">Companion Evolution</div>
            <div style="color: #aaa; font-size: 12px; margin-bottom: 15px; text-align: center;">
                Bond with your companions to unlock powerful evolutions!
            </div>
            <div id="evolution-list"></div>
        </div>
    </div>

    <!-- v5.4: Achievement Showcase Modal -->
    <div id="showcase-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 600px; max-height: 85vh; overflow-y: auto;">
            <button class="modal-close" onclick="closeShowcaseModal()">&times;</button>
            <div class="modal-title" style="color: #ffd700;">Achievement Showcase</div>
            <div class="achievement-points-display">
                <div class="ap-value" id="total-ap">0</div>
                <div class="ap-label">Achievement Points</div>
                <div class="ap-milestone">
                    <div style="display: flex; justify-content: space-between; font-size: 11px;">
                        <span style="color: #aaa;">Next Milestone:</span>
                        <span id="next-milestone-name" style="color: #ffd700;">---</span>
                    </div>
                    <div class="ap-milestone-progress">
                        <div class="ap-milestone-fill" id="milestone-progress" style="width: 0%;"></div>
                    </div>
                </div>
            </div>
            <div style="margin-bottom: 10px; font-size: 12px; color: #888;">
                Active Cosmetic: <span id="active-cosmetic" style="color: #aa44ff;">None</span>
            </div>
            <div id="showcase-badges" class="showcase-grid"></div>
        </div>
    </div>

    <!-- v5.4: World Event Indicator -->
    <div id="event-indicator" class="event-indicator">
        <div class="event-indicator-icon" id="event-ind-icon"></div>
        <div class="event-indicator-name" id="event-ind-name">No Event</div>
        <div class="event-indicator-time" id="event-ind-time">--:--</div>
        <div class="event-indicator-progress">
            <div class="event-indicator-fill" id="event-ind-fill" style="width: 100%;"></div>
        </div>
    </div>

    <!-- v5.5: 3D Ship Landing Mini-Game Overlay -->
    <div id="landing-overlay" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; z-index: 1000;">
        <div id="landing-scene-container" style="width: 100%; height: 100%;"></div>

        <!-- Landing HUD -->
        <div id="landing-info" style="position: absolute; top: 20px; left: 20px; color: white; background: rgba(0,0,0,0.7); padding: 15px; border-radius: 10px; backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.1);">
            <div style="font-size: 18px; font-weight: bold; color: #00ff88; margin-bottom: 10px;" id="landing-planet-name">Landing Sequence</div>
            <div style="margin: 5px 0; font-size: 14px;"><span style="color: #00ff88; font-weight: bold;">Altitude:</span> <span id="landing-altitude">0</span>m</div>
            <div style="margin: 5px 0; font-size: 14px;"><span style="color: #00ff88; font-weight: bold;">Speed:</span> <span id="landing-speed">0</span>m/s</div>
            <div style="margin: 5px 0; font-size: 14px;"><span style="color: #00ff88; font-weight: bold;">Fuel:</span> <span id="landing-fuel">100</span>%</div>
            <div style="margin: 5px 0; font-size: 14px;"><span style="color: #00ff88; font-weight: bold;">Mode:</span> <span id="landing-mode">Autonomous</span></div>
            <div style="margin: 5px 0; font-size: 14px;"><span style="color: #00ff88; font-weight: bold;">Distance:</span> <span id="landing-distance">0</span>m</div>
        </div>

        <!-- Landing Controls -->
        <div id="landing-controls" style="position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); padding: 15px 25px; border-radius: 10px; color: white; display: flex; gap: 20px; align-items: center; backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.1);">
            <button onclick="toggleLandingMode()" id="landing-mode-btn" style="background: #00ff88; border: none; padding: 8px 16px; border-radius: 5px; cursor: pointer; font-weight: bold; color: #000;">Switch to Manual</button>
            <button onclick="abortLanding()" style="background: #ff4444; border: none; padding: 8px 16px; border-radius: 5px; cursor: pointer; font-weight: bold; color: #fff;">Abort Landing</button>
            <div style="color: #888; font-size: 12px;">Manual: Arrow Keys + Space/Shift</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // === LEVIATHAN: OMNIVERSE v4.9 ===
        // Enhanced with local-first principles: localStorage persistence & JSON import/export
        // v4.0: Performance optimizations, audio system, particle effects, improved UX
        // v4.1: Achievement system, daily challenges, statistics panel, visual enhancements
        // v4.2: Enemy variety, skill bonuses, POI system, player ranks, combat improvements
        // v4.3: Boss encounters, mobile touch controls, ambient audio, notification queue
        // v4.4: Hit-stop combat, environmental particles, local leaderboard, prestige system, fog of war
        // v4.5: Attack telegraphing, player dodge, recipe discovery, settings panel, boss spawn gates
        // v4.6: Settings persistence, elemental status effects, parry/counter system
        // v4.7: Elite enemy system with affixes, elite gear crafting, session rewards, adaptive performance
        // v4.8: Combo attack system, combat abilities (Q/E/R), ability cooldown UI, item tooltips
        // v4.9: Tier 2 combat abilities (T/F/Z/X/C), visual buff overlays, Collection Codex system
        // v5.0: Quest System (daily/weekly/story), Pet Companions, Weather System
        // v5.1: Equipment System (4 slots), enhanced crafting, enchantment system with 8 enchants
        // v5.2: Talent Tree System (3 trees: Combat/Survival/Fortune, 15 talents)
        // v5.3: Mastery System (skill milestones), Realm Portals (endgame dungeons), Loot Rarity System (item modifiers)
        // v5.4: Companion Evolution System (pets evolve at bond levels), World Events (random spawning events), Achievement Showcase (badges & points)
        // v5.5: Ship Landing Mini-Game (physics-based landing sequence with biome-specific terrain when visiting planets)
        // v5.6: Copilot Companion System (3D AI companion that follows player and provides contextual help)
        // v5.7: RAPPID Integration (AI endpoints, Azure TTS, settings import/export)
        // v5.8: Fixed keyboard input capture when typing in chat, improved API request format
        // v5.9: Updated Azure TTS to use Microsoft Speech SDK for proper voice output
        //       Added Azure STT for microphone input, uses voice_response for TTS

        const APP_NAME = 'leviathan-omniverse';
        const VERSION = '5.9.0';

        // --- AUDIO SYSTEM (Web Audio API - No external dependencies) ---
        const AudioSystem = {
            ctx: null,
            enabled: true,
            masterVolume: 0.3,

            init() {
                try {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.warn('Web Audio API not supported');
                    this.enabled = false;
                }
            },

            resume() {
                if (this.ctx && this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
            },

            playTone(freq, duration, type = 'sine', volume = 1) {
                if (!this.enabled || !this.ctx) return;
                this.resume();

                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.value = freq;
                gain.gain.setValueAtTime(this.masterVolume * volume, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                osc.connect(gain).connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            },

            hit() { this.playTone(200, 0.08, 'square', 0.5); },
            collect() { this.playTone(600, 0.12, 'sine', 0.6); },
            damage() { this.playTone(80, 0.15, 'sawtooth', 0.7); },
            kill() {
                this.playTone(150, 0.1, 'square', 0.5);
                setTimeout(() => this.playTone(100, 0.15, 'square', 0.4), 50);
            },
            // v4.7: Explosion sound for explosive elite death
            explosion() {
                this.playTone(80, 0.3, 'sawtooth', 0.6);
                setTimeout(() => this.playTone(60, 0.2, 'sawtooth', 0.4), 50);
                setTimeout(() => this.playTone(40, 0.15, 'square', 0.3), 100);
            },
            levelUp() {
                [400, 500, 600, 800].forEach((f, i) => {
                    setTimeout(() => this.playTone(f, 0.15, 'sine', 0.5), i * 80);
                });
            },
            craft() { this.playTone(440, 0.1, 'triangle', 0.4); },
            click() { this.playTone(800, 0.03, 'sine', 0.2); },
            error() { this.playTone(100, 0.2, 'sawtooth', 0.3); },
            heal() { this.playTone(520, 0.2, 'sine', 0.4); },
            // v4.5: Dodge and telegraph sounds
            dodge() { this.playTone(300, 0.08, 'sine', 0.4); this.playTone(450, 0.06, 'sine', 0.3); },
            telegraph() { this.playTone(150, 0.1, 'square', 0.25); },

            // v4.3: Ambient Audio System
            ambientNode: null,
            ambientGain: null,
            currentBiome: null,

            // Biome-specific ambient audio configurations
            biomeAmbient: {
                Terra: { baseFreq: 80, modFreq: 0.3, type: 'sine', volume: 0.08 },
                Desert: { baseFreq: 120, modFreq: 0.1, type: 'sine', volume: 0.06 },
                Ice: { baseFreq: 200, modFreq: 0.5, type: 'sine', volume: 0.07 },
                Volcanic: { baseFreq: 60, modFreq: 0.2, type: 'triangle', volume: 0.09 },
                Alien: { baseFreq: 150, modFreq: 0.8, type: 'sawtooth', volume: 0.05 }
            },

            startAmbient(biome) {
                if (!this.enabled || !this.ctx || this.currentBiome === biome) return;
                this.stopAmbient();
                this.currentBiome = biome;
                this.resume();

                const config = this.biomeAmbient[biome] || this.biomeAmbient.Terra;

                // Create ambient drone
                this.ambientNode = this.ctx.createOscillator();
                this.ambientGain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();

                // LFO for subtle modulation
                const lfo = this.ctx.createOscillator();
                const lfoGain = this.ctx.createGain();
                lfo.frequency.value = config.modFreq;
                lfoGain.gain.value = config.baseFreq * 0.1;
                lfo.connect(lfoGain);
                lfoGain.connect(this.ambientNode.frequency);
                lfo.start();

                this.ambientNode.type = config.type;
                this.ambientNode.frequency.value = config.baseFreq;

                filter.type = 'lowpass';
                filter.frequency.value = 300;
                filter.Q.value = 1;

                this.ambientGain.gain.value = config.volume * this.masterVolume;

                this.ambientNode.connect(filter);
                filter.connect(this.ambientGain);
                this.ambientGain.connect(this.ctx.destination);
                this.ambientNode.start();

                // Store LFO for cleanup
                this.ambientLfo = lfo;
                this.ambientLfoGain = lfoGain;
            },

            stopAmbient() {
                if (this.ambientNode) {
                    try {
                        this.ambientNode.stop();
                        this.ambientNode.disconnect();
                        if (this.ambientLfo) {
                            this.ambientLfo.stop();
                            this.ambientLfo.disconnect();
                        }
                    } catch (e) {}
                    this.ambientNode = null;
                    this.ambientLfo = null;
                    this.currentBiome = null;
                }
            },

            bossSpawn() {
                // Dramatic boss spawn sound
                [100, 80, 60, 40].forEach((f, i) => {
                    setTimeout(() => this.playTone(f, 0.3, 'sawtooth', 0.6), i * 100);
                });
            },

            // v4.5: Dodge and telegraph sounds
            dodge() {
                this.playTone(400, 0.08, 'sine', 0.3);
                this.playTone(600, 0.06, 'sine', 0.2);
            },
            telegraph() {
                this.playTone(200, 0.15, 'square', 0.2);
            },
            recipeDiscovered() {
                [600, 800, 1000].forEach((f, i) => {
                    setTimeout(() => this.playTone(f, 0.12, 'triangle', 0.4), i * 60);
                });
            }
        };

        // --- PARTICLE SYSTEM ---
        class ParticleSystem {
            constructor() {
                this.particles = [];
                this.maxParticles = 200;
            }

            emit(position, count, color, options = {}) {
                const spread = options.spread || 3;
                const lifetime = options.lifetime || 1000;
                const size = options.size || 0.2;
                const gravity = options.gravity !== undefined ? options.gravity : 10;

                for (let i = 0; i < count && this.particles.length < this.maxParticles; i++) {
                    const particle = {
                        mesh: new THREE.Mesh(
                            new THREE.SphereGeometry(size, 4, 4),
                            new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 1 })
                        ),
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * spread,
                            Math.random() * spread * 0.8 + spread * 0.2,
                            (Math.random() - 0.5) * spread
                        ),
                        lifetime,
                        startTime: performance.now(),
                        gravity
                    };
                    particle.mesh.position.copy(position);
                    particle.mesh.position.y += 1;
                    scene.add(particle.mesh);
                    this.particles.push(particle);
                }
            }

            update(dt) {
                const now = performance.now();
                this.particles = this.particles.filter(p => {
                    const elapsed = now - p.startTime;
                    const progress = elapsed / p.lifetime;

                    if (progress >= 1) {
                        scene.remove(p.mesh);
                        p.mesh.geometry.dispose();
                        p.mesh.material.dispose();
                        return false;
                    }

                    // Physics
                    p.velocity.y -= p.gravity * dt;
                    p.mesh.position.add(p.velocity.clone().multiplyScalar(dt));
                    p.mesh.material.opacity = 1 - progress;
                    p.mesh.scale.setScalar(1 - progress * 0.5);

                    return true;
                });
            }
        }

        let particles;

        // v4.4: Hit-Stop System - Freezes game briefly on impacts for satisfying combat
        let hitStopUntil = 0;
        const HIT_STOP_LIGHT = 30;   // Normal hits (ms)
        const HIT_STOP_HEAVY = 80;   // Kills (ms)
        const HIT_STOP_BOSS = 150;   // Boss impacts (ms)

        function triggerHitStop(duration) {
            hitStopUntil = performance.now() + duration;
        }

        // v4.4: Enhanced Hit Flash
        function flashTargetHit(target, flashColor = 0xffffff) {
            const originalMaterials = [];
            target.traverse(child => {
                if (child.material && child.material.color) {
                    originalMaterials.push({
                        mesh: child,
                        color: child.material.color.getHex(),
                        emissive: child.material.emissive?.getHex() || 0,
                        emissiveIntensity: child.material.emissiveIntensity || 0
                    });
                    child.material.color.setHex(flashColor);
                    if (child.material.emissive) {
                        child.material.emissive.setHex(flashColor);
                        child.material.emissiveIntensity = 1;
                    }
                }
            });

            setTimeout(() => {
                originalMaterials.forEach(data => {
                    if (data.mesh.material) {
                        data.mesh.material.color.setHex(data.color);
                        if (data.mesh.material.emissive) {
                            data.mesh.material.emissive.setHex(data.emissive);
                            data.mesh.material.emissiveIntensity = data.emissiveIntensity;
                        }
                    }
                });
            }, 50);
        }

        // v4.4: Environmental Particle System
        class EnvironmentParticles {
            constructor() {
                this.particles = [];
                this.maxParticles = 60;
                this.currentBiome = null;
                this.biomeConfigs = {
                    Terra: { color: 0x88aa44, count: 20, speed: 1.5, type: 'leaves', gravity: 2 },
                    Desert: { color: 0xddcc99, count: 30, speed: 3, type: 'dust', gravity: 0.5 },
                    Ice: { color: 0xeeffff, count: 40, speed: 0.8, type: 'snow', gravity: 1 },
                    Volcanic: { color: 0xff4400, count: 25, speed: 4, type: 'embers', gravity: -3 },
                    Alien: { color: 0xff00ff, count: 20, speed: 1, type: 'spores', gravity: -0.5 }
                };
            }

            startBiome(biome) {
                if (this.currentBiome === biome) return;
                this.stop();
                this.currentBiome = biome;
            }

            stop() {
                this.particles.forEach(p => {
                    scene.remove(p.mesh);
                    p.mesh.geometry.dispose();
                    p.mesh.material.dispose();
                });
                this.particles = [];
                this.currentBiome = null;
            }

            update(dt, playerPos) {
                if (!this.currentBiome) return;
                const config = this.biomeConfigs[this.currentBiome];
                if (!config) return;

                // Spawn new particles near player
                while (this.particles.length < config.count) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = 5 + Math.random() * 20;
                    const particle = {
                        mesh: new THREE.Mesh(
                            new THREE.SphereGeometry(0.08, 4, 4),
                            new THREE.MeshBasicMaterial({ color: config.color, transparent: true, opacity: 0.6 })
                        ),
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * config.speed,
                            config.gravity > 0 ? -Math.abs(config.gravity) : config.gravity,
                            (Math.random() - 0.5) * config.speed
                        ),
                        life: 5 + Math.random() * 5
                    };
                    particle.mesh.position.set(
                        playerPos.x + Math.cos(angle) * dist,
                        playerPos.y + 5 + Math.random() * 10,
                        playerPos.z + Math.sin(angle) * dist
                    );
                    scene.add(particle.mesh);
                    this.particles.push(particle);
                }

                // Update particles
                this.particles = this.particles.filter(p => {
                    p.life -= dt;
                    if (p.life <= 0 || p.mesh.position.y < 0) {
                        scene.remove(p.mesh);
                        p.mesh.geometry.dispose();
                        p.mesh.material.dispose();
                        return false;
                    }

                    p.mesh.position.add(p.velocity.clone().multiplyScalar(dt));

                    // Sway for leaves/snow
                    if (config.type === 'leaves' || config.type === 'snow') {
                        p.mesh.position.x += Math.sin(performance.now() * 0.002 + p.life) * 0.02;
                    }

                    // Pulse for spores
                    if (config.type === 'spores') {
                        p.mesh.material.opacity = 0.3 + Math.sin(performance.now() * 0.005) * 0.3;
                    }

                    return true;
                });
            }
        }

        let envParticles;

        // v4.5: Player Dodge System
        const DODGE_CONFIG = {
            DISTANCE: 6,
            DURATION: 180,       // ms
            COOLDOWN: 600,       // ms
            IFRAMES: 150         // invincibility duration in ms
        };

        let dodgeState = {
            active: false,
            direction: new THREE.Vector3(),
            startTime: 0,
            cooldownEnd: 0,
            iframesEnd: 0
        };

        // v4.6: Parry/Counter System
        const PARRY_CONFIG = {
            WINDOW: 250,          // ms before attack lands to trigger parry
            STUN_DURATION: 1500,  // ms enemy is stunned
            CRIT_MULTIPLIER: 2.5, // damage multiplier during crit window
            CRIT_WINDOW: 2000     // ms player has to land crits
        };

        let parryState = {
            critWindowEnd: 0,
            lastParryTime: 0
        };

        // v4.8: Combo Attack System
        const COMBO_CONFIG = {
            WINDOW: 1200,           // ms to chain next hit
            MAX_HITS: 5,            // maximum combo length
            DAMAGE_MULT: [1.0, 1.15, 1.35, 1.6, 2.0],  // damage multiplier per hit
            FINISHER_BONUS: 1.5,    // extra multiplier on max combo hit
            BREAK_ON_DAMAGE: true   // combo breaks if player takes damage
        };

        let comboState = {
            count: 0,
            lastHitTime: 0,
            active: false
        };

        function updateCombo(hitTime) {
            const timeSinceLastHit = hitTime - comboState.lastHitTime;

            if (comboState.active && timeSinceLastHit <= COMBO_CONFIG.WINDOW) {
                // Continue combo
                comboState.count = Math.min(comboState.count + 1, COMBO_CONFIG.MAX_HITS - 1);
            } else {
                // Start new combo
                comboState.count = 0;
                comboState.active = true;
            }
            comboState.lastHitTime = hitTime;

            return comboState.count;
        }

        function getComboMultiplier() {
            if (!comboState.active) return 1.0;
            let mult = COMBO_CONFIG.DAMAGE_MULT[comboState.count] || COMBO_CONFIG.DAMAGE_MULT[COMBO_CONFIG.MAX_HITS - 1];
            // Finisher bonus at max combo
            if (comboState.count >= COMBO_CONFIG.MAX_HITS - 1) {
                mult *= COMBO_CONFIG.FINISHER_BONUS;
            }
            return mult;
        }

        function breakCombo() {
            if (comboState.active) {
                comboState.active = false;
                comboState.count = 0;
            }
        }

        // v4.8: Combat Abilities System
        const COMBAT_ABILITIES = {
            powerStrike: {
                name: 'Power Strike',
                key: 'Q',
                icon: 'âš”ï¸',
                cooldown: 8000,       // 8 seconds
                unlockLevel: 3,       // Combat level 3
                damageMultiplier: 3,
                description: '3x damage attack'
            },
            whirlwind: {
                name: 'Whirlwind',
                key: 'E',
                icon: 'ðŸŒ€',
                cooldown: 12000,      // 12 seconds
                unlockLevel: 5,       // Combat level 5
                radius: 8,
                damageMultiplier: 1.5,
                description: 'AoE damage to all nearby enemies'
            },
            warcry: {
                name: 'War Cry',
                key: 'R',
                icon: 'ðŸ“¢',
                cooldown: 20000,      // 20 seconds
                unlockLevel: 7,       // Combat level 7
                duration: 5000,       // 5 second buff
                damageBoost: 1.5,
                description: '+50% damage for 5 seconds'
            },
            // v4.9: Tier 2 Abilities
            heal: {
                name: 'Battle Heal',
                key: 'T',
                icon: 'ðŸ’š',
                cooldown: 15000,      // 15 seconds
                unlockLevel: 9,       // Combat level 9
                healAmount: 0.3,      // 30% of max HP
                description: 'Restore 30% of max HP'
            },
            dash: {
                name: 'Combat Dash',
                key: 'F',
                icon: 'ðŸ’¨',
                cooldown: 6000,       // 6 seconds
                unlockLevel: 10,      // Combat level 10
                distance: 8,
                damageMultiplier: 1.2,
                description: 'Dash forward, damaging enemies in path'
            },
            shieldWall: {
                name: 'Shield Wall',
                key: 'Z',
                icon: 'ðŸ›¡ï¸',
                cooldown: 25000,      // 25 seconds
                unlockLevel: 12,      // Combat level 12
                duration: 4000,       // 4 seconds
                damageReduction: 0.7, // 70% damage reduction
                description: '70% damage reduction for 4 seconds'
            },
            execute: {
                name: 'Execute',
                key: 'X',
                icon: 'ðŸ’€',
                cooldown: 10000,      // 10 seconds
                unlockLevel: 15,      // Combat level 15
                threshold: 0.3,       // Below 30% HP
                damageMultiplier: 5,  // 5x damage to low HP targets
                description: '5x damage to enemies below 30% HP'
            },
            berserk: {
                name: 'Berserker Rage',
                key: 'C',
                icon: 'ðŸ”¥',
                cooldown: 45000,      // 45 seconds (ultimate)
                unlockLevel: 20,      // Combat level 20
                duration: 8000,       // 8 seconds
                damageBoost: 2.0,     // 100% more damage
                attackSpeedBoost: 1.5,// 50% faster attacks
                description: 'ULTIMATE: +100% damage, +50% attack speed for 8s'
            }
        };

        let abilityState = {
            powerStrike: { lastUsed: 0 },
            whirlwind: { lastUsed: 0 },
            warcry: { lastUsed: 0, activeUntil: 0 },
            // v4.9: Tier 2 ability states
            heal: { lastUsed: 0 },
            dash: { lastUsed: 0 },
            shieldWall: { lastUsed: 0, activeUntil: 0 },
            execute: { lastUsed: 0 },
            berserk: { lastUsed: 0, activeUntil: 0 }
        };

        function isAbilityUnlocked(abilityKey) {
            const ability = COMBAT_ABILITIES[abilityKey];
            return gameData.skills.combat.level >= ability.unlockLevel;
        }

        function isAbilityReady(abilityKey) {
            const ability = COMBAT_ABILITIES[abilityKey];
            return performance.now() - abilityState[abilityKey].lastUsed >= ability.cooldown;
        }

        function getAbilityCooldownRemaining(abilityKey) {
            const ability = COMBAT_ABILITIES[abilityKey];
            const elapsed = performance.now() - abilityState[abilityKey].lastUsed;
            return Math.max(0, ability.cooldown - elapsed);
        }

        function useAbility(abilityKey) {
            if (!isAbilityUnlocked(abilityKey)) {
                showNotification(`${COMBAT_ABILITIES[abilityKey].name} unlocks at Combat Lv ${COMBAT_ABILITIES[abilityKey].unlockLevel}`, 'warning');
                return false;
            }
            if (!isAbilityReady(abilityKey)) {
                return false;
            }
            if (mode !== 'world' || !worldState.player) return false;

            const ability = COMBAT_ABILITIES[abilityKey];
            const p = worldState.player;
            const now = performance.now();

            abilityState[abilityKey].lastUsed = now;
            // v5.0: Track ability usage for quests
            trackAbilityUsage();

            if (abilityKey === 'powerStrike') {
                // Find nearest mob and deal massive damage
                let nearestMob = null;
                let nearestDist = 5; // Range limit
                worldState.mobs.forEach(mob => {
                    const dist = mob.position.distanceTo(p.position);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearestMob = mob;
                    }
                });
                if (nearestMob) {
                    const damage = Math.floor(getPlayerDamage() * ability.damageMultiplier);
                    nearestMob.userData.hp -= damage;
                    spawnFloater(nearestMob.position, `${ability.icon} POWER STRIKE! -${damage}`, '#ff4400');
                    triggerHitStop(HIT_STOP_BOSS);
                    screenShake(1.0);
                    if (particles) particles.emit(nearestMob.position, 25, 0xff4400, { spread: 4, lifetime: 800 });
                    AudioSystem.hit();
                    // Check kill
                    if (nearestMob.userData.hp <= 0) {
                        performAction(nearestMob);
                    }
                } else {
                    showNotification('No enemy in range!', 'warning');
                    abilityState[abilityKey].lastUsed = 0; // Refund cooldown
                    return false;
                }
            } else if (abilityKey === 'whirlwind') {
                // AoE damage to all nearby mobs
                let hitCount = 0;
                worldState.mobs.forEach(mob => {
                    const dist = mob.position.distanceTo(p.position);
                    if (dist < ability.radius) {
                        const damage = Math.floor(getPlayerDamage() * ability.damageMultiplier);
                        mob.userData.hp -= damage;
                        spawnFloater(mob.position, `${ability.icon} -${damage}`, '#00ffff');
                        hitCount++;
                        if (mob.userData.hp <= 0) {
                            // Queue for death handling
                            setTimeout(() => {
                                if (mob.userData.hp <= 0) performAction(mob);
                            }, 100);
                        }
                    }
                });
                if (hitCount > 0) {
                    spawnFloater(p.position, `${ability.icon} WHIRLWIND! x${hitCount}`, '#00ffff');
                    triggerHitStop(HIT_STOP_HEAVY);
                    screenShake(0.8);
                    if (particles) particles.emit(p.position, 40, 0x00ffff, { spread: ability.radius, lifetime: 600 });
                    AudioSystem.hit();
                } else {
                    showNotification('No enemies nearby!', 'warning');
                    abilityState[abilityKey].lastUsed = 0;
                    return false;
                }
            } else if (abilityKey === 'warcry') {
                // Activate damage buff
                abilityState.warcry.activeUntil = now + ability.duration;
                spawnFloater(p.position, `${ability.icon} WAR CRY!`, '#ff8800');
                showNotification(`+${Math.floor((ability.damageBoost - 1) * 100)}% damage for ${ability.duration / 1000}s!`, 'success');
                if (particles) particles.emit(p.position, 30, 0xff8800, { spread: 6, lifetime: 1000 });
                AudioSystem.levelUp();
            }
            // v4.9: Tier 2 Abilities
            else if (abilityKey === 'heal') {
                // Self heal
                const healAmt = Math.floor(gameData.player.maxHp * ability.healAmount);
                gameData.player.hp = Math.min(gameData.player.maxHp, gameData.player.hp + healAmt);
                spawnFloater(p.position, `${ability.icon} +${healAmt} HP`, '#00ff88');
                showNotification(`Healed ${healAmt} HP!`, 'success');
                if (particles) particles.emit(p.position, 20, 0x00ff88, { spread: 3, lifetime: 800 });
                updateHealthUI();
                AudioSystem.levelUp();
            } else if (abilityKey === 'dash') {
                // Combat dash - move forward and damage enemies in path
                const dir = new THREE.Vector3(0, 0, -1);
                dir.applyQuaternion(p.quaternion);
                const startPos = p.position.clone();
                const endPos = p.position.clone().add(dir.multiplyScalar(ability.distance));

                // Damage enemies in path
                let dashHits = 0;
                worldState.mobs.forEach(mob => {
                    const mobPos = mob.position.clone();
                    // Check if mob is roughly between start and end
                    const toMob = mobPos.sub(startPos);
                    const projection = toMob.dot(dir.clone().normalize());
                    if (projection > 0 && projection < ability.distance) {
                        const perpDist = toMob.clone().sub(dir.clone().normalize().multiplyScalar(projection)).length();
                        if (perpDist < 2) {
                            const damage = Math.floor(getPlayerDamage() * ability.damageMultiplier);
                            mob.userData.hp -= damage;
                            spawnFloater(mob.position, `${ability.icon} -${damage}`, '#88ffff');
                            dashHits++;
                            if (mob.userData.hp <= 0) {
                                setTimeout(() => { if (mob.userData.hp <= 0) performAction(mob); }, 100);
                            }
                        }
                    }
                });

                // Move player
                p.position.copy(endPos);
                spawnFloater(p.position, `${ability.icon} DASH!`, '#88ffff');
                if (dashHits > 0) {
                    showNotification(`Dash hit ${dashHits} enemies!`, 'success');
                    triggerHitStop(HIT_STOP_LIGHT);
                }
                if (particles) particles.emit(startPos, 15, 0x88ffff, { spread: 2, lifetime: 400 });
                AudioSystem.hit();
            } else if (abilityKey === 'shieldWall') {
                // Activate damage reduction buff
                abilityState.shieldWall.activeUntil = now + ability.duration;
                spawnFloater(p.position, `${ability.icon} SHIELD WALL!`, '#4488ff');
                showNotification(`${Math.floor(ability.damageReduction * 100)}% damage reduction for ${ability.duration / 1000}s!`, 'success');
                if (particles) particles.emit(p.position, 25, 0x4488ff, { spread: 4, lifetime: 1000 });
                AudioSystem.levelUp();
            } else if (abilityKey === 'execute') {
                // High damage to low HP enemies
                let target = null;
                let nearestDist = 6;
                worldState.mobs.forEach(mob => {
                    const dist = mob.position.distanceTo(p.position);
                    const hpPercent = mob.userData.hp / mob.userData.maxHp;
                    if (dist < nearestDist && hpPercent <= ability.threshold) {
                        nearestDist = dist;
                        target = mob;
                    }
                });
                if (target) {
                    const damage = Math.floor(getPlayerDamage() * ability.damageMultiplier);
                    target.userData.hp -= damage;
                    spawnFloater(target.position, `${ability.icon} EXECUTE! -${damage}`, '#ff0044');
                    triggerHitStop(HIT_STOP_BOSS);
                    screenShake(1.2);
                    if (particles) particles.emit(target.position, 35, 0xff0044, { spread: 5, lifetime: 1000 });
                    AudioSystem.hit();
                    if (target.userData.hp <= 0) {
                        performAction(target);
                    }
                } else {
                    showNotification('No low HP enemies in range!', 'warning');
                    abilityState[abilityKey].lastUsed = 0;
                    return false;
                }
            } else if (abilityKey === 'berserk') {
                // ULTIMATE: Massive damage and attack speed buff
                abilityState.berserk.activeUntil = now + ability.duration;
                spawnFloater(p.position, `${ability.icon} BERSERKER RAGE!`, '#ff4400');
                showNotification(`BERSERK! +100% DMG, +50% Attack Speed for ${ability.duration / 1000}s!`, 'success');
                screenShake(1.5);
                if (particles) particles.emit(p.position, 50, 0xff4400, { spread: 8, lifetime: 1500 });
                AudioSystem.levelUp();
            }

            updateAbilityUI();
            return true;
        }

        function isWarcryActive() {
            return performance.now() < abilityState.warcry.activeUntil;
        }

        // v4.9: Check if Shield Wall is active
        function isShieldWallActive() {
            return performance.now() < abilityState.shieldWall.activeUntil;
        }

        // v4.9: Check if Berserk is active
        function isBerserkActive() {
            return performance.now() < abilityState.berserk.activeUntil;
        }

        function startDodge() {
            if (dodgeState.active || performance.now() < dodgeState.cooldownEnd) return false;
            if (mode !== 'world' || !worldState.player) return false;

            const p = worldState.player;
            dodgeState.active = true;
            dodgeState.startTime = performance.now();
            dodgeState.cooldownEnd = performance.now() + DODGE_CONFIG.COOLDOWN;
            dodgeState.iframesEnd = performance.now() + DODGE_CONFIG.IFRAMES;

            // Direction based on current input or facing
            dodgeState.direction.set(0, 0, 0);
            if (keys.w) dodgeState.direction.z -= 1;
            if (keys.s) dodgeState.direction.z += 1;
            if (keys.a) dodgeState.direction.x -= 1;
            if (keys.d) dodgeState.direction.x += 1;

            // Also check joystick
            if (dodgeState.direction.length() < 0.1 && joystickActive) {
                dodgeState.direction.set(joystickInput.x, 0, joystickInput.y);
            }

            // Default to backward if no input
            if (dodgeState.direction.length() < 0.1) {
                dodgeState.direction.set(-Math.sin(p.rotation.y), 0, -Math.cos(p.rotation.y));
            }
            dodgeState.direction.normalize();

            AudioSystem.dodge();
            if (particles) particles.emit(p.position, 10, 0x88ffff, { spread: 2, lifetime: 300, gravity: 0 });

            // v4.6: Check for parry opportunity
            checkParryTiming();

            return true;
        }

        function updateDodge(dt) {
            if (!dodgeState.active) return;

            const elapsed = performance.now() - dodgeState.startTime;
            const progress = elapsed / DODGE_CONFIG.DURATION;

            if (progress < 1) {
                const eased = 1 - Math.pow(1 - progress, 3);
                const moveAmount = (1 - eased) * DODGE_CONFIG.DISTANCE * dt * 10;
                worldState.player.position.add(dodgeState.direction.clone().multiplyScalar(moveAmount));
            } else {
                dodgeState.active = false;
            }
        }

        function isInvincible() {
            return performance.now() < dodgeState.iframesEnd;
        }

        // v4.6: Check if dodge was timed for a parry
        function checkParryTiming() {
            if (!worldState || !worldState.mobs) return;

            const now = performance.now();
            let parried = false;

            worldState.mobs.forEach(mob => {
                if (mob.userData.telegraphing && !mob.userData.stunned) {
                    const timeToAttack = mob.userData.telegraphEnd - now;
                    // Check if dodge was in the parry window (last PARRY_CONFIG.WINDOW ms before attack)
                    if (timeToAttack > 0 && timeToAttack <= PARRY_CONFIG.WINDOW) {
                        // Perfect parry!
                        mob.userData.stunned = true;
                        mob.userData.stunEnd = now + PARRY_CONFIG.STUN_DURATION;
                        mob.userData.telegraphing = false;

                        // Visual feedback
                        mob.material.emissive.setHex(0xffff00); // Yellow stun
                        mob.scale.setScalar(1);
                        spawnFloater(mob.position, 'âš¡ PARRY!', '#ffd700');

                        parried = true;
                    }
                }
            });

            if (parried) {
                // Grant crit window
                parryState.critWindowEnd = now + PARRY_CONFIG.CRIT_WINDOW;
                parryState.lastParryTime = now;

                // Audio feedback
                AudioSystem.levelUp();

                // Screen effect
                screenShake(0.3);
                if (particles) particles.emit(worldState.player.position, 25, 0xffd700, { spread: 4, lifetime: 500 });

                showNotification('PERFECT PARRY! Critical hits enabled!');
            }
        }

        // v4.6: Check if in crit window from parry
        function isInCritWindow() {
            return performance.now() < parryState.critWindowEnd;
        }

        // --- ENGINE CORE ---
        const CONFIG = {
            GALAXY_SIZE: 3000,
            NUM_CIVS: 60,
            WORLD_SIZE: 100,
            TILE_SIZE: 2,
            PLAYER_MAX_HP: 100,
            MOB_DAMAGE: 5,
            AUTOSAVE_INTERVAL: 30000, // 30 seconds
            // New v4.0 constants
            MOB_AGGRO_RANGE: 15,
            MOB_ATTACK_RANGE: 2,
            MOB_ATTACK_COOLDOWN: 1500,
            INTERACTION_RANGE: 3.5,
            INTERACTION_COOLDOWN: 400, // ms between actions
            MOVEMENT_THRESHOLD: 0.5,
            SCREEN_SHAKE_INTENSITY: 0.5,
            SCREEN_SHAKE_DURATION: 150
        };

        // v4.7: Player state for status effects
        const playerState = {
            chilled: false,
            chilledEnd: 0,
            moveSpeedMult: 1.0
        };

        // --- PRE-ALLOCATED REUSABLE OBJECTS ---
        const _tempVec3A = new THREE.Vector3();
        const _tempVec3B = new THREE.Vector3();
        const _camOffset = new THREE.Vector3(0, 25, 25);

        // --- SCREEN EFFECTS ---
        let screenShakeIntensity = 0;
        let screenShakeDecay = 0;
        let originalCameraPos = null;

        function screenShake(intensity = CONFIG.SCREEN_SHAKE_INTENSITY) {
            // v4.6: Check settings
            if (gameData.settings && !gameData.settings.screenShakeEnabled) return;
            screenShakeIntensity = intensity;
            screenShakeDecay = intensity / (CONFIG.SCREEN_SHAKE_DURATION / 16);
            if (!originalCameraPos) originalCameraPos = new THREE.Vector3();
        }

        function updateScreenShake() {
            if (screenShakeIntensity > 0 && mode === 'world') {
                camera.position.x += (Math.random() - 0.5) * screenShakeIntensity;
                camera.position.y += (Math.random() - 0.5) * screenShakeIntensity;
                screenShakeIntensity -= screenShakeDecay;
                if (screenShakeIntensity < 0) screenShakeIntensity = 0;
            }
        }

        // Damage flash overlay
        function flashDamageOverlay() {
            const overlay = document.getElementById('damage-overlay');
            if (overlay) {
                overlay.style.opacity = '0.4';
                setTimeout(() => overlay.style.opacity = '0', 150);
            }
        }

        // v4.1: Create nebula clouds for galaxy atmosphere
        function createNebulae() {
            const nebulaColors = [0xff3366, 0x3366ff, 0x66ff33, 0xff6633, 0x9933ff, 0x33ffff];
            const nebulaCount = 6;

            for (let i = 0; i < nebulaCount; i++) {
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 256;
                const ctx = canvas.getContext('2d');

                // Create procedural nebula with radial gradients
                const color = nebulaColors[i % nebulaColors.length];
                const r = (color >> 16) & 255;
                const g = (color >> 8) & 255;
                const b = color & 255;

                // Multiple overlapping gradients for organic look
                for (let j = 0; j < 3; j++) {
                    const cx = 80 + Math.random() * 96;
                    const cy = 80 + Math.random() * 96;
                    const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, 100 + Math.random() * 56);
                    gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, 0.25)`);
                    gradient.addColorStop(0.4, `rgba(${r}, ${g}, ${b}, 0.1)`);
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, 256, 256);
                }

                const texture = new THREE.CanvasTexture(canvas);
                const material = new THREE.MeshBasicMaterial({
                    map: texture,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    side: THREE.DoubleSide,
                    depthWrite: false,
                    opacity: 0.6
                });

                const geometry = new THREE.PlaneGeometry(600, 600);
                const nebula = new THREE.Mesh(geometry, material);

                // Position nebulae around the galaxy
                const angle = (i / nebulaCount) * Math.PI * 2;
                const dist = 400 + Math.random() * 600;
                nebula.position.set(
                    Math.cos(angle) * dist,
                    (Math.random() - 0.5) * 300,
                    Math.sin(angle) * dist
                );

                // Random rotation
                nebula.rotation.set(
                    Math.random() * Math.PI,
                    Math.random() * Math.PI,
                    Math.random() * Math.PI
                );

                scene.add(nebula);
            }
        }

        const BIOMES = {
            Terra: { sky: 0x87ceeb, ground: 0x33aa33, tree: 0x228b22, rock: 0x888888, water: 0x2244aa, name: 'Terra' },
            Desert: { sky: 0xffcc99, ground: 0xeeddaa, tree: 0xccbb99, rock: 0xaa5522, water: 0x446688, name: 'Desert' },
            Ice: { sky: 0xddeeff, ground: 0xffffff, tree: 0xaaccff, rock: 0x99aabb, water: 0x88aadd, name: 'Tundra' },
            Alien: { sky: 0x220044, ground: 0x440066, tree: 0xff00ff, rock: 0x00ffcc, water: 0x8800ff, name: 'Xeno' },
            Volcanic: { sky: 0x330000, ground: 0x221111, tree: 0x552222, rock: 0x111111, water: 0xff4400, name: 'Magma' }
        };

        // v4.2: Enemy Variety System - Biome-specific enemies
        // v4.5: Added attack telegraphing parameters
        const ENEMY_TYPES = {
            Slime: {
                hp: 10, damage: 5, speed: 4, color: 0x44ff44, emissive: 0x003300,
                drops: ['Slime'], xp: 100, biomes: ['Terra', 'Alien'],
                attackWindup: 800, attackRange: 2.5  // v4.5: Telegraph timing
            },
            Scorpion: {
                hp: 15, damage: 8, speed: 5, color: 0xdd9944, emissive: 0x442200,
                drops: ['Chitin'], xp: 150, biomes: ['Desert'],
                attackWindup: 600, attackRange: 3.0
            },
            IceWisp: {
                hp: 8, damage: 6, speed: 7, color: 0x88ccff, emissive: 0x002244,
                drops: ['Frost Shard'], xp: 120, biomes: ['Ice'],
                attackWindup: 500, attackRange: 4.0  // Fast ranged
            },
            MagmaCore: {
                hp: 20, damage: 10, speed: 3, color: 0xff4400, emissive: 0x440000,
                drops: ['Magma Gem'], xp: 180, biomes: ['Volcanic'],
                attackWindup: 1200, attackRange: 3.5  // Slow heavy
            },
            VoidSpawn: {
                hp: 25, damage: 12, speed: 5, color: 0x8800ff, emissive: 0x220044,
                drops: ['Void Fragment'], xp: 250, biomes: ['Alien'],
                attackWindup: 700, attackRange: 3.0
            }
        };

        // v4.6: Elemental Status Effects System
        const STATUS_EFFECTS = {
            ice: {
                name: 'Frozen',
                duration: 3000,
                color: 0x88ccff,
                icon: 'â„ï¸',
                speedMod: 0.3  // Slows to 30% speed
            },
            fire: {
                name: 'Burning',
                duration: 4000,
                color: 0xff4400,
                icon: 'ðŸ”¥',
                tickRate: 500,
                tickDamage: 2
            },
            void: {
                name: 'Weakened',
                duration: 5000,
                color: 0x8800ff,
                icon: 'ðŸ’œ',
                damageMod: 0.5  // Enemy deals 50% damage
            },
            cosmic: {
                name: 'Annihilated',
                duration: 3000,
                color: 0xffd700,
                icon: 'âœ¨',
                tickRate: 250,
                tickDamage: 5,
                speedMod: 0.5
            }
        };

        // v4.7: Elite Enemy System - Affixes that modify enemy behavior
        const ELITE_AFFIXES = {
            swift: {
                name: 'Swift',
                prefix: 'âš¡',
                color: 0x00ffff,
                speedMult: 1.8,
                hpMult: 1.2,
                damageMult: 1.0,
                description: 'Moves much faster'
            },
            armored: {
                name: 'Armored',
                prefix: 'ðŸ›¡ï¸',
                color: 0x888888,
                speedMult: 0.8,
                hpMult: 3.0,
                damageMult: 1.0,
                description: 'Extremely tough'
            },
            vampiric: {
                name: 'Vampiric',
                prefix: 'ðŸ¦‡',
                color: 0x990000,
                speedMult: 1.0,
                hpMult: 1.5,
                damageMult: 1.2,
                lifesteal: 0.3,
                description: 'Heals on hit'
            },
            explosive: {
                name: 'Explosive',
                prefix: 'ðŸ’¥',
                color: 0xff6600,
                speedMult: 1.0,
                hpMult: 1.5,
                damageMult: 0.8,
                explodeOnDeath: true,
                description: 'Explodes on death'
            },
            berserker: {
                name: 'Berserker',
                prefix: 'ðŸ˜¤',
                color: 0xff0000,
                speedMult: 1.2,
                hpMult: 1.0,
                damageMult: 2.0,
                description: 'Deals double damage'
            },
            regenerating: {
                name: 'Regenerating',
                prefix: 'ðŸ’š',
                color: 0x00ff00,
                speedMult: 1.0,
                hpMult: 1.8,
                damageMult: 1.0,
                regenRate: 0.02,
                description: 'Regenerates health'
            },
            teleporter: {
                name: 'Teleporter',
                prefix: 'ðŸŒ€',
                color: 0x9900ff,
                speedMult: 0.9,
                hpMult: 1.3,
                damageMult: 1.3,
                canTeleport: true,
                description: 'Blinks around'
            },
            frozen: {
                name: 'Frozen',
                prefix: 'â„ï¸',
                color: 0x88ddff,
                speedMult: 0.7,
                hpMult: 2.0,
                damageMult: 1.1,
                chillingAura: true,
                description: 'Slows nearby player'
            }
        };

        const ELITE_CONFIG = {
            spawnChance: 0.15,        // 15% chance for elite
            minWorldLevel: 2,         // Only spawn in world level 2+
            essenceDropChance: 0.8,   // 80% chance to drop elite essence
            bonusXpMult: 2.5,         // 2.5x XP from elites
            bonusDropMult: 2          // Double drops from elites
        };

        // v4.7: Session Rewards - Welcome back bonuses
        const SESSION_REWARDS = {
            tiers: [
                { minHours: 1, xpBonus: 50, resources: { 'Slime': 2 }, message: 'Quick break bonus!' },
                { minHours: 4, xpBonus: 150, resources: { 'Ore': 3, 'Log': 3 }, message: 'Gone a while bonus!' },
                { minHours: 12, xpBonus: 400, resources: { 'Ore': 8, 'Log': 8, 'Health Potion': 2 }, message: 'Half-day bonus!' },
                { minHours: 24, xpBonus: 1000, resources: { 'Crystal': 2, 'Mystic Orb': 1, 'Health Potion': 3 }, message: 'Daily login bonus!' },
                { minHours: 72, xpBonus: 3000, resources: { 'Elite Essence': 5, 'Legendary Core': 1, 'Super Potion': 2 }, message: 'We missed you bonus!' }
            ],
            maxOfflineHours: 168 // Cap at 1 week
        };

        // v4.6: Get equipped weapon element
        function getEquippedElement() {
            const weapons = ['Legendary Blade', 'Void Dagger', 'Magma Sword', 'Frost Blade'];
            for (const weapon of weapons) {
                if (hasItem(weapon)) {
                    return ITEMS[weapon].element || null;
                }
            }
            return null;
        }

        // v4.6: Apply status effect to mob
        function applyStatusEffect(mob, element) {
            const effect = STATUS_EFFECTS[element];
            if (!effect) return;

            const data = mob.userData;
            data.statusEffects = data.statusEffects || {};

            // Only apply if not already affected by this element
            if (data.statusEffects[element]) return;

            data.statusEffects[element] = {
                endTime: performance.now() + effect.duration,
                lastTick: performance.now()
            };

            // Apply immediate effects
            if (effect.speedMod) {
                data.speedMultiplier = (data.speedMultiplier || 1) * effect.speedMod;
            }
            if (effect.damageMod) {
                data.damageMultiplier = (data.damageMultiplier || 1) * effect.damageMod;
            }

            // Visual feedback
            mob.material.emissive.setHex(effect.color);
            spawnFloater(mob.position, effect.icon + ' ' + effect.name, '#' + effect.color.toString(16).padStart(6, '0'));
            AudioSystem.hit();
        }

        // v4.6: Update status effects for mob
        function updateMobStatusEffects(mob, time) {
            const data = mob.userData;
            if (!data.statusEffects) return;

            for (const [element, state] of Object.entries(data.statusEffects)) {
                const effect = STATUS_EFFECTS[element];
                if (!effect) continue;

                // Apply DoT
                if (effect.tickDamage && time - state.lastTick >= effect.tickRate) {
                    data.hp -= effect.tickDamage;
                    state.lastTick = time;
                    spawnFloater(mob.position, `-${effect.tickDamage}`, '#' + effect.color.toString(16).padStart(6, '0'));

                    // Check for death by status effect
                    if (data.hp <= 0) {
                        // Will be handled in main mob loop
                    }
                }

                // Check expiration
                if (time >= state.endTime) {
                    // Clear effects
                    if (effect.speedMod) {
                        data.speedMultiplier = (data.speedMultiplier || 1) / effect.speedMod;
                    }
                    if (effect.damageMod) {
                        data.damageMultiplier = (data.damageMultiplier || 1) / effect.damageMod;
                    }
                    delete data.statusEffects[element];

                    // Restore emissive color if no more effects
                    if (Object.keys(data.statusEffects).length === 0) {
                        const originalEmissive = ENEMY_TYPES[data.name]?.emissive || 0x003300;
                        mob.material.emissive.setHex(originalEmissive);
                    }
                }
            }
        }

        // v4.3: Boss Encounter System
        // v4.5: Added gear check requirements and increased mob kill thresholds
        const BOSS_TYPES = {
            'Terra_Boss': {
                name: 'Ancient Guardian',
                hp: 100, damage: 15, speed: 2, scale: 2.5,
                color: 0x228b22, emissive: 0x114411,
                drops: [{ item: 'Boss Trophy', count: 1 }, { item: 'Ancient Artifact', count: 3 }],
                xp: 1000, biome: 'Terra',
                spawnCondition: { mobsKilled: 8, minCombatLevel: 2 },
                attackWindup: 1000, attackRange: 4
            },
            'Desert_Boss': {
                name: 'Sandstorm Titan',
                hp: 120, damage: 18, speed: 3, scale: 2.8,
                color: 0xcc8844, emissive: 0x664422,
                drops: [{ item: 'Boss Trophy', count: 1 }, { item: 'Chitin', count: 10 }],
                xp: 1200, biome: 'Desert',
                spawnCondition: { mobsKilled: 10, minCombatLevel: 3, requiredItem: 'Sword' },
                attackWindup: 900, attackRange: 4.5
            },
            'Ice_Boss': {
                name: 'Frost Monarch',
                hp: 90, damage: 20, speed: 4, scale: 2.2,
                color: 0x88ddff, emissive: 0x4488aa,
                drops: [{ item: 'Boss Trophy', count: 1 }, { item: 'Frost Shard', count: 10 }],
                xp: 1100, biome: 'Ice',
                spawnCondition: { mobsKilled: 10, minCombatLevel: 4 },
                attackWindup: 700, attackRange: 5
            },
            'Volcanic_Boss': {
                name: 'Magma Colossus',
                hp: 150, damage: 25, speed: 1.5, scale: 3,
                color: 0xff4400, emissive: 0xaa2200,
                drops: [{ item: 'Boss Trophy', count: 1 }, { item: 'Magma Gem', count: 10 }],
                xp: 1500, biome: 'Volcanic',
                spawnCondition: { mobsKilled: 12, minCombatLevel: 5, requiredItem: 'Frost Blade' },
                attackWindup: 1500, attackRange: 5
            },
            'Alien_Boss': {
                name: 'Void Leviathan',
                hp: 200, damage: 30, speed: 3, scale: 3.5,
                color: 0x8800ff, emissive: 0x440088,
                drops: [{ item: 'Boss Trophy', count: 2 }, { item: 'Void Fragment', count: 15 }, { item: 'Legendary Core', count: 1 }],
                xp: 2500, biome: 'Alien',
                spawnCondition: { mobsKilled: 15, minCombatLevel: 7, requiredItem: 'Magma Sword' },
                attackWindup: 800, attackRange: 6
            }
        };

        // v4.2: Points of Interest System
        const POI_TYPES = {
            'ancient_ruins': {
                name: 'Ancient Ruins', icon: 'ðŸ›ï¸', rarity: 0.12,
                rewards: [{ item: 'Ancient Artifact', count: 1 }],
                xpBonus: 200, biomes: null
            },
            'crystal_cave': {
                name: 'Crystal Cavern', icon: 'ðŸ’Ž', rarity: 0.10,
                rewards: [{ item: 'Crystal', count: [2, 5] }],
                xpBonus: 150, biomes: ['Ice', 'Alien']
            },
            'oasis': {
                name: 'Hidden Oasis', icon: 'ðŸŒ´', rarity: 0.15,
                rewards: [{ item: 'Healing Spring', count: 1 }],
                xpBonus: 100, biomes: ['Desert']
            },
            'volcano_vent': {
                name: 'Volcanic Vent', icon: 'ðŸŒ‹', rarity: 0.12,
                rewards: [{ item: 'Obsidian', count: [1, 3] }],
                xpBonus: 175, biomes: ['Volcanic']
            },
            'crashed_ship': {
                name: 'Crashed Vessel', icon: 'ðŸ›¸', rarity: 0.06,
                rewards: [{ item: 'Tech Fragment', count: 1 }, { item: 'Power Cell', count: 1 }],
                xpBonus: 300, biomes: null
            },
            'mystic_shrine': {
                name: 'Mystic Shrine', icon: 'â›©ï¸', rarity: 0.08,
                rewards: [{ item: 'Mystic Orb', count: 1 }],
                xpBonus: 250, biomes: ['Terra', 'Alien']
            }
        };

        // v4.2: Player Ranks and Titles
        const PLAYER_RANKS = [
            { points: 0, title: 'Novice Explorer', color: '#888888' },
            { points: 100, title: 'Wanderer', color: '#44ff44' },
            { points: 500, title: 'Pathfinder', color: '#4488ff' },
            { points: 1500, title: 'Star Scout', color: '#ff8844' },
            { points: 5000, title: 'Galaxy Ranger', color: '#ff44ff' },
            { points: 15000, title: 'Cosmic Legend', color: '#ffd700' }
        ];

        const SPECIAL_TITLES = {
            'Slime Bane': { condition: (s, sk) => s.mobsKilled >= 100, color: '#ff4444' },
            'Master Lumberjack': { condition: (s, sk) => sk.wood.level >= 10, color: '#44aa44' },
            'Deep Miner': { condition: (s, sk) => sk.mining.level >= 10, color: '#888888' },
            'Cosmic Wanderer': { condition: (s, sk) => gameData.visitedPlanets.length >= 50, color: '#00ffff' },
            'Combat Master': { condition: (s, sk) => sk.combat.level >= 10, color: '#ff6644' },
            'Master Angler': { condition: (s, sk) => sk.fishing.level >= 10, color: '#4488ff' }
        };

        const ITEMS = {
            // Base resources
            'Log': { icon: 'ðŸªµ', stackable: true, maxStack: 99 },
            'Ore': { icon: 'ðŸª¨', stackable: true, maxStack: 99 },
            'Slime': { icon: 'ðŸŸ¢', stackable: true, maxStack: 99 },
            'Raw Fish': { icon: 'ðŸŸ', stackable: true, maxStack: 99 },
            'Cooked Fish': { icon: 'ðŸ–', stackable: true, maxStack: 99, heal: 20 },
            // v4.2: Biome-specific enemy drops
            'Chitin': { icon: 'ðŸ¦‚', stackable: true, maxStack: 99 },
            'Frost Shard': { icon: 'â„ï¸', stackable: true, maxStack: 99 },
            'Magma Gem': { icon: 'ðŸ”¥', stackable: true, maxStack: 99 },
            'Void Fragment': { icon: 'ðŸŒ€', stackable: true, maxStack: 99 },
            // v4.2: POI rewards
            'Ancient Artifact': { icon: 'ðŸº', stackable: true, maxStack: 20 },
            'Crystal': { icon: 'ðŸ’ ', stackable: true, maxStack: 50 },
            'Healing Spring': { icon: 'ðŸ’§', stackable: true, maxStack: 10, heal: 100 },
            'Obsidian': { icon: 'ðŸ–¤', stackable: true, maxStack: 50 },
            'Tech Fragment': { icon: 'ðŸ”§', stackable: true, maxStack: 20 },
            'Power Cell': { icon: 'ðŸ”‹', stackable: true, maxStack: 10 },
            'Mystic Orb': { icon: 'ðŸ”®', stackable: true, maxStack: 10 },
            // Tools
            'Pickaxe': { icon: 'â›ï¸', stackable: false, miningBonus: 2 },
            'Sword': { icon: 'ðŸ—¡ï¸', stackable: false, combatBonus: 5 },
            'Fishing Rod': { icon: 'ðŸŽ£', stackable: false, fishingBonus: 2 },
            'Health Potion': { icon: 'ðŸ§ª', stackable: true, maxStack: 10, heal: 50 },
            // v4.2: New craftables
            'Frost Blade': { icon: 'ðŸ—¡ï¸', stackable: false, combatBonus: 8, element: 'ice' },
            'Magma Sword': { icon: 'ðŸ—¡ï¸', stackable: false, combatBonus: 10, element: 'fire' },
            'Void Dagger': { icon: 'ðŸ—¡ï¸', stackable: false, combatBonus: 12, element: 'void' },
            'Crystal Pickaxe': { icon: 'â›ï¸', stackable: false, miningBonus: 3 },
            'Super Potion': { icon: 'ðŸ§ª', stackable: true, maxStack: 10, heal: 100 },
            'Chitin Armor': { icon: 'ðŸ›¡ï¸', stackable: false, defenseBonus: 5 },
            // v4.3: Boss rewards
            'Boss Trophy': { icon: 'ðŸ†', stackable: true, maxStack: 20 },
            'Legendary Core': { icon: 'ðŸ’Ž', stackable: true, maxStack: 5 },
            // v4.3: Legendary gear (requires boss materials)
            'Legendary Blade': { icon: 'âš”ï¸', stackable: false, combatBonus: 20, element: 'cosmic' },
            'Guardian Armor': { icon: 'ðŸ›¡ï¸', stackable: false, defenseBonus: 15 },
            // v4.7: Elite enemy drops
            'Elite Essence': { icon: 'ðŸ’ ', stackable: true, maxStack: 99 },
            'Berserker Badge': { icon: 'ðŸ”´', stackable: false, combatBonus: 15, attackSpeedMult: 1.3 },
            'Vampiric Fang': { icon: 'ðŸ¦·', stackable: false, combatBonus: 10, lifesteal: 0.15 },
            'Frost Heart': { icon: 'ðŸ’™', stackable: false, defenseBonus: 10, element: 'ice' },
            // v5.1: New craftable equipment
            'Iron Armor': { icon: 'ðŸ›¡ï¸', stackable: false, defenseBonus: 3 },
            'Steel Armor': { icon: 'ðŸ›¡ï¸', stackable: false, defenseBonus: 8 },
            'Lucky Charm': { icon: 'ðŸ€', stackable: false },
            'Swift Boots': { icon: 'ðŸ‘¢', stackable: false },
            'Power Ring': { icon: 'ðŸ’', stackable: false },
            'Master Rod': { icon: 'ðŸŽ£', stackable: false, fishingBonus: 4 },
            // v5.1: Enchantment materials
            'Enchant Shard': { icon: 'âœ¨', stackable: true, maxStack: 50 },
            'Arcane Dust': { icon: 'ðŸ’«', stackable: true, maxStack: 99 },
            // v5.3: Portal realm rewards
            'Shadow Essence': { icon: 'ðŸŒ‘', stackable: true, maxStack: 50 },
            'Dark Crystal': { icon: 'ðŸ”®', stackable: true, maxStack: 30 },
            'Frozen Heart': { icon: 'ðŸ’™', stackable: true, maxStack: 30 },
            'Permafrost Shard': { icon: 'â„ï¸', stackable: true, maxStack: 50 },
            'Infernal Core': { icon: 'ðŸ”¥', stackable: true, maxStack: 30 },
            'Magma Heart': { icon: 'â¤ï¸â€ðŸ”¥', stackable: true, maxStack: 30 },
            'Void Core': { icon: 'ðŸŒ€', stackable: true, maxStack: 20 },
            'Dimension Shard': { icon: 'ðŸ’ ', stackable: true, maxStack: 30 },
            'Celestial Essence': { icon: 'âœ¨', stackable: true, maxStack: 10 },
            'Star Fragment': { icon: 'â­', stackable: true, maxStack: 20 },
            'Mythic Orb': { icon: 'ðŸ”®', stackable: false, combatBonus: 25, element: 'cosmic', defenseBonus: 10 },
            // v5.4: World Event items
            'Meteor Ore': { icon: 'â˜„ï¸', stackable: true, maxStack: 30, description: 'Rare ore from a meteor shower' },
            'Cosmic Dust': { icon: 'ðŸŒŸ', stackable: true, maxStack: 99, description: 'Glittering cosmic particles' },
            'Gold Chest': { icon: 'ðŸ“¦', stackable: true, maxStack: 10, description: 'A treasure chest filled with gold' },
            'Silver Chest': { icon: 'ðŸ“¦', stackable: true, maxStack: 20, description: 'A treasure chest with silver' },
            'Ancient Relic': { icon: 'ðŸ—¿', stackable: true, maxStack: 10, description: 'An ancient relic of power' },
            'Rune Stone': { icon: 'ðŸª¨', stackable: true, maxStack: 20, description: 'Stone inscribed with ancient runes' },
            'Lost Technology': { icon: 'ðŸ”§', stackable: true, maxStack: 10, description: 'Advanced technology from a lost civilization' },
            'Rainbow Crystal': { icon: 'ðŸ’Ž', stackable: true, maxStack: 15, description: 'A crystal that shimmers with all colors' },
            'Pure Crystal': { icon: 'ðŸ’ ', stackable: true, maxStack: 20, description: 'A perfectly pure crystal' },
            'Crystal Shard': { icon: 'ðŸ”¹', stackable: true, maxStack: 50, description: 'A small crystal fragment' }
        };

        const RECIPES = {
            'pickaxe': { result: 'Pickaxe', requires: { 'Ore': 3, 'Log': 2 } },
            'sword': { result: 'Sword', requires: { 'Ore': 5, 'Log': 1 } },
            'rod': { result: 'Fishing Rod', requires: { 'Log': 2 } },
            'cookedFish': { result: 'Cooked Fish', requires: { 'Raw Fish': 1 } },
            'potion': { result: 'Health Potion', requires: { 'Slime': 2 } },
            // v4.2: New recipes using biome materials
            'frostBlade': { result: 'Frost Blade', requires: { 'Ore': 8, 'Frost Shard': 5 }, craftingLevel: 5 },
            'magmaSword': { result: 'Magma Sword', requires: { 'Ore': 10, 'Magma Gem': 5 }, craftingLevel: 7 },
            'voidDagger': { result: 'Void Dagger', requires: { 'Ore': 12, 'Void Fragment': 5 }, craftingLevel: 10 },
            'crystalPickaxe': { result: 'Crystal Pickaxe', requires: { 'Ore': 6, 'Crystal': 3 }, craftingLevel: 6 },
            'superPotion': { result: 'Super Potion', requires: { 'Slime': 3, 'Mystic Orb': 1 }, craftingLevel: 8 },
            'chitinArmor': { result: 'Chitin Armor', requires: { 'Chitin': 10, 'Log': 5 }, craftingLevel: 4 },
            // v4.3: Legendary recipes (requires boss materials)
            'legendaryBlade': { result: 'Legendary Blade', requires: { 'Boss Trophy': 5, 'Legendary Core': 1, 'Ore': 20 }, craftingLevel: 15 },
            'guardianArmor': { result: 'Guardian Armor', requires: { 'Boss Trophy': 3, 'Chitin': 20, 'Crystal': 5 }, craftingLevel: 12 },
            // v4.7: Elite gear recipes
            'berserkerBadge': { result: 'Berserker Badge', requires: { 'Elite Essence': 10, 'Magma Gem': 3 }, craftingLevel: 10 },
            'vampiricFang': { result: 'Vampiric Fang', requires: { 'Elite Essence': 15, 'Void Fragment': 5 }, craftingLevel: 12 },
            'frostHeart': { result: 'Frost Heart', requires: { 'Elite Essence': 12, 'Frost Shard': 8, 'Crystal': 3 }, craftingLevel: 11 },
            // v5.1: New equipment recipes
            'ironArmor': { result: 'Iron Armor', requires: { 'Ore': 8, 'Log': 3 }, craftingLevel: 2 },
            'steelArmor': { result: 'Steel Armor', requires: { 'Ore': 15, 'Crystal': 2 }, craftingLevel: 8 },
            'luckyCharm': { result: 'Lucky Charm', requires: { 'Crystal': 5, 'Mystic Orb': 2 }, craftingLevel: 6 },
            'swiftBoots': { result: 'Swift Boots', requires: { 'Chitin': 8, 'Slime': 5 }, craftingLevel: 5 },
            'powerRing': { result: 'Power Ring', requires: { 'Ore': 10, 'Magma Gem': 3 }, craftingLevel: 7 },
            'masterRod': { result: 'Master Rod', requires: { 'Log': 10, 'Crystal': 3, 'Frost Shard': 2 }, craftingLevel: 9 },
            // v5.1: Enchantment material crafting
            'enchantShard': { result: 'Enchant Shard', requires: { 'Crystal': 3, 'Mystic Orb': 1 }, craftingLevel: 8 },
            'arcaneDust': { result: 'Arcane Dust', requires: { 'Slime': 5, 'Void Fragment': 1 }, craftingLevel: 6 }
        };

        // v5.1: Equipment System
        const EQUIPMENT_SLOTS = {
            weapon: { name: 'Weapon', icon: 'âš”ï¸', statKey: 'combatBonus' },
            armor: { name: 'Armor', icon: 'ðŸ›¡ï¸', statKey: 'defenseBonus' },
            accessory: { name: 'Accessory', icon: 'ðŸ’', statKey: 'special' },
            tool: { name: 'Tool', icon: 'ðŸ”§', statKey: 'toolBonus' }
        };

        // v5.1: Map items to equipment slots
        const EQUIPMENT_MAP = {
            // Weapons
            'Sword': { slot: 'weapon', stats: { damage: 5 } },
            'Frost Blade': { slot: 'weapon', stats: { damage: 8, element: 'ice' } },
            'Magma Sword': { slot: 'weapon', stats: { damage: 10, element: 'fire' } },
            'Void Dagger': { slot: 'weapon', stats: { damage: 12, element: 'void' } },
            'Legendary Blade': { slot: 'weapon', stats: { damage: 20, element: 'cosmic', critChance: 0.15 } },
            // Armor (tiered)
            'Iron Armor': { slot: 'armor', stats: { defense: 3 } },
            'Chitin Armor': { slot: 'armor', stats: { defense: 5 } },
            'Steel Armor': { slot: 'armor', stats: { defense: 8 } },
            'Guardian Armor': { slot: 'armor', stats: { defense: 15, maxHpBonus: 50 } },
            // Accessories
            'Berserker Badge': { slot: 'accessory', stats: { damage: 15, attackSpeed: 1.3 } },
            'Vampiric Fang': { slot: 'accessory', stats: { damage: 10, lifesteal: 0.15 } },
            'Frost Heart': { slot: 'accessory', stats: { defense: 10, element: 'ice' } },
            'Lucky Charm': { slot: 'accessory', stats: { critChance: 0.10, lootBonus: 0.15 } },
            'Swift Boots': { slot: 'accessory', stats: { moveSpeed: 1.15, dodgeBonus: 0.1 } },
            'Power Ring': { slot: 'accessory', stats: { damage: 8, critChance: 0.05 } },
            // Tools
            'Pickaxe': { slot: 'tool', stats: { miningBonus: 2 } },
            'Crystal Pickaxe': { slot: 'tool', stats: { miningBonus: 3 } },
            'Fishing Rod': { slot: 'tool', stats: { fishingBonus: 2 } },
            'Master Rod': { slot: 'tool', stats: { fishingBonus: 4 } }
        };

        // v5.1: Equipment state getter (uses gameData for persistence)
        function getEquippedGear() {
            if (!gameData.equipment) {
                gameData.equipment = { weapon: null, armor: null, accessory: null, tool: null };
            }
            return gameData.equipment;
        }

        // v5.1: Equipment functions
        function isEquippable(itemName) {
            return EQUIPMENT_MAP.hasOwnProperty(itemName);
        }

        function getEquipmentSlot(itemName) {
            return EQUIPMENT_MAP[itemName]?.slot || null;
        }

        function equipItem(itemName) {
            if (!isEquippable(itemName)) {
                showNotification('Cannot equip this item!', 'error');
                return false;
            }

            const slot = getEquipmentSlot(itemName);
            const equipData = EQUIPMENT_MAP[itemName];
            const gear = getEquippedGear();

            // Unequip current item in slot (return to inventory)
            if (gear[slot]) {
                addItem(gear[slot]);
                showNotification(`Unequipped ${gear[slot]}`, 'info');
            }

            // Remove from inventory
            if (!removeItem(itemName, 1)) {
                showNotification('Item not in inventory!', 'error');
                return false;
            }

            // Equip new item
            gear[slot] = itemName;
            showNotification(`Equipped ${itemName}!`, 'success');
            AudioSystem.collect();
            updateEquipmentUI();
            saveGameData();
            return true;
        }

        function unequipItem(slot) {
            const gear = getEquippedGear();
            if (!gear[slot]) return;

            const itemName = gear[slot];
            if (gameData.inventory.length >= 20) {
                showNotification('Inventory full!', 'error');
                return;
            }

            addItem(itemName);
            gear[slot] = null;
            showNotification(`Unequipped ${itemName}`, 'info');
            updateEquipmentUI();
            saveGameData();
        }

        function getEquipmentStats() {
            const stats = {
                damage: 0,
                defense: 0,
                miningBonus: 0,
                fishingBonus: 0,
                attackSpeed: 1.0,
                lifesteal: 0,
                critChance: 0,
                maxHpBonus: 0,
                element: null,
                // v5.1: New stats
                moveSpeed: 1.0,
                lootBonus: 0,
                dodgeBonus: 0
            };

            const gear = getEquippedGear();
            for (const slot of Object.keys(gear)) {
                const itemName = gear[slot];
                if (!itemName) continue;

                const equipData = EQUIPMENT_MAP[itemName];
                if (!equipData) continue;

                for (const [stat, value] of Object.entries(equipData.stats)) {
                    if (stat === 'element') {
                        stats.element = value;
                    } else if (stat === 'attackSpeed' || stat === 'moveSpeed') {
                        // Multiplicative stats
                        stats[stat] *= value;
                    } else {
                        stats[stat] = (stats[stat] || 0) + value;
                    }
                }

                // v5.1: Add enchantment bonuses
                const enchantBonuses = getEnchantmentBonuses(itemName);
                for (const [stat, value] of Object.entries(enchantBonuses)) {
                    if (stat === 'moveSpeed') {
                        stats[stat] *= value; // Multiplicative for move speed enchants
                    } else {
                        stats[stat] = (stats[stat] || 0) + value;
                    }
                }
            }

            return stats;
        }

        function updateEquipmentUI() {
            const gear = getEquippedGear();
            for (const [slot, slotInfo] of Object.entries(EQUIPMENT_SLOTS)) {
                const slotEl = document.getElementById(`equip-slot-${slot}`);
                if (!slotEl) continue;

                const itemName = gear[slot];
                const iconEl = slotEl.querySelector('.equip-icon');
                const nameEl = slotEl.querySelector('.equip-name');

                if (itemName) {
                    const itemDef = ITEMS[itemName];
                    iconEl.textContent = itemDef?.icon || '?';
                    nameEl.textContent = itemName;
                    slotEl.classList.add('equipped');
                } else {
                    iconEl.textContent = slotInfo.icon;
                    nameEl.textContent = 'Empty';
                    slotEl.classList.remove('equipped');
                }
            }

            // Update stats display
            const stats = getEquipmentStats();
            const statsEl = document.getElementById('equipment-stats');
            if (statsEl) {
                let html = `
                    <div style="color: #f44;">âš”ï¸ +${stats.damage} DMG</div>
                    <div style="color: #4af;">ðŸ›¡ï¸ +${stats.defense} DEF</div>
                `;
                if (stats.critChance > 0) html += `<div style="color: #fa4;">ðŸŽ¯ +${Math.round(stats.critChance * 100)}% Crit</div>`;
                if (stats.lifesteal > 0) html += `<div style="color: #4f4;">ðŸ’š ${Math.round(stats.lifesteal * 100)}% Lifesteal</div>`;
                if (stats.attackSpeed !== 1.0) html += `<div style="color: #ff4;">âš¡ ${Math.round(stats.attackSpeed * 100)}% ATK Spd</div>`;
                if (stats.moveSpeed !== 1.0) html += `<div style="color: #8ff;">ðŸ‘¢ ${Math.round(stats.moveSpeed * 100)}% Move Spd</div>`;
                if (stats.lootBonus > 0) html += `<div style="color: #8f8;">ðŸ€ +${Math.round(stats.lootBonus * 100)}% Loot</div>`;
                if (stats.dodgeBonus > 0) html += `<div style="color: #88f;">ðŸ’¨ +${Math.round(stats.dodgeBonus * 100)}% Dodge</div>`;
                statsEl.innerHTML = html;
            }
        }

        // v5.1: Enchantment System
        const ENCHANTMENTS = {
            sharpness: { name: 'Sharpness', icon: 'ðŸ”ª', stat: 'damage', bonus: 3, slots: ['weapon'], cost: { 'Enchant Shard': 2, 'Arcane Dust': 5 } },
            fortify: { name: 'Fortify', icon: 'ðŸ°', stat: 'defense', bonus: 2, slots: ['armor'], cost: { 'Enchant Shard': 2, 'Arcane Dust': 5 } },
            swiftness: { name: 'Swiftness', icon: 'ðŸ’¨', stat: 'moveSpeed', bonus: 0.05, slots: ['accessory'], cost: { 'Enchant Shard': 1, 'Arcane Dust': 3 }, multiplicative: true },
            luck: { name: 'Luck', icon: 'ðŸ€', stat: 'lootBonus', bonus: 0.05, slots: ['accessory'], cost: { 'Enchant Shard': 3, 'Arcane Dust': 8 } },
            efficiency: { name: 'Efficiency', icon: 'âš¡', stat: 'miningBonus', bonus: 1, slots: ['tool'], cost: { 'Enchant Shard': 2, 'Arcane Dust': 4 } },
            lure: { name: 'Lure', icon: 'ðŸŽ£', stat: 'fishingBonus', bonus: 1, slots: ['tool'], cost: { 'Enchant Shard': 2, 'Arcane Dust': 4 } },
            critical: { name: 'Critical', icon: 'ðŸŽ¯', stat: 'critChance', bonus: 0.05, slots: ['weapon', 'accessory'], cost: { 'Enchant Shard': 4, 'Arcane Dust': 10 } },
            vampiric: { name: 'Vampiric', icon: 'ðŸ¦‡', stat: 'lifesteal', bonus: 0.05, slots: ['weapon'], cost: { 'Enchant Shard': 5, 'Arcane Dust': 15 } }
        };

        // v5.1: Get enchantments for an item
        function getItemEnchantments(itemName) {
            if (!gameData.enchantments) gameData.enchantments = {};
            return gameData.enchantments[itemName] || [];
        }

        // v5.1: Check if enchantment can be applied
        function canEnchant(itemName, enchantId) {
            const equipData = EQUIPMENT_MAP[itemName];
            if (!equipData) return false;

            const enchant = ENCHANTMENTS[enchantId];
            if (!enchant) return false;

            // Check slot compatibility
            if (!enchant.slots.includes(equipData.slot)) return false;

            // Check if already has this enchantment
            const currentEnchants = getItemEnchantments(itemName);
            if (currentEnchants.includes(enchantId)) return false;

            // Check max enchantments (3 per item)
            if (currentEnchants.length >= 3) return false;

            // Check materials
            for (const [mat, count] of Object.entries(enchant.cost)) {
                if (!hasItem(mat, count)) return false;
            }

            return true;
        }

        // v5.1: Apply enchantment to item
        function applyEnchantment(itemName, enchantId) {
            if (!canEnchant(itemName, enchantId)) {
                showNotification('Cannot apply this enchantment!', 'error');
                return false;
            }

            const enchant = ENCHANTMENTS[enchantId];

            // Consume materials
            for (const [mat, count] of Object.entries(enchant.cost)) {
                removeItem(mat, count);
            }

            // Apply enchantment
            if (!gameData.enchantments) gameData.enchantments = {};
            if (!gameData.enchantments[itemName]) gameData.enchantments[itemName] = [];
            gameData.enchantments[itemName].push(enchantId);

            showNotification(`Applied ${enchant.icon} ${enchant.name} to ${itemName}!`, 'success');
            AudioSystem.levelUp();
            saveGameData();
            updateEnchantModal();
            updateEquipmentUI();
            return true;
        }

        // v5.1: Get total stats including enchantments
        function getEnchantmentBonuses(itemName) {
            const bonuses = {};
            const enchants = getItemEnchantments(itemName);

            for (const enchantId of enchants) {
                const enchant = ENCHANTMENTS[enchantId];
                if (!enchant) continue;

                if (enchant.multiplicative) {
                    bonuses[enchant.stat] = (bonuses[enchant.stat] || 1) * (1 + enchant.bonus);
                } else {
                    bonuses[enchant.stat] = (bonuses[enchant.stat] || 0) + enchant.bonus;
                }
            }

            return bonuses;
        }

        // v5.1: Show enchant modal
        function showEnchantModal() {
            document.getElementById('enchant-modal').style.display = 'flex';
            updateEnchantModal();
        }

        function closeEnchantModal() {
            document.getElementById('enchant-modal').style.display = 'none';
        }

        function updateEnchantModal() {
            const gear = getEquippedGear();
            const itemsDiv = document.getElementById('enchant-items');
            const enchantsDiv = document.getElementById('enchant-options');

            // List equipped items
            let itemsHtml = '';
            for (const [slot, itemName] of Object.entries(gear)) {
                if (!itemName) continue;
                const itemDef = ITEMS[itemName];
                const enchants = getItemEnchantments(itemName);
                const enchantIcons = enchants.map(e => ENCHANTMENTS[e]?.icon || '?').join('');
                itemsHtml += `
                    <div class="enchant-item" onclick="selectEnchantItem('${itemName}')" data-item="${itemName}"
                         style="display: flex; justify-content: space-between; padding: 8px; border: 1px solid #444;
                                border-radius: 4px; cursor: pointer; margin-bottom: 5px;">
                        <span>${itemDef?.icon || '?'} ${itemName}</span>
                        <span style="color: #8af;">${enchantIcons || 'No enchants'}</span>
                    </div>
                `;
            }
            itemsDiv.innerHTML = itemsHtml || '<div style="color: #888;">Equip items first!</div>';

            // Default: no item selected
            enchantsDiv.innerHTML = '<div style="color: #888;">Select an item to enchant</div>';
        }

        let selectedEnchantItem = null;

        function selectEnchantItem(itemName) {
            selectedEnchantItem = itemName;
            const equipData = EQUIPMENT_MAP[itemName];
            const enchantsDiv = document.getElementById('enchant-options');

            // Highlight selected item
            document.querySelectorAll('.enchant-item').forEach(el => {
                el.style.background = el.dataset.item === itemName ? 'rgba(68, 136, 255, 0.2)' : '';
                el.style.borderColor = el.dataset.item === itemName ? '#4af' : '#444';
            });

            // Show available enchantments
            let html = '<div style="font-weight: bold; margin-bottom: 10px;">Available Enchantments:</div>';

            for (const [id, enchant] of Object.entries(ENCHANTMENTS)) {
                if (!enchant.slots.includes(equipData.slot)) continue;

                const canApply = canEnchant(itemName, id);
                const hasIt = getItemEnchantments(itemName).includes(id);
                const costStr = Object.entries(enchant.cost).map(([m, c]) => `${c}x ${m}`).join(', ');

                html += `
                    <div style="padding: 8px; border: 1px solid ${hasIt ? '#4a4' : canApply ? '#448' : '#333'};
                                border-radius: 4px; margin-bottom: 5px; background: ${hasIt ? 'rgba(68,170,68,0.15)' : 'rgba(0,0,0,0.3)'};">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <span>${enchant.icon} ${enchant.name}</span>
                            ${hasIt ? '<span style="color: #4f4;">âœ“ Applied</span>' :
                              canApply ? `<button onclick="applyEnchantment('${itemName}', '${id}')" style="padding: 4px 8px; cursor: pointer;">Apply</button>` :
                              '<span style="color: #666;">Need materials</span>'}
                        </div>
                        <div style="font-size: 11px; color: #888; margin-top: 4px;">+${enchant.bonus}${enchant.multiplicative ? '%' : ''} ${enchant.stat} | Cost: ${costStr}</div>
                    </div>
                `;
            }

            enchantsDiv.innerHTML = html;
        }

        // v5.2: Talent Tree System
        const TALENT_TREES = {
            combat: {
                name: 'Combat Mastery', icon: 'âš”ï¸', color: '#ff4444',
                talents: {
                    brutality: { name: 'Brutality', desc: '+5% damage per rank', maxRank: 5, effect: { damage: 0.05 } },
                    toughness: { name: 'Toughness', desc: '+10 max HP per rank', maxRank: 5, effect: { maxHp: 10 } },
                    precision: { name: 'Precision', desc: '+2% crit chance per rank', maxRank: 5, effect: { critChance: 0.02 }, requires: 'brutality' },
                    bloodlust: { name: 'Bloodlust', desc: '+1% lifesteal per rank', maxRank: 3, effect: { lifesteal: 0.01 }, requires: 'precision' },
                    warlord: { name: 'Warlord', desc: '+10% ability damage', maxRank: 1, effect: { abilityDamage: 0.10 }, requires: 'bloodlust' }
                }
            },
            survival: {
                name: 'Survival Instinct', icon: 'ðŸ›¡ï¸', color: '#44aaff',
                talents: {
                    thick_skin: { name: 'Thick Skin', desc: '+2 defense per rank', maxRank: 5, effect: { defense: 2 } },
                    evasion: { name: 'Evasion', desc: '+3% dodge chance per rank', maxRank: 5, effect: { dodgeChance: 0.03 } },
                    second_wind: { name: 'Second Wind', desc: '+5% HP regen per rank', maxRank: 3, effect: { hpRegen: 0.05 }, requires: 'thick_skin' },
                    fortress: { name: 'Fortress', desc: '+20% shield duration', maxRank: 3, effect: { shieldDuration: 0.20 }, requires: 'evasion' },
                    immortal: { name: 'Immortal', desc: 'Survive fatal blow once/world', maxRank: 1, effect: { deathSave: true }, requires: 'second_wind' }
                }
            },
            fortune: {
                name: 'Fortune Seeker', icon: 'ðŸ€', color: '#44ff44',
                talents: {
                    lucky: { name: 'Lucky', desc: '+3% loot drop per rank', maxRank: 5, effect: { lootBonus: 0.03 } },
                    harvester: { name: 'Harvester', desc: '+10% resource yield per rank', maxRank: 5, effect: { resourceYield: 0.10 } },
                    treasure_sense: { name: 'Treasure Sense', desc: '+5% rare find per rank', maxRank: 3, effect: { rareFind: 0.05 }, requires: 'lucky' },
                    midas_touch: { name: 'Midas Touch', desc: '+15% XP gain per rank', maxRank: 3, effect: { xpBonus: 0.15 }, requires: 'harvester' },
                    jackpot: { name: 'Jackpot', desc: 'Double boss loot chance', maxRank: 1, effect: { doubleBossLoot: true }, requires: 'treasure_sense' }
                }
            }
        };

        // v5.2: Get talent points available
        function getTalentPoints() {
            const totalLevels = Object.values(gameData.skills).reduce((sum, s) => sum + s.level, 0);
            const pointsEarned = Math.floor(totalLevels / 5); // 1 point per 5 total skill levels
            const pointsSpent = getSpentTalentPoints();
            return { earned: pointsEarned, spent: pointsSpent, available: pointsEarned - pointsSpent };
        }

        function getSpentTalentPoints() {
            if (!gameData.talents) gameData.talents = {};
            let spent = 0;
            for (const treeId of Object.keys(TALENT_TREES)) {
                const treeTalents = gameData.talents[treeId] || {};
                for (const [talentId, rank] of Object.entries(treeTalents)) {
                    spent += rank;
                }
            }
            return spent;
        }

        function getTalentRank(treeId, talentId) {
            if (!gameData.talents) gameData.talents = {};
            if (!gameData.talents[treeId]) gameData.talents[treeId] = {};
            return gameData.talents[treeId][talentId] || 0;
        }

        function canUnlockTalent(treeId, talentId) {
            const tree = TALENT_TREES[treeId];
            const talent = tree.talents[talentId];
            const currentRank = getTalentRank(treeId, talentId);

            // Check max rank
            if (currentRank >= talent.maxRank) return false;

            // Check points available
            if (getTalentPoints().available <= 0) return false;

            // Check prerequisite
            if (talent.requires) {
                const reqRank = getTalentRank(treeId, talent.requires);
                const reqTalent = tree.talents[talent.requires];
                if (reqRank < reqTalent.maxRank) return false;
            }

            return true;
        }

        function unlockTalent(treeId, talentId) {
            if (!canUnlockTalent(treeId, talentId)) {
                showNotification('Cannot unlock this talent!', 'error');
                return false;
            }

            if (!gameData.talents) gameData.talents = {};
            if (!gameData.talents[treeId]) gameData.talents[treeId] = {};
            gameData.talents[treeId][talentId] = (gameData.talents[treeId][talentId] || 0) + 1;

            const tree = TALENT_TREES[treeId];
            const talent = tree.talents[talentId];
            showNotification(`Unlocked ${talent.name}!`, 'success');
            AudioSystem.levelUp();
            saveGameData();
            updateTalentModal();
            return true;
        }

        function getTalentBonuses() {
            const bonuses = {
                damage: 0, maxHp: 0, critChance: 0, lifesteal: 0, abilityDamage: 0,
                defense: 0, dodgeChance: 0, hpRegen: 0, shieldDuration: 0, deathSave: false,
                lootBonus: 0, resourceYield: 0, rareFind: 0, xpBonus: 0, doubleBossLoot: false
            };

            for (const [treeId, tree] of Object.entries(TALENT_TREES)) {
                for (const [talentId, talent] of Object.entries(tree.talents)) {
                    const rank = getTalentRank(treeId, talentId);
                    if (rank > 0) {
                        for (const [stat, value] of Object.entries(talent.effect)) {
                            if (typeof value === 'boolean') {
                                bonuses[stat] = value;
                            } else {
                                bonuses[stat] = (bonuses[stat] || 0) + (value * rank);
                            }
                        }
                    }
                }
            }

            return bonuses;
        }

        // v5.2: Talent Modal UI
        function showTalentModal() {
            document.getElementById('talent-modal').style.display = 'flex';
            updateTalentModal();
        }

        function closeTalentModal() {
            document.getElementById('talent-modal').style.display = 'none';
        }

        function updateTalentModal() {
            const points = getTalentPoints();
            document.getElementById('talent-points-display').textContent = `Talent Points: ${points.available}/${points.earned}`;

            for (const [treeId, tree] of Object.entries(TALENT_TREES)) {
                const treeDiv = document.getElementById(`talent-tree-${treeId}`);
                if (!treeDiv) continue;

                let html = '';
                for (const [talentId, talent] of Object.entries(tree.talents)) {
                    const rank = getTalentRank(treeId, talentId);
                    const canUnlock = canUnlockTalent(treeId, talentId);
                    const isMaxed = rank >= talent.maxRank;
                    const isLocked = talent.requires && getTalentRank(treeId, talent.requires) < TALENT_TREES[treeId].talents[talent.requires].maxRank;

                    html += `
                        <div style="padding: 8px; margin-bottom: 5px; border: 1px solid ${isMaxed ? tree.color : isLocked ? '#333' : '#555'};
                                    border-radius: 4px; background: ${isMaxed ? `${tree.color}22` : 'rgba(0,0,0,0.3)'};
                                    opacity: ${isLocked ? 0.5 : 1}; cursor: ${canUnlock ? 'pointer' : 'default'};"
                             onclick="${canUnlock ? `unlockTalent('${treeId}', '${talentId}')` : ''}">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <span style="color: ${isMaxed ? tree.color : '#fff'};">${talent.name}</span>
                                <span style="color: ${isMaxed ? '#4f4' : '#888'};">${rank}/${talent.maxRank}</span>
                            </div>
                            <div style="font-size: 10px; color: #888; margin-top: 3px;">${talent.desc}</div>
                        </div>
                    `;
                }
                treeDiv.innerHTML = html;
            }
        }

        // ============================================
        // v5.3: MASTERY SYSTEM
        // ============================================
        const MASTERY_MILESTONES = {
            mining: {
                name: 'Mining', icon: 'â›ï¸', color: '#888888',
                milestones: [
                    { level: 5, reward: { type: 'bonus', stat: 'miningYield', value: 0.1 }, desc: '+10% ore yield' },
                    { level: 10, reward: { type: 'bonus', stat: 'miningYield', value: 0.15 }, desc: '+15% ore yield' },
                    { level: 15, reward: { type: 'unlock', item: 'Miner\'s Blessing' }, desc: 'Unlock Miner\'s Blessing buff' },
                    { level: 20, reward: { type: 'bonus', stat: 'miningYield', value: 0.25 }, desc: '+25% ore yield' },
                    { level: 25, reward: { type: 'title', title: 'Grandmaster Miner' }, desc: 'Earn Grandmaster title' }
                ]
            },
            wood: {
                name: 'Woodcutting', icon: 'ðŸª“', color: '#da5500',
                milestones: [
                    { level: 5, reward: { type: 'bonus', stat: 'woodYield', value: 0.1 }, desc: '+10% wood yield' },
                    { level: 10, reward: { type: 'bonus', stat: 'woodYield', value: 0.15 }, desc: '+15% wood yield' },
                    { level: 15, reward: { type: 'unlock', item: 'Lumberjack\'s Spirit' }, desc: 'Unlock Lumberjack buff' },
                    { level: 20, reward: { type: 'bonus', stat: 'woodYield', value: 0.25 }, desc: '+25% wood yield' },
                    { level: 25, reward: { type: 'title', title: 'Grandmaster Lumberjack' }, desc: 'Earn Grandmaster title' }
                ]
            },
            combat: {
                name: 'Combat', icon: 'âš”ï¸', color: '#ff4444',
                milestones: [
                    { level: 5, reward: { type: 'bonus', stat: 'combatDamage', value: 0.05 }, desc: '+5% damage' },
                    { level: 10, reward: { type: 'bonus', stat: 'combatDamage', value: 0.1 }, desc: '+10% damage' },
                    { level: 15, reward: { type: 'unlock', ability: 'Veteran Strike' }, desc: 'Unlock Veteran Strike' },
                    { level: 20, reward: { type: 'bonus', stat: 'combatCrit', value: 0.05 }, desc: '+5% crit chance' },
                    { level: 25, reward: { type: 'title', title: 'Warlord' }, desc: 'Earn Warlord title' }
                ]
            },
            fishing: {
                name: 'Fishing', icon: 'ðŸŽ£', color: '#4488ff',
                milestones: [
                    { level: 5, reward: { type: 'bonus', stat: 'fishChance', value: 0.1 }, desc: '+10% catch rate' },
                    { level: 10, reward: { type: 'bonus', stat: 'rareFind', value: 0.05 }, desc: '+5% rare fish' },
                    { level: 15, reward: { type: 'unlock', item: 'Golden Lure' }, desc: 'Unlock Golden Lure' },
                    { level: 20, reward: { type: 'bonus', stat: 'fishChance', value: 0.2 }, desc: '+20% catch rate' },
                    { level: 25, reward: { type: 'title', title: 'Master Angler' }, desc: 'Earn Master title' }
                ]
            },
            cooking: {
                name: 'Cooking', icon: 'ðŸ³', color: '#ff8800',
                milestones: [
                    { level: 5, reward: { type: 'bonus', stat: 'healBonus', value: 0.1 }, desc: '+10% heal amount' },
                    { level: 10, reward: { type: 'bonus', stat: 'healBonus', value: 0.15 }, desc: '+15% heal amount' },
                    { level: 15, reward: { type: 'unlock', recipe: 'Feast' }, desc: 'Unlock Feast recipe' },
                    { level: 20, reward: { type: 'bonus', stat: 'foodDuration', value: 0.3 }, desc: '+30% buff duration' },
                    { level: 25, reward: { type: 'title', title: 'Master Chef' }, desc: 'Earn Master title' }
                ]
            },
            crafting: {
                name: 'Crafting', icon: 'ðŸ”¨', color: '#aa44ff',
                milestones: [
                    { level: 5, reward: { type: 'bonus', stat: 'craftBonus', value: 0.1 }, desc: '+10% craft success' },
                    { level: 10, reward: { type: 'bonus', stat: 'materialSave', value: 0.1 }, desc: '10% material savings' },
                    { level: 15, reward: { type: 'unlock', recipe: 'Masterwork Forge' }, desc: 'Unlock Masterwork crafts' },
                    { level: 20, reward: { type: 'bonus', stat: 'rarityBoost', value: 0.15 }, desc: '+15% rarity chance' },
                    { level: 25, reward: { type: 'title', title: 'Artisan Supreme' }, desc: 'Earn Artisan title' }
                ]
            }
        };

        function getMasteryBonuses() {
            const bonuses = {
                miningYield: 0, woodYield: 0, combatDamage: 0, combatCrit: 0,
                fishChance: 0, rareFind: 0, healBonus: 0, foodDuration: 0,
                craftBonus: 0, materialSave: 0, rarityBoost: 0
            };

            for (const [skillId, mastery] of Object.entries(MASTERY_MILESTONES)) {
                const skillLevel = gameData.skills[skillId]?.level || 1;
                for (const milestone of mastery.milestones) {
                    if (skillLevel >= milestone.level && milestone.reward.type === 'bonus') {
                        bonuses[milestone.reward.stat] = (bonuses[milestone.reward.stat] || 0) + milestone.reward.value;
                    }
                }
            }

            return bonuses;
        }

        function getUnlockedMasteryTitles() {
            const titles = [];
            for (const [skillId, mastery] of Object.entries(MASTERY_MILESTONES)) {
                const skillLevel = gameData.skills[skillId]?.level || 1;
                for (const milestone of mastery.milestones) {
                    if (skillLevel >= milestone.level && milestone.reward.type === 'title') {
                        titles.push(milestone.reward.title);
                    }
                }
            }
            return titles;
        }

        function openMasteryModal() {
            document.getElementById('mastery-modal').style.display = 'flex';
            updateMasteryModal();
        }

        function closeMasteryModal() {
            document.getElementById('mastery-modal').style.display = 'none';
        }

        function updateMasteryModal() {
            const listDiv = document.getElementById('mastery-list');
            let html = '';

            for (const [skillId, mastery] of Object.entries(MASTERY_MILESTONES)) {
                const skillLevel = gameData.skills[skillId]?.level || 1;
                const maxMilestone = mastery.milestones[mastery.milestones.length - 1].level;
                const progress = Math.min(100, (skillLevel / maxMilestone) * 100);
                const isMastered = skillLevel >= maxMilestone;

                html += `
                    <div class="mastery-card ${isMastered ? 'mastered' : ''}">
                        <div class="mastery-header">
                            <span class="mastery-skill" style="color: ${mastery.color};">${mastery.icon} ${mastery.name}</span>
                            <span class="mastery-level">Lv ${skillLevel}</span>
                        </div>
                        <div class="mastery-progress-bar">
                            <div class="mastery-progress-fill" style="width: ${progress}%;"></div>
                        </div>
                        <div class="mastery-milestones">
                `;

                for (const milestone of mastery.milestones) {
                    const achieved = skillLevel >= milestone.level;
                    const isNext = !achieved && mastery.milestones.find(m => skillLevel < m.level)?.level === milestone.level;
                    html += `
                        <div class="milestone ${achieved ? 'achieved' : ''} ${isNext ? 'next' : ''}" title="${milestone.desc}">
                            Lv${milestone.level}: ${achieved ? 'âœ“' : milestone.desc.substring(0, 15)}...
                        </div>
                    `;
                }

                html += `
                        </div>
                    </div>
                `;
            }

            listDiv.innerHTML = html;
        }

        // ============================================
        // v5.3: REALM PORTAL SYSTEM
        // ============================================
        const REALM_PORTALS = {
            shadow_realm: {
                name: 'Shadow Realm',
                icon: 'ðŸŒ‘',
                tier: 1,
                desc: 'A realm of darkness where shadows come alive. Enhanced enemy spawn rates.',
                requirements: { combatLevel: 10, bossesDefeated: 1 },
                modifiers: { enemyDamage: 1.5, enemyHp: 1.3, spawnRate: 2.0 },
                rewards: ['Shadow Essence', 'Dark Crystal'],
                xpMultiplier: 1.5,
                duration: 300 // 5 minutes
            },
            frost_dimension: {
                name: 'Frost Dimension',
                icon: 'â„ï¸',
                tier: 2,
                desc: 'An eternally frozen world. All enemies inflict chill. Ice enemies are empowered.',
                requirements: { combatLevel: 15, bossesDefeated: 3 },
                modifiers: { enemyDamage: 1.8, enemyHp: 1.5, allEnemiesChill: true },
                rewards: ['Frozen Heart', 'Permafrost Shard', 'Frost Blade'],
                xpMultiplier: 2.0,
                duration: 300
            },
            inferno_pit: {
                name: 'Inferno Pit',
                icon: 'ðŸ”¥',
                tier: 2,
                desc: 'Volcanic realm of eternal flame. Fire damage over time. Magma enemies empowered.',
                requirements: { combatLevel: 15, bossesDefeated: 3 },
                modifiers: { enemyDamage: 2.0, enemyHp: 1.5, environmentalDamage: 2 },
                rewards: ['Infernal Core', 'Magma Heart', 'Magma Sword'],
                xpMultiplier: 2.0,
                duration: 300
            },
            void_nexus: {
                name: 'Void Nexus',
                icon: 'ðŸŒ€',
                tier: 3,
                desc: 'The space between dimensions. Reality warps around you. Elite enemies guaranteed.',
                requirements: { combatLevel: 20, bossesDefeated: 5, elitesKilled: 20 },
                modifiers: { enemyDamage: 2.5, enemyHp: 2.0, allElites: true },
                rewards: ['Void Core', 'Dimension Shard', 'Void Dagger', 'Legendary Core'],
                xpMultiplier: 3.0,
                duration: 300
            },
            celestial_ascent: {
                name: 'Celestial Ascent',
                icon: 'âœ¨',
                tier: 4,
                desc: 'The ultimate challenge. Face the Celestial Guardians in their domain.',
                requirements: { combatLevel: 25, bossesDefeated: 10, portalClears: 5 },
                modifiers: { enemyDamage: 3.0, enemyHp: 3.0, bossOnly: true },
                rewards: ['Celestial Essence', 'Star Fragment', 'Legendary Blade', 'Mythic Orb'],
                xpMultiplier: 5.0,
                duration: 600 // 10 minutes
            }
        };

        function initPortalSystem() {
            if (!gameData.portals) {
                gameData.portals = {
                    clears: {},
                    currentPortal: null,
                    portalStartTime: 0,
                    totalClears: 0
                };
            }
        }

        function canEnterPortal(portalId) {
            const portal = REALM_PORTALS[portalId];
            if (!portal) return false;

            const reqs = portal.requirements;
            const combatLevel = gameData.skills?.combat?.level || 1;
            const bossesDefeated = gameData.statistics?.bossesDefeated || 0;
            const elitesKilled = gameData.statistics?.elitesKilled || 0;
            const portalClears = gameData.portals?.totalClears || 0;

            if (combatLevel < reqs.combatLevel) return false;
            if (bossesDefeated < reqs.bossesDefeated) return false;
            if (reqs.elitesKilled && elitesKilled < reqs.elitesKilled) return false;
            if (reqs.portalClears && portalClears < reqs.portalClears) return false;

            return true;
        }

        function getPortalRequirementText(portalId) {
            const portal = REALM_PORTALS[portalId];
            const reqs = portal.requirements;
            const parts = [];

            parts.push(`Combat Lv ${reqs.combatLevel}`);
            parts.push(`${reqs.bossesDefeated} bosses`);
            if (reqs.elitesKilled) parts.push(`${reqs.elitesKilled} elites`);
            if (reqs.portalClears) parts.push(`${reqs.portalClears} portal clears`);

            return parts.join(' | ');
        }

        function enterPortal(portalId) {
            if (!canEnterPortal(portalId)) {
                showNotification('Requirements not met!', 'error');
                return false;
            }

            if (gameData.portals.currentPortal) {
                showNotification('Already in a portal realm!', 'warning');
                return false;
            }

            if (mode !== 'world') {
                showNotification('Must be on a planet to enter portals!', 'warning');
                return false;
            }

            const portal = REALM_PORTALS[portalId];
            gameData.portals.currentPortal = portalId;
            gameData.portals.portalStartTime = Date.now();
            gameData.portals.killProgress = 0; // v5.3: Reset kill counter

            showNotification(`Entered ${portal.name}! ${portal.duration / 60} minutes to clear.`, 'success');
            AudioSystem.bossSpawn();

            if (particles && worldState.player) {
                particles.emit(worldState.player.position, 50, parseInt(portal.icon === 'ðŸŒ‘' ? '0x440088' : portal.icon === 'â„ï¸' ? '0x88ddff' : portal.icon === 'ðŸ”¥' ? '0xff4400' : '0x8844ff'), { spread: 8, lifetime: 1500 });
            }

            closePortalModal();
            updatePortalUI();
            saveGameData();
            return true;
        }

        function exitPortal(completed = false) {
            if (!gameData.portals.currentPortal) return;

            const portalId = gameData.portals.currentPortal;
            const portal = REALM_PORTALS[portalId];

            if (completed) {
                // Grant rewards
                gameData.portals.clears[portalId] = (gameData.portals.clears[portalId] || 0) + 1;
                gameData.portals.totalClears++;

                // Give a random reward
                const rewardItem = portal.rewards[Math.floor(Math.random() * portal.rewards.length)];
                addItem(rewardItem);

                showNotification(`Portal cleared! Received ${rewardItem}!`, 'success');
                AudioSystem.levelUp();

                if (particles && worldState.player) {
                    particles.emit(worldState.player.position, 60, 0xffd700, { spread: 10, lifetime: 2000 });
                }
            } else {
                showNotification('Portal expired. Try again!', 'warning');
            }

            gameData.portals.currentPortal = null;
            gameData.portals.portalStartTime = 0;
            updatePortalUI();
            saveGameData();
        }

        function getPortalModifiers() {
            if (!gameData.portals?.currentPortal) return null;
            return REALM_PORTALS[gameData.portals.currentPortal]?.modifiers || null;
        }

        function getPortalXpMultiplier() {
            if (!gameData.portals?.currentPortal) return 1;
            return REALM_PORTALS[gameData.portals.currentPortal]?.xpMultiplier || 1;
        }

        function checkPortalTimeout() {
            if (!gameData.portals?.currentPortal) return;

            const portal = REALM_PORTALS[gameData.portals.currentPortal];
            const elapsed = (Date.now() - gameData.portals.portalStartTime) / 1000;

            if (elapsed >= portal.duration) {
                exitPortal(false);
            }
        }

        function getPortalTimeRemaining() {
            if (!gameData.portals?.currentPortal) return 0;

            const portal = REALM_PORTALS[gameData.portals.currentPortal];
            const elapsed = (Date.now() - gameData.portals.portalStartTime) / 1000;
            return Math.max(0, portal.duration - elapsed);
        }

        function openPortalModal() {
            initPortalSystem();
            document.getElementById('portal-modal').style.display = 'flex';
            updatePortalModal();
        }

        function closePortalModal() {
            document.getElementById('portal-modal').style.display = 'none';
        }

        function updatePortalModal() {
            const currentPortal = gameData.portals?.currentPortal;
            document.getElementById('current-realm').textContent = currentPortal ? REALM_PORTALS[currentPortal].name : 'None';

            const listDiv = document.getElementById('portal-list');
            let html = '';

            for (const [portalId, portal] of Object.entries(REALM_PORTALS)) {
                const canEnter = canEnterPortal(portalId);
                const isActive = currentPortal === portalId;
                const clears = gameData.portals?.clears?.[portalId] || 0;

                html += `
                    <div class="portal-card ${!canEnter ? 'locked' : ''} ${isActive ? 'active' : ''}"
                         onclick="${canEnter && !currentPortal ? `enterPortal('${portalId}')` : ''}">
                        <div class="portal-header">
                            <span class="portal-name">${portal.icon} ${portal.name}</span>
                            <span class="portal-tier">Tier ${portal.tier}</span>
                        </div>
                        <div class="portal-desc">${portal.desc}</div>
                        <div class="portal-rewards">
                            ${portal.rewards.map(r => `<span class="portal-reward">${ITEMS[r]?.icon || 'ðŸ“¦'} ${r}</span>`).join('')}
                        </div>
                        <div class="portal-requirement">
                            ${canEnter ? `âœ“ Unlocked | Cleared: ${clears}x | ${portal.xpMultiplier}x XP` : `ðŸ”’ ${getPortalRequirementText(portalId)}`}
                        </div>
                        ${isActive ? `<div style="color: #ff8844; margin-top: 8px; text-align: center;">â±ï¸ Active - ${Math.floor(getPortalTimeRemaining())}s remaining</div>` : ''}
                    </div>
                `;
            }

            listDiv.innerHTML = html;
        }

        function updatePortalUI() {
            // This would update any in-game portal indicators
            if (document.getElementById('portal-modal').style.display === 'flex') {
                updatePortalModal();
            }
        }

        // ============================================
        // v5.3: LOOT RARITY SYSTEM
        // ============================================
        const LOOT_RARITIES = {
            common: { name: 'Common', color: '#aaaaaa', chance: 0.60, statMult: 1.0 },
            uncommon: { name: 'Uncommon', color: '#44ff44', chance: 0.25, statMult: 1.15 },
            rare: { name: 'Rare', color: '#4488ff', chance: 0.10, statMult: 1.35 },
            epic: { name: 'Epic', color: '#aa44ff', chance: 0.04, statMult: 1.6 },
            legendary: { name: 'Legendary', color: '#ff8800', chance: 0.0095, statMult: 2.0 },
            mythic: { name: 'Mythic', color: '#ff4488', chance: 0.0005, statMult: 3.0 }
        };

        const ITEM_MODIFIERS = {
            // Offensive modifiers
            sharp: { name: 'Sharp', stat: 'damage', value: 3, desc: '+3 Damage' },
            keen: { name: 'Keen', stat: 'critChance', value: 0.05, desc: '+5% Crit' },
            brutal: { name: 'Brutal', stat: 'damage', value: 5, desc: '+5 Damage' },
            deadly: { name: 'Deadly', stat: 'critDamage', value: 0.25, desc: '+25% Crit Damage' },
            vampiric: { name: 'Vampiric', stat: 'lifesteal', value: 0.05, desc: '+5% Lifesteal' },

            // Defensive modifiers
            sturdy: { name: 'Sturdy', stat: 'defense', value: 2, desc: '+2 Defense' },
            fortified: { name: 'Fortified', stat: 'defense', value: 4, desc: '+4 Defense' },
            vital: { name: 'Vital', stat: 'maxHp', value: 15, desc: '+15 Max HP' },
            resilient: { name: 'Resilient', stat: 'damageReduction', value: 0.05, desc: '+5% DR' },

            // Utility modifiers
            swift: { name: 'Swift', stat: 'moveSpeed', value: 0.1, desc: '+10% Speed' },
            lucky: { name: 'Lucky', stat: 'lootBonus', value: 0.1, desc: '+10% Loot' },
            wise: { name: 'Wise', stat: 'xpBonus', value: 0.1, desc: '+10% XP' },
            efficient: { name: 'Efficient', stat: 'resourceYield', value: 0.15, desc: '+15% Yield' }
        };

        function rollItemRarity(baseLuckBonus = 0) {
            const masteryBonuses = getMasteryBonuses();
            const talentBonuses = getTalentBonuses();
            const totalLuck = baseLuckBonus + (masteryBonuses.rarityBoost || 0) + (talentBonuses.rareFind || 0);

            let roll = Math.random();
            // Luck improves rare+ chances
            roll = roll * (1 - totalLuck);

            let cumulative = 0;
            for (const [rarityId, rarity] of Object.entries(LOOT_RARITIES)) {
                cumulative += rarity.chance;
                if (roll < cumulative) {
                    return rarityId;
                }
            }
            return 'common';
        }

        function rollItemModifiers(rarity) {
            const numModifiers = {
                common: 0,
                uncommon: 1,
                rare: 1,
                epic: 2,
                legendary: 2,
                mythic: 3
            };

            const count = numModifiers[rarity] || 0;
            if (count === 0) return [];

            const modifierKeys = Object.keys(ITEM_MODIFIERS);
            const selected = [];

            for (let i = 0; i < count; i++) {
                const availableModifiers = modifierKeys.filter(m => !selected.includes(m));
                if (availableModifiers.length === 0) break;

                const modId = availableModifiers[Math.floor(Math.random() * availableModifiers.length)];
                selected.push(modId);
            }

            return selected;
        }

        function createRarityItem(baseItemName, forcedRarity = null) {
            const rarity = forcedRarity || rollItemRarity();
            const modifiers = rollItemModifiers(rarity);
            const rarityData = LOOT_RARITIES[rarity];

            return {
                baseName: baseItemName,
                rarity: rarity,
                modifiers: modifiers,
                statMultiplier: rarityData.statMult
            };
        }

        function getRarityItemName(rarityItem) {
            if (!rarityItem || !rarityItem.rarity || rarityItem.rarity === 'common') {
                return rarityItem?.baseName || rarityItem;
            }

            const modNames = rarityItem.modifiers?.map(m => ITEM_MODIFIERS[m]?.name).filter(Boolean) || [];
            const prefix = modNames.length > 0 ? modNames.join(' ') + ' ' : '';
            const rarityData = LOOT_RARITIES[rarityItem.rarity];

            return `${prefix}${rarityItem.baseName}`;
        }

        function getRarityItemStats(rarityItem) {
            if (!rarityItem || typeof rarityItem === 'string') return {};

            const stats = {};
            const mult = rarityItem.statMultiplier || 1;

            // Apply modifier stats
            for (const modId of (rarityItem.modifiers || [])) {
                const mod = ITEM_MODIFIERS[modId];
                if (mod) {
                    stats[mod.stat] = (stats[mod.stat] || 0) + mod.value;
                }
            }

            return stats;
        }

        function showRarityDropPopup(rarityItem) {
            if (!rarityItem || rarityItem.rarity === 'common') return;

            const rarityData = LOOT_RARITIES[rarityItem.rarity];
            const itemData = ITEMS[rarityItem.baseName] || {};
            const displayName = getRarityItemName(rarityItem);
            const modifierStats = getRarityItemStats(rarityItem);

            // Create popup
            const popup = document.createElement('div');
            popup.className = 'loot-drop-popup';
            popup.innerHTML = `
                <div style="font-size: 24px; margin-bottom: 10px;">${itemData.icon || 'ðŸ“¦'}</div>
                <div class="rarity-${rarityItem.rarity}" style="font-size: 16px; font-weight: bold; margin-bottom: 5px;">
                    ${rarityData.name} Drop!
                </div>
                <div style="color: ${rarityData.color}; font-size: 14px; margin-bottom: 10px;">
                    ${displayName}
                </div>
                ${Object.keys(modifierStats).length > 0 ? `
                    <div class="item-modifiers">
                        ${rarityItem.modifiers.map(m => ITEM_MODIFIERS[m]?.desc).join(' | ')}
                    </div>
                ` : ''}
                <button onclick="this.parentElement.remove()" style="margin-top: 15px; padding: 8px 20px; cursor: pointer;
                    background: linear-gradient(135deg, ${rarityData.color}, #333); border: none; border-radius: 4px; color: #fff;">
                    Collect
                </button>
            `;

            document.body.appendChild(popup);

            // Auto-remove after 5 seconds
            setTimeout(() => {
                if (popup.parentElement) {
                    popup.remove();
                }
            }, 5000);

            // Play appropriate sound
            if (rarityItem.rarity === 'legendary' || rarityItem.rarity === 'mythic') {
                AudioSystem.levelUp();
            } else {
                AudioSystem.collect();
            }
        }

        // Enhanced item drop function that uses rarity system
        function dropRarityItem(baseItemName, luckBonus = 0) {
            const rarityItem = createRarityItem(baseItemName, null);

            // Store rarity items in a special format
            if (!gameData.rarityItems) gameData.rarityItems = [];

            if (rarityItem.rarity !== 'common') {
                gameData.rarityItems.push(rarityItem);
                showRarityDropPopup(rarityItem);
            }

            // Add the base item to inventory (rarity tracked separately)
            addItem(baseItemName);

            return rarityItem;
        }

        // Get total bonus stats from all rarity items
        function getRarityBonuses() {
            const bonuses = {};

            for (const item of (gameData.rarityItems || [])) {
                // Only count equipped items (check if base item is in equipment)
                const gear = getEquippedGear();
                const isEquipped = Object.values(gear).some(g => g === item.baseName);

                if (isEquipped) {
                    const stats = getRarityItemStats(item);
                    for (const [stat, value] of Object.entries(stats)) {
                        bonuses[stat] = (bonuses[stat] || 0) + value;
                    }
                }
            }

            return bonuses;
        }

        // v5.5: 3D Ship Landing Mini-Game System (Drone-style)
        let landingGame = {
            active: false,
            targetCiv: null,
            scene: null,
            camera: null,
            renderer: null,
            ship: null,
            landingPad: null,
            animFrame: null,
            lastTime: 0,
            isManual: false,
            fuel: 100,
            velocity: null,
            targetPosition: null,
            propellers: [],
            thrustLight: null,
            environmentObjects: []
        };

        const LANDING_CONFIG = {
            startAltitude: 60,
            maxSpeed: 8,
            safeSpeed: 2.5,
            gravity: 0.02,          // Much slower gravity
            thrustPower: 0.06,      // Gentler thrust
            manualControl: 0.25,    // Slower manual movement
            fuelConsumption: 0.02,  // Slower fuel drain
            landingPadSize: 18,     // Bigger landing pad
            bounds: 100,
            biomeColors: {
                Terra: { sky: 0x87CEEB, ground: 0x3a8c3a, fog: 0x87CEEB },
                Desert: { sky: 0xffcc99, ground: 0xc2a060, fog: 0xffcc99 },
                Ice: { sky: 0xddeeff, ground: 0xe8f4f8, fog: 0xddeeff },
                Volcanic: { sky: 0x330000, ground: 0x2a1a1a, fog: 0x330000 },
                Alien: { sky: 0x220044, ground: 0x440066, fog: 0x220044 }
            }
        };

        function startLandingGame(civ) {
            // Cleanup any existing landing game
            if (landingGame.animFrame) {
                cancelAnimationFrame(landingGame.animFrame);
            }
            if (landingGame.renderer) {
                landingGame.renderer.dispose();
            }

            landingGame.active = true;
            landingGame.targetCiv = civ;
            landingGame.isManual = false;
            landingGame.fuel = 100;
            landingGame.velocity = new THREE.Vector3(0, -0.1, 0);  // Very slow initial descent
            landingGame.targetPosition = new THREE.Vector3(0, 20, 0);
            landingGame.lastTime = 0;
            mode = 'landing';

            // Show landing UI
            const overlay = document.getElementById('landing-overlay');
            overlay.style.display = 'block';
            document.getElementById('landing-planet-name').textContent = `Landing on ${civ.name} (${civ.biomeName})`;
            document.getElementById('landing-mode').textContent = 'Autonomous';
            document.getElementById('landing-mode-btn').textContent = 'Switch to Manual';

            // Get biome colors
            const biomeColors = LANDING_CONFIG.biomeColors[civ.biome] || LANDING_CONFIG.biomeColors.Terra;

            // Create separate Three.js scene for landing
            landingGame.scene = new THREE.Scene();
            landingGame.scene.fog = new THREE.Fog(biomeColors.fog, 100, 500);

            // Isometric camera
            const container = document.getElementById('landing-scene-container');
            const aspect = container.clientWidth / container.clientHeight;
            const d = 50;
            landingGame.camera = new THREE.OrthographicCamera(
                -d * aspect, d * aspect, d, -d, 1, 1000
            );
            landingGame.camera.position.set(100, 100, 100);
            landingGame.camera.lookAt(0, 0, 0);

            // Renderer
            landingGame.renderer = new THREE.WebGLRenderer({ antialias: true });
            landingGame.renderer.setSize(container.clientWidth, container.clientHeight);
            landingGame.renderer.shadowMap.enabled = true;
            landingGame.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            landingGame.renderer.setClearColor(biomeColors.sky);
            container.innerHTML = '';
            container.appendChild(landingGame.renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            landingGame.scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            landingGame.scene.add(directionalLight);

            // Ground
            const groundGeometry = new THREE.PlaneGeometry(300, 300);
            const groundMaterial = new THREE.MeshLambertMaterial({ color: biomeColors.ground });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            landingGame.scene.add(ground);

            // Create landing pad
            createLandingPad();

            // Create environment based on biome
            createLandingEnvironment(civ.biome);

            // Create ship
            createLandingShip();

            // Start animation loop
            landingGameLoop(0);

            // Simple short blip sound instead of ringing tone
            AudioSystem.click();
            showNotification(`Approaching ${civ.name}... Land on the green pad!`, 'info');
        }

        function createLandingPad() {
            const padGroup = new THREE.Group();

            // Main pad
            const padGeometry = new THREE.CylinderGeometry(LANDING_CONFIG.landingPadSize, LANDING_CONFIG.landingPadSize, 1, 32);
            const padMaterial = new THREE.MeshLambertMaterial({ color: 0x44ff44 });
            const pad = new THREE.Mesh(padGeometry, padMaterial);
            pad.position.y = 0.5;
            pad.receiveShadow = true;
            padGroup.add(pad);

            // Center marker
            const markerGeometry = new THREE.CylinderGeometry(3, 3, 0.5, 32);
            const markerMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff });
            const marker = new THREE.Mesh(markerGeometry, markerMaterial);
            marker.position.y = 1.2;
            padGroup.add(marker);

            // Beacon light
            const beaconGeometry = new THREE.CylinderGeometry(1, 1, 5, 8);
            const beaconMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });
            const beacon = new THREE.Mesh(beaconGeometry, beaconMaterial);
            beacon.position.set(LANDING_CONFIG.landingPadSize - 2, 3, 0);
            beacon.castShadow = true;
            padGroup.add(beacon);

            // Beacon light
            const lightGeometry = new THREE.SphereGeometry(1.5, 16, 16);
            const lightMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            landingGame.beaconLight = new THREE.Mesh(lightGeometry, lightMaterial);
            landingGame.beaconLight.position.set(LANDING_CONFIG.landingPadSize - 2, 6, 0);
            padGroup.add(landingGame.beaconLight);

            landingGame.landingPad = padGroup;
            landingGame.scene.add(padGroup);
        }

        function createLandingEnvironment(biome) {
            landingGame.environmentObjects = [];

            // Add trees/structures based on biome
            if (biome === 'Terra' || biome === 'Alien') {
                for (let i = 0; i < 15; i++) {
                    const x = (Math.random() - 0.5) * 250;
                    const z = (Math.random() - 0.5) * 250;
                    if (Math.abs(x) > 30 || Math.abs(z) > 30) {
                        const tree = createLandingTree(biome);
                        tree.position.set(x, 0, z);
                        landingGame.scene.add(tree);
                        landingGame.environmentObjects.push(tree);
                    }
                }
            }

            // Add rocks/obstacles for all biomes
            for (let i = 0; i < 8; i++) {
                const x = (Math.random() - 0.5) * 200;
                const z = (Math.random() - 0.5) * 200;
                if (Math.abs(x) > 25 || Math.abs(z) > 25) {
                    const rock = createLandingRock(biome);
                    rock.position.set(x, 0, z);
                    landingGame.scene.add(rock);
                    landingGame.environmentObjects.push(rock);
                }
            }
        }

        function createLandingTree(biome) {
            const group = new THREE.Group();

            // Trunk
            const trunkGeometry = new THREE.CylinderGeometry(2, 3, 15);
            const trunkColor = biome === 'Alien' ? 0x8800ff : 0x8B4513;
            const trunkMaterial = new THREE.MeshLambertMaterial({ color: trunkColor });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 7.5;
            trunk.castShadow = true;
            group.add(trunk);

            // Foliage
            const foliageGeometry = new THREE.SphereGeometry(8, 8, 6);
            const foliageColor = biome === 'Alien' ? 0xff00ff : 0x228B22;
            const foliageMaterial = new THREE.MeshLambertMaterial({ color: foliageColor });
            const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
            foliage.position.y = 18;
            foliage.castShadow = true;
            group.add(foliage);

            return group;
        }

        function createLandingRock(biome) {
            const rockColors = {
                Terra: 0x888888,
                Desert: 0xaa5522,
                Ice: 0xaaccff,
                Volcanic: 0x333333,
                Alien: 0x00ffcc
            };
            const height = 5 + Math.random() * 15;
            const geometry = new THREE.DodecahedronGeometry(3 + Math.random() * 5, 0);
            const material = new THREE.MeshLambertMaterial({ color: rockColors[biome] || 0x888888 });
            const rock = new THREE.Mesh(geometry, material);
            rock.position.y = height / 2;
            rock.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
            rock.scale.y = height / 10;
            rock.castShadow = true;
            rock.receiveShadow = true;
            return rock;
        }

        function createLandingShip() {
            const shipGroup = new THREE.Group();

            // Body
            const bodyGeometry = new THREE.BoxGeometry(6, 2, 6);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = true;
            shipGroup.add(body);

            // Cockpit
            const cockpitGeometry = new THREE.SphereGeometry(2, 16, 16);
            const cockpitMaterial = new THREE.MeshLambertMaterial({ color: 0x00ffff });
            const cockpit = new THREE.Mesh(cockpitGeometry, cockpitMaterial);
            cockpit.position.y = 1.5;
            cockpit.scale.y = 0.6;
            shipGroup.add(cockpit);

            // Propeller arms and propellers
            landingGame.propellers = [];
            const propPositions = [
                [-4, 0.5, -4], [4, 0.5, -4],
                [-4, 0.5, 4], [4, 0.5, 4]
            ];

            propPositions.forEach(pos => {
                // Arm
                const armGeometry = new THREE.BoxGeometry(1, 0.5, 1);
                const armMaterial = new THREE.MeshLambertMaterial({ color: 0x666666 });
                const arm = new THREE.Mesh(armGeometry, armMaterial);
                arm.position.set(pos[0] * 0.6, pos[1], pos[2] * 0.6);
                shipGroup.add(arm);

                // Propeller
                const propGeometry = new THREE.CylinderGeometry(0.2, 0.2, 4);
                const propMaterial = new THREE.MeshLambertMaterial({ color: 0xaaaaaa });
                const propeller = new THREE.Mesh(propGeometry, propMaterial);
                propeller.rotation.z = Math.PI / 2;
                propeller.position.set(...pos);
                propeller.castShadow = true;
                landingGame.propellers.push(propeller);
                shipGroup.add(propeller);
            });

            // Engine light
            landingGame.thrustLight = new THREE.PointLight(0x00ff00, 1, 15);
            landingGame.thrustLight.position.y = -1;
            shipGroup.add(landingGame.thrustLight);

            // Position ship at start
            shipGroup.position.set(
                (Math.random() - 0.5) * 40,
                LANDING_CONFIG.startAltitude,
                (Math.random() - 0.5) * 40
            );

            landingGame.ship = shipGroup;
            landingGame.scene.add(shipGroup);
        }

        function landingGameLoop(currentTime) {
            if (!landingGame.active) return;

            const deltaTime = (currentTime - landingGame.lastTime) / 1000;
            landingGame.lastTime = currentTime;

            if (deltaTime > 0 && deltaTime < 0.1) {
                updateLandingShip(deltaTime);
                checkLandingConditions();
                updateLandingUI();
            }

            // Rotate propellers
            landingGame.propellers.forEach(prop => {
                prop.rotation.y += deltaTime * 50;
            });

            // Blink beacon
            const blinkOn = Math.floor(currentTime / 500) % 2 === 0;
            if (landingGame.beaconLight) {
                landingGame.beaconLight.material.color.setHex(blinkOn ? 0xff0000 : 0x440000);
            }

            // Camera follow
            const cameraTarget = new THREE.Vector3(
                landingGame.ship.position.x * 0.3,
                0,
                landingGame.ship.position.z * 0.3
            );
            landingGame.camera.position.x = 100 + cameraTarget.x;
            landingGame.camera.position.z = 100 + cameraTarget.z;
            landingGame.camera.lookAt(cameraTarget);

            landingGame.renderer.render(landingGame.scene, landingGame.camera);
            landingGame.animFrame = requestAnimationFrame(landingGameLoop);
        }

        function updateLandingShip(deltaTime) {
            const ship = landingGame.ship;

            // Slow fuel drain
            landingGame.fuel = Math.max(0, landingGame.fuel - deltaTime * LANDING_CONFIG.fuelConsumption * 3);

            if (!landingGame.isManual && landingGame.fuel > 0) {
                // Autonomous flight - navigate to landing pad
                runLandingAutopilot(deltaTime);
            } else if (landingGame.isManual && landingGame.fuel > 0) {
                // Manual controls via keyboard
                applyManualLandingControls(deltaTime);
            }

            // Apply gentle gravity
            landingGame.velocity.y -= LANDING_CONFIG.gravity * deltaTime * 20;

            // Apply velocity (slower multiplier)
            ship.position.add(landingGame.velocity.clone().multiplyScalar(deltaTime * 25));

            // Tilt based on velocity
            ship.rotation.z = landingGame.velocity.x * 0.05;
            ship.rotation.x = -landingGame.velocity.z * 0.05;

            // Strong damping for smoother movement
            landingGame.velocity.multiplyScalar(0.96);

            // Keep within bounds
            ship.position.clamp(
                new THREE.Vector3(-LANDING_CONFIG.bounds, 2, -LANDING_CONFIG.bounds),
                new THREE.Vector3(LANDING_CONFIG.bounds, 100, LANDING_CONFIG.bounds)
            );

            // Update thrust light color based on mode
            if (landingGame.thrustLight) {
                landingGame.thrustLight.color.setHex(landingGame.isManual ? 0xff8800 : 0x00ff88);
                landingGame.thrustLight.intensity = 1 + Math.sin(Date.now() * 0.005) * 0.3;
            }
        }

        function runLandingAutopilot(deltaTime) {
            const ship = landingGame.ship;
            const padPos = new THREE.Vector3(0, 4, 0); // Target slightly above pad

            // Calculate direction to landing pad
            const direction = new THREE.Vector3().subVectors(padPos, ship.position);
            const horizontalDist = Math.sqrt(direction.x * direction.x + direction.z * direction.z);
            const verticalDist = ship.position.y;

            // Desired velocity based on position - MUCH slower and gentler
            const desiredVelocity = new THREE.Vector3();

            // Horizontal movement - very gentle drift toward pad
            if (horizontalDist > 3) {
                desiredVelocity.x = direction.x * 0.015;  // Very slow horizontal
                desiredVelocity.z = direction.z * 0.015;
            }

            // Vertical movement - very controlled slow descent
            const slowDescent = -0.15;  // Very slow descent speed
            if (verticalDist > 25) {
                // High altitude - still slow descent
                desiredVelocity.y = slowDescent * 1.5;
            } else if (horizontalDist > 8) {
                // Not over pad yet - hover and drift
                desiredVelocity.y = -0.05;
            } else {
                // Over pad - very slow final descent
                desiredVelocity.y = slowDescent * 0.5;
            }

            // Very gentle lerp toward desired velocity
            landingGame.velocity.lerp(desiredVelocity, deltaTime * 0.8);

            // Counter gravity gently when needed
            if (landingGame.velocity.y < desiredVelocity.y - 0.05) {
                landingGame.velocity.y += LANDING_CONFIG.thrustPower * deltaTime * 30;
                landingGame.fuel -= LANDING_CONFIG.fuelConsumption * 0.5;
            }
        }

        function applyManualLandingControls(deltaTime) {
            const controlForce = LANDING_CONFIG.manualControl * deltaTime * 60;

            if (landingKeys['ArrowUp'] || landingKeys['w']) {
                landingGame.velocity.z -= controlForce;
            }
            if (landingKeys['ArrowDown'] || landingKeys['s']) {
                landingGame.velocity.z += controlForce;
            }
            if (landingKeys['ArrowLeft'] || landingKeys['a']) {
                landingGame.velocity.x -= controlForce;
            }
            if (landingKeys['ArrowRight'] || landingKeys['d']) {
                landingGame.velocity.x += controlForce;
            }
            if (landingKeys[' ']) {
                landingGame.velocity.y += controlForce * 1.5;
                landingGame.fuel -= LANDING_CONFIG.fuelConsumption * 2;
            }
            if (landingKeys['Shift']) {
                landingGame.velocity.y -= controlForce * 0.5;
            }
        }

        const landingKeys = {};

        function handleLandingKeyDown(e) {
            if (!landingGame.active) return;
            landingKeys[e.key] = true;

            if (e.key === 'Escape') {
                abortLanding();
            }
            if (e.key === 'm' || e.key === 'M') {
                toggleLandingMode();
            }

            // Auto-switch to manual if keys pressed
            if (!landingGame.isManual && ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' ', 'w', 'a', 's', 'd'].includes(e.key)) {
                landingGame.isManual = true;
                updateLandingModeUI();
                showNotification('MANUAL OVERRIDE - Autopilot disengaged', 'info');
            }

            e.preventDefault();
        }

        function handleLandingKeyUp(e) {
            landingKeys[e.key] = false;
        }

        function toggleLandingMode() {
            landingGame.isManual = !landingGame.isManual;
            updateLandingModeUI();
            showNotification(landingGame.isManual ? 'MANUAL CONTROL' : 'AUTOPILOT ENGAGED', 'info');
        }

        function updateLandingModeUI() {
            document.getElementById('landing-mode').textContent = landingGame.isManual ? 'Manual' : 'Autonomous';
            document.getElementById('landing-mode-btn').textContent = landingGame.isManual ? 'Switch to Autonomous' : 'Switch to Manual';
        }

        function updateLandingUI() {
            const ship = landingGame.ship;
            const altitude = Math.max(0, ship.position.y - 1).toFixed(1);
            const speed = landingGame.velocity.length().toFixed(1);
            const padPos = new THREE.Vector3(0, 0, 0);
            const distance = Math.sqrt(
                Math.pow(ship.position.x - padPos.x, 2) +
                Math.pow(ship.position.z - padPos.z, 2)
            ).toFixed(1);

            document.getElementById('landing-altitude').textContent = altitude;
            document.getElementById('landing-speed').textContent = speed;
            document.getElementById('landing-fuel').textContent = Math.floor(landingGame.fuel);
            document.getElementById('landing-distance').textContent = distance;
        }

        function checkLandingConditions() {
            const ship = landingGame.ship;
            const altitude = ship.position.y;
            const speed = landingGame.velocity.length();
            const horizontalDist = Math.sqrt(ship.position.x * ship.position.x + ship.position.z * ship.position.z);

            // Check if landed
            if (altitude <= 3) {
                const onPad = horizontalDist < LANDING_CONFIG.landingPadSize;
                const slowEnough = speed < LANDING_CONFIG.safeSpeed;

                if (onPad && slowEnough) {
                    landingSuccess();
                } else if (!slowEnough) {
                    landingCrash('Too fast! Reduce speed before landing.');
                } else {
                    landingCrash('Missed the landing pad!');
                }
            }

            // Out of fuel
            if (landingGame.fuel <= 0 && altitude > 10) {
                landingCrash('Out of fuel!');
            }
        }

        function landingSuccess() {
            landingGame.active = false;
            cancelAnimationFrame(landingGame.animFrame);

            const civ = landingGame.targetCiv;
            const bonusXp = Math.floor(landingGame.fuel * 2);

            cleanupLandingGame();

            showNotification(`Perfect landing on ${civ.name}! +${bonusXp} XP bonus!`, 'success');
            AudioSystem.levelUp();

            // Grant landing bonus XP
            Object.keys(gameData.skills).forEach(skill => {
                addXp(skill, Math.floor(bonusXp / 6));
            });

            // Track successful landings
            gameData.statistics.successfulLandings = (gameData.statistics.successfulLandings || 0) + 1;

            // Now actually enter the world
            initWorld(civ);
        }

        function landingCrash(reason) {
            landingGame.active = false;
            cancelAnimationFrame(landingGame.animFrame);

            cleanupLandingGame();

            showNotification(`Crash landing! ${reason}`, 'error');
            AudioSystem.error();

            // Take damage
            gameData.player.hp = Math.max(1, gameData.player.hp - 20);
            updateHealthUI();

            // Track crashes
            gameData.statistics.crashLandings = (gameData.statistics.crashLandings || 0) + 1;

            mode = 'galaxy';
        }

        function abortLanding() {
            landingGame.active = false;
            cancelAnimationFrame(landingGame.animFrame);
            cleanupLandingGame();
            mode = 'galaxy';
            showNotification('Landing aborted. Returning to orbit.', 'info');
        }

        function cleanupLandingGame() {
            document.getElementById('landing-overlay').style.display = 'none';
            if (landingGame.renderer) {
                landingGame.renderer.dispose();
                const container = document.getElementById('landing-scene-container');
                if (container) container.innerHTML = '';
            }
            // Reset keys
            Object.keys(landingKeys).forEach(k => landingKeys[k] = false);
        }

        // Math Utils
        class SeededRNG {
            constructor(seed) { this.seed = this.hash(seed); }
            hash(str) {
                let h = 0; for(let i=0;i<str.length;i++) h = Math.imul(31,h)+str.charCodeAt(i)|0;
                return Math.abs(h);
            }
            next() { this.seed = (this.seed * 16807) % 2147483647; return (this.seed - 1) / 2147483646; }
            range(min, max) { return min + this.next() * (max - min); }
            int(min, max) { return Math.floor(this.range(min, max+1)); }
            pick(arr) { return arr[Math.floor(this.next() * arr.length)]; }
        }

        // Simple noise for terrain
        function noise(x, z) {
            return Math.sin(x * 0.1) * Math.cos(z * 0.1) + Math.sin(x*0.3 + z*0.2)*0.5;
        }

        // --- GLOBAL STATE ---
        let scene, camera, renderer;
        let mode = 'galaxy';
        let activeCiv = null;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let isTouchDevice = 'ontouchstart' in window;

        // Galaxy State
        let civilizations = [];
        let galaxyGroup = new THREE.Group();
        let selectionRing;
        let lastTime = 0;
        let cycle = 0;

        // Floater pool for performance
        const floaterPool = [];
        const MAX_FLOATERS = 20;

        // RPG State
        let worldState = {
            player: null,
            terrain: [],
            interactables: [],
            fishingSpots: [],
            mobs: [],
            pois: [], // v4.2: Points of Interest
            sun: null,
            ambient: null,
            timeOfDay: 0,
            target: null,
            interactTarget: null,
            lastActionTime: 0, // v4.0: Cooldown-based interactions
            lastPlayerPos: null // v4.2: For distance tracking
        };

        // v5.5: Autonomous Exploration System
        let autoExplore = {
            enabled: true,  // Start in auto mode
            currentTarget: null,
            lastTargetTime: 0,
            targetCooldown: 3000,  // Time between target switches
            idleTime: 0,
            state: 'exploring',  // exploring, gathering, combat, idle
            combatTarget: null
        };

        function toggleAutoExplore() {
            autoExplore.enabled = !autoExplore.enabled;
            autoExplore.currentTarget = null;
            updateAutoExploreUI();
            showNotification(autoExplore.enabled ? 'AUTOPILOT: Exploring automatically' : 'MANUAL: You have control', 'info');
        }

        function updateAutoExploreUI() {
            const btn = document.getElementById('auto-explore-btn');
            const indicator = document.getElementById('auto-explore-indicator');
            if (btn) {
                btn.textContent = autoExplore.enabled ? 'Take Manual Control' : 'Enable Autopilot';
                btn.style.background = autoExplore.enabled ? '#00ff88' : '#ff8844';
            }
            if (indicator) {
                indicator.textContent = autoExplore.enabled ? 'ðŸ¤– AUTOPILOT' : 'ðŸŽ® MANUAL';
                indicator.style.color = autoExplore.enabled ? '#00ff88' : '#ff8844';
            }
        }

        function runAutoExplore(dt) {
            if (!autoExplore.enabled || mode !== 'world' || !worldState.player) return false;

            const player = worldState.player;
            const now = performance.now();

            // Priority 1: Combat - attack nearby enemies
            if (worldState.mobs.length > 0) {
                let nearestMob = null;
                let nearestDist = Infinity;

                worldState.mobs.forEach(mob => {
                    if (!mob.parent) return;
                    const dist = player.position.distanceTo(mob.position);
                    if (dist < 25 && dist < nearestDist) {
                        nearestDist = dist;
                        nearestMob = mob;
                    }
                });

                if (nearestMob) {
                    autoExplore.state = 'combat';
                    autoExplore.combatTarget = nearestMob;

                    // Move toward mob if not in range
                    if (nearestDist > CONFIG.INTERACTION_RANGE) {
                        worldState.target = nearestMob.position.clone();
                        worldState.interactTarget = nearestMob;
                    } else {
                        // Attack!
                        worldState.target = null;
                        if (now - worldState.lastActionTime > CONFIG.INTERACTION_COOLDOWN) {
                            performAction(nearestMob);
                            worldState.lastActionTime = now;
                        }
                    }
                    return true;
                }
            }

            // Priority 2: Gather resources - only target actual harvestable resources
            let bestResource = null;
            let bestResourceDist = Infinity;

            // Check interactables for actual resources (trees, rocks, ores)
            worldState.interactables.forEach(obj => {
                if (!obj.parent) return;
                const name = obj.userData.name || '';
                // Only target actual resources, not decorations
                const isResource = name.includes('Tree') || name.includes('Rock') ||
                                   name.includes('Ore') || name.includes('Crystal') ||
                                   name.includes('Bush') || name.includes('Plant') ||
                                   name.includes('Mushroom') || name.includes('Herb');
                if (!isResource) return;

                const dist = player.position.distanceTo(obj.position);
                if (dist < 50 && dist < bestResourceDist) {
                    bestResourceDist = dist;
                    bestResource = obj;
                }
            });

            // Also check fishing spots
            if (!bestResource && worldState.fishingSpots) {
                worldState.fishingSpots.forEach(spot => {
                    if (!spot.parent) return;
                    const dist = player.position.distanceTo(spot.position);
                    if (dist < 50 && dist < bestResourceDist) {
                        bestResourceDist = dist;
                        bestResource = spot;
                    }
                });
            }

            if (bestResource) {
                autoExplore.state = 'gathering';
                autoExplore.currentTarget = null; // Clear random exploration target

                if (bestResourceDist > CONFIG.INTERACTION_RANGE) {
                    worldState.target = bestResource.position.clone();
                    worldState.interactTarget = bestResource;
                } else {
                    worldState.target = null;
                    if (now - worldState.lastActionTime > CONFIG.INTERACTION_COOLDOWN) {
                        performAction(bestResource);
                        worldState.lastActionTime = now;
                    }
                }
                return true;
            }

            // Priority 3: Explore - find new resources
            autoExplore.state = 'exploring';

            // Pick a new random target periodically or if stuck
            const stuckCheck = autoExplore.currentTarget &&
                player.position.distanceTo(autoExplore.currentTarget) === autoExplore.lastDistToTarget;

            if (stuckCheck) {
                autoExplore.stuckCounter = (autoExplore.stuckCounter || 0) + 1;
            } else {
                autoExplore.stuckCounter = 0;
            }
            autoExplore.lastDistToTarget = autoExplore.currentTarget ?
                player.position.distanceTo(autoExplore.currentTarget) : 0;

            // Pick new target if: no target, timeout, or stuck
            if (!autoExplore.currentTarget ||
                now - autoExplore.lastTargetTime > autoExplore.targetCooldown ||
                autoExplore.stuckCounter > 60) {

                // Try to find an unexplored area with resources
                let foundTarget = false;

                // Search for any resource in a wider area
                let anyResource = null;
                let anyResourceDist = Infinity;

                worldState.interactables.forEach(obj => {
                    if (!obj.parent) return;
                    const dist = player.position.distanceTo(obj.position);
                    if (dist > 10 && dist < anyResourceDist) { // Not too close, not too far
                        anyResourceDist = dist;
                        anyResource = obj;
                    }
                });

                if (anyResource && anyResourceDist < 100) {
                    autoExplore.currentTarget = anyResource.position.clone();
                    foundTarget = true;
                }

                // If no resources found, pick a random direction
                if (!foundTarget) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 20 + Math.random() * 20;
                    autoExplore.currentTarget = new THREE.Vector3(
                        player.position.x + Math.cos(angle) * distance,
                        0,
                        player.position.z + Math.sin(angle) * distance
                    );
                }

                // Clamp to world bounds
                autoExplore.currentTarget.x = Math.max(-45, Math.min(45, autoExplore.currentTarget.x));
                autoExplore.currentTarget.z = Math.max(-45, Math.min(45, autoExplore.currentTarget.z));
                autoExplore.lastTargetTime = now;
                autoExplore.stuckCounter = 0;
            }

            worldState.target = autoExplore.currentTarget;

            // Check if reached target
            if (autoExplore.currentTarget && player.position.distanceTo(autoExplore.currentTarget) < 3) {
                autoExplore.currentTarget = null;
            }

            return true;
        }

        // WASD Keyboard controls
        const keys = { w: false, a: false, s: false, d: false };

        // Persistent Game Data (saved to localStorage)
        let gameData = {
            version: VERSION,
            playtime: 0,
            lastPlayed: null,
            hasSeenTutorial: false, // v4.0: Tutorial tracking
            inventory: [],
            skills: {
                mining: { level: 1, xp: 0 },
                wood: { level: 1, xp: 0 },
                combat: { level: 1, xp: 0 },
                fishing: { level: 1, xp: 0 },
                cooking: { level: 1, xp: 0 },
                crafting: { level: 1, xp: 0 }
            },
            player: {
                hp: CONFIG.PLAYER_MAX_HP,
                maxHp: CONFIG.PLAYER_MAX_HP
            },
            visitedPlanets: [],
            statistics: {
                treesChopped: 0,
                oresMined: 0,
                mobsKilled: 0,
                fishCaught: 0,
                itemsCrafted: 0,
                fishCooked: 0,
                // v4.2: New stats
                poisDiscovered: 0,
                totalDamageDealt: 0,
                bossesDefeated: 0,
                distanceTraveled: 0
            },
            // v4.2: Player rank tracking
            playerRank: { points: 0, lastTitle: 'Novice Explorer' },
            // v4.2: Discovered POIs by planet
            discoveredPOIs: {},
            // v4.1: Achievement System
            achievements: {},
            // v4.1: Daily Challenge System
            dailyChallenge: {
                lastGenerated: null,
                completed: false,
                current: null,
                streak: 0,
                bestStreak: 0
            },
            // v4.4: Prestige System
            prestige: {
                level: 0,
                totalLifetimePoints: 0,
                bonuses: {
                    xpMultiplier: 1.0,
                    startingSkillBonus: 0
                }
            },
            // v4.4: Fog of War exploration tracking per planet
            exploredTiles: {},
            // v4.6: Settings
            settings: {
                masterVolume: 30,
                sfxEnabled: true,
                ambientEnabled: true,
                particleQuality: 'high',
                shadowsEnabled: true,
                screenShakeEnabled: true,
                hintsEnabled: true
            },
            // v5.1: Equipment slots
            equipment: {
                weapon: null,
                armor: null,
                accessory: null,
                tool: null
            },
            // v5.1: Item enchantments
            enchantments: {},
            // v5.2: Talent tree points
            talents: {}
        };

        // v4.4: Simulated Leaderboard Players for local comparison
        const SIMULATED_PLAYERS = [
            { name: 'StarSeeker_X', points: 500, rank: 'Pathfinder' },
            { name: 'CosmicNova', points: 2500, rank: 'Star Scout' },
            { name: 'VoidWalker99', points: 8000, rank: 'Galaxy Ranger' },
            { name: 'AstroLegend', points: 12000, rank: 'Void Hunter' },
            { name: 'NebulaKing', points: 18000, rank: 'Cosmic Legend' },
            { name: 'Explorer42', points: 150, rank: 'Wanderer' },
            { name: 'SpaceCadet', points: 350, rank: 'Wanderer' },
            { name: 'Starlight', points: 1200, rank: 'Pathfinder' }
        ];

        // v4.4: Prestige requirements and rewards
        const PRESTIGE_LEVELS = {
            1: { required: 15000, xpBonus: 0.10, skillBonus: 0 },
            2: { required: 20000, xpBonus: 0.10, skillBonus: 1 },
            3: { required: 30000, xpBonus: 0.15, skillBonus: 1 },
            4: { required: 50000, xpBonus: 0.20, skillBonus: 2 },
            5: { required: 100000, xpBonus: 0.25, skillBonus: 3 }
        };

        function canPrestige() {
            const currentLevel = gameData.prestige?.level || 0;
            const nextLevel = PRESTIGE_LEVELS[currentLevel + 1];
            if (!nextLevel) return false;
            return calculatePlayerPoints() >= nextLevel.required;
        }

        function performPrestige() {
            if (!canPrestige()) return false;

            const currentLevel = gameData.prestige?.level || 0;
            const newLevel = currentLevel + 1;
            const reward = PRESTIGE_LEVELS[newLevel];

            // Store lifetime stats
            const lifetimePoints = (gameData.prestige?.totalLifetimePoints || 0) + calculatePlayerPoints();

            // Calculate cumulative bonuses
            const newXpMultiplier = 1.0 + Object.entries(PRESTIGE_LEVELS)
                .filter(([lvl]) => parseInt(lvl) <= newLevel)
                .reduce((sum, [, data]) => sum + data.xpBonus, 0);
            const newSkillBonus = Object.entries(PRESTIGE_LEVELS)
                .filter(([lvl]) => parseInt(lvl) <= newLevel)
                .reduce((sum, [, data]) => sum + data.skillBonus, 0);

            // Keep achievements and daily challenge
            const keepData = {
                achievements: { ...gameData.achievements },
                dailyChallenge: { ...gameData.dailyChallenge },
                hasSeenTutorial: true,
                prestige: {
                    level: newLevel,
                    totalLifetimePoints: lifetimePoints,
                    bonuses: {
                        xpMultiplier: newXpMultiplier,
                        startingSkillBonus: newSkillBonus
                    }
                }
            };

            // Reset everything else
            gameData.version = VERSION;
            gameData.playtime = 0;
            gameData.inventory = [];
            gameData.visitedPlanets = [];
            gameData.discoveredPOIs = {};
            gameData.exploredTiles = {};
            gameData.playerRank = { points: 0, lastTitle: 'Novice Explorer' };

            // Reset skills with prestige bonus
            for (const skill of Object.keys(gameData.skills)) {
                gameData.skills[skill] = { level: 1 + newSkillBonus, xp: 0 };
            }

            // Reset statistics
            for (const stat of Object.keys(gameData.statistics)) {
                gameData.statistics[stat] = 0;
            }

            gameData.player = { hp: CONFIG.PLAYER_MAX_HP, maxHp: CONFIG.PLAYER_MAX_HP };

            // Restore kept data
            Object.assign(gameData, keepData);

            saveGameData();
            showNotification(`PRESTIGE ${newLevel}! XP +${Math.round((newXpMultiplier - 1) * 100)}%`, 'success');
            AudioSystem.levelUp();
            return true;
        }

        function getLeaderboardPosition() {
            const myPoints = calculatePlayerPoints();
            const allPlayers = [...SIMULATED_PLAYERS, { name: 'YOU', points: myPoints, rank: getPlayerRank().title }]
                .sort((a, b) => b.points - a.points);
            const myIndex = allPlayers.findIndex(p => p.name === 'YOU');
            return {
                position: myIndex + 1,
                total: allPlayers.length,
                nearby: allPlayers.slice(Math.max(0, myIndex - 2), myIndex + 3)
            };
        }

        // --- ACHIEVEMENT DEFINITIONS ---
        const ACHIEVEMENTS = {
            'first_landing': { name: 'First Contact', desc: 'Land on your first planet', icon: 'ðŸŒ' },
            'explorer_10': { name: 'Star Hopper', desc: 'Visit 10 different planets', icon: 'âœ¨' },
            'explorer_30': { name: 'Galaxy Wanderer', desc: 'Visit 30 planets', icon: 'ðŸš€' },
            'lumberjack_25': { name: 'Woodcutter', desc: 'Chop 25 trees', icon: 'ðŸª“' },
            'lumberjack_100': { name: 'Lumberjack', desc: 'Chop 100 trees', icon: 'ðŸŒ²' },
            'miner_25': { name: 'Prospector', desc: 'Mine 25 ore veins', icon: 'â›ï¸' },
            'miner_100': { name: 'Master Miner', desc: 'Mine 100 ore veins', icon: 'ðŸ’Ž' },
            'angler_10': { name: 'Fisherman', desc: 'Catch 10 fish', icon: 'ðŸŸ' },
            'angler_50': { name: 'Master Angler', desc: 'Catch 50 fish', icon: 'ðŸŽ£' },
            'slayer_10': { name: 'Slime Slayer', desc: 'Defeat 10 slimes', icon: 'âš”ï¸' },
            'slayer_50': { name: 'Exterminator', desc: 'Defeat 50 slimes', icon: 'ðŸ’€' },
            'crafter_10': { name: 'Apprentice', desc: 'Craft 10 items', icon: 'ðŸ”¨' },
            'crafter_50': { name: 'Master Craftsman', desc: 'Craft 50 items', icon: 'ðŸ†' },
            'max_skill': { name: 'Specialist', desc: 'Reach level 10 in any skill', icon: 'ðŸ“ˆ' },
            'playtime_1h': { name: 'Dedicated', desc: 'Play for 1 hour', icon: 'â°' },
            'survivor': { name: 'Survivor', desc: 'Heal 500 HP total', icon: 'â¤ï¸' },
            'daily_3': { name: 'Consistent', desc: 'Complete 3 daily challenges', icon: 'ðŸ“…' },
            'daily_7': { name: 'Weekly Warrior', desc: 'Complete 7 daily challenges', icon: 'ðŸ”¥' }
        };

        // --- DAILY CHALLENGE DEFINITIONS ---
        const DAILY_CHALLENGES = [
            { type: 'gather_logs', amount: 15, desc: 'Gather 15 logs', reward: { skill: 'wood', xp: 150 } },
            { type: 'gather_ore', amount: 12, desc: 'Mine 12 ore', reward: { skill: 'mining', xp: 150 } },
            { type: 'kill_mobs', amount: 5, desc: 'Defeat 5 slimes', reward: { skill: 'combat', xp: 200 } },
            { type: 'catch_fish', amount: 8, desc: 'Catch 8 fish', reward: { skill: 'fishing', xp: 150 } },
            { type: 'craft_items', amount: 3, desc: 'Craft 3 items', reward: { skill: 'crafting', xp: 100 } },
            { type: 'visit_planets', amount: 2, desc: 'Explore 2 new planets', reward: { skill: 'combat', xp: 200 } },
            { type: 'cook_fish', amount: 3, desc: 'Cook 3 fish', reward: { skill: 'cooking', xp: 120 } }
        ];

        // Tutorial functions
        function showTutorial() {
            document.getElementById('tutorial-overlay').style.display = 'flex';
        }

        function closeTutorial() {
            document.getElementById('tutorial-overlay').style.display = 'none';
            gameData.hasSeenTutorial = true;
            saveGameData();
            AudioSystem.click();
        }

        // --- ACHIEVEMENT SYSTEM ---
        function checkAchievements() {
            const s = gameData.statistics;
            const sk = gameData.skills;

            const checks = {
                'first_landing': () => gameData.visitedPlanets.length >= 1,
                'explorer_10': () => gameData.visitedPlanets.length >= 10,
                'explorer_30': () => gameData.visitedPlanets.length >= 30,
                'lumberjack_25': () => s.treesChopped >= 25,
                'lumberjack_100': () => s.treesChopped >= 100,
                'miner_25': () => s.oresMined >= 25,
                'miner_100': () => s.oresMined >= 100,
                'angler_10': () => s.fishCaught >= 10,
                'angler_50': () => s.fishCaught >= 50,
                'slayer_10': () => s.mobsKilled >= 10,
                'slayer_50': () => s.mobsKilled >= 50,
                'crafter_10': () => s.itemsCrafted >= 10,
                'crafter_50': () => s.itemsCrafted >= 50,
                'max_skill': () => Object.values(sk).some(skill => skill.level >= 10),
                'playtime_1h': () => gameData.playtime >= 3600,
                'survivor': () => (s.totalHealed || 0) >= 500,
                'daily_3': () => (gameData.dailyChallenge.completedCount || 0) >= 3,
                'daily_7': () => (gameData.dailyChallenge.completedCount || 0) >= 7
            };

            for (const [id, check] of Object.entries(checks)) {
                if (!gameData.achievements[id] && check()) {
                    unlockAchievement(id);
                }
            }
        }

        function unlockAchievement(id) {
            if (gameData.achievements[id]) return;

            const ach = ACHIEVEMENTS[id];
            if (!ach) return;

            gameData.achievements[id] = { unlockedAt: new Date().toISOString() };

            // Show achievement popup
            showAchievementPopup(ach.icon, ach.name, ach.desc);
            AudioSystem.levelUp();

            if (particles && worldState.player) {
                particles.emit(worldState.player.position, 25, 0xffd700, { spread: 6, lifetime: 1500 });
            }

            saveGameData();
        }

        function showAchievementPopup(icon, name, desc) {
            const popup = document.createElement('div');
            popup.className = 'achievement-popup';
            popup.innerHTML = `
                <div class="ach-icon">${icon}</div>
                <div class="ach-text">
                    <div class="ach-title">Achievement Unlocked!</div>
                    <div class="ach-name">${name}</div>
                    <div class="ach-desc">${desc}</div>
                </div>
            `;
            document.body.appendChild(popup);
            setTimeout(() => popup.remove(), 4000);
        }

        // --- DAILY CHALLENGE SYSTEM ---
        function generateDailyChallenge() {
            const today = new Date().toDateString();

            if (gameData.dailyChallenge.lastGenerated === today && gameData.dailyChallenge.current) {
                return gameData.dailyChallenge.current;
            }

            // Reset streak if missed a day
            if (gameData.dailyChallenge.lastGenerated) {
                const lastDate = new Date(gameData.dailyChallenge.lastGenerated);
                const now = new Date();
                const diffDays = Math.floor((now - lastDate) / (1000 * 60 * 60 * 24));
                if (diffDays > 1) {
                    gameData.dailyChallenge.streak = 0;
                }
            }

            // Use date as seed for consistent daily challenge
            const seed = new SeededRNG(today);
            const template = seed.pick(DAILY_CHALLENGES);
            const challenge = {
                ...template,
                progress: 0,
                startStats: { ...gameData.statistics },
                startPlanets: gameData.visitedPlanets.length
            };

            gameData.dailyChallenge.lastGenerated = today;
            gameData.dailyChallenge.current = challenge;
            gameData.dailyChallenge.completed = false;
            saveGameData();

            return challenge;
        }

        function updateDailyChallengeProgress() {
            if (!gameData.dailyChallenge.current || gameData.dailyChallenge.completed) return;

            const c = gameData.dailyChallenge.current;
            const start = c.startStats || {};
            const now = gameData.statistics;

            switch (c.type) {
                case 'gather_logs': c.progress = (now.treesChopped || 0) - (start.treesChopped || 0); break;
                case 'gather_ore': c.progress = (now.oresMined || 0) - (start.oresMined || 0); break;
                case 'kill_mobs': c.progress = (now.mobsKilled || 0) - (start.mobsKilled || 0); break;
                case 'catch_fish': c.progress = (now.fishCaught || 0) - (start.fishCaught || 0); break;
                case 'craft_items': c.progress = (now.itemsCrafted || 0) - (start.itemsCrafted || 0); break;
                case 'cook_fish': c.progress = (now.fishCooked || 0) - (start.fishCooked || 0); break;
                case 'visit_planets': c.progress = gameData.visitedPlanets.length - (c.startPlanets || 0); break;
            }

            if (c.progress >= c.amount && !gameData.dailyChallenge.completed) {
                completeDailyChallenge();
            }

            updateDailyChallengeUI();
        }

        function completeDailyChallenge() {
            gameData.dailyChallenge.completed = true;
            gameData.dailyChallenge.streak++;
            gameData.dailyChallenge.completedCount = (gameData.dailyChallenge.completedCount || 0) + 1;
            gameData.dailyChallenge.bestStreak = Math.max(gameData.dailyChallenge.bestStreak || 0, gameData.dailyChallenge.streak);

            // Apply reward with streak bonus
            const reward = gameData.dailyChallenge.current.reward;
            const streakMultiplier = 1 + (gameData.dailyChallenge.streak * 0.1);
            const xpReward = Math.floor(reward.xp * streakMultiplier);

            addXp(reward.skill, xpReward);

            showNotification(`Daily Challenge Complete! +${xpReward} ${reward.skill} XP (Streak: ${gameData.dailyChallenge.streak})`);
            AudioSystem.levelUp();

            checkAchievements();
            saveGameData();
        }

        function updateDailyChallengeUI() {
            const el = document.getElementById('daily-challenge');
            if (!el) return;

            const c = gameData.dailyChallenge.current;
            if (!c) {
                el.style.display = 'none';
                return;
            }

            el.style.display = 'block';
            document.getElementById('daily-desc').textContent = c.desc;
            document.getElementById('daily-progress-text').textContent = `${Math.min(c.progress || 0, c.amount)}/${c.amount}`;
            document.getElementById('daily-progress-fill').style.width = `${Math.min(100, ((c.progress || 0) / c.amount) * 100)}%`;
            document.getElementById('daily-streak').textContent = `Streak: ${gameData.dailyChallenge.streak} days`;

            if (gameData.dailyChallenge.completed) {
                el.classList.add('completed');
            } else {
                el.classList.remove('completed');
            }
        }

        // --- v4.2: PLAYER RANK SYSTEM ---
        function calculatePlayerPoints() {
            const s = gameData.statistics;
            const sk = gameData.skills;
            return (
                gameData.visitedPlanets.length * 50 +
                s.treesChopped * 2 +
                s.oresMined * 2 +
                s.mobsKilled * 10 +
                s.fishCaught * 3 +
                s.itemsCrafted * 5 +
                (s.poisDiscovered || 0) * 100 +
                Object.values(sk).reduce((sum, skill) => sum + skill.level * 20, 0) +
                Math.floor(gameData.playtime / 60)
            );
        }

        function getPlayerRank() {
            const points = calculatePlayerPoints();
            let rank = PLAYER_RANKS[0];
            for (const r of PLAYER_RANKS) {
                if (points >= r.points) rank = r;
            }
            return { ...rank, points };
        }

        function getSpecialTitles() {
            const s = gameData.statistics;
            const sk = gameData.skills;
            const titles = [];
            for (const [name, data] of Object.entries(SPECIAL_TITLES)) {
                if (data.condition(s, sk)) {
                    titles.push({ name, color: data.color });
                }
            }
            return titles;
        }

        function updatePlayerRank() {
            const rank = getPlayerRank();
            const oldTitle = gameData.playerRank?.lastTitle || 'Novice Explorer';

            gameData.playerRank = {
                points: rank.points,
                lastTitle: rank.title
            };

            // Show rank up notification
            if (rank.title !== oldTitle) {
                showNotification(`RANK UP! You are now: ${rank.title}`, 'success');
                AudioSystem.levelUp();
            }

            saveGameData();
        }

        // --- STATISTICS PANEL ---
        function showStatsPanel() {
            updateStatsDisplay();
            document.getElementById('stats-modal').style.display = 'flex';
        }

        function closeStatsModal() {
            document.getElementById('stats-modal').style.display = 'none';
        }

        // v4.9: Collection Codex System
        const CODEX_DATA = {
            creatures: [
                { id: 'wolf', name: 'Wolf', icon: 'ðŸº', biome: 'forest', description: 'A fierce forest predator' },
                { id: 'bear', name: 'Bear', icon: 'ðŸ»', biome: 'forest', description: 'Massive and dangerous' },
                { id: 'snake', name: 'Snake', icon: 'ðŸ', biome: 'desert', description: 'Venomous desert dweller' },
                { id: 'scorpion', name: 'Scorpion', icon: 'ðŸ¦‚', biome: 'desert', description: 'Deadly desert creature' },
                { id: 'yeti', name: 'Yeti', icon: 'ðŸ¦', biome: 'arctic', description: 'Legendary snow beast' },
                { id: 'penguin', name: 'Penguin', icon: 'ðŸ§', biome: 'arctic', description: 'Hardy arctic bird' },
                { id: 'shark', name: 'Shark', icon: 'ðŸ¦ˆ', biome: 'ocean', description: 'Apex ocean predator' },
                { id: 'octopus', name: 'Octopus', icon: 'ðŸ™', biome: 'ocean', description: 'Intelligent sea creature' },
                { id: 'dragon', name: 'Dragon', icon: 'ðŸ‰', biome: 'volcanic', description: 'Ancient fire-breathing beast' },
                { id: 'phoenix', name: 'Phoenix', icon: 'ðŸ”¥', biome: 'volcanic', description: 'Immortal flame bird' },
                { id: 'alien', name: 'Alien', icon: 'ðŸ‘½', biome: 'alien', description: 'Extraterrestrial lifeform' },
                { id: 'robot', name: 'Robot', icon: 'ðŸ¤–', biome: 'crystal', description: 'Mechanical guardian' },
                { id: 'elite', name: 'Elite Monster', icon: 'ðŸ‘¹', biome: 'any', description: 'Powerful elite creature' },
                { id: 'boss', name: 'World Boss', icon: 'ðŸ’€', biome: 'any', description: 'Legendary boss creature' }
            ],
            biomes: [
                { id: 'forest', name: 'Forest World', icon: 'ðŸŒ²', color: '#228B22' },
                { id: 'desert', name: 'Desert World', icon: 'ðŸœï¸', color: '#DEB887' },
                { id: 'arctic', name: 'Arctic World', icon: 'â„ï¸', color: '#87CEEB' },
                { id: 'ocean', name: 'Ocean World', icon: 'ðŸŒŠ', color: '#1E90FF' },
                { id: 'volcanic', name: 'Volcanic World', icon: 'ðŸŒ‹', color: '#FF4500' },
                { id: 'alien', name: 'Alien World', icon: 'ðŸ›¸', color: '#9400D3' },
                { id: 'crystal', name: 'Crystal World', icon: 'ðŸ’Ž', color: '#00CED1' },
                { id: 'mushroom', name: 'Mushroom World', icon: 'ðŸ„', color: '#FF69B4' }
            ]
        };

        function initCodexTracking() {
            if (!gameData.codex) {
                gameData.codex = {
                    creatures: {},
                    items: {},
                    biomes: {}
                };
            }
        }

        function trackCreatureKill(creatureType) {
            initCodexTracking();
            if (!gameData.codex.creatures[creatureType]) {
                gameData.codex.creatures[creatureType] = { count: 0, firstKill: Date.now() };
                showNotification(`New Codex Entry: ${creatureType}!`, 'success');
            }
            gameData.codex.creatures[creatureType].count++;
        }

        function trackItemDiscovery(itemName) {
            initCodexTracking();
            if (!gameData.codex.items[itemName]) {
                gameData.codex.items[itemName] = { count: 0, firstFound: Date.now() };
            }
            gameData.codex.items[itemName].count++;
        }

        function trackBiomeVisit(biomeType) {
            initCodexTracking();
            if (!gameData.codex.biomes[biomeType]) {
                gameData.codex.biomes[biomeType] = { visited: true, firstVisit: Date.now() };
                showNotification(`New Biome Discovered: ${biomeType}!`, 'success');
            }
        }

        function openCodexModal() {
            initCodexTracking();
            updateCodexDisplay();
            document.getElementById('codex-modal').style.display = 'flex';
        }

        function closeCodexModal() {
            document.getElementById('codex-modal').style.display = 'none';
        }

        function switchCodexTab(tab) {
            document.querySelectorAll('.codex-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.codex-content').forEach(c => c.style.display = 'none');
            document.querySelector(`.codex-tab[data-tab="${tab}"]`).classList.add('active');
            document.getElementById(`codex-${tab}`).style.display = 'block';
        }

        function updateCodexDisplay() {
            // Creatures
            const creaturesGrid = document.getElementById('codex-creatures-grid');
            let creaturesHtml = '';
            let discoveredCreatures = 0;
            CODEX_DATA.creatures.forEach(c => {
                const discovered = gameData.codex?.creatures?.[c.id];
                if (discovered) discoveredCreatures++;
                creaturesHtml += `
                    <div class="codex-entry ${discovered ? 'discovered' : 'undiscovered'}" title="${discovered ? c.description : '???'}">
                        <span class="entry-icon">${c.icon}</span>
                        <span class="entry-name">${discovered ? c.name : '???'}</span>
                        ${discovered ? `<span class="entry-count">Defeated: ${discovered.count}</span>` : ''}
                    </div>
                `;
            });
            creaturesGrid.innerHTML = creaturesHtml;
            document.getElementById('codex-creatures-count').textContent = discoveredCreatures;
            document.getElementById('codex-creatures-total').textContent = CODEX_DATA.creatures.length;

            // Items
            const itemsGrid = document.getElementById('codex-items-grid');
            let itemsHtml = '';
            let discoveredItems = 0;
            const allItems = Object.keys(ITEMS);
            allItems.forEach(itemName => {
                const item = ITEMS[itemName];
                const discovered = gameData.codex?.items?.[itemName];
                if (discovered) discoveredItems++;
                itemsHtml += `
                    <div class="codex-entry ${discovered ? 'discovered' : 'undiscovered'}" title="${discovered ? (item.description || itemName) : '???'}">
                        <span class="entry-icon">${item.icon || 'ðŸ“¦'}</span>
                        <span class="entry-name">${discovered ? itemName : '???'}</span>
                        ${discovered ? `<span class="entry-count">Found: ${discovered.count}</span>` : ''}
                    </div>
                `;
            });
            itemsGrid.innerHTML = itemsHtml;
            document.getElementById('codex-items-count').textContent = discoveredItems;
            document.getElementById('codex-items-total').textContent = allItems.length;

            // Biomes
            const biomesGrid = document.getElementById('codex-biomes-grid');
            let biomesHtml = '';
            let discoveredBiomes = 0;
            CODEX_DATA.biomes.forEach(b => {
                const discovered = gameData.codex?.biomes?.[b.id];
                if (discovered) discoveredBiomes++;
                biomesHtml += `
                    <div class="codex-entry ${discovered ? 'discovered' : 'undiscovered'}" style="${discovered ? `border-color: ${b.color}` : ''}">
                        <span class="entry-icon">${b.icon}</span>
                        <span class="entry-name">${discovered ? b.name : '???'}</span>
                    </div>
                `;
            });
            biomesGrid.innerHTML = biomesHtml;
            document.getElementById('codex-biomes-count').textContent = discoveredBiomes;
            document.getElementById('codex-biomes-total').textContent = CODEX_DATA.biomes.length;

            // Abilities
            const abilitiesGrid = document.getElementById('codex-abilities-grid');
            let abilitiesHtml = '';
            let unlockedAbilities = 0;
            const combatLevel = gameData.skills?.combat?.level || 1;
            Object.entries(COMBAT_ABILITIES).forEach(([key, ability]) => {
                const unlocked = combatLevel >= ability.unlockLevel;
                if (unlocked) unlockedAbilities++;
                abilitiesHtml += `
                    <div class="codex-entry ${unlocked ? 'discovered' : 'undiscovered'}" title="${unlocked ? ability.description : `Unlocks at Combat Lv ${ability.unlockLevel}`}">
                        <span class="entry-icon">${ability.icon}</span>
                        <span class="entry-name">${unlocked ? ability.name : '???'}</span>
                        <span class="entry-count">${unlocked ? `[${ability.key}]` : `Lv ${ability.unlockLevel}`}</span>
                    </div>
                `;
            });
            abilitiesGrid.innerHTML = abilitiesHtml;
            document.getElementById('codex-abilities-count').textContent = unlockedAbilities;
            document.getElementById('codex-abilities-total').textContent = Object.keys(COMBAT_ABILITIES).length;

            // v5.0: Pets
            initPetSystem();
            const petsGrid = document.getElementById('codex-pets-grid');
            let petsHtml = '';
            let collectedPets = 0;
            const ownedPets = gameData.pets?.owned || [];
            const activePet = gameData.pets?.active;

            Object.entries(PET_TYPES).forEach(([petId, pet]) => {
                const owned = ownedPets.includes(petId);
                const isActive = activePet === petId;
                if (owned) collectedPets++;

                petsHtml += `
                    <div class="codex-entry ${owned ? 'discovered' : 'undiscovered'} ${isActive ? 'active-pet' : ''}"
                         style="${owned ? `border-color: ${RARITY_COLORS[pet.rarity]}` : ''}; ${isActive ? 'box-shadow: 0 0 10px ' + RARITY_COLORS[pet.rarity] : ''}"
                         title="${owned ? pet.abilityDesc : '???'}"
                         onclick="${owned ? `setActivePet('${isActive ? '' : petId}')` : ''}">
                        <span class="entry-icon" style="font-size: 32px;">${pet.icon}</span>
                        <span class="entry-name" style="color: ${owned ? RARITY_COLORS[pet.rarity] : '#666'}">${owned ? pet.name : '???'}</span>
                        ${owned ? `<span class="entry-count" style="color: ${RARITY_COLORS[pet.rarity]}">${pet.rarity.toUpperCase()}</span>` : ''}
                        ${owned ? `<span style="font-size: 10px; color: #aaa;">${pet.abilityDesc}</span>` : ''}
                        ${isActive ? '<span style="color: #ff8c00; font-size: 10px;">ACTIVE</span>' : ''}
                    </div>
                `;
            });
            petsGrid.innerHTML = petsHtml;
            document.getElementById('codex-pets-count').textContent = collectedPets;
            document.getElementById('codex-pets-total').textContent = Object.keys(PET_TYPES).length;
            document.getElementById('active-pet-name').textContent = activePet ? PET_TYPES[activePet].name : 'None';
        }

        // v5.0: Quest System
        const QUEST_TEMPLATES = {
            daily: [
                { id: 'kill_mobs', name: 'Monster Hunter', desc: 'Defeat enemies', icon: 'âš”ï¸', target: 10, reward: { xp: 500, item: 'Health Potion' }, stat: 'mobsKilled' },
                { id: 'gather_wood', name: 'Lumberjack', desc: 'Chop down trees', icon: 'ðŸª“', target: 15, reward: { xp: 300 }, stat: 'treesChopped' },
                { id: 'mine_ore', name: 'Prospector', desc: 'Mine ore deposits', icon: 'â›ï¸', target: 10, reward: { xp: 400, item: 'Iron Ore' }, stat: 'oresMined' },
                { id: 'catch_fish', name: 'Angler', desc: 'Catch fish', icon: 'ðŸŽ£', target: 8, reward: { xp: 350 }, stat: 'fishCaught' },
                { id: 'visit_planets', name: 'Explorer', desc: 'Visit different planets', icon: 'ðŸŒ', target: 3, reward: { xp: 600 }, stat: 'planetsVisited' },
                { id: 'craft_items', name: 'Artisan', desc: 'Craft items', icon: 'ðŸ”¨', target: 5, reward: { xp: 400, item: 'Super Potion' }, stat: 'itemsCrafted' },
                { id: 'use_abilities', name: 'Ability Master', desc: 'Use combat abilities', icon: 'âœ¨', target: 20, reward: { xp: 450 }, stat: 'abilitiesUsed' },
                { id: 'kill_elites', name: 'Elite Slayer', desc: 'Defeat elite enemies', icon: 'ðŸ‘¹', target: 2, reward: { xp: 800, item: 'Void Fragment' }, stat: 'elitesKilled' }
            ],
            weekly: [
                { id: 'w_kill_mobs', name: 'Monster Massacre', desc: 'Defeat many enemies', icon: 'ðŸ’€', target: 100, reward: { xp: 5000, item: 'Legendary Blade' }, stat: 'mobsKilled' },
                { id: 'w_bosses', name: 'Boss Hunter', desc: 'Defeat world bosses', icon: 'ðŸ‰', target: 5, reward: { xp: 8000 }, stat: 'bossesDefeated' },
                { id: 'w_explore', name: 'Galactic Explorer', desc: 'Visit many planets', icon: 'ðŸš€', target: 15, reward: { xp: 6000 }, stat: 'planetsVisited' },
                { id: 'w_gather', name: 'Resource Mogul', desc: 'Gather total resources', icon: 'ðŸ“¦', target: 200, reward: { xp: 4000, item: 'Super Potion' }, stat: 'totalGathered' },
                { id: 'w_combat', name: 'Combat Veteran', desc: 'Deal damage with abilities', icon: 'âš¡', target: 50, reward: { xp: 5500 }, stat: 'abilitiesUsed' }
            ],
            story: [
                { id: 's_first_kill', name: 'First Blood', desc: 'Defeat your first enemy', icon: 'ðŸ©¸', target: 1, reward: { xp: 100 }, stat: 'mobsKilled', oneTime: true },
                { id: 's_first_planet', name: 'First Steps', desc: 'Visit your first planet', icon: 'ðŸ‘£', target: 1, reward: { xp: 200 }, stat: 'planetsVisited', oneTime: true },
                { id: 's_craft_weapon', name: 'Armed and Ready', desc: 'Craft a weapon', icon: 'ðŸ—¡ï¸', target: 1, reward: { xp: 300, item: 'Health Potion' }, stat: 'weaponsCrafted', oneTime: true },
                { id: 's_level_combat', name: 'Warrior\'s Path', desc: 'Reach Combat Level 5', icon: 'âš”ï¸', target: 5, reward: { xp: 500 }, stat: 'combatLevel', oneTime: true },
                { id: 's_first_boss', name: 'Giant Slayer', desc: 'Defeat a world boss', icon: 'ðŸ†', target: 1, reward: { xp: 1000, item: 'Magma Sword' }, stat: 'bossesDefeated', oneTime: true },
                { id: 's_master_combat', name: 'Combat Master', desc: 'Reach Combat Level 15', icon: 'ðŸŽ–ï¸', target: 15, reward: { xp: 2000 }, stat: 'combatLevel', oneTime: true },
                { id: 's_explore_all', name: 'Galaxy Conqueror', desc: 'Visit 30 planets', icon: 'ðŸŒŒ', target: 30, reward: { xp: 5000, item: 'Legendary Blade' }, stat: 'planetsVisited', oneTime: true },
                { id: 's_ultimate', name: 'Legendary Hero', desc: 'Reach Combat Level 20', icon: 'ðŸ‘‘', target: 20, reward: { xp: 10000 }, stat: 'combatLevel', oneTime: true }
            ]
        };

        function initQuestSystem() {
            if (!gameData.quests) {
                gameData.quests = {
                    daily: { quests: [], lastReset: 0, sessionStart: {} },
                    weekly: { quests: [], lastReset: 0, sessionStart: {} },
                    story: { completed: [], claimed: [] }
                };
            }
            checkQuestResets();
        }

        function checkQuestResets() {
            const now = Date.now();
            const dayMs = 24 * 60 * 60 * 1000;
            const weekMs = 7 * dayMs;

            // Daily reset (every 24 hours from first play)
            if (now - gameData.quests.daily.lastReset > dayMs) {
                generateDailyQuests();
            }

            // Weekly reset (every 7 days)
            if (now - gameData.quests.weekly.lastReset > weekMs) {
                generateWeeklyQuests();
            }
        }

        function generateDailyQuests() {
            const shuffled = [...QUEST_TEMPLATES.daily].sort(() => Math.random() - 0.5);
            const selected = shuffled.slice(0, 3);

            gameData.quests.daily = {
                quests: selected.map(q => ({ ...q, progress: 0, claimed: false })),
                lastReset: Date.now(),
                sessionStart: captureQuestStats()
            };
            saveGameData();
        }

        function generateWeeklyQuests() {
            const shuffled = [...QUEST_TEMPLATES.weekly].sort(() => Math.random() - 0.5);
            const selected = shuffled.slice(0, 2);

            gameData.quests.weekly = {
                quests: selected.map(q => ({ ...q, progress: 0, claimed: false })),
                lastReset: Date.now(),
                sessionStart: captureQuestStats()
            };
            saveGameData();
        }

        function captureQuestStats() {
            const s = gameData.statistics;
            return {
                mobsKilled: s.mobsKilled || 0,
                treesChopped: s.treesChopped || 0,
                oresMined: s.oresMined || 0,
                fishCaught: s.fishCaught || 0,
                planetsVisited: gameData.visitedPlanets.length,
                itemsCrafted: s.itemsCrafted || 0,
                bossesDefeated: s.bossesDefeated || 0,
                elitesKilled: s.elitesKilled || 0,
                abilitiesUsed: s.abilitiesUsed || 0,
                totalGathered: (s.treesChopped || 0) + (s.oresMined || 0) + (s.fishCaught || 0),
                combatLevel: gameData.skills?.combat?.level || 1,
                weaponsCrafted: s.weaponsCrafted || 0
            };
        }

        function getQuestProgress(quest, type) {
            const current = captureQuestStats();
            const start = gameData.quests[type]?.sessionStart || {};

            if (quest.oneTime) {
                return current[quest.stat] || 0;
            }

            const startVal = start[quest.stat] || 0;
            const currentVal = current[quest.stat] || 0;
            return Math.max(0, currentVal - startVal);
        }

        function openQuestModal() {
            initQuestSystem();
            updateQuestDisplay();
            document.getElementById('quest-modal').style.display = 'flex';
            startQuestTimers();
        }

        function closeQuestModal() {
            document.getElementById('quest-modal').style.display = 'none';
        }

        function switchQuestTab(tab) {
            document.querySelectorAll('#quest-modal .codex-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.quest-content').forEach(c => c.style.display = 'none');
            document.querySelector(`#quest-modal .codex-tab[data-tab="${tab}"]`).classList.add('active');
            document.getElementById(`quest-${tab}`).style.display = 'block';
        }

        let questTimerInterval = null;
        function startQuestTimers() {
            if (questTimerInterval) clearInterval(questTimerInterval);
            questTimerInterval = setInterval(updateQuestTimers, 1000);
            updateQuestTimers();
        }

        function updateQuestTimers() {
            const now = Date.now();
            const dayMs = 24 * 60 * 60 * 1000;
            const weekMs = 7 * dayMs;

            const dailyReset = (gameData.quests?.daily?.lastReset || now) + dayMs;
            const weeklyReset = (gameData.quests?.weekly?.lastReset || now) + weekMs;

            document.getElementById('daily-reset-timer').textContent = formatTimeRemaining(dailyReset - now);
            document.getElementById('weekly-reset-timer').textContent = formatTimeRemaining(weeklyReset - now);
        }

        function formatTimeRemaining(ms) {
            if (ms <= 0) return 'Resetting...';
            const hours = Math.floor(ms / (60 * 60 * 1000));
            const mins = Math.floor((ms % (60 * 60 * 1000)) / (60 * 1000));
            const secs = Math.floor((ms % (60 * 1000)) / 1000);
            return `${hours}h ${mins}m ${secs}s`;
        }

        function updateQuestDisplay() {
            // Daily quests
            const dailyList = document.getElementById('daily-quests-list');
            dailyList.innerHTML = renderQuestList(gameData.quests.daily.quests, 'daily');

            // Weekly quests
            const weeklyList = document.getElementById('weekly-quests-list');
            weeklyList.innerHTML = renderQuestList(gameData.quests.weekly.quests, 'weekly');

            // Story quests
            const storyList = document.getElementById('story-quests-list');
            storyList.innerHTML = renderStoryQuests();
        }

        function renderQuestList(quests, type) {
            return quests.map((quest, idx) => {
                const progress = getQuestProgress(quest, type);
                const percent = Math.min(100, (progress / quest.target) * 100);
                const completed = progress >= quest.target;
                const claimed = quest.claimed;

                return `
                    <div class="quest-item ${completed ? 'completed' : ''} ${claimed ? 'claimed' : ''}">
                        <div class="quest-header">
                            <span class="quest-title">${quest.icon} ${quest.name}</span>
                            <span class="quest-reward">+${quest.reward.xp} XP${quest.reward.item ? ` + ${quest.reward.item}` : ''}</span>
                        </div>
                        <div class="quest-desc">${quest.desc}</div>
                        <div class="quest-progress-bar">
                            <div class="quest-progress-fill" style="width: ${percent}%"></div>
                        </div>
                        <div class="quest-progress-text">${Math.min(progress, quest.target)} / ${quest.target}</div>
                        ${completed && !claimed ? `<button class="quest-claim-btn" onclick="claimQuest('${type}', ${idx})">Claim Reward</button>` : ''}
                        ${claimed ? '<div style="text-align: center; color: #4a4; font-size: 12px; margin-top: 8px;">âœ“ Claimed</div>' : ''}
                    </div>
                `;
            }).join('');
        }

        function renderStoryQuests() {
            return QUEST_TEMPLATES.story.map((quest, idx) => {
                const progress = captureQuestStats()[quest.stat] || 0;
                const percent = Math.min(100, (progress / quest.target) * 100);
                const completed = progress >= quest.target;
                const claimed = gameData.quests.story.claimed.includes(quest.id);

                return `
                    <div class="quest-item ${completed ? 'completed' : ''} ${claimed ? 'claimed' : ''}">
                        <div class="quest-header">
                            <span class="quest-title">${quest.icon} ${quest.name}</span>
                            <span class="quest-reward">+${quest.reward.xp} XP${quest.reward.item ? ` + ${quest.reward.item}` : ''}</span>
                        </div>
                        <div class="quest-desc">${quest.desc}</div>
                        <div class="quest-progress-bar">
                            <div class="quest-progress-fill" style="width: ${percent}%"></div>
                        </div>
                        <div class="quest-progress-text">${Math.min(progress, quest.target)} / ${quest.target}</div>
                        ${completed && !claimed ? `<button class="quest-claim-btn" onclick="claimStoryQuest('${quest.id}')">Claim Reward</button>` : ''}
                        ${claimed ? '<div style="text-align: center; color: #4a4; font-size: 12px; margin-top: 8px;">âœ“ Completed</div>' : ''}
                    </div>
                `;
            }).join('');
        }

        function claimQuest(type, idx) {
            const quest = gameData.quests[type].quests[idx];
            if (!quest || quest.claimed) return;

            quest.claimed = true;

            // Grant rewards
            addXp('combat', quest.reward.xp);
            if (quest.reward.item) {
                addItem(quest.reward.item);
            }

            showNotification(`Quest Complete: ${quest.name}! +${quest.reward.xp} XP`, 'success');
            AudioSystem.levelUp();

            if (worldState.player && particles) {
                particles.emit(worldState.player.position, 30, 0xffd700, { spread: 5, lifetime: 1000 });
            }

            saveGameData();
            updateQuestDisplay();
        }

        function claimStoryQuest(questId) {
            if (gameData.quests.story.claimed.includes(questId)) return;

            const quest = QUEST_TEMPLATES.story.find(q => q.id === questId);
            if (!quest) return;

            gameData.quests.story.claimed.push(questId);

            // Grant rewards
            addXp('combat', quest.reward.xp);
            if (quest.reward.item) {
                addItem(quest.reward.item);
            }

            showNotification(`Story Quest Complete: ${quest.name}!`, 'success');
            AudioSystem.levelUp();

            if (worldState.player && particles) {
                particles.emit(worldState.player.position, 40, 0xffd700, { spread: 6, lifetime: 1200 });
            }

            saveGameData();
            updateQuestDisplay();
        }

        // Track ability usage for quests
        function trackAbilityUsage() {
            if (!gameData.statistics.abilitiesUsed) gameData.statistics.abilitiesUsed = 0;
            gameData.statistics.abilitiesUsed++;
        }

        // v5.0: Pet Companion System
        const PET_TYPES = {
            slime: {
                name: 'Slime Buddy',
                icon: 'ðŸŸ¢',
                color: 0x44ff44,
                rarity: 'common',
                dropChance: 0.05,
                ability: 'regen',
                abilityDesc: '+1 HP/5s',
                speed: 3
            },
            firefly: {
                name: 'Firefly',
                icon: 'âœ¨',
                color: 0xffff00,
                rarity: 'common',
                dropChance: 0.04,
                ability: 'light',
                abilityDesc: 'Reveals hidden items',
                speed: 5
            },
            crystal: {
                name: 'Crystal Sprite',
                icon: 'ðŸ’Ž',
                color: 0x00ffff,
                rarity: 'uncommon',
                dropChance: 0.02,
                ability: 'luck',
                abilityDesc: '+10% drop rate',
                speed: 4
            },
            shadow: {
                name: 'Shadow Wisp',
                icon: 'ðŸ‘»',
                color: 0x8800ff,
                rarity: 'uncommon',
                dropChance: 0.02,
                ability: 'dodge',
                abilityDesc: '+5% dodge chance',
                speed: 6
            },
            phoenix: {
                name: 'Mini Phoenix',
                icon: 'ðŸ”¥',
                color: 0xff4400,
                rarity: 'rare',
                dropChance: 0.008,
                ability: 'damage',
                abilityDesc: '+15% damage',
                speed: 5
            },
            dragon: {
                name: 'Baby Dragon',
                icon: 'ðŸ²',
                color: 0xff0088,
                rarity: 'rare',
                dropChance: 0.005,
                ability: 'attack',
                abilityDesc: 'Attacks nearby enemies',
                speed: 4
            },
            void: {
                name: 'Void Entity',
                icon: 'ðŸŒ€',
                color: 0x4400ff,
                rarity: 'legendary',
                dropChance: 0.002,
                ability: 'absorb',
                abilityDesc: '+25% XP gain',
                speed: 3
            },
            celestial: {
                name: 'Celestial Star',
                icon: 'â­',
                color: 0xffd700,
                rarity: 'legendary',
                dropChance: 0.001,
                ability: 'allStats',
                abilityDesc: '+10% all stats',
                speed: 7
            }
        };

        const RARITY_COLORS = {
            common: '#aaaaaa',
            uncommon: '#00ff00',
            rare: '#0088ff',
            legendary: '#ff8800'
        };

        let activePetMesh = null;
        let petAnimTime = 0;

        function initPetSystem() {
            if (!gameData.pets) {
                gameData.pets = {
                    owned: [],
                    active: null
                };
            }
        }

        function tryDropPet(mobType) {
            initPetSystem();
            // Each mob kill has a chance to drop a random pet
            for (const [petId, pet] of Object.entries(PET_TYPES)) {
                if (Math.random() < pet.dropChance) {
                    if (!gameData.pets.owned.includes(petId)) {
                        gameData.pets.owned.push(petId);
                        showNotification(`NEW PET: ${pet.icon} ${pet.name}!`, 'success');
                        AudioSystem.levelUp();
                        if (worldState.player && particles) {
                            particles.emit(worldState.player.position, 40, pet.color, { spread: 6, lifetime: 1500 });
                        }
                        saveGameData();
                        return true;
                    }
                }
            }
            return false;
        }

        function setActivePet(petId) {
            initPetSystem();
            if (petId && !gameData.pets.owned.includes(petId)) return;

            gameData.pets.active = petId;
            updatePetMesh();
            saveGameData();

            if (petId) {
                const pet = PET_TYPES[petId];
                showNotification(`${pet.icon} ${pet.name} is now your companion!`);
            } else {
                showNotification('Pet dismissed');
            }
        }

        function updatePetMesh() {
            // Remove existing pet
            if (activePetMesh) {
                scene.remove(activePetMesh);
                activePetMesh = null;
            }

            if (!gameData.pets?.active || mode !== 'world') return;

            const pet = PET_TYPES[gameData.pets.active];
            if (!pet) return;

            // Create pet mesh
            const geometry = new THREE.SphereGeometry(0.4, 8, 8);
            const material = new THREE.MeshStandardMaterial({
                color: pet.color,
                emissive: pet.color,
                emissiveIntensity: 0.5
            });
            activePetMesh = new THREE.Mesh(geometry, material);
            activePetMesh.castShadow = true;

            // Add glow
            const glowGeo = new THREE.SphereGeometry(0.6, 8, 8);
            const glowMat = new THREE.MeshBasicMaterial({
                color: pet.color,
                transparent: true,
                opacity: 0.3
            });
            const glow = new THREE.Mesh(glowGeo, glowMat);
            activePetMesh.add(glow);

            scene.add(activePetMesh);
        }

        function updatePet(dt, time) {
            if (!activePetMesh || !worldState.player) return;

            const pet = PET_TYPES[gameData.pets?.active];
            if (!pet) return;

            petAnimTime += dt;

            // Follow player with offset
            const targetX = worldState.player.position.x + Math.sin(petAnimTime * 2) * 1.5;
            const targetZ = worldState.player.position.z + Math.cos(petAnimTime * 2) * 1.5;
            const targetY = worldState.player.position.y + 2 + Math.sin(petAnimTime * 3) * 0.3;

            // Smooth follow
            activePetMesh.position.x += (targetX - activePetMesh.position.x) * dt * pet.speed;
            activePetMesh.position.z += (targetZ - activePetMesh.position.z) * dt * pet.speed;
            activePetMesh.position.y += (targetY - activePetMesh.position.y) * dt * pet.speed;

            // Rotate
            activePetMesh.rotation.y += dt * 2;

            // Dragon attack ability
            if (pet.ability === 'attack' && Math.random() < 0.01) {
                const nearestMob = findNearestMob(activePetMesh.position, 8);
                if (nearestMob) {
                    const damage = Math.max(1, Math.floor(getPlayerDamage() * 0.3));
                    nearestMob.userData.hp -= damage;
                    spawnFloater(nearestMob.position, `ðŸ² -${damage}`, '#ff0088');
                    if (particles) particles.emit(nearestMob.position, 5, 0xff0088);
                    if (nearestMob.userData.hp <= 0) {
                        performAction(nearestMob);
                    }
                }
            }
        }

        function findNearestMob(position, range) {
            let nearest = null;
            let minDist = range;
            worldState.mobs.forEach(mob => {
                const dist = mob.position.distanceTo(position);
                if (dist < minDist) {
                    minDist = dist;
                    nearest = mob;
                }
            });
            return nearest;
        }

        function getPetBonuses() {
            const bonuses = {
                regen: 0,
                luck: 0,
                dodge: 0,
                damage: 0,
                xp: 0,
                allStats: 0
            };

            if (!gameData.pets?.active) return bonuses;

            const pet = PET_TYPES[gameData.pets.active];
            if (!pet) return bonuses;

            switch (pet.ability) {
                case 'regen': bonuses.regen = 1; break;
                case 'luck': bonuses.luck = 0.1; break;
                case 'dodge': bonuses.dodge = 0.05; break;
                case 'damage': bonuses.damage = 0.15; break;
                case 'absorb': bonuses.xp = 0.25; break;
                case 'allStats': bonuses.allStats = 0.1; break;
            }

            return bonuses;
        }

        // Pet regen tick
        let lastPetRegenTick = 0;
        function updatePetRegen(time) {
            const bonuses = getPetBonuses();
            if (bonuses.regen > 0 && time - lastPetRegenTick > 5000) {
                lastPetRegenTick = time;
                if (gameData.player.hp < gameData.player.maxHp) {
                    gameData.player.hp = Math.min(gameData.player.maxHp, gameData.player.hp + bonuses.regen);
                    updateHealthUI();
                    if (worldState.player) {
                        spawnFloater(worldState.player.position, `+${bonuses.regen}`, '#88ff88');
                    }
                }
            }
        }

        // ============================================
        // v5.6: COPILOT COMPANION SYSTEM
        // Follows the player with advice and assistance
        // ============================================
        let copilotMesh = null;
        let copilotAnimTime = 0;
        let copilotChatOpen = false;
        let copilotConversationHistory = [];
        let copilotVoiceRecognition = null;
        let copilotIsListening = false;
        let copilotSynthesis = window.speechSynthesis;
        let speechRecognizer = null; // v5.9: Azure Speech SDK recognizer

        const COPILOT_CONFIG = {
            followDistance: 3,      // Distance behind player
            floatHeight: 2.5,       // Height above ground
            floatAmplitude: 0.4,    // Bobbing amount
            floatSpeed: 2,          // Bobbing speed
            orbitSpeed: 0.5,        // Circling speed
            followSmoothing: 4,     // How quickly it catches up
            color: 0x8a2be2,        // Primary color (purple)
            glowColor: 0x06ffa5,    // Glow color (cyan/green)
            particleCount: 30
        };

        // Context-aware responses based on game state
        const COPILOT_RESPONSES = {
            greeting: [
                "Hello, Explorer! Ready for adventure?",
                "Greetings! I'm here to help you on your journey.",
                "Welcome back! What shall we explore today?"
            ],
            lowHealth: [
                "Careful! Your health is low. Consider using a health potion or retreating.",
                "You're wounded! Look for healing items or rest at a safe spot.",
                "Warning: Low HP! Maybe craft some health potions?"
            ],
            nearEnemy: [
                "Enemy spotted nearby! Prepare for combat.",
                "Be cautious, there's a hostile creature close by.",
                "I sense danger ahead. Ready your weapon!"
            ],
            afterKill: [
                "Well done! That was impressive combat.",
                "Excellent work, Explorer!",
                "Another victory! Your skills are improving."
            ],
            exploration: [
                "This area looks interesting. Let's explore!",
                "I wonder what secrets this place holds...",
                "Keep your eyes open for resources and treasures."
            ],
            tips: [
                "Tip: Use WASD to move and click to attack enemies.",
                "Tip: Collect resources to craft better equipment.",
                "Tip: Your combat skill increases as you defeat enemies.",
                "Tip: Look for points of interest marked on the minimap.",
                "Tip: Different biomes have different resources and enemies.",
                "Tip: Pets can help you in combat and provide bonuses."
            ],
            whatNext: [
                "Try exploring new areas to find resources and level up.",
                "You could hunt some enemies to gain XP and loot.",
                "Check your inventory - maybe craft some new equipment.",
                "Have you discovered all the points of interest on this planet?"
            ],
            getStronger: [
                "Fight enemies to gain combat XP and level up your skills.",
                "Craft better weapons and armor from the resources you gather.",
                "Find and bond with a pet companion for stat bonuses.",
                "Complete daily challenges for bonus rewards.",
                "Unlock talents in the talent tree as you level up."
            ],
            enemies: [
                "Enemies respawn periodically throughout the world.",
                "Look for the red markers on your minimap.",
                "Elite enemies (marked with special effects) drop better loot.",
                "Different biomes have different enemy types."
            ]
        };

        function initCopilotCompanion() {
            // Initialize speech recognition if available (browser fallback)
            if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                copilotVoiceRecognition = new SpeechRecognition();
                copilotVoiceRecognition.continuous = false;
                copilotVoiceRecognition.interimResults = true; // v5.9: Enable interim results
                copilotVoiceRecognition.lang = 'en-US';

                copilotVoiceRecognition.onresult = (event) => {
                    let interimTranscript = '';
                    let finalTranscript = '';

                    for (let i = event.resultIndex; i < event.results.length; i++) {
                        const transcript = event.results[i][0].transcript;
                        if (event.results[i].isFinal) {
                            finalTranscript += transcript;
                        } else {
                            interimTranscript += transcript;
                        }
                    }

                    // Update overlay with real-time transcription
                    if (finalTranscript) {
                        updateSTTTranscript(finalTranscript, true);
                    } else if (interimTranscript) {
                        updateSTTTranscript(interimTranscript, false);
                    }
                };

                copilotVoiceRecognition.onend = () => {
                    copilotIsListening = false;
                    document.getElementById('copilot-voice-btn').classList.remove('recording');
                };

                copilotVoiceRecognition.onerror = (event) => {
                    copilotIsListening = false;
                    document.getElementById('copilot-voice-btn').classList.remove('recording');
                    showSTTOverlay(false);
                    console.error('Browser STT error:', event.error);
                };
            }
        }

        function createCopilotMesh() {
            if (copilotMesh) {
                scene.remove(copilotMesh);
                copilotMesh = null;
            }

            if (mode !== 'world' || !worldState.player) return;

            const companionGroup = new THREE.Group();

            // Main orb
            const orbGeometry = new THREE.SphereGeometry(0.5, 24, 24);
            const orbMaterial = new THREE.MeshStandardMaterial({
                color: COPILOT_CONFIG.color,
                emissive: COPILOT_CONFIG.color,
                emissiveIntensity: 0.6,
                metalness: 0.8,
                roughness: 0.2,
                transparent: true,
                opacity: 0.9
            });
            const orb = new THREE.Mesh(orbGeometry, orbMaterial);
            companionGroup.add(orb);

            // Inner glow core
            const coreGeometry = new THREE.SphereGeometry(0.3, 16, 16);
            const coreMaterial = new THREE.MeshBasicMaterial({
                color: COPILOT_CONFIG.glowColor,
                transparent: true,
                opacity: 0.8
            });
            const core = new THREE.Mesh(coreGeometry, coreMaterial);
            companionGroup.add(core);

            // Outer glow
            const glowGeometry = new THREE.SphereGeometry(0.7, 16, 16);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: COPILOT_CONFIG.glowColor,
                transparent: true,
                opacity: 0.2,
                side: THREE.BackSide
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            companionGroup.add(glow);

            // Point light for illumination
            const light = new THREE.PointLight(COPILOT_CONFIG.glowColor, 1.5, 8);
            companionGroup.add(light);

            // Particle ring
            const particleGeometry = new THREE.BufferGeometry();
            const particleCount = COPILOT_CONFIG.particleCount;
            const positions = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount * 3; i += 3) {
                const angle = (i / 3) * (Math.PI * 2 / particleCount);
                const radius = 0.8 + Math.random() * 0.3;
                positions[i] = Math.cos(angle) * radius;
                positions[i + 1] = (Math.random() - 0.5) * 0.4;
                positions[i + 2] = Math.sin(angle) * radius;
            }

            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            const particleMaterial = new THREE.PointsMaterial({
                color: COPILOT_CONFIG.glowColor,
                size: 0.08,
                transparent: true,
                opacity: 0.7,
                blending: THREE.AdditiveBlending
            });

            const particles = new THREE.Points(particleGeometry, particleMaterial);
            companionGroup.add(particles);

            // Store references for animation
            companionGroup.userData = {
                orb: orb,
                core: core,
                glow: glow,
                light: light,
                particles: particles,
                isClickable: true,
                isCopilot: true
            };

            // Position initially near player
            if (worldState.player) {
                companionGroup.position.copy(worldState.player.position);
                companionGroup.position.y += COPILOT_CONFIG.floatHeight;
                companionGroup.position.z += COPILOT_CONFIG.followDistance;
            }

            scene.add(companionGroup);
            copilotMesh = companionGroup;
        }

        function updateCopilotCompanion(dt, time) {
            if (!copilotMesh || !worldState.player || mode !== 'world') return;

            copilotAnimTime += dt;

            // Calculate target position (behind and above player)
            const playerPos = worldState.player.position;
            const playerRotY = worldState.player.rotation.y;

            // Orbit slightly around the player
            const orbitAngle = copilotAnimTime * COPILOT_CONFIG.orbitSpeed;
            const offsetX = Math.sin(playerRotY + orbitAngle + Math.PI) * COPILOT_CONFIG.followDistance;
            const offsetZ = Math.cos(playerRotY + orbitAngle + Math.PI) * COPILOT_CONFIG.followDistance;

            const targetX = playerPos.x + offsetX;
            const targetZ = playerPos.z + offsetZ;
            const targetY = playerPos.y + COPILOT_CONFIG.floatHeight +
                           Math.sin(copilotAnimTime * COPILOT_CONFIG.floatSpeed) * COPILOT_CONFIG.floatAmplitude;

            // Smooth follow
            const smoothing = COPILOT_CONFIG.followSmoothing * dt;
            copilotMesh.position.x += (targetX - copilotMesh.position.x) * smoothing;
            copilotMesh.position.z += (targetZ - copilotMesh.position.z) * smoothing;
            copilotMesh.position.y += (targetY - copilotMesh.position.y) * smoothing;

            // Rotate particles
            if (copilotMesh.userData.particles) {
                copilotMesh.userData.particles.rotation.y += dt * 1.5;
            }

            // Pulse glow effect
            const pulse = 0.5 + Math.sin(time * 0.003) * 0.3;
            if (copilotMesh.userData.glow) {
                copilotMesh.userData.glow.material.opacity = 0.15 + pulse * 0.1;
            }
            if (copilotMesh.userData.light) {
                copilotMesh.userData.light.intensity = 1 + pulse;
            }
            if (copilotMesh.userData.orb) {
                copilotMesh.userData.orb.material.emissiveIntensity = 0.4 + pulse * 0.4;
            }

            // Make copilot face camera
            copilotMesh.lookAt(camera.position);
        }

        function toggleCopilotChat() {
            copilotChatOpen = !copilotChatOpen;
            const chatInterface = document.getElementById('copilot-chat-interface');
            const button = document.getElementById('copilot-button');

            if (copilotChatOpen) {
                chatInterface.classList.add('active');
                button.classList.add('active');
                document.getElementById('copilot-chat-input').focus();
            } else {
                chatInterface.classList.remove('active');
                button.classList.remove('active');
            }
        }

        async function sendCopilotMessage() {
            const input = document.getElementById('copilot-chat-input');
            const message = input.value.trim();
            if (!message) return;

            // Add user message to chat
            addCopilotMessage(message, 'user');
            input.value = '';

            // Add to history
            copilotConversationHistory.push({ role: 'user', content: message });

            // Show typing indicator
            showCopilotTyping();

            // Check if RAPPID is configured for AI-powered responses
            const hasRappid = rappidSettings.rappid && getActiveEndpoint();

            if (hasRappid) {
                // Use RAPPID API for response
                try {
                    // v5.9: Response now contains { text, voice } - text for display, voice for TTS
                    const response = await generateCopilotResponseWithRappid(message);
                    hideCopilotTyping();
                    // Display the full text response in chat
                    addCopilotMessage(response.text, 'ai');
                    copilotConversationHistory.push({ role: 'assistant', content: response.text });
                    animateCopilotResponse();

                    // v5.9: Use voice_response for TTS (concise, no formatting)
                    if (rappidSettings.azureTTSKey && rappidSettings.azureRegion) {
                        speakWithAzureTTS(response.voice);
                    } else {
                        speakCopilotResponse(response.voice);
                    }
                } catch (error) {
                    console.error('RAPPID response error:', error);
                    hideCopilotTyping();
                    const fallbackResponse = generateCopilotResponse(message);
                    addCopilotMessage(fallbackResponse, 'ai');
                    speakCopilotResponse(fallbackResponse);
                }
            } else {
                // Use local responses
                setTimeout(() => {
                    hideCopilotTyping();
                    const response = generateCopilotResponse(message);
                    addCopilotMessage(response, 'ai');
                    copilotConversationHistory.push({ role: 'assistant', content: response });

                    // Animate copilot when responding
                    animateCopilotResponse();

                    // Optionally speak the response
                    speakCopilotResponse(response);
                }, 800 + Math.random() * 700);
            }
        }

        function sendCopilotQuickMessage(message) {
            document.getElementById('copilot-chat-input').value = message;
            sendCopilotMessage();
        }

        function generateCopilotResponse(message) {
            const lowerMessage = message.toLowerCase();

            // Context-aware responses
            if (lowerMessage.includes('health') || lowerMessage.includes('hp') || lowerMessage.includes('hurt')) {
                if (gameData.player.hp < gameData.player.maxHp * 0.3) {
                    return getRandomResponse(COPILOT_RESPONSES.lowHealth);
                }
                return `Your health is ${gameData.player.hp}/${gameData.player.maxHp}. ${gameData.player.hp < gameData.player.maxHp * 0.5 ? 'Consider healing up!' : 'You\'re in good shape!'}`;
            }

            if (lowerMessage.includes('tip') || lowerMessage.includes('help') || lowerMessage.includes('advice')) {
                return getRandomResponse(COPILOT_RESPONSES.tips);
            }

            if (lowerMessage.includes('what') && (lowerMessage.includes('next') || lowerMessage.includes('do'))) {
                return getRandomResponse(COPILOT_RESPONSES.whatNext);
            }

            if (lowerMessage.includes('strong') || lowerMessage.includes('level') || lowerMessage.includes('power')) {
                return getRandomResponse(COPILOT_RESPONSES.getStronger);
            }

            if (lowerMessage.includes('enemy') || lowerMessage.includes('enemies') || lowerMessage.includes('monster')) {
                return getRandomResponse(COPILOT_RESPONSES.enemies);
            }

            if (lowerMessage.includes('hello') || lowerMessage.includes('hi') || lowerMessage.includes('hey')) {
                return getRandomResponse(COPILOT_RESPONSES.greeting);
            }

            if (lowerMessage.includes('explore') || lowerMessage.includes('where')) {
                return getRandomResponse(COPILOT_RESPONSES.exploration);
            }

            if (lowerMessage.includes('stats') || lowerMessage.includes('status')) {
                return `Stats: Combat Lvl ${gameData.skills.combat.level}, HP: ${gameData.player.hp}/${gameData.player.maxHp}, XP: ${gameData.skills.combat.xp}/${gameData.skills.combat.xpNeeded}`;
            }

            if (lowerMessage.includes('pet') || lowerMessage.includes('companion')) {
                const activePet = gameData.pets?.active;
                if (activePet) {
                    const pet = PET_TYPES[activePet];
                    return `You have ${pet.name} (${pet.icon}) as your pet companion. ${pet.abilityDesc}. You can find more pets by defeating enemies!`;
                }
                return "You don't have an active pet. Defeat enemies to find pet companions that can help you!";
            }

            // Default response
            const defaults = [
                "I'm here to help! Try asking about tips, enemies, or how to get stronger.",
                "Interesting question! I can help with game tips, enemy locations, and advice.",
                "Let me think... Try asking 'What should I do next?' or 'Give me a tip' for guidance.",
                "I'm your Copilot! Ask me about your health, enemies, or exploration tips."
            ];
            return getRandomResponse(defaults);
        }

        function getRandomResponse(responses) {
            return responses[Math.floor(Math.random() * responses.length)];
        }

        function addCopilotMessage(text, sender) {
            const messagesContainer = document.getElementById('copilot-chat-messages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `copilot-message ${sender}`;
            messageDiv.textContent = text;
            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        function showCopilotTyping() {
            const messagesContainer = document.getElementById('copilot-chat-messages');
            const typingDiv = document.createElement('div');
            typingDiv.id = 'copilot-typing';
            typingDiv.className = 'copilot-typing';
            typingDiv.innerHTML = '<div class="copilot-typing-dot"></div><div class="copilot-typing-dot"></div><div class="copilot-typing-dot"></div>';
            messagesContainer.appendChild(typingDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        function hideCopilotTyping() {
            const typing = document.getElementById('copilot-typing');
            if (typing) typing.remove();
        }

        function animateCopilotResponse() {
            if (!copilotMesh || !copilotMesh.userData.orb) return;

            const orb = copilotMesh.userData.orb;
            const originalScale = 1;
            let progress = 0;

            const animate = () => {
                progress += 0.08;
                if (progress > 1) return;

                const scale = originalScale + Math.sin(progress * Math.PI) * 0.3;
                orb.scale.setScalar(scale);

                if (copilotMesh.userData.light) {
                    copilotMesh.userData.light.intensity = 2 + Math.sin(progress * Math.PI * 2) * 1.5;
                }

                requestAnimationFrame(animate);
            };
            animate();
        }

        function speakCopilotResponse(text) {
            if (!copilotSynthesis) return;

            // Cancel any ongoing speech
            copilotSynthesis.cancel();

            const utterance = new SpeechSynthesisUtterance(text);
            utterance.rate = 1.0;
            utterance.pitch = 1.1;
            utterance.volume = 0.8;

            // Try to use a female voice
            const voices = copilotSynthesis.getVoices();
            const preferredVoice = voices.find(v => v.name.includes('Female') || v.name.includes('Samantha') || v.name.includes('Google'));
            if (preferredVoice) utterance.voice = preferredVoice;

            utterance.onstart = () => {
                document.getElementById('copilot-voice-indicator').classList.add('active');
            };

            utterance.onend = () => {
                document.getElementById('copilot-voice-indicator').classList.remove('active');
            };

            copilotSynthesis.speak(utterance);
        }

        // v5.9: Toggle voice input - click to start/stop
        let sttFinalTranscript = '';

        async function toggleCopilotVoice() {
            if (copilotIsListening) {
                stopCopilotVoice();
                return;
            }

            // Check if Azure Speech SDK should be used
            if (rappidSettings.azureTTSKey && rappidSettings.azureRegion) {
                await startAzureSTT();
            } else if (copilotVoiceRecognition) {
                // Fall back to browser speech recognition
                startBrowserSTT();
            } else {
                console.warn('No speech recognition available');
                alert('Speech recognition not available. Please configure Azure Speech key in RAPPID settings.');
            }
        }

        // Show/hide transcription overlay
        function showSTTOverlay(show) {
            const overlay = document.getElementById('stt-transcription-overlay');
            if (show) {
                overlay.classList.add('active');
                document.getElementById('stt-transcript-text').textContent = 'Speak now...';
                document.getElementById('stt-transcript-text').className = 'stt-transcript-text interim';
                document.getElementById('stt-status').textContent = 'Listening...';
                document.getElementById('stt-waveform').style.display = 'flex';
                document.getElementById('stt-actions').style.display = 'none';
            } else {
                overlay.classList.remove('active');
            }
        }

        // Update transcription display
        function updateSTTTranscript(text, isFinal) {
            const textEl = document.getElementById('stt-transcript-text');
            textEl.textContent = text || 'Speak now...';
            textEl.className = 'stt-transcript-text ' + (isFinal ? 'final' : 'interim');

            if (isFinal && text) {
                sttFinalTranscript = text;
                document.getElementById('stt-status').textContent = 'Ready to send';
                document.getElementById('stt-waveform').style.display = 'none';
                document.getElementById('stt-actions').style.display = 'flex';
            }
        }

        // Send the transcribed message
        function sendSTTMessage() {
            if (sttFinalTranscript) {
                document.getElementById('copilot-chat-input').value = sttFinalTranscript;
                sendCopilotMessage();
            }
            showSTTOverlay(false);
            sttFinalTranscript = '';
        }

        // Cancel STT message
        function cancelSTTMessage() {
            showSTTOverlay(false);
            sttFinalTranscript = '';
            cleanupSTT();
        }

        // Retry STT
        function retrySTT() {
            sttFinalTranscript = '';
            showSTTOverlay(false);
            cleanupSTT();
            setTimeout(() => toggleCopilotVoice(), 200);
        }

        // Browser-based STT fallback
        function startBrowserSTT() {
            if (!copilotVoiceRecognition || copilotIsListening) return;

            try {
                copilotIsListening = true;
                document.getElementById('copilot-voice-btn').classList.add('recording');
                showSTTOverlay(true);
                copilotVoiceRecognition.start();
            } catch (e) {
                console.error('Browser STT error:', e);
                copilotIsListening = false;
                document.getElementById('copilot-voice-btn').classList.remove('recording');
                showSTTOverlay(false);
            }
        }

        // v5.9: Azure Speech-to-Text using Speech SDK with real-time transcription
        let sttInitializing = false;
        async function startAzureSTT() {
            // Prevent multiple simultaneous initializations
            if (sttInitializing || copilotIsListening) {
                console.log('STT already initializing or listening');
                return;
            }

            sttInitializing = true;
            sttFinalTranscript = '';

            try {
                // Load Speech SDK if not already loaded
                await loadSpeechSdk();

                if (!window.SpeechSDK) {
                    console.warn('Speech SDK not available, falling back to browser STT');
                    sttInitializing = false;
                    startBrowserSTT();
                    return;
                }

                // Clean up any existing recognizer first
                if (speechRecognizer) {
                    try {
                        speechRecognizer.close();
                    } catch (e) {
                        // Ignore cleanup errors
                    }
                    speechRecognizer = null;
                    // Small delay to ensure cleanup
                    await new Promise(resolve => setTimeout(resolve, 100));
                }

                // Request microphone permission first
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    // Stop the test stream immediately
                    stream.getTracks().forEach(track => track.stop());
                } catch (permError) {
                    console.error('Microphone permission denied:', permError);
                    alert('Microphone access denied. Please allow microphone access to use voice input.');
                    sttInitializing = false;
                    return;
                }

                // Show the overlay
                showSTTOverlay(true);

                // Create speech config
                const speechConfig = window.SpeechSDK.SpeechConfig.fromSubscription(
                    rappidSettings.azureTTSKey,
                    rappidSettings.azureRegion
                );
                speechConfig.speechRecognitionLanguage = 'en-US';

                // Use default microphone
                const audioConfig = window.SpeechSDK.AudioConfig.fromDefaultMicrophoneInput();

                // Create recognizer
                speechRecognizer = new window.SpeechSDK.SpeechRecognizer(speechConfig, audioConfig);

                // Set up event handlers for real-time transcription
                let interimTranscript = '';

                // Recognizing event - fires with interim results
                speechRecognizer.recognizing = (s, e) => {
                    if (e.result.reason === window.SpeechSDK.ResultReason.RecognizingSpeech) {
                        interimTranscript = e.result.text;
                        console.log('Azure STT interim:', interimTranscript);
                        updateSTTTranscript(interimTranscript, false);
                    }
                };

                // Recognized event - fires with final result
                speechRecognizer.recognized = (s, e) => {
                    if (e.result.reason === window.SpeechSDK.ResultReason.RecognizedSpeech) {
                        const finalText = e.result.text;
                        console.log('Azure STT final:', finalText);
                        if (finalText && finalText.trim()) {
                            updateSTTTranscript(finalText, true);
                            // Stop continuous recognition after getting result
                            speechRecognizer.stopContinuousRecognitionAsync();
                        }
                    } else if (e.result.reason === window.SpeechSDK.ResultReason.NoMatch) {
                        console.log('Azure STT: No speech recognized');
                        updateSTTTranscript('No speech detected. Try again.', false);
                    }
                };

                // Canceled event
                speechRecognizer.canceled = (s, e) => {
                    console.warn('Azure STT canceled:', e.reason);
                    if (e.errorDetails) {
                        console.warn('Error details:', e.errorDetails);
                    }
                    cleanupSTT();
                    showSTTOverlay(false);
                };

                // Session stopped event
                speechRecognizer.sessionStopped = (s, e) => {
                    console.log('Azure STT session stopped');
                    copilotIsListening = false;
                    document.getElementById('copilot-voice-btn').classList.remove('recording');
                };

                copilotIsListening = true;
                sttInitializing = false;
                document.getElementById('copilot-voice-btn').classList.add('recording');

                console.log('Azure STT: Starting continuous recognition...');

                // Start continuous recognition for real-time transcription
                speechRecognizer.startContinuousRecognitionAsync(
                    () => {
                        console.log('Azure STT: Continuous recognition started');
                    },
                    (error) => {
                        console.error('Azure STT start error:', error);
                        cleanupSTT();
                        showSTTOverlay(false);
                    }
                );
            } catch (error) {
                console.error('Azure STT initialization error:', error);
                sttInitializing = false;
                cleanupSTT();
                showSTTOverlay(false);

                // Fall back to browser STT
                startBrowserSTT();
            }
        }

        // Clean up STT resources
        function cleanupSTT() {
            copilotIsListening = false;
            sttInitializing = false;
            document.getElementById('copilot-voice-btn').classList.remove('recording');

            if (speechRecognizer) {
                try {
                    speechRecognizer.stopContinuousRecognitionAsync(
                        () => {
                            try { speechRecognizer.close(); } catch(e) {}
                            speechRecognizer = null;
                        },
                        () => {
                            try { speechRecognizer.close(); } catch(e) {}
                            speechRecognizer = null;
                        }
                    );
                } catch (e) {
                    try { speechRecognizer.close(); } catch(e2) {}
                    speechRecognizer = null;
                }
            }
        }

        function stopCopilotVoice() {
            // Stop Azure STT if active
            cleanupSTT();
            showSTTOverlay(false);

            // Stop browser STT if active
            if (copilotVoiceRecognition) {
                try {
                    copilotVoiceRecognition.stop();
                } catch (e) {
                    // Ignore
                }
            }
        }

        // Check for 3D copilot click
        function checkCopilotClick(event) {
            if (!copilotMesh || mode !== 'world') return false;

            const rect = renderer.domElement.getBoundingClientRect();
            const mouse = new THREE.Vector2(
                ((event.clientX - rect.left) / rect.width) * 2 - 1,
                -((event.clientY - rect.top) / rect.height) * 2 + 1
            );

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObject(copilotMesh, true);
            if (intersects.length > 0) {
                toggleCopilotChat();
                return true;
            }
            return false;
        }

        // Contextual notifications from copilot
        let lastCopilotNotification = 0;
        function triggerCopilotContextualHelp(context) {
            const now = performance.now();
            if (now - lastCopilotNotification < 30000) return; // 30 second cooldown

            let message = '';
            switch (context) {
                case 'lowHealth':
                    message = getRandomResponse(COPILOT_RESPONSES.lowHealth);
                    break;
                case 'nearEnemy':
                    if (Math.random() < 0.3) message = getRandomResponse(COPILOT_RESPONSES.nearEnemy);
                    break;
                case 'afterKill':
                    if (Math.random() < 0.2) message = getRandomResponse(COPILOT_RESPONSES.afterKill);
                    break;
            }

            if (message) {
                lastCopilotNotification = now;
                addCopilotMessage(message, 'ai');
                if (copilotChatOpen) {
                    speakCopilotResponse(message);
                }
            }
        }

        // ============================================
        // v5.7: RAPPID INTEGRATION SYSTEM
        // AI-powered responses via external endpoints
        // ============================================
        const RAPPID_STORAGE_KEY = 'leviathan-rappid-settings';
        let rappidSettings = {
            rappid: false,
            endpoints: {},
            azureTTSKey: '',
            azureRegion: '',
            ttsVoiceName: 'en-US-JennyNeural',
            version: '1.0'
        };

        function loadRappidSettings() {
            try {
                const saved = localStorage.getItem(RAPPID_STORAGE_KEY);
                if (saved) {
                    rappidSettings = JSON.parse(saved);
                    console.log('RAPPID settings loaded');
                    updateRappidUI();
                }
            } catch (e) {
                console.error('Failed to load RAPPID settings:', e);
            }
        }

        function saveRappidSettings() {
            try {
                localStorage.setItem(RAPPID_STORAGE_KEY, JSON.stringify(rappidSettings));
                console.log('RAPPID settings saved');
            } catch (e) {
                console.error('Failed to save RAPPID settings:', e);
            }
        }

        // v5.7: AI Settings Modal Functions
        function openRappidModal() {
            document.getElementById('ai-settings-modal').classList.add('active');
            updateAISettingsUI();
        }

        function closeAISettingsModal() {
            document.getElementById('ai-settings-modal').classList.remove('active');
        }

        // Alias for backwards compatibility
        function closeRappidModal() {
            closeAISettingsModal();
        }

        function switchAITab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.ai-settings-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            event.target.classList.add('active');

            // Update tab content
            document.querySelectorAll('.ai-tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById('ai-tab-' + tabName).classList.add('active');
        }

        function updateAISettingsUI() {
            // Update General tab - API fields
            const activeEndpoint = getActiveEndpoint();
            if (activeEndpoint) {
                document.getElementById('ai-api-key').value = activeEndpoint.key || '';
                document.getElementById('ai-api-endpoint').value = activeEndpoint.url || '';
            }

            // Update endpoints list in General tab
            const endpointsList = document.getElementById('ai-endpoints-list');
            if (endpointsList && rappidSettings.endpoints && Object.keys(rappidSettings.endpoints).length > 0) {
                endpointsList.innerHTML = '<label style="display:block; margin: 15px 0 10px; font-size: 12px; color: #aaa;">Available Endpoints</label>';
                Object.values(rappidSettings.endpoints).forEach(endpoint => {
                    const div = document.createElement('div');
                    div.className = `ai-endpoint-card ${endpoint.active ? 'active' : ''}`;
                    div.onclick = () => { setActiveEndpoint(endpoint.id); updateAISettingsUI(); };
                    div.innerHTML = `
                        <div class="ai-endpoint-name">${endpoint.name}</div>
                        <div class="ai-endpoint-url">${endpoint.url}</div>
                        <span class="ai-endpoint-badge ${endpoint.active ? 'active' : 'inactive'}">
                            ${endpoint.active ? 'ACTIVE' : 'INACTIVE'}
                        </span>
                    `;
                    endpointsList.appendChild(div);
                });
            } else if (endpointsList) {
                endpointsList.innerHTML = '';
            }

            // Update Voice tab - TTS settings
            if (rappidSettings.azureTTSKey) {
                document.getElementById('ai-tts-key').value = rappidSettings.azureTTSKey;
            }
            if (rappidSettings.azureRegion) {
                document.getElementById('ai-tts-region').value = rappidSettings.azureRegion;
            }
            if (rappidSettings.ttsVoiceName) {
                document.getElementById('ai-tts-voice').value = rappidSettings.ttsVoiceName;
            }

            // Update Import/Export tab - endpoints preview
            const endpointsPreview = document.getElementById('ai-endpoints-preview');
            if (endpointsPreview && rappidSettings.endpoints && Object.keys(rappidSettings.endpoints).length > 0) {
                endpointsPreview.innerHTML = '';
                Object.values(rappidSettings.endpoints).forEach(endpoint => {
                    const div = document.createElement('div');
                    div.className = `ai-endpoint-card ${endpoint.active ? 'active' : ''}`;
                    div.onclick = () => { setActiveEndpoint(endpoint.id); updateAISettingsUI(); };
                    div.innerHTML = `
                        <div class="ai-endpoint-name">${endpoint.name}</div>
                        <div class="ai-endpoint-url">${endpoint.url}</div>
                        <span class="ai-endpoint-badge ${endpoint.active ? 'active' : 'inactive'}">
                            ${endpoint.active ? 'ACTIVE' : 'INACTIVE'}
                        </span>
                    `;
                    endpointsPreview.appendChild(div);
                });
            } else if (endpointsPreview) {
                endpointsPreview.innerHTML = '<div style="padding: 15px; background: rgba(0,0,0,0.3); border-radius: 8px; text-align: center; color: #888;">No endpoints configured yet</div>';
            }

            // Update connection status
            const statusDiv = document.getElementById('ai-connection-status');
            if (statusDiv) {
                if (activeEndpoint) {
                    statusDiv.innerHTML = `
                        <div style="color: #06ffa5; margin-bottom: 5px;">Connected to: ${activeEndpoint.name}</div>
                        <div style="font-size: 11px; color: #666;">${activeEndpoint.url}</div>
                    `;
                } else {
                    statusDiv.innerHTML = '<span style="color: #888;">No endpoint configured</span>';
                }
            }
        }

        function saveAISettings() {
            // Save API settings from General tab
            const apiKey = document.getElementById('ai-api-key').value;
            const apiEndpoint = document.getElementById('ai-api-endpoint').value;

            // If user entered new endpoint details, create/update a custom endpoint
            if (apiKey && apiEndpoint) {
                const customId = 'custom-' + Date.now();
                rappidSettings.endpoints = rappidSettings.endpoints || {};

                // Check if updating existing or adding new
                const activeEndpoint = getActiveEndpoint();
                if (activeEndpoint) {
                    activeEndpoint.key = apiKey;
                    activeEndpoint.url = apiEndpoint;
                } else {
                    rappidSettings.endpoints[customId] = {
                        id: customId,
                        name: 'Custom Endpoint',
                        url: apiEndpoint,
                        key: apiKey,
                        guid: 'custom-guid',
                        active: true
                    };
                }
                rappidSettings.rappid = true;
            }

            // Save Voice settings
            rappidSettings.azureTTSKey = document.getElementById('ai-tts-key').value;
            rappidSettings.azureRegion = document.getElementById('ai-tts-region').value;
            rappidSettings.ttsVoiceName = document.getElementById('ai-tts-voice').value;

            // Save companion settings
            rappidSettings.companionName = document.getElementById('ai-companion-name').value;
            rappidSettings.companionPersonality = document.getElementById('ai-companion-personality').value;
            rappidSettings.voiceEnabled = document.getElementById('ai-voice-enabled').checked;
            rappidSettings.autoSpeak = document.getElementById('ai-auto-speak').checked;
            rappidSettings.voiceInputEnabled = document.getElementById('ai-voice-input-enabled').checked;
            rappidSettings.continuousMode = document.getElementById('ai-continuous-mode').checked;
            rappidSettings.pttKey = document.getElementById('ai-ptt-key').value;

            // Save 3D view settings
            rappidSettings.primaryColor = document.getElementById('ai-primary-color').value;
            rappidSettings.glowColor = document.getElementById('ai-glow-color').value;
            rappidSettings.companionSize = document.getElementById('ai-companion-size').value;
            rappidSettings.showParticles = document.getElementById('ai-show-particles').checked;
            rappidSettings.enableGlow = document.getElementById('ai-enable-glow').checked;
            rappidSettings.followDistance = parseFloat(document.getElementById('ai-follow-distance').value);
            rappidSettings.floatHeight = parseFloat(document.getElementById('ai-float-height').value);

            saveRappidSettings();
            showAIStatusMessage('Settings saved successfully!', 'success');
            showNotification('AI Companion settings saved!');

            // Apply 3D settings immediately if companion exists
            applyCompanionSettings();
        }

        function applyCompanionSettings() {
            // Update COPILOT_CONFIG with new settings
            if (rappidSettings.followDistance) COPILOT_CONFIG.followDistance = rappidSettings.followDistance;
            if (rappidSettings.floatHeight) COPILOT_CONFIG.floatHeight = rappidSettings.floatHeight;
            if (rappidSettings.primaryColor) COPILOT_CONFIG.color = parseInt(rappidSettings.primaryColor.replace('#', '0x'));
            if (rappidSettings.glowColor) COPILOT_CONFIG.glowColor = parseInt(rappidSettings.glowColor.replace('#', '0x'));

            // Recreate mesh with new settings
            if (copilotMesh && mode === 'world') {
                createCopilotMesh();
            }
        }

        function showAIStatusMessage(message, type) {
            const statusEl = document.getElementById('ai-status-message');
            if (statusEl) {
                statusEl.textContent = message;
                statusEl.className = 'ai-status-msg ' + type;
                setTimeout(() => {
                    statusEl.textContent = '';
                    statusEl.className = 'ai-status-msg';
                }, 3000);
            }
        }

        // Alias for backwards compatibility
        function showRappidStatus(message, type) {
            showAIStatusMessage(message, type);
        }

        // Keep old updateRappidUI for backwards compatibility
        function updateRappidUI() {
            updateAISettingsUI();
        }

        // Color picker sync
        document.addEventListener('DOMContentLoaded', function() {
            // Primary color sync
            const primaryColor = document.getElementById('ai-primary-color');
            const primaryHex = document.getElementById('ai-primary-color-hex');
            if (primaryColor && primaryHex) {
                primaryColor.addEventListener('input', () => primaryHex.value = primaryColor.value);
                primaryHex.addEventListener('input', () => primaryColor.value = primaryHex.value);
            }

            // Glow color sync
            const glowColor = document.getElementById('ai-glow-color');
            const glowHex = document.getElementById('ai-glow-color-hex');
            if (glowColor && glowHex) {
                glowColor.addEventListener('input', () => glowHex.value = glowColor.value);
                glowHex.addEventListener('input', () => glowColor.value = glowHex.value);
            }
        });

        function setActiveEndpoint(endpointId) {
            Object.values(rappidSettings.endpoints).forEach(ep => {
                ep.active = ep.id === endpointId;
            });
            saveRappidSettings();
            updateRappidUI();
            showRappidStatus('Endpoint activated: ' + rappidSettings.endpoints[endpointId]?.name, 'success');
        }

        function getActiveEndpoint() {
            return Object.values(rappidSettings.endpoints).find(ep => ep.active);
        }

        function importRappidSettings(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const imported = JSON.parse(e.target.result);

                    // Validate it's a RAPPID settings file
                    if (imported.rappid === true && imported.backupType === 'RAPPID Settings Backup') {
                        rappidSettings = {
                            rappid: true,
                            backupType: imported.backupType,
                            endpoints: imported.endpoints || {},
                            azureTTSKey: imported.azureTTSKey || '',
                            azureRegion: imported.azureRegion || '',
                            ttsVoiceName: imported.ttsVoiceName || 'en-US-JennyNeural',
                            exportDate: imported.exportDate,
                            version: imported.version || '1.0'
                        };
                        saveRappidSettings();
                        updateRappidUI();
                        showRappidStatus('RAPPID settings imported successfully!', 'success');
                        showNotification('RAPPID settings imported! Copilot is now AI-powered.');
                    } else {
                        showRappidStatus('Invalid RAPPID settings file', 'error');
                    }
                } catch (error) {
                    console.error('RAPPID import error:', error);
                    showRappidStatus('Failed to import: Invalid JSON file', 'error');
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        function exportRappidSettings() {
            if (!rappidSettings.rappid) {
                showRappidStatus('No RAPPID settings to export', 'error');
                return;
            }

            const exportData = {
                rappid: true,
                backupType: 'RAPPID Settings Backup',
                endpoints: rappidSettings.endpoints,
                azureTTSKey: rappidSettings.azureTTSKey,
                azureRegion: rappidSettings.azureRegion,
                ttsVoiceName: rappidSettings.ttsVoiceName,
                exportDate: new Date().toISOString(),
                version: rappidSettings.version
            };

            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `leviathan-rappid-backup-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);
            showRappidStatus('RAPPID settings exported!', 'success');
        }

        async function testRappidConnection() {
            const endpoint = getActiveEndpoint();
            if (!endpoint) {
                showRappidStatus('No active endpoint selected', 'error');
                return;
            }

            showRappidStatus('Testing connection...', '');

            try {
                const response = await fetch(endpoint.url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-functions-key': endpoint.key
                    },
                    body: JSON.stringify({
                        message: 'Hello, this is a connection test from LEVIATHAN game.',
                        guid: endpoint.guid
                    })
                });

                if (response.ok) {
                    const data = await response.json();
                    showRappidStatus('Connection successful! Endpoint is responding.', 'success');
                    showNotification('RAPPID connection test passed!');
                } else {
                    showRappidStatus(`Connection failed: HTTP ${response.status}`, 'error');
                }
            } catch (error) {
                console.error('RAPPID connection test error:', error);
                showRappidStatus('Connection failed: Network error', 'error');
            }
        }

        function clearRappidSettings() {
            if (confirm('Are you sure you want to clear all RAPPID settings?')) {
                rappidSettings = {
                    rappid: false,
                    endpoints: {},
                    azureTTSKey: '',
                    azureRegion: '',
                    ttsVoiceName: 'en-US-JennyNeural',
                    version: '1.0'
                };
                localStorage.removeItem(RAPPID_STORAGE_KEY);
                updateRappidUI();
                showRappidStatus('RAPPID settings cleared', 'success');
            }
        }

        function showRappidStatus(message, type) {
            const statusEl = document.getElementById('rappid-status-message');
            statusEl.textContent = message;
            statusEl.className = 'rappid-status ' + type;
        }

        // v5.9: Enhanced generateCopilotResponse with RAPPID API integration
        // Uses correct API format: user_input, conversation_history, user_guid
        // Returns object with { text, voice } - text for display, voice for TTS
        async function generateCopilotResponseWithRappid(message) {
            const endpoint = getActiveEndpoint();

            // If no active RAPPID endpoint, fall back to local responses
            if (!endpoint || !endpoint.url || !endpoint.key) {
                const localResponse = generateCopilotResponse(message);
                return { text: localResponse, voice: localResponse };
            }

            try {
                // Build context from game state
                const gameContext = {
                    playerHP: gameData.player?.hp || 100,
                    playerMaxHP: gameData.player?.maxHp || 100,
                    combatLevel: gameData.skills?.combat?.level || 1,
                    currentBiome: worldState?.currentCiv?.biomeName || 'Unknown',
                    planetName: worldState?.currentCiv?.name || 'Unknown',
                    activePet: gameData.pets?.active || null,
                    inventoryItems: Object.keys(gameData.inventory || {}).length
                };

                // Build conversation history with system context
                const systemMessage = {
                    role: 'system',
                    content: `You are a helpful AI companion in the game LEVIATHAN: OMNIVERSE. The player is exploring alien worlds. Current status: HP ${gameContext.playerHP}/${gameContext.playerMaxHP}, Combat Level ${gameContext.combatLevel}, currently on planet "${gameContext.planetName}" (${gameContext.currentBiome} biome). ${gameContext.activePet ? `They have a ${gameContext.activePet} pet companion.` : 'They have no pet.'} Keep responses brief and helpful (1-3 sentences).`
                };

                // Build conversation history for API
                const conversationForApi = [systemMessage, ...copilotConversationHistory];

                const response = await fetch(endpoint.url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-functions-key': endpoint.key
                    },
                    body: JSON.stringify({
                        user_input: message,
                        conversation_history: conversationForApi,
                        user_guid: endpoint.guid || 'leviathan-game-user'
                    })
                });

                if (response.ok) {
                    const data = await response.json();
                    // v5.9: Extract both assistant_response (for display) and voice_response (for TTS)
                    const textResponse = data.assistant_response || data.response || data.message || data.reply || generateCopilotResponse(message);
                    // Use voice_response for TTS if available, otherwise fall back to text response
                    const voiceResponse = data.voice_response || textResponse;
                    return { text: textResponse, voice: voiceResponse };
                } else {
                    console.warn('RAPPID API error (status ' + response.status + '), falling back to local response');
                    const localResponse = generateCopilotResponse(message);
                    return { text: localResponse, voice: localResponse };
                }
            } catch (error) {
                console.error('RAPPID request failed:', error);
                const localResponse = generateCopilotResponse(message);
                return { text: localResponse, voice: localResponse };
            }
        }

        // Azure TTS integration using Microsoft Speech SDK
        let speechSdkLoaded = false;
        let speechSynthesizer = null;

        function loadSpeechSdk() {
            return new Promise((resolve, reject) => {
                if (speechSdkLoaded && window.SpeechSDK) {
                    resolve();
                    return;
                }

                const script = document.createElement('script');
                script.src = 'https://aka.ms/csspeech/jsbrowserpackageraw';
                script.onload = () => {
                    speechSdkLoaded = true;
                    console.log('Microsoft Speech SDK loaded');
                    resolve();
                };
                script.onerror = () => {
                    console.error('Failed to load Speech SDK');
                    reject(new Error('Speech SDK failed to load'));
                };
                document.head.appendChild(script);
            });
        }

        async function speakWithAzureTTS(text) {
            if (!rappidSettings.azureTTSKey || !rappidSettings.azureRegion) {
                // Fall back to browser TTS
                speakCopilotResponse(text);
                return;
            }

            try {
                // Load Speech SDK if not already loaded
                await loadSpeechSdk();

                if (!window.SpeechSDK) {
                    console.warn('Speech SDK not available, falling back to browser TTS');
                    speakCopilotResponse(text);
                    return;
                }

                // Cancel any existing speech
                if (speechSynthesizer) {
                    speechSynthesizer.close();
                    speechSynthesizer = null;
                }

                // Create speech config
                const speechConfig = window.SpeechSDK.SpeechConfig.fromSubscription(
                    rappidSettings.azureTTSKey,
                    rappidSettings.azureRegion
                );
                speechConfig.speechSynthesisVoiceName = rappidSettings.ttsVoiceName || 'en-US-JennyNeural';

                // Use default speaker output
                const audioConfig = window.SpeechSDK.AudioConfig.fromDefaultSpeakerOutput();

                // Create synthesizer
                speechSynthesizer = new window.SpeechSDK.SpeechSynthesizer(speechConfig, audioConfig);

                // Truncate text if too long (SDK has limits)
                const maxLength = 5000;
                const truncatedText = text.length > maxLength ? text.substring(0, maxLength) + '...' : text;

                // Show voice indicator
                const voiceIndicator = document.getElementById('copilot-voice-indicator');
                if (voiceIndicator) voiceIndicator.classList.add('active');

                // Speak the text
                speechSynthesizer.speakTextAsync(
                    truncatedText,
                    (result) => {
                        // Hide voice indicator on completion
                        if (voiceIndicator) voiceIndicator.classList.remove('active');

                        if (result.reason === window.SpeechSDK.ResultReason.SynthesizingAudioCompleted) {
                            console.log('Azure TTS completed successfully');
                        } else {
                            console.warn('Azure TTS synthesis ended with reason:', result.reason);
                        }

                        // Clean up
                        if (speechSynthesizer) {
                            speechSynthesizer.close();
                            speechSynthesizer = null;
                        }
                    },
                    (error) => {
                        console.error('Azure TTS error:', error);
                        if (voiceIndicator) voiceIndicator.classList.remove('active');

                        // Clean up
                        if (speechSynthesizer) {
                            speechSynthesizer.close();
                            speechSynthesizer = null;
                        }

                        // Fall back to browser TTS
                        speakCopilotResponse(text);
                    }
                );
            } catch (error) {
                console.error('Azure TTS error:', error);
                speakCopilotResponse(text);
            }
        }

        // Function to stop Azure TTS
        function stopAzureTTS() {
            if (speechSynthesizer) {
                speechSynthesizer.close();
                speechSynthesizer = null;
            }
            const voiceIndicator = document.getElementById('copilot-voice-indicator');
            if (voiceIndicator) voiceIndicator.classList.remove('active');
        }

        // Override sendCopilotMessage to use RAPPID when available
        const originalSendCopilotMessage = typeof sendCopilotMessage === 'function' ? sendCopilotMessage : null;

        // ============================================
        // v5.4: COMPANION EVOLUTION SYSTEM
        // ============================================
        const PET_EVOLUTIONS = {
            slime: {
                stages: [
                    { name: 'Slime Hatchling', icon: 'ðŸŸ¢', bondRequired: 0, abilities: ['regen'], statMult: 1.0 },
                    { name: 'Gel Guardian', icon: 'ðŸ§ª', bondRequired: 50, abilities: ['regen', 'shield'], statMult: 1.5 },
                    { name: 'Slime Sovereign', icon: 'ðŸ‘‘', bondRequired: 150, abilities: ['regen', 'shield', 'absorb'], statMult: 2.5 }
                ]
            },
            wisp: {
                stages: [
                    { name: 'Tiny Wisp', icon: 'âœ¨', bondRequired: 0, abilities: ['luck'], statMult: 1.0 },
                    { name: 'Bright Spirit', icon: 'ðŸ’«', bondRequired: 60, abilities: ['luck', 'illuminate'], statMult: 1.6 },
                    { name: 'Radiant Beacon', icon: 'ðŸŒŸ', bondRequired: 180, abilities: ['luck', 'illuminate', 'fortune'], statMult: 2.8 }
                ]
            },
            bat: {
                stages: [
                    { name: 'Cave Bat', icon: 'ðŸ¦‡', bondRequired: 0, abilities: ['dodge'], statMult: 1.0 },
                    { name: 'Shadow Wing', icon: 'ðŸ–¤', bondRequired: 55, abilities: ['dodge', 'swoop'], statMult: 1.4 },
                    { name: 'Vampire Lord', icon: 'ðŸ§›', bondRequired: 165, abilities: ['dodge', 'swoop', 'lifesteal'], statMult: 2.4 }
                ]
            },
            phoenix: {
                stages: [
                    { name: 'Mini Phoenix', icon: 'ðŸ”¥', bondRequired: 0, abilities: ['damage'], statMult: 1.0 },
                    { name: 'Flame Herald', icon: 'ðŸŒ‹', bondRequired: 70, abilities: ['damage', 'burn'], statMult: 1.7 },
                    { name: 'Inferno Avatar', icon: 'â˜€ï¸', bondRequired: 200, abilities: ['damage', 'burn', 'rebirth'], statMult: 3.0 }
                ]
            },
            dragon: {
                stages: [
                    { name: 'Baby Dragon', icon: 'ðŸ²', bondRequired: 0, abilities: ['attack'], statMult: 1.0 },
                    { name: 'Drake Champion', icon: 'ðŸ‰', bondRequired: 80, abilities: ['attack', 'firebreath'], statMult: 1.8 },
                    { name: 'Elder Wyrm', icon: 'ðŸ”±', bondRequired: 250, abilities: ['attack', 'firebreath', 'devastation'], statMult: 3.5 }
                ]
            },
            void: {
                stages: [
                    { name: 'Void Entity', icon: 'ðŸŒ€', bondRequired: 0, abilities: ['absorb'], statMult: 1.0 },
                    { name: 'Void Walker', icon: 'ðŸ•³ï¸', bondRequired: 100, abilities: ['absorb', 'phase'], statMult: 2.0 },
                    { name: 'Void Sovereign', icon: 'âš«', bondRequired: 300, abilities: ['absorb', 'phase', 'annihilate'], statMult: 4.0 }
                ]
            },
            celestial: {
                stages: [
                    { name: 'Celestial Star', icon: 'â­', bondRequired: 0, abilities: ['allStats'], statMult: 1.0 },
                    { name: 'Constellation Spirit', icon: 'ðŸŒŒ', bondRequired: 120, abilities: ['allStats', 'blessing'], statMult: 2.2 },
                    { name: 'Cosmic Deity', icon: 'ðŸ’Ž', bondRequired: 400, abilities: ['allStats', 'blessing', 'transcendence'], statMult: 5.0 }
                ]
            }
        };

        const EVOLUTION_ABILITIES = {
            regen: { name: 'Regeneration', desc: '+1 HP/5s', icon: 'ðŸ’š' },
            shield: { name: 'Shield Aura', desc: '+5% damage reduction', icon: 'ðŸ›¡ï¸' },
            absorb: { name: 'Soul Absorb', desc: '+25% XP gain', icon: 'ðŸ‘»' },
            luck: { name: 'Lucky Charm', desc: '+10% loot bonus', icon: 'ðŸ€' },
            illuminate: { name: 'Illuminate', desc: 'Reveals hidden items', icon: 'ðŸ’¡' },
            fortune: { name: 'Fortune', desc: '+20% rare item chance', icon: 'ðŸ’°' },
            dodge: { name: 'Evasion', desc: '+5% dodge chance', icon: 'ðŸ’¨' },
            swoop: { name: 'Swoop Attack', desc: 'Pet deals bonus damage', icon: 'ðŸŽ¯' },
            lifesteal: { name: 'Lifesteal', desc: '+8% life on hit', icon: 'ðŸ©¸' },
            damage: { name: 'Power Boost', desc: '+15% damage', icon: 'âš”ï¸' },
            burn: { name: 'Burning Aura', desc: 'Enemies take fire damage', icon: 'ðŸ”¥' },
            rebirth: { name: 'Rebirth', desc: 'Revive once per fight', icon: 'ðŸŒ…' },
            attack: { name: 'Pet Attack', desc: 'Pet attacks enemies', icon: 'ðŸ‘Š' },
            firebreath: { name: 'Fire Breath', desc: 'AoE fire damage', icon: 'ðŸ²' },
            devastation: { name: 'Devastation', desc: '+50% boss damage', icon: 'ðŸ’€' },
            phase: { name: 'Phase Shift', desc: 'Ignore 10% damage', icon: 'ðŸŒ€' },
            annihilate: { name: 'Annihilate', desc: 'Execute low HP enemies', icon: 'âš«' },
            allStats: { name: 'All Stats', desc: '+10% all stats', icon: 'âœ¨' },
            blessing: { name: 'Blessing', desc: '+15% all bonuses', icon: 'ðŸ™' },
            transcendence: { name: 'Transcendence', desc: 'Ultimate power', icon: 'ðŸŒˆ' }
        };

        function initPetEvolutionSystem() {
            if (!gameData.petEvolution) {
                gameData.petEvolution = {};
            }
            // Initialize bond for each owned pet
            if (gameData.pets?.owned) {
                for (const petId of gameData.pets.owned) {
                    if (!gameData.petEvolution[petId]) {
                        gameData.petEvolution[petId] = {
                            bond: 0,
                            stage: 0
                        };
                    }
                }
            }
        }

        function getPetEvolutionStage(petId) {
            initPetEvolutionSystem();
            return gameData.petEvolution[petId]?.stage || 0;
        }

        function getPetBond(petId) {
            initPetEvolutionSystem();
            return gameData.petEvolution[petId]?.bond || 0;
        }

        function addPetBond(petId, amount) {
            initPetEvolutionSystem();
            if (!gameData.petEvolution[petId]) {
                gameData.petEvolution[petId] = { bond: 0, stage: 0 };
            }
            gameData.petEvolution[petId].bond += amount;
            saveGameData();
        }

        function canEvolvePet(petId) {
            const evolution = PET_EVOLUTIONS[petId];
            if (!evolution) return false;

            const currentStage = getPetEvolutionStage(petId);
            const nextStage = evolution.stages[currentStage + 1];
            if (!nextStage) return false;

            const currentBond = getPetBond(petId);
            return currentBond >= nextStage.bondRequired;
        }

        function evolvePet(petId) {
            if (!canEvolvePet(petId)) return false;

            const evolution = PET_EVOLUTIONS[petId];
            const currentStage = getPetEvolutionStage(petId);
            const nextStage = evolution.stages[currentStage + 1];

            gameData.petEvolution[petId].stage = currentStage + 1;
            saveGameData();

            // Show evolution popup
            showNotification(`${nextStage.icon} ${nextStage.name} EVOLVED!`, 'success');
            AudioSystem.levelUp();

            if (particles && worldState.player) {
                particles.emit(worldState.player.position, 60, 0xaa44ff, { spread: 8, lifetime: 2000 });
            }

            updateEvolutionDisplay();
            return true;
        }

        function getCurrentPetData(petId) {
            const basePet = PET_TYPES[petId];
            if (!basePet) return null;

            const evolution = PET_EVOLUTIONS[petId];
            if (!evolution) return basePet;

            const stage = getPetEvolutionStage(petId);
            const stageData = evolution.stages[stage];

            return {
                ...basePet,
                name: stageData.name,
                icon: stageData.icon,
                abilities: stageData.abilities,
                statMult: stageData.statMult
            };
        }

        function getEvolutionBonuses() {
            const bonuses = {
                damageReduction: 0,
                xpBonus: 0,
                lootBonus: 0,
                rareChance: 0,
                dodgeBonus: 0,
                lifesteal: 0,
                damageBonus: 0,
                burnDamage: false,
                canRevive: false,
                bossDamage: 0,
                phaseShift: 0,
                executeThreshold: 0,
                allStatsBonus: 0,
                blessingMult: 1.0
            };

            if (!gameData.pets?.active) return bonuses;

            const petData = getCurrentPetData(gameData.pets.active);
            if (!petData?.abilities) return bonuses;

            for (const ability of petData.abilities) {
                switch (ability) {
                    case 'shield': bonuses.damageReduction += 0.05; break;
                    case 'absorb': bonuses.xpBonus += 0.25; break;
                    case 'luck': bonuses.lootBonus += 0.1; break;
                    case 'fortune': bonuses.rareChance += 0.2; break;
                    case 'dodge': bonuses.dodgeBonus += 0.05; break;
                    case 'lifesteal': bonuses.lifesteal += 0.08; break;
                    case 'damage': bonuses.damageBonus += 0.15; break;
                    case 'burn': bonuses.burnDamage = true; break;
                    case 'rebirth': bonuses.canRevive = true; break;
                    case 'devastation': bonuses.bossDamage += 0.5; break;
                    case 'phase': bonuses.phaseShift += 0.1; break;
                    case 'annihilate': bonuses.executeThreshold = 0.15; break;
                    case 'allStats': bonuses.allStatsBonus += 0.1; break;
                    case 'blessing': bonuses.blessingMult = 1.15; break;
                    case 'transcendence':
                        bonuses.allStatsBonus += 0.2;
                        bonuses.blessingMult = 1.3;
                        break;
                }
            }

            // Apply blessing multiplier
            bonuses.damageBonus *= bonuses.blessingMult;
            bonuses.xpBonus *= bonuses.blessingMult;
            bonuses.lootBonus *= bonuses.blessingMult;

            return bonuses;
        }

        function openEvolutionModal() {
            initPetEvolutionSystem();
            updateEvolutionDisplay();
            document.getElementById('evolution-modal').style.display = 'flex';
            AudioSystem.click();
        }

        function closeEvolutionModal() {
            document.getElementById('evolution-modal').style.display = 'none';
        }

        function updateEvolutionDisplay() {
            const container = document.getElementById('evolution-list');
            if (!container) return;

            initPetEvolutionSystem();
            const ownedPets = gameData.pets?.owned || [];

            if (ownedPets.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: #888; padding: 20px;">No companions yet. Defeat enemies to find pets!</div>';
                return;
            }

            let html = '';
            for (const petId of ownedPets) {
                const evolution = PET_EVOLUTIONS[petId];
                if (!evolution) continue;

                const currentStage = getPetEvolutionStage(petId);
                const stageData = evolution.stages[currentStage];
                const nextStage = evolution.stages[currentStage + 1];
                const bond = getPetBond(petId);
                const canEvolve = canEvolvePet(petId);
                const isActive = gameData.pets?.active === petId;

                const bondForNext = nextStage ? nextStage.bondRequired : bond;
                const bondProgress = nextStage ? Math.min(100, (bond / bondForNext) * 100) : 100;

                html += `
                    <div class="evolution-card ${canEvolve ? 'can-evolve' : ''}" style="${isActive ? 'border-color: #ff8800;' : ''}">
                        <div class="evolution-header">
                            <div class="evolution-icon">${stageData.icon}</div>
                            <div class="evolution-info">
                                <div class="evolution-name">${stageData.name}</div>
                                <div class="evolution-stage">Stage ${currentStage + 1}/${evolution.stages.length} ${isActive ? '(ACTIVE)' : ''}</div>
                            </div>
                            <div style="text-align: right;">
                                <div style="color: #ffd700; font-size: 14px;">${bond} Bond</div>
                                <div style="color: #888; font-size: 11px;">x${stageData.statMult.toFixed(1)} Stats</div>
                            </div>
                        </div>
                        <div class="evolution-bond">
                            <div style="display: flex; justify-content: space-between; font-size: 11px; color: #888; margin-bottom: 4px;">
                                <span>Bond Progress</span>
                                <span>${bond}/${bondForNext}</span>
                            </div>
                            <div class="bond-bar">
                                <div class="bond-fill" style="width: ${bondProgress}%;"></div>
                            </div>
                        </div>
                        <div class="evolution-abilities">
                            ${stageData.abilities.map(ab => {
                                const abilityData = EVOLUTION_ABILITIES[ab];
                                return `<div class="evolution-ability" title="${abilityData?.desc || ''}">${abilityData?.icon || ''} ${abilityData?.name || ab}</div>`;
                            }).join('')}
                            ${nextStage ? nextStage.abilities.filter(ab => !stageData.abilities.includes(ab)).map(ab => {
                                const abilityData = EVOLUTION_ABILITIES[ab];
                                return `<div class="evolution-ability locked" title="Unlock at next evolution">${abilityData?.icon || ''} ???</div>`;
                            }).join('') : ''}
                        </div>
                        ${nextStage ? `
                            <button class="evolve-btn" onclick="evolvePet('${petId}')" ${canEvolve ? '' : 'disabled'}>
                                ${canEvolve ? `EVOLVE to ${nextStage.name}` : `Need ${bondForNext - bond} more bond`}
                            </button>
                        ` : '<div style="text-align: center; color: #ffd700; margin-top: 10px; font-size: 12px;">MAX EVOLUTION</div>'}
                    </div>
                `;
            }

            container.innerHTML = html;
        }

        // Gain bond from various activities
        function gainPetBond(amount) {
            if (!gameData.pets?.active) return;
            addPetBond(gameData.pets.active, amount);
        }

        // ============================================
        // v5.4: WORLD EVENTS SYSTEM
        // ============================================
        const WORLD_EVENTS = {
            meteorShower: {
                name: 'Meteor Shower',
                icon: 'â˜„ï¸',
                desc: 'Meteors rain from the sky! Collect rare ores.',
                duration: 120000, // 2 minutes
                minLevel: 3,
                spawnItems: ['Meteor Ore', 'Star Fragment', 'Cosmic Dust'],
                rewards: { xp: 500, lootBonus: 0.5 },
                color: 0xff4400
            },
            treasureHunt: {
                name: 'Treasure Hunt',
                icon: 'ðŸ—ºï¸',
                desc: 'Hidden treasure chests have appeared!',
                duration: 180000, // 3 minutes
                minLevel: 2,
                spawnItems: ['Gold Chest', 'Silver Chest', 'Ancient Relic'],
                rewards: { xp: 400, goldBonus: 2.0 },
                color: 0xffd700
            },
            invasionWave: {
                name: 'Monster Invasion',
                icon: 'ðŸ‘¹',
                desc: 'Powerful monsters are invading! Defend the area!',
                duration: 150000, // 2.5 minutes
                minLevel: 5,
                spawnMobs: true,
                mobMultiplier: 2.0,
                rewards: { xp: 800, combatXp: 300 },
                color: 0xff0044
            },
            harvestMoon: {
                name: 'Harvest Moon',
                icon: 'ðŸŒ•',
                desc: 'Resources yield double during the Harvest Moon!',
                duration: 240000, // 4 minutes
                minLevel: 1,
                resourceMultiplier: 2.0,
                rewards: { xp: 300 },
                color: 0xffcc00
            },
            ancientRuins: {
                name: 'Ancient Ruins Emerge',
                icon: 'ðŸ›ï¸',
                desc: 'Ancient ruins have surfaced! Explore for rare artifacts.',
                duration: 200000, // 3.33 minutes
                minLevel: 7,
                spawnItems: ['Ancient Artifact', 'Rune Stone', 'Lost Technology'],
                rewards: { xp: 1000, rareChance: 0.3 },
                color: 0x8844aa
            },
            crystalBloom: {
                name: 'Crystal Bloom',
                icon: 'ðŸ’Ž',
                desc: 'Rare crystals are blooming across the land!',
                duration: 160000, // 2.66 minutes
                minLevel: 4,
                spawnItems: ['Rainbow Crystal', 'Pure Crystal', 'Crystal Shard'],
                rewards: { xp: 600, craftBonus: 0.5 },
                color: 0x44ffff
            },
            bossRush: {
                name: 'Boss Rush',
                icon: 'ðŸ’€',
                desc: 'Multiple bosses have spawned! Great rewards await!',
                duration: 300000, // 5 minutes
                minLevel: 10,
                spawnBosses: true,
                rewards: { xp: 2000, rareLoot: true },
                color: 0xff00ff
            },
            peacefulDay: {
                name: 'Peaceful Day',
                icon: 'ðŸŒ¸',
                desc: 'A peaceful day with bonus XP and healing!',
                duration: 180000, // 3 minutes
                minLevel: 1,
                xpMultiplier: 1.5,
                healingBonus: 2.0,
                rewards: { xp: 200 },
                color: 0xff88aa
            }
        };

        let activeWorldEvent = null;
        let worldEventEndTime = 0;
        let worldEventProgress = { collected: 0, killed: 0, explored: 0 };
        let lastWorldEventCheck = 0;
        let worldEventSpawns = [];

        function initWorldEventSystem() {
            if (!gameData.worldEvents) {
                gameData.worldEvents = {
                    completed: {},
                    totalEventsCompleted: 0,
                    lastEventTime: 0
                };
            }
        }

        function canSpawnWorldEvent() {
            if (activeWorldEvent) return false;
            if (mode !== 'world') return false;

            const timeSinceLastEvent = performance.now() - (gameData.worldEvents?.lastEventTime || 0);
            return timeSinceLastEvent > 180000; // 3 minute cooldown between events
        }

        function trySpawnWorldEvent() {
            if (!canSpawnWorldEvent()) return false;

            // 2% chance per check (checked every ~5 seconds in game loop)
            if (Math.random() > 0.02) return false;

            const playerLevel = Math.max(...Object.values(gameData.skills).map(s => s.level));
            const eligibleEvents = Object.entries(WORLD_EVENTS).filter(([id, event]) => {
                return playerLevel >= event.minLevel;
            });

            if (eligibleEvents.length === 0) return false;

            const [eventId, eventData] = eligibleEvents[Math.floor(Math.random() * eligibleEvents.length)];
            startWorldEvent(eventId);
            return true;
        }

        function startWorldEvent(eventId) {
            const eventData = WORLD_EVENTS[eventId];
            if (!eventData) return;

            activeWorldEvent = { id: eventId, ...eventData };
            worldEventEndTime = performance.now() + eventData.duration;
            worldEventProgress = { collected: 0, killed: 0, explored: 0 };
            worldEventSpawns = [];

            // Show event notification
            showWorldEventNotification(eventData);

            // Spawn event-specific content
            if (eventData.spawnItems) {
                spawnEventItems(eventData);
            }
            if (eventData.spawnMobs) {
                spawnEventMobs(eventData);
            }
            if (eventData.spawnBosses) {
                spawnEventBosses();
            }

            // Update UI
            updateEventIndicator();

            gameData.worldEvents.lastEventTime = performance.now();
            saveGameData();
        }

        function showWorldEventNotification(eventData) {
            const notification = document.createElement('div');
            notification.className = 'event-notification';
            notification.innerHTML = `
                <div class="event-title">${eventData.icon} ${eventData.name}!</div>
                <div class="event-desc">${eventData.desc}</div>
                <div class="event-timer">Duration: ${Math.floor(eventData.duration / 1000)}s</div>
            `;
            document.body.appendChild(notification);

            AudioSystem.levelUp();
            if (particles && worldState.player) {
                particles.emit(worldState.player.position, 40, eventData.color, { spread: 10, lifetime: 2000 });
            }

            setTimeout(() => notification.remove(), 5000);
        }

        function spawnEventItems(eventData) {
            if (!worldState.player) return;

            const itemCount = 5 + Math.floor(Math.random() * 5);
            for (let i = 0; i < itemCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = 20 + Math.random() * 40;
                const x = worldState.player.position.x + Math.cos(angle) * dist;
                const z = worldState.player.position.z + Math.sin(angle) * dist;

                const itemType = eventData.spawnItems[Math.floor(Math.random() * eventData.spawnItems.length)];

                // Create visual marker
                const geometry = new THREE.SphereGeometry(0.5, 8, 8);
                const material = new THREE.MeshStandardMaterial({
                    color: eventData.color,
                    emissive: eventData.color,
                    emissiveIntensity: 0.5
                });
                const marker = new THREE.Mesh(geometry, material);
                marker.position.set(x, 1, z);
                marker.userData = { type: 'eventItem', itemType, eventId: activeWorldEvent.id, hp: 1, maxHp: 1 };
                scene.add(marker);
                worldEventSpawns.push(marker);
                // Add to interactables so player can target them
                worldState.interactables.push(marker);
            }
        }

        function spawnEventMobs(eventData) {
            // Spawn extra mobs during invasion
            const extraMobs = Math.floor(10 * (eventData.mobMultiplier || 1));
            for (let i = 0; i < extraMobs; i++) {
                if (typeof spawnMob === 'function') {
                    spawnMob(true); // Force spawn stronger mobs
                }
            }
        }

        function spawnEventBosses() {
            // Spawn multiple bosses during boss rush
            for (let i = 0; i < 3; i++) {
                if (typeof spawnBoss === 'function') {
                    setTimeout(() => spawnBoss(), i * 30000);
                }
            }
        }

        function updateWorldEvent(dt, time) {
            if (!activeWorldEvent) {
                // Check for new event every 5 seconds
                if (time - lastWorldEventCheck > 5000) {
                    lastWorldEventCheck = time;
                    trySpawnWorldEvent();
                }
                return;
            }

            // Check if event ended
            if (performance.now() >= worldEventEndTime) {
                endWorldEvent();
                return;
            }

            // Update event indicator
            updateEventIndicator();

            // Apply event bonuses
            applyEventBonuses();

            // Animate event spawns
            worldEventSpawns.forEach(spawn => {
                if (spawn && spawn.position) {
                    spawn.position.y = 1 + Math.sin(time * 0.003) * 0.3;
                    spawn.rotation.y += dt * 2;
                }
            });
        }

        function applyEventBonuses() {
            // Bonuses are applied in relevant game functions
            // This function tracks active bonuses
        }

        function getWorldEventBonuses() {
            if (!activeWorldEvent) return {};

            return {
                resourceMultiplier: activeWorldEvent.resourceMultiplier || 1,
                xpMultiplier: activeWorldEvent.xpMultiplier || 1,
                lootBonus: activeWorldEvent.rewards?.lootBonus || 0,
                healingBonus: activeWorldEvent.healingBonus || 1
            };
        }

        function collectEventItem(marker) {
            if (!marker.userData.itemType) return;

            const itemType = marker.userData.itemType;
            worldEventProgress.collected++;

            // Add item to inventory
            addItem(itemType);
            showNotification(`Collected: ${itemType}`, 'success');
            AudioSystem.collect();

            if (particles) {
                particles.emit(marker.position, 15, activeWorldEvent?.color || 0xffd700);
            }

            // Remove marker
            scene.remove(marker);
            worldEventSpawns = worldEventSpawns.filter(s => s !== marker);
            worldState.interactables = worldState.interactables.filter(i => i !== marker);

            // Gain pet bond
            gainPetBond(2);
        }

        function endWorldEvent() {
            if (!activeWorldEvent) return;

            initWorldEventSystem();

            // Apply completion rewards
            const rewards = activeWorldEvent.rewards;
            if (rewards.xp) {
                addXp('combat', rewards.xp);
            }
            if (rewards.combatXp) {
                addXp('combat', rewards.combatXp);
            }

            // Track completion
            if (!gameData.worldEvents.completed[activeWorldEvent.id]) {
                gameData.worldEvents.completed[activeWorldEvent.id] = 0;
            }
            gameData.worldEvents.completed[activeWorldEvent.id]++;
            gameData.worldEvents.totalEventsCompleted++;

            showNotification(`${activeWorldEvent.icon} Event Complete! +${rewards.xp || 0} XP`, 'success');

            // Clean up event spawns
            worldEventSpawns.forEach(spawn => {
                if (spawn && spawn.parent) scene.remove(spawn);
                // Remove from interactables
                worldState.interactables = worldState.interactables.filter(i => i !== spawn);
            });
            worldEventSpawns = [];

            // Gain pet bond for completion
            gainPetBond(10);

            activeWorldEvent = null;
            updateEventIndicator();
            saveGameData();
        }

        function updateEventIndicator() {
            const indicator = document.getElementById('event-indicator');
            if (!indicator) return;

            if (!activeWorldEvent) {
                indicator.classList.remove('active');
                return;
            }

            indicator.classList.add('active');

            const timeLeft = Math.max(0, worldEventEndTime - performance.now());
            const minutes = Math.floor(timeLeft / 60000);
            const seconds = Math.floor((timeLeft % 60000) / 1000);
            const progress = (timeLeft / activeWorldEvent.duration) * 100;

            document.getElementById('event-ind-icon').textContent = activeWorldEvent.icon;
            document.getElementById('event-ind-name').textContent = activeWorldEvent.name;
            document.getElementById('event-ind-time').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            document.getElementById('event-ind-fill').style.width = `${progress}%`;
        }

        // ============================================
        // v5.4: ACHIEVEMENT SHOWCASE SYSTEM
        // ============================================
        const ACHIEVEMENT_POINTS = {
            // Basic achievements
            'first_landing': { points: 10, tier: 'common' },
            'explorer_10': { points: 25, tier: 'common' },
            'explorer_30': { points: 50, tier: 'rare' },
            'lumberjack_25': { points: 15, tier: 'common' },
            'lumberjack_100': { points: 40, tier: 'rare' },
            'miner_25': { points: 15, tier: 'common' },
            'miner_100': { points: 40, tier: 'rare' },
            'angler_10': { points: 15, tier: 'common' },
            'angler_50': { points: 35, tier: 'rare' },
            'slayer_10': { points: 20, tier: 'common' },
            'slayer_50': { points: 50, tier: 'rare' },
            'crafter_10': { points: 15, tier: 'common' },
            'crafter_50': { points: 45, tier: 'rare' },
            'max_skill': { points: 75, tier: 'legendary' },
            'playtime_1h': { points: 30, tier: 'common' },
            'survivor': { points: 35, tier: 'rare' },
            'daily_3': { points: 25, tier: 'common' },
            'daily_7': { points: 60, tier: 'rare' }
        };

        const AP_MILESTONES = [
            { points: 50, name: 'Novice Achiever', reward: { type: 'cosmetic', id: 'sparkle' } },
            { points: 100, name: 'Rising Star', reward: { type: 'xpBonus', value: 0.05 } },
            { points: 200, name: 'Accomplished', reward: { type: 'cosmetic', id: 'aura_blue' } },
            { points: 350, name: 'Elite Achiever', reward: { type: 'lootBonus', value: 0.1 } },
            { points: 500, name: 'Master Achiever', reward: { type: 'cosmetic', id: 'aura_gold' } },
            { points: 750, name: 'Legendary Status', reward: { type: 'allBonus', value: 0.1 } },
            { points: 1000, name: 'Achievement God', reward: { type: 'cosmetic', id: 'aura_rainbow' } }
        ];

        const COSMETIC_EFFECTS = {
            sparkle: { name: 'Sparkle Trail', desc: 'Leave sparkles as you move', icon: 'âœ¨' },
            aura_blue: { name: 'Blue Aura', desc: 'Mystical blue glow around player', icon: 'ðŸ’™' },
            aura_gold: { name: 'Golden Aura', desc: 'Prestigious golden glow', icon: 'ðŸ’›' },
            aura_rainbow: { name: 'Rainbow Aura', desc: 'Ultimate rainbow effect', icon: 'ðŸŒˆ' }
        };

        function initAchievementShowcase() {
            if (!gameData.achievementShowcase) {
                gameData.achievementShowcase = {
                    activeCosmetic: null,
                    unlockedCosmetics: [],
                    bonuses: {
                        xpBonus: 0,
                        lootBonus: 0,
                        allBonus: 0
                    }
                };
            }
        }

        function calculateTotalAP() {
            let total = 0;
            for (const [achId, achPoints] of Object.entries(ACHIEVEMENT_POINTS)) {
                if (gameData.achievements[achId]) {
                    total += achPoints.points;
                }
            }
            return total;
        }

        function getCurrentMilestone() {
            const totalAP = calculateTotalAP();
            let current = null;
            let next = AP_MILESTONES[0];

            for (let i = 0; i < AP_MILESTONES.length; i++) {
                if (totalAP >= AP_MILESTONES[i].points) {
                    current = AP_MILESTONES[i];
                    next = AP_MILESTONES[i + 1] || null;
                } else {
                    break;
                }
            }

            return { current, next };
        }

        function checkMilestoneRewards() {
            initAchievementShowcase();
            const totalAP = calculateTotalAP();

            for (const milestone of AP_MILESTONES) {
                if (totalAP >= milestone.points) {
                    const reward = milestone.reward;

                    if (reward.type === 'cosmetic') {
                        if (!gameData.achievementShowcase.unlockedCosmetics.includes(reward.id)) {
                            gameData.achievementShowcase.unlockedCosmetics.push(reward.id);
                            showNotification(`Cosmetic Unlocked: ${COSMETIC_EFFECTS[reward.id]?.name}!`, 'success');
                        }
                    } else if (reward.type === 'xpBonus') {
                        gameData.achievementShowcase.bonuses.xpBonus = Math.max(
                            gameData.achievementShowcase.bonuses.xpBonus,
                            reward.value
                        );
                    } else if (reward.type === 'lootBonus') {
                        gameData.achievementShowcase.bonuses.lootBonus = Math.max(
                            gameData.achievementShowcase.bonuses.lootBonus,
                            reward.value
                        );
                    } else if (reward.type === 'allBonus') {
                        gameData.achievementShowcase.bonuses.allBonus = Math.max(
                            gameData.achievementShowcase.bonuses.allBonus,
                            reward.value
                        );
                    }
                }
            }

            saveGameData();
        }

        function getShowcaseBonuses() {
            initAchievementShowcase();
            return {
                xpBonus: gameData.achievementShowcase.bonuses?.xpBonus || 0,
                lootBonus: gameData.achievementShowcase.bonuses?.lootBonus || 0,
                allBonus: gameData.achievementShowcase.bonuses?.allBonus || 0
            };
        }

        function setActiveCosmetic(cosmeticId) {
            initAchievementShowcase();
            if (cosmeticId && !gameData.achievementShowcase.unlockedCosmetics.includes(cosmeticId)) {
                return false;
            }

            gameData.achievementShowcase.activeCosmetic = cosmeticId;
            saveGameData();
            updateShowcaseDisplay();

            if (cosmeticId) {
                const cosmetic = COSMETIC_EFFECTS[cosmeticId];
                showNotification(`Cosmetic equipped: ${cosmetic?.name}`, 'info');
            } else {
                showNotification('Cosmetic removed', 'info');
            }

            return true;
        }

        function openShowcaseModal() {
            initAchievementShowcase();
            checkMilestoneRewards();
            updateShowcaseDisplay();
            document.getElementById('showcase-modal').style.display = 'flex';
            AudioSystem.click();
        }

        function closeShowcaseModal() {
            document.getElementById('showcase-modal').style.display = 'none';
        }

        function updateShowcaseDisplay() {
            const totalAP = calculateTotalAP();
            const milestones = getCurrentMilestone();

            document.getElementById('total-ap').textContent = totalAP;

            if (milestones.next) {
                document.getElementById('next-milestone-name').textContent =
                    `${milestones.next.name} (${milestones.next.points} AP)`;
                const progress = ((totalAP - (milestones.current?.points || 0)) /
                    (milestones.next.points - (milestones.current?.points || 0))) * 100;
                document.getElementById('milestone-progress').style.width = `${Math.min(100, progress)}%`;
            } else {
                document.getElementById('next-milestone-name').textContent = 'All milestones complete!';
                document.getElementById('milestone-progress').style.width = '100%';
            }

            // Active cosmetic
            const activeCosmetic = gameData.achievementShowcase?.activeCosmetic;
            document.getElementById('active-cosmetic').textContent =
                activeCosmetic ? COSMETIC_EFFECTS[activeCosmetic]?.name : 'None';

            // Render badges
            const container = document.getElementById('showcase-badges');
            let html = '';

            // Cosmetics section
            html += '<div style="grid-column: 1 / -1; font-weight: bold; color: #aa44ff; margin: 10px 0;">Cosmetics</div>';
            for (const [cosId, cosmetic] of Object.entries(COSMETIC_EFFECTS)) {
                const unlocked = gameData.achievementShowcase?.unlockedCosmetics?.includes(cosId);
                const isActive = activeCosmetic === cosId;
                html += `
                    <div class="showcase-badge ${unlocked ? 'earned' : ''} ${isActive ? 'legendary' : ''}"
                         onclick="${unlocked ? `setActiveCosmetic('${isActive ? '' : cosId}')` : ''}"
                         title="${unlocked ? cosmetic.desc : 'Locked - earn more AP!'}">
                        <div class="showcase-badge-icon">${cosmetic.icon}</div>
                        <div class="showcase-badge-name">${unlocked ? cosmetic.name : '???'}</div>
                    </div>
                `;
            }

            // Achievements section
            html += '<div style="grid-column: 1 / -1; font-weight: bold; color: #ffd700; margin: 10px 0;">Achievements</div>';
            for (const [achId, achData] of Object.entries(ACHIEVEMENT_POINTS)) {
                const achievement = ACHIEVEMENTS[achId];
                if (!achievement) continue;

                const unlocked = gameData.achievements[achId];
                const tierClass = achData.tier === 'legendary' ? 'legendary' :
                                 achData.tier === 'rare' ? 'rare' : '';

                html += `
                    <div class="showcase-badge ${unlocked ? 'earned' : ''} ${unlocked && tierClass}"
                         title="${achievement.desc} (${achData.points} AP)">
                        <div class="showcase-badge-icon">${achievement.icon}</div>
                        <div class="showcase-badge-name">${unlocked ? achievement.name : '???'}</div>
                        ${unlocked ? `<div style="font-size: 9px; color: #ffd700;">+${achData.points} AP</div>` : ''}
                    </div>
                `;
            }

            container.innerHTML = html;
        }

        // Apply cosmetic effect visuals
        let lastCosmeticUpdate = 0;
        function updateCosmeticEffects(time) {
            if (!worldState.player) return;

            const activeCosmetic = gameData.achievementShowcase?.activeCosmetic;
            if (!activeCosmetic) return;

            if (time - lastCosmeticUpdate < 100) return;
            lastCosmeticUpdate = time;

            if (activeCosmetic === 'sparkle' && particles) {
                particles.emit(worldState.player.position, 2, 0xffffff, { spread: 1, lifetime: 500 });
            } else if (activeCosmetic.startsWith('aura_') && particles) {
                const colors = {
                    aura_blue: 0x4488ff,
                    aura_gold: 0xffd700,
                    aura_rainbow: Math.random() > 0.5 ? 0xff4488 : (Math.random() > 0.5 ? 0x44ff88 : 0x4488ff)
                };
                particles.emit(worldState.player.position, 1, colors[activeCosmetic] || 0xffffff, { spread: 2, lifetime: 800 });
            }
        }

        // v5.0: Dynamic Weather System
        const WEATHER_TYPES = {
            clear: {
                name: 'Clear',
                icon: 'â˜€ï¸',
                fogDensity: 1.0,
                lightIntensity: 1.0,
                moveSpeedMod: 1.0,
                particleType: null
            },
            rain: {
                name: 'Rain',
                icon: 'ðŸŒ§ï¸',
                fogDensity: 0.7,
                lightIntensity: 0.6,
                moveSpeedMod: 0.9,
                particleType: 'rain',
                particleColor: 0x6688aa
            },
            storm: {
                name: 'Storm',
                icon: 'â›ˆï¸',
                fogDensity: 0.5,
                lightIntensity: 0.4,
                moveSpeedMod: 0.8,
                particleType: 'rain',
                particleColor: 0x445566,
                lightning: true
            },
            fog: {
                name: 'Fog',
                icon: 'ðŸŒ«ï¸',
                fogDensity: 0.3,
                lightIntensity: 0.7,
                moveSpeedMod: 0.95,
                particleType: null
            },
            snow: {
                name: 'Snow',
                icon: 'â„ï¸',
                fogDensity: 0.6,
                lightIntensity: 0.8,
                moveSpeedMod: 0.85,
                particleType: 'snow',
                particleColor: 0xffffff
            },
            sandstorm: {
                name: 'Sandstorm',
                icon: 'ðŸœï¸',
                fogDensity: 0.4,
                lightIntensity: 0.5,
                moveSpeedMod: 0.75,
                particleType: 'sand',
                particleColor: 0xddbb88
            }
        };

        const BIOME_WEATHER = {
            Terra: ['clear', 'rain', 'fog'],
            Forest: ['clear', 'rain', 'fog'],
            Desert: ['clear', 'sandstorm'],
            Ice: ['clear', 'snow', 'storm'],
            Volcanic: ['clear', 'fog'],
            Ocean: ['clear', 'rain', 'storm'],
            Alien: ['clear', 'fog', 'storm'],
            Crystal: ['clear', 'fog']
        };

        let currentWeather = 'clear';
        let weatherTransition = 0;
        let weatherParticles = [];
        let lastLightningTime = 0;
        let weatherChangeTime = 0;

        function initWeatherSystem() {
            currentWeather = 'clear';
            weatherParticles = [];
            weatherChangeTime = performance.now() + 60000 + Math.random() * 120000; // 1-3 min initial
        }

        function updateWeather(dt, time) {
            if (!activeCiv || mode !== 'world') return;

            // Check for weather change
            if (time > weatherChangeTime) {
                changeWeather();
                weatherChangeTime = time + 60000 + Math.random() * 180000; // 1-4 min between changes
            }

            const weather = WEATHER_TYPES[currentWeather];
            if (!weather) return;

            // Update fog based on weather
            if (scene.fog) {
                const targetNear = 20 * weather.fogDensity;
                const targetFar = 120 * weather.fogDensity;
                scene.fog.near += (targetNear - scene.fog.near) * dt * 0.5;
                scene.fog.far += (targetFar - scene.fog.far) * dt * 0.5;
            }

            // Update light intensity
            if (worldState.sun) {
                const baseIntensity = Math.max(0.1, Math.sin(worldState.timeOfDay * Math.PI * 2)) * 1.2;
                worldState.sun.intensity = baseIntensity * weather.lightIntensity;
            }

            // Spawn weather particles
            if (weather.particleType && worldState.player) {
                spawnWeatherParticles(weather, dt);
            }

            // Update weather particles
            updateWeatherParticles(dt);

            // Lightning effect
            if (weather.lightning && time - lastLightningTime > 3000 + Math.random() * 7000) {
                if (Math.random() < 0.3) {
                    triggerLightning();
                    lastLightningTime = time;
                }
            }
        }

        function changeWeather() {
            if (!activeCiv) return;

            const biomeWeathers = BIOME_WEATHER[activeCiv.biome] || ['clear'];
            const newWeather = biomeWeathers[Math.floor(Math.random() * biomeWeathers.length)];

            if (newWeather !== currentWeather) {
                currentWeather = newWeather;
                const weather = WEATHER_TYPES[newWeather];
                showNotification(`Weather: ${weather.icon} ${weather.name}`, 'info');
                updateWeatherUI();
            }
        }

        function updateWeatherUI() {
            const weather = WEATHER_TYPES[currentWeather];
            if (!weather) return;

            const iconEl = document.getElementById('weather-icon');
            const nameEl = document.getElementById('weather-name');
            const effectEl = document.getElementById('weather-effect');

            if (iconEl) iconEl.textContent = weather.icon;
            if (nameEl) nameEl.textContent = weather.name;

            // Show speed effect if not 100%
            if (effectEl) {
                const speedPct = Math.round(weather.moveSpeedMod * 100);
                effectEl.textContent = speedPct < 100 ? `Speed: ${speedPct}%` : '';
            }
        }

        function spawnWeatherParticles(weather, dt) {
            const spawnRate = weather.particleType === 'rain' ? 50 : 20;
            const spawnCount = Math.floor(spawnRate * dt);

            for (let i = 0; i < spawnCount; i++) {
                const x = worldState.player.position.x + (Math.random() - 0.5) * 40;
                const z = worldState.player.position.z + (Math.random() - 0.5) * 40;
                const y = worldState.player.position.y + 20 + Math.random() * 10;

                weatherParticles.push({
                    x, y, z,
                    vx: (Math.random() - 0.5) * (weather.particleType === 'sand' ? 5 : 0.5),
                    vy: weather.particleType === 'snow' ? -3 - Math.random() * 2 : -15 - Math.random() * 10,
                    vz: (Math.random() - 0.5) * (weather.particleType === 'sand' ? 5 : 0.5),
                    life: 3,
                    color: weather.particleColor,
                    type: weather.particleType
                });
            }

            // Limit particle count
            if (weatherParticles.length > 500) {
                weatherParticles = weatherParticles.slice(-400);
            }
        }

        function updateWeatherParticles(dt) {
            weatherParticles = weatherParticles.filter(p => {
                p.x += p.vx * dt;
                p.y += p.vy * dt;
                p.z += p.vz * dt;
                p.life -= dt;

                // Draw particle (simple point)
                if (p.life > 0 && particles && worldState.player) {
                    const dist = Math.sqrt(
                        Math.pow(p.x - worldState.player.position.x, 2) +
                        Math.pow(p.z - worldState.player.position.z, 2)
                    );
                    if (dist < 30 && Math.random() < 0.1) {
                        particles.emit(
                            { x: p.x, y: p.y, z: p.z },
                            1,
                            p.color,
                            { spread: 0.1, lifetime: 100, size: p.type === 'snow' ? 0.15 : 0.05 }
                        );
                    }
                }

                return p.life > 0 && p.y > -10;
            });
        }

        function triggerLightning() {
            // Flash screen white briefly
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                background: white; opacity: 0.8; pointer-events: none; z-index: 100;
            `;
            document.body.appendChild(overlay);

            setTimeout(() => {
                overlay.style.opacity = '0.3';
                setTimeout(() => {
                    overlay.remove();
                }, 100);
            }, 50);

            // Thunder sound
            if (AudioSystem.enabled && AudioSystem.ctx) {
                const osc = AudioSystem.ctx.createOscillator();
                const gain = AudioSystem.ctx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(80, AudioSystem.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(20, AudioSystem.ctx.currentTime + 0.5);
                gain.gain.setValueAtTime(0.3, AudioSystem.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, AudioSystem.ctx.currentTime + 0.8);
                osc.connect(gain);
                gain.connect(AudioSystem.ctx.destination);
                osc.start();
                osc.stop(AudioSystem.ctx.currentTime + 0.8);
            }

            screenShake(0.8);
        }

        function getWeatherSpeedMod() {
            const weather = WEATHER_TYPES[currentWeather];
            return weather ? weather.moveSpeedMod : 1.0;
        }

        function updateStatsDisplay() {
            const s = gameData.statistics;

            document.getElementById('stat-planets').textContent = `${gameData.visitedPlanets.length} / ${CONFIG.NUM_CIVS}`;

            const total = Math.floor(gameData.playtime);
            const hours = Math.floor(total / 3600);
            const mins = Math.floor((total % 3600) / 60);
            document.getElementById('stat-playtime').textContent = `${hours}h ${mins}m`;

            document.getElementById('stat-trees').textContent = s.treesChopped || 0;
            document.getElementById('stat-ore').textContent = s.oresMined || 0;
            document.getElementById('stat-fish').textContent = s.fishCaught || 0;
            document.getElementById('stat-mobs').textContent = s.mobsKilled || 0;
            document.getElementById('stat-crafted').textContent = s.itemsCrafted || 0;

            // v4.2: Display POIs discovered and player rank
            const poisEl = document.getElementById('stat-pois');
            if (poisEl) poisEl.textContent = s.poisDiscovered || 0;

            const rankEl = document.getElementById('stat-rank');
            if (rankEl) {
                const rank = getPlayerRank();
                rankEl.textContent = rank.title;
                rankEl.style.color = rank.color;
            }

            const pointsEl = document.getElementById('stat-points');
            if (pointsEl) pointsEl.textContent = calculatePlayerPoints();

            // v4.2: Display special titles
            const titlesEl = document.getElementById('special-titles');
            if (titlesEl) {
                const titles = getSpecialTitles();
                if (titles.length > 0) {
                    titlesEl.innerHTML = titles.map(t =>
                        `<span style="color:${t.color}">${t.name}</span>`
                    ).join(' | ');
                } else {
                    titlesEl.innerHTML = '<span style="color:#666">None yet</span>';
                }
            }

            // Render achievements
            const achList = document.getElementById('achievements-list');
            if (achList) {
                achList.innerHTML = '';
                for (const [id, ach] of Object.entries(ACHIEVEMENTS)) {
                    const unlocked = gameData.achievements[id];
                    const div = document.createElement('div');
                    div.className = `ach-item ${unlocked ? 'unlocked' : 'locked'}`;
                    div.innerHTML = `<span class="ach-badge">${ach.icon}</span><span>${ach.name}</span>`;
                    div.title = ach.desc;
                    achList.appendChild(div);
                }
            }

            // v4.4: Render leaderboard
            const lbList = document.getElementById('leaderboard-list');
            if (lbList) {
                const lb = getLeaderboardPosition();
                lbList.innerHTML = lb.nearby.map((p, i) => {
                    const isYou = p.name === 'YOU';
                    const bgColor = isYou ? 'rgba(255,215,0,0.2)' : 'transparent';
                    const textColor = isYou ? '#ffd700' : '#aaa';
                    const rank = lb.position - (lb.nearby.indexOf(lb.nearby.find(x => x.name === 'YOU'))) + i;
                    return `<div style="display: flex; justify-content: space-between; padding: 4px 8px; margin: 2px 0; background: ${bgColor}; border-radius: 4px;">
                        <span style="color: ${textColor};">#${rank} ${p.name}</span>
                        <span style="color: #888;">${p.points.toLocaleString()} pts</span>
                    </div>`;
                }).join('');
            }

            // v4.4: Render prestige info
            const prestigeLevel = gameData.prestige?.level || 0;
            const xpMult = gameData.prestige?.bonuses?.xpMultiplier || 1.0;
            const lifetimePoints = gameData.prestige?.totalLifetimePoints || 0;

            document.getElementById('prestige-level').textContent = prestigeLevel;
            document.getElementById('prestige-xp').textContent = `x${xpMult.toFixed(1)}`;
            document.getElementById('prestige-lifetime').textContent = lifetimePoints.toLocaleString();

            const progressEl = document.getElementById('prestige-progress');
            const prestigeBtn = document.getElementById('prestige-btn');
            const nextLevel = PRESTIGE_LEVELS[prestigeLevel + 1];

            if (nextLevel) {
                const currentPts = calculatePlayerPoints();
                const progress = Math.min(100, (currentPts / nextLevel.required) * 100);
                progressEl.innerHTML = `Next prestige: ${currentPts.toLocaleString()} / ${nextLevel.required.toLocaleString()} pts (${progress.toFixed(1)}%)`;

                if (canPrestige()) {
                    prestigeBtn.style.display = 'block';
                } else {
                    prestigeBtn.style.display = 'none';
                }
            } else {
                progressEl.innerHTML = `<span style="color: #aa44ff;">MAX PRESTIGE REACHED!</span>`;
                prestigeBtn.style.display = 'none';
            }
        }

        // --- DATA PERSISTENCE ---
        function loadGameData() {
            try {
                const saved = localStorage.getItem(APP_NAME);
                if (saved) {
                    const parsed = JSON.parse(saved);
                    // Merge with defaults to handle version updates
                    gameData = { ...gameData, ...parsed };
                    // Ensure nested objects exist
                    gameData.skills = { ...gameData.skills, ...parsed.skills };
                    gameData.player = { ...gameData.player, ...parsed.player };
                    gameData.statistics = { ...gameData.statistics, ...parsed.statistics };
                    console.log('Game data loaded successfully');
                }
            } catch (e) {
                console.error('Failed to load game data:', e);
            }
        }

        function saveGameData() {
            try {
                gameData.lastPlayed = new Date().toISOString();
                localStorage.setItem(APP_NAME, JSON.stringify(gameData));
                console.log('Game saved');
            } catch (e) {
                console.error('Failed to save game data:', e);
            }
        }

        function exportData() {
            const dataStr = JSON.stringify(gameData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `${APP_NAME}-save-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);
            showNotification('Game exported successfully!');
        }

        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const imported = JSON.parse(e.target.result);
                    if (imported.version) {
                        gameData = { ...gameData, ...imported };
                        saveGameData();
                        showNotification('Save imported! Refreshing...');
                        setTimeout(() => location.reload(), 1500);
                    } else {
                        alert('Invalid save file format');
                    }
                } catch (error) {
                    alert('Failed to import: Invalid JSON file');
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        // v4.6: Quick save function
        function quickSave() {
            saveGameData();
            document.getElementById('last-save-time').textContent = new Date().toLocaleString();
            showNotification('Game saved!');
        }

        // v4.7: Session Rewards System
        let pendingSessionReward = null;

        function checkSessionRewards() {
            if (!gameData.lastPlayed) return null;

            const lastPlayed = new Date(gameData.lastPlayed);
            const now = new Date();
            const hoursAway = Math.min(
                (now - lastPlayed) / (1000 * 60 * 60),
                SESSION_REWARDS.maxOfflineHours
            );

            // Find the best applicable tier
            let bestTier = null;
            for (const tier of SESSION_REWARDS.tiers) {
                if (hoursAway >= tier.minHours) {
                    bestTier = tier;
                }
            }

            if (bestTier) {
                return {
                    tier: bestTier,
                    hoursAway: Math.floor(hoursAway),
                    minutesAway: Math.floor((hoursAway % 1) * 60)
                };
            }
            return null;
        }

        function showWelcomeBackModal(reward) {
            pendingSessionReward = reward;

            document.getElementById('welcome-back-message').textContent = reward.tier.message;

            const timeText = reward.hoursAway > 0
                ? `You were away for ${reward.hoursAway}h ${reward.minutesAway}m`
                : `You were away for ${reward.minutesAway}m`;
            document.getElementById('welcome-back-time').textContent = timeText;

            // Build rewards list
            const rewardsList = document.getElementById('welcome-back-rewards-list');
            let html = '';
            html += `<div style="color: #ffd700; margin-bottom: 8px;">+${reward.tier.xpBonus} XP (all skills)</div>`;
            for (const [item, count] of Object.entries(reward.tier.resources)) {
                const icon = ITEMS[item]?.icon || 'ðŸ“¦';
                html += `<div style="color: #aaf; margin-bottom: 4px;">${icon} ${count}x ${item}</div>`;
            }
            rewardsList.innerHTML = html;

            document.getElementById('welcome-back-modal').style.display = 'flex';
            AudioSystem.levelUp();
        }

        function claimWelcomeBackRewards() {
            if (!pendingSessionReward) return;

            const reward = pendingSessionReward;

            // Grant XP to all skills
            Object.keys(gameData.skills).forEach(skill => {
                addXp(skill, Math.floor(reward.tier.xpBonus / Object.keys(gameData.skills).length));
            });

            // Grant resources
            for (const [item, count] of Object.entries(reward.tier.resources)) {
                for (let i = 0; i < count; i++) {
                    addItem(item);
                }
            }

            // Track the claim
            gameData.statistics.sessionRewardsClaimed = (gameData.statistics.sessionRewardsClaimed || 0) + 1;

            document.getElementById('welcome-back-modal').style.display = 'none';
            showNotification('Rewards claimed! Welcome back!', 'success');
            AudioSystem.collect();

            pendingSessionReward = null;
            saveGameData();
        }

        // v5.7: Secondary menu toggle
        function toggleSecondaryMenu() {
            const menu = document.getElementById('menu-secondary');
            menu.classList.toggle('show');
        }

        // Close secondary menu when clicking outside
        document.addEventListener('click', function(e) {
            const menu = document.getElementById('menu-secondary');
            const toggle = document.querySelector('.menu-toggle');
            if (menu && toggle && !menu.contains(e.target) && !toggle.contains(e.target)) {
                menu.classList.remove('show');
            }
        });

        // v4.6: Settings Modal Functions
        function showSettingsModal() {
            // Sync UI with current settings
            const s = gameData.settings || {};
            document.getElementById('volume-slider').value = s.masterVolume || 30;
            document.getElementById('volume-display').textContent = (s.masterVolume || 30) + '%';
            updateToggleBtn('sfx-toggle', s.sfxEnabled !== false);
            updateToggleBtn('ambient-toggle', s.ambientEnabled !== false);
            updateToggleBtn('shadow-toggle', s.shadowsEnabled !== false);
            updateToggleBtn('shake-toggle', s.screenShakeEnabled !== false);
            updateToggleBtn('hints-toggle', s.hintsEnabled !== false);
            document.getElementById('particle-quality').value = s.particleQuality || 'high';
            document.getElementById('last-save-time').textContent = gameData.lastPlayed ? new Date(gameData.lastPlayed).toLocaleString() : 'Never';
            document.getElementById('settings-modal').style.display = 'flex';
        }

        function closeSettingsModal() {
            document.getElementById('settings-modal').style.display = 'none';
            saveGameData();
        }

        function updateToggleBtn(id, isOn) {
            const btn = document.getElementById(id);
            if (isOn) {
                btn.textContent = 'ON';
                btn.classList.remove('off');
            } else {
                btn.textContent = 'OFF';
                btn.classList.add('off');
            }
        }

        function setMasterVolume(val) {
            gameData.settings = gameData.settings || {};
            gameData.settings.masterVolume = parseInt(val);
            AudioSystem.masterVolume = val / 100;
            document.getElementById('volume-display').textContent = val + '%';
        }

        function toggleSFX() {
            gameData.settings = gameData.settings || {};
            gameData.settings.sfxEnabled = !gameData.settings.sfxEnabled;
            AudioSystem.enabled = gameData.settings.sfxEnabled;
            updateToggleBtn('sfx-toggle', gameData.settings.sfxEnabled);
        }

        function toggleAmbient() {
            gameData.settings = gameData.settings || {};
            gameData.settings.ambientEnabled = !gameData.settings.ambientEnabled;
            if (gameData.settings.ambientEnabled) {
                if (mode === 'world' && activeCiv) AudioSystem.startAmbient(activeCiv.biome);
            } else {
                AudioSystem.stopAmbient();
            }
            updateToggleBtn('ambient-toggle', gameData.settings.ambientEnabled);
        }

        function setParticleQuality(quality) {
            gameData.settings = gameData.settings || {};
            gameData.settings.particleQuality = quality;
            // Adjust particle limits
            if (particles) {
                particles.maxParticles = quality === 'high' ? 100 : quality === 'medium' ? 50 : 25;
            }
            if (envParticles) {
                envParticles.maxParticles = quality === 'high' ? 60 : quality === 'medium' ? 30 : 15;
            }
        }

        function toggleShadows() {
            gameData.settings = gameData.settings || {};
            gameData.settings.shadowsEnabled = !gameData.settings.shadowsEnabled;
            renderer.shadowMap.enabled = gameData.settings.shadowsEnabled;
            updateToggleBtn('shadow-toggle', gameData.settings.shadowsEnabled);
        }

        function toggleScreenShake() {
            gameData.settings = gameData.settings || {};
            gameData.settings.screenShakeEnabled = !gameData.settings.screenShakeEnabled;
            updateToggleBtn('shake-toggle', gameData.settings.screenShakeEnabled);
        }

        function toggleHints() {
            gameData.settings = gameData.settings || {};
            gameData.settings.hintsEnabled = !gameData.settings.hintsEnabled;
            updateToggleBtn('hints-toggle', gameData.settings.hintsEnabled);
        }

        // v4.6: Apply settings on load
        function applySettings() {
            const s = gameData.settings || {};
            AudioSystem.masterVolume = (s.masterVolume || 30) / 100;
            AudioSystem.enabled = s.sfxEnabled !== false;
            if (particles) {
                particles.maxParticles = s.particleQuality === 'high' ? 100 : s.particleQuality === 'medium' ? 50 : 25;
            }
            if (envParticles) {
                envParticles.maxParticles = s.particleQuality === 'high' ? 60 : s.particleQuality === 'medium' ? 30 : 15;
            }
        }

        function closeModal() {
            document.getElementById('settings-modal').style.display = 'none';
        }

        // v4.3: Notification queue to prevent stacking
        const notificationQueue = [];
        let notificationActive = false;
        const MAX_VISIBLE_NOTIFICATIONS = 3;
        let visibleNotifications = [];

        function showNotification(message, type = 'success') {
            // Add to queue
            notificationQueue.push({ message, type });
            processNotificationQueue();
        }

        function processNotificationQueue() {
            // Remove expired notifications
            visibleNotifications = visibleNotifications.filter(n => n.element.parentNode);

            // Process queue while under limit
            while (notificationQueue.length > 0 && visibleNotifications.length < MAX_VISIBLE_NOTIFICATIONS) {
                const { message, type } = notificationQueue.shift();
                displayNotification(message, type);
            }
        }

        function displayNotification(message, type) {
            const notif = document.createElement('div');
            notif.className = 'notification';
            notif.textContent = message;

            // Position based on how many are currently visible
            const offset = visibleNotifications.length * 50;
            notif.style.top = (100 + offset) + 'px';

            if (type === 'error') {
                notif.style.background = 'rgba(100, 0, 0, 0.9)';
                notif.style.borderColor = '#f00';
                notif.style.color = '#f00';
            } else if (type === 'warning') {
                notif.style.background = 'rgba(100, 80, 0, 0.9)';
                notif.style.borderColor = '#fa0';
                notif.style.color = '#fa0';
            }

            document.body.appendChild(notif);
            const notifObj = { element: notif, expires: Date.now() + 2500 };
            visibleNotifications.push(notifObj);

            setTimeout(() => {
                notif.style.opacity = '0';
                notif.style.transition = 'opacity 0.3s';
                setTimeout(() => {
                    notif.remove();
                    processNotificationQueue();
                }, 300);
            }, 2500);
        }

        // --- INITIALIZATION ---
        function init() {
            loadGameData();

            // v5.7: Load RAPPID settings for AI-powered Copilot
            loadRappidSettings();

            // v5.3: Initialize portal system
            initPortalSystem();

            // v4.7: Check for welcome back rewards
            const sessionReward = checkSessionRewards();
            if (sessionReward) {
                // Delay modal to let game initialize
                setTimeout(() => showWelcomeBackModal(sessionReward), 1500);
            }

            // v4.0: Initialize audio and particle systems
            AudioSystem.init();
            particles = new ParticleSystem();
            envParticles = new EnvironmentParticles(); // v4.4

            // v4.6: Apply saved settings
            applySettings();

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 5000);
            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('container').appendChild(renderer.domElement);

            // Initialize floater pool
            for (let i = 0; i < MAX_FLOATERS; i++) {
                const el = document.createElement('div');
                el.className = 'floater';
                el.style.display = 'none';
                document.body.appendChild(el);
                floaterPool.push({ el, active: false });
            }

            // Inputs
            window.addEventListener('resize', onResize);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mousedown', onMouseDown);

            // Touch events
            if (isTouchDevice) {
                document.getElementById('touch-controls').style.display = 'flex';
                renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
                renderer.domElement.addEventListener('touchmove', onTouchMove, { passive: false });
                renderer.domElement.addEventListener('touchend', onTouchEnd, { passive: false });
                document.getElementById('touch-action').addEventListener('touchstart', onTouchAction);

                // v4.3: Virtual Joystick setup
                const joystick = document.getElementById('virtual-joystick');
                const joystickKnob = document.getElementById('joystick-knob');
                const actionBtn = document.getElementById('touch-action-btn');

                joystick.style.display = 'block';
                actionBtn.style.display = 'flex';

                joystick.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    const rect = joystick.getBoundingClientRect();
                    joystickCenter = { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
                    joystickActive = true;
                    updateJoystick(e.touches[0].clientX, e.touches[0].clientY);
                }, { passive: false });

                joystick.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (joystickActive) {
                        updateJoystick(e.touches[0].clientX, e.touches[0].clientY);
                    }
                }, { passive: false });

                joystick.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    joystickActive = false;
                    joystickInput = { x: 0, y: 0 };
                    joystickKnob.style.transform = 'translate(-50%, -50%)';
                }, { passive: false });

                actionBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (mode === 'world' && worldState.interactTarget) {
                        performAction(worldState.interactTarget);
                    }
                }, { passive: false });

                // v4.5: Dodge button setup
                const dodgeBtn = document.getElementById('touch-dodge-btn');
                dodgeBtn.style.display = 'flex';
                dodgeBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (mode === 'world') {
                        startDodge();
                    }
                }, { passive: false });

                function updateJoystick(touchX, touchY) {
                    let dx = touchX - joystickCenter.x;
                    let dy = touchY - joystickCenter.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist > joystickMaxDist) {
                        dx = (dx / dist) * joystickMaxDist;
                        dy = (dy / dist) * joystickMaxDist;
                    }

                    joystickKnob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
                    joystickInput = { x: dx / joystickMaxDist, y: dy / joystickMaxDist };
                }
            }

            // Keyboard events (including WASD)
            window.addEventListener('keydown', onKeyDown);
            window.addEventListener('keyup', onKeyUp);

            initGalaxy();
            updateInventoryUI();
            updateSkillsUI();
            updateHealthUI();

            // v4.1: Initialize daily challenge system
            generateDailyChallenge();
            updateDailyChallengeUI();

            document.getElementById('loading').style.display = 'none';

            // v4.0: Show tutorial for first-time players
            if (!gameData.hasSeenTutorial) {
                setTimeout(showTutorial, 500);
            }

            // v4.1: Check achievements on load
            checkAchievements();

            // Autosave
            setInterval(() => {
                if (mode === 'world') {
                    saveGameData();
                    checkAchievements();
                    updateDailyChallengeProgress();
                    // v5.3: Check portal timeout
                    checkPortalTimeout();
                }
            }, CONFIG.AUTOSAVE_INTERVAL);

            requestAnimationFrame(loop);
        }

        // --- GALAXY MODE ---
        function initGalaxy() {
            mode = 'galaxy';

            // v4.3: Stop ambient audio when leaving planet
            AudioSystem.stopAmbient();

            // v4.4: Stop environmental particles
            if (envParticles) envParticles.stop();

            while(scene.children.length > 0) scene.remove(scene.children[0]);
            scene.fog = new THREE.FogExp2(0x000510, 0.0002);
            scene.background = new THREE.Color(0x000510);

            scene.add(new THREE.AmbientLight(0x444444));
            let sun = new THREE.PointLight(0xffffff, 1.5, 4000);
            scene.add(sun);

            // Starfield (optimized with BufferGeometry)
            const starGeo = new THREE.BufferGeometry();
            const starPos = [];
            const starColors = [];
            for(let i=0; i<8000; i++) {
                const r = 2000 * Math.cbrt(Math.random());
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2*Math.random()-1);
                starPos.push(r*Math.sin(phi)*Math.cos(theta), r*Math.sin(phi)*Math.sin(theta), r*Math.cos(phi));
                const c = new THREE.Color().setHSL(Math.random() * 0.2 + 0.55, 0.2, 0.8 + Math.random() * 0.2);
                starColors.push(c.r, c.g, c.b);
            }
            starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
            starGeo.setAttribute('color', new THREE.Float32BufferAttribute(starColors, 3));
            scene.add(new THREE.Points(starGeo, new THREE.PointsMaterial({ size: 2, vertexColors: true })));

            // v4.1: Nebula clouds for atmosphere
            createNebulae();

            // Civilizations
            const rng = new SeededRNG('OMNIVERSE');
            civilizations = [];
            galaxyGroup = new THREE.Group();

            for(let i=0; i<CONFIG.NUM_CIVS; i++) {
                const angle = rng.next() * Math.PI * 2;
                const dist = rng.range(200, 1200);
                const x = Math.cos(angle) * dist;
                const z = Math.sin(angle) * dist;
                const y = rng.range(-100, 100);

                const color = new THREE.Color().setHSL(rng.next(), 0.8, 0.5);
                const biomeKey = rng.pick(Object.keys(BIOMES));
                const civ = {
                    id: i, x, y, z, color,
                    name: `System-${rng.int(100,999)}`,
                    biome: biomeKey,
                    biomeName: BIOMES[biomeKey].name,
                    pop: rng.int(1, 100),
                    visited: gameData.visitedPlanets.includes(i)
                };
                civilizations.push(civ);

                const sysGroup = new THREE.Group();
                sysGroup.position.set(x,y,z);

                const star = new THREE.Mesh(
                    new THREE.SphereGeometry(8, 16, 16),
                    new THREE.MeshBasicMaterial({color: color})
                );
                sysGroup.add(star);

                const glow = new THREE.Mesh(
                    new THREE.SphereGeometry(16, 16, 16),
                    new THREE.MeshBasicMaterial({color: color, transparent: true, opacity: 0.2})
                );
                sysGroup.add(glow);

                // Mark visited planets
                if (civ.visited) {
                    const ring = new THREE.Mesh(
                        new THREE.RingGeometry(18, 20, 16),
                        new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide, transparent: true, opacity: 0.5 })
                    );
                    ring.rotation.x = Math.PI / 2;
                    sysGroup.add(ring);
                }

                sysGroup.userData = { type: 'civ', data: civ };
                galaxyGroup.add(sysGroup);
            }
            scene.add(galaxyGroup);

            selectionRing = new THREE.Mesh(
                new THREE.RingGeometry(12, 14, 32),
                new THREE.MeshBasicMaterial({color: 0x00ffff, side: THREE.DoubleSide})
            );
            selectionRing.rotation.x = Math.PI/2;
            selectionRing.visible = false;
            scene.add(selectionRing);

            camera.position.set(0, 1000, 1500);
            camera.lookAt(0,0,0);

            document.getElementById('galaxy-controls').style.display = 'flex';
            document.getElementById('world-controls').style.display = 'none';
            document.getElementById('rpg-ui').style.display = 'none';
            document.getElementById('player-health-bar').style.display = 'none';
            document.getElementById('minimap').style.display = 'none';
            document.getElementById('ability-bar').style.display = 'none';
            document.getElementById('weather-indicator').style.display = 'none';
            document.getElementById('civ-count').innerText = CONFIG.NUM_CIVS;

            updatePlaytimeDisplay();
        }

        // --- WORLD MODE ---
        function initWorld(civ) {
            activeCiv = civ;
            mode = 'world';

            // Mark as visited
            if (!gameData.visitedPlanets.includes(civ.id)) {
                gameData.visitedPlanets.push(civ.id);
                showNotification(`First visit to ${civ.name}!`);
                // v4.1: Check achievements after planet discovery
                checkAchievements();
                updateDailyChallengeProgress();
            }

            // v4.9: Track biome in codex
            trackBiomeVisit(civ.biome.toLowerCase());

            while(scene.children.length > 0) scene.remove(scene.children[0]);

            // v4.3: Reset boss spawn tracking for new world
            worldMobKillCount = 0;
            bossSpawned = false;

            const biome = BIOMES[civ.biome];
            scene.background = new THREE.Color(biome.sky);
            scene.fog = new THREE.Fog(biome.sky, 20, 120);

            worldState.ambient = new THREE.AmbientLight(0x404040);
            scene.add(worldState.ambient);

            worldState.sun = new THREE.DirectionalLight(0xffffff, 1);
            worldState.sun.castShadow = true;
            worldState.sun.shadow.camera.left = -50;
            worldState.sun.shadow.camera.right = 50;
            worldState.sun.shadow.camera.top = 50;
            worldState.sun.shadow.camera.bottom = -50;
            worldState.sun.shadow.mapSize.width = 1024;
            worldState.sun.shadow.mapSize.height = 1024;
            scene.add(worldState.sun);

            const rng = new SeededRNG(civ.name);
            worldState.terrain = [];
            worldState.interactables = [];
            worldState.fishingSpots = [];
            worldState.mobs = [];

            // Merged geometry for better performance
            const groundGeo = new THREE.BoxGeometry(CONFIG.TILE_SIZE, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE);
            const groundMat = new THREE.MeshLambertMaterial({ color: biome.ground });
            const waterMat = new THREE.MeshLambertMaterial({ color: biome.water, transparent: true, opacity: 0.8 });

            const worldGroup = new THREE.Group();

            for(let x=0; x<CONFIG.WORLD_SIZE; x++) {
                worldState.terrain[x] = [];
                for(let z=0; z<CONFIG.WORLD_SIZE; z++) {
                    const hVal = noise(x + civ.id, z + civ.id);
                    const height = Math.floor((hVal + 1) * 3);
                    const realY = height * CONFIG.TILE_SIZE/2;

                    const isWater = height < 1;

                    const mesh = new THREE.Mesh(groundGeo, isWater ? waterMat : groundMat);
                    mesh.position.set(
                        (x - CONFIG.WORLD_SIZE/2) * CONFIG.TILE_SIZE,
                        realY,
                        (z - CONFIG.WORLD_SIZE/2) * CONFIG.TILE_SIZE
                    );
                    mesh.receiveShadow = true;
                    worldGroup.add(mesh);

                    worldState.terrain[x][z] = isWater ? -99 : (height * CONFIG.TILE_SIZE/2) + CONFIG.TILE_SIZE/2;

                    // Fishing spots in water
                    if(isWater && rng.next() > 0.95) {
                        createFishingSpot(mesh.position.x, mesh.position.y + 1, mesh.position.z);
                    }

                    // Trees/Rocks
                    if(!isWater && rng.next() > 0.85) {
                        const type = rng.next() > 0.5 ? 'tree' : 'rock';
                        createProp(type, mesh.position.x, mesh.position.y + CONFIG.TILE_SIZE/2, mesh.position.z, biome);
                    }
                }
            }
            scene.add(worldGroup);

            // Player - Using CylinderGeometry since CapsuleGeometry isn't in Three.js r128
            const playerGroup = new THREE.Group();

            // Body (cylinder)
            const bodyGeo = new THREE.CylinderGeometry(0.6, 0.6, 1.6, 8);
            const playerMat = new THREE.MeshStandardMaterial({ color: 0xffff00, metalness: 0.3, roughness: 0.7 });
            const body = new THREE.Mesh(bodyGeo, playerMat);
            body.position.y = 0.8;
            body.castShadow = true;
            playerGroup.add(body);

            // Head (sphere on top)
            const headGeo = new THREE.SphereGeometry(0.5, 8, 8);
            const head = new THREE.Mesh(headGeo, playerMat);
            head.position.y = 1.8;
            head.castShadow = true;
            playerGroup.add(head);

            worldState.player = playerGroup;
            worldState.player.position.set(0, 10, 0);

            const ring = new THREE.Mesh(
                new THREE.RingGeometry(0.8, 1, 16),
                new THREE.MeshBasicMaterial({ color: 0xffff00, side: THREE.DoubleSide })
            );
            ring.rotation.x = -Math.PI/2;
            ring.position.y = 0;
            worldState.player.add(ring);

            scene.add(worldState.player);

            // Mobs
            const mobCount = 5 + Math.floor(rng.next() * 5);
            for(let i=0; i<mobCount; i++) {
                createMob(rng, biome);
            }

            // v4.2: Generate POIs based on biome
            worldState.pois = [];
            const biomeKey = civ.biome;
            for (const [poiType, poiData] of Object.entries(POI_TYPES)) {
                // Check if POI can spawn in this biome
                if (poiData.biomes && !poiData.biomes.includes(biomeKey)) continue;

                // Check rarity
                if (rng.next() < poiData.rarity) {
                    // Check if already discovered on this planet
                    const alreadyDiscovered = gameData.discoveredPOIs[civ.id]?.includes(poiType);
                    createPOI(rng, biome, poiType, poiData);
                    // Mark pre-discovered POIs
                    if (alreadyDiscovered && worldState.pois.length > 0) {
                        const poi = worldState.pois[worldState.pois.length - 1];
                        poi.userData.discovered = true;
                        if (poi.userData.beacon) poi.userData.beacon.material.emissiveIntensity = 0.1;
                        if (poi.userData.iconMesh) poi.userData.iconMesh.material.opacity = 0.3;
                    }
                }
            }

            // UI
            document.getElementById('galaxy-controls').style.display = 'none';
            document.getElementById('world-controls').style.display = 'flex';
            document.getElementById('world-name').textContent = civ.biomeName;
            document.getElementById('rpg-ui').style.display = 'flex';
            document.getElementById('player-health-bar').style.display = 'block';
            document.getElementById('minimap').style.display = 'block';
            document.getElementById('ability-bar').style.display = 'block';
            document.getElementById('weather-indicator').style.display = 'block';
            updateAbilityUI();
            updateWeatherUI();

            // v4.3: Start biome ambient audio
            AudioSystem.startAmbient(civ.biome);

            // v5.0: Spawn pet companion
            initPetSystem();
            updatePetMesh();

            // v5.6: Initialize and spawn Copilot Companion
            initCopilotCompanion();
            createCopilotMesh();

            // v5.0: Initialize weather system
            initWeatherSystem();

            // v5.4: Initialize new systems
            initPetEvolutionSystem();
            initWorldEventSystem();
            initAchievementShowcase();

            // v4.4: Start environmental particles
            if (envParticles) envParticles.startBiome(civ.biome);

            worldState.target = null;
            worldState.interactTarget = null;

            updateInventoryUI();
            updateSkillsUI();
            updateHealthUI();
            updateCraftingUI();
            initMinimap();
        }

        function createProp(type, x, y, z, biome) {
            const group = new THREE.Group();
            group.position.set(x, y, z);

            if(type === 'tree') {
                const trunk = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.3, 0.5, 2, 6),
                    new THREE.MeshLambertMaterial({ color: 0x553311 })
                );
                trunk.position.y = 1;
                trunk.castShadow = true;
                group.add(trunk);

                const leaves = new THREE.Mesh(
                    new THREE.ConeGeometry(1.2, 2.5, 8),
                    new THREE.MeshLambertMaterial({ color: biome.tree })
                );
                leaves.position.y = 2.8;
                leaves.castShadow = true;
                group.add(leaves);
                group.userData = { type: 'tree', hp: 3, maxHp: 3, name: 'Ancient Tree' };
            } else {
                const rock = new THREE.Mesh(
                    new THREE.DodecahedronGeometry(1),
                    new THREE.MeshLambertMaterial({ color: biome.rock })
                );
                rock.position.y = 0.5;
                rock.rotation.set(Math.random(), Math.random(), Math.random());
                rock.castShadow = true;
                group.add(rock);
                group.userData = { type: 'rock', hp: 3, maxHp: 3, name: 'Ore Vein' };
            }

            scene.add(group);
            worldState.interactables.push(group);
        }

        function createFishingSpot(x, y, z) {
            const group = new THREE.Group();
            group.position.set(x, y, z);

            // Ripple effect
            const ripple = new THREE.Mesh(
                new THREE.RingGeometry(0.8, 1, 16),
                new THREE.MeshBasicMaterial({ color: 0x88ccff, transparent: true, opacity: 0.5, side: THREE.DoubleSide })
            );
            ripple.rotation.x = -Math.PI / 2;
            group.add(ripple);

            group.userData = { type: 'fishing', name: 'Fishing Spot', ripple };
            scene.add(group);
            worldState.fishingSpots.push(group);
            worldState.interactables.push(group);
        }

        function createMob(rng, biome) {
            // v4.2: Select enemy type based on biome
            const biomeKey = biome.name === 'Terra' ? 'Terra' :
                            biome.name === 'Desert' ? 'Desert' :
                            biome.name === 'Tundra' ? 'Ice' :
                            biome.name === 'Xeno' ? 'Alien' :
                            biome.name === 'Magma' ? 'Volcanic' : 'Terra';

            const validEnemies = Object.entries(ENEMY_TYPES)
                .filter(([name, data]) => data.biomes.includes(biomeKey));

            const [enemyName, enemyData] = validEnemies.length > 0
                ? validEnemies[rng.int(0, validEnemies.length - 1)]
                : ['Slime', ENEMY_TYPES.Slime];

            // v4.7: Elite enemy roll
            const prestigeLevel = gameData.prestige?.level || 0;
            const isElite = prestigeLevel >= ELITE_CONFIG.minWorldLevel &&
                           rng.next() < ELITE_CONFIG.spawnChance;

            let eliteAffix = null;
            let eliteData = null;
            if (isElite) {
                const affixKeys = Object.keys(ELITE_AFFIXES);
                const affixKey = affixKeys[rng.int(0, affixKeys.length - 1)];
                eliteAffix = affixKey;
                eliteData = ELITE_AFFIXES[affixKey];
            }

            // Calculate stats with elite multipliers
            const baseHp = enemyData.hp * (eliteData ? eliteData.hpMult : 1);
            const baseDamage = enemyData.damage * (eliteData ? eliteData.damageMult : 1);
            const baseSpeed = enemyData.speed * (eliteData ? eliteData.speedMult : 1);

            const mobGeo = new THREE.SphereGeometry(isElite ? 1.0 : 0.8, 16, 16);
            const mobMat = new THREE.MeshStandardMaterial({
                color: eliteData ? eliteData.color : enemyData.color,
                roughness: 0.3,
                emissive: eliteData ? eliteData.color : enemyData.emissive,
                emissiveIntensity: isElite ? 0.5 : 0.2
            });
            const mob = new THREE.Mesh(mobGeo, mobMat);

            const rx = (rng.next() - 0.5) * 60;
            const rz = (rng.next() - 0.5) * 60;
            mob.position.set(rx, 10, rz);
            mob.castShadow = true;

            // v4.7: Add glowing aura ring for elite enemies
            if (isElite) {
                const auraGeo = new THREE.RingGeometry(1.2, 1.5, 32);
                const auraMat = new THREE.MeshBasicMaterial({
                    color: eliteData.color,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.6
                });
                const aura = new THREE.Mesh(auraGeo, auraMat);
                aura.rotation.x = -Math.PI / 2;
                aura.position.y = 0.1;
                mob.add(aura);
                mob.userData.auraRing = aura;
            }

            // Health bar above mob (larger for elites)
            const hpBar = new THREE.Mesh(
                new THREE.PlaneGeometry(isElite ? 2.0 : 1.5, 0.15),
                new THREE.MeshBasicMaterial({ color: isElite ? 0xffaa00 : 0x00ff00, side: THREE.DoubleSide })
            );
            hpBar.position.y = isElite ? 1.8 : 1.5;
            mob.add(hpBar);

            const hpBg = new THREE.Mesh(
                new THREE.PlaneGeometry(isElite ? 2.1 : 1.6, 0.2),
                new THREE.MeshBasicMaterial({ color: isElite ? 0x553300 : 0x333333, side: THREE.DoubleSide })
            );
            hpBg.position.y = isElite ? 1.8 : 1.5;
            hpBg.position.z = -0.01;
            mob.add(hpBg);

            // v5.3: Apply portal modifiers to mob stats
            const portalMods = getPortalModifiers();
            let finalHp = baseHp;
            let finalDamage = baseDamage;
            if (portalMods) {
                finalHp = Math.floor(baseHp * (portalMods.enemyHp || 1));
                finalDamage = Math.floor(baseDamage * (portalMods.enemyDamage || 1));
            }

            mob.userData = {
                type: 'mob',
                hp: finalHp,
                maxHp: finalHp,
                name: enemyName,
                damage: finalDamage,
                speed: baseSpeed,
                drops: enemyData.drops,
                xpReward: enemyData.xp * (isElite ? ELITE_CONFIG.bonusXpMult : 1),
                nextMove: 0,
                nextAttack: 0,
                targetPos: new THREE.Vector3(),
                hpBar,
                // v4.5: Attack telegraph properties
                attackWindup: enemyData.attackWindup || 600,
                attackRange: enemyData.attackRange || 2.5,
                telegraphing: false,
                // v4.7: Elite properties
                isElite: isElite,
                eliteAffix: eliteAffix,
                eliteData: eliteData,
                displayName: isElite ? `${eliteData.prefix} ${eliteData.name} ${enemyName}` : enemyName,
                // v5.3: Portal-modified flag
                portalBuffed: portalMods !== null
            };

            scene.add(mob);
            worldState.mobs.push(mob);

            // v4.7: Announce elite spawn
            if (isElite) {
                showNotification(`${eliteData.prefix} ELITE ${eliteData.name} ${enemyName} appeared!`, 'warning');
            }
        }

        // v4.2: Create Point of Interest
        function createPOI(rng, biome, poiType, poiData) {
            const group = new THREE.Group();

            // Create visual marker based on POI type
            const baseGeo = new THREE.CylinderGeometry(2, 2.5, 0.5, 8);
            const baseMat = new THREE.MeshStandardMaterial({
                color: 0x886644,
                roughness: 0.8
            });
            const base = new THREE.Mesh(baseGeo, baseMat);
            group.add(base);

            // Add glowing beacon
            const beaconGeo = new THREE.CylinderGeometry(0.3, 0.3, 4, 8);
            const beaconMat = new THREE.MeshStandardMaterial({
                color: 0xffdd00,
                emissive: 0xffaa00,
                emissiveIntensity: 0.5
            });
            const beacon = new THREE.Mesh(beaconGeo, beaconMat);
            beacon.position.y = 2.5;
            group.add(beacon);

            // Floating icon sphere
            const iconGeo = new THREE.SphereGeometry(0.6, 16, 16);
            const iconMat = new THREE.MeshStandardMaterial({
                color: 0x44ffff,
                emissive: 0x22aaaa,
                transparent: true,
                opacity: 0.8
            });
            const icon = new THREE.Mesh(iconGeo, iconMat);
            icon.position.y = 5;
            group.add(icon);

            const rx = (rng.next() - 0.5) * 50;
            const rz = (rng.next() - 0.5) * 50;
            group.position.set(rx, 0, rz);

            group.userData = {
                type: 'poi',
                poiType: poiType,
                name: poiData.name,
                icon: poiData.icon,
                rewards: poiData.rewards,
                xpBonus: poiData.xpBonus,
                discovered: false,
                beacon: beacon,
                iconMesh: icon
            };

            scene.add(group);
            worldState.pois.push(group);
            worldState.interactables.push(group);
        }

        // v4.3: Create Boss
        function createBoss(biomeKey) {
            const bossId = `${biomeKey}_Boss`;
            const bossData = BOSS_TYPES[bossId];
            if (!bossData) return;

            // Create larger, more intimidating boss mesh
            const bossGeo = new THREE.SphereGeometry(0.8 * bossData.scale, 24, 24);
            const bossMat = new THREE.MeshStandardMaterial({
                color: bossData.color,
                roughness: 0.2,
                emissive: bossData.emissive,
                emissiveIntensity: 0.5
            });
            const boss = new THREE.Mesh(bossGeo, bossMat);

            // Position boss away from spawn
            boss.position.set(
                (Math.random() - 0.5) * 40,
                15,
                (Math.random() - 0.5) * 40
            );
            boss.castShadow = true;

            // Boss health bar (larger)
            const hpBar = new THREE.Mesh(
                new THREE.PlaneGeometry(3, 0.3),
                new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide })
            );
            hpBar.position.y = 3;
            boss.add(hpBar);

            const hpBg = new THREE.Mesh(
                new THREE.PlaneGeometry(3.2, 0.4),
                new THREE.MeshBasicMaterial({ color: 0x333333, side: THREE.DoubleSide })
            );
            hpBg.position.y = 3;
            hpBg.position.z = -0.01;
            boss.add(hpBg);

            // Crown/indicator for boss
            const crownGeo = new THREE.ConeGeometry(0.5, 0.8, 4);
            const crownMat = new THREE.MeshStandardMaterial({ color: 0xffd700, emissive: 0xaa8800 });
            const crown = new THREE.Mesh(crownGeo, crownMat);
            crown.position.y = bossData.scale * 0.8 + 0.5;
            crown.rotation.y = Math.PI / 4;
            boss.add(crown);

            boss.userData = {
                type: 'boss',
                bossId: bossId,
                hp: bossData.hp,
                maxHp: bossData.hp,
                name: bossData.name,
                damage: bossData.damage,
                speed: bossData.speed,
                scale: bossData.scale,
                drops: bossData.drops,
                xpReward: bossData.xp,
                nextMove: 0,
                nextAttack: 0,
                targetPos: new THREE.Vector3(),
                hpBar,
                isBoss: true
            };

            scene.add(boss);
            worldState.mobs.push(boss);

            // Announce boss spawn
            showNotification(`BOSS APPEARED: ${bossData.name}!`, 'error');
            AudioSystem.bossSpawn();

            return boss;
        }

        // v4.3: Track world mob kills for boss spawning
        let worldMobKillCount = 0;
        let bossSpawned = false;

        function checkBossSpawn() {
            if (bossSpawned || !activeCiv) return;

            // Find the appropriate boss for this biome
            const biomeKey = activeCiv.biome;
            const bossId = `${biomeKey}_Boss`;
            const bossData = BOSS_TYPES[bossId];

            if (!bossData) return;

            const condition = bossData.spawnCondition;

            // v4.5: Check mob kill requirement
            if (worldMobKillCount < condition.mobsKilled) return;

            // v4.5: Check combat level requirement
            if (condition.minCombatLevel && gameData.skills.combat.level < condition.minCombatLevel) {
                // Show hint if close to spawning
                if (worldMobKillCount === condition.mobsKilled) {
                    showNotification(`Boss requires Combat Level ${condition.minCombatLevel}!`, 'warning');
                }
                return;
            }

            // v4.5: Check required item
            if (condition.requiredItem && !hasItem(condition.requiredItem)) {
                if (worldMobKillCount === condition.mobsKilled) {
                    showNotification(`Boss requires ${condition.requiredItem} equipped!`, 'warning');
                }
                return;
            }

            createBoss(biomeKey);
            bossSpawned = true;
        }

        // --- GAME LOOP ---
        // v4.7: Tab visibility handling
        let tabVisible = true;
        let lastFpsTime = 0;
        let frameCount = 0;
        let currentFps = 60;

        document.addEventListener('visibilitychange', () => {
            tabVisible = !document.hidden;
            if (tabVisible) {
                // Reset timing when tab becomes visible to prevent huge dt
                lastTime = performance.now();
                AudioSystem.resume();
            } else {
                // Pause audio when tab is hidden
                if (AudioSystem.ctx && AudioSystem.ctx.state === 'running') {
                    AudioSystem.ctx.suspend();
                }
            }
        });

        function loop(time) {
            requestAnimationFrame(loop);

            // v4.7: Skip updates when tab is not visible (save resources)
            if (!tabVisible) {
                return;
            }

            // v4.7: Track FPS for adaptive performance
            frameCount++;
            if (time - lastFpsTime >= 1000) {
                currentFps = frameCount;
                frameCount = 0;
                lastFpsTime = time;

                // Adaptive performance: reduce particles if FPS drops
                if (currentFps < 30 && particles && particles.maxParticles > 25) {
                    particles.maxParticles = Math.max(25, particles.maxParticles - 10);
                    console.log('Performance: Reduced particles to', particles.maxParticles);
                } else if (currentFps > 55 && particles && particles.maxParticles < 100) {
                    particles.maxParticles = Math.min(100, particles.maxParticles + 5);
                }
            }

            // v4.4: Hit-stop effect - skip game logic during freeze, still render
            if (performance.now() < hitStopUntil) {
                renderer.render(scene, camera);
                return;
            }

            const dt = Math.min((time - lastTime) / 1000, 0.1);
            lastTime = time;

            gameData.playtime += dt;

            if(mode === 'galaxy') {
                galaxyGroup.rotation.y += 0.0005;
                cycle = Math.floor(time / 1000);
                document.getElementById('cycle-count').innerText = cycle;

                if(activeCiv) {
                    selectionRing.rotation.z -= 0.01;
                    const pulse = 1 + Math.sin(time * 0.005) * 0.1;
                    selectionRing.scale.set(pulse, pulse, 1);
                }

                if (cycle % 10 === 0) updatePlaytimeDisplay();
            }
            else if(mode === 'world') {
                updateWorld(dt, time);
            }

            renderer.render(scene, camera);
        }

        function updateWorld(dt, time) {
            // Day/Night Cycle
            worldState.timeOfDay = (time * 0.00005) % 1;
            const angle = worldState.timeOfDay * Math.PI * 2;
            const radius = 80;

            worldState.sun.position.set(Math.cos(angle)*radius, Math.sin(angle)*radius, 50);
            worldState.sun.intensity = Math.max(0.1, Math.sin(angle)) * 1.2;

            const biome = BIOMES[activeCiv.biome];
            const dayColor = new THREE.Color(biome.sky);
            const nightColor = new THREE.Color(0x050510);
            scene.background.lerpColors(nightColor, dayColor, Math.max(0.1, Math.sin(angle)));
            scene.fog.color.copy(scene.background);

            // Player Movement
            const p = worldState.player;

            // v4.7: Check and clear chilled status
            if (playerState.chilled && time > playerState.chilledEnd) {
                playerState.chilled = false;
                playerState.moveSpeedMult = 1.0;
            }
            // v5.0: Apply weather speed modifier, v5.1: Apply equipment move speed
            const equipStats = getEquipmentStats();
            const speed = 12 * playerState.moveSpeedMult * getWeatherSpeedMod() * equipStats.moveSpeed;

            // v4.0: WASD keyboard movement + v4.3: Virtual joystick
            const hasKeyInput = keys.w || keys.a || keys.s || keys.d;
            const hasJoystickInput = joystickActive && (Math.abs(joystickInput.x) > 0.1 || Math.abs(joystickInput.y) > 0.1);

            // v5.5: Disable autopilot if player takes manual control
            if (hasKeyInput || hasJoystickInput) {
                if (autoExplore.enabled) {
                    autoExplore.enabled = false;
                    autoExplore.currentTarget = null;
                    updateAutoExploreUI();
                    showNotification('MANUAL OVERRIDE - Autopilot disengaged', 'info');
                }
            }

            // v5.5: Run autonomous exploration if enabled
            if (autoExplore.enabled) {
                runAutoExplore(dt);
            }

            if (hasKeyInput || hasJoystickInput) {
                _tempVec3A.set(0, 0, 0);
                if (hasKeyInput) {
                    if (keys.w) _tempVec3A.z -= 1;
                    if (keys.s) _tempVec3A.z += 1;
                    if (keys.a) _tempVec3A.x -= 1;
                    if (keys.d) _tempVec3A.x += 1;
                } else if (hasJoystickInput) {
                    // v4.3: Joystick input (x is left/right, y is up/down on screen = forward/back in 3D)
                    _tempVec3A.x = joystickInput.x;
                    _tempVec3A.z = joystickInput.y;
                }
                _tempVec3A.normalize().multiplyScalar(speed * dt);
                p.position.add(_tempVec3A);
                worldState.target = null;
                worldState.interactTarget = null;
                // Face movement direction
                if (_tempVec3A.length() > 0.01) {
                    p.rotation.y = Math.atan2(_tempVec3A.x, _tempVec3A.z);
                }
            }

            // Click-to-move (using pre-allocated vector)
            if(worldState.target) {
                _tempVec3A.subVectors(worldState.target, p.position);
                _tempVec3A.y = 0;
                const dist = _tempVec3A.length();

                if(dist > CONFIG.MOVEMENT_THRESHOLD) {
                    _tempVec3A.normalize();
                    p.position.add(_tempVec3A.multiplyScalar(speed * dt));
                    p.lookAt(worldState.target.x, p.position.y, worldState.target.z);
                } else {
                    worldState.target = null;
                }
            }

            snapToGround(p);

            // v4.0: Cooldown-based interaction (replaces random chance)
            if(worldState.interactTarget) {
                const t = worldState.interactTarget;
                const dist = p.position.distanceTo(t.position);

                if(dist < CONFIG.INTERACTION_RANGE) {
                    worldState.target = null;

                    const now = performance.now();
                    if(now - worldState.lastActionTime > CONFIG.INTERACTION_COOLDOWN) {
                        performAction(t);
                        worldState.lastActionTime = now;
                    }
                } else if (!worldState.target) {
                    worldState.target = t.position.clone();
                }
            }

            // Camera Follow (using pre-allocated vector)
            camera.position.lerp(p.position.clone().add(_camOffset), 0.08);
            camera.lookAt(p.position);

            // v4.0: Screen shake effect
            updateScreenShake();

            // v4.0: Update particles
            if (particles) particles.update(dt);

            // v4.4: Update environmental particles
            if (envParticles && worldState.player) {
                envParticles.update(dt, worldState.player.position);
            }

            // v4.5: Update dodge movement
            updateDodge(dt);

            // Mob AI with aggro (using CONFIG constants)
            worldState.mobs.forEach(mob => {
                if (!mob.parent) return;

                // v4.6: Update status effects
                updateMobStatusEffects(mob, time);

                // Check if mob died from status effect DoT
                if (mob.userData.hp <= 0) {
                    // Handle death - same as combat death but simplified
                    const xpReward = mob.userData.xpReward || 100;
                    addXp('combat', xpReward);
                    gameData.statistics.mobsKilled++;
                    worldMobKillCount++;
                    checkBossSpawn();
                    // v4.9: Track creature in codex
                    trackCreatureKill(mob.userData.name?.toLowerCase() || 'unknown');
                    spawnFloater(mob.position, `KILLED! +${xpReward}XP`, '#f00');
                    if (particles) particles.emit(mob.position, 20, ENEMY_TYPES[mob.userData.name]?.color || 0x44ff44);
                    scene.remove(mob);
                    worldState.mobs = worldState.mobs.filter(x => x !== mob);
                    return;
                }

                // v4.6: Handle stun state from parry
                if (mob.userData.stunned) {
                    if (time < mob.userData.stunEnd) {
                        // Still stunned - skip AI behavior, keep yellow glow
                        mob.userData.telegraphing = false;
                        // Update HP bar to face camera
                        if (mob.userData.hpBar) mob.userData.hpBar.lookAt(camera.position);
                        return;
                    } else {
                        // Stun ended
                        mob.userData.stunned = false;
                        // Restore original emissive
                        const originalEmissive = ENEMY_TYPES[mob.userData.name]?.emissive || 0x003300;
                        mob.material.emissive.setHex(originalEmissive);
                    }
                }

                const distToPlayer = mob.position.distanceTo(p.position);

                // Aggro range
                if (distToPlayer < CONFIG.MOB_AGGRO_RANGE && distToPlayer > CONFIG.MOB_ATTACK_RANGE) {
                    mob.userData.targetPos.copy(p.position);
                    mob.userData.nextMove = time + 500;
                } else if(time > mob.userData.nextMove) {
                    mob.userData.targetPos.set(
                        mob.position.x + (Math.random()-0.5)*10,
                        0,
                        mob.position.z + (Math.random()-0.5)*10
                    );
                    mob.userData.nextMove = time + 2000 + Math.random()*2000;
                }

                // Move mob (using temp vector) - v4.2: Use enemy-specific speed
                // v4.6: Apply status effect speed modifier
                _tempVec3B.subVectors(mob.userData.targetPos, mob.position);
                _tempVec3B.y = 0;
                if(_tempVec3B.length() > 0.1) {
                    _tempVec3B.normalize();
                    const mobSpeed = (mob.userData.speed || 4) * (mob.userData.speedMultiplier || 1);
                    mob.position.add(_tempVec3B.multiplyScalar(mobSpeed * dt));
                }
                snapToGround(mob);

                // v4.5: Attack telegraph system with windup
                const attackRange = mob.userData.attackRange || CONFIG.MOB_ATTACK_RANGE;
                const attackWindup = mob.userData.attackWindup || 600;

                // Start telegraph when in range and ready to attack
                if (distToPlayer < attackRange && time > mob.userData.nextAttack && !mob.userData.telegraphing) {
                    mob.userData.telegraphing = true;
                    mob.userData.telegraphStart = time;
                    mob.userData.telegraphEnd = time + attackWindup;
                    // Show telegraph visual - mob glows red
                    if (mob.material) {
                        mob.userData.originalEmissive = mob.material.emissive.getHex();
                        mob.material.emissive.setHex(0xff0000);
                    }
                    AudioSystem.telegraph();
                }

                // Update telegraph progress
                if (mob.userData.telegraphing) {
                    const telegraphProgress = (time - mob.userData.telegraphStart) / attackWindup;
                    // Pulse effect during windup
                    const pulseScale = 1 + Math.sin(telegraphProgress * Math.PI * 4) * 0.15;
                    mob.scale.setScalar(pulseScale);

                    // Execute attack when windup completes
                    if (time >= mob.userData.telegraphEnd) {
                        mob.userData.telegraphing = false;
                        mob.scale.setScalar(1);
                        // Restore original emissive
                        if (mob.material && mob.userData.originalEmissive !== undefined) {
                            mob.material.emissive.setHex(mob.userData.originalEmissive);
                        }
                        // Only deal damage if still in range
                        if (distToPlayer < attackRange * 1.2) {
                            // v4.6: Apply damage multiplier from status effects
                            const actualDamage = Math.floor(mob.userData.damage * (mob.userData.damageMultiplier || 1));
                            damagePlayer(actualDamage);
                            spawnFloater(p.position, `-${actualDamage} HP`, '#ff4444');

                            // v4.7: Vampiric elite heals on hit
                            if (mob.userData.isElite && mob.userData.eliteData?.lifesteal) {
                                const healAmount = Math.floor(actualDamage * mob.userData.eliteData.lifesteal);
                                mob.userData.hp = Math.min(mob.userData.maxHp, mob.userData.hp + healAmount);
                                spawnFloater(mob.position, `ðŸ¦‡ +${healAmount}`, '#ff00ff');
                                // Update health bar
                                if (mob.userData.hpBar) {
                                    const hpPercent = mob.userData.hp / mob.userData.maxHp;
                                    mob.userData.hpBar.scale.x = Math.max(0.01, hpPercent);
                                }
                            }
                        }
                        mob.userData.nextAttack = time + CONFIG.MOB_ATTACK_COOLDOWN;
                    }
                }

                // v4.7: Elite affix behaviors
                if (mob.userData.isElite && mob.userData.eliteData) {
                    const eliteData = mob.userData.eliteData;

                    // Regenerating: heal over time
                    if (eliteData.regenRate && mob.userData.hp < mob.userData.maxHp) {
                        const regenAmount = mob.userData.maxHp * eliteData.regenRate * dt;
                        mob.userData.hp = Math.min(mob.userData.maxHp, mob.userData.hp + regenAmount);
                        // Update health bar
                        if (mob.userData.hpBar) {
                            const hpPercent = mob.userData.hp / mob.userData.maxHp;
                            mob.userData.hpBar.scale.x = Math.max(0.01, hpPercent);
                        }
                    }

                    // Teleporter: blink towards player when in aggro range
                    if (eliteData.canTeleport && distToPlayer < CONFIG.MOB_AGGRO_RANGE && distToPlayer > 5) {
                        if (!mob.userData.lastTeleport || time - mob.userData.lastTeleport > 4000) {
                            // Teleport towards player
                            const teleportDist = Math.min(10, distToPlayer - 3);
                            const dir = _tempVec3B.subVectors(p.position, mob.position).normalize();
                            mob.position.add(dir.multiplyScalar(teleportDist));
                            mob.userData.lastTeleport = time;
                            spawnFloater(mob.position, 'ðŸŒ€', '#9900ff');
                            if (particles) particles.emit(mob.position, 15, 0x9900ff, { spread: 3, lifetime: 500 });
                        }
                    }

                    // Chilling Aura: slow player when nearby
                    if (eliteData.chillingAura && distToPlayer < 6) {
                        if (!playerState.chilled || time > playerState.chilledEnd) {
                            playerState.chilled = true;
                            playerState.chilledEnd = time + 500;
                            playerState.moveSpeedMult = 0.5;
                        }
                    }

                    // Animate elite aura ring
                    if (mob.userData.auraRing) {
                        mob.userData.auraRing.rotation.z += dt * 2;
                        const auraScale = 1 + Math.sin(time * 0.005) * 0.2;
                        mob.userData.auraRing.scale.set(auraScale, auraScale, 1);
                    }
                }

                // Update HP bar rotation to face camera
                if (mob.userData.hpBar) {
                    mob.userData.hpBar.lookAt(camera.position);
                }
            });

            // Animate fishing spots
            worldState.fishingSpots.forEach(spot => {
                if (spot.userData.ripple) {
                    const scale = 1 + Math.sin(time * 0.003) * 0.2;
                    spot.userData.ripple.scale.set(scale, scale, 1);
                }
            });

            // Update minimap
            updateMinimap();

            // v4.8: Update ability cooldowns
            updateAbilityUI();

            // v5.0: Update pet companion
            updatePet(dt, time);
            updatePetRegen(time);

            // v5.6: Update Copilot Companion
            updateCopilotCompanion(dt, time);

            // v5.0: Update weather system
            updateWeather(dt, time);

            // v5.4: Update world events
            updateWorldEvent(dt, time);

            // v5.4: Update cosmetic effects
            updateCosmeticEffects(time);
        }

        function snapToGround(obj) {
            const gx = Math.round(obj.position.x / CONFIG.TILE_SIZE) + CONFIG.WORLD_SIZE/2;
            const gz = Math.round(obj.position.z / CONFIG.TILE_SIZE) + CONFIG.WORLD_SIZE/2;

            if(gx >=0 && gx < CONFIG.WORLD_SIZE && gz >= 0 && gz < CONFIG.WORLD_SIZE) {
                const y = worldState.terrain[gx][gz];
                if(y > -50) {
                    const targetY = y + (obj === worldState.player ? 1.2 : 0.8);
                    obj.position.y = THREE.MathUtils.lerp(obj.position.y, targetY, 0.15);
                }
            }
        }

        // v4.2: Calculate player damage with weapon bonus and skill levels
        function getPlayerDamage() {
            let baseDamage = 1;

            // v5.1: Get damage from equipped gear
            const equipStats = getEquipmentStats();
            let weaponBonus = equipStats.damage;

            // Fallback: Check inventory for weapons if nothing equipped
            if (weaponBonus === 0) {
                const weapons = ['Legendary Blade', 'Void Dagger', 'Magma Sword', 'Frost Blade', 'Sword'];
                for (const weapon of weapons) {
                    if (hasItem(weapon)) {
                        weaponBonus = Math.max(weaponBonus, ITEMS[weapon].combatBonus || 0);
                        break;
                    }
                }
            }

            // Skill bonus: +1 damage every 3 combat levels
            const skillBonus = Math.floor(gameData.skills.combat.level / 3);

            let totalDamage = baseDamage + weaponBonus + skillBonus;

            // v5.1: Apply equipment crit chance
            if (equipStats.critChance > 0 && Math.random() < equipStats.critChance) {
                totalDamage = Math.floor(totalDamage * 2);
                if (worldState.player) {
                    spawnFloater(worldState.player.position, 'âš¡ CRIT!', '#ffaa00');
                }
            }

            // v4.6: Apply crit multiplier if in parry crit window
            if (isInCritWindow()) {
                totalDamage = Math.floor(totalDamage * PARRY_CONFIG.CRIT_MULTIPLIER);
            }

            // v4.8: Apply combo multiplier
            const comboMult = getComboMultiplier();
            if (comboMult > 1) {
                totalDamage = Math.floor(totalDamage * comboMult);
            }

            // v4.8: Apply War Cry damage boost
            if (isWarcryActive()) {
                totalDamage = Math.floor(totalDamage * COMBAT_ABILITIES.warcry.damageBoost);
            }

            // v4.9: Apply Berserker Rage damage boost
            if (isBerserkActive()) {
                totalDamage = Math.floor(totalDamage * COMBAT_ABILITIES.berserk.damageBoost);
            }

            // v5.0: Apply pet damage bonus
            const petBonuses = getPetBonuses();
            if (petBonuses.damage > 0) {
                totalDamage = Math.floor(totalDamage * (1 + petBonuses.damage));
            }
            if (petBonuses.allStats > 0) {
                totalDamage = Math.floor(totalDamage * (1 + petBonuses.allStats));
            }

            // v5.2: Apply talent bonuses
            const talentBonuses = getTalentBonuses();
            if (talentBonuses.damage > 0) {
                totalDamage = Math.floor(totalDamage * (1 + talentBonuses.damage));
            }
            // v5.2: Apply talent crit chance
            if (talentBonuses.critChance > 0 && Math.random() < talentBonuses.critChance) {
                totalDamage = Math.floor(totalDamage * 2);
                if (worldState.player) {
                    spawnFloater(worldState.player.position, 'ðŸŒŸ TALENT CRIT!', '#ffd700');
                }
            }

            // v5.3: Apply mastery combat bonuses
            const masteryBonuses = getMasteryBonuses();
            if (masteryBonuses.combatDamage > 0) {
                totalDamage = Math.floor(totalDamage * (1 + masteryBonuses.combatDamage));
            }
            if (masteryBonuses.combatCrit > 0 && Math.random() < masteryBonuses.combatCrit) {
                totalDamage = Math.floor(totalDamage * 2);
                if (worldState.player) {
                    spawnFloater(worldState.player.position, 'âœ¨ MASTERY CRIT!', '#ff44ff');
                }
            }

            // v5.3: Apply rarity item bonuses
            const rarityBonuses = getRarityBonuses();
            if (rarityBonuses.damage > 0) {
                totalDamage += rarityBonuses.damage;
            }
            if (rarityBonuses.critChance > 0 && Math.random() < rarityBonuses.critChance) {
                const critMult = 2 + (rarityBonuses.critDamage || 0);
                totalDamage = Math.floor(totalDamage * critMult);
                if (worldState.player) {
                    spawnFloater(worldState.player.position, 'ðŸ’Ž RARITY CRIT!', '#4488ff');
                }
            }

            // v5.4: Apply evolution damage bonus
            const evolutionBonuses = getEvolutionBonuses();
            if (evolutionBonuses.damageBonus > 0) {
                totalDamage = Math.floor(totalDamage * (1 + evolutionBonuses.damageBonus));
            }
            // v5.8: Boss damage bonus is now applied in performAction where isBoss is known

            return totalDamage;
        }

        // v4.2: Calculate skill bonus for gathering (multiplier)
        function getSkillBonus(skillName) {
            const level = gameData.skills[skillName]?.level || 1;
            return 1 + Math.floor(level / 5) * 0.25; // +25% every 5 levels
        }

        // v4.2: Calculate player defense from armor
        function getPlayerDefense() {
            let defense = 0;

            // v5.1: Get defense from equipped gear
            const equipStats = getEquipmentStats();
            defense += equipStats.defense;

            // Fallback: Check inventory for armor if nothing equipped
            if (equipStats.defense === 0 && hasItem('Chitin Armor')) {
                defense += ITEMS['Chitin Armor'].defenseBonus;
            }
            if (equipStats.defense === 0 && hasItem('Guardian Armor')) {
                defense += ITEMS['Guardian Armor'].defenseBonus;
            }

            defense += Math.floor(gameData.skills.combat.level / 5); // +1 defense every 5 combat levels

            // v5.2: Apply talent defense bonus
            const talentBonuses = getTalentBonuses();
            defense += talentBonuses.defense || 0;

            // v5.3: Apply rarity item defense bonus
            const rarityBonuses = getRarityBonuses();
            defense += rarityBonuses.defense || 0;

            return defense;
        }

        function performAction(target) {
            const data = target.userData;

            // v5.4: Handle event item collection
            if (data.type === 'eventItem') {
                collectEventItem(target);
                return;
            }

            // v4.2: Handle POI interactions differently
            if (data.type === 'poi') {
                if (!data.discovered) {
                    data.discovered = true;
                    gameData.statistics.poisDiscovered++;

                    // Mark as discovered for this planet
                    if (!gameData.discoveredPOIs[activeCiv.id]) {
                        gameData.discoveredPOIs[activeCiv.id] = [];
                    }
                    gameData.discoveredPOIs[activeCiv.id].push(data.poiType);

                    // Grant rewards
                    data.rewards.forEach(reward => {
                        const count = Array.isArray(reward.count)
                            ? Math.floor(Math.random() * (reward.count[1] - reward.count[0] + 1)) + reward.count[0]
                            : reward.count;
                        for (let i = 0; i < count; i++) {
                            addItem(reward.item);
                        }
                        spawnFloater(target.position, `+${count} ${reward.item}`, '#ffdd00');
                    });

                    // Grant XP bonus
                    addXp('combat', data.xpBonus);

                    spawnFloater(target.position.clone().add(new THREE.Vector3(0, 2, 0)), `${data.icon} ${data.name} DISCOVERED!`, '#ffdd00');
                    AudioSystem.levelUp();
                    if (particles) particles.emit(target.position, 30, 0xffdd00, { spread: 6, lifetime: 1500, size: 0.3 });

                    // Change POI appearance to show it's been discovered
                    if (data.beacon) data.beacon.material.emissiveIntensity = 0.1;
                    if (data.iconMesh) data.iconMesh.material.opacity = 0.3;

                    checkAchievements();
                    updateDailyChallengeProgress();
                    updatePlayerRank();
                } else {
                    spawnFloater(target.position, "Already discovered", '#888888');
                }
                return;
            }

            // v4.2: Calculate damage based on type
            let damage = 1;
            if (data.type === 'mob' || data.type === 'boss') {
                damage = getPlayerDamage();
                // v5.8: Apply evolution boss damage bonus here where isBoss is known
                const isBoss = data.type === 'boss' || data.isBoss;
                if (isBoss) {
                    const evolutionBonuses = getEvolutionBonuses();
                    if (evolutionBonuses.bossDamage > 0) {
                        damage = Math.floor(damage * (1 + evolutionBonuses.bossDamage));
                    }
                }
            }

            // v4.8: Update combo state on combat hit
            const isCombatHit = data.type === 'mob' || data.type === 'boss';
            let comboHit = 0;
            if (isCombatHit) {
                comboHit = updateCombo(performance.now());
            }

            // v4.6: Show crit feedback if in crit window, v4.8: combo feedback
            const isCrit = isInCritWindow() && isCombatHit;
            const isFinisher = comboHit >= COMBO_CONFIG.MAX_HITS - 1;

            let hitText, hitColor;
            if (isFinisher) {
                hitText = `ðŸ’¥ FINISHER x${comboHit + 1}! -${damage}`;
                hitColor = '#ff00ff';
            } else if (isCrit) {
                hitText = `âš”ï¸ CRIT! -${damage}`;
                hitColor = '#ffd700';
            } else if (comboHit > 0) {
                hitText = `x${comboHit + 1} COMBO! -${damage}`;
                hitColor = '#00ffff';
            } else {
                hitText = damage > 1 ? `HIT! -${damage}` : "HIT!";
                hitColor = undefined;
            }

            spawnFloater(target.position, hitText, hitColor);
            AudioSystem.hit();

            data.hp -= damage;
            gameData.statistics.totalDamageDealt += damage;

            // v5.1: Apply lifesteal from equipment
            const equipStats = getEquipmentStats();
            if (equipStats.lifesteal > 0) {
                const healAmount = Math.floor(damage * equipStats.lifesteal);
                if (healAmount > 0) {
                    gameData.player.hp = Math.min(CONFIG.PLAYER_MAX_HP + equipStats.maxHpBonus, gameData.player.hp + healAmount);
                    spawnFloater(worldState.player.position, `ðŸ’š +${healAmount}`, '#44ff44');
                    updateHealthUI();
                }
            }

            // v4.4: Hit-stop and flash for satisfying combat
            const isBossTarget = data.type === 'boss' || data.isBoss;
            const isMobTarget = data.type === 'mob';
            if (isBossTarget) {
                triggerHitStop(HIT_STOP_BOSS);
                flashTargetHit(target, 0xff4400);
            } else if (isMobTarget) {
                triggerHitStop(HIT_STOP_LIGHT);
                flashTargetHit(target, 0xff0000);
            }

            // v4.6: Apply elemental status effect on hit
            if (isMobTarget || isBossTarget) {
                const element = getEquippedElement();
                if (element) {
                    applyStatusEffect(target, element);
                }
            }

            // Visual feedback
            target.scale.setScalar(0.85);
            setTimeout(() => { if(target.parent) target.scale.setScalar(1); }, 100);

            // v4.0: Hit particles based on type
            if (particles) {
                const particleColor = data.type === 'tree' ? 0x885522 :
                                     data.type === 'rock' ? 0x888888 :
                                     data.type === 'mob' ? (ENEMY_TYPES[data.name]?.color || 0x44ff44) : 0x4488ff;
                particles.emit(target.position, 5, particleColor, { spread: 2, lifetime: 600, size: 0.15 });
            }

            // Update mob health bar
            if (data.type === 'mob' && data.hpBar) {
                const hpPercent = data.hp / data.maxHp;
                data.hpBar.scale.x = Math.max(0.01, hpPercent);
                data.hpBar.material.color.setHex(hpPercent > 0.5 ? 0x00ff00 : hpPercent > 0.25 ? 0xffff00 : 0xff0000);
            }

            if(data.hp <= 0) {
                if(data.type === 'tree') {
                    // v4.2: Apply skill bonus to gathering
                    const toolBonus = hasItem('Crystal Pickaxe') ? 3 : hasItem('Pickaxe') ? 2 : 1;
                    const skillMultiplier = getSkillBonus('wood');
                    const totalYield = Math.floor(toolBonus * skillMultiplier);
                    for (let i = 0; i < totalYield; i++) addItem('Log');
                    addXp('wood', 50);
                    gameData.statistics.treesChopped++;
                    gainPetBond(1); // v5.4: Pet bond from gathering
                    spawnFloater(target.position, `+${totalYield} LOG`, '#da5');
                    AudioSystem.collect();
                    if (particles) particles.emit(target.position, 12, 0xdd9955, { spread: 4, lifetime: 1000 });
                    scene.remove(target);
                    worldState.interactables = worldState.interactables.filter(x => x !== target);
                }
                else if(data.type === 'rock') {
                    // v4.2: Apply skill bonus to gathering
                    const toolBonus = hasItem('Crystal Pickaxe') ? 3 : hasItem('Pickaxe') ? 2 : 1;
                    const skillMultiplier = getSkillBonus('mining');
                    const totalYield = Math.floor(toolBonus * skillMultiplier);
                    for (let i = 0; i < totalYield; i++) addItem('Ore');
                    addXp('mining', 50);
                    gameData.statistics.oresMined++;
                    gainPetBond(1); // v5.4: Pet bond from gathering
                    spawnFloater(target.position, `+${totalYield} ORE`, '#888');
                    AudioSystem.collect();
                    if (particles) particles.emit(target.position, 15, 0x888888, { spread: 3, lifetime: 800 });
                    scene.remove(target);
                    worldState.interactables = worldState.interactables.filter(x => x !== target);
                }
                else if(data.type === 'mob' || data.type === 'boss') {
                    // v4.3: Handle both regular mobs and bosses
                    const isBoss = data.type === 'boss' || data.isBoss;

                    // v4.2/4.3: Drop items from enemy data
                    const drops = data.drops || ['Slime'];
                    // v4.7: Elite enemies drop more items
                    const dropMultiplier = data.isElite ? ELITE_CONFIG.bonusDropMult : 1;

                    drops.forEach(drop => {
                        // Handle boss drop format { item, count }
                        if (typeof drop === 'object') {
                            const count = drop.count * dropMultiplier;
                            for (let i = 0; i < count; i++) addItem(drop.item);
                            spawnFloater(target.position.clone().add(new THREE.Vector3(Math.random(), 1, Math.random())), `+${count} ${drop.item}`, '#ffd700');
                        } else {
                            for (let i = 0; i < dropMultiplier; i++) addItem(drop);
                        }
                    });

                    // v4.7: Elite essence drop
                    if (data.isElite && Math.random() < ELITE_CONFIG.essenceDropChance) {
                        const essenceCount = 1 + Math.floor(Math.random() * 3); // 1-3 essence
                        for (let i = 0; i < essenceCount; i++) addItem('Elite Essence');
                        spawnFloater(target.position.clone().add(new THREE.Vector3(0, 1.5, 0)), `+${essenceCount} Elite Essence`, '#aa00ff');
                    }

                    const xpReward = data.xpReward || 100;
                    addXp('combat', xpReward);

                    // v4.7: Handle explosive affix death
                    if (data.isElite && data.eliteData?.explodeOnDeath) {
                        const explosionDamage = Math.floor(data.damage * 2);
                        const explosionRange = 5;
                        const distToPlayer = target.position.distanceTo(p.position);
                        if (distToPlayer < explosionRange) {
                            damagePlayer(explosionDamage, 'explosion');
                            spawnFloater(p.position, `ðŸ’¥ EXPLOSION! -${explosionDamage}`, '#ff6600');
                        }
                        if (particles) particles.emit(target.position, 40, 0xff6600, { spread: 8, lifetime: 1000, size: 0.4 });
                        screenShake(1.2);
                        AudioSystem.explosion && AudioSystem.explosion();
                    }

                    if (isBoss) {
                        gameData.statistics.bossesDefeated++;
                        // v4.9: Track boss in codex
                        trackCreatureKill('boss');
                        spawnFloater(target.position.clone().add(new THREE.Vector3(0, 2, 0)), `BOSS DEFEATED! +${xpReward}XP`, '#ffd700');
                        showNotification(`${data.name} has been defeated!`, 'success');
                        // v4.4: Extra long hit-stop for boss kill
                        triggerHitStop(HIT_STOP_BOSS * 2);
                        screenShake(1.5);
                        // Extra celebration
                        if (particles) particles.emit(target.position, 50, 0xffd700, { spread: 8, lifetime: 2000, size: 0.4 });

                        // v5.3: Check portal clear on boss kill (portal realms require boss kills)
                        if (gameData.portals?.currentPortal) {
                            const portalMods = getPortalModifiers();
                            if (portalMods?.bossOnly) {
                                exitPortal(true);
                            }
                        }

                        // v5.3: Chance for rarity loot on boss kills
                        if (Math.random() < 0.4) {
                            const rareDrop = drops[0]?.item || drops[0] || 'Boss Trophy';
                            const rarityItem = createRarityItem(rareDrop);
                            if (rarityItem.rarity !== 'common') {
                                if (!gameData.rarityItems) gameData.rarityItems = [];
                                gameData.rarityItems.push(rarityItem);
                                showRarityDropPopup(rarityItem);
                            }
                        }
                    } else {
                        gameData.statistics.mobsKilled++;
                        // v4.9: Track creature in codex
                        if (data.isElite) {
                            trackCreatureKill('elite');
                        } else {
                            trackCreatureKill(data.name?.toLowerCase() || 'unknown');
                        }
                        // v5.0: Try to drop a pet
                        tryDropPet(data.name);
                        // v5.4: Gain pet bond from kills
                        gainPetBond(data.isElite ? 3 : 1);
                        // v4.7: Track elite kills
                        if (data.isElite) {
                            gameData.statistics.elitesKilled = (gameData.statistics.elitesKilled || 0) + 1;
                            spawnFloater(target.position.clone().add(new THREE.Vector3(0, 2, 0)), `${data.eliteData.prefix} ELITE SLAIN! +${xpReward}XP`, '#ffaa00');
                            showNotification(`Elite ${data.name} defeated!`, 'success');
                            triggerHitStop(HIT_STOP_BOSS);

                            // v5.3: Chance for rarity loot on elite kills
                            if (Math.random() < 0.2) {
                                const rareDrop = drops[0] || 'Elite Essence';
                                const rarityItem = createRarityItem(rareDrop);
                                if (rarityItem.rarity !== 'common') {
                                    if (!gameData.rarityItems) gameData.rarityItems = [];
                                    gameData.rarityItems.push(rarityItem);
                                    showRarityDropPopup(rarityItem);
                                }
                            }
                        } else {
                            spawnFloater(target.position, `KILLED! +${xpReward}XP`, '#f00');
                            triggerHitStop(HIT_STOP_HEAVY);
                        }
                        worldMobKillCount++; // v4.3: Track for boss spawning
                        checkBossSpawn(); // v4.3: Check if boss should spawn

                        // v5.3: Track portal kills - elites count more
                        if (gameData.portals?.currentPortal) {
                            const portalMods = getPortalModifiers();
                            // Portals without bossOnly can be cleared by killing enough enemies
                            if (!portalMods?.bossOnly && data.isElite) {
                                if (!gameData.portals.killProgress) gameData.portals.killProgress = 0;
                                gameData.portals.killProgress += 5; // Elite = 5 kills
                                if (gameData.portals.killProgress >= 25) { // Need 25 points (5 elites or 25 mobs)
                                    exitPortal(true);
                                }
                            } else if (!portalMods?.bossOnly) {
                                if (!gameData.portals.killProgress) gameData.portals.killProgress = 0;
                                gameData.portals.killProgress += 1;
                                if (gameData.portals.killProgress >= 25) {
                                    exitPortal(true);
                                }
                            }
                        }
                    }

                    AudioSystem.kill();
                    const mobColor = data.isElite ? (data.eliteData?.color || 0xffaa00) :
                                    isBoss ? (BOSS_TYPES[data.bossId]?.color || 0xffd700) :
                                    (ENEMY_TYPES[data.name]?.color || 0x44ff44);
                    if (particles && !isBoss) particles.emit(target.position, data.isElite ? 30 : 20, mobColor, { spread: data.isElite ? 7 : 5, lifetime: 1200, size: data.isElite ? 0.35 : 0.25 });
                    scene.remove(target);
                    worldState.mobs = worldState.mobs.filter(x => x !== target);
                }
                else if(data.type === 'fishing') {
                    if (hasItem('Fishing Rod')) {
                        // v4.2: Skill bonus for fishing
                        const skillMultiplier = getSkillBonus('fishing');
                        const fishCount = Math.floor(1 * skillMultiplier);
                        for (let i = 0; i < fishCount; i++) addItem('Raw Fish');
                        addXp('fishing', 40);
                        gameData.statistics.fishCaught += fishCount;
                        gainPetBond(1); // v5.4: Pet bond from fishing
                        spawnFloater(target.position, `+${fishCount} FISH`, '#44f');
                        AudioSystem.collect();
                        if (particles) particles.emit(target.position, 8, 0x4488ff, { spread: 2, lifetime: 800, gravity: 5 });
                    } else {
                        spawnFloater(target.position, "Need Rod!", '#f44');
                        AudioSystem.error();
                    }
                    data.hp = data.maxHp = 1;
                    return;
                }
                worldState.interactTarget = null;

                checkAchievements();
                updateDailyChallengeProgress();
                updatePlayerRank();
            }
        }

        function damagePlayer(amount) {
            // v4.5: Check for dodge i-frames
            if (isInvincible()) {
                spawnFloater(worldState.player.position, 'DODGE!', '#88ffff');
                return;
            }

            // v4.8: Break combo on taking damage
            if (COMBO_CONFIG.BREAK_ON_DAMAGE && comboState.active) {
                breakCombo();
            }

            // v4.9: Apply Shield Wall damage reduction
            let reducedAmount = amount;
            if (isShieldWallActive()) {
                reducedAmount = Math.floor(amount * (1 - COMBAT_ABILITIES.shieldWall.damageReduction));
                if (worldState.player) {
                    spawnFloater(worldState.player.position, `ðŸ›¡ï¸ BLOCKED!`, '#4488ff');
                }
            }

            // v5.4: Apply evolution damage reduction and phase shift
            const evolutionBonuses = getEvolutionBonuses();
            if (evolutionBonuses.damageReduction > 0) {
                reducedAmount = Math.floor(reducedAmount * (1 - evolutionBonuses.damageReduction));
            }
            if (evolutionBonuses.phaseShift > 0 && Math.random() < evolutionBonuses.phaseShift) {
                reducedAmount = Math.floor(reducedAmount * 0.5);
                if (worldState.player) {
                    spawnFloater(worldState.player.position, 'ðŸŒ€ PHASED!', '#4400ff');
                }
            }

            // v4.2: Apply defense reduction
            const defense = getPlayerDefense();
            const actualDamage = Math.max(1, reducedAmount - defense);
            gameData.player.hp = Math.max(0, gameData.player.hp - actualDamage);
            updateHealthUI();

            // v4.0: Enhanced damage feedback
            AudioSystem.damage();
            screenShake(amount * 0.1);
            flashDamageOverlay();

            if (gameData.player.hp <= 0) {
                playerDeath();
            }
        }

        function healPlayer(amount) {
            gameData.player.hp = Math.min(gameData.player.maxHp, gameData.player.hp + amount);
            updateHealthUI();
            spawnFloater(worldState.player.position, `+${amount} HP`, '#44ff44');
            AudioSystem.heal(); // v4.0
        }

        function playerDeath() {
            showNotification('You died! Respawning...', 'error');
            gameData.player.hp = gameData.player.maxHp;
            worldState.player.position.set(0, 10, 0);
            worldState.target = null;
            worldState.interactTarget = null;
            updateHealthUI();
        }

        function spawnFloater(pos, text, color='#fff') {
            // Use pool
            let floater = floaterPool.find(f => !f.active);
            if (!floater) {
                floater = floaterPool[0]; // Reuse oldest
            }

            floater.active = true;
            floater.el.textContent = text;
            floater.el.style.color = color;
            floater.el.style.display = 'block';
            floater.el.style.animation = 'none';
            floater.el.offsetHeight; // Trigger reflow
            floater.el.style.animation = 'floatUp 1.5s forwards';

            const v = pos.clone();
            v.y += 2;
            v.project(camera);

            const x = (v.x * .5 + .5) * window.innerWidth;
            const y = (-(v.y * .5) + .5) * window.innerHeight;

            floater.el.style.left = x + 'px';
            floater.el.style.top = y + 'px';

            setTimeout(() => {
                floater.el.style.display = 'none';
                floater.active = false;
            }, 1400);
        }

        // --- INPUT HANDLERS ---
        function onMouseMove(e) {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            const tooltip = document.getElementById('tooltip');

            if(mode === 'galaxy') {
                const intersects = raycaster.intersectObjects(galaxyGroup.children, true);
                if(intersects.length > 0) {
                    let obj = intersects[0].object;
                    while(obj.parent && obj.parent !== galaxyGroup) obj = obj.parent;

                    if(obj.userData.type === 'civ') {
                        const civ = obj.userData.data;
                        tooltip.style.display = 'block';
                        tooltip.style.left = e.clientX + 10 + 'px';
                        tooltip.style.top = e.clientY + 10 + 'px';
                        tooltip.innerHTML = `<strong>${civ.name}</strong><br>Biome: ${civ.biomeName}<br>Pop: ${civ.pop}M${civ.visited ? '<br><span style="color:#0f0">Visited</span>' : ''}<br><span style="color:#888">ðŸš€ Click to Begin Landing Sequence</span>`;
                        document.body.style.cursor = 'pointer';

                        selectionRing.visible = true;
                        selectionRing.position.copy(obj.position);
                        return;
                    }
                }
            } else if (mode === 'world') {
                // v5.6: Check for Copilot Companion hover
                if (copilotMesh) {
                    const copilotHits = raycaster.intersectObject(copilotMesh, true);
                    if (copilotHits.length > 0) {
                        const copilotTooltip = document.getElementById('copilot-3d-tooltip');
                        if (copilotTooltip) {
                            copilotTooltip.style.display = 'block';
                            copilotTooltip.style.left = e.clientX + 15 + 'px';
                            copilotTooltip.style.top = e.clientY - 30 + 'px';
                        }
                        document.body.style.cursor = 'pointer';
                        return;
                    } else {
                        const copilotTooltip = document.getElementById('copilot-3d-tooltip');
                        if (copilotTooltip) copilotTooltip.style.display = 'none';
                    }
                }

                const hits = raycaster.intersectObjects([...worldState.interactables, ...worldState.mobs], true);
                if(hits.length > 0) {
                    let obj = hits[0].object;
                    while(obj.parent && obj.parent.type !== 'Scene') obj = obj.parent;

                    if(obj.userData.name) {
                        tooltip.style.display = 'block';
                        tooltip.style.left = e.clientX + 10 + 'px';
                        tooltip.style.top = e.clientY + 10 + 'px';
                        const hpText = obj.userData.hp !== undefined ? `<br>HP: ${obj.userData.hp}/${obj.userData.maxHp}` : '';
                        tooltip.innerHTML = `<strong>${obj.userData.name}</strong>${hpText}<br><span style="color:#888">Click to Interact</span>`;
                        document.body.style.cursor = 'pointer';
                        return;
                    }
                }
            }

            tooltip.style.display = 'none';
            document.body.style.cursor = 'default';
            if(mode === 'galaxy') selectionRing.visible = false;
        }

        function onMouseDown(e) {
            raycaster.setFromCamera(mouse, camera);

            // v5.6: Check for Copilot Companion click first
            if (checkCopilotClick(e)) {
                return; // Copilot was clicked, don't process other clicks
            }

            if(mode === 'galaxy') {
                const intersects = raycaster.intersectObjects(galaxyGroup.children, true);
                if(intersects.length > 0) {
                    let obj = intersects[0].object;
                    while(obj.parent && obj.parent !== galaxyGroup) obj = obj.parent;
                    if(obj.userData.type === 'civ') {
                        // v5.5: Landing mini-game before entering world
                        startLandingGame(obj.userData.data);
                    }
                }
            }
            else if(mode === 'world') {
                const hits = raycaster.intersectObjects([...worldState.interactables, ...worldState.mobs], true);
                if(hits.length > 0) {
                    let obj = hits[0].object;
                    while(obj.parent && obj.parent.type !== 'Scene') obj = obj.parent;
                    worldState.interactTarget = obj;
                    spawnFloater(obj.position, "Targeting...", '#0ff');
                    return;
                }

                const groundHits = raycaster.intersectObjects(scene.children, true);
                if(groundHits.length > 0) {
                    const pt = groundHits[0].point;
                    worldState.target = pt;
                    worldState.interactTarget = null;

                    const m = new THREE.Mesh(
                        new THREE.RingGeometry(0.4, 0.5, 16),
                        new THREE.MeshBasicMaterial({ color: 0xffff00, side: THREE.DoubleSide })
                    );
                    m.rotation.x = -Math.PI/2;
                    m.position.copy(pt);
                    m.position.y += 0.2;
                    scene.add(m);
                    setTimeout(() => scene.remove(m), 400);
                }
            }
        }

        // Touch handlers
        let touchStartPos = null;

        // v4.3: Virtual Joystick state
        let joystickActive = false;
        let joystickCenter = { x: 0, y: 0 };
        let joystickInput = { x: 0, y: 0 };
        const joystickMaxDist = 40;

        function onTouchStart(e) {
            e.preventDefault();
            if (e.touches.length === 1) {
                touchStartPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                mouse.x = (e.touches[0].clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.touches[0].clientY / window.innerHeight) * 2 + 1;
            }
        }

        function onTouchMove(e) {
            e.preventDefault();
            if (e.touches.length === 1) {
                mouse.x = (e.touches[0].clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.touches[0].clientY / window.innerHeight) * 2 + 1;
            }
        }

        function onTouchEnd(e) {
            e.preventDefault();
            if (touchStartPos) {
                raycaster.setFromCamera(mouse, camera);
                onMouseDown({ clientX: touchStartPos.x, clientY: touchStartPos.y });
                touchStartPos = null;
            }
        }

        function onTouchAction() {
            // Quick action button - interact with nearest target
            if (mode === 'world' && worldState.interactTarget) {
                performAction(worldState.interactTarget);
            }
        }

        function onKeyDown(e) {
            // v5.8: Skip keyboard handling when typing in input fields
            const activeElement = document.activeElement;
            if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA' || activeElement.isContentEditable)) {
                return; // Don't capture keys when user is typing
            }

            // v5.5: Landing mini-game controls
            if (landingGame.active) {
                handleLandingKeyDown(e);
                return;
            }

            // WASD movement
            const key = e.key.toLowerCase();
            if (key in keys) {
                keys[key] = true;
                e.preventDefault();
            }

            // Number keys 1-9 to use inventory items
            if (mode === 'world' && e.key >= '1' && e.key <= '9') {
                const idx = parseInt(e.key) - 1;
                useInventoryItem(idx);
            }
            // E to eat food
            if (e.key === 'e' || e.key === 'E') {
                const foodIdx = gameData.inventory.findIndex(item =>
                    item && (item.name === 'Cooked Fish' || item.name === 'Health Potion')
                );
                if (foodIdx >= 0) useInventoryItem(foodIdx);
            }
            // H for help/tutorial
            if (e.key === 'h' || e.key === 'H') {
                showTutorial();
            }
            // v5.5: M to toggle autopilot exploration
            if ((e.key === 'm' || e.key === 'M') && mode === 'world') {
                toggleAutoExplore();
            }
            // v4.5: Space or Shift to dodge
            if (e.key === ' ' || e.key === 'Shift') {
                if (mode === 'world') {
                    startDodge();
                    e.preventDefault();
                }
            }
            // v4.8: Combat abilities Q/E/R (v4.9: Extended with Tier 2 T/F/Z/X/C)
            if (mode === 'world') {
                if (e.key === 'q' || e.key === 'Q') {
                    useAbility('powerStrike');
                    e.preventDefault();
                }
                if (e.key === 'e' || e.key === 'E') {
                    // E is now abilities, but keep food eating as fallback if no ability ready
                    if (!useAbility('whirlwind')) {
                        const foodIdx = gameData.inventory.findIndex(item =>
                            item && (item.name === 'Cooked Fish' || item.name === 'Health Potion' || item.name === 'Super Potion')
                        );
                        if (foodIdx >= 0) useInventoryItem(foodIdx);
                    }
                    e.preventDefault();
                }
                if (e.key === 'r' || e.key === 'R') {
                    useAbility('warcry');
                    e.preventDefault();
                }
                // v4.9: Tier 2 Abilities
                if (e.key === 't' || e.key === 'T') {
                    useAbility('heal');
                    e.preventDefault();
                }
                if (e.key === 'f' || e.key === 'F') {
                    useAbility('dash');
                    e.preventDefault();
                }
                if (e.key === 'z' || e.key === 'Z') {
                    useAbility('shieldWall');
                    e.preventDefault();
                }
                if (e.key === 'x' || e.key === 'X') {
                    useAbility('execute');
                    e.preventDefault();
                }
                if (e.key === 'c' || e.key === 'C') {
                    useAbility('berserk');
                    e.preventDefault();
                }
            }
        }

        function onKeyUp(e) {
            // v5.8: Skip keyboard handling when typing in input fields
            const activeElement = document.activeElement;
            if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA' || activeElement.isContentEditable)) {
                return; // Don't capture keys when user is typing
            }

            // v5.5: Landing mini-game controls
            if (landingGame.active) {
                handleLandingKeyUp(e);
                return;
            }

            const key = e.key.toLowerCase();
            if (key in keys) {
                keys[key] = false;
            }
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function returnToGalaxy() {
            saveGameData();
            initGalaxy();
            activeCiv = null;
        }

        // --- INVENTORY & RPG ---
        function addItem(name) {
            const itemDef = ITEMS[name];
            if (!itemDef) return false;

            // v4.9: Track item in codex
            trackItemDiscovery(name);

            // Find existing stack
            if (itemDef.stackable) {
                const existing = gameData.inventory.find(item =>
                    item && item.name === name && item.count < (itemDef.maxStack || 99)
                );
                if (existing) {
                    existing.count++;
                    updateInventoryUI();
                    return true;
                }
            }

            // Add new slot
            if (gameData.inventory.length < 20) {
                gameData.inventory.push({ name, count: 1 });
                updateInventoryUI();
                return true;
            }

            spawnFloater(worldState.player.position, "Inventory full!", '#f44');
            return false;
        }

        function removeItem(name, count = 1) {
            for (let i = 0; i < gameData.inventory.length; i++) {
                const item = gameData.inventory[i];
                if (item && item.name === name) {
                    item.count -= count;
                    if (item.count <= 0) {
                        gameData.inventory.splice(i, 1);
                    }
                    updateInventoryUI();
                    return true;
                }
            }
            return false;
        }

        function hasItem(name, count = 1) {
            const item = gameData.inventory.find(i => i && i.name === name);
            return item && item.count >= count;
        }

        function countItem(name) {
            const item = gameData.inventory.find(i => i && i.name === name);
            return item ? item.count : 0;
        }

        function useInventoryItem(idx) {
            const item = gameData.inventory[idx];
            if (!item) return;

            const def = ITEMS[item.name];

            // v5.1: Check if item is equippable
            if (isEquippable(item.name)) {
                equipItem(item.name);
                updateInventoryUI();
                return;
            }

            // Use consumables
            if (def && def.heal) {
                if (gameData.player.hp < gameData.player.maxHp) {
                    healPlayer(def.heal);
                    removeItem(item.name, 1);
                } else {
                    showNotification('Health is already full!');
                }
            }
        }

        function updateInventoryUI() {
            const grid = document.getElementById('inventory-grid');
            grid.innerHTML = '';

            gameData.inventory.forEach((item, idx) => {
                if (!item) return;
                const def = ITEMS[item.name] || { icon: '?' };
                const slot = document.createElement('div');
                slot.className = 'inv-slot';

                // v4.8: Build detailed tooltip
                const tooltip = buildItemTooltip(item.name, def, item.count);
                slot.title = tooltip;

                slot.innerHTML = `${def.icon}<div class="inv-count">${item.count}</div>`;
                slot.onclick = () => useInventoryItem(idx);
                grid.appendChild(slot);
            });

            // Fill empty slots
            for (let i = gameData.inventory.length; i < 20; i++) {
                const slot = document.createElement('div');
                slot.className = 'inv-slot';
                grid.appendChild(slot);
            }

            document.getElementById('inv-count').textContent = gameData.inventory.length;
        }

        // v4.8: Build detailed item tooltip
        function buildItemTooltip(name, def, count) {
            let lines = [name];

            // Add quantity for stackable items
            if (def.stackable && count > 1) {
                lines[0] += ` (x${count})`;
            }

            // Healing items
            if (def.heal) {
                lines.push(`Heals ${def.heal} HP`);
                lines.push('Click or press E to use');
            }

            // Combat bonuses
            if (def.combatBonus) {
                lines.push(`Combat: +${def.combatBonus} damage`);
            }

            // Defense
            if (def.defenseBonus) {
                lines.push(`Defense: +${def.defenseBonus}`);
            }

            // Mining/Tool bonuses
            if (def.miningBonus) {
                lines.push(`Mining: x${def.miningBonus} yield`);
            }
            if (def.fishingBonus) {
                lines.push(`Fishing: x${def.fishingBonus} yield`);
            }

            // Elemental
            if (def.element) {
                const elementNames = { ice: 'Ice (Slow)', fire: 'Fire (Burn)', void: 'Void (Weaken)', cosmic: 'Cosmic (All)' };
                lines.push(`Element: ${elementNames[def.element] || def.element}`);
            }

            // Lifesteal
            if (def.lifesteal) {
                lines.push(`Lifesteal: ${Math.floor(def.lifesteal * 100)}%`);
            }

            // Attack speed
            if (def.attackSpeedMult) {
                lines.push(`Attack Speed: +${Math.floor((def.attackSpeedMult - 1) * 100)}%`);
            }

            // Max stack info for materials
            if (def.stackable && def.maxStack) {
                lines.push(`Max Stack: ${def.maxStack}`);
            }

            return lines.join('\\n');
        }

        function addXp(skill, amt) {
            if (!gameData.skills[skill]) return;

            // v4.4: Apply prestige XP multiplier
            let multiplier = gameData.prestige?.bonuses?.xpMultiplier || 1.0;

            // v5.3: Apply portal XP multiplier
            multiplier *= getPortalXpMultiplier();

            // v5.3: Apply mastery XP bonus
            const masteryBonuses = getMasteryBonuses();
            // v5.3: Apply talent XP bonus
            const talentBonuses = getTalentBonuses();
            multiplier *= (1 + (talentBonuses.xpBonus || 0));

            // v5.3: Apply rarity item XP bonus
            const rarityBonuses = getRarityBonuses();
            multiplier *= (1 + (rarityBonuses.xpBonus || 0));

            // v5.4: Apply showcase milestone XP bonus
            const showcaseBonuses = getShowcaseBonuses();
            multiplier *= (1 + (showcaseBonuses.xpBonus || 0) + (showcaseBonuses.allBonus || 0));

            // v5.4: Apply world event XP bonus
            const eventBonuses = getWorldEventBonuses();
            multiplier *= (eventBonuses.xpMultiplier || 1);

            // v5.4: Apply evolution XP bonus
            const evolutionBonuses = getEvolutionBonuses();
            multiplier *= (1 + (evolutionBonuses.xpBonus || 0));

            const adjustedAmt = Math.round(amt * multiplier);

            const oldLevel = gameData.skills[skill].level;
            gameData.skills[skill].xp += adjustedAmt;

            // Check level up
            const newLevel = Math.floor(Math.sqrt(gameData.skills[skill].xp / 100)) + 1;
            gameData.skills[skill].level = newLevel;

            if (newLevel > oldLevel) {
                showNotification(`${skill.charAt(0).toUpperCase() + skill.slice(1)} leveled up to ${newLevel}!`);
                AudioSystem.levelUp(); // v4.0
                if (worldState.player) {
                    spawnFloater(worldState.player.position, `LEVEL UP!`, '#ffff00');
                    // v4.0: Level up particle burst
                    if (particles) particles.emit(worldState.player.position, 25, 0xffff00, { spread: 6, lifetime: 1500, gravity: 3 });
                }
            }

            updateSkillsUI();
        }

        function updateSkillsUI() {
            const skills = ['mining', 'wood', 'combat', 'fishing', 'cooking', 'crafting'];

            skills.forEach(skill => {
                const data = gameData.skills[skill];
                if (!data) return;

                const level = data.level;
                const xp = data.xp;
                const nextLevelXp = Math.pow(level, 2) * 100;
                const prevLevelXp = Math.pow(level - 1, 2) * 100;
                const progress = ((xp - prevLevelXp) / (nextLevelXp - prevLevelXp)) * 100;

                const lvlEl = document.getElementById(`lvl-${skill}`);
                const barEl = document.getElementById(`bar-${skill}`);

                if (lvlEl) lvlEl.textContent = level;
                if (barEl) barEl.style.width = Math.min(100, progress) + '%';
            });

            // v5.2: Update talent points button
            const talentBtn = document.getElementById('talent-points-btn');
            if (talentBtn) {
                const points = getTalentPoints();
                talentBtn.textContent = points.available;
                talentBtn.parentElement.style.borderColor = points.available > 0 ? '#ff0' : '#ffd700';
                talentBtn.parentElement.style.animation = points.available > 0 ? 'ability-ready-pulse 2s infinite' : 'none';
            }
        }

        function updateHealthUI() {
            const hp = gameData.player.hp;
            const maxHp = gameData.player.maxHp;
            const percent = (hp / maxHp) * 100;

            document.getElementById('player-health-fill').style.width = percent + '%';
            document.getElementById('health-text').textContent = `${Math.round(hp)} / ${maxHp}`;
        }

        // v4.8: Update ability UI cooldowns and states (v4.9: Extended with Tier 2)
        function updateAbilityUI() {
            const abilities = [
                // Tier 1
                { key: 'q', id: 'powerStrike', slot: 'ability-q', cooldown: 'cooldown-q' },
                { key: 'e', id: 'whirlwind', slot: 'ability-e', cooldown: 'cooldown-e' },
                { key: 'r', id: 'warcry', slot: 'ability-r', cooldown: 'cooldown-r' },
                // v4.9: Tier 2
                { key: 't', id: 'heal', slot: 'ability-t', cooldown: 'cooldown-t' },
                { key: 'f', id: 'dash', slot: 'ability-f', cooldown: 'cooldown-f' },
                { key: 'z', id: 'shieldWall', slot: 'ability-z', cooldown: 'cooldown-z' },
                { key: 'x', id: 'execute', slot: 'ability-x', cooldown: 'cooldown-x' },
                { key: 'c', id: 'berserk', slot: 'ability-c', cooldown: 'cooldown-c' }
            ];

            abilities.forEach(({ key, id, slot, cooldown }) => {
                const slotEl = document.getElementById(slot);
                const cdEl = document.getElementById(cooldown);
                const ability = COMBAT_ABILITIES[id];

                if (!slotEl || !cdEl) return;

                // Check if unlocked
                const unlocked = isAbilityUnlocked(id);
                slotEl.classList.toggle('locked', !unlocked);

                // Check cooldown
                const cdRemaining = getAbilityCooldownRemaining(id);
                const onCooldown = cdRemaining > 0;
                slotEl.classList.toggle('on-cooldown', onCooldown);

                // Show cooldown overlay
                if (onCooldown) {
                    const cdPercent = (cdRemaining / ability.cooldown) * 100;
                    cdEl.style.height = cdPercent + '%';
                } else {
                    cdEl.style.height = '0%';
                }

                // Special: Buff active states
                if (id === 'warcry' && isWarcryActive()) {
                    slotEl.classList.add('active-buff');
                } else if (id === 'warcry') {
                    slotEl.classList.remove('active-buff');
                }
                // v4.9: Shield Wall active state
                if (id === 'shieldWall' && isShieldWallActive()) {
                    slotEl.classList.add('active-buff');
                    slotEl.style.borderColor = '#4488ff';
                    slotEl.style.boxShadow = '0 0 10px #4488ff';
                } else if (id === 'shieldWall') {
                    slotEl.classList.remove('active-buff');
                    slotEl.style.borderColor = '';
                    slotEl.style.boxShadow = '';
                }
                // v4.9: Berserk active state
                if (id === 'berserk' && isBerserkActive()) {
                    slotEl.classList.add('active-buff');
                    slotEl.style.borderColor = '#ff4400';
                    slotEl.style.boxShadow = '0 0 15px #ff4400';
                } else if (id === 'berserk') {
                    slotEl.classList.remove('active-buff');
                    slotEl.style.borderColor = '';
                    slotEl.style.boxShadow = '';
                }
            });

            // v4.9: Update buff overlays
            const berserkOverlay = document.getElementById('berserk-overlay');
            const shieldOverlay = document.getElementById('shield-overlay');
            if (berserkOverlay) {
                berserkOverlay.style.opacity = isBerserkActive() ? '1' : '0';
            }
            if (shieldOverlay) {
                shieldOverlay.style.opacity = isShieldWallActive() ? '1' : '0';
            }
        }

        function updatePlaytimeDisplay() {
            const total = Math.floor(gameData.playtime);
            const hours = Math.floor(total / 3600);
            const mins = Math.floor((total % 3600) / 60);
            document.getElementById('total-playtime').textContent = `${hours}:${mins.toString().padStart(2, '0')}`;
        }

        // --- CRAFTING ---
        function craft(recipeId) {
            const recipe = RECIPES[recipeId];
            if (!recipe) return;

            // v4.2: Check crafting level requirement
            if (recipe.craftingLevel && gameData.skills.crafting.level < recipe.craftingLevel) {
                showNotification(`Requires Crafting level ${recipe.craftingLevel}!`, 'error');
                AudioSystem.error();
                return;
            }

            // Check requirements
            for (const [item, count] of Object.entries(recipe.requires)) {
                if (!hasItem(item, count)) {
                    showNotification(`Need ${count}x ${item}!`, 'error');
                    AudioSystem.error(); // v4.0
                    return;
                }
            }

            // Consume materials
            for (const [item, count] of Object.entries(recipe.requires)) {
                removeItem(item, count);
            }

            // Add result
            addItem(recipe.result);
            addXp('crafting', 30);
            if (recipeId === 'cookedFish') {
                addXp('cooking', 25);
                gameData.statistics.fishCooked = (gameData.statistics.fishCooked || 0) + 1;
            }
            gameData.statistics.itemsCrafted++;

            // v4.1: Check achievements and daily progress
            checkAchievements();
            updateDailyChallengeProgress();

            showNotification(`Crafted ${recipe.result}!`);
            AudioSystem.craft(); // v4.0
            updateCraftingUI();
        }

        // v4.2: Enhanced crafting UI with level requirements and new recipes
        function updateCraftingUI() {
            const recipeDisplayNames = {
                'pickaxe': 'Pickaxe',
                'sword': 'Sword',
                'rod': 'Fishing Rod',
                'cookedFish': 'Cooked Fish',
                'potion': 'Health Potion',
                'frostBlade': 'Frost Blade',
                'magmaSword': 'Magma Sword',
                'voidDagger': 'Void Dagger',
                'crystalPickaxe': 'Crystal Pickaxe',
                'superPotion': 'Super Potion',
                'chitinArmor': 'Chitin Armor'
            };

            for (const [id, recipe] of Object.entries(RECIPES)) {
                const btn = document.getElementById(`craft-${id}`);
                if (!btn) continue;

                let canCraft = true;
                let reqParts = [];

                // v4.2: Check level requirement
                if (recipe.craftingLevel && gameData.skills.crafting.level < recipe.craftingLevel) {
                    canCraft = false;
                    reqParts.push(`Lvl ${recipe.craftingLevel} req`);
                }

                for (const [item, count] of Object.entries(recipe.requires)) {
                    const have = countItem(item);
                    if (have < count) canCraft = false;
                    reqParts.push(`${have}/${count} ${item}`);
                }
                btn.disabled = !canCraft;
                btn.innerHTML = `${recipeDisplayNames[id] || recipe.result}<br><small style="opacity:0.7">${reqParts.join(', ')}</small>`;
            }
        }

        // --- MINIMAP ---
        let minimapCtx;

        function initMinimap() {
            const canvas = document.getElementById('minimap-canvas');
            canvas.width = 100;
            canvas.height = 100;
            minimapCtx = canvas.getContext('2d');
        }

        // v4.4: Update fog of war exploration
        function updateExploration() {
            if (!worldState.player || !activeCiv) return;

            const planetId = activeCiv.id;
            if (!gameData.exploredTiles[planetId]) {
                gameData.exploredTiles[planetId] = {};
            }

            // Mark tiles within vision radius as explored
            const px = Math.floor(worldState.player.position.x / 10);
            const pz = Math.floor(worldState.player.position.z / 10);
            const visionRadius = 3;

            for (let dx = -visionRadius; dx <= visionRadius; dx++) {
                for (let dz = -visionRadius; dz <= visionRadius; dz++) {
                    if (dx * dx + dz * dz <= visionRadius * visionRadius) {
                        const key = `${px + dx},${pz + dz}`;
                        gameData.exploredTiles[planetId][key] = 1;
                    }
                }
            }
        }

        function isTileExplored(planetId, worldX, worldZ) {
            const tx = Math.floor(worldX / 10);
            const tz = Math.floor(worldZ / 10);
            const key = `${tx},${tz}`;
            return gameData.exploredTiles[planetId]?.[key] === 1;
        }

        function updateMinimap() {
            if (!minimapCtx || !worldState.player) return;

            // v4.4: Update exploration tracking
            updateExploration();

            const ctx = minimapCtx;
            const size = 100;
            const scale = size / (CONFIG.WORLD_SIZE * 2);
            const planetId = activeCiv?.id;

            // Clear with fog of war (darker)
            ctx.fillStyle = '#050505';
            ctx.fillRect(0, 0, size, size);

            // v4.4: Draw explored areas lighter
            if (planetId && gameData.exploredTiles[planetId]) {
                ctx.fillStyle = '#181818';
                for (const key in gameData.exploredTiles[planetId]) {
                    const [tx, tz] = key.split(',').map(Number);
                    const x = (tx * 10 + CONFIG.WORLD_SIZE) * scale;
                    const y = (tz * 10 + CONFIG.WORLD_SIZE) * scale;
                    ctx.fillRect(x - 5 * scale, y - 5 * scale, 10 * scale, 10 * scale);
                }
            }

            // Draw terrain bounds
            ctx.strokeStyle = '#333';
            ctx.strokeRect(0, 0, size, size);

            // Draw interactables (only in explored areas)
            ctx.fillStyle = '#0a0';
            worldState.interactables.forEach(obj => {
                if (obj.userData.type === 'tree') {
                    const x = (obj.position.x + CONFIG.WORLD_SIZE) * scale;
                    const y = (obj.position.z + CONFIG.WORLD_SIZE) * scale;
                    ctx.fillRect(x - 1, y - 1, 2, 2);
                }
            });

            ctx.fillStyle = '#888';
            worldState.interactables.forEach(obj => {
                if (obj.userData.type === 'rock') {
                    const x = (obj.position.x + CONFIG.WORLD_SIZE) * scale;
                    const y = (obj.position.z + CONFIG.WORLD_SIZE) * scale;
                    ctx.fillRect(x - 1, y - 1, 2, 2);
                }
            });

            // Draw mobs
            ctx.fillStyle = '#f00';
            worldState.mobs.forEach(mob => {
                const x = (mob.position.x + CONFIG.WORLD_SIZE) * scale;
                const y = (mob.position.z + CONFIG.WORLD_SIZE) * scale;
                ctx.beginPath();
                ctx.arc(x, y, 2, 0, Math.PI * 2);
                ctx.fill();
            });

            // v4.2: Draw POIs
            worldState.pois.forEach(poi => {
                const x = (poi.position.x + CONFIG.WORLD_SIZE) * scale;
                const y = (poi.position.z + CONFIG.WORLD_SIZE) * scale;
                ctx.fillStyle = poi.userData.discovered ? '#666' : '#ffd700';
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fill();
                if (!poi.userData.discovered) {
                    ctx.strokeStyle = '#ffa500';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            });

            // Draw player
            ctx.fillStyle = '#ff0';
            const px = (worldState.player.position.x + CONFIG.WORLD_SIZE) * scale;
            const py = (worldState.player.position.z + CONFIG.WORLD_SIZE) * scale;
            ctx.beginPath();
            ctx.arc(px, py, 3, 0, Math.PI * 2);
            ctx.fill();
        }

        // Start
        init();
    </script>
</body>
</html>
