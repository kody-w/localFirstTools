<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cellular Automata City Planner</title>
    <style>
        /* ========== CSS Reset & Base Styles ========== */
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --bg-primary: #0a0a0f;
            --bg-secondary: #12121a;
            --bg-tertiary: #1a1a25;
            --text-primary: #e8e8f0;
            --text-secondary: #a0a0b0;
            --accent: #6366f1;
            --accent-glow: rgba(99, 102, 241, 0.4);

            /* Zone colors */
            --zone-empty: #1a1a25;
            --zone-residential: #22c55e;
            --zone-commercial: #3b82f6;
            --zone-industrial: #f97316;
            --zone-park: #84cc16;
            --zone-road: #71717a;
            --zone-water: #06b6d4;

            --sidebar-width: 280px;
            --topbar-height: 60px;
            --statsbar-width: 320px;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Inter', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }

        /* ========== Layout ========== */
        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        .top-bar {
            height: var(--topbar-height);
            background: var(--bg-secondary);
            border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            z-index: 100;
        }

        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .left-sidebar {
            width: var(--sidebar-width);
            background: var(--bg-secondary);
            border-right: 1px solid rgba(255,255,255,0.1);
            overflow-y: auto;
            padding: 15px;
            flex-shrink: 0;
        }

        .canvas-container {
            flex: 1;
            position: relative;
            background: var(--bg-primary);
            overflow: hidden;
        }

        .right-sidebar {
            width: var(--statsbar-width);
            background: var(--bg-secondary);
            border-left: 1px solid rgba(255,255,255,0.1);
            overflow-y: auto;
            padding: 15px;
            flex-shrink: 0;
        }

        /* ========== Top Bar Styles ========== */
        .logo {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .logo-icon {
            width: 36px;
            height: 36px;
            background: linear-gradient(135deg, var(--zone-residential), var(--zone-commercial));
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
        }

        .logo-text {
            font-size: 18px;
            font-weight: 700;
            background: linear-gradient(135deg, #fff, #a0a0b0);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .controls-center {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .generation-display {
            background: var(--bg-tertiary);
            padding: 8px 16px;
            border-radius: 8px;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 14px;
        }

        .generation-label {
            color: var(--text-secondary);
            margin-right: 8px;
        }

        .generation-value {
            color: var(--accent);
            font-weight: 600;
        }

        .playback-controls {
            display: flex;
            gap: 5px;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
            background: var(--bg-tertiary);
            padding: 5px 15px;
            border-radius: 8px;
        }

        .speed-control label {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .speed-control input[type="range"] {
            width: 80px;
            accent-color: var(--accent);
        }

        .view-toggle {
            display: flex;
            background: var(--bg-tertiary);
            border-radius: 8px;
            overflow: hidden;
        }

        .view-toggle button {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            padding: 8px 16px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .view-toggle button.active {
            background: var(--accent);
            color: white;
        }

        .view-toggle button:hover:not(.active) {
            background: rgba(255,255,255,0.1);
        }

        .top-right-controls {
            display: flex;
            gap: 10px;
        }

        /* ========== Buttons ========== */
        .btn {
            background: var(--bg-tertiary);
            border: 1px solid rgba(255,255,255,0.1);
            color: var(--text-primary);
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .btn:hover {
            background: rgba(255,255,255,0.1);
            border-color: rgba(255,255,255,0.2);
        }

        .btn-primary {
            background: var(--accent);
            border-color: var(--accent);
        }

        .btn-primary:hover {
            background: #5558e8;
        }

        .btn-success {
            background: var(--zone-residential);
            border-color: var(--zone-residential);
            color: #000;
        }

        .btn-icon {
            padding: 8px 10px;
        }

        .btn-sm {
            padding: 5px 10px;
            font-size: 12px;
        }

        /* ========== Left Sidebar ========== */
        .sidebar-section {
            margin-bottom: 20px;
        }

        .sidebar-section h3 {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-secondary);
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .zone-selector {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .zone-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            padding: 12px 8px;
            background: var(--bg-tertiary);
            border: 2px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .zone-btn:hover {
            background: rgba(255,255,255,0.1);
        }

        .zone-btn.active {
            border-color: var(--accent);
            background: rgba(99, 102, 241, 0.1);
        }

        .zone-color {
            width: 24px;
            height: 24px;
            border-radius: 4px;
        }

        .zone-color.empty { background: var(--zone-empty); border: 1px solid rgba(255,255,255,0.2); }
        .zone-color.residential { background: var(--zone-residential); }
        .zone-color.commercial { background: var(--zone-commercial); }
        .zone-color.industrial { background: var(--zone-industrial); }
        .zone-color.park { background: var(--zone-park); }
        .zone-color.road { background: var(--zone-road); }
        .zone-color.water { background: var(--zone-water); }

        .zone-btn span {
            font-size: 10px;
            color: var(--text-secondary);
        }

        .brush-size-control {
            display: flex;
            gap: 8px;
        }

        .brush-btn {
            flex: 1;
            padding: 8px;
            background: var(--bg-tertiary);
            border: 2px solid transparent;
            border-radius: 6px;
            color: var(--text-primary);
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }

        .brush-btn.active {
            border-color: var(--accent);
            background: rgba(99, 102, 241, 0.1);
        }

        .preset-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .preset-btn {
            width: 100%;
            text-align: left;
            padding: 10px 12px;
            background: var(--bg-tertiary);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 6px;
            color: var(--text-primary);
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }

        .preset-btn:hover {
            background: rgba(255,255,255,0.1);
            border-color: var(--accent);
        }

        .heatmap-controls {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .heatmap-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 10px;
            background: var(--bg-tertiary);
            border: 1px solid transparent;
            border-radius: 6px;
            color: var(--text-primary);
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }

        .heatmap-btn.active {
            border-color: var(--accent);
            background: rgba(99, 102, 241, 0.1);
        }

        .heatmap-indicator {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }

        /* ========== Rule Editor ========== */
        .rule-editor {
            background: var(--bg-tertiary);
            border-radius: 8px;
            padding: 12px;
            margin-top: 10px;
        }

        .rule-zone-tabs {
            display: flex;
            gap: 4px;
            margin-bottom: 12px;
            flex-wrap: wrap;
        }

        .rule-zone-tab {
            padding: 4px 8px;
            border-radius: 4px;
            border: none;
            cursor: pointer;
            font-size: 10px;
            transition: all 0.2s;
        }

        .rule-zone-tab.residential { background: var(--zone-residential); color: #000; }
        .rule-zone-tab.commercial { background: var(--zone-commercial); color: #fff; }
        .rule-zone-tab.industrial { background: var(--zone-industrial); color: #000; }

        .rule-zone-tab.active {
            box-shadow: 0 0 0 2px white;
        }

        .rule-group {
            margin-bottom: 12px;
        }

        .rule-group label {
            display: block;
            font-size: 11px;
            color: var(--text-secondary);
            margin-bottom: 6px;
        }

        .rule-slider-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .rule-slider-row input[type="range"] {
            flex: 1;
            accent-color: var(--accent);
        }

        .rule-slider-row .value {
            width: 24px;
            text-align: center;
            font-size: 12px;
            font-family: monospace;
        }

        .rule-presets {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-top: 10px;
        }

        .rule-preset-btn {
            padding: 4px 8px;
            background: var(--bg-secondary);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 4px;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 10px;
            transition: all 0.2s;
        }

        .rule-preset-btn:hover {
            background: rgba(255,255,255,0.1);
            color: var(--text-primary);
        }

        /* ========== Right Sidebar - Statistics ========== */
        .stat-card {
            background: var(--bg-tertiary);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 12px;
        }

        .stat-card h4 {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-secondary);
            margin-bottom: 10px;
        }

        .stat-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .stat-label {
            font-size: 10px;
            color: var(--text-secondary);
        }

        .stat-value {
            font-size: 18px;
            font-weight: 600;
        }

        .stat-value.residential { color: var(--zone-residential); }
        .stat-value.commercial { color: var(--zone-commercial); }
        .stat-value.industrial { color: var(--zone-industrial); }
        .stat-value.park { color: var(--zone-park); }
        .stat-value.road { color: var(--zone-road); }
        .stat-value.water { color: var(--zone-water); }

        .zone-bar {
            height: 8px;
            background: var(--bg-secondary);
            border-radius: 4px;
            overflow: hidden;
            display: flex;
        }

        .zone-bar-segment {
            height: 100%;
            transition: width 0.3s ease;
        }

        .chart-container {
            height: 120px;
            background: var(--bg-secondary);
            border-radius: 6px;
            padding: 10px;
            margin-top: 10px;
        }

        .chart-canvas {
            width: 100%;
            height: 100%;
        }

        /* ========== Canvas & 3D View ========== */
        #canvas2d {
            position: absolute;
            top: 0;
            left: 0;
            cursor: crosshair;
        }

        #canvas3d {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .minimap {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 150px;
            height: 150px;
            background: var(--bg-secondary);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            overflow: hidden;
        }

        .minimap canvas {
            width: 100%;
            height: 100%;
        }

        .canvas-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 12px;
            display: flex;
            gap: 20px;
        }

        .canvas-info span {
            color: var(--text-secondary);
        }

        .canvas-info strong {
            color: var(--text-primary);
            margin-left: 5px;
        }

        /* ========== 3D Controls Overlay ========== */
        .controls-3d-overlay {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.85);
            padding: 12px 20px;
            border-radius: 10px;
            font-size: 12px;
            color: var(--text-secondary);
            display: none;
        }

        .controls-3d-overlay.visible {
            display: block;
        }

        .controls-3d-overlay kbd {
            background: var(--bg-tertiary);
            padding: 2px 6px;
            border-radius: 3px;
            margin: 0 3px;
            font-family: monospace;
        }

        /* ========== Modal Styles ========== */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s;
        }

        .modal-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .modal {
            background: var(--bg-secondary);
            border-radius: 16px;
            padding: 30px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            transform: scale(0.9);
            transition: transform 0.3s;
        }

        .modal-overlay.visible .modal {
            transform: scale(1);
        }

        .modal h2 {
            font-size: 24px;
            margin-bottom: 20px;
            background: linear-gradient(135deg, var(--accent), var(--zone-residential));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .modal p {
            color: var(--text-secondary);
            line-height: 1.6;
            margin-bottom: 15px;
        }

        .modal-actions {
            display: flex;
            gap: 10px;
            margin-top: 25px;
            justify-content: flex-end;
        }

        /* ========== Data Controls ========== */
        .data-controls {
            display: flex;
            gap: 8px;
        }

        #importFile {
            display: none;
        }

        /* ========== Tooltip ========== */
        .tooltip {
            position: fixed;
            background: rgba(0,0,0,0.9);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .tooltip.visible {
            opacity: 1;
        }

        .tooltip-zone {
            font-weight: 600;
            margin-bottom: 4px;
        }

        .tooltip-info {
            color: var(--text-secondary);
        }

        /* ========== Notification ========== */
        .notification {
            position: fixed;
            top: 80px;
            right: 20px;
            background: var(--bg-secondary);
            border-left: 4px solid var(--accent);
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            z-index: 1000;
            transform: translateX(120%);
            transition: transform 0.3s;
        }

        .notification.visible {
            transform: translateX(0);
        }

        .notification.success {
            border-color: var(--zone-residential);
        }

        .notification.error {
            border-color: #ef4444;
        }

        /* ========== Responsive Design ========== */
        @media (max-width: 1200px) {
            .right-sidebar {
                width: 260px;
            }
        }

        @media (max-width: 1024px) {
            .left-sidebar, .right-sidebar {
                display: none;
            }

            .mobile-controls {
                display: flex;
            }
        }

        @media (max-width: 768px) {
            .top-bar {
                padding: 0 10px;
                height: 50px;
            }

            .logo-text {
                display: none;
            }

            .generation-display {
                padding: 5px 10px;
                font-size: 12px;
            }

            .speed-control {
                display: none;
            }
        }

        /* ========== Scrollbar Styling ========== */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-primary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--bg-tertiary);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255,255,255,0.2);
        }

        /* ========== Loading State ========== */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--bg-primary);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid var(--bg-tertiary);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Top Bar -->
        <div class="top-bar">
            <div class="logo">
                <div class="logo-icon">CA</div>
                <span class="logo-text">Cellular Automata City Planner</span>
            </div>

            <div class="controls-center">
                <div class="generation-display">
                    <span class="generation-label">GEN</span>
                    <span class="generation-value" id="generationCounter">0</span>
                </div>

                <div class="playback-controls">
                    <button class="btn btn-icon" id="btnReset" title="Reset">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/>
                            <path d="M3 3v5h5"/>
                        </svg>
                    </button>
                    <button class="btn btn-icon" id="btnStep" title="Step Forward">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polygon points="5 4 15 12 5 20 5 4"/>
                            <line x1="19" y1="5" x2="19" y2="19"/>
                        </svg>
                    </button>
                    <button class="btn btn-primary btn-icon" id="btnPlayPause" title="Play/Pause">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" id="playIcon">
                            <polygon points="5 3 19 12 5 21 5 3"/>
                        </svg>
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" id="pauseIcon" style="display:none;">
                            <rect x="6" y="4" width="4" height="16"/>
                            <rect x="14" y="4" width="4" height="16"/>
                        </svg>
                    </button>
                    <button class="btn btn-icon" id="btnFastForward" title="Fast Forward (100 gens)">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polygon points="13 19 22 12 13 5 13 19"/>
                            <polygon points="2 19 11 12 2 5 2 19"/>
                        </svg>
                    </button>
                </div>

                <div class="speed-control">
                    <label>Speed</label>
                    <input type="range" id="speedSlider" min="1" max="20" value="5">
                    <span id="speedValue">5</span>
                </div>

                <div class="view-toggle">
                    <button class="active" id="btn2D">2D</button>
                    <button id="btn3D">3D</button>
                </div>
            </div>

            <div class="top-right-controls">
                <div class="data-controls">
                    <button class="btn" id="btnExport" title="Export Data">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                            <polyline points="7 10 12 15 17 10"/>
                            <line x1="12" y1="15" x2="12" y2="3"/>
                        </svg>
                        Export
                    </button>
                    <button class="btn" id="btnImport" title="Import Data">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                            <polyline points="17 8 12 3 7 8"/>
                            <line x1="12" y1="3" x2="12" y2="15"/>
                        </svg>
                        Import
                    </button>
                    <input type="file" id="importFile" accept=".json">
                </div>
                <button class="btn" id="btnHelp" title="Help">?</button>
            </div>
        </div>

        <!-- Main Content -->
        <div class="main-content">
            <!-- Left Sidebar -->
            <div class="left-sidebar">
                <div class="sidebar-section">
                    <h3>Zone Brush</h3>
                    <div class="zone-selector">
                        <button class="zone-btn active" data-zone="empty">
                            <div class="zone-color empty"></div>
                            <span>Eraser</span>
                        </button>
                        <button class="zone-btn" data-zone="residential">
                            <div class="zone-color residential"></div>
                            <span>Residential</span>
                        </button>
                        <button class="zone-btn" data-zone="commercial">
                            <div class="zone-color commercial"></div>
                            <span>Commercial</span>
                        </button>
                        <button class="zone-btn" data-zone="industrial">
                            <div class="zone-color industrial"></div>
                            <span>Industrial</span>
                        </button>
                        <button class="zone-btn" data-zone="park">
                            <div class="zone-color park"></div>
                            <span>Park</span>
                        </button>
                        <button class="zone-btn" data-zone="road">
                            <div class="zone-color road"></div>
                            <span>Road</span>
                        </button>
                        <button class="zone-btn" data-zone="water">
                            <div class="zone-color water"></div>
                            <span>Water</span>
                        </button>
                    </div>
                </div>

                <div class="sidebar-section">
                    <h3>Brush Size</h3>
                    <div class="brush-size-control">
                        <button class="brush-btn active" data-size="1">1x1</button>
                        <button class="brush-btn" data-size="3">3x3</button>
                        <button class="brush-btn" data-size="5">5x5</button>
                    </div>
                </div>

                <div class="sidebar-section">
                    <h3>City Presets</h3>
                    <div class="preset-list">
                        <button class="preset-btn" data-preset="blank">Blank Canvas</button>
                        <button class="preset-btn" data-preset="random">Random Seed</button>
                        <button class="preset-btn" data-preset="manhattan">Manhattan Grid</button>
                        <button class="preset-btn" data-preset="sprawl">Sprawl City</button>
                        <button class="preset-btn" data-preset="industrial">Industrial Hub</button>
                        <button class="preset-btn" data-preset="garden">Garden City</button>
                    </div>
                </div>

                <div class="sidebar-section">
                    <h3>Heatmap Overlay</h3>
                    <div class="heatmap-controls">
                        <button class="heatmap-btn active" data-heatmap="none">
                            <div class="heatmap-indicator" style="background: transparent; border: 1px solid rgba(255,255,255,0.3);"></div>
                            None
                        </button>
                        <button class="heatmap-btn" data-heatmap="density">
                            <div class="heatmap-indicator" style="background: linear-gradient(90deg, #22c55e, #eab308, #ef4444);"></div>
                            Population Density
                        </button>
                        <button class="heatmap-btn" data-heatmap="commercial">
                            <div class="heatmap-indicator" style="background: linear-gradient(90deg, #1e3a5f, #3b82f6);"></div>
                            Commercial Activity
                        </button>
                        <button class="heatmap-btn" data-heatmap="pollution">
                            <div class="heatmap-indicator" style="background: linear-gradient(90deg, #22c55e, #854d0e, #7f1d1d);"></div>
                            Pollution
                        </button>
                        <button class="heatmap-btn" data-heatmap="desirability">
                            <div class="heatmap-indicator" style="background: linear-gradient(90deg, #dc2626, #fbbf24, #22c55e);"></div>
                            Desirability
                        </button>
                    </div>
                </div>

                <div class="sidebar-section">
                    <h3>Rule Configuration</h3>
                    <div class="rule-editor">
                        <div class="rule-zone-tabs">
                            <button class="rule-zone-tab residential active" data-zone="residential">Res</button>
                            <button class="rule-zone-tab commercial" data-zone="commercial">Com</button>
                            <button class="rule-zone-tab industrial" data-zone="industrial">Ind</button>
                        </div>

                        <div id="ruleControls">
                            <div class="rule-group">
                                <label>Min Neighbors to Spawn</label>
                                <div class="rule-slider-row">
                                    <input type="range" id="ruleMinSpawn" min="0" max="8" value="2">
                                    <span class="value" id="ruleMinSpawnVal">2</span>
                                </div>
                            </div>
                            <div class="rule-group">
                                <label>Max Neighbors to Spawn</label>
                                <div class="rule-slider-row">
                                    <input type="range" id="ruleMaxSpawn" min="0" max="8" value="4">
                                    <span class="value" id="ruleMaxSpawnVal">4</span>
                                </div>
                            </div>
                            <div class="rule-group">
                                <label>Road Requirement</label>
                                <div class="rule-slider-row">
                                    <input type="range" id="ruleRoadReq" min="0" max="3" value="1">
                                    <span class="value" id="ruleRoadReqVal">1</span>
                                </div>
                            </div>
                            <div class="rule-group">
                                <label>Growth Rate</label>
                                <div class="rule-slider-row">
                                    <input type="range" id="ruleGrowth" min="1" max="100" value="30">
                                    <span class="value" id="ruleGrowthVal">30%</span>
                                </div>
                            </div>
                        </div>

                        <div class="rule-presets">
                            <button class="rule-preset-btn" data-ruleset="classic">Classic</button>
                            <button class="rule-preset-btn" data-ruleset="sprawl">Sprawl</button>
                            <button class="rule-preset-btn" data-ruleset="dense">Dense</button>
                            <button class="rule-preset-btn" data-ruleset="eco">Eco-City</button>
                            <button class="rule-preset-btn" data-ruleset="chaos">Chaos</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Canvas Container -->
            <div class="canvas-container" id="canvasContainer">
                <canvas id="canvas2d"></canvas>
                <div id="canvas3d" style="display: none;"></div>

                <div class="minimap">
                    <canvas id="minimapCanvas"></canvas>
                </div>

                <div class="canvas-info" id="canvasInfo">
                    <div><span>Position:</span><strong id="infoPos">0, 0</strong></div>
                    <div><span>Zone:</span><strong id="infoZone">Empty</strong></div>
                    <div><span>Neighbors:</span><strong id="infoNeighbors">0</strong></div>
                </div>

                <div class="controls-3d-overlay" id="controls3d">
                    <kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd> Move |
                    <kbd>Mouse</kbd> Look |
                    <kbd>Shift</kbd> Run |
                    <kbd>Space</kbd> Up |
                    <kbd>Ctrl</kbd> Down
                </div>
            </div>

            <!-- Right Sidebar - Statistics -->
            <div class="right-sidebar">
                <div class="stat-card">
                    <h4>City Overview</h4>
                    <div class="stat-grid">
                        <div class="stat-item">
                            <span class="stat-label">Population</span>
                            <span class="stat-value" id="statPopulation">0</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">City Area</span>
                            <span class="stat-value" id="statArea">0</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Growth Rate</span>
                            <span class="stat-value" id="statGrowth">0/gen</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Desirability</span>
                            <span class="stat-value" id="statDesirability">0%</span>
                        </div>
                    </div>
                </div>

                <div class="stat-card">
                    <h4>Zone Distribution</h4>
                    <div class="zone-bar" id="zoneBar">
                        <div class="zone-bar-segment" style="background: var(--zone-residential);"></div>
                        <div class="zone-bar-segment" style="background: var(--zone-commercial);"></div>
                        <div class="zone-bar-segment" style="background: var(--zone-industrial);"></div>
                        <div class="zone-bar-segment" style="background: var(--zone-park);"></div>
                        <div class="zone-bar-segment" style="background: var(--zone-road);"></div>
                        <div class="zone-bar-segment" style="background: var(--zone-water);"></div>
                    </div>
                    <div class="stat-grid" style="margin-top: 15px;">
                        <div class="stat-item">
                            <span class="stat-label">Residential</span>
                            <span class="stat-value residential" id="statResidential">0</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Commercial</span>
                            <span class="stat-value commercial" id="statCommercial">0</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Industrial</span>
                            <span class="stat-value industrial" id="statIndustrial">0</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Parks</span>
                            <span class="stat-value park" id="statPark">0</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Roads</span>
                            <span class="stat-value road" id="statRoad">0</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Water</span>
                            <span class="stat-value water" id="statWater">0</span>
                        </div>
                    </div>
                </div>

                <div class="stat-card">
                    <h4>Environment</h4>
                    <div class="stat-grid">
                        <div class="stat-item">
                            <span class="stat-label">Pollution Level</span>
                            <span class="stat-value" id="statPollution">0%</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Road Coverage</span>
                            <span class="stat-value" id="statRoadCoverage">0%</span>
                        </div>
                    </div>
                </div>

                <div class="stat-card">
                    <h4>Growth History</h4>
                    <div class="chart-container">
                        <canvas id="chartCanvas" class="chart-canvas"></canvas>
                    </div>
                </div>

                <div class="stat-card">
                    <h4>Quick Actions</h4>
                    <div style="display: flex; flex-direction: column; gap: 8px;">
                        <button class="btn btn-sm" id="btnClear">Clear All Zones</button>
                        <button class="btn btn-sm" id="btnRandomSeed">Random Seed (20 zones)</button>
                        <button class="btn btn-sm" id="btnExportImage">Export as PNG</button>
                        <button class="btn btn-sm" id="btnExportCSV">Export Stats CSV</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Tooltip -->
    <div class="tooltip" id="tooltip">
        <div class="tooltip-zone"></div>
        <div class="tooltip-info"></div>
    </div>

    <!-- Notification -->
    <div class="notification" id="notification">
        <span id="notificationText"></span>
    </div>

    <!-- Help Modal -->
    <div class="modal-overlay" id="helpModal">
        <div class="modal">
            <h2>Cellular Automata City Planner</h2>
            <p>
                Watch cities emerge organically from simple rules! Different zone types grow,
                interact, and evolve based on their neighbors, creating complex urban patterns
                from basic cellular automata principles.
            </p>
            <h3 style="margin: 20px 0 10px; color: var(--accent);">Zone Types</h3>
            <ul style="line-height: 1.8; color: var(--text-secondary); padding-left: 20px;">
                <li><strong style="color: var(--zone-residential);">Residential:</strong> Grows near other homes, needs shops and roads, avoids industry</li>
                <li><strong style="color: var(--zone-commercial);">Commercial:</strong> Needs customers (residential), clusters into business districts</li>
                <li><strong style="color: var(--zone-industrial);">Industrial:</strong> Creates pollution, prefers city edges, needs roads</li>
                <li><strong style="color: var(--zone-park);">Parks:</strong> Increases desirability, absorbs pollution</li>
                <li><strong style="color: var(--zone-road);">Roads:</strong> Required for most zone growth</li>
                <li><strong style="color: var(--zone-water);">Water:</strong> Natural features that increase property value</li>
            </ul>
            <h3 style="margin: 20px 0 10px; color: var(--accent);">Controls</h3>
            <ul style="line-height: 1.8; color: var(--text-secondary); padding-left: 20px;">
                <li><strong>Click/Drag:</strong> Paint zones on the grid</li>
                <li><strong>Scroll:</strong> Zoom in/out</li>
                <li><strong>Middle-click Drag:</strong> Pan the view</li>
                <li><strong>Space:</strong> Play/Pause simulation</li>
                <li><strong>N:</strong> Step one generation</li>
            </ul>
            <h3 style="margin: 20px 0 10px; color: var(--accent);">3D Mode</h3>
            <p>Switch to 3D view to walk through your city! Use WASD to move, mouse to look around.</p>
            <div class="modal-actions">
                <button class="btn btn-primary" id="btnCloseHelp">Got it!</button>
            </div>
        </div>
    </div>

    <script>
        // ============================================================
        // CELLULAR AUTOMATA CITY PLANNER
        // A self-contained urban planning simulation
        // ============================================================

        const APP_NAME = 'cellular-automata-city-planner';

        // ============================================================
        // ZONE TYPES & CONSTANTS
        // ============================================================
        const ZONES = {
            EMPTY: 0,
            RESIDENTIAL: 1,
            COMMERCIAL: 2,
            INDUSTRIAL: 3,
            PARK: 4,
            ROAD: 5,
            WATER: 6
        };

        const ZONE_NAMES = ['empty', 'residential', 'commercial', 'industrial', 'park', 'road', 'water'];

        const ZONE_COLORS = {
            [ZONES.EMPTY]: '#1a1a25',
            [ZONES.RESIDENTIAL]: '#22c55e',
            [ZONES.COMMERCIAL]: '#3b82f6',
            [ZONES.INDUSTRIAL]: '#f97316',
            [ZONES.PARK]: '#84cc16',
            [ZONES.ROAD]: '#71717a',
            [ZONES.WATER]: '#06b6d4'
        };

        const ZONE_HEIGHTS = {
            [ZONES.EMPTY]: 0,
            [ZONES.RESIDENTIAL]: 2,
            [ZONES.COMMERCIAL]: 5,
            [ZONES.INDUSTRIAL]: 3,
            [ZONES.PARK]: 0.2,
            [ZONES.ROAD]: 0.1,
            [ZONES.WATER]: -0.3
        };

        // ============================================================
        // APPLICATION STATE
        // ============================================================
        let state = {
            grid: null,
            gridWidth: 100,
            gridHeight: 100,
            generation: 0,
            isPlaying: false,
            speed: 5,
            lastTickTime: 0,

            // View state
            viewMode: '2d',
            zoom: 1,
            panX: 0,
            panY: 0,
            cellSize: 8,

            // Brush state
            selectedZone: ZONES.EMPTY,
            brushSize: 1,
            isPainting: false,

            // Heatmap
            currentHeatmap: 'none',
            pollutionMap: null,
            desirabilityMap: null,

            // History for statistics
            history: [],
            maxHistory: 500,

            // Rules configuration
            rules: null,
            currentRuleZone: 'residential',

            // Initial state for reset
            initialGrid: null
        };

        // Default rules for each zone type
        const DEFAULT_RULES = {
            residential: {
                minNeighbors: 2,
                maxNeighbors: 4,
                roadRequired: 1,
                commercialBonus: true,
                industrialPenalty: 3,
                parkBonus: true,
                growthRate: 0.3
            },
            commercial: {
                minNeighbors: 1,
                maxNeighbors: 5,
                roadRequired: 1,
                residentialRequired: 3,
                clusterBonus: true,
                growthRate: 0.2
            },
            industrial: {
                minNeighbors: 1,
                maxNeighbors: 4,
                roadRequired: 1,
                edgePreference: true,
                growthRate: 0.15
            }
        };

        // Rule presets
        const RULE_PRESETS = {
            classic: {
                residential: { minNeighbors: 2, maxNeighbors: 4, roadRequired: 1, growthRate: 0.3 },
                commercial: { minNeighbors: 1, maxNeighbors: 5, roadRequired: 1, growthRate: 0.2 },
                industrial: { minNeighbors: 1, maxNeighbors: 4, roadRequired: 1, growthRate: 0.15 }
            },
            sprawl: {
                residential: { minNeighbors: 1, maxNeighbors: 6, roadRequired: 0, growthRate: 0.5 },
                commercial: { minNeighbors: 1, maxNeighbors: 6, roadRequired: 0, growthRate: 0.3 },
                industrial: { minNeighbors: 0, maxNeighbors: 4, roadRequired: 0, growthRate: 0.2 }
            },
            dense: {
                residential: { minNeighbors: 3, maxNeighbors: 8, roadRequired: 1, growthRate: 0.4 },
                commercial: { minNeighbors: 2, maxNeighbors: 8, roadRequired: 1, growthRate: 0.35 },
                industrial: { minNeighbors: 2, maxNeighbors: 6, roadRequired: 1, growthRate: 0.2 }
            },
            eco: {
                residential: { minNeighbors: 2, maxNeighbors: 3, roadRequired: 1, growthRate: 0.2 },
                commercial: { minNeighbors: 1, maxNeighbors: 3, roadRequired: 1, growthRate: 0.15 },
                industrial: { minNeighbors: 1, maxNeighbors: 2, roadRequired: 1, growthRate: 0.1 }
            },
            chaos: {
                residential: { minNeighbors: 1, maxNeighbors: 8, roadRequired: 0, growthRate: 0.6 },
                commercial: { minNeighbors: 0, maxNeighbors: 8, roadRequired: 0, growthRate: 0.5 },
                industrial: { minNeighbors: 0, maxNeighbors: 8, roadRequired: 0, growthRate: 0.4 }
            }
        };

        // ============================================================
        // CANVAS & RENDERING
        // ============================================================
        let canvas2d, ctx2d;
        let minimapCanvas, minimapCtx;
        let chartCanvas, chartCtx;
        let animationId;

        function initCanvas() {
            canvas2d = document.getElementById('canvas2d');
            ctx2d = canvas2d.getContext('2d');

            minimapCanvas = document.getElementById('minimapCanvas');
            minimapCtx = minimapCanvas.getContext('2d');

            chartCanvas = document.getElementById('chartCanvas');
            chartCtx = chartCanvas.getContext('2d');

            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
        }

        function resizeCanvas() {
            const container = document.getElementById('canvasContainer');
            const rect = container.getBoundingClientRect();

            canvas2d.width = rect.width;
            canvas2d.height = rect.height;

            minimapCanvas.width = 150;
            minimapCanvas.height = 150;

            chartCanvas.width = chartCanvas.parentElement.clientWidth - 20;
            chartCanvas.height = chartCanvas.parentElement.clientHeight - 20;

            render();
        }

        function render() {
            if (state.viewMode === '2d') {
                render2D();
            }
            renderMinimap();
        }

        function render2D() {
            const { grid, gridWidth, gridHeight, zoom, panX, panY, cellSize } = state;

            ctx2d.fillStyle = '#0a0a0f';
            ctx2d.fillRect(0, 0, canvas2d.width, canvas2d.height);

            const actualCellSize = cellSize * zoom;
            const startX = Math.floor(-panX / actualCellSize);
            const startY = Math.floor(-panY / actualCellSize);
            const endX = Math.min(gridWidth, startX + Math.ceil(canvas2d.width / actualCellSize) + 1);
            const endY = Math.min(gridHeight, startY + Math.ceil(canvas2d.height / actualCellSize) + 1);

            // Draw grid cells
            for (let y = Math.max(0, startY); y < endY; y++) {
                for (let x = Math.max(0, startX); x < endX; x++) {
                    const zone = grid[y * gridWidth + x];
                    const screenX = x * actualCellSize + panX;
                    const screenY = y * actualCellSize + panY;

                    // Base zone color
                    let color = ZONE_COLORS[zone];

                    // Apply heatmap overlay
                    if (state.currentHeatmap !== 'none' && zone !== ZONES.WATER) {
                        color = getHeatmapColor(x, y);
                    }

                    ctx2d.fillStyle = color;
                    ctx2d.fillRect(screenX, screenY, actualCellSize - 1, actualCellSize - 1);
                }
            }

            // Draw grid lines if zoomed in enough
            if (actualCellSize >= 8) {
                ctx2d.strokeStyle = 'rgba(255,255,255,0.05)';
                ctx2d.lineWidth = 1;

                for (let x = Math.max(0, startX); x <= endX; x++) {
                    const screenX = x * actualCellSize + panX;
                    ctx2d.beginPath();
                    ctx2d.moveTo(screenX, 0);
                    ctx2d.lineTo(screenX, canvas2d.height);
                    ctx2d.stroke();
                }

                for (let y = Math.max(0, startY); y <= endY; y++) {
                    const screenY = y * actualCellSize + panY;
                    ctx2d.beginPath();
                    ctx2d.moveTo(0, screenY);
                    ctx2d.lineTo(canvas2d.width, screenY);
                    ctx2d.stroke();
                }
            }

            // Draw brush preview
            if (state.hoverX !== undefined && state.hoverY !== undefined) {
                const brushRadius = Math.floor(state.brushSize / 2);
                ctx2d.strokeStyle = 'rgba(255,255,255,0.5)';
                ctx2d.lineWidth = 2;

                for (let dy = -brushRadius; dy <= brushRadius; dy++) {
                    for (let dx = -brushRadius; dx <= brushRadius; dx++) {
                        const x = state.hoverX + dx;
                        const y = state.hoverY + dy;
                        if (x >= 0 && x < gridWidth && y >= 0 && y < gridHeight) {
                            const screenX = x * actualCellSize + panX;
                            const screenY = y * actualCellSize + panY;
                            ctx2d.strokeRect(screenX, screenY, actualCellSize - 1, actualCellSize - 1);
                        }
                    }
                }
            }
        }

        function renderMinimap() {
            const { grid, gridWidth, gridHeight } = state;
            const scale = Math.min(150 / gridWidth, 150 / gridHeight);

            minimapCtx.fillStyle = '#0a0a0f';
            minimapCtx.fillRect(0, 0, 150, 150);

            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    const zone = grid[y * gridWidth + x];
                    if (zone !== ZONES.EMPTY) {
                        minimapCtx.fillStyle = ZONE_COLORS[zone];
                        minimapCtx.fillRect(x * scale, y * scale, Math.max(1, scale), Math.max(1, scale));
                    }
                }
            }

            // Draw viewport rectangle
            const viewWidth = canvas2d.width / (state.cellSize * state.zoom);
            const viewHeight = canvas2d.height / (state.cellSize * state.zoom);
            const viewX = -state.panX / (state.cellSize * state.zoom);
            const viewY = -state.panY / (state.cellSize * state.zoom);

            minimapCtx.strokeStyle = 'rgba(255,255,255,0.8)';
            minimapCtx.lineWidth = 1;
            minimapCtx.strokeRect(viewX * scale, viewY * scale, viewWidth * scale, viewHeight * scale);
        }

        function getHeatmapColor(x, y) {
            const { gridWidth } = state;
            let value = 0;

            switch (state.currentHeatmap) {
                case 'density':
                    value = countNeighborsOfType(x, y, ZONES.RESIDENTIAL, 3) / 28;
                    return interpolateColor('#1a1a25', '#22c55e', '#eab308', '#ef4444', value);

                case 'commercial':
                    value = countNeighborsOfType(x, y, ZONES.COMMERCIAL, 3) / 28;
                    return interpolateColor('#1e3a5f', '#3b82f6', '#60a5fa', '#93c5fd', value);

                case 'pollution':
                    if (state.pollutionMap) {
                        value = state.pollutionMap[y * gridWidth + x];
                        return interpolateColor('#22c55e', '#854d0e', '#dc2626', '#7f1d1d', value);
                    }
                    break;

                case 'desirability':
                    if (state.desirabilityMap) {
                        value = state.desirabilityMap[y * gridWidth + x];
                        return interpolateColor('#dc2626', '#fbbf24', '#22c55e', '#16a34a', value);
                    }
                    break;
            }

            return ZONE_COLORS[state.grid[y * gridWidth + x]];
        }

        function interpolateColor(c1, c2, c3, c4, t) {
            const colors = [c1, c2, c3, c4];
            const idx = Math.min(Math.floor(t * 3), 2);
            const localT = (t * 3) - idx;

            const from = hexToRgb(colors[idx]);
            const to = hexToRgb(colors[idx + 1]);

            const r = Math.round(from.r + (to.r - from.r) * localT);
            const g = Math.round(from.g + (to.g - from.g) * localT);
            const b = Math.round(from.b + (to.b - from.b) * localT);

            return `rgb(${r},${g},${b})`;
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 0, g: 0, b: 0 };
        }

        function renderChart() {
            const { history } = state;
            if (history.length < 2) return;

            const width = chartCanvas.width;
            const height = chartCanvas.height;

            chartCtx.fillStyle = '#12121a';
            chartCtx.fillRect(0, 0, width, height);

            const dataPoints = Math.min(history.length, 100);
            const startIdx = history.length - dataPoints;
            const stepX = width / (dataPoints - 1);

            // Find max value for scaling
            let maxVal = 0;
            for (let i = startIdx; i < history.length; i++) {
                const h = history[i];
                maxVal = Math.max(maxVal, h.residential, h.commercial, h.industrial);
            }
            maxVal = maxVal || 1;

            // Draw each zone type
            const zoneTypes = ['residential', 'commercial', 'industrial'];
            const colors = [ZONE_COLORS[ZONES.RESIDENTIAL], ZONE_COLORS[ZONES.COMMERCIAL], ZONE_COLORS[ZONES.INDUSTRIAL]];

            zoneTypes.forEach((zone, zoneIdx) => {
                chartCtx.strokeStyle = colors[zoneIdx];
                chartCtx.lineWidth = 2;
                chartCtx.beginPath();

                for (let i = 0; i < dataPoints; i++) {
                    const h = history[startIdx + i];
                    const x = i * stepX;
                    const y = height - (h[zone] / maxVal) * (height - 10);

                    if (i === 0) chartCtx.moveTo(x, y);
                    else chartCtx.lineTo(x, y);
                }

                chartCtx.stroke();
            });
        }

        // ============================================================
        // CELLULAR AUTOMATA ENGINE
        // ============================================================
        function initGrid() {
            const size = state.gridWidth * state.gridHeight;
            state.grid = new Uint8Array(size);
            state.pollutionMap = new Float32Array(size);
            state.desirabilityMap = new Float32Array(size);
            state.rules = JSON.parse(JSON.stringify(DEFAULT_RULES));
            state.history = [];
            state.generation = 0;
        }

        function countNeighborsOfType(x, y, zoneType, range = 1) {
            const { grid, gridWidth, gridHeight } = state;
            let count = 0;

            for (let dy = -range; dy <= range; dy++) {
                for (let dx = -range; dx <= range; dx++) {
                    if (dx === 0 && dy === 0) continue;

                    const nx = x + dx;
                    const ny = y + dy;

                    if (nx >= 0 && nx < gridWidth && ny >= 0 && ny < gridHeight) {
                        if (grid[ny * gridWidth + nx] === zoneType) {
                            count++;
                        }
                    }
                }
            }

            return count;
        }

        function countAllNeighbors(x, y, range = 1) {
            const counts = {
                residential: countNeighborsOfType(x, y, ZONES.RESIDENTIAL, range),
                commercial: countNeighborsOfType(x, y, ZONES.COMMERCIAL, range),
                industrial: countNeighborsOfType(x, y, ZONES.INDUSTRIAL, range),
                park: countNeighborsOfType(x, y, ZONES.PARK, range),
                road: countNeighborsOfType(x, y, ZONES.ROAD, 1),
                water: countNeighborsOfType(x, y, ZONES.WATER, range)
            };
            return counts;
        }

        function tick() {
            const { grid, gridWidth, gridHeight, rules } = state;
            const newGrid = new Uint8Array(grid.length);

            // Update pollution and desirability maps
            updatePollutionMap();
            updateDesirabilityMap();

            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    const idx = y * gridWidth + x;
                    const currentZone = grid[idx];
                    const neighbors = countAllNeighbors(x, y);

                    // Static zones don't change
                    if (currentZone === ZONES.WATER || currentZone === ZONES.PARK || currentZone === ZONES.ROAD) {
                        newGrid[idx] = currentZone;
                        continue;
                    }

                    // Process empty cells for birth
                    if (currentZone === ZONES.EMPTY) {
                        newGrid[idx] = tryBirthZone(x, y, neighbors);
                        continue;
                    }

                    // Process existing zones for survival/death
                    newGrid[idx] = trySurviveZone(currentZone, x, y, neighbors);
                }
            }

            state.grid = newGrid;
            state.generation++;

            // Record history
            recordHistory();

            // Update UI
            updateStats();
            document.getElementById('generationCounter').textContent = state.generation;
        }

        function tryBirthZone(x, y, neighbors) {
            const { rules } = state;
            const pollution = state.pollutionMap[y * state.gridWidth + x];

            // Try residential
            const resRules = rules.residential;
            if (neighbors.residential >= resRules.minNeighbors &&
                neighbors.residential <= resRules.maxNeighbors &&
                neighbors.road >= resRules.roadRequired &&
                neighbors.industrial < 3 &&
                pollution < 0.5 &&
                Math.random() < resRules.growthRate) {

                // Bonus for nearby commercial and parks
                let bonus = 0;
                if (neighbors.commercial > 0) bonus += 0.2;
                if (neighbors.park > 0) bonus += 0.15;
                if (neighbors.water > 0) bonus += 0.1;

                if (Math.random() < bonus + 0.3) {
                    return ZONES.RESIDENTIAL;
                }
            }

            // Try commercial
            const comRules = rules.commercial;
            if (neighbors.commercial >= comRules.minNeighbors &&
                neighbors.commercial <= comRules.maxNeighbors &&
                neighbors.road >= comRules.roadRequired &&
                neighbors.residential >= 2 &&
                Math.random() < comRules.growthRate) {
                return ZONES.COMMERCIAL;
            }

            // Try industrial
            const indRules = rules.industrial;
            if (neighbors.industrial >= indRules.minNeighbors &&
                neighbors.industrial <= indRules.maxNeighbors &&
                neighbors.road >= indRules.roadRequired &&
                neighbors.residential < 3 &&
                Math.random() < indRules.growthRate) {
                // Preference for edges
                const isEdge = x < 10 || x > state.gridWidth - 10 || y < 10 || y > state.gridHeight - 10;
                if (isEdge || Math.random() < 0.3) {
                    return ZONES.INDUSTRIAL;
                }
            }

            return ZONES.EMPTY;
        }

        function trySurviveZone(zone, x, y, neighbors) {
            const pollution = state.pollutionMap[y * state.gridWidth + x];

            switch (zone) {
                case ZONES.RESIDENTIAL:
                    // Dies if too much pollution or too isolated
                    if (pollution > 0.7 ||
                        (neighbors.residential < 1 && neighbors.road < 1) ||
                        neighbors.industrial >= 4) {
                        return Math.random() < 0.3 ? ZONES.EMPTY : zone;
                    }
                    break;

                case ZONES.COMMERCIAL:
                    // Dies if no customers
                    if (neighbors.residential < 1 && neighbors.commercial < 1) {
                        return Math.random() < 0.2 ? ZONES.EMPTY : zone;
                    }
                    break;

                case ZONES.INDUSTRIAL:
                    // Very persistent
                    if (neighbors.road < 1 && Math.random() < 0.1) {
                        return ZONES.EMPTY;
                    }
                    break;
            }

            return zone;
        }

        function updatePollutionMap() {
            const { grid, gridWidth, gridHeight, pollutionMap } = state;
            const newPollution = new Float32Array(pollutionMap.length);

            // Calculate pollution from industrial zones
            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    const idx = y * gridWidth + x;
                    if (grid[idx] === ZONES.INDUSTRIAL) {
                        // Spread pollution in radius
                        for (let dy = -5; dy <= 5; dy++) {
                            for (let dx = -5; dx <= 5; dx++) {
                                const nx = x + dx;
                                const ny = y + dy;
                                if (nx >= 0 && nx < gridWidth && ny >= 0 && ny < gridHeight) {
                                    const dist = Math.sqrt(dx * dx + dy * dy);
                                    const nidx = ny * gridWidth + nx;
                                    newPollution[nidx] += Math.max(0, 1 - dist / 5) * 0.3;
                                }
                            }
                        }
                    }
                    // Parks absorb pollution
                    if (grid[idx] === ZONES.PARK) {
                        newPollution[idx] *= 0.3;
                    }
                }
            }

            // Clamp values
            for (let i = 0; i < newPollution.length; i++) {
                state.pollutionMap[i] = Math.min(1, newPollution[i]);
            }
        }

        function updateDesirabilityMap() {
            const { grid, gridWidth, gridHeight, desirabilityMap, pollutionMap } = state;

            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    const idx = y * gridWidth + x;
                    let desirability = 0.5;

                    const neighbors = countAllNeighbors(x, y, 3);

                    // Parks increase desirability
                    desirability += neighbors.park * 0.1;

                    // Water increases desirability
                    desirability += neighbors.water * 0.08;

                    // Pollution decreases desirability
                    desirability -= pollutionMap[idx] * 0.5;

                    // Commercial nearby is good (access to shops)
                    desirability += Math.min(neighbors.commercial, 3) * 0.05;

                    // Too much industrial is bad
                    desirability -= neighbors.industrial * 0.1;

                    // Roads are necessary
                    desirability += Math.min(neighbors.road, 2) * 0.05;

                    desirabilityMap[idx] = Math.max(0, Math.min(1, desirability));
                }
            }
        }

        function recordHistory() {
            const stats = calculateStats();
            state.history.push({
                generation: state.generation,
                residential: stats.residential,
                commercial: stats.commercial,
                industrial: stats.industrial,
                population: stats.population
            });

            if (state.history.length > state.maxHistory) {
                state.history.shift();
            }
        }

        function calculateStats() {
            const { grid, gridWidth, gridHeight, pollutionMap } = state;
            const counts = { empty: 0, residential: 0, commercial: 0, industrial: 0, park: 0, road: 0, water: 0 };
            let totalPollution = 0;
            let totalDesirability = 0;

            for (let i = 0; i < grid.length; i++) {
                counts[ZONE_NAMES[grid[i]]]++;
                totalPollution += pollutionMap[i];
                totalDesirability += state.desirabilityMap[i];
            }

            const totalCells = gridWidth * gridHeight;
            const developedCells = totalCells - counts.empty - counts.water;

            // Estimate population (residential cells * average 100 people)
            const population = counts.residential * 100;

            // Calculate growth rate
            const growthRate = state.history.length > 1
                ? (counts.residential + counts.commercial + counts.industrial) -
                  (state.history[state.history.length - 1].residential +
                   state.history[state.history.length - 1].commercial +
                   state.history[state.history.length - 1].industrial)
                : 0;

            return {
                ...counts,
                population,
                area: developedCells,
                growthRate,
                pollution: totalPollution / totalCells,
                desirability: totalDesirability / totalCells,
                roadCoverage: developedCells > 0 ? (counts.road / developedCells) : 0
            };
        }

        function updateStats() {
            const stats = calculateStats();

            document.getElementById('statPopulation').textContent = formatNumber(stats.population);
            document.getElementById('statArea').textContent = formatNumber(stats.area);
            document.getElementById('statGrowth').textContent = `${stats.growthRate > 0 ? '+' : ''}${stats.growthRate}/gen`;
            document.getElementById('statDesirability').textContent = `${Math.round(stats.desirability * 100)}%`;

            document.getElementById('statResidential').textContent = formatNumber(stats.residential);
            document.getElementById('statCommercial').textContent = formatNumber(stats.commercial);
            document.getElementById('statIndustrial').textContent = formatNumber(stats.industrial);
            document.getElementById('statPark').textContent = formatNumber(stats.park);
            document.getElementById('statRoad').textContent = formatNumber(stats.road);
            document.getElementById('statWater').textContent = formatNumber(stats.water);

            document.getElementById('statPollution').textContent = `${Math.round(stats.pollution * 100)}%`;
            document.getElementById('statRoadCoverage').textContent = `${Math.round(stats.roadCoverage * 100)}%`;

            // Update zone bar
            const total = stats.residential + stats.commercial + stats.industrial + stats.park + stats.road + stats.water || 1;
            const segments = document.querySelectorAll('.zone-bar-segment');
            segments[0].style.width = `${(stats.residential / total) * 100}%`;
            segments[1].style.width = `${(stats.commercial / total) * 100}%`;
            segments[2].style.width = `${(stats.industrial / total) * 100}%`;
            segments[3].style.width = `${(stats.park / total) * 100}%`;
            segments[4].style.width = `${(stats.road / total) * 100}%`;
            segments[5].style.width = `${(stats.water / total) * 100}%`;

            renderChart();
        }

        function formatNumber(n) {
            if (n >= 1000000) return (n / 1000000).toFixed(1) + 'M';
            if (n >= 1000) return (n / 1000).toFixed(1) + 'K';
            return n.toString();
        }

        // ============================================================
        // CITY PRESETS
        // ============================================================
        function loadPreset(preset) {
            initGrid();
            state.generation = 0;
            state.history = [];

            const { gridWidth, gridHeight, grid } = state;
            const centerX = Math.floor(gridWidth / 2);
            const centerY = Math.floor(gridHeight / 2);

            switch (preset) {
                case 'blank':
                    // Already empty
                    break;

                case 'random':
                    for (let i = 0; i < 20; i++) {
                        const x = Math.floor(Math.random() * gridWidth);
                        const y = Math.floor(Math.random() * gridHeight);
                        const zone = [ZONES.RESIDENTIAL, ZONES.COMMERCIAL, ZONES.ROAD][Math.floor(Math.random() * 3)];
                        grid[y * gridWidth + x] = zone;
                    }
                    break;

                case 'manhattan':
                    // Dense commercial core with grid roads
                    for (let dy = -5; dy <= 5; dy++) {
                        for (let dx = -5; dx <= 5; dx++) {
                            const x = centerX + dx;
                            const y = centerY + dy;
                            grid[y * gridWidth + x] = ZONES.COMMERCIAL;
                        }
                    }
                    // Grid roads
                    for (let i = 0; i < gridWidth; i += 10) {
                        for (let j = 0; j < gridHeight; j++) {
                            grid[j * gridWidth + i] = ZONES.ROAD;
                        }
                    }
                    for (let j = 0; j < gridHeight; j += 10) {
                        for (let i = 0; i < gridWidth; i++) {
                            grid[j * gridWidth + i] = ZONES.ROAD;
                        }
                    }
                    // Surrounding residential
                    for (let dy = -15; dy <= 15; dy++) {
                        for (let dx = -15; dx <= 15; dx++) {
                            const x = centerX + dx;
                            const y = centerY + dy;
                            if (x >= 0 && x < gridWidth && y >= 0 && y < gridHeight) {
                                if (grid[y * gridWidth + x] === ZONES.EMPTY && Math.random() < 0.3) {
                                    grid[y * gridWidth + x] = ZONES.RESIDENTIAL;
                                }
                            }
                        }
                    }
                    break;

                case 'sprawl':
                    // Single residential seed
                    grid[centerY * gridWidth + centerX] = ZONES.RESIDENTIAL;
                    grid[centerY * gridWidth + centerX + 1] = ZONES.ROAD;
                    grid[centerY * gridWidth + centerX - 1] = ZONES.ROAD;
                    grid[(centerY + 1) * gridWidth + centerX] = ZONES.ROAD;
                    grid[(centerY - 1) * gridWidth + centerX] = ZONES.ROAD;
                    // Apply sprawl rules
                    state.rules = JSON.parse(JSON.stringify(RULE_PRESETS.sprawl));
                    break;

                case 'industrial':
                    // Industrial clusters near edges with water
                    for (let i = 0; i < 20; i++) {
                        grid[i * gridWidth + 5] = ZONES.WATER;
                        grid[i * gridWidth + 6] = ZONES.WATER;
                    }
                    for (let i = 0; i < 10; i++) {
                        grid[(10 + i) * gridWidth + 10] = ZONES.INDUSTRIAL;
                        grid[(10 + i) * gridWidth + 11] = ZONES.INDUSTRIAL;
                    }
                    // Roads
                    for (let i = 0; i < 30; i++) {
                        grid[15 * gridWidth + i] = ZONES.ROAD;
                    }
                    // Residential
                    for (let dy = -5; dy <= 5; dy++) {
                        for (let dx = -5; dx <= 5; dx++) {
                            const x = centerX + dx;
                            const y = centerY + dy;
                            if (grid[y * gridWidth + x] === ZONES.EMPTY) {
                                grid[y * gridWidth + x] = ZONES.RESIDENTIAL;
                            }
                        }
                    }
                    break;

                case 'garden':
                    // Parks interspersed with residential
                    for (let y = 10; y < gridHeight - 10; y += 8) {
                        for (let x = 10; x < gridWidth - 10; x += 8) {
                            // Park in center
                            grid[y * gridWidth + x] = ZONES.PARK;
                            grid[y * gridWidth + x + 1] = ZONES.PARK;
                            grid[(y + 1) * gridWidth + x] = ZONES.PARK;
                            grid[(y + 1) * gridWidth + x + 1] = ZONES.PARK;

                            // Residential around
                            for (let dy = -2; dy <= 3; dy++) {
                                for (let dx = -2; dx <= 3; dx++) {
                                    const nx = x + dx;
                                    const ny = y + dy;
                                    if (nx >= 0 && nx < gridWidth && ny >= 0 && ny < gridHeight) {
                                        if (grid[ny * gridWidth + nx] === ZONES.EMPTY && Math.random() < 0.5) {
                                            grid[ny * gridWidth + nx] = ZONES.RESIDENTIAL;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    // Roads connecting
                    for (let i = 10; i < gridWidth - 10; i++) {
                        grid[20 * gridWidth + i] = ZONES.ROAD;
                        grid[40 * gridWidth + i] = ZONES.ROAD;
                        grid[60 * gridWidth + i] = ZONES.ROAD;
                        grid[80 * gridWidth + i] = ZONES.ROAD;
                    }
                    state.rules = JSON.parse(JSON.stringify(RULE_PRESETS.eco));
                    break;
            }

            // Save initial state for reset
            state.initialGrid = new Uint8Array(grid);

            updateStats();
            render();
            showNotification(`Loaded preset: ${preset}`, 'success');
        }

        // ============================================================
        // INPUT HANDLING
        // ============================================================
        function initInputHandlers() {
            const canvas = canvas2d;

            // Mouse position tracking
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                const actualCellSize = state.cellSize * state.zoom;
                const gridX = Math.floor((mouseX - state.panX) / actualCellSize);
                const gridY = Math.floor((mouseY - state.panY) / actualCellSize);

                state.hoverX = gridX;
                state.hoverY = gridY;

                // Update info display
                if (gridX >= 0 && gridX < state.gridWidth && gridY >= 0 && gridY < state.gridHeight) {
                    document.getElementById('infoPos').textContent = `${gridX}, ${gridY}`;
                    const zone = state.grid[gridY * state.gridWidth + gridX];
                    document.getElementById('infoZone').textContent = ZONE_NAMES[zone].charAt(0).toUpperCase() + ZONE_NAMES[zone].slice(1);
                    document.getElementById('infoNeighbors').textContent = countNeighborsOfType(gridX, gridY, zone);
                }

                // Paint if dragging
                if (state.isPainting) {
                    paintAt(gridX, gridY);
                }

                render();
            });

            canvas.addEventListener('mousedown', (e) => {
                if (e.button === 0) {
                    state.isPainting = true;
                    const rect = canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;

                    const actualCellSize = state.cellSize * state.zoom;
                    const gridX = Math.floor((mouseX - state.panX) / actualCellSize);
                    const gridY = Math.floor((mouseY - state.panY) / actualCellSize);

                    paintAt(gridX, gridY);
                    render();
                } else if (e.button === 1) {
                    // Middle button for panning
                    state.isPanning = true;
                    state.panStartX = e.clientX - state.panX;
                    state.panStartY = e.clientY - state.panY;
                    e.preventDefault();
                }
            });

            canvas.addEventListener('mouseup', () => {
                state.isPainting = false;
                state.isPanning = false;
            });

            canvas.addEventListener('mouseleave', () => {
                state.isPainting = false;
                state.isPanning = false;
                state.hoverX = undefined;
                state.hoverY = undefined;
                render();
            });

            // Zooming
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                const newZoom = Math.max(0.2, Math.min(5, state.zoom * zoomFactor));

                // Zoom towards mouse position
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                const scale = newZoom / state.zoom;
                state.panX = mouseX - (mouseX - state.panX) * scale;
                state.panY = mouseY - (mouseY - state.panY) * scale;
                state.zoom = newZoom;

                render();
            });

            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                if (e.target.tagName === 'INPUT') return;

                switch (e.code) {
                    case 'Space':
                        e.preventDefault();
                        togglePlay();
                        break;
                    case 'KeyN':
                        step();
                        break;
                    case 'KeyR':
                        if (e.ctrlKey || e.metaKey) return;
                        reset();
                        break;
                    case 'Digit1':
                        selectZone(ZONES.EMPTY);
                        break;
                    case 'Digit2':
                        selectZone(ZONES.RESIDENTIAL);
                        break;
                    case 'Digit3':
                        selectZone(ZONES.COMMERCIAL);
                        break;
                    case 'Digit4':
                        selectZone(ZONES.INDUSTRIAL);
                        break;
                    case 'Digit5':
                        selectZone(ZONES.PARK);
                        break;
                    case 'Digit6':
                        selectZone(ZONES.ROAD);
                        break;
                    case 'Digit7':
                        selectZone(ZONES.WATER);
                        break;
                }
            });
        }

        function paintAt(x, y) {
            const { grid, gridWidth, gridHeight, selectedZone, brushSize } = state;
            const radius = Math.floor(brushSize / 2);

            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    const nx = x + dx;
                    const ny = y + dy;

                    if (nx >= 0 && nx < gridWidth && ny >= 0 && ny < gridHeight) {
                        grid[ny * gridWidth + nx] = selectedZone;
                    }
                }
            }

            // Save initial state if this is first paint
            if (!state.initialGrid) {
                state.initialGrid = new Uint8Array(grid);
            }
        }

        function selectZone(zone) {
            state.selectedZone = zone;
            document.querySelectorAll('.zone-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.zone === ZONE_NAMES[zone]);
            });
        }

        // ============================================================
        // SIMULATION CONTROLS
        // ============================================================
        function togglePlay() {
            state.isPlaying = !state.isPlaying;

            const playIcon = document.getElementById('playIcon');
            const pauseIcon = document.getElementById('pauseIcon');

            if (state.isPlaying) {
                playIcon.style.display = 'none';
                pauseIcon.style.display = 'block';
            } else {
                playIcon.style.display = 'block';
                pauseIcon.style.display = 'none';
            }
        }

        function step() {
            tick();
            render();
        }

        function reset() {
            if (state.initialGrid) {
                state.grid = new Uint8Array(state.initialGrid);
            } else {
                state.grid.fill(0);
            }
            state.generation = 0;
            state.history = [];
            state.isPlaying = false;

            document.getElementById('playIcon').style.display = 'block';
            document.getElementById('pauseIcon').style.display = 'none';
            document.getElementById('generationCounter').textContent = '0';

            updateStats();
            render();
        }

        function fastForward(generations = 100) {
            for (let i = 0; i < generations; i++) {
                tick();
            }
            render();
        }

        // ============================================================
        // 3D VISUALIZATION (Simplified inline Three.js alternative)
        // ============================================================
        let scene3d = null;

        function init3D() {
            // Create a simple 3D canvas renderer
            const container = document.getElementById('canvas3d');
            container.innerHTML = '';

            const canvas3d = document.createElement('canvas');
            canvas3d.width = container.clientWidth;
            canvas3d.height = container.clientHeight;
            container.appendChild(canvas3d);

            const ctx3d = canvas3d.getContext('2d');

            // Store 3D state
            scene3d = {
                canvas: canvas3d,
                ctx: ctx3d,
                camera: {
                    x: state.gridWidth * 4,
                    y: 50,
                    z: state.gridHeight * 4,
                    rotX: -0.3,
                    rotY: Math.PI / 4,
                    speed: 2
                },
                keys: {},
                mouseDown: false,
                lastMouseX: 0,
                lastMouseY: 0
            };

            // Input handlers for 3D
            canvas3d.addEventListener('mousedown', (e) => {
                scene3d.mouseDown = true;
                scene3d.lastMouseX = e.clientX;
                scene3d.lastMouseY = e.clientY;
                canvas3d.requestPointerLock();
            });

            document.addEventListener('mouseup', () => {
                scene3d.mouseDown = false;
            });

            document.addEventListener('mousemove', (e) => {
                if (document.pointerLockElement === canvas3d) {
                    scene3d.camera.rotY += e.movementX * 0.002;
                    scene3d.camera.rotX = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1,
                        scene3d.camera.rotX - e.movementY * 0.002));
                }
            });

            document.addEventListener('keydown', (e) => {
                scene3d.keys[e.code] = true;
            });

            document.addEventListener('keyup', (e) => {
                scene3d.keys[e.code] = false;
            });

            document.addEventListener('pointerlockchange', () => {
                if (document.pointerLockElement !== canvas3d) {
                    // Pointer unlocked
                }
            });
        }

        function update3D() {
            if (!scene3d || state.viewMode !== '3d') return;

            const cam = scene3d.camera;
            const speed = scene3d.keys['ShiftLeft'] ? cam.speed * 2 : cam.speed;

            // Movement
            const forward = { x: Math.sin(cam.rotY), z: Math.cos(cam.rotY) };
            const right = { x: Math.cos(cam.rotY), z: -Math.sin(cam.rotY) };

            if (scene3d.keys['KeyW']) {
                cam.x += forward.x * speed;
                cam.z += forward.z * speed;
            }
            if (scene3d.keys['KeyS']) {
                cam.x -= forward.x * speed;
                cam.z -= forward.z * speed;
            }
            if (scene3d.keys['KeyA']) {
                cam.x -= right.x * speed;
                cam.z -= right.z * speed;
            }
            if (scene3d.keys['KeyD']) {
                cam.x += right.x * speed;
                cam.z += right.z * speed;
            }
            if (scene3d.keys['Space']) {
                cam.y += speed;
            }
            if (scene3d.keys['ControlLeft']) {
                cam.y = Math.max(5, cam.y - speed);
            }
        }

        function render3D() {
            if (!scene3d || state.viewMode !== '3d') return;

            const { canvas, ctx, camera } = scene3d;
            const { grid, gridWidth, gridHeight } = state;

            // Clear
            ctx.fillStyle = '#0a0a1f';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw gradient sky
            const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height / 2);
            skyGradient.addColorStop(0, '#0a0a2a');
            skyGradient.addColorStop(1, '#1a1a4a');
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height / 2);

            // Collect and sort buildings by distance
            const buildings = [];
            const cellSize = 8;

            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    const zone = grid[y * gridWidth + x];
                    if (zone === ZONES.EMPTY) continue;

                    const worldX = x * cellSize;
                    const worldZ = y * cellSize;

                    // Distance from camera
                    const dx = worldX - camera.x;
                    const dz = worldZ - camera.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);

                    // Only render nearby buildings
                    if (dist < 200) {
                        buildings.push({
                            x: worldX,
                            z: worldZ,
                            zone,
                            dist,
                            height: ZONE_HEIGHTS[zone] * cellSize
                        });
                    }
                }
            }

            // Sort by distance (far to near)
            buildings.sort((a, b) => b.dist - a.dist);

            // Render buildings
            buildings.forEach(bld => {
                const screenPos = worldToScreen(bld.x, 0, bld.z, camera, canvas);
                const screenTop = worldToScreen(bld.x, bld.height, bld.z, camera, canvas);

                if (screenPos.behind || screenTop.behind) return;

                const size = Math.max(2, 300 / bld.dist);
                const heightOnScreen = screenPos.y - screenTop.y;

                // Building color with distance fog
                const fogAmount = Math.min(0.8, bld.dist / 200);
                const baseColor = hexToRgb(ZONE_COLORS[bld.zone]);
                const fogColor = { r: 10, g: 10, b: 31 };

                const r = Math.round(baseColor.r * (1 - fogAmount) + fogColor.r * fogAmount);
                const g = Math.round(baseColor.g * (1 - fogAmount) + fogColor.g * fogAmount);
                const b = Math.round(baseColor.b * (1 - fogAmount) + fogColor.b * fogAmount);

                ctx.fillStyle = `rgb(${r},${g},${b})`;

                if (bld.zone === ZONES.WATER) {
                    // Water is flat
                    ctx.fillRect(screenPos.x - size/2, screenPos.y - size/4, size, size/2);
                } else if (bld.zone === ZONES.ROAD) {
                    // Roads are flat
                    ctx.fillStyle = `rgba(${r},${g},${b},0.8)`;
                    ctx.fillRect(screenPos.x - size/2, screenPos.y - 2, size, 4);
                } else {
                    // Buildings
                    ctx.fillRect(screenPos.x - size/2, screenTop.y, size, heightOnScreen);

                    // Building top (lighter)
                    ctx.fillStyle = `rgb(${Math.min(255, r + 30)},${Math.min(255, g + 30)},${Math.min(255, b + 30)})`;
                    ctx.fillRect(screenPos.x - size/2, screenTop.y, size, 2);
                }
            });

            // Draw ground plane horizon line
            ctx.strokeStyle = 'rgba(100, 100, 150, 0.3)';
            ctx.beginPath();
            ctx.moveTo(0, canvas.height / 2 + 50);
            ctx.lineTo(canvas.width, canvas.height / 2 + 50);
            ctx.stroke();
        }

        function worldToScreen(wx, wy, wz, camera, canvas) {
            // Transform to camera space
            let dx = wx - camera.x;
            let dy = wy - camera.y;
            let dz = wz - camera.z;

            // Rotate around Y axis (yaw)
            const cosY = Math.cos(-camera.rotY);
            const sinY = Math.sin(-camera.rotY);
            const rx = dx * cosY - dz * sinY;
            const rz = dx * sinY + dz * cosY;

            // Rotate around X axis (pitch)
            const cosX = Math.cos(-camera.rotX);
            const sinX = Math.sin(-camera.rotX);
            const ry = dy * cosX - rz * sinX;
            const finalZ = dy * sinX + rz * cosX;

            // Project to screen
            const fov = 400;
            const behind = finalZ <= 0;
            const z = Math.max(1, finalZ);

            const screenX = canvas.width / 2 + (rx * fov) / z;
            const screenY = canvas.height / 2 - (ry * fov) / z;

            return { x: screenX, y: screenY, behind };
        }

        // ============================================================
        // DATA PERSISTENCE
        // ============================================================
        function saveState() {
            const data = {
                grid: Array.from(state.grid),
                gridWidth: state.gridWidth,
                gridHeight: state.gridHeight,
                generation: state.generation,
                rules: state.rules,
                history: state.history.slice(-100),
                initialGrid: state.initialGrid ? Array.from(state.initialGrid) : null
            };

            localStorage.setItem(APP_NAME, JSON.stringify(data));
        }

        function loadState() {
            const saved = localStorage.getItem(APP_NAME);
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    state.gridWidth = data.gridWidth || 100;
                    state.gridHeight = data.gridHeight || 100;
                    state.grid = new Uint8Array(data.grid);
                    state.generation = data.generation || 0;
                    state.rules = data.rules || JSON.parse(JSON.stringify(DEFAULT_RULES));
                    state.history = data.history || [];
                    state.initialGrid = data.initialGrid ? new Uint8Array(data.initialGrid) : null;

                    // Initialize maps
                    const size = state.gridWidth * state.gridHeight;
                    state.pollutionMap = new Float32Array(size);
                    state.desirabilityMap = new Float32Array(size);

                    return true;
                } catch (e) {
                    console.error('Failed to load saved state:', e);
                }
            }
            return false;
        }

        function exportData() {
            const data = {
                version: 1,
                timestamp: new Date().toISOString(),
                grid: Array.from(state.grid),
                gridWidth: state.gridWidth,
                gridHeight: state.gridHeight,
                generation: state.generation,
                rules: state.rules,
                history: state.history
            };

            const dataStr = JSON.stringify(data, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            const link = document.createElement('a');
            link.href = url;
            link.download = `${APP_NAME}-${new Date().toISOString().split('T')[0]}.json`;
            link.click();

            URL.revokeObjectURL(url);
            showNotification('City exported successfully!', 'success');
        }

        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);

                    state.gridWidth = data.gridWidth || 100;
                    state.gridHeight = data.gridHeight || 100;
                    state.grid = new Uint8Array(data.grid);
                    state.generation = data.generation || 0;
                    state.rules = data.rules || JSON.parse(JSON.stringify(DEFAULT_RULES));
                    state.history = data.history || [];
                    state.initialGrid = new Uint8Array(data.grid);

                    const size = state.gridWidth * state.gridHeight;
                    state.pollutionMap = new Float32Array(size);
                    state.desirabilityMap = new Float32Array(size);

                    document.getElementById('generationCounter').textContent = state.generation;
                    updateStats();
                    render();
                    saveState();

                    showNotification('City imported successfully!', 'success');
                } catch (error) {
                    showNotification('Invalid file format', 'error');
                }
            };
            reader.readAsText(file);

            // Reset file input
            event.target.value = '';
        }

        function exportImage() {
            const link = document.createElement('a');
            link.download = `city-${state.generation}.png`;
            link.href = canvas2d.toDataURL('image/png');
            link.click();
            showNotification('Image exported!', 'success');
        }

        function exportCSV() {
            const stats = calculateStats();
            let csv = 'Metric,Value\n';
            csv += `Generation,${state.generation}\n`;
            csv += `Population,${stats.population}\n`;
            csv += `Residential,${stats.residential}\n`;
            csv += `Commercial,${stats.commercial}\n`;
            csv += `Industrial,${stats.industrial}\n`;
            csv += `Parks,${stats.park}\n`;
            csv += `Roads,${stats.road}\n`;
            csv += `Water,${stats.water}\n`;
            csv += `Pollution,${(stats.pollution * 100).toFixed(1)}%\n`;
            csv += `Desirability,${(stats.desirability * 100).toFixed(1)}%\n`;

            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `city-stats-${state.generation}.csv`;
            link.click();
            URL.revokeObjectURL(url);
            showNotification('Stats exported as CSV!', 'success');
        }

        // ============================================================
        // UI SETUP
        // ============================================================
        function setupUI() {
            // Zone buttons
            document.querySelectorAll('.zone-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const zoneIndex = ZONE_NAMES.indexOf(btn.dataset.zone);
                    selectZone(zoneIndex);
                });
            });

            // Brush size buttons
            document.querySelectorAll('.brush-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    state.brushSize = parseInt(btn.dataset.size);
                    document.querySelectorAll('.brush-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                });
            });

            // Preset buttons
            document.querySelectorAll('.preset-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    loadPreset(btn.dataset.preset);
                });
            });

            // Heatmap buttons
            document.querySelectorAll('.heatmap-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    state.currentHeatmap = btn.dataset.heatmap;
                    document.querySelectorAll('.heatmap-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    render();
                });
            });

            // Rule zone tabs
            document.querySelectorAll('.rule-zone-tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    state.currentRuleZone = tab.dataset.zone;
                    document.querySelectorAll('.rule-zone-tab').forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    updateRuleUI();
                });
            });

            // Rule sliders
            const ruleInputs = ['ruleMinSpawn', 'ruleMaxSpawn', 'ruleRoadReq', 'ruleGrowth'];
            ruleInputs.forEach(id => {
                const input = document.getElementById(id);
                input.addEventListener('input', () => {
                    updateRuleFromUI();
                });
            });

            // Rule presets
            document.querySelectorAll('.rule-preset-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    state.rules = JSON.parse(JSON.stringify(RULE_PRESETS[btn.dataset.ruleset]));
                    updateRuleUI();
                    showNotification(`Applied ${btn.dataset.ruleset} rules`, 'success');
                });
            });

            // Playback controls
            document.getElementById('btnPlayPause').addEventListener('click', togglePlay);
            document.getElementById('btnStep').addEventListener('click', step);
            document.getElementById('btnReset').addEventListener('click', reset);
            document.getElementById('btnFastForward').addEventListener('click', () => fastForward(100));

            // Speed slider
            const speedSlider = document.getElementById('speedSlider');
            speedSlider.addEventListener('input', () => {
                state.speed = parseInt(speedSlider.value);
                document.getElementById('speedValue').textContent = state.speed;
            });

            // View toggle
            document.getElementById('btn2D').addEventListener('click', () => {
                state.viewMode = '2d';
                document.getElementById('btn2D').classList.add('active');
                document.getElementById('btn3D').classList.remove('active');
                document.getElementById('canvas2d').style.display = 'block';
                document.getElementById('canvas3d').style.display = 'none';
                document.getElementById('controls3d').classList.remove('visible');
                render();
            });

            document.getElementById('btn3D').addEventListener('click', () => {
                state.viewMode = '3d';
                document.getElementById('btn3D').classList.add('active');
                document.getElementById('btn2D').classList.remove('active');
                document.getElementById('canvas2d').style.display = 'none';
                document.getElementById('canvas3d').style.display = 'block';
                document.getElementById('controls3d').classList.add('visible');
                if (!scene3d) init3D();
            });

            // Data controls
            document.getElementById('btnExport').addEventListener('click', exportData);
            document.getElementById('btnImport').addEventListener('click', () => {
                document.getElementById('importFile').click();
            });
            document.getElementById('importFile').addEventListener('change', importData);

            // Quick actions
            document.getElementById('btnClear').addEventListener('click', () => {
                state.grid.fill(0);
                state.initialGrid = null;
                state.generation = 0;
                state.history = [];
                document.getElementById('generationCounter').textContent = '0';
                updateStats();
                render();
                showNotification('City cleared', 'success');
            });

            document.getElementById('btnRandomSeed').addEventListener('click', () => {
                loadPreset('random');
            });

            document.getElementById('btnExportImage').addEventListener('click', exportImage);
            document.getElementById('btnExportCSV').addEventListener('click', exportCSV);

            // Help modal
            document.getElementById('btnHelp').addEventListener('click', () => {
                document.getElementById('helpModal').classList.add('visible');
            });

            document.getElementById('btnCloseHelp').addEventListener('click', () => {
                document.getElementById('helpModal').classList.remove('visible');
            });

            document.getElementById('helpModal').addEventListener('click', (e) => {
                if (e.target.id === 'helpModal') {
                    document.getElementById('helpModal').classList.remove('visible');
                }
            });
        }

        function updateRuleUI() {
            const rules = state.rules[state.currentRuleZone];
            if (!rules) return;

            document.getElementById('ruleMinSpawn').value = rules.minNeighbors;
            document.getElementById('ruleMinSpawnVal').textContent = rules.minNeighbors;

            document.getElementById('ruleMaxSpawn').value = rules.maxNeighbors;
            document.getElementById('ruleMaxSpawnVal').textContent = rules.maxNeighbors;

            document.getElementById('ruleRoadReq').value = rules.roadRequired;
            document.getElementById('ruleRoadReqVal').textContent = rules.roadRequired;

            document.getElementById('ruleGrowth').value = Math.round(rules.growthRate * 100);
            document.getElementById('ruleGrowthVal').textContent = Math.round(rules.growthRate * 100) + '%';
        }

        function updateRuleFromUI() {
            const rules = state.rules[state.currentRuleZone];
            if (!rules) return;

            rules.minNeighbors = parseInt(document.getElementById('ruleMinSpawn').value);
            rules.maxNeighbors = parseInt(document.getElementById('ruleMaxSpawn').value);
            rules.roadRequired = parseInt(document.getElementById('ruleRoadReq').value);
            rules.growthRate = parseInt(document.getElementById('ruleGrowth').value) / 100;

            document.getElementById('ruleMinSpawnVal').textContent = rules.minNeighbors;
            document.getElementById('ruleMaxSpawnVal').textContent = rules.maxNeighbors;
            document.getElementById('ruleRoadReqVal').textContent = rules.roadRequired;
            document.getElementById('ruleGrowthVal').textContent = Math.round(rules.growthRate * 100) + '%';
        }

        function showNotification(message, type = 'info') {
            const notification = document.getElementById('notification');
            const text = document.getElementById('notificationText');

            text.textContent = message;
            notification.className = 'notification visible ' + type;

            setTimeout(() => {
                notification.classList.remove('visible');
            }, 3000);
        }

        // ============================================================
        // MAIN LOOP
        // ============================================================
        function gameLoop(timestamp) {
            // Simulation tick
            if (state.isPlaying) {
                const tickInterval = 1000 / state.speed;
                if (timestamp - state.lastTickTime >= tickInterval) {
                    tick();
                    state.lastTickTime = timestamp;
                }
            }

            // 3D update and render
            if (state.viewMode === '3d') {
                update3D();
                render3D();
            }

            // Render 2D
            if (state.viewMode === '2d') {
                render();
            }

            // Auto-save every 30 seconds
            if (timestamp % 30000 < 16) {
                saveState();
            }

            animationId = requestAnimationFrame(gameLoop);
        }

        // ============================================================
        // INITIALIZATION
        // ============================================================
        function init() {
            // Try to load saved state, or initialize new grid
            if (!loadState()) {
                initGrid();
                // Show help modal on first visit
                setTimeout(() => {
                    document.getElementById('helpModal').classList.add('visible');
                }, 500);
            }

            initCanvas();
            setupUI();
            initInputHandlers();
            updateRuleUI();
            updateStats();

            // Center view
            state.panX = (canvas2d.width - state.gridWidth * state.cellSize * state.zoom) / 2;
            state.panY = (canvas2d.height - state.gridHeight * state.cellSize * state.zoom) / 2;

            // Start game loop
            animationId = requestAnimationFrame(gameLoop);

            console.log('Cellular Automata City Planner initialized');
        }

        // Start the application
        init();
    </script>
</body>
</html>
