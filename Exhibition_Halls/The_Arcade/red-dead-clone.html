<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Red Dead Frontier - Open World Western</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', serif;
            overflow: hidden;
            background: #1a1510;
            color: #f4e9d8;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100vh;
            cursor: crosshair;
        }

        /* HUD Container */
        #hud {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        /* Minimap */
        #minimap {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 200px;
            height: 200px;
            background: rgba(0, 0, 0, 0.7);
            border: 3px solid #8B4513;
            border-radius: 50%;
            overflow: hidden;
        }

        #minimapCanvas {
            width: 100%;
            height: 100%;
        }

        /* Stats Bars */
        .stats-container {
            position: absolute;
            top: 30px;
            left: 30px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .stat-bar {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .stat-label {
            font-size: 14px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            min-width: 80px;
            color: #f4e9d8;
        }

        .stat-bar-bg {
            width: 200px;
            height: 25px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #8B4513;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        .stat-bar-fill {
            height: 100%;
            transition: width 0.3s ease;
            position: relative;
        }

        .health-fill {
            background: linear-gradient(90deg, #c41e3a 0%, #ff6b6b 100%);
        }

        .stamina-fill {
            background: linear-gradient(90deg, #2a9d2a 0%, #4caf50 100%);
        }

        .deadeye-fill {
            background: linear-gradient(90deg, #d4af37 0%, #ffd700 100%);
        }

        .stat-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 12px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.9);
            z-index: 1;
        }

        /* Honor System */
        #honorMeter {
            position: absolute;
            top: 30px;
            right: 30px;
            text-align: center;
        }

        #honorBar {
            width: 200px;
            height: 30px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #8B4513;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        #honorFill {
            height: 100%;
            position: absolute;
            left: 0;
            transition: all 0.5s ease;
        }

        .honor-good {
            background: linear-gradient(90deg, #2a9d2a 0%, #4caf50 100%);
        }

        .honor-neutral {
            background: linear-gradient(90deg, #666 0%, #999 100%);
        }

        .honor-bad {
            background: linear-gradient(90deg, #8B0000 0%, #c41e3a 100%);
        }

        #honorText {
            position: relative;
            z-index: 1;
            font-size: 14px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            padding: 5px;
        }

        /* Weapon Wheel */
        #weaponWheel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 400px;
            height: 400px;
            display: none;
            pointer-events: auto;
        }

        #weaponWheel.active {
            display: block;
        }

        .weapon-slot {
            position: absolute;
            width: 80px;
            height: 80px;
            background: rgba(0, 0, 0, 0.8);
            border: 3px solid #8B4513;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 24px;
        }

        .weapon-slot:hover,
        .weapon-slot.selected {
            background: rgba(139, 69, 19, 0.9);
            transform: scale(1.1);
            border-color: #FFD700;
        }

        .weapon-name {
            position: absolute;
            bottom: -25px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
            white-space: nowrap;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        /* Current Weapon Display */
        #currentWeapon {
            position: absolute;
            bottom: 30px;
            right: 30px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #8B4513;
            padding: 15px 20px;
            border-radius: 8px;
            text-align: center;
        }

        #weaponName {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 5px;
        }

        #ammoCount {
            font-size: 14px;
            color: #FFD700;
        }

        /* Mission Display */
        #missionDisplay {
            position: absolute;
            top: 150px;
            left: 30px;
            max-width: 300px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #8B4513;
            padding: 15px;
            border-radius: 8px;
            display: none;
        }

        #missionDisplay.active {
            display: block;
        }

        #missionTitle {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #FFD700;
        }

        #missionObjective {
            font-size: 14px;
            line-height: 1.4;
        }

        /* Notifications */
        #notifications {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: none;
        }

        .notification {
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #8B4513;
            padding: 20px 30px;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            text-align: center;
            animation: fadeInOut 3s ease;
        }

        @keyframes fadeInOut {
            0%, 100% { opacity: 0; transform: translateY(20px); }
            10%, 90% { opacity: 1; transform: translateY(0); }
        }

        /* Controls Help */
        #controlsHelp {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #8B4513;
            padding: 15px 25px;
            border-radius: 8px;
            display: none;
            pointer-events: auto;
        }

        #controlsHelp.active {
            display: block;
        }

        .control-row {
            display: flex;
            gap: 20px;
            margin: 5px 0;
            font-size: 14px;
        }

        .control-key {
            font-weight: bold;
            color: #FFD700;
            min-width: 100px;
        }

        /* Menu */
        #menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            pointer-events: auto;
        }

        #menu.hidden {
            display: none;
        }

        .menu-title {
            font-size: 48px;
            font-weight: bold;
            margin-bottom: 40px;
            color: #8B4513;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.8);
            font-family: 'Georgia', serif;
        }

        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .menu-button {
            padding: 15px 40px;
            font-size: 20px;
            font-weight: bold;
            background: linear-gradient(135deg, #8B4513 0%, #654321 100%);
            color: #f4e9d8;
            border: 3px solid #654321;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-family: 'Georgia', serif;
            pointer-events: auto;
        }

        .menu-button:hover {
            background: linear-gradient(135deg, #A0522D 0%, #8B4513 100%);
            border-color: #FFD700;
            transform: scale(1.05);
        }

        /* Dead Eye Effect */
        #deadeyeOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(139, 69, 19, 0.3);
            display: none;
            pointer-events: none;
            z-index: 50;
        }

        #deadeyeOverlay.active {
            display: block;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 0.5; }
        }

        /* Crosshair */
        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 40px;
            pointer-events: none;
            z-index: 200;
        }

        .crosshair-line {
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
            box-shadow: 0 0 3px rgba(0,0,0,0.8);
        }

        .crosshair-h {
            width: 20px;
            height: 2px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .crosshair-v {
            width: 2px;
            height: 20px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        /* Horse Indicator */
        #horseIndicator {
            position: absolute;
            top: 200px;
            right: 30px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #8B4513;
            padding: 10px 15px;
            border-radius: 8px;
            display: none;
        }

        #horseIndicator.active {
            display: block;
        }

        /* Wanted Level */
        #wantedLevel {
            position: absolute;
            top: 100px;
            right: 30px;
            background: rgba(139, 0, 0, 0.8);
            border: 2px solid #8B0000;
            padding: 10px 15px;
            border-radius: 8px;
            display: none;
            font-weight: bold;
        }

        #wantedLevel.active {
            display: block;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Data Controls */
        .data-controls {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1001;
            display: flex;
            gap: 10px;
        }

        .data-controls button {
            padding: 8px 16px;
            background: linear-gradient(135deg, #8B4513 0%, #654321 100%);
            color: #f4e9d8;
            border: 2px solid #654321;
            border-radius: 6px;
            cursor: pointer;
            font-family: 'Georgia', serif;
            font-weight: bold;
            transition: all 0.3s;
            pointer-events: auto;
        }

        .data-controls button:hover {
            background: linear-gradient(135deg, #A0522D 0%, #8B4513 100%);
            border-color: #FFD700;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            #minimap {
                width: 120px;
                height: 120px;
                bottom: 15px;
                left: 15px;
            }

            .stats-container {
                top: 15px;
                left: 15px;
            }

            .stat-bar-bg {
                width: 150px;
                height: 20px;
            }

            #honorMeter {
                top: 15px;
                right: 15px;
            }

            #honorBar {
                width: 150px;
                height: 25px;
            }

            #currentWeapon {
                bottom: 15px;
                right: 15px;
                padding: 10px 15px;
            }

            .menu-title {
                font-size: 32px;
            }

            .menu-button {
                padding: 12px 30px;
                font-size: 16px;
            }
        }

        /* Loading Screen */
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #1a1510;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            flex-direction: column;
            gap: 20px;
        }

        #loading.hidden {
            display: none;
        }

        .loading-text {
            font-size: 24px;
            font-weight: bold;
            color: #8B4513;
        }

        .loading-bar {
            width: 300px;
            height: 20px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #8B4513;
            border-radius: 10px;
            overflow: hidden;
        }

        .loading-fill {
            height: 100%;
            background: linear-gradient(90deg, #8B4513 0%, #A0522D 100%);
            width: 0%;
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loading">
        <div class="loading-text">RED DEAD FRONTIER</div>
        <div class="loading-bar">
            <div class="loading-fill" id="loadingFill"></div>
        </div>
        <div class="loading-text" id="loadingStatus">Loading...</div>
    </div>

    <!-- Main Menu -->
    <div id="menu">
        <div class="menu-title">RED DEAD FRONTIER</div>
        <div class="menu-buttons">
            <button class="menu-button" onclick="startGame()">Start Game</button>
            <button class="menu-button" onclick="document.getElementById('importFile').click()">Load Game</button>
            <button class="menu-button" onclick="toggleControls()">Controls</button>
        </div>
    </div>

    <!-- Game Canvas -->
    <canvas id="gameCanvas"></canvas>

    <!-- HUD -->
    <div id="hud">
        <!-- Stats -->
        <div class="stats-container">
            <div class="stat-bar">
                <div class="stat-label">HEALTH</div>
                <div class="stat-bar-bg">
                    <div class="stat-bar-fill health-fill" id="healthBar" style="width: 100%;">
                        <div class="stat-text" id="healthText">100/100</div>
                    </div>
                </div>
            </div>
            <div class="stat-bar">
                <div class="stat-label">STAMINA</div>
                <div class="stat-bar-bg">
                    <div class="stat-bar-fill stamina-fill" id="staminaBar" style="width: 100%;">
                        <div class="stat-text" id="staminaText">100/100</div>
                    </div>
                </div>
            </div>
            <div class="stat-bar">
                <div class="stat-label">DEAD EYE</div>
                <div class="stat-bar-bg">
                    <div class="stat-bar-fill deadeye-fill" id="deadeyeBar" style="width: 100%;">
                        <div class="stat-text" id="deadeyeText">100/100</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Honor Meter -->
        <div id="honorMeter">
            <div id="honorBar">
                <div id="honorFill" class="honor-neutral" style="width: 50%;"></div>
                <div id="honorText">NEUTRAL</div>
            </div>
        </div>

        <!-- Minimap -->
        <div id="minimap">
            <canvas id="minimapCanvas" width="200" height="200"></canvas>
        </div>

        <!-- Current Weapon -->
        <div id="currentWeapon">
            <div id="weaponName">Cattleman Revolver</div>
            <div id="ammoCount">6 / 36</div>
        </div>

        <!-- Weapon Wheel -->
        <div id="weaponWheel">
            <div class="weapon-slot selected" style="top: 10px; left: 160px;" data-weapon="revolver">
                üî´
                <div class="weapon-name">Revolver</div>
            </div>
            <div class="weapon-slot" style="top: 80px; left: 280px;" data-weapon="rifle">
                üéØ
                <div class="weapon-name">Rifle</div>
            </div>
            <div class="weapon-slot" style="top: 240px; left: 280px;" data-weapon="shotgun">
                üí•
                <div class="weapon-name">Shotgun</div>
            </div>
            <div class="weapon-slot" style="top: 310px; left: 160px;" data-weapon="bow">
                üèπ
                <div class="weapon-name">Bow</div>
            </div>
            <div class="weapon-slot" style="top: 240px; left: 40px;" data-weapon="knife">
                üî™
                <div class="weapon-name">Knife</div>
            </div>
            <div class="weapon-slot" style="top: 80px; left: 40px;" data-weapon="lasso">
                ü™¢
                <div class="weapon-name">Lasso</div>
            </div>
        </div>

        <!-- Mission Display -->
        <div id="missionDisplay">
            <div id="missionTitle">Mission Name</div>
            <div id="missionObjective">Mission objective goes here</div>
        </div>

        <!-- Horse Indicator -->
        <div id="horseIndicator">
            <div>üê¥ Horse Bonding: <span id="horseBonding">Level 1</span></div>
            <div>Horse Stamina: <span id="horseStamina">100%</span></div>
        </div>

        <!-- Wanted Level -->
        <div id="wantedLevel">
            ‚≠ê WANTED ‚≠ê
        </div>

        <!-- Crosshair -->
        <div id="crosshair">
            <div class="crosshair-line crosshair-h"></div>
            <div class="crosshair-line crosshair-v"></div>
        </div>

        <!-- Notifications -->
        <div id="notifications"></div>

        <!-- Controls Help -->
        <div id="controlsHelp">
            <div class="control-row">
                <span class="control-key">WASD</span>
                <span>Move / Ride Horse</span>
            </div>
            <div class="control-row">
                <span class="control-key">Shift</span>
                <span>Sprint / Gallop</span>
            </div>
            <div class="control-row">
                <span class="control-key">Space</span>
                <span>Jump</span>
            </div>
            <div class="control-row">
                <span class="control-key">E</span>
                <span>Mount/Dismount Horse</span>
            </div>
            <div class="control-row">
                <span class="control-key">H</span>
                <span>Whistle for Horse</span>
            </div>
            <div class="control-row">
                <span class="control-key">Mouse</span>
                <span>Look Around</span>
            </div>
            <div class="control-row">
                <span class="control-key">Left Click</span>
                <span>Shoot / Attack</span>
            </div>
            <div class="control-row">
                <span class="control-key">Right Click</span>
                <span>Aim</span>
            </div>
            <div class="control-row">
                <span class="control-key">Q</span>
                <span>Dead Eye</span>
            </div>
            <div class="control-row">
                <span class="control-key">Tab</span>
                <span>Weapon Wheel</span>
            </div>
            <div class="control-row">
                <span class="control-key">F</span>
                <span>Interact</span>
            </div>
            <div class="control-row">
                <span class="control-key">C</span>
                <span>Crouch</span>
            </div>
            <div class="control-row">
                <span class="control-key">ESC</span>
                <span>Menu</span>
            </div>
            <div class="control-row">
                <span class="control-key">F1</span>
                <span>Toggle Help</span>
            </div>
        </div>

        <!-- Dead Eye Overlay -->
        <div id="deadeyeOverlay"></div>
    </div>

    <!-- Data Controls -->
    <div class="data-controls">
        <button onclick="exportData()">Export Save</button>
        <button onclick="document.getElementById('importFile').click()">Import Save</button>
        <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importData(event)">
    </div>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <!-- Game Code -->
    <script>
        // ================================
        // CORE GAME SETUP
        // ================================
        const APP_NAME = 'red-dead-frontier';
        let scene, camera, renderer, clock;
        let world, player, horse, npcs = [], wildlife = [];
        let keys = {}, mouseMovement = { x: 0, y: 0 };
        let gameState = {
            isPlaying: false,
            isPointerLocked: false,
            time: 0,
            weather: 'clear',
            playerStats: {
                health: 100,
                maxHealth: 100,
                stamina: 100,
                maxStamina: 100,
                deadEye: 100,
                maxDeadEye: 100
            },
            honor: 50,
            wanted: 0,
            onHorse: false,
            currentWeapon: 'revolver',
            inventory: {
                revolver: { name: 'Cattleman Revolver', ammo: 6, maxAmmo: 6, totalAmmo: 36, damage: 30 },
                rifle: { name: 'Lancaster Repeater', ammo: 14, maxAmmo: 14, totalAmmo: 60, damage: 40 },
                shotgun: { name: 'Pump Shotgun', ammo: 5, maxAmmo: 5, totalAmmo: 25, damage: 60 },
                bow: { name: 'Hunting Bow', ammo: 1, maxAmmo: 1, totalAmmo: 20, damage: 50 },
                knife: { name: 'Hunting Knife', ammo: 999, maxAmmo: 999, totalAmmo: 999, damage: 80 },
                lasso: { name: 'Lasso', ammo: 1, maxAmmo: 1, totalAmmo: 1, damage: 0 }
            },
            missions: [],
            currentMission: null,
            horseData: {
                bonding: 1,
                stamina: 100,
                maxStamina: 100,
                speed: 1.0
            }
        };

        let deadEyeActive = false;
        let deadEyeTargets = [];
        let isAiming = false;
        let isCrouching = false;

        // ================================
        // INITIALIZATION
        // ================================
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 100, 500);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 10);

            // Renderer
            const canvas = document.getElementById('gameCanvas');
            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // Clock
            clock = new THREE.Clock();

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const sunLight = new THREE.DirectionalLight(0xfff4e6, 0.8);
            sunLight.position.set(50, 100, 50);
            sunLight.castShadow = true;
            sunLight.shadow.camera.left = -100;
            sunLight.shadow.camera.right = 100;
            sunLight.shadow.camera.top = 100;
            sunLight.shadow.camera.bottom = -100;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            scene.add(sunLight);

            // Create World
            createWorld();

            // Create Player
            createPlayer();

            // Create Horse
            createHorse();

            // Create NPCs
            createNPCs();

            // Create Wildlife
            createWildlife();

            // Create Missions
            initializeMissions();

            // Event Listeners
            setupEventListeners();

            // Update HUD
            updateHUD();

            // Hide loading screen
            setTimeout(() => {
                document.getElementById('loading').classList.add('hidden');
            }, 1000);
        }

        // ================================
        // WORLD CREATION
        // ================================
        function createWorld() {
            world = {
                terrain: null,
                buildings: [],
                vegetation: [],
                rocks: []
            };

            // Ground
            const groundGeometry = new THREE.PlaneGeometry(1000, 1000, 50, 50);
            const vertices = groundGeometry.attributes.position.array;

            // Create terrain with hills
            for (let i = 0; i < vertices.length; i += 3) {
                const x = vertices[i];
                const y = vertices[i + 1];
                vertices[i + 2] = Math.sin(x * 0.02) * Math.cos(y * 0.02) * 5 +
                                  Math.random() * 2;
            }
            groundGeometry.computeVertexNormals();

            const groundMaterial = new THREE.MeshLambertMaterial({
                color: 0xc2b280,
                flatShading: true
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            world.terrain = ground;

            // Town buildings
            createTown();

            // Trees
            for (let i = 0; i < 100; i++) {
                const tree = createTree();
                const angle = Math.random() * Math.PI * 2;
                const distance = 50 + Math.random() * 400;
                tree.position.x = Math.cos(angle) * distance;
                tree.position.z = Math.sin(angle) * distance;
                tree.position.y = 0;
                scene.add(tree);
                world.vegetation.push(tree);
            }

            // Cacti
            for (let i = 0; i < 50; i++) {
                const cactus = createCactus();
                const angle = Math.random() * Math.PI * 2;
                const distance = 50 + Math.random() * 400;
                cactus.position.x = Math.cos(angle) * distance;
                cactus.position.z = Math.sin(angle) * distance;
                cactus.position.y = 0;
                scene.add(cactus);
                world.vegetation.push(cactus);
            }

            // Rocks
            for (let i = 0; i < 80; i++) {
                const rock = createRock();
                const angle = Math.random() * Math.PI * 2;
                const distance = 30 + Math.random() * 450;
                rock.position.x = Math.cos(angle) * distance;
                rock.position.z = Math.sin(angle) * distance;
                rock.position.y = 0;
                scene.add(rock);
                world.rocks.push(rock);
            }
        }

        function createTown() {
            const townCenter = { x: 0, z: 0 };

            // Saloon
            const saloon = createBuilding(20, 12, 15, 0x8B4513);
            saloon.position.set(townCenter.x - 30, 6, townCenter.z);
            scene.add(saloon);
            world.buildings.push({ mesh: saloon, type: 'saloon' });

            // Sheriff's Office
            const sheriff = createBuilding(12, 10, 10, 0xA0522D);
            sheriff.position.set(townCenter.x + 30, 5, townCenter.z);
            scene.add(sheriff);
            world.buildings.push({ mesh: sheriff, type: 'sheriff' });

            // General Store
            const store = createBuilding(15, 10, 12, 0xCD853F);
            store.position.set(townCenter.x, 5, townCenter.z - 30);
            scene.add(store);
            world.buildings.push({ mesh: store, type: 'store' });

            // Bank
            const bank = createBuilding(18, 12, 14, 0xDEB887);
            bank.position.set(townCenter.x, 6, townCenter.z + 30);
            scene.add(bank);
            world.buildings.push({ mesh: bank, type: 'bank' });

            // Houses
            for (let i = 0; i < 8; i++) {
                const house = createBuilding(8, 8, 8, 0xD2691E);
                const angle = (i / 8) * Math.PI * 2;
                const distance = 50;
                house.position.set(
                    townCenter.x + Math.cos(angle) * distance,
                    4,
                    townCenter.z + Math.sin(angle) * distance
                );
                scene.add(house);
                world.buildings.push({ mesh: house, type: 'house' });
            }
        }

        function createBuilding(width, height, depth, color) {
            const building = new THREE.Group();

            // Main structure
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const material = new THREE.MeshLambertMaterial({ color });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            building.add(mesh);

            // Roof
            const roofGeometry = new THREE.ConeGeometry(width * 0.7, height * 0.3, 4);
            const roofMaterial = new THREE.MeshLambertMaterial({ color: 0x8B0000 });
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.position.y = height * 0.65;
            roof.rotation.y = Math.PI / 4;
            roof.castShadow = true;
            building.add(roof);

            return building;
        }

        function createTree() {
            const tree = new THREE.Group();

            // Trunk
            const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.7, 6, 8);
            const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x4a2511 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 3;
            trunk.castShadow = true;
            tree.add(trunk);

            // Foliage
            const foliageGeometry = new THREE.SphereGeometry(3, 8, 8);
            const foliageMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
            const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
            foliage.position.y = 7;
            foliage.castShadow = true;
            foliage.scale.y = 1.5;
            tree.add(foliage);

            return tree;
        }

        function createCactus() {
            const cactus = new THREE.Group();

            // Main body
            const bodyGeometry = new THREE.CylinderGeometry(0.8, 1, 5, 8);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x2F4F2F });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 2.5;
            body.castShadow = true;
            cactus.add(body);

            // Arms
            const armGeometry = new THREE.CylinderGeometry(0.5, 0.6, 2, 6);
            const armMaterial = new THREE.MeshLambertMaterial({ color: 0x2F4F2F });

            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-1.2, 3, 0);
            leftArm.rotation.z = Math.PI / 4;
            leftArm.castShadow = true;
            cactus.add(leftArm);

            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(1.2, 3.5, 0);
            rightArm.rotation.z = -Math.PI / 4;
            rightArm.castShadow = true;
            cactus.add(rightArm);

            return cactus;
        }

        function createRock() {
            const geometry = new THREE.DodecahedronGeometry(1 + Math.random() * 2, 0);
            const material = new THREE.MeshLambertMaterial({
                color: 0x808080,
                flatShading: true
            });
            const rock = new THREE.Mesh(geometry, material);
            rock.castShadow = true;
            rock.receiveShadow = true;
            rock.scale.y = 0.5 + Math.random() * 0.5;
            return rock;
        }

        // ================================
        // PLAYER CREATION
        // ================================
        function createPlayer() {
            player = {
                mesh: new THREE.Group(),
                velocity: new THREE.Vector3(),
                position: new THREE.Vector3(0, 2, 0),
                rotation: 0,
                moveSpeed: 0.15,
                runSpeed: 0.25,
                crouchSpeed: 0.08,
                jumpPower: 0.3,
                isGrounded: true
            };

            // Body
            const bodyGeometry = new THREE.CapsuleGeometry(0.5, 1.5, 4, 8);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x4169E1 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = true;
            player.mesh.add(body);

            // Head
            const headGeometry = new THREE.SphereGeometry(0.4, 8, 8);
            const headMaterial = new THREE.MeshLambertMaterial({ color: 0xFFDBAC });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.5;
            head.castShadow = true;
            player.mesh.add(head);

            // Hat
            const hatGeometry = new THREE.CylinderGeometry(0.6, 0.6, 0.3, 8);
            const hatMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const hat = new THREE.Mesh(hatGeometry, hatMaterial);
            hat.position.y = 1.9;
            hat.castShadow = true;
            player.mesh.add(hat);

            player.mesh.position.copy(player.position);
            scene.add(player.mesh);
        }

        // ================================
        // HORSE CREATION
        // ================================
        function createHorse() {
            horse = {
                mesh: new THREE.Group(),
                position: new THREE.Vector3(5, 0, 5),
                velocity: new THREE.Vector3(),
                rotation: 0,
                isBeingRidden: false,
                comeToPlayer: false
            };

            // Body
            const bodyGeometry = new THREE.BoxGeometry(1.5, 1.2, 3);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 1.5;
            body.castShadow = true;
            horse.mesh.add(body);

            // Head
            const headGeometry = new THREE.BoxGeometry(0.8, 0.8, 1.2);
            const headMaterial = new THREE.MeshLambertMaterial({ color: 0x654321 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.set(0, 1.8, 2);
            head.castShadow = true;
            horse.mesh.add(head);

            // Legs
            const legGeometry = new THREE.CylinderGeometry(0.15, 0.2, 1.5, 6);
            const legMaterial = new THREE.MeshLambertMaterial({ color: 0x654321 });

            const positions = [
                [-0.5, 0.75, 1],
                [0.5, 0.75, 1],
                [-0.5, 0.75, -1],
                [0.5, 0.75, -1]
            ];

            positions.forEach(pos => {
                const leg = new THREE.Mesh(legGeometry, legMaterial);
                leg.position.set(...pos);
                leg.castShadow = true;
                horse.mesh.add(leg);
            });

            horse.mesh.position.copy(horse.position);
            scene.add(horse.mesh);
        }

        // ================================
        // NPC CREATION
        // ================================
        function createNPCs() {
            const npcTypes = [
                { type: 'civilian', color: 0x8B4513, hostile: false },
                { type: 'civilian', color: 0xA0522D, hostile: false },
                { type: 'lawman', color: 0x4169E1, hostile: false },
                { type: 'bandit', color: 0x8B0000, hostile: true }
            ];

            for (let i = 0; i < 15; i++) {
                const npcData = npcTypes[Math.floor(Math.random() * npcTypes.length)];
                const npc = createNPC(npcData);

                const angle = Math.random() * Math.PI * 2;
                const distance = 10 + Math.random() * 40;
                npc.position.set(
                    Math.cos(angle) * distance,
                    1,
                    Math.sin(angle) * distance
                );

                npcs.push(npc);
            }
        }

        function createNPC(data) {
            const npc = {
                mesh: new THREE.Group(),
                position: new THREE.Vector3(),
                velocity: new THREE.Vector3(),
                rotation: Math.random() * Math.PI * 2,
                type: data.type,
                hostile: data.hostile,
                health: 100,
                state: 'idle',
                target: null,
                wanderTimer: 0,
                shootTimer: 0
            };

            // Body
            const bodyGeometry = new THREE.CapsuleGeometry(0.4, 1.2, 4, 8);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: data.color });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = true;
            npc.mesh.add(body);

            // Head
            const headGeometry = new THREE.SphereGeometry(0.3, 8, 8);
            const headMaterial = new THREE.MeshLambertMaterial({ color: 0xFFDBAC });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.2;
            head.castShadow = true;
            npc.mesh.add(head);

            // Hat
            const hatGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.2, 8);
            const hatMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });
            const hat = new THREE.Mesh(hatGeometry, hatMaterial);
            hat.position.y = 1.5;
            hat.castShadow = true;
            npc.mesh.add(hat);

            scene.add(npc.mesh);
            return npc;
        }

        // ================================
        // WILDLIFE CREATION
        // ================================
        function createWildlife() {
            const animalTypes = ['deer', 'rabbit', 'bird'];

            for (let i = 0; i < 20; i++) {
                const type = animalTypes[Math.floor(Math.random() * animalTypes.length)];
                const animal = createAnimal(type);

                const angle = Math.random() * Math.PI * 2;
                const distance = 50 + Math.random() * 300;
                animal.position.set(
                    Math.cos(angle) * distance,
                    type === 'bird' ? 10 + Math.random() * 20 : 0,
                    Math.sin(angle) * distance
                );

                wildlife.push(animal);
            }
        }

        function createAnimal(type) {
            const animal = {
                mesh: new THREE.Group(),
                position: new THREE.Vector3(),
                velocity: new THREE.Vector3(),
                type: type,
                fleeDistance: 20,
                state: 'wander',
                wanderTimer: 0
            };

            let color, size;
            switch(type) {
                case 'deer':
                    color = 0x8B4513;
                    size = 1;
                    break;
                case 'rabbit':
                    color = 0xA0522D;
                    size = 0.3;
                    break;
                case 'bird':
                    color = 0x000000;
                    size = 0.2;
                    break;
            }

            const geometry = new THREE.BoxGeometry(size, size * 0.6, size * 1.5);
            const material = new THREE.MeshLambertMaterial({ color });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;
            animal.mesh.add(mesh);

            scene.add(animal.mesh);
            return animal;
        }

        // ================================
        // MISSION SYSTEM
        // ================================
        function initializeMissions() {
            gameState.missions = [
                {
                    id: 'intro',
                    title: 'Welcome to the Frontier',
                    description: 'Explore the town and get familiar with your surroundings',
                    objectives: ['Mount your horse', 'Ride to the saloon'],
                    completed: false,
                    active: false
                },
                {
                    id: 'bounty1',
                    title: 'Wanted: Dead or Alive',
                    description: 'Track down and eliminate the bandit hideout',
                    objectives: ['Find the bandit camp', 'Eliminate all bandits'],
                    completed: false,
                    active: false
                },
                {
                    id: 'hunt1',
                    title: 'The Hunter',
                    description: 'Hunt wildlife for food and materials',
                    objectives: ['Hunt 3 deer', 'Return to camp'],
                    completed: false,
                    active: false
                }
            ];
        }

        function startMission(missionId) {
            const mission = gameState.missions.find(m => m.id === missionId);
            if (mission && !mission.completed) {
                mission.active = true;
                gameState.currentMission = mission;
                updateMissionDisplay();
                showNotification(`Mission Started: ${mission.title}`);
            }
        }

        function updateMissionDisplay() {
            const display = document.getElementById('missionDisplay');
            if (gameState.currentMission) {
                display.classList.add('active');
                document.getElementById('missionTitle').textContent = gameState.currentMission.title;
                document.getElementById('missionObjective').textContent =
                    gameState.currentMission.objectives.join('\n');
            } else {
                display.classList.remove('active');
            }
        }

        // ================================
        // EVENT LISTENERS
        // ================================
        function setupEventListeners() {
            // Keyboard
            document.addEventListener('keydown', (e) => {
                keys[e.key.toLowerCase()] = true;

                if (e.key === 'Escape') {
                    toggleMenu();
                }
                if (e.key === 'F1') {
                    toggleControls();
                }
                if (e.key.toLowerCase() === 'tab') {
                    e.preventDefault();
                    toggleWeaponWheel();
                }
                if (e.key.toLowerCase() === 'q' && !deadEyeActive) {
                    activateDeadEye();
                }
                if (e.key.toLowerCase() === 'e') {
                    toggleHorse();
                }
                if (e.key.toLowerCase() === 'h') {
                    whistleHorse();
                }
                if (e.key.toLowerCase() === 'c') {
                    isCrouching = !isCrouching;
                }
            });

            document.addEventListener('keyup', (e) => {
                keys[e.key.toLowerCase()] = false;

                if (e.key.toLowerCase() === 'q') {
                    deactivateDeadEye();
                }
            });

            // Mouse
            document.addEventListener('mousedown', (e) => {
                if (!gameState.isPlaying) return;

                if (e.button === 0) { // Left click
                    shoot();
                } else if (e.button === 2) { // Right click
                    isAiming = true;
                }
            });

            document.addEventListener('mouseup', (e) => {
                if (e.button === 2) {
                    isAiming = false;
                }
            });

            document.addEventListener('mousemove', (e) => {
                if (gameState.isPointerLocked) {
                    mouseMovement.x = e.movementX || 0;
                    mouseMovement.y = e.movementY || 0;
                }
            });

            document.addEventListener('contextmenu', (e) => e.preventDefault());

            // Pointer lock
            const canvas = document.getElementById('gameCanvas');
            canvas.addEventListener('click', () => {
                if (gameState.isPlaying && !gameState.isPointerLocked) {
                    canvas.requestPointerLock();
                }
            });

            document.addEventListener('pointerlockchange', () => {
                gameState.isPointerLocked = document.pointerLockElement === canvas;
            });

            // Window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            // Weapon wheel selection
            document.querySelectorAll('.weapon-slot').forEach(slot => {
                slot.addEventListener('click', () => {
                    const weapon = slot.dataset.weapon;
                    selectWeapon(weapon);
                });
            });
        }

        // ================================
        // GAME LOOP
        // ================================
        function animate() {
            requestAnimationFrame(animate);

            if (!gameState.isPlaying) {
                renderer.render(scene, camera);
                return;
            }

            const delta = clock.getDelta();
            gameState.time += delta;

            // Update player
            updatePlayer(delta);

            // Update horse
            updateHorse(delta);

            // Update NPCs
            updateNPCs(delta);

            // Update wildlife
            updateWildlife(delta);

            // Update camera
            updateCamera();

            // Update environment
            updateEnvironment();

            // Update HUD
            updateHUD();

            // Update minimap
            updateMinimap();

            // Regenerate stats
            regenerateStats(delta);

            // Render
            renderer.render(scene, camera);
        }

        // ================================
        // PLAYER UPDATE
        // ================================
        function updatePlayer(delta) {
            if (gameState.onHorse) {
                updatePlayerOnHorse(delta);
                return;
            }

            const moveSpeed = isCrouching ? player.crouchSpeed :
                             (keys['shift'] ? player.runSpeed : player.moveSpeed);

            // Movement
            const forward = new THREE.Vector3(0, 0, -1);
            const right = new THREE.Vector3(1, 0, 0);

            forward.applyAxisAngle(new THREE.Vector3(0, 1, 0), player.rotation);
            right.applyAxisAngle(new THREE.Vector3(0, 1, 0), player.rotation);

            player.velocity.x *= 0.9;
            player.velocity.z *= 0.9;

            if (keys['w']) {
                player.velocity.add(forward.multiplyScalar(moveSpeed));
                if (keys['shift'] && gameState.playerStats.stamina > 0) {
                    gameState.playerStats.stamina -= delta * 10;
                }
            }
            if (keys['s']) {
                player.velocity.add(forward.multiplyScalar(-moveSpeed * 0.7));
            }
            if (keys['a']) {
                player.velocity.add(right.multiplyScalar(-moveSpeed));
            }
            if (keys['d']) {
                player.velocity.add(right.multiplyScalar(moveSpeed));
            }

            // Jump
            if (keys[' '] && player.isGrounded && gameState.playerStats.stamina > 20) {
                player.velocity.y = player.jumpPower;
                player.isGrounded = false;
                gameState.playerStats.stamina -= 20;
            }

            // Gravity
            player.velocity.y -= 0.02;

            // Update position
            player.position.add(player.velocity);

            // Ground collision
            if (player.position.y <= 2) {
                player.position.y = 2;
                player.velocity.y = 0;
                player.isGrounded = true;
            }

            // Update mesh
            player.mesh.position.copy(player.position);
            player.mesh.rotation.y = player.rotation;
        }

        function updatePlayerOnHorse(delta) {
            const moveSpeed = keys['shift'] ? 0.4 : 0.2;

            const forward = new THREE.Vector3(0, 0, -1);
            const right = new THREE.Vector3(1, 0, 0);

            forward.applyAxisAngle(new THREE.Vector3(0, 1, 0), horse.rotation);
            right.applyAxisAngle(new THREE.Vector3(0, 1, 0), horse.rotation);

            horse.velocity.x *= 0.95;
            horse.velocity.z *= 0.95;

            if (keys['w']) {
                horse.velocity.add(forward.multiplyScalar(moveSpeed * gameState.horseData.speed));
                if (keys['shift'] && gameState.horseData.stamina > 0) {
                    gameState.horseData.stamina -= delta * 15;
                }
            }
            if (keys['s']) {
                horse.velocity.add(forward.multiplyScalar(-moveSpeed * 0.5));
            }
            if (keys['a']) {
                horse.rotation += delta * 2;
                player.rotation = horse.rotation;
            }
            if (keys['d']) {
                horse.rotation -= delta * 2;
                player.rotation = horse.rotation;
            }

            horse.position.add(horse.velocity);
            horse.mesh.position.copy(horse.position);
            horse.mesh.rotation.y = horse.rotation;

            // Player follows horse
            player.position.copy(horse.position);
            player.position.y += 2;
            player.mesh.position.copy(player.position);
            player.mesh.rotation.y = player.rotation;
        }

        // ================================
        // HORSE UPDATE
        // ================================
        function updateHorse(delta) {
            if (gameState.onHorse) {
                document.getElementById('horseIndicator').classList.add('active');
                return;
            }

            document.getElementById('horseIndicator').classList.remove('active');

            // Come to player when whistled
            if (horse.comeToPlayer) {
                const direction = new THREE.Vector3()
                    .subVectors(player.position, horse.position)
                    .normalize();

                const distance = horse.position.distanceTo(player.position);

                if (distance > 3) {
                    horse.velocity.copy(direction.multiplyScalar(0.15));
                    horse.rotation = Math.atan2(direction.x, direction.z);
                } else {
                    horse.comeToPlayer = false;
                    horse.velocity.set(0, 0, 0);
                }
            }

            horse.position.add(horse.velocity);
            horse.velocity.multiplyScalar(0.95);
            horse.mesh.position.copy(horse.position);
            horse.mesh.rotation.y = horse.rotation;
        }

        // ================================
        // NPC UPDATE
        // ================================
        function updateNPCs(delta) {
            npcs.forEach(npc => {
                npc.wanderTimer -= delta;
                npc.shootTimer -= delta;

                const distanceToPlayer = npc.mesh.position.distanceTo(player.position);

                // Check if player is wanted and npc is lawman
                if (gameState.wanted > 0 && npc.type === 'lawman') {
                    npc.hostile = true;
                }

                // AI behavior
                if (npc.hostile && distanceToPlayer < 50) {
                    // Chase and attack player
                    const direction = new THREE.Vector3()
                        .subVectors(player.position, npc.mesh.position)
                        .normalize();

                    if (distanceToPlayer > 10) {
                        npc.velocity.copy(direction.multiplyScalar(0.08));
                        npc.rotation = Math.atan2(direction.x, direction.z);
                    } else {
                        npc.velocity.set(0, 0, 0);

                        // Shoot at player
                        if (npc.shootTimer <= 0) {
                            npcShoot(npc);
                            npc.shootTimer = 1 + Math.random();
                        }
                    }
                } else {
                    // Wander behavior
                    if (npc.wanderTimer <= 0) {
                        npc.rotation = Math.random() * Math.PI * 2;
                        npc.wanderTimer = 2 + Math.random() * 3;
                    }

                    const forward = new THREE.Vector3(0, 0, -1);
                    forward.applyAxisAngle(new THREE.Vector3(0, 1, 0), npc.rotation);
                    npc.velocity.copy(forward.multiplyScalar(0.03));
                }

                npc.position.copy(npc.mesh.position);
                npc.position.add(npc.velocity);
                npc.mesh.position.copy(npc.position);
                npc.mesh.rotation.y = npc.rotation;

                // Remove dead NPCs
                if (npc.health <= 0) {
                    scene.remove(npc.mesh);
                    npcs.splice(npcs.indexOf(npc), 1);
                }
            });
        }

        function npcShoot(npc) {
            // NPC shoots at player
            const damage = 10 + Math.random() * 10;
            const accuracy = 0.7;

            if (Math.random() < accuracy) {
                gameState.playerStats.health -= damage;
                showNotification(`Hit! -${Math.floor(damage)} HP`);

                if (gameState.playerStats.health <= 0) {
                    gameOver();
                }
            }
        }

        // ================================
        // WILDLIFE UPDATE
        // ================================
        function updateWildlife(delta) {
            wildlife.forEach(animal => {
                animal.wanderTimer -= delta;

                const distanceToPlayer = animal.mesh.position.distanceTo(player.position);

                // Flee from player
                if (distanceToPlayer < animal.fleeDistance) {
                    const direction = new THREE.Vector3()
                        .subVectors(animal.mesh.position, player.position)
                        .normalize();

                    animal.velocity.copy(direction.multiplyScalar(0.15));
                } else {
                    // Wander
                    if (animal.wanderTimer <= 0) {
                        if (animal.type === 'bird') {
                            animal.velocity.set(
                                (Math.random() - 0.5) * 0.1,
                                (Math.random() - 0.5) * 0.05,
                                (Math.random() - 0.5) * 0.1
                            );
                        } else {
                            const angle = Math.random() * Math.PI * 2;
                            animal.velocity.set(
                                Math.cos(angle) * 0.05,
                                0,
                                Math.sin(angle) * 0.05
                            );
                        }
                        animal.wanderTimer = 2 + Math.random() * 3;
                    }
                }

                animal.position.copy(animal.mesh.position);
                animal.position.add(animal.velocity);

                // Keep birds in air
                if (animal.type === 'bird') {
                    if (animal.position.y < 5) animal.position.y = 5;
                    if (animal.position.y > 40) animal.position.y = 40;
                }

                animal.mesh.position.copy(animal.position);
                animal.velocity.multiplyScalar(0.98);
            });
        }

        // ================================
        // CAMERA UPDATE
        // ================================
        function updateCamera() {
            // Rotate camera with mouse
            player.rotation -= mouseMovement.x * 0.002;

            const verticalAngle = Math.max(-Math.PI / 3,
                                  Math.min(Math.PI / 3,
                                  -mouseMovement.y * 0.002));

            mouseMovement.x = 0;
            mouseMovement.y = 0;

            // Position camera behind player
            const distance = isAiming ? 3 : 8;
            const height = isCrouching ? 1.5 : 2.5;

            camera.position.x = player.position.x + Math.sin(player.rotation) * distance;
            camera.position.z = player.position.z + Math.cos(player.rotation) * distance;
            camera.position.y = player.position.y + height;

            // Look at player
            const lookTarget = new THREE.Vector3(
                player.position.x - Math.sin(player.rotation) * 2,
                player.position.y + 1,
                player.position.z - Math.cos(player.rotation) * 2
            );
            camera.lookAt(lookTarget);
        }

        // ================================
        // ENVIRONMENT UPDATE
        // ================================
        function updateEnvironment() {
            // Day/night cycle
            const dayTime = (gameState.time % 120) / 120; // 2 minute day cycle
            const sunIntensity = Math.abs(Math.sin(dayTime * Math.PI));

            scene.children.forEach(child => {
                if (child instanceof THREE.DirectionalLight) {
                    child.intensity = 0.4 + sunIntensity * 0.6;
                }
            });

            // Sky color changes
            const skyColor = new THREE.Color();
            if (dayTime < 0.25) { // Night
                skyColor.setHex(0x001a33);
            } else if (dayTime < 0.3) { // Dawn
                skyColor.setHex(0xff6b35);
            } else if (dayTime < 0.7) { // Day
                skyColor.setHex(0x87CEEB);
            } else if (dayTime < 0.75) { // Dusk
                skyColor.setHex(0xff6b35);
            } else { // Night
                skyColor.setHex(0x001a33);
            }

            scene.background = skyColor;
            scene.fog.color = skyColor;
        }

        // ================================
        // COMBAT SYSTEM
        // ================================
        function shoot() {
            const weapon = gameState.inventory[gameState.currentWeapon];

            if (weapon.ammo <= 0) {
                reload();
                return;
            }

            weapon.ammo--;

            // Raycast to find target
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);

            // Check NPC hits
            npcs.forEach(npc => {
                const intersects = raycaster.intersectObject(npc.mesh, true);
                if (intersects.length > 0) {
                    npc.health -= weapon.damage;
                    showNotification(`Hit! ${weapon.damage} damage`);

                    if (npc.health <= 0) {
                        if (npc.type === 'civilian') {
                            changeHonor(-10);
                            addWantedLevel(1);
                        } else if (npc.type === 'bandit') {
                            changeHonor(5);
                        }
                    }
                }
            });

            // Check wildlife hits
            wildlife.forEach(animal => {
                const intersects = raycaster.intersectObject(animal.mesh, true);
                if (intersects.length > 0) {
                    scene.remove(animal.mesh);
                    wildlife.splice(wildlife.indexOf(animal), 1);
                    showNotification(`Hunted ${animal.type}!`);
                }
            });

            updateHUD();
        }

        function reload() {
            const weapon = gameState.inventory[gameState.currentWeapon];

            if (weapon.totalAmmo <= 0) {
                showNotification('No ammo!');
                return;
            }

            const needed = weapon.maxAmmo - weapon.ammo;
            const available = Math.min(needed, weapon.totalAmmo);

            weapon.ammo += available;
            weapon.totalAmmo -= available;

            showNotification('Reloaded!');
            updateHUD();
        }

        function activateDeadEye() {
            if (gameState.playerStats.deadEye < 50) return;

            deadEyeActive = true;
            document.getElementById('deadeyeOverlay').classList.add('active');
            gameState.playerStats.deadEye -= 50;
        }

        function deactivateDeadEye() {
            deadEyeActive = false;
            document.getElementById('deadeyeOverlay').classList.remove('active');
        }

        // ================================
        // WEAPON SYSTEM
        // ================================
        function toggleWeaponWheel() {
            const wheel = document.getElementById('weaponWheel');
            wheel.classList.toggle('active');
        }

        function selectWeapon(weaponType) {
            gameState.currentWeapon = weaponType;

            document.querySelectorAll('.weapon-slot').forEach(slot => {
                slot.classList.remove('selected');
            });
            document.querySelector(`[data-weapon="${weaponType}"]`).classList.add('selected');

            toggleWeaponWheel();
            updateHUD();
        }

        // ================================
        // HORSE SYSTEM
        // ================================
        function toggleHorse() {
            const distance = player.position.distanceTo(horse.position);

            if (distance < 3) {
                gameState.onHorse = !gameState.onHorse;

                if (gameState.onHorse) {
                    showNotification('Mounted horse');
                    // Increase bonding
                    if (gameState.horseData.bonding < 4) {
                        gameState.horseData.bonding += 0.1;
                    }
                } else {
                    showNotification('Dismounted horse');
                }
            } else {
                showNotification('Horse too far away');
            }
        }

        function whistleHorse() {
            horse.comeToPlayer = true;
            showNotification('Horse coming...');
        }

        // ================================
        // HONOR SYSTEM
        // ================================
        function changeHonor(amount) {
            gameState.honor = Math.max(0, Math.min(100, gameState.honor + amount));
            updateHonorDisplay();

            if (amount > 0) {
                showNotification(`+${amount} Honor`);
            } else {
                showNotification(`${amount} Honor`);
            }
        }

        function updateHonorDisplay() {
            const fill = document.getElementById('honorFill');
            const text = document.getElementById('honorText');

            fill.style.width = gameState.honor + '%';

            if (gameState.honor < 33) {
                fill.className = 'honor-bad';
                text.textContent = 'DISHONORABLE';
            } else if (gameState.honor < 66) {
                fill.className = 'honor-neutral';
                text.textContent = 'NEUTRAL';
            } else {
                fill.className = 'honor-good';
                text.textContent = 'HONORABLE';
            }
        }

        // ================================
        // WANTED SYSTEM
        // ================================
        function addWantedLevel(level) {
            gameState.wanted = Math.min(5, gameState.wanted + level);

            if (gameState.wanted > 0) {
                document.getElementById('wantedLevel').classList.add('active');
                document.getElementById('wantedLevel').innerHTML = '‚≠ê'.repeat(gameState.wanted) + ' WANTED ' + '‚≠ê'.repeat(gameState.wanted);
            }
        }

        function clearWantedLevel() {
            gameState.wanted = 0;
            document.getElementById('wantedLevel').classList.remove('active');
        }

        // ================================
        // HUD UPDATE
        // ================================
        function updateHUD() {
            // Health
            const healthPercent = (gameState.playerStats.health / gameState.playerStats.maxHealth) * 100;
            document.getElementById('healthBar').style.width = healthPercent + '%';
            document.getElementById('healthText').textContent =
                `${Math.floor(gameState.playerStats.health)}/${gameState.playerStats.maxHealth}`;

            // Stamina
            const staminaPercent = (gameState.playerStats.stamina / gameState.playerStats.maxStamina) * 100;
            document.getElementById('staminaBar').style.width = staminaPercent + '%';
            document.getElementById('staminaText').textContent =
                `${Math.floor(gameState.playerStats.stamina)}/${gameState.playerStats.maxStamina}`;

            // Dead Eye
            const deadeyePercent = (gameState.playerStats.deadEye / gameState.playerStats.maxDeadEye) * 100;
            document.getElementById('deadeyeBar').style.width = deadeyePercent + '%';
            document.getElementById('deadeyeText').textContent =
                `${Math.floor(gameState.playerStats.deadEye)}/${gameState.playerStats.maxDeadEye}`;

            // Weapon
            const weapon = gameState.inventory[gameState.currentWeapon];
            document.getElementById('weaponName').textContent = weapon.name;
            document.getElementById('ammoCount').textContent = `${weapon.ammo} / ${weapon.totalAmmo}`;

            // Horse
            document.getElementById('horseBonding').textContent = `Level ${Math.floor(gameState.horseData.bonding)}`;
            const horseStaminaPercent = (gameState.horseData.stamina / gameState.horseData.maxStamina) * 100;
            document.getElementById('horseStamina').textContent = `${Math.floor(horseStaminaPercent)}%`;
        }

        // ================================
        // MINIMAP
        // ================================
        function updateMinimap() {
            const canvas = document.getElementById('minimapCanvas');
            const ctx = canvas.getContext('2d');

            ctx.clearRect(0, 0, 200, 200);

            // Background
            ctx.fillStyle = 'rgba(194, 178, 128, 0.5)';
            ctx.fillRect(0, 0, 200, 200);

            const scale = 2;
            const centerX = 100;
            const centerY = 100;

            // Buildings
            ctx.fillStyle = '#8B4513';
            world.buildings.forEach(building => {
                const x = centerX + (building.mesh.position.x - player.position.x) * scale;
                const y = centerY + (building.mesh.position.z - player.position.z) * scale;
                ctx.fillRect(x - 3, y - 3, 6, 6);
            });

            // NPCs
            ctx.fillStyle = '#FF0000';
            npcs.forEach(npc => {
                if (npc.hostile) {
                    const x = centerX + (npc.position.x - player.position.x) * scale;
                    const y = centerY + (npc.position.z - player.position.z) * scale;
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            // Horse
            if (!gameState.onHorse) {
                ctx.fillStyle = '#8B4513';
                const hx = centerX + (horse.position.x - player.position.x) * scale;
                const hy = centerY + (horse.position.z - player.position.z) * scale;
                ctx.beginPath();
                ctx.arc(hx, hy, 4, 0, Math.PI * 2);
                ctx.fill();
            }

            // Player
            ctx.fillStyle = '#FFFFFF';
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(centerX, centerY, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // Direction indicator
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(
                centerX + Math.sin(player.rotation) * 15,
                centerY + Math.cos(player.rotation) * 15
            );
            ctx.stroke();
        }

        // ================================
        // STAT REGENERATION
        // ================================
        function regenerateStats(delta) {
            // Stamina regeneration
            if (!keys['shift'] && !keys[' ']) {
                gameState.playerStats.stamina = Math.min(
                    gameState.playerStats.maxStamina,
                    gameState.playerStats.stamina + delta * 15
                );
            }

            // Dead Eye regeneration
            gameState.playerStats.deadEye = Math.min(
                gameState.playerStats.maxDeadEye,
                gameState.playerStats.deadEye + delta * 5
            );

            // Horse stamina regeneration
            if (!keys['shift'] || !gameState.onHorse) {
                gameState.horseData.stamina = Math.min(
                    gameState.horseData.maxStamina,
                    gameState.horseData.stamina + delta * 20
                );
            }

            // Reduce wanted level over time
            if (gameState.wanted > 0) {
                // Check distance from town
                const distanceFromTown = Math.sqrt(
                    player.position.x * player.position.x +
                    player.position.z * player.position.z
                );

                if (distanceFromTown > 100) {
                    // Slowly reduce wanted level when far from town
                    if (Math.random() < 0.001) {
                        gameState.wanted--;
                        if (gameState.wanted === 0) {
                            clearWantedLevel();
                            showNotification('Wanted level cleared');
                        }
                    }
                }
            }
        }

        // ================================
        // UI FUNCTIONS
        // ================================
        function showNotification(message) {
            const notification = document.createElement('div');
            notification.className = 'notification';
            notification.textContent = message;
            document.getElementById('notifications').appendChild(notification);

            setTimeout(() => {
                notification.remove();
            }, 3000);
        }

        function toggleMenu() {
            const menu = document.getElementById('menu');
            menu.classList.toggle('hidden');

            if (menu.classList.contains('hidden')) {
                gameState.isPlaying = true;
                document.getElementById('gameCanvas').requestPointerLock();
            } else {
                gameState.isPlaying = false;
                document.exitPointerLock();
            }
        }

        function toggleControls() {
            document.getElementById('controlsHelp').classList.toggle('active');
        }

        function gameOver() {
            gameState.isPlaying = false;
            showNotification('You died!');
            setTimeout(() => {
                // Respawn
                gameState.playerStats.health = gameState.playerStats.maxHealth;
                player.position.set(0, 2, 0);
                gameState.wanted = 0;
                clearWantedLevel();
                gameState.isPlaying = true;
            }, 3000);
        }

        // ================================
        // GAME CONTROL
        // ================================
        function startGame() {
            document.getElementById('menu').classList.add('hidden');
            gameState.isPlaying = true;

            // Start intro mission
            startMission('intro');

            animate();
        }

        // ================================
        // SAVE/LOAD SYSTEM
        // ================================
        function exportData() {
            const saveData = {
                playerStats: gameState.playerStats,
                honor: gameState.honor,
                inventory: gameState.inventory,
                missions: gameState.missions,
                horseData: gameState.horseData,
                position: {
                    x: player.position.x,
                    y: player.position.y,
                    z: player.position.z
                },
                rotation: player.rotation,
                time: gameState.time
            };

            const dataStr = JSON.stringify(saveData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `red-dead-frontier-save-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);

            showNotification('Game saved!');
        }

        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const saveData = JSON.parse(e.target.result);

                    // Restore game state
                    gameState.playerStats = saveData.playerStats;
                    gameState.honor = saveData.honor;
                    gameState.inventory = saveData.inventory;
                    gameState.missions = saveData.missions;
                    gameState.horseData = saveData.horseData;
                    gameState.time = saveData.time || 0;

                    player.position.set(
                        saveData.position.x,
                        saveData.position.y,
                        saveData.position.z
                    );
                    player.rotation = saveData.rotation;

                    updateHUD();
                    updateHonorDisplay();

                    showNotification('Game loaded!');
                    startGame();
                } catch (error) {
                    alert('Invalid save file');
                }
            };
            reader.readAsText(file);
        }

        // ================================
        // INITIALIZE GAME
        // ================================
        window.addEventListener('load', init);
    </script>
</body>
</html>