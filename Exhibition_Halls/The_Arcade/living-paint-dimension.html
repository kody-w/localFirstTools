<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Living Paint Dimension</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            background: #f0f0f0;
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: crosshair;
            background: white;
        }

        /* Controls Panel */
        .controls {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            max-width: 280px;
            backdrop-filter: blur(10px);
        }

        .controls h3 {
            margin: 0 0 15px 0;
            color: #333;
            font-size: 18px;
            font-weight: 600;
        }

        /* Data Controls */
        .data-controls {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1000;
            display: flex;
            gap: 10px;
        }

        .data-controls button {
            padding: 10px 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .data-controls button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(102, 126, 234, 0.4);
        }

        /* Color Palette */
        .color-palette {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .color-btn {
            width: 35px;
            height: 35px;
            border-radius: 50%;
            border: 3px solid transparent;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
        }

        .color-btn.active {
            border-color: #333;
            transform: scale(1.15);
        }

        .color-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }

        /* Movement Modes */
        .movement-modes {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 15px;
        }

        .mode-btn {
            padding: 8px;
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s;
            text-align: center;
        }

        .mode-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-color: #667eea;
        }

        .mode-btn:hover {
            border-color: #667eea;
            transform: translateY(-1px);
        }

        /* Instructions */
        .instructions {
            font-size: 11px;
            color: #666;
            line-height: 1.4;
            padding: 10px;
            background: #f8f8f8;
            border-radius: 8px;
            margin-top: 10px;
        }

        .instructions strong {
            color: #333;
            display: block;
            margin-bottom: 5px;
        }

        /* Stats Display */
        .stats {
            position: fixed;
            bottom: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.95);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 12px;
            color: #666;
            backdrop-filter: blur(10px);
            z-index: 1000;
        }

        .clear-btn {
            width: 100%;
            padding: 10px;
            background: #ff6b6b;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s;
        }

        .clear-btn:hover {
            background: #ff5252;
            transform: translateY(-1px);
        }

        /* Particle Effect Overlay */
        .particle-count {
            position: fixed;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <!-- Main Canvas -->
    <canvas id="canvas"></canvas>

    <!-- Controls Panel -->
    <div class="controls">
        <h3>ðŸŽ¨ Living Paint Dimension</h3>

        <div class="color-palette" id="colorPalette">
            <!-- Color buttons will be added via JS -->
        </div>

        <div class="movement-modes">
            <button class="mode-btn active" data-mode="garden">ðŸŒ± Garden</button>
            <button class="mode-btn" data-mode="creature">ðŸ¦‹ Creatures</button>
            <button class="mode-btn" data-mode="galaxy">âœ¨ Galaxy</button>
            <button class="mode-btn" data-mode="splatter">ðŸ’§ Splatter</button>
        </div>

        <button class="clear-btn" onclick="clearCanvas()">Clear Canvas</button>

        <div class="instructions">
            <strong>How to Paint:</strong>
            â€¢ Click and drag to paint<br>
            â€¢ Hold Shift for faster painting<br>
            â€¢ Space to toggle animation<br>
            â€¢ Scroll to change brush size
        </div>
    </div>

    <!-- Data Controls -->
    <div class="data-controls">
        <button onclick="exportData()">Export Artwork</button>
        <button onclick="document.getElementById('importFile').click()">Import Artwork</button>
        <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importData(event)">
    </div>

    <!-- Stats Display -->
    <div class="stats" id="stats">
        Living Objects: <span id="objectCount">0</span> |
        FPS: <span id="fps">60</span>
    </div>

    <script>
        // Application State
        const APP_NAME = 'living-paint-dimension';
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Resize canvas to full window
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Color Palettes
        const colorPalettes = {
            garden: ['#4CAF50', '#8BC34A', '#CDDC39', '#FFC107', '#FF5722'],
            ocean: ['#0288D1', '#03A9F4', '#00BCD4', '#009688', '#4CAF50'],
            sunset: ['#FF6B6B', '#FF8E53', '#FE6B8B', '#FF8E53', '#FFA726'],
            galaxy: ['#9C27B0', '#673AB7', '#3F51B5', '#2196F3', '#00BCD4'],
            rainbow: ['#FF0000', '#FF7F00', '#FFFF00', '#00FF00', '#0000FF', '#4B0082', '#9400D3']
        };

        let currentPalette = colorPalettes.rainbow;
        let currentColor = currentPalette[0];
        let currentMode = 'garden';
        let brushSize = 20;
        let isAnimating = true;

        // Living Objects Array
        let livingObjects = [];

        // Mouse State
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let mouseVelocity = { x: 0, y: 0 };

        // Living Object Classes
        class LivingObject {
            constructor(x, y, color, type) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.type = type;
                this.age = 0;
                this.size = Math.random() * 10 + 5;
                this.growthRate = Math.random() * 0.5 + 0.1;
                this.maxSize = Math.random() * 30 + 20;
                this.opacity = 1;
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.05;
            }

            update() {
                this.age++;

                // Growth behavior
                if (this.size < this.maxSize) {
                    this.size += this.growthRate;
                }

                // Type-specific behaviors
                switch(this.type) {
                    case 'garden':
                        this.updateGarden();
                        break;
                    case 'creature':
                        this.updateCreature();
                        break;
                    case 'galaxy':
                        this.updateGalaxy();
                        break;
                    case 'splatter':
                        this.updateSplatter();
                        break;
                }

                // Fade out old objects
                if (this.age > 500) {
                    this.opacity = Math.max(0, 1 - (this.age - 500) / 200);
                }

                return this.opacity > 0;
            }

            updateGarden() {
                // Organic growth pattern
                this.growthRate *= 0.98;
                if (Math.random() < 0.01 && this.size > 15) {
                    // Spawn child plant
                    const angle = Math.random() * Math.PI * 2;
                    const dist = this.size + 10;
                    livingObjects.push(new LivingObject(
                        this.x + Math.cos(angle) * dist,
                        this.y + Math.sin(angle) * dist,
                        this.color,
                        'garden'
                    ));
                }
            }

            updateCreature() {
                // Flutter movement
                this.x += Math.sin(this.age * 0.05) * 2;
                this.y += Math.cos(this.age * 0.03) * 1 - 0.5;
                this.rotation += this.rotationSpeed;
            }

            updateGalaxy() {
                // Orbital rotation
                this.rotation += this.rotationSpeed;
                this.x += Math.cos(this.rotation) * 0.5;
                this.y += Math.sin(this.rotation) * 0.5;
            }

            updateSplatter() {
                // Drip effect
                this.y += this.growthRate * 2;
                this.x += (Math.random() - 0.5) * 0.5;
                this.size *= 0.99;
            }

            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = this.opacity;
                ctx.fillStyle = this.color;
                ctx.strokeStyle = this.color;

                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);

                switch(this.type) {
                    case 'garden':
                        this.drawGarden(ctx);
                        break;
                    case 'creature':
                        this.drawCreature(ctx);
                        break;
                    case 'galaxy':
                        this.drawGalaxy(ctx);
                        break;
                    case 'splatter':
                        this.drawSplatter(ctx);
                        break;
                }

                ctx.restore();
            }

            drawGarden(ctx) {
                // Draw flower/plant
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    const petalSize = this.size * 0.6;
                    ctx.moveTo(0, 0);
                    ctx.quadraticCurveTo(
                        Math.cos(angle) * petalSize,
                        Math.sin(angle) * petalSize,
                        Math.cos(angle + 0.3) * petalSize * 1.2,
                        Math.sin(angle + 0.3) * petalSize * 1.2
                    );
                }
                ctx.fill();

                // Center
                ctx.fillStyle = this.adjustColor(this.color, 20);
                ctx.beginPath();
                ctx.arc(0, 0, this.size * 0.2, 0, Math.PI * 2);
                ctx.fill();
            }

            drawCreature(ctx) {
                // Draw butterfly-like creature
                ctx.beginPath();
                // Wings
                ctx.ellipse(-this.size/2, 0, this.size/2, this.size, 0, 0, Math.PI * 2);
                ctx.ellipse(this.size/2, 0, this.size/2, this.size, 0, 0, Math.PI * 2);
                ctx.fill();

                // Body
                ctx.fillStyle = this.adjustColor(this.color, -30);
                ctx.fillRect(-2, -this.size, 4, this.size * 2);
            }

            drawGalaxy(ctx) {
                // Draw star/galaxy spiral
                ctx.beginPath();
                for (let i = 0; i < 5; i++) {
                    const angle = (i / 5) * Math.PI * 2 - Math.PI/2;
                    const x = Math.cos(angle) * this.size;
                    const y = Math.sin(angle) * this.size;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fill();

                // Glow effect
                ctx.globalAlpha = this.opacity * 0.3;
                ctx.beginPath();
                ctx.arc(0, 0, this.size * 1.5, 0, Math.PI * 2);
                ctx.fill();
            }

            drawSplatter(ctx) {
                // Draw paint splatter
                ctx.beginPath();
                ctx.arc(0, 0, this.size, 0, Math.PI * 2);
                ctx.fill();

                // Splatter drops
                for (let i = 0; i < 3; i++) {
                    const angle = (i / 3) * Math.PI * 2;
                    const dist = this.size + Math.random() * 10;
                    ctx.beginPath();
                    ctx.arc(
                        Math.cos(angle) * dist,
                        Math.sin(angle) * dist,
                        this.size * 0.3,
                        0, Math.PI * 2
                    );
                    ctx.fill();
                }
            }

            adjustColor(color, amount) {
                const rgb = this.hexToRgb(color);
                return `rgb(${Math.min(255, Math.max(0, rgb.r + amount))}, ${Math.min(255, Math.max(0, rgb.g + amount))}, ${Math.min(255, Math.max(0, rgb.b + amount))})`;
            }

            hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : { r: 0, g: 0, b: 0 };
            }
        }

        // Initialize Color Palette
        function initColorPalette() {
            const paletteDiv = document.getElementById('colorPalette');
            currentPalette.forEach((color, index) => {
                const btn = document.createElement('div');
                btn.className = 'color-btn';
                if (index === 0) btn.classList.add('active');
                btn.style.background = color;
                btn.dataset.color = color;
                btn.onclick = () => selectColor(color, btn);
                paletteDiv.appendChild(btn);
            });
        }

        function selectColor(color, btn) {
            currentColor = color;
            document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
        }

        // Mode Selection
        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                currentMode = btn.dataset.mode;
                document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
            });
        });

        // Mouse Events
        canvas.addEventListener('mousedown', (e) => {
            isDrawing = true;
            lastX = e.clientX;
            lastY = e.clientY;

            // Create initial object
            createLivingObject(e.clientX, e.clientY);
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!isDrawing) return;

            // Calculate velocity
            mouseVelocity.x = e.clientX - lastX;
            mouseVelocity.y = e.clientY - lastY;

            // Create trail of objects
            const distance = Math.sqrt(mouseVelocity.x ** 2 + mouseVelocity.y ** 2);
            const steps = Math.max(1, Math.floor(distance / 5));

            for (let i = 0; i < steps; i++) {
                const t = i / steps;
                const x = lastX + mouseVelocity.x * t;
                const y = lastY + mouseVelocity.y * t;

                if (e.shiftKey || distance > 10) {
                    createLivingObject(x, y);
                }
            }

            lastX = e.clientX;
            lastY = e.clientY;
        });

        canvas.addEventListener('mouseup', () => {
            isDrawing = false;
        });

        canvas.addEventListener('mouseleave', () => {
            isDrawing = false;
        });

        // Touch Events for Mobile
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            isDrawing = true;
            lastX = touch.clientX;
            lastY = touch.clientY;
            createLivingObject(touch.clientX, touch.clientY);
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!isDrawing) return;

            const touch = e.touches[0];
            mouseVelocity.x = touch.clientX - lastX;
            mouseVelocity.y = touch.clientY - lastY;

            const distance = Math.sqrt(mouseVelocity.x ** 2 + mouseVelocity.y ** 2);
            const steps = Math.max(1, Math.floor(distance / 5));

            for (let i = 0; i < steps; i++) {
                const t = i / steps;
                const x = lastX + mouseVelocity.x * t;
                const y = lastY + mouseVelocity.y * t;
                createLivingObject(x, y);
            }

            lastX = touch.clientX;
            lastY = touch.clientY;
        });

        canvas.addEventListener('touchend', () => {
            isDrawing = false;
        });

        // Scroll for brush size
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            brushSize = Math.max(5, Math.min(50, brushSize - e.deltaY * 0.1));
        });

        // Keyboard Events
        document.addEventListener('keydown', (e) => {
            if (e.key === ' ') {
                e.preventDefault();
                isAnimating = !isAnimating;
            }
        });

        // Create Living Object
        function createLivingObject(x, y) {
            // Add some randomness to position
            const offsetX = (Math.random() - 0.5) * brushSize;
            const offsetY = (Math.random() - 0.5) * brushSize;

            livingObjects.push(new LivingObject(
                x + offsetX,
                y + offsetY,
                currentColor,
                currentMode
            ));

            // Limit objects for performance
            if (livingObjects.length > 1000) {
                livingObjects = livingObjects.slice(-800);
            }
        }

        // Animation Loop
        let lastFrameTime = performance.now();
        let frameCount = 0;
        let fps = 60;

        function animate() {
            const now = performance.now();
            const deltaTime = now - lastFrameTime;

            // Calculate FPS
            frameCount++;
            if (frameCount % 30 === 0) {
                fps = Math.round(1000 / deltaTime);
                document.getElementById('fps').textContent = fps;
            }

            // Clear canvas with slight fade for trail effect
            ctx.fillStyle = 'rgba(255, 255, 255, 0.02)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Update and draw living objects
            if (isAnimating) {
                livingObjects = livingObjects.filter(obj => obj.update());
            }

            livingObjects.forEach(obj => obj.draw(ctx));

            // Update stats
            document.getElementById('objectCount').textContent = livingObjects.length;

            lastFrameTime = now;
            requestAnimationFrame(animate);
        }

        // Clear Canvas
        function clearCanvas() {
            livingObjects = [];
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            saveData();
        }

        // Data Management
        function saveData() {
            const data = {
                objects: livingObjects.map(obj => ({
                    x: obj.x,
                    y: obj.y,
                    color: obj.color,
                    type: obj.type,
                    size: obj.size,
                    age: obj.age
                })),
                settings: {
                    currentColor,
                    currentMode,
                    brushSize
                }
            };
            localStorage.setItem(APP_NAME, JSON.stringify(data));
        }

        function loadData() {
            const stored = localStorage.getItem(APP_NAME);
            if (stored) {
                try {
                    const data = JSON.parse(stored);
                    if (data.objects) {
                        livingObjects = data.objects.map(obj => {
                            const living = new LivingObject(obj.x, obj.y, obj.color, obj.type);
                            living.size = obj.size;
                            living.age = obj.age;
                            return living;
                        });
                    }
                    if (data.settings) {
                        currentColor = data.settings.currentColor || currentColor;
                        currentMode = data.settings.currentMode || currentMode;
                        brushSize = data.settings.brushSize || brushSize;
                    }
                } catch (e) {
                    console.error('Failed to load data:', e);
                }
            }
        }

        function exportData() {
            const data = {
                objects: livingObjects.map(obj => ({
                    x: obj.x,
                    y: obj.y,
                    color: obj.color,
                    type: obj.type,
                    size: obj.size,
                    age: obj.age,
                    rotation: obj.rotation
                })),
                settings: {
                    currentColor,
                    currentMode,
                    brushSize,
                    palette: currentPalette
                },
                metadata: {
                    created: new Date().toISOString(),
                    version: '1.0.0',
                    objectCount: livingObjects.length
                }
            };

            const dataStr = JSON.stringify(data, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `living-paint-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);
        }

        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);

                    // Load objects
                    if (data.objects && Array.isArray(data.objects)) {
                        livingObjects = data.objects.map(obj => {
                            const living = new LivingObject(obj.x, obj.y, obj.color, obj.type);
                            living.size = obj.size || living.size;
                            living.age = obj.age || 0;
                            living.rotation = obj.rotation || 0;
                            return living;
                        });
                    }

                    // Load settings
                    if (data.settings) {
                        currentColor = data.settings.currentColor || currentColor;
                        currentMode = data.settings.currentMode || currentMode;
                        brushSize = data.settings.brushSize || brushSize;

                        if (data.settings.palette && Array.isArray(data.settings.palette)) {
                            currentPalette = data.settings.palette;
                            // Refresh palette UI
                            document.getElementById('colorPalette').innerHTML = '';
                            initColorPalette();
                        }
                    }

                    saveData();

                    // Clear and redraw
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    alert(`Imported artwork with ${livingObjects.length} objects!`);
                } catch (error) {
                    alert('Invalid JSON file: ' + error.message);
                }
            };
            reader.readAsText(file);
            event.target.value = ''; // Reset file input
        }

        // Auto-save periodically
        setInterval(saveData, 5000);

        // Initialize
        initColorPalette();
        loadData();
        animate();

        // Initial canvas clear to white
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    </script>
</body>
</html>