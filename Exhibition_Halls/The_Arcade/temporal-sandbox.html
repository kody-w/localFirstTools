<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Temporal Sandbox - 4D Universe Factory</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Courier New', monospace;
            background: #000;
            color: #0ff;
            overflow: hidden;
            height: 100vh;
        }

        #universe-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, #0a0a1a 0%, #000 100%);
        }

        canvas {
            display: block;
        }

        .ui-overlay {
            position: fixed;
            z-index: 100;
            pointer-events: none;
        }

        .ui-overlay > * {
            pointer-events: auto;
        }

        #time-controls {
            top: 20px;
            left: 20px;
            background: rgba(0, 20, 40, 0.9);
            border: 1px solid #0ff;
            border-radius: 10px;
            padding: 15px;
            min-width: 280px;
        }

        #timeline-display {
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 20, 40, 0.9);
            border: 1px solid #0ff;
            border-radius: 10px;
            padding: 15px;
            width: 80%;
            max-width: 800px;
        }

        #info-panel {
            top: 20px;
            right: 20px;
            background: rgba(0, 20, 40, 0.9);
            border: 1px solid #0ff;
            border-radius: 10px;
            padding: 15px;
            max-width: 300px;
            max-height: 60vh;
            overflow-y: auto;
        }

        #nested-indicator {
            top: 50%;
            left: 20px;
            transform: translateY(-50%);
            background: rgba(0, 20, 40, 0.9);
            border: 1px solid #f0f;
            border-radius: 10px;
            padding: 10px;
        }

        h2 {
            font-size: 14px;
            margin-bottom: 10px;
            color: #0ff;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 12px;
        }

        .stat-label { color: #888; }
        .stat-value { color: #0ff; font-weight: bold; }

        button {
            background: transparent;
            border: 1px solid #0ff;
            color: #0ff;
            padding: 8px 16px;
            margin: 5px;
            cursor: pointer;
            font-family: inherit;
            font-size: 12px;
            border-radius: 5px;
            transition: all 0.3s;
        }

        button:hover {
            background: #0ff;
            color: #000;
        }

        button.active {
            background: #0ff;
            color: #000;
        }

        button.danger {
            border-color: #f44;
            color: #f44;
        }

        button.danger:hover {
            background: #f44;
            color: #000;
        }

        button.fork {
            border-color: #f0f;
            color: #f0f;
        }

        button.fork:hover {
            background: #f0f;
            color: #000;
        }

        #timeline-canvas {
            width: 100%;
            height: 100px;
            border: 1px solid #333;
            border-radius: 5px;
            cursor: crosshair;
        }

        .time-slider {
            width: 100%;
            margin: 10px 0;
            -webkit-appearance: none;
            background: #222;
            height: 8px;
            border-radius: 4px;
        }

        .time-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: #0ff;
            border-radius: 50%;
            cursor: grab;
            box-shadow: 0 0 10px #0ff;
        }

        .nested-level {
            display: flex;
            align-items: center;
            margin: 5px 0;
            font-size: 11px;
        }

        .level-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .level-dot:hover {
            transform: scale(1.3);
        }

        .level-dot.active {
            box-shadow: 0 0 10px currentColor;
        }

        #entity-list {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
        }

        .entity-item {
            padding: 5px;
            margin: 3px 0;
            background: rgba(0, 255, 255, 0.1);
            border-radius: 3px;
            font-size: 11px;
            cursor: pointer;
        }

        .entity-item:hover {
            background: rgba(0, 255, 255, 0.2);
        }

        .physics-rule {
            display: inline-block;
            padding: 2px 6px;
            margin: 2px;
            background: rgba(255, 0, 255, 0.2);
            border-radius: 3px;
            font-size: 10px;
        }

        #intro-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .intro-content {
            max-width: 600px;
            padding: 40px;
            text-align: center;
        }

        .intro-content h1 {
            font-size: 36px;
            margin-bottom: 20px;
            background: linear-gradient(90deg, #0ff, #f0f, #0ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: shimmer 3s infinite;
        }

        @keyframes shimmer {
            0%, 100% { filter: hue-rotate(0deg); }
            50% { filter: hue-rotate(30deg); }
        }

        .intro-content p {
            margin: 15px 0;
            line-height: 1.6;
            color: #aaa;
        }

        .controls-hint {
            margin-top: 30px;
            padding: 20px;
            background: rgba(0, 255, 255, 0.1);
            border-radius: 10px;
            text-align: left;
        }

        .controls-hint div {
            margin: 8px 0;
            font-size: 13px;
        }

        .key {
            display: inline-block;
            background: #333;
            padding: 3px 8px;
            border-radius: 4px;
            margin-right: 10px;
            min-width: 60px;
            text-align: center;
        }

        .data-controls {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 200;
        }

        .data-controls button {
            font-size: 10px;
            padding: 5px 10px;
        }

        #notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 255, 255, 0.9);
            color: #000;
            padding: 20px 40px;
            border-radius: 10px;
            font-size: 18px;
            z-index: 500;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
        }

        #notification.show {
            opacity: 1;
        }

        .emergence-event {
            position: fixed;
            padding: 10px 20px;
            background: rgba(255, 0, 255, 0.9);
            color: #fff;
            border-radius: 5px;
            font-size: 14px;
            z-index: 400;
            animation: emergeFade 4s forwards;
        }

        @keyframes emergeFade {
            0% { opacity: 0; transform: translateY(20px); }
            10% { opacity: 1; transform: translateY(0); }
            80% { opacity: 1; }
            100% { opacity: 0; transform: translateY(-20px); }
        }

        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #111; }
        ::-webkit-scrollbar-thumb { background: #0ff; border-radius: 3px; }
    </style>
</head>
<body>
    <div id="intro-modal">
        <div class="intro-content">
            <h1>TEMPORAL SANDBOX</h1>
            <p>You are about to navigate a 4-dimensional universe where <strong>time is a physical dimension</strong> you can walk through.</p>
            <p>Watch physics evolve. See intelligence emerge. Witness civilizations build their own simulations inside yours - infinitely nested realities.</p>
            <div class="controls-hint">
                <div><span class="key">WASD</span> Move through space</div>
                <div><span class="key">Q / E</span> Move through time (backward/forward)</div>
                <div><span class="key">SHIFT</span> Step sideways to fork timeline</div>
                <div><span class="key">SPACE</span> Pause/resume simulation</div>
                <div><span class="key">ENTER</span> Dive into nested simulation</div>
                <div><span class="key">ESC</span> Ascend to parent universe</div>
                <div><span class="key">CLICK</span> Select entity to observe</div>
            </div>
            <button onclick="startSandbox()" style="margin-top: 30px; font-size: 16px; padding: 15px 40px;">
                ENTER THE SANDBOX
            </button>
        </div>
    </div>

    <div id="universe-container">
        <canvas id="main-canvas"></canvas>
    </div>

    <div id="time-controls" class="ui-overlay">
        <h2>Temporal Navigation</h2>
        <div class="stat-row">
            <span class="stat-label">Universe Age:</span>
            <span class="stat-value" id="universe-age">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Your Time Position:</span>
            <span class="stat-value" id="time-position">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Timeline Branch:</span>
            <span class="stat-value" id="timeline-branch">Prime</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Active Timelines:</span>
            <span class="stat-value" id="timeline-count">1</span>
        </div>
        <input type="range" class="time-slider" id="time-scrubber" min="0" max="1000" value="0">
        <div style="margin-top: 10px;">
            <button id="play-pause-btn" onclick="toggleSimulation()">⏸ PAUSE</button>
            <button class="fork" onclick="forkTimeline()">⑂ FORK</button>
        </div>
        <div style="margin-top: 5px;">
            <button onclick="setTimeScale(0.1)">0.1x</button>
            <button onclick="setTimeScale(1)" class="active" id="speed-1x">1x</button>
            <button onclick="setTimeScale(10)">10x</button>
            <button onclick="setTimeScale(100)">100x</button>
        </div>
    </div>

    <div id="timeline-display" class="ui-overlay">
        <canvas id="timeline-canvas"></canvas>
        <div style="display: flex; justify-content: space-between; margin-top: 5px; font-size: 11px;">
            <span>Past</span>
            <span id="timeline-label">Prime Timeline</span>
            <span>Future</span>
        </div>
    </div>

    <div id="info-panel" class="ui-overlay">
        <h2>Universe State</h2>
        <div class="stat-row">
            <span class="stat-label">Entities:</span>
            <span class="stat-value" id="entity-count">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Civilizations:</span>
            <span class="stat-value" id="civ-count">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Nested Simulations:</span>
            <span class="stat-value" id="sim-count">0</span>
        </div>
        <div style="margin: 10px 0;">
            <h2>Active Physics</h2>
            <div id="physics-rules"></div>
        </div>
        <div>
            <h2>Emergent Entities</h2>
            <div id="entity-list"></div>
        </div>
    </div>

    <div id="nested-indicator" class="ui-overlay">
        <h2 style="color: #f0f;">Reality Depth</h2>
        <div id="nesting-levels"></div>
    </div>

    <div class="data-controls">
        <button onclick="resetUniverse()" style="border-color: #f44; color: #f44;">Reset</button>
        <button onclick="exportData()">Export</button>
        <button onclick="document.getElementById('importFile').click()">Import</button>
        <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importData(event)">
    </div>

    <div id="notification"></div>

    <script>
        // ============================================
        // TEMPORAL SANDBOX - 4D UNIVERSE FACTORY
        // ============================================

        const APP_NAME = 'temporal-sandbox';

        // Canvas setup
        const canvas = document.getElementById('main-canvas');
        const ctx = canvas.getContext('2d');
        const timelineCanvas = document.getElementById('timeline-canvas');
        const timelineCtx = timelineCanvas.getContext('2d');

        // State
        let appData = JSON.parse(localStorage.getItem(APP_NAME) || '{}');
        let running = false;
        let paused = false;
        let timeScale = 1;
        let lastTime = 0;

        // Universe state
        let universeStack = []; // Stack of nested universes
        let currentUniverse = null;

        // Player state
        const player = {
            x: 0,
            y: 0,
            z: 0, // Spatial Z
            t: 0, // Time position (4th dimension)
            targetT: 0
        };

        // Input state
        const keys = {};

        // Physics rules that can evolve
        const PHYSICS_TYPES = {
            GRAVITY: { name: 'Gravity', color: '#ff6b6b', strength: 1 },
            ELECTROMAGNETISM: { name: 'EM Force', color: '#4ecdc4', strength: 1 },
            STRONG_NUCLEAR: { name: 'Strong Force', color: '#ffe66d', strength: 1 },
            WEAK_NUCLEAR: { name: 'Weak Force', color: '#95e1d3', strength: 1 },
            DARK_ENERGY: { name: 'Dark Energy', color: '#a855f7', strength: 0 },
            TIME_CRYSTAL: { name: 'Time Crystal', color: '#0ff', strength: 0 },
            CONSCIOUSNESS: { name: 'Consciousness Field', color: '#f0f', strength: 0 }
        };

        // Entity types
        const ENTITY_TYPES = {
            PARTICLE: 0,
            ATOM: 1,
            MOLECULE: 2,
            CELL: 3,
            ORGANISM: 4,
            INTELLIGENCE: 5,
            CIVILIZATION: 6,
            SIMULATION: 7
        };

        // Universe class
        class Universe {
            constructor(parent = null, branchName = 'Prime') {
                this.id = Math.random().toString(36).substr(2, 9);
                this.parent = parent;
                this.branchName = branchName;
                this.age = 0;
                this.entities = [];
                this.timelines = [{ id: 'prime', name: 'Prime', snapshots: [], forkPoint: 0 }];
                this.currentTimeline = this.timelines[0];
                this.physics = this.initPhysics();
                this.nestedSimulations = [];
                this.civilizations = [];
                this.history = [];
                this.depth = parent ? parent.depth + 1 : 0;

                // Seed initial particles
                this.seedUniverse();
            }

            initPhysics() {
                const physics = {};
                for (let key in PHYSICS_TYPES) {
                    physics[key] = {
                        ...PHYSICS_TYPES[key],
                        active: ['GRAVITY', 'ELECTROMAGNETISM'].includes(key),
                        evolved: false
                    };
                }
                return physics;
            }

            seedUniverse() {
                // Create initial quantum foam
                for (let i = 0; i < 50; i++) {
                    this.entities.push(new Entity(this, ENTITY_TYPES.PARTICLE, {
                        x: (Math.random() - 0.5) * 800,
                        y: (Math.random() - 0.5) * 600,
                        vx: (Math.random() - 0.5) * 2,
                        vy: (Math.random() - 0.5) * 2,
                        charge: Math.random() > 0.5 ? 1 : -1,
                        mass: Math.random() * 2 + 0.5
                    }));
                }
            }

            update(dt) {
                if (paused) return;

                const scaledDt = dt * timeScale;
                this.age += scaledDt;

                // Physics evolution
                this.evolvePhysics(scaledDt);

                // Update entities
                for (let i = this.entities.length - 1; i >= 0; i--) {
                    const entity = this.entities[i];
                    entity.update(scaledDt, this);

                    if (entity.dead) {
                        this.entities.splice(i, 1);
                    }
                }

                // Entity interactions
                this.processInteractions(scaledDt);

                // Check for emergence
                this.checkEmergence();

                // Update nested simulations
                for (const sim of this.nestedSimulations) {
                    sim.update(dt * 0.1); // Nested simulations run slower
                }

                // Take snapshot for timeline
                if (Math.floor(this.age) % 10 === 0 && this.history.length < this.age / 10) {
                    this.takeSnapshot();
                }
            }

            evolvePhysics(dt) {
                // Physics can evolve based on universe state
                const entityCount = this.entities.length;
                const complexity = this.calculateComplexity();

                // Dark energy emerges with expansion
                if (this.age > 1000 && !this.physics.DARK_ENERGY.active) {
                    if (Math.random() < 0.001 * dt) {
                        this.physics.DARK_ENERGY.active = true;
                        this.physics.DARK_ENERGY.evolved = true;
                        showEmergenceEvent('Dark Energy has emerged!');
                    }
                }

                // Time crystals emerge with high complexity
                if (complexity > 50 && !this.physics.TIME_CRYSTAL.active) {
                    if (Math.random() < 0.0005 * dt) {
                        this.physics.TIME_CRYSTAL.active = true;
                        this.physics.TIME_CRYSTAL.evolved = true;
                        showEmergenceEvent('Time Crystals detected!');
                    }
                }

                // Consciousness field emerges with intelligence
                if (this.civilizations.length > 0 && !this.physics.CONSCIOUSNESS.active) {
                    if (Math.random() < 0.001 * dt) {
                        this.physics.CONSCIOUSNESS.active = true;
                        this.physics.CONSCIOUSNESS.evolved = true;
                        showEmergenceEvent('Consciousness Field manifests!');
                    }
                }

                // Mutate physics strengths slightly
                for (let key in this.physics) {
                    if (this.physics[key].active && Math.random() < 0.0001 * dt) {
                        this.physics[key].strength *= (0.95 + Math.random() * 0.1);
                        this.physics[key].strength = Math.max(0.1, Math.min(5, this.physics[key].strength));
                    }
                }
            }

            calculateComplexity() {
                let complexity = 0;
                for (const entity of this.entities) {
                    complexity += entity.type + 1;
                }
                return complexity / Math.max(1, this.entities.length);
            }

            processInteractions(dt) {
                // Simplified N-body interactions
                for (let i = 0; i < this.entities.length; i++) {
                    for (let j = i + 1; j < this.entities.length; j++) {
                        const a = this.entities[i];
                        const b = this.entities[j];

                        const dx = b.x - a.x;
                        const dy = b.y - a.y;
                        const dist = Math.sqrt(dx * dx + dy * dy) || 1;

                        if (dist < 20) {
                            // Potential combination
                            this.tryCombine(a, b);
                        }

                        // Apply forces
                        if (this.physics.GRAVITY.active && dist < 300) {
                            const force = this.physics.GRAVITY.strength * a.mass * b.mass / (dist * dist) * 0.01;
                            const fx = force * dx / dist;
                            const fy = force * dy / dist;
                            a.vx += fx / a.mass * dt;
                            a.vy += fy / a.mass * dt;
                            b.vx -= fx / b.mass * dt;
                            b.vy -= fy / b.mass * dt;
                        }

                        if (this.physics.ELECTROMAGNETISM.active && a.charge && b.charge) {
                            const force = -this.physics.ELECTROMAGNETISM.strength * a.charge * b.charge / (dist * dist) * 0.5;
                            const fx = force * dx / dist;
                            const fy = force * dy / dist;
                            a.vx += fx * dt;
                            a.vy += fy * dt;
                            b.vx -= fx * dt;
                            b.vy -= fy * dt;
                        }
                    }
                }

                // Dark energy expansion
                if (this.physics.DARK_ENERGY.active) {
                    for (const entity of this.entities) {
                        const dist = Math.sqrt(entity.x * entity.x + entity.y * entity.y);
                        if (dist > 0) {
                            entity.vx += (entity.x / dist) * this.physics.DARK_ENERGY.strength * 0.001 * dt;
                            entity.vy += (entity.y / dist) * this.physics.DARK_ENERGY.strength * 0.001 * dt;
                        }
                    }
                }
            }

            tryCombine(a, b) {
                // Entities can combine to form higher-order structures
                if (a.type === b.type && a.type < ENTITY_TYPES.SIMULATION) {
                    if (Math.random() < 0.01) {
                        const newType = a.type + 1;
                        a.type = newType;
                        a.mass += b.mass;
                        a.size = Math.min(30, a.size * 1.2);
                        a.complexity = (a.complexity || 1) + (b.complexity || 1);
                        b.dead = true;

                        if (newType === ENTITY_TYPES.INTELLIGENCE) {
                            showEmergenceEvent('Intelligence has emerged!');
                        }
                        if (newType === ENTITY_TYPES.CIVILIZATION) {
                            this.civilizations.push(a);
                            showEmergenceEvent('A Civilization has formed!');
                        }
                    }
                }
            }

            checkEmergence() {
                // Civilizations can create their own simulations
                for (const civ of this.civilizations) {
                    if (civ.age > 500 && this.nestedSimulations.length < 3) {
                        if (Math.random() < 0.0001) {
                            const nested = new Universe(this, `${civ.name || 'Civ'}'s Simulation`);
                            this.nestedSimulations.push(nested);
                            showEmergenceEvent(`${civ.name || 'A civilization'} created a simulation!`);
                        }
                    }
                }

                // Spontaneous entity generation in complex universes
                if (this.age > 500 && this.entities.length < 200 && Math.random() < 0.01) {
                    this.entities.push(new Entity(this, ENTITY_TYPES.PARTICLE, {
                        x: (Math.random() - 0.5) * 800,
                        y: (Math.random() - 0.5) * 600,
                        vx: (Math.random() - 0.5) * 2,
                        vy: (Math.random() - 0.5) * 2,
                        charge: Math.random() > 0.5 ? 1 : -1,
                        mass: Math.random() * 2 + 0.5
                    }));
                }
            }

            takeSnapshot() {
                this.history.push({
                    age: this.age,
                    entities: this.entities.map(e => e.serialize()),
                    physics: JSON.parse(JSON.stringify(this.physics))
                });

                // Keep history manageable
                if (this.history.length > 100) {
                    this.history = this.history.filter((_, i) => i % 2 === 0);
                }
            }

            fork(name) {
                const forked = new Universe(this.parent, name || `Fork-${this.timelines.length}`);
                forked.age = this.age;
                forked.entities = this.entities.map(e => e.clone());
                forked.physics = JSON.parse(JSON.stringify(this.physics));
                forked.history = [...this.history];

                this.timelines.push({
                    id: forked.id,
                    name: forked.branchName,
                    universe: forked,
                    forkPoint: this.age
                });

                return forked;
            }

            getTimelineAt(t) {
                // Find the closest snapshot to time t
                if (this.history.length === 0) return null;

                let closest = this.history[0];
                for (const snapshot of this.history) {
                    if (Math.abs(snapshot.age - t) < Math.abs(closest.age - t)) {
                        closest = snapshot;
                    }
                }
                return closest;
            }

            render(ctx, playerT) {
                // Render entities with temporal ghosting
                for (const entity of this.entities) {
                    entity.render(ctx, playerT, this.age);
                }

                // Render nested simulation indicators
                for (let i = 0; i < this.nestedSimulations.length; i++) {
                    const angle = (i / this.nestedSimulations.length) * Math.PI * 2;
                    const x = Math.cos(angle) * 250;
                    const y = Math.sin(angle) * 200;

                    ctx.save();
                    ctx.translate(x, y);

                    // Nested universe portal
                    ctx.beginPath();
                    ctx.arc(0, 0, 40, 0, Math.PI * 2);
                    ctx.strokeStyle = '#f0f';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // Swirling effect
                    const swirl = (this.age % 360) * Math.PI / 180;
                    ctx.rotate(swirl);
                    for (let j = 0; j < 3; j++) {
                        ctx.beginPath();
                        ctx.arc(0, 0, 30 - j * 8, j, Math.PI + j);
                        ctx.strokeStyle = `hsla(${280 + j * 20}, 100%, 60%, 0.5)`;
                        ctx.stroke();
                    }

                    ctx.restore();

                    // Label
                    ctx.fillStyle = '#f0f';
                    ctx.font = '10px Courier New';
                    ctx.textAlign = 'center';
                    ctx.fillText(this.nestedSimulations[i].branchName, x, y + 55);
                }
            }

            serialize() {
                return {
                    id: this.id,
                    branchName: this.branchName,
                    age: this.age,
                    entities: this.entities.map(e => e.serialize()),
                    physics: this.physics,
                    history: this.history.slice(-20),
                    nestedSimulations: this.nestedSimulations.map(s => s.serialize()),
                    civilizations: this.civilizations.map(c => c.serialize()),
                    depth: this.depth
                };
            }

            static deserialize(data, parent = null) {
                const universe = new Universe(parent, data.branchName);
                universe.id = data.id;
                universe.age = data.age;
                universe.physics = data.physics;
                universe.history = data.history || [];
                universe.depth = data.depth || 0;
                universe.entities = data.entities.map(e => Entity.deserialize(e, universe));
                universe.nestedSimulations = (data.nestedSimulations || []).map(s => Universe.deserialize(s, universe));
                universe.civilizations = universe.entities.filter(e => e.type === ENTITY_TYPES.CIVILIZATION);
                return universe;
            }
        }

        // Entity class
        class Entity {
            constructor(universe, type, props = {}) {
                this.id = Math.random().toString(36).substr(2, 9);
                this.type = type;
                this.x = props.x || 0;
                this.y = props.y || 0;
                this.vx = props.vx || 0;
                this.vy = props.vy || 0;
                this.mass = props.mass || 1;
                this.charge = props.charge || 0;
                this.size = props.size || (3 + type * 2);
                this.age = 0;
                this.complexity = props.complexity || 1;
                this.dead = false;
                this.name = this.generateName();
                this.birthTime = universe ? universe.age : 0;
                this.trail = [];
            }

            generateName() {
                const prefixes = ['Xan', 'Vor', 'Kri', 'Zul', 'Nex', 'Pho', 'Ara', 'Lum'];
                const suffixes = ['ith', 'on', 'ara', 'ix', 'us', 'ia', 'or', 'um'];
                return prefixes[Math.floor(Math.random() * prefixes.length)] +
                       suffixes[Math.floor(Math.random() * suffixes.length)];
            }

            update(dt, universe) {
                this.age += dt;

                // Movement
                this.x += this.vx * dt;
                this.y += this.vy * dt;

                // Damping
                this.vx *= 0.999;
                this.vy *= 0.999;

                // Boundary wrapping
                const bound = 500;
                if (this.x < -bound) this.x = bound;
                if (this.x > bound) this.x = -bound;
                if (this.y < -bound) this.y = bound;
                if (this.y > bound) this.y = -bound;

                // Trail
                this.trail.push({ x: this.x, y: this.y, t: universe.age });
                if (this.trail.length > 50) this.trail.shift();

                // Higher entities have behaviors
                if (this.type >= ENTITY_TYPES.ORGANISM) {
                    this.behave(dt, universe);
                }
            }

            behave(dt, universe) {
                // Simple emergent behavior for intelligent entities
                if (this.type >= ENTITY_TYPES.INTELLIGENCE) {
                    // Seek others of similar type
                    let nearestSimilar = null;
                    let nearestDist = Infinity;

                    for (const other of universe.entities) {
                        if (other !== this && other.type >= ENTITY_TYPES.ORGANISM) {
                            const dx = other.x - this.x;
                            const dy = other.y - this.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist < nearestDist) {
                                nearestDist = dist;
                                nearestSimilar = other;
                            }
                        }
                    }

                    if (nearestSimilar && nearestDist < 200) {
                        const dx = nearestSimilar.x - this.x;
                        const dy = nearestSimilar.y - this.y;
                        this.vx += (dx / nearestDist) * 0.1 * dt;
                        this.vy += (dy / nearestDist) * 0.1 * dt;
                    }
                }
            }

            render(ctx, playerT, universeAge) {
                // Full 6-digit hex colors (required for alpha concatenation)
                const colors = [
                    '#666666', // Particle
                    '#888888', // Atom
                    '#aaaaaa', // Molecule
                    '#4ecdc4', // Cell
                    '#ffe66d', // Organism
                    '#ff6b6b', // Intelligence
                    '#a855f7', // Civilization
                    '#00ffff'  // Simulation
                ];

                // Calculate temporal distance for ghosting effect
                const temporalDist = Math.abs(this.birthTime - playerT);
                const alpha = Math.max(0.3, 1 - temporalDist / 500);

                // Draw trail
                if (this.trail.length > 1) {
                    ctx.beginPath();
                    ctx.moveTo(this.trail[0].x, this.trail[0].y);
                    for (let i = 1; i < this.trail.length; i++) {
                        ctx.lineTo(this.trail[i].x, this.trail[i].y);
                    }
                    ctx.strokeStyle = colors[this.type] + '44';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }

                // Draw entity
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);

                if (this.type >= ENTITY_TYPES.CIVILIZATION) {
                    // Special glow for civilizations
                    const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size * 2);
                    gradient.addColorStop(0, colors[this.type]);
                    gradient.addColorStop(1, 'transparent');
                    ctx.fillStyle = gradient;
                } else {
                    ctx.fillStyle = colors[this.type] + Math.floor(alpha * 255).toString(16).padStart(2, '0');
                }
                ctx.fill();

                // Label for higher entities
                if (this.type >= ENTITY_TYPES.INTELLIGENCE) {
                    ctx.fillStyle = '#fff';
                    ctx.font = '9px Courier New';
                    ctx.textAlign = 'center';
                    ctx.fillText(this.name, this.x, this.y - this.size - 5);
                }
            }

            clone() {
                const cloned = new Entity(null, this.type, {
                    x: this.x,
                    y: this.y,
                    vx: this.vx,
                    vy: this.vy,
                    mass: this.mass,
                    charge: this.charge,
                    size: this.size,
                    complexity: this.complexity
                });
                cloned.age = this.age;
                cloned.name = this.name;
                cloned.birthTime = this.birthTime;
                return cloned;
            }

            serialize() {
                return {
                    id: this.id,
                    type: this.type,
                    x: this.x,
                    y: this.y,
                    vx: this.vx,
                    vy: this.vy,
                    mass: this.mass,
                    charge: this.charge,
                    size: this.size,
                    age: this.age,
                    complexity: this.complexity,
                    name: this.name,
                    birthTime: this.birthTime
                };
            }

            static deserialize(data, universe) {
                const entity = new Entity(universe, data.type, data);
                entity.id = data.id;
                entity.age = data.age;
                entity.name = data.name;
                entity.birthTime = data.birthTime;
                return entity;
            }
        }

        // Initialization
        function init() {
            resize();
            window.addEventListener('resize', resize);
            window.addEventListener('keydown', handleKeyDown);
            window.addEventListener('keyup', handleKeyUp);
            canvas.addEventListener('click', handleClick);

            document.getElementById('time-scrubber').addEventListener('input', (e) => {
                if (currentUniverse) {
                    player.targetT = parseFloat(e.target.value);
                }
            });
        }

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            timelineCanvas.width = timelineCanvas.offsetWidth;
            timelineCanvas.height = 100;
        }

        function startSandbox() {
            document.getElementById('intro-modal').style.display = 'none';

            // Clear any corrupted data and start fresh
            try {
                if (appData.universe) {
                    currentUniverse = Universe.deserialize(appData.universe);
                    console.log('Loaded saved universe with', currentUniverse.entities.length, 'entities');
                } else {
                    currentUniverse = new Universe();
                    console.log('Created new universe with', currentUniverse.entities.length, 'entities');
                }
            } catch (e) {
                console.error('Error loading universe, creating new one:', e);
                localStorage.removeItem(APP_NAME);
                appData = {};
                currentUniverse = new Universe();
            }

            universeStack = [currentUniverse];
            running = true;
            lastTime = performance.now();
            console.log('Starting game loop, running =', running);
            requestAnimationFrame(gameLoop);
        }

        function gameLoop(timestamp) {
            if (!running) return;

            const dt = Math.min((timestamp - lastTime) / 1000, 0.1);
            lastTime = timestamp;

            update(dt);
            render();

            requestAnimationFrame(gameLoop);
        }

        function update(dt) {
            // Handle input
            const moveSpeed = 200 * dt;
            const timeSpeed = 50 * dt * timeScale;

            if (keys['KeyW'] || keys['ArrowUp']) player.y -= moveSpeed;
            if (keys['KeyS'] || keys['ArrowDown']) player.y += moveSpeed;
            if (keys['KeyA'] || keys['ArrowLeft']) player.x -= moveSpeed;
            if (keys['KeyD'] || keys['ArrowRight']) player.x += moveSpeed;
            if (keys['KeyQ']) player.targetT = Math.max(0, player.targetT - timeSpeed);
            if (keys['KeyE']) player.targetT = Math.min(currentUniverse.age, player.targetT + timeSpeed);

            // Smooth time movement
            player.t += (player.targetT - player.t) * 0.1;

            // Update universe
            currentUniverse.update(dt);

            // Update scrubber
            document.getElementById('time-scrubber').max = Math.max(1000, currentUniverse.age);
            document.getElementById('time-scrubber').value = player.t;

            // Auto-save periodically
            if (Math.floor(timestamp / 10000) !== Math.floor((timestamp - dt * 1000) / 10000)) {
                saveData();
            }
        }

        function render() {
            // Clear
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Background stars
            drawStarfield();

            // Center on player
            ctx.save();
            ctx.translate(canvas.width / 2 - player.x, canvas.height / 2 - player.y);

            // Grid
            drawGrid();

            // Render universe
            currentUniverse.render(ctx, player.t);

            // Player indicator
            ctx.beginPath();
            ctx.arc(player.x, player.y, 10, 0, Math.PI * 2);
            ctx.strokeStyle = '#0ff';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Time position indicator
            ctx.beginPath();
            ctx.arc(player.x, player.y, 15 + Math.sin(Date.now() / 200) * 3, 0, Math.PI * 2);
            ctx.strokeStyle = `hsla(${(player.t % 360)}, 100%, 60%, 0.5)`;
            ctx.stroke();

            ctx.restore();

            // Draw timeline
            drawTimeline();

            // Update UI
            updateUI();
        }

        function drawStarfield() {
            const seed = 12345;
            for (let i = 0; i < 200; i++) {
                const x = ((seed * i * 7) % canvas.width);
                const y = ((seed * i * 13) % canvas.height);
                const brightness = 0.2 + (Math.sin(Date.now() / 1000 + i) + 1) * 0.3;
                ctx.fillStyle = `rgba(255, 255, 255, ${brightness})`;
                ctx.fillRect(x, y, 1, 1);
            }
        }

        function drawGrid() {
            const gridSize = 100;
            ctx.strokeStyle = '#1a3a4a';
            ctx.lineWidth = 1;

            for (let x = -500; x <= 500; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, -500);
                ctx.lineTo(x, 500);
                ctx.stroke();
            }

            for (let y = -500; y <= 500; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(-500, y);
                ctx.lineTo(500, y);
                ctx.stroke();
            }

            // Origin marker
            ctx.beginPath();
            ctx.arc(0, 0, 5, 0, Math.PI * 2);
            ctx.fillStyle = '#00ffff33';
            ctx.fill();
        }

        function drawTimeline() {
            const w = timelineCanvas.width;
            const h = timelineCanvas.height;

            timelineCtx.fillStyle = '#0a0a1a';
            timelineCtx.fillRect(0, 0, w, h);

            // Draw timeline branches
            const maxAge = Math.max(1000, currentUniverse.age);

            // Main timeline
            timelineCtx.beginPath();
            timelineCtx.moveTo(0, h / 2);
            timelineCtx.lineTo(w, h / 2);
            timelineCtx.strokeStyle = '#0ff';
            timelineCtx.lineWidth = 2;
            timelineCtx.stroke();

            // Fork points
            for (const timeline of currentUniverse.timelines) {
                if (timeline.forkPoint > 0) {
                    const x = (timeline.forkPoint / maxAge) * w;
                    timelineCtx.beginPath();
                    timelineCtx.arc(x, h / 2, 5, 0, Math.PI * 2);
                    timelineCtx.fillStyle = '#f0f';
                    timelineCtx.fill();

                    // Branch line
                    timelineCtx.beginPath();
                    timelineCtx.moveTo(x, h / 2);
                    timelineCtx.lineTo(w, h / 2 - 20);
                    timelineCtx.strokeStyle = '#f0f44';
                    timelineCtx.stroke();
                }
            }

            // History markers
            for (const snapshot of currentUniverse.history) {
                const x = (snapshot.age / maxAge) * w;
                timelineCtx.fillStyle = '#333';
                timelineCtx.fillRect(x, h / 2 - 3, 2, 6);
            }

            // Player position
            const playerX = (player.t / maxAge) * w;
            timelineCtx.beginPath();
            timelineCtx.moveTo(playerX, 10);
            timelineCtx.lineTo(playerX, h - 10);
            timelineCtx.strokeStyle = '#0ff';
            timelineCtx.lineWidth = 2;
            timelineCtx.stroke();

            // Now marker
            const nowX = (currentUniverse.age / maxAge) * w;
            timelineCtx.beginPath();
            timelineCtx.arc(nowX, h / 2, 8, 0, Math.PI * 2);
            timelineCtx.fillStyle = '#0f0';
            timelineCtx.fill();
        }

        function updateUI() {
            document.getElementById('universe-age').textContent = Math.floor(currentUniverse.age);
            document.getElementById('time-position').textContent = Math.floor(player.t);
            document.getElementById('timeline-branch').textContent = currentUniverse.branchName;
            document.getElementById('timeline-count').textContent = currentUniverse.timelines.length;

            document.getElementById('entity-count').textContent = currentUniverse.entities.length;
            document.getElementById('civ-count').textContent = currentUniverse.civilizations.length;
            document.getElementById('sim-count').textContent = currentUniverse.nestedSimulations.length;

            // Physics rules
            const physicsDiv = document.getElementById('physics-rules');
            physicsDiv.innerHTML = '';
            for (const key in currentUniverse.physics) {
                if (currentUniverse.physics[key].active) {
                    const rule = document.createElement('span');
                    rule.className = 'physics-rule';
                    rule.style.borderColor = currentUniverse.physics[key].color;
                    rule.textContent = `${currentUniverse.physics[key].name} (${currentUniverse.physics[key].strength.toFixed(2)})`;
                    if (currentUniverse.physics[key].evolved) {
                        rule.style.background = currentUniverse.physics[key].color + '44';
                    }
                    physicsDiv.appendChild(rule);
                }
            }

            // Entity list
            const entityList = document.getElementById('entity-list');
            entityList.innerHTML = '';
            const interestingEntities = currentUniverse.entities
                .filter(e => e.type >= ENTITY_TYPES.ORGANISM)
                .slice(0, 10);

            for (const entity of interestingEntities) {
                const item = document.createElement('div');
                item.className = 'entity-item';
                const typeNames = ['Particle', 'Atom', 'Molecule', 'Cell', 'Organism', 'Intelligence', 'Civilization', 'Simulation'];
                item.textContent = `${entity.name} (${typeNames[entity.type]})`;
                item.onclick = () => {
                    player.x = entity.x;
                    player.y = entity.y;
                };
                entityList.appendChild(item);
            }

            // Nesting levels
            const nestingDiv = document.getElementById('nesting-levels');
            nestingDiv.innerHTML = '';
            for (let i = 0; i < universeStack.length; i++) {
                const level = document.createElement('div');
                level.className = 'nested-level';
                const dot = document.createElement('div');
                dot.className = 'level-dot' + (i === universeStack.length - 1 ? ' active' : '');
                dot.style.background = `hsl(${280 - i * 30}, 70%, 60%)`;
                dot.onclick = () => ascendToLevel(i);
                level.appendChild(dot);
                level.appendChild(document.createTextNode(universeStack[i].branchName));
                nestingDiv.appendChild(level);
            }
        }

        function handleKeyDown(e) {
            keys[e.code] = true;

            if (e.code === 'Space') {
                e.preventDefault();
                toggleSimulation();
            }

            if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') {
                forkTimeline();
            }

            if (e.code === 'Enter') {
                // Dive into nested simulation
                if (currentUniverse.nestedSimulations.length > 0) {
                    const nearest = findNearestSimulation();
                    if (nearest) {
                        universeStack.push(nearest);
                        currentUniverse = nearest;
                        player.x = 0;
                        player.y = 0;
                        player.t = 0;
                        player.targetT = 0;
                        showNotification('Diving into nested simulation...');
                    }
                }
            }

            if (e.code === 'Escape') {
                // Ascend to parent
                if (universeStack.length > 1) {
                    universeStack.pop();
                    currentUniverse = universeStack[universeStack.length - 1];
                    player.x = 0;
                    player.y = 0;
                    showNotification('Ascending to parent universe...');
                }
            }
        }

        function handleKeyUp(e) {
            keys[e.code] = false;
        }

        function handleClick(e) {
            const rect = canvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left - canvas.width / 2 + player.x;
            const clickY = e.clientY - rect.top - canvas.height / 2 + player.y;

            // Find clicked entity
            for (const entity of currentUniverse.entities) {
                const dx = entity.x - clickX;
                const dy = entity.y - clickY;
                if (Math.sqrt(dx * dx + dy * dy) < entity.size + 10) {
                    showNotification(`Selected: ${entity.name}`);
                    break;
                }
            }
        }

        function findNearestSimulation() {
            let nearest = null;
            let nearestDist = Infinity;

            for (let i = 0; i < currentUniverse.nestedSimulations.length; i++) {
                const angle = (i / currentUniverse.nestedSimulations.length) * Math.PI * 2;
                const x = Math.cos(angle) * 250;
                const y = Math.sin(angle) * 200;

                const dx = x - player.x;
                const dy = y - player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < nearestDist) {
                    nearestDist = dist;
                    nearest = currentUniverse.nestedSimulations[i];
                }
            }

            return nearestDist < 100 ? nearest : null;
        }

        function ascendToLevel(level) {
            while (universeStack.length > level + 1) {
                universeStack.pop();
            }
            currentUniverse = universeStack[universeStack.length - 1];
            player.x = 0;
            player.y = 0;
            showNotification(`Returned to ${currentUniverse.branchName}`);
        }

        function toggleSimulation() {
            paused = !paused;
            document.getElementById('play-pause-btn').textContent = paused ? '▶ PLAY' : '⏸ PAUSE';
        }

        function setTimeScale(scale) {
            timeScale = scale;
            document.querySelectorAll('#time-controls button').forEach(b => b.classList.remove('active'));
            document.getElementById(`speed-${scale}x`)?.classList.add('active');
        }

        function forkTimeline() {
            const forked = currentUniverse.fork();
            universeStack.push(forked);
            currentUniverse = forked;
            showNotification(`Timeline forked: ${forked.branchName}`);
        }

        function showNotification(text) {
            const notification = document.getElementById('notification');
            notification.textContent = text;
            notification.classList.add('show');
            setTimeout(() => notification.classList.remove('show'), 2000);
        }

        function showEmergenceEvent(text) {
            const event = document.createElement('div');
            event.className = 'emergence-event';
            event.textContent = text;
            event.style.left = Math.random() * (window.innerWidth - 200) + 100 + 'px';
            event.style.top = Math.random() * (window.innerHeight - 100) + 50 + 'px';
            document.body.appendChild(event);
            setTimeout(() => event.remove(), 4000);
        }

        function saveData() {
            appData.universe = currentUniverse.serialize();
            localStorage.setItem(APP_NAME, JSON.stringify(appData));
        }

        function resetUniverse() {
            if (confirm('Reset universe? This will delete all progress.')) {
                localStorage.removeItem(APP_NAME);
                appData = {};
                currentUniverse = new Universe();
                universeStack = [currentUniverse];
                player.x = 0;
                player.y = 0;
                player.t = 0;
                player.targetT = 0;
                showNotification('Universe reset!');
            }
        }

        function exportData() {
            const dataStr = JSON.stringify({ universe: currentUniverse.serialize() }, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `temporal-sandbox-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);
        }

        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    if (data.universe) {
                        currentUniverse = Universe.deserialize(data.universe);
                        universeStack = [currentUniverse];
                        player.x = 0;
                        player.y = 0;
                        player.t = 0;
                        player.targetT = 0;
                        saveData();
                        showNotification('Universe imported successfully!');
                    }
                } catch (error) {
                    alert('Invalid save file');
                }
            };
            reader.readAsText(file);
        }

        // Initialize and auto-start
        init();

        // Force start after short delay to ensure DOM is ready
        setTimeout(() => {
            if (!running) {
                console.log('Auto-starting universe...');
                startSandbox();
            }
        }, 100);
    </script>
</body>
</html>
