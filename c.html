<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>AI Companion Hub - Interactive Assistant</title>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
            -webkit-overflow-scrolling: touch;
        }

        #three-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        #gamepad-indicator {
            position: fixed;
            top: 140px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border-radius: 20px;
            color: #06ffa5;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        #gamepad-indicator.active {
            opacity: 1;
        }

        .ai-chat-interface {
            position: fixed;
            bottom: calc(env(safe-area-inset-bottom, 20px) + 100px);
            right: calc(env(safe-area-inset-right, 20px));
            width: 350px;
            height: 450px;
            background: rgba(20, 20, 40, 0.85);
            border: 2px solid rgba(138, 56, 236, 0.5);
            border-radius: 20px;
            display: none;
            flex-direction: column;
            z-index: 1003;
            box-shadow: 0 0 30px rgba(138, 56, 236, 0.3);
            backdrop-filter: blur(5px);
        }

        .ai-chat-interface.active {
            display: flex;
        }

        .ai-chat-header {
            padding: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .ai-chat-title {
            font-weight: bold;
            color: #06ffa5;
        }

        .ai-modal-close {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #fff;
            transition: all 0.3s;
        }

        .ai-modal-close:hover {
            color: #ff006e;
            transform: rotate(90deg);
        }

        .ai-chat-messages {
            flex: 1;
            padding: 15px;
            overflow-y: auto;
            scroll-behavior: smooth;
        }

        .ai-message {
            margin: 10px 0;
            padding: 10px 15px;
            border-radius: 15px;
            max-width: 80%;
            word-wrap: break-word;
            overflow-wrap: break-word;
            word-break: break-word;
            font-size: 15px;
            line-height: 1.6;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            transition: all 0.2s ease;
            max-width: 100%;
            overflow-x: auto;
        }

        .ai-message.user {
            background: rgba(131, 56, 236, 0.3);
            margin-left: auto;
            text-align: right;
        }

        .ai-message.ai {
            background: rgba(6, 255, 165, 0.2);
            margin-right: auto;
        }

        .ai-typing {
            margin: 10px 0;
            padding: 10px 15px;
            border-radius: 15px;
            max-width: 80%;
            background: rgba(6, 255, 165, 0.2);
            margin-right: auto;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .typing-dot {
            width: 8px;
            height: 8px;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            animation: typingPulse 1.4s infinite ease-in-out;
        }

        .typing-dot:nth-child(1) {
            animation-delay: -0.32s;
        }

        .typing-dot:nth-child(2) {
            animation-delay: -0.16s;
        }

        @keyframes typingPulse {
            0%, 80%, 100% {
                transform: scale(0.8);
                opacity: 0.5;
            }
            40% {
                transform: scale(1);
                opacity: 1;
            }
        }

        .ai-chat-input-container {
            padding: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .ai-chat-input {
            flex: 1;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            color: white;
            font-size: 14px;
        }

        .ai-chat-send {
            background: linear-gradient(45deg, #8338ec, #3a86ff);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .ai-chat-send:hover {
            transform: scale(1.05);
        }

        .ai-companion-button {
            position: fixed;
            bottom: calc(env(safe-area-inset-bottom, 30px));
            right: calc(env(safe-area-inset-right, 30px));
            width: 60px;
            height: 60px;
            background: rgba(131, 56, 236, 0.3);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(131, 56, 236, 0.5);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 1002;
            box-shadow: 0 0 20px rgba(131, 56, 236, 0.3);
        }

        .ai-companion-button:hover {
            background: rgba(131, 56, 236, 0.5);
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(131, 56, 236, 0.5);
        }

        .ai-companion-button.active {
            background: rgba(6, 255, 165, 0.3);
            border-color: rgba(6, 255, 165, 0.5);
        }

        .world-ui {
            position: absolute;
            top: env(safe-area-inset-top, 20px);
            left: env(safe-area-inset-left, 20px);
            z-index: 1001;
            pointer-events: none;
        }

        .world-title {
            font-size: 3em;
            font-weight: 100;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            background: linear-gradient(45deg, #ff006e, #8338ec, #3a86ff, #06ffa5);
            background-size: 400% 100%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: shimmer 8s ease-in-out infinite;
            margin-bottom: 10px;
        }

        .world-description {
            font-size: 1.2em;
            color: rgba(255, 255, 255, 0.6);
            max-width: 400px;
        }

        @keyframes shimmer {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .mobile-controls {
            position: fixed;
            bottom: calc(env(safe-area-inset-bottom, 0px) + 20px);
            left: 0;
            right: 0;
            display: none;
            z-index: 1001;
            padding: 0 20px;
            pointer-events: none;
        }

        .mobile-controls.show {
            display: block;
        }

        .controls-container {
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            width: 100%;
            max-width: 600px;
            margin: 0 auto;
        }

        .joystick-container {
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            position: relative;
            pointer-events: auto;
            touch-action: none;
        }

        .joystick-handle {
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        .look-area {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 200px;
            z-index: 999;
            touch-action: none;
        }

        .controls-hint {
            position: absolute;
            bottom: env(safe-area-inset-bottom, 30px);
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.8);
            z-index: 1001;
            text-align: center;
            backdrop-filter: blur(10px);
            pointer-events: none;
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            font-size: 1.2em;
            color: rgba(255, 255, 255, 0.4);
            font-weight: 200;
            letter-spacing: 0.1em;
            z-index: 2000;
        }

        .loading::after {
            content: '';
            display: block;
            width: 60px;
            height: 1px;
            background: linear-gradient(90deg, transparent, #fff, transparent);
            margin: 30px auto;
            animation: scan 2s linear infinite;
        }

        @keyframes scan {
            0% { transform: translateX(-100px); }
            100% { transform: translateX(100px); }
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }

        .notification {
            position: fixed;
            top: 100px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            border: 2px solid rgba(0, 255, 255, 0.5);
            animation: slideIn 0.3s ease;
            z-index: 1005;
            backdrop-filter: blur(10px);
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @media (max-width: 768px) {
            .world-title {
                font-size: 2em;
            }

            .world-description {
                font-size: 1em;
                max-width: 300px;
            }

            .ai-chat-interface {
                width: calc(100% - 40px);
                right: 20px;
                left: 20px;
            }
        }

        @supports (-webkit-touch-callout: none) {
            body {
                position: fixed;
                height: 100vh;
                height: -webkit-fill-available;
            }

            #three-container {
                height: 100vh;
                height: -webkit-fill-available;
            }
        }
    </style>
</head>
<body>
    <div id="three-container"></div>

    <div id="gamepad-indicator">
        🎮 Gamepad Mode
        <span style="font-size: 12px; color: rgba(255, 255, 255, 0.6); margin-left: 10px;">
            LS: Move | RS: Look | A: Interact
        </span>
    </div>

    <div class="ai-chat-interface" id="ai-chat-interface">
        <div class="ai-chat-header">
            <div class="ai-chat-title">AI Companion Chat</div>
            <button class="ai-modal-close" onclick="document.getElementById('ai-chat-interface').classList.remove('active')">&times;</button>
        </div>
        <div class="ai-chat-messages" id="ai-chat-messages"></div>
        <div class="ai-chat-input-container">
            <input type="text" class="ai-chat-input" id="ai-chat-input" placeholder="Type a message..." onkeypress="if(event.key==='Enter') window.worldNavigator.chatManager.sendMessage()">
            <button class="ai-chat-send" onclick="window.worldNavigator.chatManager.sendMessage()">Send</button>
        </div>
    </div>

    <div class="look-area" id="look-area"></div>

    <div class="world-ui">
        <h1 class="world-title" id="world-title">AI COMPANION HUB</h1>
        <p class="world-description" id="world-description">Your intelligent assistant awaits. Interact through text or explore the collaborative space together.</p>
    </div>

    <div class="ai-companion-button active" id="ai-companion-button">
        <svg class="view-toggle-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"></path>
        </svg>
    </div>

    <div class="controls-hint" id="controls-hint">Use WASD to move, Mouse to look around</div>

    <div class="mobile-controls" id="mobile-controls">
        <div class="controls-container">
            <div class="joystick-container" id="movement-joystick">
                <div class="joystick-handle" id="movement-handle"></div>
            </div>
        </div>
    </div>

    <div class="loading" id="loading">Initializing Environment...</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const WORLD_ATTRIBUTES = {
            name: "AI Companion Hub",
            description: "Your intelligent assistant awaits. Interact through text or explore the collaborative space together.",
            ambientColor: 0x1a1a2e,
            fogColor: 0x0a0a0f,
            groundColor: 0x16213e,
            skyColor: 0x0f3460,
            moveSpeed: 0.15,
            lookSpeed: 0.002,
            particleCount: 300,
            cameraHeight: 3,
            fogNear: 5,
            fogFar: 50,
            companionDistance: 8
        };

        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                        (window.matchMedia && window.matchMedia('(max-width: 768px)').matches) ||
                        (window.matchMedia && window.matchMedia('(pointer: coarse)').matches);

        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;

        window.addEventListener('DOMContentLoaded', () => {
            const navigator = new WorldNavigator();
            navigator.init();
        });

        class ParticleTextSystem {
            constructor(scene, camera) {
                this.scene = scene;
                this.camera = camera;
                this.particles = [];
                this.physicsMode = 'magnetism';
                this.isActive = false;
                this.mousePosition = new THREE.Vector3(0, 5, -8);
                
                this.physicsModes = {
                    magnetism: { strength: 0.3 },
                    repulsion: { strength: 1.0 },
                    orbital: { strength: 0.2 }
                };
            }

            createTextParticles(text) {
                this.clearParticles();
                
                if (!text) return;

                const canvas = document.createElement('canvas');
                canvas.width = 1024;
                canvas.height = 256;
                const ctx = canvas.getContext('2d');
                
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 120px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(text, canvas.width / 2, canvas.height / 2);

                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const pixels = imageData.data;

                const sampling = 6;
                const scale = 0.02;
                const offsetX = -canvas.width * scale / 2;
                const offsetY = 2;

                for (let y = 0; y < canvas.height; y += sampling) {
                    for (let x = 0; x < canvas.width; x += sampling) {
                        const index = (y * canvas.width + x) * 4;
                        const alpha = pixels[index + 3];
                        
                        if (alpha > 128) {
                            const hue = (x / canvas.width) * 360;
                            const color = new THREE.Color().setHSL(hue / 360, 0.7, 0.6);
                            
                            const particle = {
                                originX: x * scale + offsetX,
                                originY: offsetY,
                                originZ: -y * scale / 4,
                                x: x * scale + offsetX,
                                y: offsetY,
                                z: -y * scale / 4,
                                vx: 0,
                                vy: 0,
                                vz: 0,
                                color: color
                            };
                            
                            this.particles.push(particle);
                        }
                    }
                }

                this.createParticleMesh();
                this.isActive = true;
            }

            createParticleMesh() {
                if (this.particleMesh) {
                    this.scene.remove(this.particleMesh);
                    if (this.particleMesh.geometry) this.particleMesh.geometry.dispose();
                    if (this.particleMesh.material) this.particleMesh.material.dispose();
                }

                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(this.particles.length * 3);
                const colors = new Float32Array(this.particles.length * 3);

                this.particles.forEach((particle, i) => {
                    positions[i * 3] = particle.x;
                    positions[i * 3 + 1] = particle.y;
                    positions[i * 3 + 2] = particle.z;

                    colors[i * 3] = particle.color.r;
                    colors[i * 3 + 1] = particle.color.g;
                    colors[i * 3 + 2] = particle.color.b;
                });

                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

                const material = new THREE.PointsMaterial({
                    size: 0.15,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.9,
                    blending: THREE.AdditiveBlending
                });

                this.particleMesh = new THREE.Points(geometry, material);
                this.scene.add(this.particleMesh);
            }

            update() {
                if (!this.isActive || this.particles.length === 0) return;

                const cameraDirection = new THREE.Vector3();
                this.camera.getWorldDirection(cameraDirection);
                
                this.mousePosition.copy(this.camera.position);
                this.mousePosition.add(cameraDirection.multiplyScalar(5));

                this.particles.forEach((particle, i) => {
                    const dx = this.mousePosition.x - particle.x;
                    const dy = this.mousePosition.y - particle.y;
                    const dz = this.mousePosition.z - particle.z;
                    const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                    const strength = this.physicsModes[this.physicsMode].strength;

                    if (this.physicsMode === 'magnetism') {
                        if (distance > 0.5) {
                            const force = (strength * 5) / (distance * distance);
                            particle.vx += (dx / distance) * force;
                            particle.vy += (dy / distance) * force;
                            particle.vz += (dz / distance) * force;
                        }
                    } else if (this.physicsMode === 'repulsion') {
                        if (distance < 10) {
                            const force = (strength * 10) / (distance * distance + 1);
                            particle.vx -= (dx / distance) * force;
                            particle.vy -= (dy / distance) * force;
                            particle.vz -= (dz / distance) * force;
                        }
                    } else if (this.physicsMode === 'orbital') {
                        if (distance < 15 && distance > 1) {
                            const tangentX = -dz;
                            const tangentZ = dx;
                            const tangentLength = Math.sqrt(tangentX * tangentX + tangentZ * tangentZ);
                            const force = strength * (5 / distance);
                            
                            if (tangentLength > 0) {
                                particle.vx += (tangentX / tangentLength) * force;
                                particle.vz += (tangentZ / tangentLength) * force;
                            }
                            
                            const attractForce = 0.03;
                            particle.vx += (dx / distance) * attractForce;
                            particle.vy += (dy / distance) * attractForce;
                            particle.vz += (dz / distance) * attractForce;
                        }
                    }

                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.z += particle.vz;

                    particle.vx *= 0.95;
                    particle.vy *= 0.95;
                    particle.vz *= 0.95;

                    const returnForce = 0.02;
                    particle.vx += (particle.originX - particle.x) * returnForce;
                    particle.vy += (particle.originY - particle.y) * returnForce;
                    particle.vz += (particle.originZ - particle.z) * returnForce;
                });

                this.updateParticleMesh();
            }

            updateParticleMesh() {
                if (!this.particleMesh) return;

                const positions = this.particleMesh.geometry.attributes.position.array;
                
                this.particles.forEach((particle, i) => {
                    positions[i * 3] = particle.x;
                    positions[i * 3 + 1] = particle.y;
                    positions[i * 3 + 2] = particle.z;
                });

                this.particleMesh.geometry.attributes.position.needsUpdate = true;
            }

            clearParticles() {
                this.particles = [];
                this.isActive = false;
                
                if (this.particleMesh) {
                    this.scene.remove(this.particleMesh);
                    if (this.particleMesh.geometry) this.particleMesh.geometry.dispose();
                    if (this.particleMesh.material) this.particleMesh.material.dispose();
                    this.particleMesh = null;
                }
            }

            setPhysicsMode(mode) {
                if (this.physicsModes[mode]) {
                    this.physicsMode = mode;
                }
            }
        }

        class ChatManager {
            constructor(worldInstance) {
                this.world = worldInstance;
                this.chatInterface = document.getElementById('ai-chat-interface');
                this.chatMessages = document.getElementById('ai-chat-messages');
                this.chatInput = document.getElementById('ai-chat-input');
                
                this.mockResponses = [
                    "That's an interesting perspective! Let me think about that.",
                    "I understand what you're saying. Could you tell me more?",
                    "Great question! Here's my take on it...",
                    "I see where you're coming from. Have you considered this angle?",
                    "Thanks for sharing that with me!",
                    "That makes sense. What else would you like to know?",
                    "Fascinating! I'd love to explore this topic further.",
                    "I appreciate your input. Let's dive deeper into this."
                ];
            }

            async sendMessage() {
                const message = this.chatInput.value.trim();
                if (!message) return;

                this.addMessage(message, 'user');
                this.chatInput.value = '';

                this.showTypingIndicator();

                await this.delay(1500);

                this.hideTypingIndicator();

                const response = this.mockResponses[Math.floor(Math.random() * this.mockResponses.length)];
                this.addMessage(response, 'ai');

                this.animateTextResponse(response);
            }

            animateTextResponse(text) {
                const words = text.split(' ');
                const shortText = words.slice(0, 5).join(' ');
                
                if (this.world.particleTextSystem) {
                    this.world.particleTextSystem.createTextParticles(shortText);
                    
                    const modes = ['magnetism', 'repulsion', 'orbital'];
                    const mode = modes[Math.floor(Math.random() * modes.length)];
                    this.world.particleTextSystem.setPhysicsMode(mode);

                    setTimeout(() => {
                        if (this.world.particleTextSystem) {
                            this.world.particleTextSystem.clearParticles();
                        }
                    }, 8000);
                }

                this.animateCompanionSpeaking();
            }

            animateCompanionSpeaking() {
                if (!this.world.companion) return;

                const originalScale = this.world.companion.orb.scale.x;
                let progress = 0;
                const animate = () => {
                    progress += 0.1;
                    if (progress > 1) return;

                    const scale = originalScale + Math.sin(progress * Math.PI) * 0.3;
                    this.world.companion.orb.scale.setScalar(scale);

                    this.world.companion.light.intensity = 3 + Math.sin(progress * Math.PI * 2) * 1;
                    this.world.companion.orb.material.emissiveIntensity = 0.5 + Math.sin(progress * Math.PI) * 0.3;

                    requestAnimationFrame(animate);
                };
                animate();
            }

            showTypingIndicator() {
                const typingDiv = document.createElement('div');
                typingDiv.className = 'ai-message ai-typing';
                typingDiv.id = 'ai-typing-indicator';
                typingDiv.innerHTML = `
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                `;
                this.chatMessages.appendChild(typingDiv);
                this.chatMessages.scrollTop = this.chatMessages.scrollHeight;
            }

            hideTypingIndicator() {
                const typingIndicator = document.getElementById('ai-typing-indicator');
                if (typingIndicator) {
                    typingIndicator.remove();
                }
            }

            addMessage(text, sender) {
                const messageDiv = document.createElement('div');
                messageDiv.className = `ai-message ${sender}`;
                messageDiv.textContent = text;

                this.chatMessages.appendChild(messageDiv);
                this.chatMessages.scrollTop = this.chatMessages.scrollHeight;
            }

            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }

        class WorldNavigator {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.raycaster = new THREE.Raycaster();
                this.clock = new THREE.Clock();

                this.moveSpeed = WORLD_ATTRIBUTES.moveSpeed;
                this.lookSpeed = WORLD_ATTRIBUTES.lookSpeed;
                this.keys = { w: false, a: false, s: false, d: false };
                this.rotation = { x: 0, y: 0 };

                this.isMobile = isMobile;
                this.isIOS = isIOS;
                this.joystickActive = false;
                this.joystickVector = new THREE.Vector2();
                this.lookTouch = null;
                this.joystickTouch = null;

                this.isPointerLocked = false;

                this.gamepad = null;
                this.gamepadDeadzone = 0.15;
                this.gamepadButtonStates = {};

                this.chatManager = null;
                this.companion = null;
                this.particleTextSystem = null;

                if (this.isIOS) {
                    document.body.addEventListener('touchmove', (e) => {
                        if (e.target === document.body) {
                            e.preventDefault();
                        }
                    }, { passive: false });
                }
            }

            init() {
                setTimeout(() => {
                    document.getElementById('loading').style.display = 'none';
                }, 1000);

                this.setupScene();
                this.setupLighting();
                this.createEnvironment();
                this.createAICompanion();
                this.setupEventListeners();

                this.chatManager = new ChatManager(this);
                this.particleTextSystem = new ParticleTextSystem(this.scene, this.camera);

                this.setupGamepadControls();

                if (this.isMobile) {
                    document.getElementById('controls-hint').textContent = 'Touch & drag to look around, Use joystick to move';
                    document.getElementById('mobile-controls').classList.add('show');
                }

                window.worldNavigator = this;

                this.focusOnCompanion();
                this.animate();
            }

            setupScene() {
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.Fog(WORLD_ATTRIBUTES.fogColor, WORLD_ATTRIBUTES.fogNear, WORLD_ATTRIBUTES.fogFar);

                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, WORLD_ATTRIBUTES.cameraHeight, 0);

                this.renderer = new THREE.WebGLRenderer({ 
                    antialias: true, 
                    alpha: true,
                    powerPreference: "high-performance"
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.getElementById('three-container').appendChild(this.renderer.domElement);
            }

            setupLighting() {
                const ambientLight = new THREE.AmbientLight(WORLD_ATTRIBUTES.ambientColor, 0.6);
                this.scene.add(ambientLight);

                const dirLight = new THREE.DirectionalLight(0x8338ec, 0.8);
                dirLight.position.set(10, 20, 10);
                dirLight.castShadow = true;
                this.scene.add(dirLight);

                const spotLight = new THREE.SpotLight(0x06ffa5, 1, 30, Math.PI / 6, 0.5, 2);
                spotLight.position.set(0, 10, -5);
                spotLight.target.position.set(0, 0, -WORLD_ATTRIBUTES.companionDistance);
                this.scene.add(spotLight);
                this.scene.add(spotLight.target);
            }

            createEnvironment() {
                const groundGeometry = new THREE.PlaneGeometry(100, 100, 50, 50);
                const groundMaterial = new THREE.MeshStandardMaterial({
                    color: WORLD_ATTRIBUTES.groundColor,
                    roughness: 0.8,
                    metalness: 0.2,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.3
                });

                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.receiveShadow = true;
                this.scene.add(ground);

                const solidGroundGeometry = new THREE.PlaneGeometry(100, 100);
                const solidGroundMaterial = new THREE.MeshStandardMaterial({
                    color: 0x0a0a0f,
                    roughness: 1,
                    metalness: 0
                });

                const solidGround = new THREE.Mesh(solidGroundGeometry, solidGroundMaterial);
                solidGround.rotation.x = -Math.PI / 2;
                solidGround.position.y = -0.1;
                this.scene.add(solidGround);

                const skyGeometry = new THREE.SphereGeometry(200, 32, 32);
                const skyMaterial = new THREE.MeshBasicMaterial({
                    color: WORLD_ATTRIBUTES.skyColor,
                    side: THREE.BackSide
                });
                const sky = new THREE.Mesh(skyGeometry, skyMaterial);
                this.scene.add(sky);

                const particleGeometry = new THREE.BufferGeometry();
                const particleCount = WORLD_ATTRIBUTES.particleCount;
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);

                for (let i = 0; i < particleCount * 3; i += 3) {
                    positions[i] = (Math.random() - 0.5) * 80;
                    positions[i + 1] = Math.random() * 30 + 5;
                    positions[i + 2] = (Math.random() - 0.5) * 80;

                    colors[i] = Math.random() * 0.5 + 0.5;
                    colors[i + 1] = Math.random() * 0.5;
                    colors[i + 2] = Math.random() * 0.5 + 0.5;
                }

                particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

                const particleMaterial = new THREE.PointsMaterial({
                    size: 0.2,
                    transparent: true,
                    opacity: 0.8,
                    vertexColors: true,
                    blending: THREE.AdditiveBlending
                });

                const particles = new THREE.Points(particleGeometry, particleMaterial);
                this.scene.add(particles);
            }

            createAICompanion() {
                const companionGroup = new THREE.Group();

                const geometry = new THREE.SphereGeometry(1.5, 32, 32);
                const material = new THREE.MeshStandardMaterial({
                    color: 0x06ffa5,
                    emissive: 0x06ffa5,
                    emissiveIntensity: 0.5,
                    metalness: 0.8,
                    roughness: 0.2,
                    transparent: true,
                    opacity: 0.8
                });

                const orb = new THREE.Mesh(geometry, material);
                orb.position.y = 4;
                companionGroup.add(orb);

                const glowLight = new THREE.PointLight(0x06ffa5, 2, 10);
                glowLight.position.y = 4;
                companionGroup.add(glowLight);

                const particleGeometry = new THREE.BufferGeometry();
                const particleCount = 100;
                const positions = new Float32Array(particleCount * 3);

                for (let i = 0; i < particleCount * 3; i += 3) {
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    const radius = 2.5 + Math.random() * 1;

                    positions[i] = radius * Math.sin(phi) * Math.cos(theta);
                    positions[i + 1] = radius * Math.sin(phi) * Math.sin(theta) + 4;
                    positions[i + 2] = radius * Math.cos(phi);
                }

                particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

                const particleMaterial = new THREE.PointsMaterial({
                    color: 0x8338ec,
                    size: 0.1,
                    transparent: true,
                    opacity: 0.6
                });

                const particles = new THREE.Points(particleGeometry, particleMaterial);
                companionGroup.add(particles);

                companionGroup.position.set(0, 0, -WORLD_ATTRIBUTES.companionDistance);
                this.scene.add(companionGroup);

                this.companion = {
                    object: companionGroup,
                    orb: orb,
                    particles: particles,
                    light: glowLight
                };

                this.animateCompanion();
            }

            animateCompanion() {
                const animate = () => {
                    if (!this.companion) return;

                    const time = Date.now() * 0.001;

                    this.companion.orb.position.y = 4 + Math.sin(time * 2) * 0.3;
                    this.companion.particles.rotation.y = time * 0.5;
                    this.companion.light.intensity = 2 + Math.sin(time * 3) * 0.5;

                    const cameraDirection = new THREE.Vector3();
                    this.camera.getWorldDirection(cameraDirection);
                    
                    const targetPos = new THREE.Vector3();
                    targetPos.copy(this.camera.position);
                    targetPos.add(cameraDirection.multiplyScalar(WORLD_ATTRIBUTES.companionDistance));
                    targetPos.y = 0;

                    this.companion.object.position.lerp(targetPos, 0.1);

                    if (this.particleTextSystem) {
                        this.particleTextSystem.update();
                    }

                    requestAnimationFrame(animate);
                };

                animate();
            }

            focusOnCompanion() {
                this.rotation.y = 0;
                this.rotation.x = -0.1;
            }

            setupEventListeners() {
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });

                document.getElementById('ai-companion-button').addEventListener('click', () => {
                    document.getElementById('ai-chat-interface').classList.toggle('active');
                });

                if (this.isMobile) {
                    this.setupMobileControls();
                } else {
                    this.setupDesktopControls();
                }
            }

            setupDesktopControls() {
                window.addEventListener('keydown', (e) => {
                    if (e.key.toLowerCase() in this.keys) {
                        this.keys[e.key.toLowerCase()] = true;
                    }
                });

                window.addEventListener('keyup', (e) => {
                    if (e.key.toLowerCase() in this.keys) {
                        this.keys[e.key.toLowerCase()] = false;
                    }
                });

                this.renderer.domElement.addEventListener('click', (e) => {
                    if (!this.isPointerLocked) {
                        this.renderer.domElement.requestPointerLock();
                    }
                });

                document.addEventListener('pointerlockchange', () => {
                    this.isPointerLocked = document.pointerLockElement === this.renderer.domElement;
                });

                document.addEventListener('mousemove', (e) => {
                    if (this.isPointerLocked) {
                        this.rotation.y -= e.movementX * this.lookSpeed;
                        this.rotation.x -= e.movementY * this.lookSpeed;
                        this.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.rotation.x));
                    }
                });
            }

            setupMobileControls() {
                const lookArea = document.getElementById('look-area');

                lookArea.addEventListener('touchstart', (e) => {
                    const touch = e.touches[0];
                    this.lookTouch = {
                        id: touch.identifier,
                        startX: touch.clientX,
                        startY: touch.clientY,
                        currentX: touch.clientX,
                        currentY: touch.clientY
                    };
                }, { passive: true });

                lookArea.addEventListener('touchmove', (e) => {
                    if (!this.lookTouch) return;

                    for (let i = 0; i < e.touches.length; i++) {
                        const touch = e.touches[i];
                        if (touch.identifier === this.lookTouch.id) {
                            const deltaX = touch.clientX - this.lookTouch.currentX;
                            const deltaY = touch.clientY - this.lookTouch.currentY;

                            this.rotation.y -= deltaX * this.lookSpeed * 2;
                            this.rotation.x -= deltaY * this.lookSpeed * 2;
                            this.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.rotation.x));

                            this.lookTouch.currentX = touch.clientX;
                            this.lookTouch.currentY = touch.clientY;

                            e.preventDefault();
                            break;
                        }
                    }
                }, { passive: false });

                lookArea.addEventListener('touchend', (e) => {
                    for (let i = 0; i < e.changedTouches.length; i++) {
                        const touch = e.changedTouches[i];
                        if (this.lookTouch && touch.identifier === this.lookTouch.id) {
                            this.lookTouch = null;
                            break;
                        }
                    }
                }, { passive: true });

                const joystick = document.getElementById('movement-joystick');
                const handle = document.getElementById('movement-handle');

                joystick.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    const touch = e.touches[0];
                    this.joystickTouch = { id: touch.identifier };
                    this.joystickActive = true;
                    this.updateJoystick(touch, joystick, handle);
                }, { passive: false });

                joystick.addEventListener('touchmove', (e) => {
                    if (!this.joystickActive || !this.joystickTouch) return;
                    e.preventDefault();
                    e.stopPropagation();
                    for (let i = 0; i < e.touches.length; i++) {
                        const touch = e.touches[i];
                        if (touch.identifier === this.joystickTouch.id) {
                            this.updateJoystick(touch, joystick, handle);
                            break;
                        }
                    }
                }, { passive: false });

                joystick.addEventListener('touchend', (e) => {
                    for (let i = 0; i < e.changedTouches.length; i++) {
                        const touch = e.changedTouches[i];
                        if (this.joystickTouch && touch.identifier === this.joystickTouch.id) {
                            this.joystickActive = false;
                            this.joystickTouch = null;
                            this.joystickVector.set(0, 0);
                            handle.style.transform = 'translate(-50%, -50%)';
                            e.preventDefault();
                            e.stopPropagation();
                            break;
                        }
                    }
                }, { passive: false });

                window.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    return false;
                });
            }

            updateJoystick(touch, joystick, handle) {
                const rect = joystick.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;

                let deltaX = touch.clientX - centerX;
                let deltaY = touch.clientY - centerY;

                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                const maxDistance = rect.width / 2 - 25;

                if (distance > maxDistance) {
                    deltaX = (deltaX / distance) * maxDistance;
                    deltaY = (deltaY / distance) * maxDistance;
                }

                handle.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;

                this.joystickVector.x = deltaX / maxDistance;
                this.joystickVector.y = -deltaY / maxDistance;
            }

            setupGamepadControls() {
                if (!('getGamepads' in navigator)) {
                    return;
                }

                window.addEventListener('gamepadconnected', (e) => {
                    this.gamepad = e.gamepad.index;
                    this.showNotification('Gamepad connected!');
                    document.getElementById('gamepad-indicator').classList.add('active');
                });

                window.addEventListener('gamepaddisconnected', (e) => {
                    if (this.gamepad === e.gamepad.index) {
                        this.gamepad = null;
                        document.getElementById('gamepad-indicator').classList.remove('active');
                    }
                });
            }

            updateGamepadInput() {
                if (this.gamepad === null) return;

                const gamepads = navigator.getGamepads();
                const gp = gamepads[this.gamepad];
                
                if (!gp || !gp.connected) return;

                const leftX = this.applyDeadzone(gp.axes[0]);
                const leftY = this.applyDeadzone(gp.axes[1]);
                const rightX = this.applyDeadzone(gp.axes[2]);
                const rightY = this.applyDeadzone(gp.axes[3]);

                if (Math.abs(leftX) > 0 || Math.abs(leftY) > 0) {
                    const forward = new THREE.Vector3();
                    const right = new THREE.Vector3();

                    this.camera.getWorldDirection(forward);
                    forward.y = 0;
                    forward.normalize();

                    right.crossVectors(forward, new THREE.Vector3(0, 1, 0));

                    const moveForward = forward.multiplyScalar(-leftY * this.moveSpeed);
                    const moveRight = right.multiplyScalar(leftX * this.moveSpeed);
                    
                    this.camera.position.add(moveForward);
                    this.camera.position.add(moveRight);
                }

                if (Math.abs(rightX) > 0 || Math.abs(rightY) > 0) {
                    this.rotation.y -= rightX * this.lookSpeed * 2;
                    this.rotation.x -= rightY * this.lookSpeed * 2;
                    this.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.rotation.x));
                }

                if (gp.buttons[2].pressed && !this.gamepadButtonStates.x) {
                    document.getElementById('ai-companion-button').click();
                }

                this.updateGamepadButtonStates(gp);
            }

            applyDeadzone(value) {
                if (Math.abs(value) < this.gamepadDeadzone) {
                    return 0;
                }
                return value;
            }

            updateGamepadButtonStates(gp) {
                if (!this.gamepadButtonStates) {
                    this.gamepadButtonStates = {};
                }
                
                this.gamepadButtonStates.x = gp.buttons[2].pressed;
            }

            updateMovement() {
                const forward = new THREE.Vector3();
                const right = new THREE.Vector3();

                this.camera.getWorldDirection(forward);
                forward.y = 0;
                forward.normalize();

                right.crossVectors(forward, new THREE.Vector3(0, 1, 0));

                if (this.isMobile) {
                    if (this.joystickActive) {
                        const moveForward = forward.multiplyScalar(this.joystickVector.y * this.moveSpeed);
                        const moveRight = right.multiplyScalar(this.joystickVector.x * this.moveSpeed);
                        this.camera.position.add(moveForward);
                        this.camera.position.add(moveRight);
                    }
                } else {
                    if (this.keys.w) this.camera.position.add(forward.multiplyScalar(this.moveSpeed));
                    if (this.keys.s) this.camera.position.add(forward.multiplyScalar(-this.moveSpeed));
                    if (this.keys.a) this.camera.position.add(right.multiplyScalar(-this.moveSpeed));
                    if (this.keys.d) this.camera.position.add(right.multiplyScalar(this.moveSpeed));
                }

                this.camera.rotation.order = 'YXZ';
                this.camera.rotation.y = this.rotation.y;
                this.camera.rotation.x = this.rotation.x;
            }

            showNotification(message) {
                const notification = document.createElement('div');
                notification.className = 'notification';
                notification.textContent = message;

                document.body.appendChild(notification);

                setTimeout(() => {
                    notification.style.animation = 'slideOut 0.3s ease';
                    setTimeout(() => notification.remove(), 300);
                }, 3000);
            }

            animate() {
                requestAnimationFrame(() => this.animate());

                const time = this.clock.getElapsedTime();

                this.updateGamepadInput();
                this.updateMovement();

                const particles = this.scene.getObjectByProperty('type', 'Points');
                if (particles && !particles.geometry.attributes.color) {
                    particles.rotation.y = time * 0.05;
                    particles.position.y = Math.sin(time * 0.2) * 2;
                }

                this.renderer.render(this.scene, this.camera);
            }
        }

        let lastY = 0;
        window.addEventListener('touchstart', (e) => {
            lastY = e.touches[0].clientY;
        }, { passive: true });

        window.addEventListener('touchmove', (e) => {
            const y = e.touches[0].clientY;
            const scrollingUp = y > lastY;
            const atTop = window.pageYOffset === 0;

            if (scrollingUp && atTop) {
                e.preventDefault();
            }
            lastY = y;
        }, { passive: false });
    </script>
</body>
</html>