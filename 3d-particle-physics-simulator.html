<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Particle Physics Simulator</title>
    <meta name="description" content="Advanced 3D particle physics simulation with gravity, collisions, force fields, and real-time WebGL rendering">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
            color: #e0e0e0;
            overflow: hidden;
            height: 100vh;
        }

        #app-container {
            display: flex;
            height: 100vh;
        }

        #canvas-container {
            flex: 1;
            position: relative;
        }

        #webgl-canvas {
            width: 100%;
            height: 100%;
            display: block;
            cursor: grab;
        }

        #webgl-canvas:active {
            cursor: grabbing;
        }

        #controls-panel {
            width: 320px;
            background: rgba(20, 20, 30, 0.95);
            padding: 20px;
            overflow-y: auto;
            box-shadow: -5px 0 20px rgba(0, 0, 0, 0.3);
        }

        h1 {
            font-size: 20px;
            margin-bottom: 20px;
            color: #00d9ff;
            text-align: center;
            text-shadow: 0 0 10px rgba(0, 217, 255, 0.3);
        }

        .control-section {
            margin-bottom: 25px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 8px;
            border: 1px solid rgba(0, 217, 255, 0.1);
        }

        .control-section h2 {
            font-size: 14px;
            margin-bottom: 12px;
            color: #00d9ff;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .control-group {
            margin-bottom: 12px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            color: #aaa;
        }

        input[type="range"] {
            width: 100%;
            height: 4px;
            border-radius: 2px;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #00d9ff;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 217, 255, 0.5);
        }

        input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #00d9ff;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 10px rgba(0, 217, 255, 0.5);
        }

        .value-display {
            display: inline-block;
            float: right;
            color: #00d9ff;
            font-weight: bold;
            font-size: 11px;
        }

        button {
            width: 100%;
            padding: 10px;
            margin-bottom: 8px;
            background: linear-gradient(135deg, #00d9ff 0%, #0099cc 100%);
            color: #fff;
            border: none;
            border-radius: 5px;
            font-size: 13px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 217, 255, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button.secondary {
            background: linear-gradient(135deg, #ff006e 0%, #cc0055 100%);
        }

        select {
            width: 100%;
            padding: 8px;
            background: rgba(255, 255, 255, 0.05);
            color: #e0e0e0;
            border: 1px solid rgba(0, 217, 255, 0.2);
            border-radius: 5px;
            font-size: 12px;
            cursor: pointer;
        }

        .stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
        }

        .stat-box {
            background: rgba(0, 217, 255, 0.05);
            padding: 10px;
            border-radius: 5px;
            text-align: center;
            border: 1px solid rgba(0, 217, 255, 0.2);
        }

        .stat-label {
            font-size: 10px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .stat-value {
            font-size: 18px;
            color: #00d9ff;
            font-weight: bold;
            margin-top: 5px;
        }

        #info-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 20px;
            border-radius: 8px;
            font-size: 12px;
            line-height: 1.6;
            pointer-events: none;
            border: 1px solid rgba(0, 217, 255, 0.3);
        }

        .preset-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 10px;
        }

        .preset-buttons button {
            font-size: 11px;
            padding: 8px;
        }

        @media (max-width: 768px) {
            #app-container {
                flex-direction: column;
            }
            #controls-panel {
                width: 100%;
                height: 40vh;
            }
            #canvas-container {
                height: 60vh;
            }
        }
    </style>
</head>
<body>
    <div id="app-container">
        <div id="canvas-container">
            <canvas id="webgl-canvas"></canvas>
            <div id="info-overlay">
                <div><strong>Controls:</strong></div>
                <div>üñ±Ô∏è Drag: Rotate view</div>
                <div>üñ±Ô∏è Scroll: Zoom in/out</div>
                <div>‚å®Ô∏è Space: Pause/Resume</div>
            </div>
        </div>
        <div id="controls-panel">
            <h1>‚öõÔ∏è 3D Particle Physics</h1>

            <div class="control-section">
                <h2>Simulation</h2>
                <button id="pauseBtn">‚è∏Ô∏è Pause</button>
                <button id="resetBtn" class="secondary">üîÑ Reset</button>
                <button id="addParticlesBtn">‚ûï Add 100 Particles</button>

                <div class="stats">
                    <div class="stat-box">
                        <div class="stat-label">Particles</div>
                        <div class="stat-value" id="particleCount">1000</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">FPS</div>
                        <div class="stat-value" id="fpsCounter">60</div>
                    </div>
                </div>
            </div>

            <div class="control-section">
                <h2>Particle Properties</h2>
                <div class="control-group">
                    <label>Particle Size <span class="value-display" id="sizeValue">2.0</span></label>
                    <input type="range" id="particleSize" min="0.5" max="5" step="0.1" value="2">
                </div>
                <div class="control-group">
                    <label>Mass <span class="value-display" id="massValue">1.0</span></label>
                    <input type="range" id="particleMass" min="0.1" max="5" step="0.1" value="1">
                </div>
                <div class="control-group">
                    <label>Velocity Damping <span class="value-display" id="dampingValue">0.99</span></label>
                    <input type="range" id="damping" min="0.90" max="1.00" step="0.01" value="0.99">
                </div>
            </div>

            <div class="control-section">
                <h2>Forces</h2>
                <div class="control-group">
                    <label>Gravity <span class="value-display" id="gravityValue">0.5</span></label>
                    <input type="range" id="gravity" min="0" max="2" step="0.1" value="0.5">
                </div>
                <div class="control-group">
                    <label>Force Field Type</label>
                    <select id="forceFieldType">
                        <option value="none">None</option>
                        <option value="attract">Central Attraction</option>
                        <option value="repel">Central Repulsion</option>
                        <option value="vortex" selected>Vortex</option>
                        <option value="orbit">Orbital</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Force Strength <span class="value-display" id="forceValue">0.3</span></label>
                    <input type="range" id="forceStrength" min="0" max="2" step="0.1" value="0.3">
                </div>
            </div>

            <div class="control-section">
                <h2>Visual Settings</h2>
                <div class="control-group">
                    <label>Color Mode</label>
                    <select id="colorMode">
                        <option value="velocity">Velocity Based</option>
                        <option value="height">Height Based</option>
                        <option value="distance">Distance from Center</option>
                        <option value="static">Static Rainbow</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Trail Length <span class="value-display" id="trailValue">0.95</span></label>
                    <input type="range" id="trailLength" min="0" max="0.99" step="0.01" value="0.95">
                </div>
            </div>

            <div class="control-section">
                <h2>Presets</h2>
                <div class="preset-buttons">
                    <button onclick="loadPreset('galaxy')">üåå Galaxy</button>
                    <button onclick="loadPreset('explosion')">üí• Explosion</button>
                    <button onclick="loadPreset('dance')">üíÉ Dance</button>
                    <button onclick="loadPreset('fountain')">‚õ≤ Fountain</button>
                </div>
            </div>

            <div class="control-section">
                <h2>Data Management</h2>
                <button id="exportBtn">üíæ Export Settings</button>
                <button id="importBtn">üì• Import Settings</button>
                <input type="file" id="fileInput" accept=".json" style="display: none;">
            </div>
        </div>
    </div>

    <script>
        // ========================================
        // WebGL Setup
        // ========================================
        const canvas = document.getElementById('webgl-canvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

        if (!gl) {
            alert('WebGL not supported in your browser');
            throw new Error('WebGL not supported');
        }

        // Resize canvas
        function resizeCanvas() {
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // ========================================
        // Shader Programs
        // ========================================
        const vertexShaderSource = `
            attribute vec3 aPosition;
            attribute vec3 aColor;

            uniform mat4 uModelViewMatrix;
            uniform mat4 uProjectionMatrix;
            uniform float uPointSize;

            varying vec3 vColor;

            void main() {
                gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aPosition, 1.0);
                gl_PointSize = uPointSize;
                vColor = aColor;
            }
        `;

        const fragmentShaderSource = `
            precision mediump float;
            varying vec3 vColor;

            void main() {
                vec2 coord = gl_PointCoord - vec2(0.5);
                float dist = length(coord);
                if (dist > 0.5) discard;

                float alpha = 1.0 - (dist * 2.0);
                gl_FragColor = vec4(vColor, alpha);
            }
        `;

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program link error:', gl.getProgramInfoLog(program));
                gl.deleteProgram(program);
                return null;
            }
            return program;
        }

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        const program = createProgram(gl, vertexShader, fragmentShader);

        // Get attribute and uniform locations
        const aPosition = gl.getAttribLocation(program, 'aPosition');
        const aColor = gl.getAttribLocation(program, 'aColor');
        const uModelViewMatrix = gl.getUniformLocation(program, 'uModelViewMatrix');
        const uProjectionMatrix = gl.getUniformLocation(program, 'uProjectionMatrix');
        const uPointSize = gl.getUniformLocation(program, 'uPointSize');

        // ========================================
        // Particle System
        // ========================================
        class Particle {
            constructor(x, y, z) {
                this.position = [x, y, z];
                this.velocity = [
                    (Math.random() - 0.5) * 0.5,
                    (Math.random() - 0.5) * 0.5,
                    (Math.random() - 0.5) * 0.5
                ];
                this.acceleration = [0, 0, 0];
                this.mass = parseFloat(document.getElementById('particleMass').value);
                this.color = [1, 1, 1];
            }

            applyForce(force) {
                this.acceleration[0] += force[0] / this.mass;
                this.acceleration[1] += force[1] / this.mass;
                this.acceleration[2] += force[2] / this.mass;
            }

            update(dt) {
                // Update velocity
                this.velocity[0] += this.acceleration[0] * dt;
                this.velocity[1] += this.acceleration[1] * dt;
                this.velocity[2] += this.acceleration[2] * dt;

                // Apply damping
                const damping = parseFloat(document.getElementById('damping').value);
                this.velocity[0] *= damping;
                this.velocity[1] *= damping;
                this.velocity[2] *= damping;

                // Update position
                this.position[0] += this.velocity[0] * dt;
                this.position[1] += this.velocity[1] * dt;
                this.position[2] += this.velocity[2] * dt;

                // Boundary collision
                const bounds = 50;
                const restitution = 0.8;

                for (let i = 0; i < 3; i++) {
                    if (this.position[i] > bounds) {
                        this.position[i] = bounds;
                        this.velocity[i] *= -restitution;
                    } else if (this.position[i] < -bounds) {
                        this.position[i] = -bounds;
                        this.velocity[i] *= -restitution;
                    }
                }

                // Reset acceleration
                this.acceleration = [0, 0, 0];
            }

            updateColor(mode) {
                switch(mode) {
                    case 'velocity':
                        const speed = Math.sqrt(
                            this.velocity[0]**2 +
                            this.velocity[1]**2 +
                            this.velocity[2]**2
                        );
                        const hue = (speed * 50) % 360;
                        this.color = hslToRgb(hue, 100, 60);
                        break;

                    case 'height':
                        const heightHue = ((this.position[1] + 50) / 100) * 240;
                        this.color = hslToRgb(heightHue, 80, 60);
                        break;

                    case 'distance':
                        const dist = Math.sqrt(
                            this.position[0]**2 +
                            this.position[1]**2 +
                            this.position[2]**2
                        );
                        const distHue = (dist / 50) * 180;
                        this.color = hslToRgb(distHue, 90, 60);
                        break;

                    case 'static':
                        const staticHue = (particles.indexOf(this) * 360 / particles.length) % 360;
                        this.color = hslToRgb(staticHue, 80, 60);
                        break;
                }
            }
        }

        function hslToRgb(h, s, l) {
            s /= 100;
            l /= 100;
            const c = (1 - Math.abs(2 * l - 1)) * s;
            const x = c * (1 - Math.abs((h / 60) % 2 - 1));
            const m = l - c / 2;
            let r, g, b;

            if (h < 60) { r = c; g = x; b = 0; }
            else if (h < 120) { r = x; g = c; b = 0; }
            else if (h < 180) { r = 0; g = c; b = x; }
            else if (h < 240) { r = 0; g = x; b = c; }
            else if (h < 300) { r = x; g = 0; b = c; }
            else { r = c; g = 0; b = x; }

            return [(r + m), (g + m), (b + m)];
        }

        // Initialize particles
        let particles = [];
        function initParticles(count) {
            particles = [];
            for (let i = 0; i < count; i++) {
                const radius = Math.random() * 30;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;

                const x = radius * Math.sin(phi) * Math.cos(theta);
                const y = radius * Math.sin(phi) * Math.sin(theta);
                const z = radius * Math.cos(phi);

                particles.push(new Particle(x, y, z));
            }
        }

        initParticles(1000);

        // Create buffers
        const positionBuffer = gl.createBuffer();
        const colorBuffer = gl.createBuffer();

        // ========================================
        // Matrix Math
        // ========================================
        function createPerspectiveMatrix(fov, aspect, near, far) {
            const f = 1.0 / Math.tan(fov / 2);
            const rangeInv = 1 / (near - far);

            return [
                f / aspect, 0, 0, 0,
                0, f, 0, 0,
                0, 0, (near + far) * rangeInv, -1,
                0, 0, near * far * rangeInv * 2, 0
            ];
        }

        function multiplyMatrices(a, b) {
            const result = new Array(16);
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    result[i * 4 + j] =
                        a[i * 4 + 0] * b[0 * 4 + j] +
                        a[i * 4 + 1] * b[1 * 4 + j] +
                        a[i * 4 + 2] * b[2 * 4 + j] +
                        a[i * 4 + 3] * b[3 * 4 + j];
                }
            }
            return result;
        }

        function createRotationMatrix(angleX, angleY) {
            const cosX = Math.cos(angleX);
            const sinX = Math.sin(angleX);
            const cosY = Math.cos(angleY);
            const sinY = Math.sin(angleY);

            const rotX = [
                1, 0, 0, 0,
                0, cosX, -sinX, 0,
                0, sinX, cosX, 0,
                0, 0, 0, 1
            ];

            const rotY = [
                cosY, 0, sinY, 0,
                0, 1, 0, 0,
                -sinY, 0, cosY, 0,
                0, 0, 0, 1
            ];

            return multiplyMatrices(rotY, rotX);
        }

        function createTranslationMatrix(x, y, z) {
            return [
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                x, y, z, 1
            ];
        }

        // ========================================
        // Camera Controls
        // ========================================
        let cameraRotationX = 0.3;
        let cameraRotationY = 0.5;
        let cameraDistance = 100;
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;

        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaX = e.clientX - lastMouseX;
                const deltaY = e.clientY - lastMouseY;

                cameraRotationY += deltaX * 0.01;
                cameraRotationX += deltaY * 0.01;

                cameraRotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, cameraRotationX));

                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            cameraDistance += e.deltaY * 0.1;
            cameraDistance = Math.max(50, Math.min(200, cameraDistance));
        });

        // ========================================
        // Physics Forces
        // ========================================
        function applyForces() {
            const gravity = parseFloat(document.getElementById('gravity').value);
            const forceType = document.getElementById('forceFieldType').value;
            const forceStrength = parseFloat(document.getElementById('forceStrength').value);

            particles.forEach(particle => {
                // Gravity
                if (gravity > 0) {
                    particle.applyForce([0, -gravity * particle.mass, 0]);
                }

                // Force fields
                if (forceType !== 'none') {
                    const dx = -particle.position[0];
                    const dy = -particle.position[1];
                    const dz = -particle.position[2];
                    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);

                    if (dist > 0.1) {
                        const nx = dx / dist;
                        const ny = dy / dist;
                        const nz = dz / dist;

                        switch(forceType) {
                            case 'attract':
                                const attractForce = forceStrength * particle.mass / (dist * 0.1);
                                particle.applyForce([nx * attractForce, ny * attractForce, nz * attractForce]);
                                break;

                            case 'repel':
                                const repelForce = forceStrength * particle.mass * 10 / (dist * dist);
                                particle.applyForce([-nx * repelForce, -ny * repelForce, -nz * repelForce]);
                                break;

                            case 'vortex':
                                const perpX = -particle.position[2];
                                const perpZ = particle.position[0];
                                const perpDist = Math.sqrt(perpX*perpX + perpZ*perpZ);
                                if (perpDist > 0.1) {
                                    const vortexForce = forceStrength * particle.mass / dist;
                                    particle.applyForce([
                                        perpX / perpDist * vortexForce,
                                        ny * forceStrength * 0.5,
                                        perpZ / perpDist * vortexForce
                                    ]);
                                }
                                break;

                            case 'orbit':
                                const tangentX = -dz;
                                const tangentZ = dx;
                                const tangentDist = Math.sqrt(tangentX*tangentX + tangentZ*tangentZ);
                                if (tangentDist > 0.1) {
                                    const orbitForce = forceStrength * particle.mass * 0.5;
                                    particle.applyForce([
                                        tangentX / tangentDist * orbitForce + nx * forceStrength * 0.2,
                                        0,
                                        tangentZ / tangentDist * orbitForce + nz * forceStrength * 0.2
                                    ]);
                                }
                                break;
                        }
                    }
                }
            });
        }

        // ========================================
        // Animation Loop
        // ========================================
        let isPaused = false;
        let lastTime = performance.now();
        let frameCount = 0;
        let lastFpsTime = performance.now();

        function animate(currentTime) {
            requestAnimationFrame(animate);

            // Calculate delta time
            const dt = Math.min((currentTime - lastTime) / 1000, 0.033); // Cap at 30fps
            lastTime = currentTime;

            // Update FPS counter
            frameCount++;
            if (currentTime - lastFpsTime > 1000) {
                document.getElementById('fpsCounter').textContent = frameCount;
                frameCount = 0;
                lastFpsTime = currentTime;
            }

            // Update physics
            if (!isPaused) {
                applyForces();
                particles.forEach(particle => {
                    particle.update(dt);
                    particle.updateColor(document.getElementById('colorMode').value);
                });
            }

            // Render
            render();
        }

        function render() {
            // Apply trail effect
            const trailLength = parseFloat(document.getElementById('trailLength').value);
            if (trailLength > 0) {
                gl.clearColor(0, 0, 0, 1 - trailLength);
            } else {
                gl.clearColor(0.04, 0.04, 0.12, 1);
            }
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

            // Prepare data
            const positions = new Float32Array(particles.length * 3);
            const colors = new Float32Array(particles.length * 3);

            particles.forEach((particle, i) => {
                positions[i * 3] = particle.position[0];
                positions[i * 3 + 1] = particle.position[1];
                positions[i * 3 + 2] = particle.position[2];

                colors[i * 3] = particle.color[0];
                colors[i * 3 + 1] = particle.color[1];
                colors[i * 3 + 2] = particle.color[2];
            });

            // Update buffers
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, positions, gl.DYNAMIC_DRAW);

            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, colors, gl.DYNAMIC_DRAW);

            // Use shader program
            gl.useProgram(program);

            // Set up attributes
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.enableVertexAttribArray(aPosition);
            gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.enableVertexAttribArray(aColor);
            gl.vertexAttribPointer(aColor, 3, gl.FLOAT, false, 0, 0);

            // Set up matrices
            const aspect = canvas.width / canvas.height;
            const projectionMatrix = createPerspectiveMatrix(Math.PI / 4, aspect, 0.1, 1000);

            const rotationMatrix = createRotationMatrix(cameraRotationX, cameraRotationY);
            const translationMatrix = createTranslationMatrix(0, 0, -cameraDistance);
            const modelViewMatrix = multiplyMatrices(translationMatrix, rotationMatrix);

            gl.uniformMatrix4fv(uProjectionMatrix, false, projectionMatrix);
            gl.uniformMatrix4fv(uModelViewMatrix, false, modelViewMatrix);
            gl.uniform1f(uPointSize, parseFloat(document.getElementById('particleSize').value) * (canvas.width / 1000));

            // Draw particles
            gl.drawArrays(gl.POINTS, 0, particles.length);
        }

        // ========================================
        // UI Controls
        // ========================================
        document.getElementById('pauseBtn').addEventListener('click', () => {
            isPaused = !isPaused;
            document.getElementById('pauseBtn').textContent = isPaused ? '‚ñ∂Ô∏è Resume' : '‚è∏Ô∏è Pause';
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            initParticles(particles.length);
        });

        document.getElementById('addParticlesBtn').addEventListener('click', () => {
            const currentCount = particles.length;
            for (let i = 0; i < 100; i++) {
                const radius = Math.random() * 30;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;

                const x = radius * Math.sin(phi) * Math.cos(theta);
                const y = radius * Math.sin(phi) * Math.sin(theta);
                const z = radius * Math.cos(phi);

                particles.push(new Particle(x, y, z));
            }
            document.getElementById('particleCount').textContent = particles.length;
        });

        // Update value displays
        document.getElementById('particleSize').addEventListener('input', (e) => {
            document.getElementById('sizeValue').textContent = e.target.value;
        });

        document.getElementById('particleMass').addEventListener('input', (e) => {
            document.getElementById('massValue').textContent = e.target.value;
            particles.forEach(p => p.mass = parseFloat(e.target.value));
        });

        document.getElementById('damping').addEventListener('input', (e) => {
            document.getElementById('dampingValue').textContent = e.target.value;
        });

        document.getElementById('gravity').addEventListener('input', (e) => {
            document.getElementById('gravityValue').textContent = e.target.value;
        });

        document.getElementById('forceStrength').addEventListener('input', (e) => {
            document.getElementById('forceValue').textContent = e.target.value;
        });

        document.getElementById('trailLength').addEventListener('input', (e) => {
            document.getElementById('trailValue').textContent = e.target.value;
        });

        // Update particle count display
        setInterval(() => {
            document.getElementById('particleCount').textContent = particles.length;
        }, 1000);

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                document.getElementById('pauseBtn').click();
            }
        });

        // ========================================
        // Presets
        // ========================================
        window.loadPreset = function(preset) {
            switch(preset) {
                case 'galaxy':
                    initParticles(2000);
                    document.getElementById('forceFieldType').value = 'orbit';
                    document.getElementById('forceStrength').value = 0.8;
                    document.getElementById('gravity').value = 0;
                    document.getElementById('colorMode').value = 'distance';
                    document.getElementById('trailLength').value = 0.98;
                    break;

                case 'explosion':
                    particles.forEach(p => {
                        const force = 20;
                        const dx = p.position[0];
                        const dy = p.position[1];
                        const dz = p.position[2];
                        const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                        if (dist > 0) {
                            p.velocity[0] = (dx / dist) * force;
                            p.velocity[1] = (dy / dist) * force;
                            p.velocity[2] = (dz / dist) * force;
                        }
                    });
                    document.getElementById('forceFieldType').value = 'repel';
                    document.getElementById('forceStrength').value = 1.5;
                    document.getElementById('colorMode').value = 'velocity';
                    break;

                case 'dance':
                    document.getElementById('forceFieldType').value = 'vortex';
                    document.getElementById('forceStrength').value = 1.2;
                    document.getElementById('gravity').value = 0.3;
                    document.getElementById('colorMode').value = 'height';
                    document.getElementById('trailLength').value = 0.90;
                    break;

                case 'fountain':
                    initParticles(1500);
                    document.getElementById('forceFieldType').value = 'attract';
                    document.getElementById('forceStrength').value = 0.5;
                    document.getElementById('gravity').value = 1.2;
                    document.getElementById('colorMode').value = 'height';
                    document.getElementById('trailLength').value = 0.85;
                    break;
            }
        };

        // ========================================
        // Data Management
        // ========================================
        function getSettings() {
            return {
                particleCount: particles.length,
                particleSize: document.getElementById('particleSize').value,
                particleMass: document.getElementById('particleMass').value,
                damping: document.getElementById('damping').value,
                gravity: document.getElementById('gravity').value,
                forceFieldType: document.getElementById('forceFieldType').value,
                forceStrength: document.getElementById('forceStrength').value,
                colorMode: document.getElementById('colorMode').value,
                trailLength: document.getElementById('trailLength').value,
                timestamp: new Date().toISOString()
            };
        }

        function applySettings(settings) {
            if (settings.particleCount) initParticles(settings.particleCount);
            if (settings.particleSize) document.getElementById('particleSize').value = settings.particleSize;
            if (settings.particleMass) document.getElementById('particleMass').value = settings.particleMass;
            if (settings.damping) document.getElementById('damping').value = settings.damping;
            if (settings.gravity) document.getElementById('gravity').value = settings.gravity;
            if (settings.forceFieldType) document.getElementById('forceFieldType').value = settings.forceFieldType;
            if (settings.forceStrength) document.getElementById('forceStrength').value = settings.forceStrength;
            if (settings.colorMode) document.getElementById('colorMode').value = settings.colorMode;
            if (settings.trailLength) document.getElementById('trailLength').value = settings.trailLength;

            // Trigger input events to update displays
            ['particleSize', 'particleMass', 'damping', 'gravity', 'forceStrength', 'trailLength'].forEach(id => {
                document.getElementById(id).dispatchEvent(new Event('input'));
            });
        }

        document.getElementById('exportBtn').addEventListener('click', () => {
            const settings = getSettings();
            const blob = new Blob([JSON.stringify(settings, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `particle-sim-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        });

        document.getElementById('importBtn').addEventListener('click', () => {
            document.getElementById('fileInput').click();
        });

        document.getElementById('fileInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const settings = JSON.parse(e.target.result);
                        applySettings(settings);
                    } catch (error) {
                        alert('Invalid settings file');
                    }
                };
                reader.readAsText(file);
            }
        });

        // Auto-save to localStorage
        setInterval(() => {
            localStorage.setItem('particleSimSettings', JSON.stringify(getSettings()));
        }, 5000);

        // Load saved settings
        const savedSettings = localStorage.getItem('particleSimSettings');
        if (savedSettings) {
            try {
                applySettings(JSON.parse(savedSettings));
            } catch (e) {
                console.error('Failed to load saved settings');
            }
        }

        // Start animation
        animate(performance.now());
    </script>
</body>
</html>