<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>AI Companion Hub - Interactive Assistant</title>

    <!-- Preload critical resources -->
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js" as="script">
    <link rel="preload" href="https://threejs.org/examples/fonts/helvetiker_regular.typeface.json" as="fetch" crossorigin>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
            -webkit-overflow-scrolling: touch;
        }

        /* Enhanced loading screen */
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            transition: opacity 0.5s ease;
        }

        .loading.fade-out {
            opacity: 0;
            pointer-events: none;
        }

        .loading-content {
            text-align: center;
        }

        .loading-logo {
            width: 80px;
            height: 80px;
            margin-bottom: 30px;
            position: relative;
        }

        .loading-orb {
            width: 80px;
            height: 80px;
            background: linear-gradient(45deg, #06ffa5, #8338ec);
            border-radius: 50%;
            animation: loadingPulse 2s infinite;
            box-shadow: 0 0 40px rgba(6, 255, 165, 0.5);
        }

        @keyframes loadingPulse {
            0%, 100% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.1); opacity: 1; }
        }

        .loading-text {
            font-size: 1.2em;
            color: rgba(255, 255, 255, 0.9);
            font-weight: 200;
            letter-spacing: 0.1em;
            margin-bottom: 20px;
        }

        .loading-progress {
            width: 200px;
            height: 2px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 1px;
            overflow: hidden;
            margin: 0 auto;
        }

        .loading-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #06ffa5, #8338ec);
            border-radius: 1px;
            width: 0%;
            transition: width 0.3s ease;
        }

        .loading-status {
            margin-top: 15px;
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.6);
        }

        #three-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            cursor: default;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        #three-container.visible {
            opacity: 1;
        }

        /* Tool Overlay Window */
        .tool-overlay {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            width: 90%;
            max-width: 1200px;
            height: 85vh;
            background: rgba(20, 20, 40, 0.98);
            border: 2px solid rgba(138, 43, 226, 0.5);
            border-radius: 20px;
            z-index: 2004;
            display: none;
            opacity: 0;
            transition: all 0.3s ease;
            box-shadow: 0 0 50px rgba(138, 43, 226, 0.3);
            backdrop-filter: blur(10px);
        }

        .tool-overlay.active {
            display: block;
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
        }

        .tool-overlay-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            background: rgba(0, 0, 0, 0.3);
            border-radius: 20px 20px 0 0;
        }

        .tool-overlay-title {
            font-size: 1.5em;
            font-weight: 300;
            color: #06ffa5;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .tool-overlay-actions {
            display: flex;
            gap: 10px;
        }

        .tool-overlay-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 10px 20px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .tool-overlay-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }

        .tool-overlay-btn.primary {
            background: linear-gradient(45deg, #06ffa5, #00cc88);
            border: none;
            color: #000;
            font-weight: bold;
        }

        .tool-overlay-btn.primary:hover {
            box-shadow: 0 4px 20px rgba(6, 255, 165, 0.4);
        }

        .tool-overlay-close {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            font-size: 30px;
            cursor: pointer;
            color: #fff;
            transition: all 0.3s;
        }

        .tool-overlay-close:hover {
            color: #ff006e;
            transform: rotate(90deg);
        }

        .tool-overlay-content {
            height: calc(100% - 80px);
            position: relative;
            overflow: hidden;
            border-radius: 0 0 20px 20px;
        }

        .tool-iframe {
            width: 100%;
            height: 100%;
            border: none;
            background: white;
            border-radius: 0 0 20px 20px;
        }

        .tool-loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: rgba(255, 255, 255, 0.6);
        }

        .tool-loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top-color: #06ffa5;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Tool Gallery Button */
        .tool-gallery-button {
            position: fixed;
            bottom: calc(env(safe-area-inset-bottom, 30px) + 320px);
            right: calc(env(safe-area-inset-right, 30px));
            width: 60px;
            height: 60px;
            background: rgba(255, 106, 0, 0.3);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 106, 0, 0.5);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 1002;
            box-shadow: 0 0 20px rgba(255, 106, 0, 0.3);
            opacity: 0;
            transform: scale(0.8);
            animation: fadeInButton 0.5s ease 0.4s forwards;
        }

        .tool-gallery-button:hover {
            background: rgba(255, 106, 0, 0.5);
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(255, 106, 0, 0.5);
        }

        .tool-gallery-button svg {
            width: 28px;
            height: 28px;
            color: white;
        }

        /* Show Mode Button */
        .show-mode-button {
            position: fixed;
            bottom: calc(env(safe-area-inset-bottom, 30px) + 240px);
            right: calc(env(safe-area-inset-right, 30px));
            width: 60px;
            height: 60px;
            background: rgba(0, 255, 255, 0.3);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 1002;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
            opacity: 0;
            transform: scale(0.8);
            animation: fadeInButton 0.5s ease 0.5s forwards;
        }

        @keyframes fadeInButton {
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .show-mode-button:hover {
            background: rgba(0, 255, 255, 0.5);
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
        }

        .show-mode-button.active {
            background: rgba(0, 255, 0, 0.3);
            border-color: rgba(0, 255, 0, 0.5);
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
        }

        .show-mode-button svg {
            width: 28px;
            height: 28px;
            color: white;
        }

        /* Show Mode Status */
        .show-mode-status {
            position: fixed;
            top: env(safe-area-inset-top, 80px);
            right: env(safe-area-inset-right, 20px);
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border-radius: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .show-mode-status.visible {
            opacity: 1;
        }

        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #888;
            transition: all 0.3s ease;
        }

        .status-indicator.connected {
            background: #00ff00;
            box-shadow: 0 0 10px #00ff00;
        }

        .status-indicator.hosting {
            background: #06ffa5;
            box-shadow: 0 0 10px #06ffa5;
        }

        .status-text {
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.9em;
        }

        .viewer-count {
            color: #06ffa5;
            font-weight: bold;
        }

        /* Viewer Mode Indicator */
        .viewer-mode-indicator {
            position: fixed;
            top: env(safe-area-inset-top, 20px);
            left: env(safe-area-inset-left, 20px);
            background: rgba(138, 43, 226, 0.9);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            display: none;
            align-items: center;
            gap: 10px;
            z-index: 1005;
            font-weight: bold;
            animation: pulse 2s infinite;
        }

        .viewer-mode-indicator.active {
            display: flex;
        }

        .viewer-mode-indicator svg {
            width: 20px;
            height: 20px;
        }

        /* Show Mode Modal */
        .show-mode-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 2001;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(5px);
        }

        .show-mode-modal.show {
            display: flex;
        }

        .show-mode-modal-content {
            background: rgba(20, 20, 40, 0.95);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            padding: 30px;
            max-width: 400px;
            width: 90%;
            text-align: center;
            position: relative;
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.3);
        }

        .modal-close {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            font-size: 30px;
            cursor: pointer;
            color: #fff;
            transition: all 0.3s;
        }

        .modal-close:hover {
            color: #ff006e;
            transform: rotate(90deg);
        }

        .show-mode-modal h3 {
            margin: 0 0 20px 0;
            font-size: 24px;
            background: linear-gradient(45deg, #00ffff, #0088ff, #06ffa5);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .show-mode-info {
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 10px;
            padding: 10px;
            margin: 15px 0;
            font-size: 0.9em;
            color: #06ffa5;
        }

        #qr-code-container {
            margin: 20px auto;
            display: flex;
            justify-content: center;
            padding: 20px;
            background: white;
            border-radius: 15px;
            min-height: 250px;
        }

        #qr-code-container canvas,
        #qr-code-container img {
            border-radius: 10px;
        }

        .qr-url {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            word-break: break-all;
            margin: 20px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            font-family: monospace;
        }

        .copy-url-btn {
            background: linear-gradient(45deg, #00ffff, #0088ff);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .copy-url-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(0, 255, 255, 0.4);
        }

        .copy-url-btn.copied {
            background: linear-gradient(45deg, #06ffa5, #00ff88);
        }

        /* Show Mode Notifications */
        .show-mode-notification {
            position: fixed;
            top: 100px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            border: 2px solid rgba(0, 255, 255, 0.5);
            animation: slideIn 0.3s ease;
            z-index: 1005;
            backdrop-filter: blur(10px);
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* Following Indicator */
        .following-indicator {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 255, 255, 0.9);
            color: #000;
            padding: 10px 20px;
            border-radius: 20px;
            display: none;
            align-items: center;
            gap: 10px;
            z-index: 1004;
            font-weight: bold;
            animation: pulse 2s infinite;
        }

        .following-indicator.active {
            display: flex;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.9; }
            50% { opacity: 0.6; }
        }

        /* Settings Button */
        .settings-button {
            position: fixed;
            bottom: calc(env(safe-area-inset-bottom, 30px) + 160px);
            right: calc(env(safe-area-inset-right, 30px));
            width: 60px;
            height: 60px;
            background: rgba(138, 43, 226, 0.3);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(138, 43, 226, 0.5);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 1002;
            box-shadow: 0 0 20px rgba(138, 43, 226, 0.3);
            opacity: 0;
            transform: scale(0.8);
            animation: fadeInButton 0.5s ease 0.6s forwards;
        }

        .settings-button:hover {
            background: rgba(138, 43, 226, 0.5);
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(138, 43, 226, 0.5);
        }

        .settings-button svg {
            width: 28px;
            height: 28px;
            color: white;
        }

        /* Settings Panel */
        .settings-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 20, 40, 0.95);
            border: 2px solid rgba(138, 43, 226, 0.5);
            border-radius: 20px;
            padding: 30px;
            z-index: 2003;
            max-width: 600px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 0 50px rgba(138, 43, 226, 0.3);
            display: none;
            backdrop-filter: blur(10px);
        }

        .settings-panel.active {
            display: block;
        }

        .settings-panel h2 {
            margin: 0 0 25px 0;
            font-size: 28px;
            background: linear-gradient(45deg, #8a2be2, #06ffa5);
            background-clip: text;
            -webkit-text-fill-color: transparent;
            text-align: center;
        }

        .settings-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 25px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 15px;
        }

        .settings-tab {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 8px 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
        }

        .settings-tab:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .settings-tab.active {
            background: linear-gradient(45deg, #8a2be2, #06ffa5);
            border-color: transparent;
        }

        .settings-section {
            display: none;
        }

        .settings-section.active {
            display: block;
        }

        .settings-group {
            margin-bottom: 20px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .settings-group h3 {
            margin: 0 0 15px 0;
            font-size: 18px;
            color: #06ffa5;
        }

        .setting-item {
            margin-bottom: 15px;
        }

        .setting-item label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.8);
        }

        .setting-item input[type="text"],
        .setting-item input[type="password"],
        .setting-item input[type="number"],
        .setting-item select {
            width: 100%;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            color: white;
            font-size: 14px;
        }

        .setting-item input[type="range"] {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }

        .setting-item input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: #8a2be2;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .setting-item input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            background: #06ffa5;
        }

        .range-value {
            display: inline-block;
            margin-left: 10px;
            font-family: monospace;
            color: #06ffa5;
            font-size: 13px;
            min-width: 60px;
        }

        .toggle-setting {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .toggle-switch {
            position: relative;
            width: 48px;
            height: 24px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .toggle-switch.active {
            background: #06ffa5;
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            transition: all 0.3s ease;
        }

        .toggle-switch.active::after {
            transform: translateX(24px);
        }

        .settings-actions {
            display: flex;
            gap: 10px;
            margin-top: 25px;
            padding-top: 20px;
            border-top: 2px solid rgba(255, 255, 255, 0.1);
        }

        .settings-btn {
            flex: 1;
            padding: 12px 20px;
            background: linear-gradient(45deg, #8a2be2, #06ffa5);
            border: none;
            border-radius: 10px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .settings-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(138, 43, 226, 0.4);
        }

        .settings-btn.secondary {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .settings-btn.danger {
            background: linear-gradient(45deg, #ff0066, #ff4458);
        }

        .close-settings {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            font-size: 30px;
            cursor: pointer;
            color: #fff;
            transition: all 0.3s;
        }

        .close-settings:hover {
            color: #ff006e;
            transform: rotate(90deg);
        }

        .import-export-section {
            margin-top: 20px;
            padding: 20px;
            background: rgba(138, 43, 226, 0.1);
            border-radius: 15px;
            border: 1px solid rgba(138, 43, 226, 0.3);
        }

        .import-export-section h4 {
            margin: 0 0 15px 0;
            color: #8a2be2;
            font-size: 16px;
        }

        .json-preview {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 15px;
            font-family: monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
            margin: 10px 0;
            white-space: pre-wrap;
            word-break: break-all;
        }

        .file-input-wrapper {
            position: relative;
            display: inline-block;
            width: 100%;
        }

        .file-input-wrapper input[type="file"] {
            position: absolute;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        .file-input-label {
            display: block;
            padding: 12px 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .file-input-label:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: #8a2be2;
        }

        /* Perspective Controls */
        .perspective-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .perspective-preset {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 15px;
        }

        .preset-btn {
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            color: white;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .preset-btn:hover {
            background: rgba(138, 43, 226, 0.3);
            border-color: #8a2be2;
        }

        /* Click to Chat Tooltip */
        .companion-tooltip {
            position: absolute;
            background: rgba(255, 255, 255, 0.9);
            color: #000;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            white-space: nowrap;
            z-index: 1010;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }

        .companion-tooltip.visible {
            opacity: 1;
        }

        /* Voice Pause Button - PROMINENT POSITION */
        .voice-pause-button {
            position: fixed;
            top: calc(env(safe-area-inset-top, 20px) + 60px);
            right: calc(env(safe-area-inset-right, 20px));
            width: 120px;
            height: 50px;
            background: rgba(255, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 0, 0, 0.5);
            border-radius: 25px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 1006;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.3);
            font-weight: bold;
            font-size: 14px;
            opacity: 0;
            transform: scale(0.8);
            animation: fadeInButton 0.5s ease 0.4s forwards;
        }

        .voice-pause-button:hover {
            background: rgba(255, 0, 0, 0.5);
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.5);
        }

        .voice-pause-button.paused {
            background: rgba(255, 165, 0, 0.3);
            border-color: rgba(255, 165, 0, 0.5);
            box-shadow: 0 0 20px rgba(255, 165, 0, 0.3);
        }

        .voice-pause-button.paused:hover {
            background: rgba(255, 165, 0, 0.5);
            box-shadow: 0 0 30px rgba(255, 165, 0, 0.5);
        }

        .voice-pause-button svg {
            width: 24px;
            height: 24px;
            color: white;
        }

        /* Voice Paused Indicator */
        .voice-paused-indicator {
            position: fixed;
            top: calc(env(safe-area-inset-top, 20px) + 10px);
            right: calc(env(safe-area-inset-right, 20px));
            background: rgba(255, 165, 0, 0.9);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            display: none;
            align-items: center;
            gap: 8px;
            z-index: 1005;
            animation: fadeIn 0.3s ease-out;
            font-size: 13px;
            font-weight: bold;
        }

        .voice-paused-indicator.active {
            display: flex;
        }

        .voice-paused-indicator svg {
            width: 16px;
            height: 16px;
            animation: blink 2s infinite;
        }

        @keyframes blink {
            0%, 50%, 100% { opacity: 1; }
            25%, 75% { opacity: 0.3; }
        }

        /* Voice Indicator */
        .voice-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(138, 56, 236, 0.9);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            display: none;
            align-items: center;
            gap: 10px;
            z-index: 1004;
            animation: fadeIn 0.3s ease-out;
        }

        .voice-indicator.active {
            display: flex;
        }

        .voice-indicator i {
            animation: pulse 1.5s infinite;
        }

        /* Listening Indicator */
        .listening-indicator {
            position: fixed;
            top: 80px;
            right: 20px;
            background: rgba(255, 0, 110, 0.9);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            display: none;
            align-items: center;
            gap: 10px;
            z-index: 1004;
            animation: fadeIn 0.3s ease-out;
        }

        .listening-indicator.active {
            display: flex;
        }

        .listening-indicator svg {
            width: 20px;
            height: 20px;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        /* AI Chat Interface */
        .ai-chat-interface {
            position: fixed;
            bottom: calc(env(safe-area-inset-bottom, 20px) + 100px);
            right: calc(env(safe-area-inset-right, 20px));
            width: 350px;
            height: 450px;
            background: rgba(20, 20, 40, 0.85);
            border: 2px solid rgba(138, 56, 236, 0.5);
            border-radius: 20px;
            display: none;
            flex-direction: column;
            z-index: 1003;
            box-shadow: 0 0 30px rgba(138, 56, 236, 0.3);
            backdrop-filter: blur(5px);
        }

        .ai-chat-interface.active {
            display: flex;
        }

        /* Special styling for viewer mode chat */
        .ai-chat-interface.viewer-mode {
            border-color: rgba(0, 255, 255, 0.5);
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
        }

        /* Viewers can still interact with chat */
        .ai-chat-interface.viewer-mode .ai-chat-input-container {
            opacity: 1;
            pointer-events: all;
        }

        .ai-chat-header {
            padding: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .ai-chat-title {
            font-weight: bold;
            color: #06ffa5;
        }

        .viewer-chat-label {
            background: rgba(0, 255, 255, 0.2);
            color: #00ffff;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            margin-left: 10px;
        }

        .ai-chat-messages {
            flex: 1;
            padding: 15px;
            overflow-y: auto;
            scroll-behavior: smooth;
        }

        .ai-message {
            margin: 10px 0;
            padding: 10px 15px;
            border-radius: 15px;
            max-width: 80%;
            word-wrap: break-word;
            overflow-wrap: break-word;
            word-break: break-word;
            font-size: 15px;
            line-height: 1.6;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            transition: all 0.2s ease;
            max-width: 100%;
            overflow-x: auto;
            -webkit-user-select: text;
            user-select: text;
        }

        .ai-message.user {
            background: rgba(131, 56, 236, 0.3);
            margin-left: auto;
            text-align: right;
        }

        .ai-message.ai {
            background: rgba(6, 255, 165, 0.2);
            margin-right: auto;
        }

        /* Tool recommendation styling */
        .tool-recommendation {
            background: rgba(255, 106, 0, 0.15);
            border: 1px solid rgba(255, 106, 0, 0.3);
            border-radius: 10px;
            padding: 10px;
            margin: 10px 0;
        }

        .tool-recommendation-header {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: bold;
            color: #ff6a00;
            margin-bottom: 8px;
        }

        .tool-recommendation-title {
            font-size: 1.1em;
            color: #ffa500;
            margin-bottom: 5px;
        }

        .tool-recommendation-description {
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 10px;
        }

        .tool-recommendation-actions {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .tool-action-btn {
            padding: 8px 16px;
            background: linear-gradient(45deg, #ff6a00, #ff8c00);
            border: none;
            border-radius: 15px;
            color: white;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 5px;
        }

        .tool-action-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(255, 106, 0, 0.4);
        }

        .tool-action-btn.secondary {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .tool-action-btn.secondary:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        /* Presenter label for viewer mode */
        .ai-message.presenter-message::before {
            content: "Presenter";
            display: block;
            font-size: 11px;
            color: #00ffff;
            margin-bottom: 4px;
            opacity: 0.8;
        }

        /* Viewer label for presenter mode */
        .ai-message.viewer-message::before {
            content: attr(data-viewer-name);
            display: block;
            font-size: 11px;
            color: #ff6a00;
            margin-bottom: 4px;
            opacity: 0.8;
        }

        /* Markdown Styles for AI Messages */
        .ai-message.ai h1,
        .ai-message.ai h2,
        .ai-message.ai h3,
        .ai-message.ai h4,
        .ai-message.ai h5,
        .ai-message.ai h6 {
            margin: 0.5em 0 0.3em 0;
            font-weight: 600;
            line-height: 1.3;
            color: #06ffa5;
        }

        .ai-message.ai h1 { font-size: 1.3em; }
        .ai-message.ai h2 { font-size: 1.2em; }
        .ai-message.ai h3 { font-size: 1.1em; }
        .ai-message.ai h4 { font-size: 1.05em; }
        .ai-message.ai h5 { font-size: 1em; }
        .ai-message.ai h6 { font-size: 0.95em; }

        .ai-message.ai p {
            margin: 0.5em 0;
        }

        .ai-message.ai a {
            color: #00ffff;
            text-decoration: underline;
            cursor: pointer;
            transition: color 0.2s ease;
        }

        .ai-message.ai a:hover {
            color: #06ffa5;
            text-decoration: underline;
        }

        .ai-message.ai strong {
            font-weight: 600;
            color: #ffffff;
        }

        .ai-message.ai em {
            font-style: italic;
            color: rgba(255, 255, 255, 0.9);
        }

        .ai-message.ai code {
            background: rgba(0, 0, 0, 0.3);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Monaco', 'Consolas', 'Courier New', monospace;
            font-size: 0.9em;
            color: #06ffa5;
        }

        .ai-message.ai pre {
            background: rgba(0, 0, 0, 0.4);
            padding: 12px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 0.5em 0;
        }

        .ai-message.ai pre code {
            background: none;
            padding: 0;
            color: #ffffff;
        }

        .ai-message.ai blockquote {
            border-left: 4px solid #8338ec;
            padding-left: 12px;
            margin: 0.5em 0;
            color: rgba(255, 255, 255, 0.8);
            font-style: italic;
        }

        .ai-message.ai ul,
        .ai-message.ai ol {
            margin: 0.5em 0;
            padding-left: 1.5em;
        }

        .ai-message.ai li {
            margin: 0.25em 0;
        }

        .ai-message.ai hr {
            border: none;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            margin: 1em 0;
        }

        .ai-message.ai table {
            border-collapse: collapse;
            width: 100%;
            margin: 0.5em 0;
        }

        .ai-message.ai th,
        .ai-message.ai td {
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 8px;
            text-align: left;
        }

        .ai-message.ai th {
            background: rgba(138, 43, 226, 0.2);
            font-weight: 600;
        }

        .ai-message.ai img {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            margin: 0.5em 0;
        }

        .ai-message.task-replay {
            border: 1px solid rgba(255, 106, 0, 0.5);
            opacity: 0.8;
            font-style: italic;
        }

        .ai-typing {
            margin: 10px 0;
            padding: 10px 15px;
            border-radius: 15px;
            max-width: 80%;
            background: rgba(6, 255, 165, 0.2);
            margin-right: auto;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .typing-dot {
            width: 8px;
            height: 8px;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            animation: typingPulse 1.4s infinite ease-in-out;
        }

        .typing-dot:nth-child(1) {
            animation-delay: -0.32s;
        }

        .typing-dot:nth-child(2) {
            animation-delay: -0.16s;
        }

        @keyframes typingPulse {
            0%, 80%, 100% {
                transform: scale(0.8);
                opacity: 0.5;
            }
            40% {
                transform: scale(1);
                opacity: 1;
            }
        }

        .ai-chat-input-container {
            padding: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .ai-chat-input {
            flex: 1;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            color: white;
            font-size: 14px;
        }

        .ai-chat-send {
            background: linear-gradient(45deg, #8338ec, #3a86ff);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .ai-chat-send:hover {
            transform: scale(1.05);
        }

        /* Voice Input Button */
        .voice-input-btn {
            background: linear-gradient(45deg, #ff006e, #ff4458);
            color: white;
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .voice-input-btn:hover {
            transform: scale(1.1);
        }

        .voice-input-btn.recording {
            background: linear-gradient(45deg, #ff0000, #ff4444);
            animation: recordPulse 1.5s infinite;
        }

        .voice-input-btn.disabled {
            background: linear-gradient(45deg, #666, #888);
            cursor: not-allowed;
            opacity: 0.5;
        }

        .voice-input-btn.disabled:hover {
            transform: scale(1);
        }

        @keyframes recordPulse {
            0% {
                box-shadow: 0 0 0 0 rgba(255, 0, 0, 0.7);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(255, 0, 0, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(255, 0, 0, 0);
            }
        }

        /* AI Companion Button */
        .ai-companion-button {
            position: fixed;
            bottom: calc(env(safe-area-inset-bottom, 30px));
            right: calc(env(safe-area-inset-right, 30px));
            width: 60px;
            height: 60px;
            background: rgba(131, 56, 236, 0.3);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(131, 56, 236, 0.5);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 1002;
            box-shadow: 0 0 20px rgba(131, 56, 236, 0.3);
            opacity: 0;
            transform: scale(0.8);
            animation: fadeInButton 0.5s ease 0.8s forwards;
        }

        .ai-companion-button:hover {
            background: rgba(131, 56, 236, 0.5);
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(131, 56, 236, 0.5);
        }

        .ai-companion-button.active {
            background: rgba(6, 255, 165, 0.3);
            border-color: rgba(6, 255, 165, 0.5);
        }

        /* Tasks Button */
        .tasks-button {
            position: fixed;
            bottom: calc(env(safe-area-inset-bottom, 30px) + 80px);
            right: calc(env(safe-area-inset-right, 30px));
            width: 60px;
            height: 60px;
            background: rgba(255, 106, 0, 0.3);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 106, 0, 0.5);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 1002;
            box-shadow: 0 0 20px rgba(255, 106, 0, 0.3);
            opacity: 0;
            transform: scale(0.8);
            animation: fadeInButton 0.5s ease 0.7s forwards;
        }

        .tasks-button:hover {
            background: rgba(255, 106, 0, 0.5);
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(255, 106, 0, 0.5);
        }

        .tasks-button svg {
            width: 28px;
            height: 28px;
            color: white;
        }

        /* Task Panel */
        .task-panel {
            position: fixed;
            bottom: calc(env(safe-area-inset-bottom, 100px));
            left: calc(env(safe-area-inset-left, 20px));
            background: rgba(20, 20, 40, 0.95);
            border: 2px solid rgba(255, 106, 0, 0.5);
            border-radius: 20px;
            padding: 20px;
            z-index: 1002;
            max-width: 350px;
            max-height: 400px;
            overflow-y: auto;
            box-shadow: 0 0 30px rgba(255, 106, 0, 0.3);
            display: none;
        }

        .task-panel.active {
            display: block;
        }

        .task-panel h3 {
            margin: 0 0 15px 0;
            font-size: 20px;
            background: linear-gradient(45deg, #ff6a00, #ff8c00, #ffa500);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .upload-conversation-btn {
            background: linear-gradient(45deg, #742774, #4a90e2);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 15px;
            cursor: pointer;
            font-size: 14px;
            margin: 10px 0;
            width: 100%;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .upload-conversation-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(116, 39, 116, 0.4);
        }

        .conversation-upload-input {
            display: none;
        }

        .task-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 12px;
            margin: 8px 0;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid transparent;
        }

        .task-item:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 106, 0, 0.5);
            transform: translateX(5px);
        }

        .task-item strong {
            color: #ffa500;
            display: block;
            margin-bottom: 5px;
        }

        .task-item small {
            color: rgba(255, 255, 255, 0.6);
            display: block;
            margin-top: 5px;
        }

        .world-ui {
            position: absolute;
            top: env(safe-area-inset-top, 20px);
            left: env(safe-area-inset-left, 20px);
            z-index: 1001;
            pointer-events: none;
            opacity: 0;
            animation: fadeIn 0.5s ease 0.3s forwards;
        }

        @keyframes fadeIn {
            to {
                opacity: 1;
            }
        }

        .world-title {
            font-size: 3em;
            font-weight: 100;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            background: linear-gradient(45deg, #ff006e, #8338ec, #3a86ff, #06ffa5);
            background-size: 400% 100%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: shimmer 8s ease-in-out infinite;
            margin-bottom: 10px;
        }

        .world-description {
            font-size: 1.2em;
            color: rgba(255, 255, 255, 0.6);
            max-width: 400px;
        }

        @keyframes shimmer {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }

        .notification {
            position: fixed;
            top: 100px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            border: 2px solid rgba(0, 255, 255, 0.5);
            animation: slideIn 0.3s ease;
            z-index: 1005;
            backdrop-filter: blur(10px);
        }

        /* Inactive AI Companion Text */
        .inactive-companion-text {
            position: absolute;
            color: #ff6a00;
            font-size: 1.2em;
            text-align: center;
            width: 300px;
            margin-left: -150px;
            text-shadow: 0 0 10px rgba(255, 106, 0, 0.5);
            animation: floatText 3s ease-in-out infinite;
        }

        @keyframes floatText {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        @media (max-width: 768px) {
            .world-title {
                font-size: 2em;
            }

            .world-description {
                font-size: 1em;
                max-width: 300px;
            }

            .ai-chat-interface {
                width: calc(100% - 40px);
                right: 20px;
                left: 20px;
                height: 350px;
                bottom: calc(env(safe-area-inset-bottom, 20px) + 20px);
            }

            .voice-pause-button {
                width: 100px;
                height: 45px;
                font-size: 13px;
            }

            .settings-panel {
                width: 95%;
                padding: 20px;
            }

            .settings-tabs {
                flex-wrap: wrap;
            }

            .perspective-controls {
                grid-template-columns: 1fr;
            }

            .tool-overlay {
                width: 95%;
                height: 90vh;
            }
        }

        /* iOS specific fixes */
        @supports (-webkit-touch-callout: none) {
            body {
                position: fixed;
                height: 100vh;
                height: -webkit-fill-available;
            }

            #three-container {
                height: 100vh;
                height: -webkit-fill-available;
            }
        }
    </style>
</head>
<body>
    <!-- Enhanced Loading Screen -->
    <div class="loading" id="loading">
        <div class="loading-content">
            <div class="loading-logo">
                <div class="loading-orb"></div>
            </div>
            <div class="loading-text">Initializing AI Companion</div>
            <div class="loading-progress">
                <div class="loading-progress-bar" id="loading-progress"></div>
            </div>
            <div class="loading-status" id="loading-status">Loading core modules...</div>
        </div>
    </div>

    <div id="three-container"></div>

    <!-- Tool Overlay Window -->
    <div class="tool-overlay" id="tool-overlay">
        <div class="tool-overlay-header">
            <div class="tool-overlay-title">
                <span id="tool-overlay-icon">🛠️</span>
                <span id="tool-overlay-title">Loading Tool...</span>
            </div>
            <div class="tool-overlay-actions">
                <a href="#" target="_blank" class="tool-overlay-btn primary" id="tool-overlay-new-tab">
                    Open in New Tab
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <polyline points="15 3 21 3 21 9"></polyline>
                        <line x1="10" y1="14" x2="21" y2="3"></line>
                    </svg>
                </a>
                <button class="tool-overlay-btn" id="tool-overlay-refresh">
                    Refresh
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="23 4 23 10 17 10"></polyline>
                        <polyline points="1 20 1 14 7 14"></polyline>
                        <path d="M3.51 9a9 9 0 0114.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0020.49 15"></path>
                   </svg>
               </button>
           </div>
           <button class="tool-overlay-close" id="tool-overlay-close">&times;</button>
       </div>
       <div class="tool-overlay-content">
           <div class="tool-loading" id="tool-loading">
               <div class="tool-loading-spinner"></div>
               <p>Loading tool...</p>
           </div>
           <iframe class="tool-iframe" id="tool-iframe" style="display: none;" sandbox="allow-scripts allow-same-origin allow-forms allow-popups allow-modals allow-downloads"></iframe>
       </div>
   </div>

   <!-- Click to Chat Tooltip -->
   <div class="companion-tooltip" id="companion-tooltip">Click to chat</div>

   <!-- Viewer Mode Indicator -->
   <div class="viewer-mode-indicator" id="viewer-mode-indicator">
       <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
           <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
           <circle cx="12" cy="12" r="3"></circle>
       </svg>
       <span>Viewing Mode</span>
   </div>

   <!-- Following Indicator -->
   <div class="following-indicator" id="following-indicator">
       <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2">
           <circle cx="12" cy="12" r="10"/>
           <polygon points="10 8 16 12 10 16 10 8"/>
       </svg>
       <span>Following Presenter's View</span>
   </div>

   <!-- Show Mode Status -->
   <div class="show-mode-status" id="show-mode-status">
       <div class="status-indicator" id="status-indicator"></div>
       <span class="status-text" id="status-text">Connecting...</span>
       <div class="viewer-count">
           <span id="viewer-count">1</span> viewers
       </div>
   </div>

   <!-- Voice Pause Button -->
   <div class="voice-pause-button" id="voice-pause-button">
       <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
           <path d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path>
       </svg>
       <span id="voice-pause-text">Pause Voice</span>
   </div>

   <!-- Voice Paused Indicator -->
   <div class="voice-paused-indicator" id="voice-paused-indicator">
       <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
           <path d="M10 9v6m4-6v6"></path>
       </svg>
       <span>Voice Paused</span>
   </div>

   <!-- Tool Gallery Button -->
   <div class="tool-gallery-button" id="tool-gallery-button">
       <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
           <rect x="3" y="3" width="7" height="7"></rect>
           <rect x="14" y="3" width="7" height="7"></rect>
           <rect x="14" y="14" width="7" height="7"></rect>
           <rect x="3" y="14" width="7" height="7"></rect>
       </svg>
   </div>

   <!-- Show Mode Button -->
   <div class="show-mode-button" id="show-mode-button">
       <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
           <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
           <circle cx="12" cy="12" r="3"></circle>
       </svg>
   </div>

   <!-- Show Mode Modal -->
   <div class="show-mode-modal" id="show-mode-modal">
       <div class="show-mode-modal-content">
           <button class="modal-close" id="show-mode-close">&times;</button>
           <h3>Show Mode</h3>
           <p style="color: rgba(255, 255, 255, 0.7); margin-bottom: 20px;">
               Share your perspective in real-time. Others can scan the QR code to follow your view.
           </p>
           <div class="show-mode-info" id="show-mode-info">
               🌐 Show Mode Active - Viewers will see what you see in real-time!
           </div>
           <div id="qr-code-container"></div>
           <p class="qr-url" id="qr-url"></p>
           <button class="copy-url-btn" id="copy-url-btn">Copy URL</button>
       </div>
   </div>

   <!-- Settings Panel -->
   <div class="settings-panel" id="settings-panel">
       <button class="close-settings" id="close-settings">&times;</button>
       <h2>AI Companion Settings</h2>
       
       <div class="settings-tabs">
           <button class="settings-tab active" data-tab="general">General</button>
           <button class="settings-tab" data-tab="voice">Voice</button>
           <button class="settings-tab" data-tab="perspective">3D View</button>
           <button class="settings-tab" data-tab="import-export">Import/Export</button>
       </div>

       <!-- General Settings -->
       <div class="settings-section active" id="general-settings">
           <div class="settings-group">
               <h3>API Configuration</h3>
               <div class="setting-item">
                   <label for="settings-api-key">API Key</label>
                   <input type="password" id="settings-api-key" placeholder="Enter your API key">
               </div>
               <div class="setting-item">
                   <label for="settings-endpoint">API Endpoint</label>
                   <input type="text" id="settings-endpoint" value="https://azfbusinessbot.azurewebsites.net/api/businessinsightbot_function">
               </div>
           </div>

           <div class="settings-group">
               <h3>World Settings</h3>
               <div class="setting-item">
                   <label for="world-name">World Name</label>
                   <input type="text" id="world-name" value="AI Companion Hub">
               </div>
               <div class="setting-item">
                   <label for="world-description">World Description</label>
                   <input type="text" id="world-description" value="Your intelligent assistant awaits. Click on the AI companion to start chatting!">
               </div>
           </div>
       </div>

       <!-- Voice Settings -->
       <div class="settings-section" id="voice-settings">
           <div class="settings-group">
               <h3>Voice Output</h3>
               <div class="toggle-setting">
                   <label>Enable Voice Response</label>
                   <div class="toggle-switch" id="settings-voice-enabled"></div>
               </div>
               <div class="toggle-setting">
                   <label>Auto-speak Responses</label>
                   <div class="toggle-switch" id="settings-auto-speak"></div>
               </div>
               <div class="setting-item">
                   <label for="settings-azure-tts-key">Azure TTS API Key</label>
                   <input type="password" id="settings-azure-tts-key" placeholder="Enter Azure TTS key for premium voices">
               </div>
               <div class="setting-item">
                   <label for="settings-tts-voice">TTS Voice</label>
                   <select id="settings-tts-voice">
                       <option value="en-US-JennyNeural">Jenny (Female)</option>
                       <option value="en-US-GuyNeural">Guy (Male)</option>
                       <option value="en-US-AriaNeural">Aria (Female)</option>
                       <option value="en-US-DavisNeural">Davis (Male)</option>
                       <option value="en-US-AmberNeural">Amber (Female)</option>
                       <option value="en-US-JasonNeural">Jason (Male)</option>
                       <option value="en-GB-SoniaNeural">Sonia (British Female)</option>
                       <option value="en-GB-RyanNeural">Ryan (British Male)</option>
                   </select>
               </div>
           </div>

           <div class="settings-group">
               <h3>Voice Input</h3>
               <div class="toggle-setting">
                   <label>Enable Voice Input</label>
                   <div class="toggle-switch active" id="settings-voice-input-enabled"></div>
               </div>
               <div class="toggle-setting">
                   <label>Continuous Conversation Mode</label>
                   <div class="toggle-switch" id="settings-continuous-conversation"></div>
               </div>
               <div class="setting-item">
                   <label for="settings-push-to-talk">Push-to-Talk Key</label>
                   <select id="settings-push-to-talk">
                       <option value="Space">Space</option>
                       <option value="v">V</option>
                       <option value="t">T</option>
                       <option value="Control">Ctrl</option>
                       <option value="Alt">Alt</option>
                   </select>
               </div>
           </div>
       </div>

       <!-- Perspective Settings -->
       <div class="settings-section" id="perspective-settings">
           <div class="settings-group">
               <h3>Camera Controls</h3>
               <div class="perspective-controls">
                   <div class="setting-item">
                       <label>Position X <span class="range-value" id="pos-x-value">0</span></label>
                       <input type="range" id="camera-pos-x" min="-50" max="50" value="0" step="0.5">
                   </div>
                   <div class="setting-item">
                       <label>Position Y <span class="range-value" id="pos-y-value">5</span></label>
                       <input type="range" id="camera-pos-y" min="-20" max="50" value="5" step="0.5"></div>
                   <div class="setting-item">
                       <label>Position Z <span class="range-value" id="pos-z-value">8</span></label>
                       <input type="range" id="camera-pos-z" min="-50" max="50" value="8" step="0.5">
                   </div>
                   <div class="setting-item">
                       <label>Rotation X <span class="range-value" id="rot-x-value">0</span></label>
                       <input type="range" id="camera-rot-x" min="-180" max="180" value="0" step="1">
                   </div>
                   <div class="setting-item">
                       <label>Rotation Y <span class="range-value" id="rot-y-value">0</span></label>
                       <input type="range" id="camera-rot-y" min="-180" max="180" value="0" step="1">
                   </div>
                   <div class="setting-item">
                       <label>FOV <span class="range-value" id="fov-value">75</span></label>
                       <input type="range" id="camera-fov" min="30" max="120" value="75" step="1">
                   </div>
               </div>
               
               <h4 style="margin-top: 20px; margin-bottom: 10px; color: #8a2be2;">Presets</h4>
               <div class="perspective-preset">
                   <button class="preset-btn" onclick="window.worldNavigator.perspectiveManager.applyPreset('default')">Default</button>
                   <button class="preset-btn" onclick="window.worldNavigator.perspectiveManager.applyPreset('overhead')">Overhead</button>
                   <button class="preset-btn" onclick="window.worldNavigator.perspectiveManager.applyPreset('close')">Close-up</button>
                   <button class="preset-btn" onclick="window.worldNavigator.perspectiveManager.applyPreset('side')">Side View</button>
                   <button class="preset-btn" onclick="window.worldNavigator.perspectiveManager.applyPreset('wide')">Wide Angle</button>
                   <button class="preset-btn" onclick="window.worldNavigator.perspectiveManager.applyPreset('dramatic')">Dramatic</button>
               </div>
           </div>

           <div class="settings-group">
               <h3>Visual Settings</h3>
               <div class="setting-item">
                   <label>Fog Density <span class="range-value" id="fog-density-value">50</span></label>
                   <input type="range" id="fog-density" min="10" max="200" value="50" step="5">
               </div>
               <div class="setting-item">
                   <label>Particle Count <span class="range-value" id="particle-count-value">300</span></label>
                   <input type="range" id="particle-count" min="0" max="1000" value="300" step="50">
               </div>
           </div>
       </div>

       <!-- Import/Export Settings -->
       <div class="settings-section" id="import-export-settings">
           <div class="import-export-section">
               <h4>Export Settings</h4>
               <p style="color: rgba(255, 255, 255, 0.6); margin-bottom: 15px; font-size: 14px;">
                   Export all your settings including API keys, voice configuration, and 3D perspective as a JSON file.
               </p>
               <div class="json-preview" id="json-preview"></div>
               <button class="settings-btn" onclick="window.worldNavigator.settingsManager.exportSettings()">
                   Export Settings to JSON
               </button>
           </div>

           <div class="import-export-section" style="margin-top: 30px;">
               <h4>Import Settings</h4>
               <p style="color: rgba(255, 255, 255, 0.6); margin-bottom: 15px; font-size: 14px;">
                   Import a previously exported settings file to restore your configuration.
               </p>
               <div class="file-input-wrapper">
                   <input type="file" id="import-settings-file" accept=".json" onchange="window.worldNavigator.settingsManager.importSettings(event)">
                   <label for="import-settings-file" class="file-input-label">
                       Click to select settings file or drag and drop here
                   </label>
               </div>
           </div>

           <div class="import-export-section" style="margin-top: 30px;">
               <h4>Danger Zone</h4>
               <p style="color: rgba(255, 165, 0, 0.8); margin-bottom: 15px; font-size: 14px;">
                   ⚠️ This action will reset all settings to their default values. This cannot be undone.
               </p>
               <button class="settings-btn danger" onclick="window.worldNavigator.settingsManager.resetSettings()">
                   Reset All Settings
               </button>
           </div>
       </div>

       <div class="settings-actions">
           <button class="settings-btn" onclick="window.worldNavigator.settingsManager.saveSettings()">Save Changes</button>
           <button class="settings-btn secondary" onclick="document.getElementById('settings-panel').classList.remove('active')">Cancel</button>
       </div>
   </div>

   <!-- Voice Indicator -->
   <div class="voice-indicator" id="voice-indicator">
       <i class="fas fa-volume-up"></i>
       <span>Speaking...</span>
   </div>

   <!-- Listening Indicator -->
   <div class="listening-indicator" id="listening-indicator">
       <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
           <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path>
           <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
           <line x1="12" y1="19" x2="12" y2="23"></line>
           <line x1="8" y1="23" x2="16" y2="23"></line>
       </svg>
       <span>Listening...</span>
   </div>

   <!-- AI Chat Interface -->
   <div class="ai-chat-interface" id="ai-chat-interface">
       <div class="ai-chat-header">
           <div class="ai-chat-title">
               AI Companion Chat
               <span class="viewer-chat-label" id="viewer-chat-label" style="display: none;">Viewer Mode</span>
           </div>
           <button class="modal-close" onclick="document.getElementById('ai-chat-interface').classList.remove('active')">&times;</button>
       </div>
       <div class="ai-chat-messages" id="ai-chat-messages"></div>
       <div class="ai-chat-input-container">
           <input type="text" class="ai-chat-input" id="ai-chat-input" placeholder="Type a message..." onkeypress="if(event.key==='Enter') window.worldNavigator.aiManager.sendMessage()">
           <button class="voice-input-btn" id="voice-input-btn" title="Hold to speak">
               <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2">
                   <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path>
                   <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
                   <line x1="12" y1="19" x2="12" y2="23"></line>
                   <line x1="8" y1="23" x2="16" y2="23"></line>
               </svg>
           </button>
           <button class="ai-chat-send" onclick="window.worldNavigator.aiManager.sendMessage()">Send</button>
       </div>
   </div>

   <!-- Task Panel -->
   <div class="task-panel" id="task-panel">
       <h3>📚 Saved Conversations</h3>
       <button class="upload-conversation-btn" onclick="document.getElementById('conversation-upload-input').click()">
           <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2">
               <path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"></path>
               <polyline points="17 8 12 3 7 8"></polyline>
               <line x1="12" y1="3" x2="12" y2="15"></line>
           </svg>
           Upload Conversation JSON
       </button>
       <input type="file" id="conversation-upload-input" class="conversation-upload-input" accept=".json" onchange="window.worldNavigator.taskManager.uploadConversation(event)">
       <div id="task-list">
           <!-- Tasks populated here -->
       </div>
   </div>

   <div class="world-ui">
       <h1 class="world-title" id="world-title">AI COMPANION HUB</h1>
       <p class="world-description" id="world-description">Your intelligent assistant awaits. Click on the AI companion to start chatting!</p>
   </div>

   <!-- AI Companion Button -->
   <div class="ai-companion-button" id="ai-companion-button">
       <svg class="view-toggle-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
           <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"></path>
       </svg>
   </div>

   <!-- Tasks Button -->
   <div class="tasks-button" id="tasks-button">
       <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
           <path d="M9 11l3 3L22 4"></path>
           <path d="M21 12v7a2 2 0 01-2 2H5a2 2 0 01-2-2V5a2 2 0 012-2h11"></path>
       </svg>
   </div>

   <!-- Settings Button -->
   <div class="settings-button" id="settings-button">
       <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
           <circle cx="12" cy="12" r="3"></circle>
           <path d="M12 1v6m0 6v6m4.22-10.22l1.42-1.42m-1.42 8.49l1.42 1.42M20 12h-6m-6 0H1m4.22 4.22l-1.42 1.42m1.42-8.49L3.8 7.73"></path>
       </svg>
   </div>

   <!-- Load Three.js early -->
   <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
   
   <!-- Main JavaScript -->
   <script>
       // Global app namespace
       window.AICompanion = {
           loadProgress: 0,
           modules: {
               threejs: false,
               font: false,
               core: false,
               ui: false
           }
       };

       // Update loading progress
       function updateLoadingProgress() {
           const completed = Object.values(window.AICompanion.modules).filter(v => v).length;
           const total = Object.keys(window.AICompanion.modules).length;
           const progress = (completed / total) * 100;
           
           const progressBar = document.getElementById('loading-progress');
           if (progressBar) {
               progressBar.style.width = progress + '%';
           }
           
           if (progress === 100) {
               setTimeout(() => {
                   const loading = document.getElementById('loading');
                   if (loading) {
                       loading.classList.add('fade-out');
                       setTimeout(() => {
                           loading.style.display = 'none';
                       }, 500);
                   }
                   
                   const container = document.getElementById('three-container');
                   if (container) {
                       container.classList.add('visible');
                   }
               }, 300);
           }
       }

       // Mark Three.js as loaded
       window.AICompanion.modules.threejs = true;
       updateLoadingProgress();

       // Preload font
       const fontLoader = new Promise((resolve) => {
           fetch('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json')
               .then(response => response.json())
               .then(data => {
                   window.AICompanion.fontData = data;
                   window.AICompanion.modules.font = true;
                   updateLoadingProgress();
                   resolve();
               })
               .catch(() => {
                   // Font loading failed, but continue anyway
                   window.AICompanion.modules.font = true;
                   updateLoadingProgress();
                   resolve();
               });
       });

       // Configuration
       const WORLD_ATTRIBUTES = {
           name: "AI Companion Hub",
           description: "Your intelligent assistant awaits. Click on the AI companion to start chatting!",
           ambientColor: 0x1a1a2e,
           fogColor: 0x0a0a0f,
           groundColor: 0x16213e,
           skyColor: 0x0f3460,
           particleCount: 300,
           fogNear: 5,
           fogFar: 50,
           companionDistance: 5,
           cameraPositionY: 5,
           cameraPositionZ: 8
       };

       const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                       (window.matchMedia && window.matchMedia('(max-width: 768px)').matches) ||
                       (window.matchMedia && window.matchMedia('(pointer: coarse)').matches);

       const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;

       // Initialize app when DOM is ready
       document.addEventListener('DOMContentLoaded', async () => {
           document.getElementById('loading-status').textContent = 'Loading resources...';
           
           // Load PeerJS asynchronously
           const peerJsScript = document.createElement('script');
           peerJsScript.src = 'https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js';
           peerJsScript.async = true;
           peerJsScript.onload = () => {
               window.AICompanion.modules.core = true;
               updateLoadingProgress();
           };
           document.head.appendChild(peerJsScript);

           // Wait for font to load
           await fontLoader;

           // Load main application code
           document.getElementById('loading-status').textContent = 'Initializing world...';
           
           // Mark UI as loaded
           window.AICompanion.modules.ui = true;
           updateLoadingProgress();
           
           // Initialize after a small delay to ensure everything is ready
           setTimeout(initializeApplication, 100);
       });

       // Tool Knowledge Base
       const GITHUB_TOOLS = {
           "kody-w/localFirstTools": {
               "rainbow-svg-path": {
                   path: "/apps/productivity/digital-twin-keeper.html",
                   title: "Rainbow SVG Path Designer",
                   description: "Create beautiful animated SVG paths with rainbow gradients",
                   icon: "🌈"
               },
               "breathwork": {
                   path: "breathwork.html",
                   title: "Breathwork Guide",
                   description: "Interactive breathing exercises for relaxation",
                   icon: "🧘"
               },
               "fractal-tree": {
                   path: "fractal-tree.html",
                   title: "Fractal Tree Generator",
                   description: "Create beautiful algorithmic tree visualizations",
                   icon: "🌳"
               },
               "mandala-maker": {
                   path: "mandala-maker.html",
                   title: "Mandala Creator",
                   description: "Design intricate mandala patterns",
                   icon: "🎨"
               },
               "particle-life": {
                   path: "particle-life.html",
                   title: "Particle Life Simulation",
                   description: "Watch emergent behaviors in particle systems",
                   icon: "✨"
               },
               "wave-interference": {
                   path: "wave-interference.html",
                   title: "Wave Interference Visualizer",
                   description: "Explore wave physics through interactive visualization",
                   icon: "🌊"
               },
               "audio-visualizer": {
                   path: "audio-visualizer.html",
                   title: "Audio Visualizer",
                   description: "See your music come to life",
                   icon: "🎵"
               },
               "color-harmony": {
                   path: "color-harmony.html",
                   title: "Color Harmony Tool",
                   description: "Generate beautiful color palettes",
                   icon: "🎨"
               }
           }
       };

       // Markdown Parser Class
       class MarkdownParser {
           constructor() {
               this.rules = {
                   // Headers
                   h1: /^# (.+)$/gm,
                   h2: /^## (.+)$/gm,
                   h3: /^### (.+)$/gm,
                   h4: /^#### (.+)$/gm,
                   h5: /^##### (.+)$/gm,
                   h6: /^###### (.+)$/gm,
                   
                   // Bold and italic
                   boldItalic: /\*\*\*(.+?)\*\*\*/g,
                   bold: /\*\*(.+?)\*\*/g,
                   italic: /\*(.+?)\*/g,
                   
                   // Links
                   link: /\[([^\]]+)\]\(([^)]+)\)/g,
                   
                   // Images
                   image: /!\[([^\]]*)\]\(([^)]+)\)/g,
                   
                   // Code
                   codeBlock: /```([\s\S]*?)```/g,
                   inlineCode: /`([^`]+)`/g,
                   
                   // Blockquote
                   blockquote: /^> (.+)$/gm,
                   
                   // Lists
                   unorderedList: /^[*\-+] (.+)$/gm,
                   orderedList: /^\d+\. (.+)$/gm,
                   
                   // Horizontal rule
                   hr: /^(---|\*\*\*|___)$/gm,
                   
                   // Line breaks
                   lineBreak: /  $/gm,
                   
                   // Tables (simplified)
                   table: /\|(.+)\|/g
               };
           }

           parse(text) {
               if (!text) return '';
               
               // Escape HTML
               text = this.escapeHtml(text);
               
               // Process block elements first
               text = this.processBlockElements(text);
               
               // Process inline elements
               text = this.processInlineElements(text);
               
               // Convert line breaks
               text = text.replace(/\n/g, '<br>');
               
               return text;
           }

           escapeHtml(text) {
               const div = document.createElement('div');
               div.textContent = text;
               return div.innerHTML;
           }

           processBlockElements(text) {
               // Code blocks (process first to avoid other parsing inside)
               text = text.replace(this.rules.codeBlock, '<pre><code>$1</code></pre>');
               
               // Headers
               text = text.replace(this.rules.h6, '<h6>$1</h6>');
               text = text.replace(this.rules.h5, '<h5>$1</h5>');
               text = text.replace(this.rules.h4, '<h4>$1</h4>');
               text = text.replace(this.rules.h3, '<h3>$1</h3>');
               text = text.replace(this.rules.h2, '<h2>$1</h2>');
               text = text.replace(this.rules.h1, '<h1>$1</h1>');
               
               // Blockquotes
               text = text.replace(this.rules.blockquote, '<blockquote>$1</blockquote>');
               
               // Horizontal rules
               text = text.replace(this.rules.hr, '<hr>');
               
               // Lists
               text = this.processList(text);
               
               return text;
           }

           processInlineElements(text) {
               // Bold italic (process before individual bold/italic)
               text = text.replace(this.rules.boldItalic, '<strong><em>$1</em></strong>');
               
               // Bold
               text = text.replace(this.rules.bold, '<strong>$1</strong>');
               
               // Italic
               text = text.replace(this.rules.italic, '<em>$1</em>');
               
               // Links
               text = text.replace(this.rules.link, '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>');
               
               // Images
               text = text.replace(this.rules.image, '<img src="$2" alt="$1">');
               
               // Inline code
               text = text.replace(this.rules.inlineCode, '<code>$1</code>');
               
               // Line breaks
               text = text.replace(this.rules.lineBreak, '<br>');
               
               return text;
           }

           processList(text) {
               const lines = text.split('\n');
               let inUl = false;
               let inOl = false;
               let result = [];
               
               for (let line of lines) {
                   if (line.match(/^[*\-+] /)) {
                       if (!inUl) {
                           result.push('<ul>');
                           inUl = true;
                       }
                       if (inOl) {
                           result.push('</ol>');
                           inOl = false;
                       }
                       result.push('<li>' + line.replace(/^[*\-+] /, '') + '</li>');
                   } else if (line.match(/^\d+\. /)) {
                       if (!inOl) {
                           result.push('<ol>');
                           inOl = true;
                       }
                       if (inUl) {
                           result.push('</ul>');
                           inUl = false;
                       }
                       result.push('<li>' + line.replace(/^\d+\. /, '') + '</li>');
                   } else {
                       if (inUl) {
                           result.push('</ul>');
                           inUl = false;
                       }
                       if (inOl) {
                           result.push('</ol>');
                           inOl = false;
                       }
                       result.push(line);
                   }
               }
               
               if (inUl) result.push('</ul>');
               if (inOl) result.push('</ol>');
               
               return result.join('\n');
           }
       }

       // Tool Manager Class
       class ToolManager {
           constructor(worldInstance) {
               this.world = worldInstance;
               this.currentTool = null;
               this.toolOverlay = document.getElementById('tool-overlay');
               this.toolIframe = document.getElementById('tool-iframe');
               this.toolLoading = document.getElementById('tool-loading');
               
               this.setupEventListeners();
           }

           setupEventListeners() {
               // Tool overlay buttons
               document.getElementById('tool-overlay-close').addEventListener('click', () => {
                   this.closeTool();
               });

               document.getElementById('tool-overlay-refresh').addEventListener('click', () => {
                   if (this.currentTool) {
                       this.refreshTool();
                   }
               });

               // Tool gallery button
               document.getElementById('tool-gallery-button').addEventListener('click', () => {
                   this.openGallery();
               });
           }

           async openTool(toolInfo) {
               this.currentTool = toolInfo;
               
               // Update overlay header
               document.getElementById('tool-overlay-icon').textContent = toolInfo.icon || '🛠️';
               document.getElementById('tool-overlay-title').textContent = toolInfo.title || 'Loading Tool...';
               
               // Update new tab link
               const newTabLink = document.getElementById('tool-overlay-new-tab');
               newTabLink.href = toolInfo.url;
               
               // Show overlay
               this.toolOverlay.classList.add('active');
               this.toolLoading.style.display = 'block';
               this.toolIframe.style.display = 'none';
               
               // Load tool in iframe
               this.toolIframe.src = toolInfo.url;
               
               // Handle iframe load
               this.toolIframe.onload = () => {
                   this.toolLoading.style.display = 'none';
                   this.toolIframe.style.display = 'block';
               };
               
               // Handle iframe error
               this.toolIframe.onerror = () => {
                   this.toolLoading.innerHTML = `
                       <p style="color: #ff006e;">Failed to load tool</p>
                       <p style="font-size: 0.9em; margin-top: 10px;">
                           <a href="${toolInfo.url}" target="_blank" style="color: #06ffa5;">Open in new tab instead</a>
                       </p>
                   `;
               };

               // Show notification
               this.world.showNotification(`Opening ${toolInfo.title}...`);
           }

           refreshTool() {
               if (this.currentTool) {
                   this.toolLoading.style.display = 'block';
                   this.toolIframe.style.display = 'none';
                   this.toolIframe.src = this.currentTool.url;
               }
           }

           closeTool() {
               this.toolOverlay.classList.remove('active');
               this.toolIframe.src = '';
               this.currentTool = null;
           }

           openGallery() {
               // Open the vibe coding gallery
               const galleryUrl = 'https://kody-w.github.io/localFirstTools/index.html';
               window.open(galleryUrl, '_blank');
               this.world.showNotification('Opening Vibe Coding Gallery...');
           }

           openToolInNewTab(toolInfo) {
               window.open(toolInfo.url, '_blank');
               this.world.showNotification(`Opening ${toolInfo.title} in new tab...`);
           }
       }

       // Show Mode Manager Class with Full Chat Sync
       class ShowModeManager {
           constructor(worldInstance) {
               this.world = worldInstance;
               this.peer = null;
               this.connections = new Map();
               this.isHost = false;
               this.roomId = null;
               this.isFollowing = false;
               this.updateInterval = 50; // ms
               this.lastUpdate = 0;
               this.viewerNames = new Map(); // Store viewer names

               this.initializePeer();
               this.setupEventListeners();
           }

           initializePeer() {
               const urlParams = new URLSearchParams(window.location.search);
               const hostId = urlParams.get('show');

               try {
                   if (hostId) {
                       // Joining a show
                       this.roomId = hostId;
                       this.peer = new Peer();
                       this.isFollowing = true;

                       this.peer.on('open', (id) => {
                           console.log('Viewer peer ID:', id);
                           console.log('Attempting to join show:', this.roomId);
                           
                           // Set viewer mode UI
                           this.setupViewerMode();
                           
                           setTimeout(() => {
                               this.connectToHost(this.roomId);
                           }, 1000);
                           
                           this.updateStatus('Connecting to presenter...', false);
                           document.getElementById('following-indicator').classList.add('active');
                       });
                   } else {
                       // Not in show mode initially
                       this.peer = new Peer();
                       
                       this.peer.on('open', (id) => {
                           console.log('Peer ID:', id);
                       });
                   }

                   // Handle incoming connections
                   this.peer.on('connection', (conn) => {
                       console.log('Incoming connection from:', conn.peer);
                       this.handleNewConnection(conn);
                   });

                   // Handle errors
                   this.peer.on('error', (err) => {
                       console.error('Peer error:', err);
                       
                       if (err.type === 'peer-unavailable') {
                           this.showError('Presenter not found. Make sure they are online.');
                       } else if (err.type === 'network') {
                           this.showError('Network error. Check your connection.');
                       } else {
                           this.showError('Connection error: ' + err.message);
                       }
                       
                       this.updateStatus('Error', false);
                   });

                   // Handle disconnection
                   this.peer.on('disconnected', () => {
                       console.log('Disconnected from peer server');
                       this.updateStatus('Disconnected', false);
                       
                       setTimeout(() => {
                           if (!this.peer.destroyed) {
                               console.log('Attempting to reconnect...');
                               this.peer.reconnect();
                           }
                       }, 3000);
                   });

               } catch (error) {
                   console.error('Failed to initialize peer:', error);
                   this.showError('Failed to initialize show mode');
               }
           }

           setupViewerMode() {
               // Show viewer mode indicator
               document.getElementById('viewer-mode-indicator').classList.add('active');
               
               // Update chat interface for viewer mode
               const chatInterface = document.getElementById('ai-chat-interface');
               chatInterface.classList.add('viewer-mode');
               
               // Show viewer label in chat
               document.getElementById('viewer-chat-label').style.display = 'inline-block';
               
               // Hide show mode button for viewers
               document.getElementById('show-mode-button').style.display = 'none';
               
               // Keep voice pause button visible but disabled for viewers
               const voicePauseBtn = document.getElementById('voice-pause-button');
               voicePauseBtn.style.opacity = '0.5';
               voicePauseBtn.style.pointerEvents = 'none';
               
               // Hide companion tooltip since viewers can't interact with the 3D companion
               document.getElementById('companion-tooltip').style.display = 'none';
               
               // Adjust camera for third person view
               if (this.world.camera) {
                   // Move camera back and up for better third person perspective
                   this.world.camera.position.z = 15;
                   this.world.camera.position.y = 8;
                   this.world.camera.lookAt(0, 3, 0);
               }
           }

           setupEventListeners() {
               // Show Mode button
               document.getElementById('show-mode-button').addEventListener('click', () => {
                   if (this.isHost) {
                       this.stopHosting();
                   } else {
                       this.startHosting();
                   }
               });

               // Modal close
               document.getElementById('show-mode-close').addEventListener('click', () => {
                   document.getElementById('show-mode-modal').classList.remove('show');
               });

               // Copy URL button
               document.getElementById('copy-url-btn').addEventListener('click', async () => {
                   const urlElement = document.getElementById('qr-url');
                   try {
                       await navigator.clipboard.writeText(urlElement.textContent);
                       const btn = document.getElementById('copy-url-btn');
                       btn.textContent = 'Copied!';
                       btn.classList.add('copied');
                       
                       setTimeout(() => {
                           btn.textContent = 'Copy URL';
                           btn.classList.remove('copied');
                       }, 2000);
                   } catch (err) {
                       console.error('Failed to copy:', err);
                   }
               });

               // Close modal on outside click
               document.getElementById('show-mode-modal').addEventListener('click', (e) => {
                   if (e.target.id === 'show-mode-modal') {
                       document.getElementById('show-mode-modal').classList.remove('show');
                   }
               });
           }

           startHosting() {
               this.isHost = true;
               this.roomId = this.peer.id;
               
               document.getElementById('show-mode-button').classList.add('active');
               document.getElementById('show-mode-modal').classList.add('show');
               document.getElementById('show-mode-status').classList.add('visible');
               
               this.updateStatus('Hosting Show', true);
               this.updateShareUrl();
               
               this.showNotification('Show Mode activated! Share the QR code for others to follow your view.');
           }

           stopHosting() {
               this.isHost = false;
               
               // Disconnect all viewers
               this.connections.forEach((conn) => {
                   conn.close();
               });
               this.connections.clear();
               this.viewerNames.clear();
               
               document.getElementById('show-mode-button').classList.remove('active');
               document.getElementById('show-mode-modal').classList.remove('show');
               document.getElementById('show-mode-status').classList.remove('visible');
               
               this.showNotification('Show Mode deactivated');
               this.updateViewerCount();
           }

           connectToHost(hostId) {
               try {
                   console.log('Connecting to host:', hostId);
                   
                   const viewerUsername = this.generateUsername();
                   
                   const conn = this.peer.connect(hostId, {
                       reliable: true,
                       serialization: 'json',
                       metadata: {
                           type: 'viewer',
                           username: viewerUsername
                       }
                   });

                   // Set connection timeout
                   const connectionTimeout = setTimeout(() => {
                       if (conn.open === false) {
                           console.error('Connection timeout');
                           this.showError('Connection timeout. Presenter may be offline.');
                           conn.close();
                           document.getElementById('following-indicator').classList.remove('active');
                       }
                   }, 10000);

                   conn.on('open', () => {
                       clearTimeout(connectionTimeout);
                       console.log('Connected to presenter successfully');
                       this.updateStatus('Following presenter', true);
                       this.showNotification('Connected to presenter! You are now following their view.');
                       
                       // Store our username for later use
                       this.myUsername = viewerUsername;
                       
                       // Request initial state
                       conn.send({ type: 'requestState' });
                   });

                   this.handleNewConnection(conn);
               } catch (error) {
                   console.error('Failed to connect to host:', error);
                   this.showError('Failed to connect to presenter');
                   document.getElementById('following-indicator').classList.remove('active');
               }
           }

           handleNewConnection(conn) {
               const peerId = conn.peer;

               conn.on('open', () => {
                   console.log('Connection opened with peer:', peerId);
                   this.connections.set(peerId, conn);

                   if (this.isHost) {
                       // Store viewer name
                       const viewerName = conn.metadata?.username || 'Anonymous';
                       this.viewerNames.set(peerId, viewerName);
                       
                       // Show notification for new viewer
                       this.showNotification(`New viewer joined: ${viewerName}`);
                       this.updateViewerCount();
                       
                       // Send current state to new viewer
                       this.sendCurrentState(conn);
                   }
               });

               conn.on('data', (data) => {
                   try {
                       this.handlePeerData(peerId, data);
                   } catch (error) {
                       console.error('Error handling peer data:', error);
                   }
               });

               conn.on('close', () => {
                   console.log('Peer disconnected:', peerId);
                   
                   if (this.isHost) {
                       const viewerName = this.viewerNames.get(peerId) || 'Anonymous';
                       this.showNotification(`${viewerName} left the show`);
                       this.viewerNames.delete(peerId);
                   }
                   
                   this.connections.delete(peerId);
                   
                   if (this.isHost) {
                       this.updateViewerCount();
                   } else if (this.isFollowing) {
                       this.updateStatus('Disconnected from presenter', false);
                       document.getElementById('following-indicator').classList.remove('active');
                       this.showNotification('Disconnected from presenter');
                   }
               });

               conn.on('error', (err) => {
                   console.error('Connection error with peer', peerId, ':', err);
               });
           }

           handlePeerData(peerId, data) {
               switch (data.type) {
                   case 'cameraUpdate':
                       if (this.isFollowing) {
                           this.updateCameraFromHost(data);
                       }
                       break;
                   
                   case 'chatMessage':
                       // Handle chat messages from both viewers and presenter
                       this.showChatMessage(data);
                       break;
                   
                   case 'viewerMessage':
                       // Host receives viewer messages
                       if (this.isHost) {
                           this.handleViewerMessage(peerId, data);
                       }
                       break;
                   
                   case 'aiInteraction':
                       if (this.isFollowing) {
                           this.showAIInteraction(data);
                       }
                       break;
                   
                   case 'voiceActivity':
                       if (this.isFollowing) {
                           this.showVoiceActivity(data);
                       }
                       break;
                   
                   case 'typingIndicator':
                       if (this.isFollowing) {
                           this.showTypingIndicator(data.isTyping);
                       }
                       break;
                   
                   case 'requestState':
                       if (this.isHost) {
                           const conn = this.connections.get(peerId);
                           if (conn) {
                               this.sendCurrentState(conn);
                           }
                       }
                       break;
                   
                   case 'currentState':
                       if (this.isFollowing) {
                           this.applyHostState(data.state);
                       }
                       break;
               }
           }

           handleViewerMessage(peerId, data) {
               const viewerName = this.viewerNames.get(peerId) || 'Anonymous Viewer';
               
               // Add the message to the chat
               const chatMessages = document.getElementById('ai-chat-messages');
               const messageDiv = document.createElement('div');
               messageDiv.className = 'ai-message user viewer-message';
               messageDiv.setAttribute('data-viewer-name', viewerName);
               messageDiv.textContent = data.message;
               
               chatMessages.appendChild(messageDiv);
               chatMessages.scrollTop = chatMessages.scrollHeight;
               
               // Broadcast to all other viewers
               this.connections.forEach((conn, connPeerId) => {
                   if (conn && conn.open && connPeerId !== peerId) {
                       conn.send({
                           type: 'chatMessage',
                           sender: 'user',
                           content: data.message,
                           isPresenter: false,
                           viewerName: viewerName,
                           timestamp: Date.now()
                       });
                   }
               });
               
               // If AI is active and it's a message for the AI, process it
               if (this.world.aiManager && this.world.aiManager.isActive) {
                   // Show notification that viewer sent a message
                   this.showNotification(`${viewerName} sent a message`);
                   
                   // Optionally, you could process viewer messages through AI here
                   // this.world.aiManager.processViewerMessage(data.message, viewerName);
               }
           }

           sendCurrentState(conn) {
               // Send all current chat messages
               const chatMessages = document.getElementById('ai-chat-messages');
               const messages = [];
               
               chatMessages.querySelectorAll('.ai-message').forEach(msg => {
                   const isViewer = msg.classList.contains('viewer-message');
                   messages.push({
                       type: msg.classList.contains('user') ? 'user' : 'ai',
                       content: msg.innerHTML,
                       isPresenter: !isViewer,
                       viewerName: isViewer ? msg.getAttribute('data-viewer-name') : null
                   });
               });
               
               const state = {
                   type: 'currentState',
                   state: {
                       camera: {
                           position: {
                               x: this.world.camera.position.x,
                               y: this.world.camera.position.y,
                               z: this.world.camera.position.z
                           },
                           rotation: {
                               x: this.world.camera.rotation.x,
                               y: this.world.camera.rotation.y,
                               z: this.world.camera.rotation.z
                           }
                       },
                       chatMessages: messages,
                       aiActive: this.world.aiManager.isActive
                   }
               };
               
               conn.send(state);
           }

           applyHostState(state) {
               // Apply camera state
               if (state.camera) {
                   this.updateCameraFromHost({ 
                       position: state.camera.position, 
                       rotation: state.camera.rotation 
                   });
               }
               
               // Apply chat messages
               if (state.chatMessages) {
                   const chatMessages = document.getElementById('ai-chat-messages');
                   chatMessages.innerHTML = '';
                   
                   state.chatMessages.forEach(msg => {
                       this.showChatMessage({
                           sender: msg.type,
                           content: msg.content,
                           isPresenter: msg.isPresenter,
                           viewerName: msg.viewerName
                       });
                   });
               }
               
               // Show chat if AI is active
               if (state.aiActive) {
                   document.getElementById('ai-chat-interface').classList.add('active');
               }
           }

           updateCameraFromHost(data) {
               if (!this.world.camera) return;

               // Smoothly interpolate camera position
               const targetPos = new THREE.Vector3(
                   data.position.x,
                   data.position.y,
                   data.position.z
               );

               // For viewers, offset the camera to show third person perspective
               if (this.isFollowing) {
                   targetPos.z += 7; // Move camera back
                   targetPos.y += 3; // Move camera up
               }

               this.world.camera.position.lerp(targetPos, 0.3);
               
               // Update camera rotation
               this.world.camera.rotation.x = data.rotation.x;
               this.world.camera.rotation.y = data.rotation.y;
               this.world.camera.rotation.z = data.rotation.z;
           }

           showChatMessage(data) {
               const chatMessages = document.getElementById('ai-chat-messages');
               const messageDiv = document.createElement('div');
               messageDiv.className = `ai-message ${data.sender}`;
               
               if (data.isPresenter && this.isFollowing) {
                   messageDiv.classList.add('presenter-message');
               } else if (!data.isPresenter && data.viewerName) {
                   messageDiv.classList.add('viewer-message');
                   messageDiv.setAttribute('data-viewer-name', data.viewerName);
               }
               
               // Use innerHTML to preserve formatting
               messageDiv.innerHTML = data.content;
               
               chatMessages.appendChild(messageDiv);
               chatMessages.scrollTop = chatMessages.scrollHeight;
               
               // Ensure chat is visible
               if (!document.getElementById('ai-chat-interface').classList.contains('active')) {
                   document.getElementById('ai-chat-interface').classList.add('active');
               }
               
               // Animate companion if AI message
               if (data.sender === 'ai' && this.world.aiManager) {
                   this.world.aiManager.animateCompanionSpeaking();
                   
                   // Show 3D text if available
                   if (data.voiceResponse) {
                       this.world.aiManager.animateTextResponse(data.voiceResponse);
                   }
               }
           }

           showTypingIndicator(isTyping) {
               if (isTyping) {
                   this.world.aiManager.showTypingIndicator();
               } else {
                   this.world.aiManager.hideTypingIndicator();
               }
           }

           showVoiceActivity(data) {
               if (data.activity === 'speaking') {
                   document.getElementById('voice-indicator').classList.add('active');
               } else if (data.activity === 'listening') {
                   document.getElementById('listening-indicator').classList.add('active');
               } else {
                   document.getElementById('voice-indicator').classList.remove('active');
                   document.getElementById('listening-indicator').classList.remove('active');
               }
           }

           showAIInteraction(data) {
               // Show notification when presenter interacts with AI
               if (data.action === 'chat_opened') {
                   this.showNotification('Presenter opened AI chat');
               } else if (data.action === 'message_sent') {
                   this.showNotification('Presenter is chatting with AI');
               }
           }

           broadcastCameraUpdate() {
               if (!this.isHost || this.connections.size === 0) return;

               const now = Date.now();
               if (now - this.lastUpdate < this.updateInterval) return;

               const cameraData = {
                   type: 'cameraUpdate',
                   position: {
                       x: this.world.camera.position.x,
                       y: this.world.camera.position.y,
                       z: this.world.camera.position.z
                   },
                   rotation: {
                       x: this.world.camera.rotation.x,
                       y: this.world.camera.rotation.y,
                       z: this.world.camera.rotation.z
                   }
               };

               this.connections.forEach((conn) => {
                   if (conn && conn.open) {
                       try {
                           conn.send(cameraData);
                       } catch (error) {
                           console.error('Failed to send camera update:', error);
                       }
                   }
               });

               this.lastUpdate = now;
           }

           broadcastChatMessage(sender, content, voiceResponse = null) {
               if (!this.isHost || this.connections.size === 0) return;

               const data = {
                   type: 'chatMessage',
                   sender: sender,
                   content: content,
                   voiceResponse: voiceResponse,
                   isPresenter: true,
                   timestamp: Date.now()
               };

               this.connections.forEach((conn) => {
                   if (conn && conn.open) {
                       try {
                           conn.send(data);
                       } catch (error) {
                           console.error('Failed to send chat message:', error);
                       }
                   }
               });
           }

           // New method for viewers to send messages
           sendViewerMessage(message) {
               if (!this.isFollowing) return;
               
               // Find the host connection
               const hostConn = Array.from(this.connections.values())[0];
               if (hostConn && hostConn.open) {
                   hostConn.send({
                       type: 'viewerMessage',
                       message: message,
                       timestamp: Date.now()
                   });
               }
           }

           broadcastTypingIndicator(isTyping) {
               if (!this.isHost || this.connections.size === 0) return;

               const data = {
                   type: 'typingIndicator',
                   isTyping: isTyping
               };

               this.connections.forEach((conn) => {
                   if (conn && conn.open) {
                       try {
                           conn.send(data);
                       } catch (error) {
                           console.error('Failed to send typing indicator:', error);
                       }
                   }
               });
           }

           broadcastVoiceActivity(activity) {
               if (!this.isHost || this.connections.size === 0) return;

               const data = {
                   type: 'voiceActivity',
                   activity: activity // 'speaking', 'listening', or 'idle'
               };

               this.connections.forEach((conn) => {
                   if (conn && conn.open) {
                       try {
                           conn.send(data);
                       } catch (error) {
                           console.error('Failed to send voice activity:', error);
                       }
                   }
               });
           }

           broadcastAIInteraction(action) {
               if (!this.isHost || this.connections.size === 0) return;

               const data = {
                   type: 'aiInteraction',
                   action: action,
                   timestamp: Date.now()
               };

               this.connections.forEach((conn) => {
                   if (conn && conn.open) {
                       try {
                           conn.send(data);
                       } catch (error) {
                           console.error('Failed to send AI interaction:', error);
                       }
                   }
               });
           }

           updateShareUrl() {
               const currentFile = window.location.pathname.split('/').pop() || 'index.html';
               const params = new URLSearchParams({
                   show: this.roomId
               });
               const shareUrl = `${window.location.origin}${window.location.pathname.replace(/[^/]*$/, '')}${currentFile}?${params}`;

               // Update QR code
               const qrUrlElement = document.getElementById('qr-url');
               if (qrUrlElement) {
                   qrUrlElement.textContent = shareUrl;
               }

               // Generate QR code
               this.generateQRCode(shareUrl);

               // Update button appearance
               const showModeButton = document.getElementById('show-mode-button');
               if (showModeButton) {
                   showModeButton.classList.add('active');
               }
           }

           generateQRCode(url) {
               const container = document.getElementById('qr-code-container');
               container.innerHTML = '';

               const loadQRious = () => {
                   return new Promise((resolve, reject) => {
                       if (window.QRious) {
                           resolve();
                       } else {
                           const script = document.createElement('script');
                           script.src = 'https://cdnjs.cloudflare.com/ajax/libs/qrious/4.0.2/qrious.min.js';
                           script.onload = resolve;
                           script.onerror = reject;
                           document.head.appendChild(script);
                       }
                   });
               };

               loadQRious().then(() => {
                   const canvas = document.createElement('canvas');
                   container.appendChild(canvas);

                   new window.QRious({
                       element: canvas,
                       value: url,
                       size: 250,
                       background: 'white',
                       foreground: 'black',
                       level: 'H'
                   });
               }).catch(() => {
                   const img = document.createElement('img');
                   img.src = `https://api.qrserver.com/v1/create-qr-code/?size=250x250&data=${encodeURIComponent(url)}`;
                   img.alt = 'QR Code';
                   container.appendChild(img);
               });
           }

           updateStatus(status, connected) {
               const statusText = document.getElementById('status-text');
               const statusIndicator = document.getElementById('status-indicator');

               if (statusText) statusText.textContent = status;
               if (statusIndicator) {
                   statusIndicator.classList.toggle('connected', connected);
                   statusIndicator.classList.toggle('hosting', this.isHost);
               }
           }

           updateViewerCount() {
               const count = this.connections.size + 1; // +1 for self
               const viewerCountEl = document.getElementById('viewer-count');
               if (viewerCountEl) viewerCountEl.textContent = count;
           }

           generateUsername() {
               const adjectives = ['Swift', 'Curious', 'Bright', 'Eager', 'Active'];
               const nouns = ['Viewer', 'Observer', 'Student', 'Attendee', 'Participant'];
               const adj = adjectives[Math.floor(Math.random() * adjectives.length)];
               const noun = nouns[Math.floor(Math.random() * nouns.length)];
               return `${adj}${noun}${Math.floor(Math.random() * 100)}`;
           }

           showNotification(message) {
               const notification = document.createElement('div');
               notification.className = 'show-mode-notification';
               notification.textContent = message;

               document.body.appendChild(notification);

               setTimeout(() => {
                   notification.style.animation = 'slideOut 0.3s ease';
                   setTimeout(() => notification.remove(), 300);
               }, 3000);
           }

           showError(message) {
               console.error(message);
               this.showNotification('⚠️ ' + message);
           }

           // Call this in the animation loop
           update() {
               this.broadcastCameraUpdate();
           }
       }

       // Settings Manager
       class SettingsManager {
           constructor(worldInstance) {
               this.world = worldInstance;
               this.settings = this.loadAllSettings();
               this.setupEventListeners();
               this.updatePreview();
           }

           loadAllSettings() {
               const stored = localStorage.getItem('aiCompanionAllSettings');
               if (stored) {
                   return JSON.parse(stored);
               }

               return {
                   version: "1.0",
                   timestamp: new Date().toISOString(),
                   api: {
                       key: localStorage.getItem('nexus_ai_api_key') || '',
                       endpoint: 'https://azfbusinessbot.azurewebsites.net/api/businessinsightbot_function'
                   },
                   voice: {
                       output: {
                           enabled: true,
                           autoSpeak: false,
                           azureTTSKey: '',
                           ttsVoiceName: 'en-US-JennyNeural'
                       },
                       input: {
                           enabled: true,
                           continuousConversation: false,
                           pushToTalkKey: 'Space'
                       }
                   },
                   perspective: {
                       camera: {
                           position: { x: 0, y: 5, z: 8 },
                           rotation: { x: 0, y: 0, z: 0 },
                           fov: 75
                       },
                       visual: {
                           fogDensity: 50,
                           particleCount: 300
                       }
                   },
                   world: {
                       name: "AI Companion Hub",
                       description: "Your intelligent assistant awaits. Click on the AI companion to start chatting!"
                   }
               };
           }

           setupEventListeners() {
               // Tab switching
               document.querySelectorAll('.settings-tab').forEach(tab => {
                   tab.addEventListener('click', (e) => {
                       document.querySelectorAll('.settings-tab').forEach(t => t.classList.remove('active'));
                       document.querySelectorAll('.settings-section').forEach(s => s.classList.remove('active'));
                       
                       e.target.classList.add('active');
                       const tabName = e.target.dataset.tab;
                       document.getElementById(`${tabName}-settings`).classList.add('active');
                   });
               });

               // Close button
               document.getElementById('close-settings').addEventListener('click', () => {
                   document.getElementById('settings-panel').classList.remove('active');
               });

               // Settings button
               document.getElementById('settings-button').addEventListener('click', () => {
                   this.openSettings();
               });

               // Toggle switches
               this.setupToggleSwitch('settings-voice-enabled', 'voice.output.enabled');
               this.setupToggleSwitch('settings-auto-speak', 'voice.output.autoSpeak');
               this.setupToggleSwitch('settings-voice-input-enabled', 'voice.input.enabled');
               this.setupToggleSwitch('settings-continuous-conversation', 'voice.input.continuousConversation');

               // Input fields
               this.setupInputField('settings-api-key', 'api.key');
               this.setupInputField('settings-endpoint', 'api.endpoint');
               this.setupInputField('settings-azure-tts-key', 'voice.output.azureTTSKey');
               this.setupInputField('world-name', 'world.name');
               this.setupInputField('world-description', 'world.description');

               // Select fields
               this.setupSelectField('settings-tts-voice', 'voice.output.ttsVoiceName');
               this.setupSelectField('settings-push-to-talk', 'voice.input.pushToTalkKey');

               // Real-time preview update
               setInterval(() => this.updatePreview(), 1000);
           }

           setupToggleSwitch(elementId, settingPath) {
               const element = document.getElementById(elementId);
               if (!element) return;

               const value = this.getNestedValue(this.settings, settingPath);
               element.classList.toggle('active', value);

               element.addEventListener('click', () => {
                   const isActive = element.classList.toggle('active');
                   this.setNestedValue(this.settings, settingPath, isActive);
                   this.updatePreview();
               });
           }

           setupInputField(elementId, settingPath) {
               const element = document.getElementById(elementId);
               if (!element) return;

               const value = this.getNestedValue(this.settings, settingPath);
               element.value = value || '';

               element.addEventListener('input', (e) => {
                   this.setNestedValue(this.settings, settingPath, e.target.value);
                   this.updatePreview();
               });
           }

           setupSelectField(elementId, settingPath) {
               const element = document.getElementById(elementId);
               if (!element) return;

               const value = this.getNestedValue(this.settings, settingPath);
               element.value = value || '';

               element.addEventListener('change', (e) => {
                   this.setNestedValue(this.settings, settingPath, e.target.value);
                   this.updatePreview();
               });
           }

           getNestedValue(obj, path) {
               return path.split('.').reduce((curr, prop) => curr?.[prop], obj);
           }

           setNestedValue(obj, path, value) {
               const props = path.split('.');
               const last = props.pop();
               const target = props.reduce((curr, prop) => {
                   if (!curr[prop]) curr[prop] = {};
                   return curr[prop];
               }, obj);
               target[last] = value;
           }

           openSettings() {
               this.loadSettingsToUI();
               document.getElementById('settings-panel').classList.add('active');
               this.updatePreview();
           }

           loadSettingsToUI() {
               // Load all current settings into UI
               this.loadToggleSwitch('settings-voice-enabled', 'voice.output.enabled');
               this.loadToggleSwitch('settings-auto-speak', 'voice.output.autoSpeak');
               this.loadToggleSwitch('settings-voice-input-enabled', 'voice.input.enabled');
               this.loadToggleSwitch('settings-continuous-conversation', 'voice.input.continuousConversation');

               this.loadInputField('settings-api-key', 'api.key');
               this.loadInputField('settings-endpoint', 'api.endpoint');
               this.loadInputField('settings-azure-tts-key', 'voice.output.azureTTSKey');
               this.loadInputField('world-name', 'world.name');
               this.loadInputField('world-description', 'world.description');

               this.loadSelectField('settings-tts-voice', 'voice.output.ttsVoiceName');
               this.loadSelectField('settings-push-to-talk', 'voice.input.pushToTalkKey');
           }

           loadToggleSwitch(elementId, settingPath) {
               const element = document.getElementById(elementId);
               if (!element) return;
               const value = this.getNestedValue(this.settings, settingPath);
               element.classList.toggle('active', value);
           }

           loadInputField(elementId, settingPath) {
               const element = document.getElementById(elementId);
               if (!element) return;
               const value = this.getNestedValue(this.settings, settingPath);
               element.value = value || '';
           }

           loadSelectField(elementId, settingPath) {
               const element = document.getElementById(elementId);
               if (!element) return;
               const value = this.getNestedValue(this.settings, settingPath);
               element.value = value || '';
           }

           updatePreview() {
               const preview = document.getElementById('json-preview');
               if (preview) {
                   const displaySettings = JSON.parse(JSON.stringify(this.settings));
                   
                   // Mask sensitive data for display
                   if (displaySettings.api.key) {
                       displaySettings.api.key = displaySettings.api.key.substring(0, 8) + '...';
                   }
                   if (displaySettings.voice.output.azureTTSKey) {
                       displaySettings.voice.output.azureTTSKey = displaySettings.voice.output.azureTTSKey.substring(0, 8) + '...';
                   }
                   
                   preview.textContent = JSON.stringify(displaySettings, null, 2);
               }
           }

           saveSettings() {
               this.settings.timestamp = new Date().toISOString();
               localStorage.setItem('aiCompanionAllSettings', JSON.stringify(this.settings));
               
               // Apply settings to various components
               if (this.world.aiManager) {
                   this.world.aiManager.apiKey = this.settings.api.key;
                   this.world.aiManager.endpoint = this.settings.api.endpoint;
                   this.world.aiManager.applySettingsFromManager();
                   
                   // If API key is set and AI isn't active, try to activate it
                   if (this.settings.api.key && !this.world.aiManager.isActive) {
                       this.world.aiManager.checkCachedApiKey();
                   }
               }

               if (this.world.perspectiveManager) {
                   this.world.perspectiveManager.applySettings(this.settings.perspective);
               }

               // Update world UI
               document.getElementById('world-title').textContent = this.settings.world.name;
               document.getElementById('world-description').textContent = this.settings.world.description;

               this.world.showNotification('Settings saved successfully!');
               document.getElementById('settings-panel').classList.remove('active');
           }

           exportSettings() {
               const dataStr = JSON.stringify(this.settings, null, 2);
               const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
               
               const exportFileDefaultName = `ai-companion-settings-${new Date().toISOString().split('T')[0]}.json`;
               
               const linkElement = document.createElement('a');
               linkElement.setAttribute('href', dataUri);
               linkElement.setAttribute('download', exportFileDefaultName);
               linkElement.click();
               
               this.world.showNotification('Settings exported successfully!');
           }

           async importSettings(event) {
               const file = event.target.files[0];
               if (!file) return;

               try {
                   const text = await file.text();
                   const imported = JSON.parse(text);
                   
                   // Validate imported settings
                   if (!imported.version || !imported.api || !imported.voice || !imported.perspective) {
                       throw new Error('Invalid settings file format');
                   }
                   
                   // Merge with current settings
                   this.settings = { ...this.settings, ...imported };
                   this.settings.timestamp = new Date().toISOString();
                   
                   // Save and apply
                   this.saveSettings();
                   this.loadSettingsToUI();
                   this.updatePreview();
                   this.world.showNotification('Settings imported successfully!');
               } catch (error) {
                   console.error('Error importing settings:', error);
                   this.world.showNotification('Failed to import settings. Please check the file format.');
               }
               
               event.target.value = '';
           }

           resetSettings() {
               if (confirm('Are you sure you want to reset all settings? This cannot be undone.')) {
                   localStorage.removeItem('aiCompanionAllSettings');
                   localStorage.removeItem('nexus_ai_api_key');
                   localStorage.removeItem('nexusAISettings');
                   
                   this.settings = this.loadAllSettings();
                   this.loadSettingsToUI();
                   this.updatePreview();
                   
                   this.world.showNotification('All settings have been reset to defaults.');
               }
           }
       }

       // Perspective Manager
       class PerspectiveManager {
           constructor(worldInstance) {
               this.world = worldInstance;
               this.setupControls();
               this.presets = {
                   default: { position: { x: 0, y: 5, z: 8 }, rotation: { x: 0, y: 0 }, fov: 75 },
                   overhead: { position: { x: 0, y: 20, z: 5 }, rotation: { x: -60, y: 0 }, fov: 60 },
                   close: { position: { x: 0, y: 4, z: 3 }, rotation: { x: 0, y: 0 }, fov: 90 },
                   side: { position: { x: 10, y: 5, z: 0 }, rotation: { x: 0, y: 90 }, fov: 75 },
                   wide: { position: { x: 0, y: 8, z: 15 }, rotation: { x: 0, y: 0 }, fov: 100 },
                   dramatic: { position: { x: -5, y: 2, z: 5 }, rotation: { x: 10, y: -45 }, fov: 85 }
               };
           }

           setupControls() {
               // Camera position controls
               this.setupRangeControl('camera-pos-x', 'pos-x-value', (value) => {
                   if (this.world.camera) this.world.camera.position.x = parseFloat(value);
               });

               this.setupRangeControl('camera-pos-y', 'pos-y-value', (value) => {
                   if (this.world.camera) this.world.camera.position.y = parseFloat(value);
               });

               this.setupRangeControl('camera-pos-z', 'pos-z-value', (value) => {
                   if (this.world.camera) this.world.camera.position.z = parseFloat(value);
               });

               // Camera rotation controls
               this.setupRangeControl('camera-rot-x', 'rot-x-value', (value) => {
                   if (this.world.camera) this.world.camera.rotation.x = THREE.MathUtils.degToRad(parseFloat(value));
               });

               this.setupRangeControl('camera-rot-y', 'rot-y-value', (value) => {
                   if (this.world.camera) this.world.camera.rotation.y = THREE.MathUtils.degToRad(parseFloat(value));
               });

               // FOV control
               this.setupRangeControl('camera-fov', 'fov-value', (value) => {
                   if (this.world.camera) {
                       this.world.camera.fov = parseFloat(value);
                       this.world.camera.updateProjectionMatrix();
                   }
               });

               // Visual settings
               this.setupRangeControl('fog-density', 'fog-density-value', (value) => {
                   if (this.world.scene && this.world.scene.fog) {
                       this.world.scene.fog.far = parseFloat(value);
                   }
               });

               this.setupRangeControl('particle-count', 'particle-count-value', (value) => {
                   this.updateParticleCount(parseInt(value));
               });
           }

           setupRangeControl(inputId, displayId, onChange) {
               const input = document.getElementById(inputId);
               const display = document.getElementById(displayId);
               
               if (input && display) {
                   input.addEventListener('input', (e) => {
                       display.textContent = e.target.value;
                       onChange(e.target.value);
                       this.updateSettingsFromUI();
                   });
               }
           }

           updateSettingsFromUI() {
               if (this.world.settingsManager) {
                   const settings = this.world.settingsManager.settings;
                   
                   settings.perspective.camera.position.x = parseFloat(document.getElementById('camera-pos-x').value);
                   settings.perspective.camera.position.y = parseFloat(document.getElementById('camera-pos-y').value);
                   settings.perspective.camera.position.z = parseFloat(document.getElementById('camera-pos-z').value);
                   
                   settings.perspective.camera.rotation.x = parseFloat(document.getElementById('camera-rot-x').value);
                   settings.perspective.camera.rotation.y = parseFloat(document.getElementById('camera-rot-y').value);
                   
                   settings.perspective.camera.fov = parseFloat(document.getElementById('camera-fov').value);
                   settings.perspective.visual.fogDensity = parseFloat(document.getElementById('fog-density').value);
                   settings.perspective.visual.particleCount = parseInt(document.getElementById('particle-count').value);
                   
                   this.world.settingsManager.updatePreview();
               }
           }

           applyPreset(presetName) {
               const preset = this.presets[presetName];
               if (!preset) return;

               // Update camera
               if (this.world.camera) {
                   this.world.camera.position.set(preset.position.x, preset.position.y, preset.position.z);
                   this.world.camera.rotation.x = THREE.MathUtils.degToRad(preset.rotation.x);
                   this.world.camera.rotation.y = THREE.MathUtils.degToRad(preset.rotation.y);
                   this.world.camera.fov = preset.fov;
                   this.world.camera.updateProjectionMatrix();
               }

               // Update UI controls
               document.getElementById('camera-pos-x').value = preset.position.x;
               document.getElementById('pos-x-value').textContent = preset.position.x;
               
               document.getElementById('camera-pos-y').value = preset.position.y;
               document.getElementById('pos-y-value').textContent = preset.position.y;
               
               document.getElementById('camera-pos-z').value = preset.position.z;
               document.getElementById('pos-z-value').textContent = preset.position.z;
               
               document.getElementById('camera-rot-x').value = preset.rotation.x;
               document.getElementById('rot-x-value').textContent = preset.rotation.x;
               
               document.getElementById('camera-rot-y').value = preset.rotation.y;
               document.getElementById('rot-y-value').textContent = preset.rotation.y;
               
               document.getElementById('camera-fov').value = preset.fov;
               document.getElementById('fov-value').textContent = preset.fov;

               this.updateSettingsFromUI();
               this.world.showNotification(`Applied ${presetName} preset`);
           }

           applySettings(perspectiveSettings) {
               if (!perspectiveSettings) return;

               // Apply camera settings
               if (this.world.camera && perspectiveSettings.camera) {
                   const cam = perspectiveSettings.camera;
                   this.world.camera.position.set(cam.position.x, cam.position.y, cam.position.z);
                   this.world.camera.rotation.set(
                       THREE.MathUtils.degToRad(cam.rotation.x),
                       THREE.MathUtils.degToRad(cam.rotation.y),
                       THREE.MathUtils.degToRad(cam.rotation.z || 0)
                   );
                   this.world.camera.fov = cam.fov;
                   this.world.camera.updateProjectionMatrix();
               }

               // Apply visual settings
               if (perspectiveSettings.visual) {
                   if (this.world.scene && this.world.scene.fog) {
                       this.world.scene.fog.far = perspectiveSettings.visual.fogDensity;
                   }
                   this.updateParticleCount(perspectiveSettings.visual.particleCount);
               }
           }

           updateParticleCount(count) {
               // Find and update particle system
               const particles = this.world.scene.getObjectByProperty('type', 'Points');
               if (particles) {
                   const positions = new Float32Array(count * 3);
                   const colors = new Float32Array(count * 3);

                   for (let i = 0; i < count * 3; i += 3) {
                       positions[i] = (Math.random() - 0.5) * 80;
                       positions[i + 1] = Math.random() * 30 + 5;
                       positions[i + 2] = (Math.random() - 0.5) * 80;

                       colors[i] = Math.random() * 0.5 + 0.5;
                       colors[i + 1] = Math.random() * 0.5;
                       colors[i + 2] = Math.random() * 0.5 + 0.5;
                   }

                   particles.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                   particles.geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
               }
           }
       }

       // Voice Input Manager - FIXED
       class VoiceInputManager {
           constructor(aiManager) {
               this.aiManager = aiManager;
               this.recognition = null;
               this.isListening = false;
               this.isEnabled = true;
               this.continuousMode = false;
               this.pushToTalkKey = 'Space';
               this.isKeyPressed = false;
               this.isPaused = false;
               this.wasListeningBeforePause = false;
               
               this.initializeSpeechRecognition();
               
               this.voiceInputBtn = document.getElementById('voice-input-btn');
               this.listeningIndicator = document.getElementById('listening-indicator');
               
               this.setupEventListeners();
           }

           initializeSpeechRecognition() {
               const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
               
               if (!SpeechRecognition) {
                   console.error('Speech recognition not supported');
                   this.showNotification('Speech recognition not supported in this browser');
                   return;
               }

               this.recognition = new SpeechRecognition();
               this.recognition.continuous = false;
               this.recognition.interimResults = true;
               this.recognition.lang = 'en-US';

               this.recognition.onstart = () => {
                   console.log('Speech recognition started');
                   this.isListening = true;
                   this.voiceInputBtn.classList.add('recording');
                   this.listeningIndicator.classList.add('active');
                   
                   // Broadcast voice activity
                   if (this.aiManager.world.showModeManager && this.aiManager.world.showModeManager.isHost) {
                       this.aiManager.world.showModeManager.broadcastVoiceActivity('listening');
                   }
               };

               this.recognition.onend = () => {
                   console.log('Speech recognition ended');
                   this.isListening = false;
                   this.voiceInputBtn.classList.remove('recording');
                   this.listeningIndicator.classList.remove('active');
                   
                   // Broadcast voice activity
                   if (this.aiManager.world.showModeManager && this.aiManager.world.showModeManager.isHost) {
                       this.aiManager.world.showModeManager.broadcastVoiceActivity('idle');
                   }
                   
                   // Only restart if continuous mode is enabled and not paused
                   if (this.continuousMode && this.isEnabled && this.aiManager.isActive && !this.isPaused) {
                       setTimeout(() => {
                           if (!this.aiManager.voiceManager.isSpeaking && !this.isPaused) {
                               this.startListening();
                           }
                       }, 500);
                   }
               };

               this.recognition.onresult = (event) => {
                   let finalTranscript = '';
                   let interimTranscript = '';

                   for (let i = event.resultIndex; i < event.results.length; i++) {
                       const transcript = event.results[i][0].transcript;
                       if (event.results[i].isFinal) {
                           finalTranscript += transcript;
                       } else {
                           interimTranscript += transcript;
                       }
                   }

                   if (interimTranscript) {
                       document.getElementById('ai-chat-input').value = interimTranscript;
                   }

                   if (finalTranscript) {
                       console.log('Final transcript:', finalTranscript);
                       document.getElementById('ai-chat-input').value = finalTranscript;
                       this.aiManager.sendMessage();
                       
                       if (!this.continuousMode) {
                           this.stopListening();
                       }
                   }
               };

               this.recognition.onerror = (event) => {
                   console.error('Speech recognition error:', event.error);
                   this.isListening = false;
                   this.voiceInputBtn.classList.remove('recording');
                   this.listeningIndicator.classList.remove('active');
                   
                   // Ignore aborted errors when pausing
                   if (event.error === 'aborted') {
                       console.log('Speech recognition aborted (likely due to pause)');
                       return;
                   }
                   
                   if (event.error === 'no-speech') {
                       return;
                   }
                   
                   this.showNotification(`Speech recognition error: ${event.error}`);
               };
           }

           setupEventListeners() {
               if (this.voiceInputBtn) {
                   if (isMobile) {
                       this.voiceInputBtn.addEventListener('touchstart', (e) => {
                           e.preventDefault();
                           if (this.isEnabled && this.aiManager.isActive && !this.isPaused) {
                               this.startListening();
                           }
                       });

                       this.voiceInputBtn.addEventListener('touchend', (e) => {
                           e.preventDefault();
                           if (!this.continuousMode) {
                               this.stopListening();
                           }
                       });
                   } else {
                       this.voiceInputBtn.addEventListener('mousedown', (e) => {
                           e.preventDefault();
                           if (this.isEnabled && this.aiManager.isActive && !this.isPaused) {
                               this.startListening();
                           }
                       });

                       this.voiceInputBtn.addEventListener('mouseup', (e) => {
                           e.preventDefault();
                           if (!this.continuousMode) {
                               this.stopListening();
                           }
                       });

                       this.voiceInputBtn.addEventListener('mouseleave', (e) => {
                           if (this.isListening && !this.continuousMode) {
                               this.stopListening();
                           }
                       });
                   }
               }

               if (!isMobile) {
                   window.addEventListener('keydown', (e) => {
                       if (e.key === this.pushToTalkKey && !this.isKeyPressed && this.isEnabled && this.aiManager.isActive && !e.repeat && !this.isPaused) {
                           this.isKeyPressed = true;
                           this.startListening();
                       }
                   });

                   window.addEventListener('keyup', (e) => {
                       if (e.key === this.pushToTalkKey && this.isKeyPressed) {
                           this.isKeyPressed = false;
                           if (!this.continuousMode) {
                               this.stopListening();
                           }
                       }
                   });
               }
           }

           startListening() {
               if (!this.recognition || this.isListening || this.aiManager.voiceManager.isSpeaking || this.isPaused) {
                   return;
               }

               try {
                   this.recognition.start();
               } catch (error) {
                   console.error('Error starting speech recognition:', error);
               }
           }

           stopListening() {
               if (!this.recognition || !this.isListening) {
                   return;
               }

               try {
                   this.recognition.stop();
               } catch (error) {
                   console.error('Error stopping speech recognition:', error);
               }
           }

           setEnabled(enabled) {
               this.isEnabled = enabled;
               if (!enabled) {
                   this.stopListening();
               }
               this.updateButtonState();
           }

           setContinuousMode(enabled) {
               this.continuousMode = enabled;
               if (enabled && this.isEnabled && this.aiManager.isActive && !this.isListening && !this.isPaused) {
                   this.startListening();
               } else if (!enabled && this.isListening) {
                   this.stopListening();
               }
           }

           setPushToTalkKey(key) {
               this.pushToTalkKey = key;
           }

           setPaused(paused) {
               this.isPaused = paused;
               
               if (paused) {
                   // Remember if we were listening before pause
                   this.wasListeningBeforePause = this.isListening;
                   
                   // Stop listening gracefully
                   if (this.isListening) {
                       try {
                           this.recognition.abort(); // Use abort instead of stop to prevent error
                       } catch (error) {
                           console.log('Error aborting speech recognition:', error);
                       }
                       this.isListening = false;
                       this.voiceInputBtn.classList.remove('recording');
                       this.listeningIndicator.classList.remove('active');
                   }
               } else {
                   // Resume if we were listening before and continuous mode is on
                   if (this.continuousMode && this.isEnabled && this.aiManager.isActive && this.wasListeningBeforePause) {
                       setTimeout(() => {
                           this.startListening();
                       }, 500);
                   }
                   this.wasListeningBeforePause = false;
               }
               
               this.updateButtonState();
           }

           updateButtonState() {
               if (this.voiceInputBtn) {
                   if (this.isPaused || !this.isEnabled) {
                       this.voiceInputBtn.classList.add('disabled');
                       this.voiceInputBtn.title = this.isPaused ? 'Voice input paused' : 'Voice input disabled';
                   } else {
                       this.voiceInputBtn.classList.remove('disabled');
                       this.voiceInputBtn.title = 'Hold to speak';
                   }
               }
           }

           showNotification(message) {
               if (this.aiManager && this.aiManager.showNotification) {
                   this.aiManager.showNotification(message);
               }
           }
       }

       // Voice Manager with Azure TTS
       class VoiceManager {
           constructor() {
               this.synthesis = window.speechSynthesis;
               this.enabled = true;
               this.autoSpeak = false;
               this.isSpeaking = false;
               this.azureKey = '';
               this.azureRegion = 'eastus2';
               this.voiceName = 'en-US-JennyNeural';
               this.isSdkLoaded = false;
               this.speechSynthesizer = null;
               this.maxCharacters = 5000;
               this.isPaused = false;
               
               this.loadSpeechSdk();
           }

           loadSpeechSdk() {
               if (window.SpeechSDK) {
                   this.isSdkLoaded = true;
                   return;
               }

               const script = document.createElement("script");
               script.src = "https://aka.ms/csspeech/jsbrowserpackageraw";
               script.async = true;
               script.onload = () => {
                   console.log("Microsoft Speech SDK loaded");
                   this.isSdkLoaded = true;
               };
               script.onerror = () => {
                   console.error("Failed to load Microsoft Speech SDK");
               };

               document.body.appendChild(script);
           }

           setEnabled(enabled) {
               this.enabled = enabled;
               if (!enabled) {
                   this.stopSpeaking();
               }
           }

           setAutoSpeak(autoSpeak) {
               this.autoSpeak = autoSpeak;
           }

           setAzureKey(key) {
               this.azureKey = key;
           }

           setVoiceName(voiceName) {
               this.voiceName = voiceName;
           }

           setPaused(paused) {
               this.isPaused = paused;
               if (paused) {
                   this.stopSpeaking();
               }
           }

           async speak(text, aiManager = null) {
               if (!this.enabled || !text || this.isSpeaking || this.isPaused) return;

               this.stopSpeaking();
               
               const cleanText = this.cleanTextForSpeech(text);
               
               // Broadcast voice activity
               if (aiManager && aiManager.world.showModeManager && aiManager.world.showModeManager.isHost) {
                   aiManager.world.showModeManager.broadcastVoiceActivity('speaking');
               }
               
               if (this.azureKey && this.isSdkLoaded && window.SpeechSDK) {
                   await this.speakWithAzure(cleanText, aiManager);
               } else {
                   await this.speakWithBrowser(cleanText, aiManager);
               }
               
               // Broadcast voice activity end
               if (aiManager && aiManager.world.showModeManager && aiManager.world.showModeManager.isHost) {
                   aiManager.world.showModeManager.broadcastVoiceActivity('idle');
               }
           }

           async speakWithAzure(text, aiManager = null) {
               if (this.isPaused) return;
               
               try {
                   const truncatedText = text.length > this.maxCharacters
                       ? text.substring(0, this.maxCharacters) + "... (text truncated for speech)"
                       : text;

                   const speechConfig = window.SpeechSDK.SpeechConfig.fromSubscription(
                       this.azureKey,
                       this.azureRegion
                   );
                   speechConfig.speechSynthesisVoiceName = this.voiceName;

                   const audioConfig = window.SpeechSDK.AudioConfig.fromDefaultSpeakerOutput();
                   this.speechSynthesizer = new window.SpeechSDK.SpeechSynthesizer(
                       speechConfig,
                       audioConfig
                   );

                   this.isSpeaking = true;
                   document.getElementById('voice-indicator').classList.add('active');

                   await new Promise((resolve, reject) => {
                       this.speechSynthesizer.speakTextAsync(
                           truncatedText,
                           (result) => {
                               if (
                                   result.reason ===
                                   window.SpeechSDK.ResultReason.SynthesizingAudioCompleted
                               ) {
                                   console.log("Azure TTS synthesis completed");
                                   this.isSpeaking = false;
                                   document.getElementById('voice-indicator').classList.remove('active');
                                   
                                   if (this.speechSynthesizer) {
                                       this.speechSynthesizer.close();
                                       this.speechSynthesizer = null;
                                   }
                                   resolve();
                               } else {
                                   console.error(
                                       `Speech synthesis canceled, reason: ${result.reason}`
                                   );
                                   
                                   if (this.speechSynthesizer) {
                                       this.speechSynthesizer.close();
                                       this.speechSynthesizer = null;
                                   }

                                   this.isSpeaking = false;
                                   document.getElementById('voice-indicator').classList.remove('active');
                                   reject(new Error(`Speech synthesis failed.`));
                               }
                           },
                           (error) => {
                               console.error("Azure TTS error:", error);

                               if (this.speechSynthesizer) {
                                   this.speechSynthesizer.close();
                                   this.speechSynthesizer = null;
                               }

                               this.isSpeaking = false;
                               document.getElementById('voice-indicator').classList.remove('active');
                               reject(error);
                           }
                       );
                   });
               } catch (error) {
                   console.error("Azure TTS error:", error);
                   this.isSpeaking = false;
                   document.getElementById('voice-indicator').classList.remove('active');
                   await this.speakWithBrowser(text, aiManager);
               }
           }

           async speakWithBrowser(text, aiManager = null) {
               if (this.isPaused) return;
               
               return new Promise((resolve, reject) => {
                   try {
                       const utterance = new SpeechSynthesisUtterance(text);
                       utterance.rate = 1.0;
                       utterance.pitch = 1.0;
                       utterance.volume = 1.0;
                       
                       const voices = this.synthesis.getVoices();
                       const preferredVoice = voices.find(voice => 
                           voice.name.includes('Microsoft') || 
                           voice.name.includes('Google') ||
                           voice.name.includes('Natural')
                       ) || voices[0];
                       
                       if (preferredVoice) {
                           utterance.voice = preferredVoice;
                       }
                       
                       utterance.onstart = () => {
                           this.isSpeaking = true;
                           document.getElementById('voice-indicator').classList.add('active');
                       };
                       
                       utterance.onend = () => {
                           this.isSpeaking = false;
                           document.getElementById('voice-indicator').classList.remove('active');
                           resolve();
                       };
                       
                       utterance.onerror = (error) => {
                           this.isSpeaking = false;
                           document.getElementById('voice-indicator').classList.remove('active');
                           reject(error);
                       };
                       
                       this.synthesis.speak(utterance);
                   } catch (error) {
                       this.isSpeaking = false;
                       document.getElementById('voice-indicator').classList.remove('active');
                       reject(error);
                   }
               });
           }

           stopSpeaking() {
               if (this.speechSynthesizer) {
                   try {
                       this.speechSynthesizer.close();
                   } catch (e) {
                       console.warn("Error closing speech synthesizer:", e);
                   }
                   this.speechSynthesizer = null;
               }

               if (window.speechSynthesis) {
                   try {
                       window.speechSynthesis.cancel();
                   } catch (e) {
                       console.warn("Error canceling speech synthesis:", e);
                   }
               }

               this.isSpeaking = false;
               document.getElementById('voice-indicator').classList.remove('active');
           }

           cleanTextForSpeech(text) {
               let cleanText = text.replace(/<[^>]*>/g, " ");

               cleanText = cleanText
                   .replace(/\*\*([^*]+)\*\*/g, "$1")
                   .replace(/\*([^*]+)\*/g, "$1")
                   .replace(/`([^`]+)`/g, "$1")
                   .replace(/\[([^\]]+)\]\([^)]+\)/g, "$1")
                   .replace(/#{1,6}\s+([^\n]+)/g, "$1")
                   .replace(/```[\s\S]*?```/g, "")
                   .replace(/\n/g, " ")
                   .replace(/\s+/g, " ")
                   .trim();

               return cleanText;
           }
       }

       // Task Manager for conversation replay
       class TaskManager {
           constructor(worldInstance) {
               this.world = worldInstance;
               this.conversations = new Map();
               this.currentReplay = null;
               this.isReplaying = false;

               this.setupEventListeners();
           }

           setupEventListeners() {
               document.getElementById('tasks-button').addEventListener('click', () => {
                   this.toggleTaskPanel();
               });
           }

           toggleTaskPanel() {
               const panel = document.getElementById('task-panel');
               panel.classList.toggle('active');
               if (panel.classList.contains('active')) {
                   this.updateTaskList();
               }
           }

           updateTaskList() {
               const taskList = document.getElementById('task-list');
               taskList.innerHTML = '';

               if (this.conversations.size === 0) {
                   taskList.innerHTML = '<p style="color: rgba(255, 255, 255, 0.5); text-align: center; margin-top: 20px;">No conversations loaded yet. Upload a Teacher-Learner conversation JSON to replay it in 3D space!</p>';
                   return;
               }

               this.conversations.forEach((conversation, conversationId) => {
                   const taskEl = document.createElement('div');
                   taskEl.className = 'task-item';
                   
                   const messageCount = conversation.conversation ? conversation.conversation.length : 0;
                   const timestamp = conversation.timestamp ? new Date(conversation.timestamp).toLocaleString() : 'Unknown';
                   const appName = conversation.appName || 'Unnamed Conversation';
                   
                   taskEl.innerHTML = `<strong>${appName}</strong>
                       <small>Saved: ${timestamp}</small>
                       <div style="font-size: 0.85em; color: rgba(255, 255, 255, 0.7); margin-top: 8px;">
                           ${messageCount} messages
                       </div>
                   `;
                   taskEl.onclick = () => this.startConversationReplay(conversationId);
                   taskList.appendChild(taskEl);
               });
           }

           async uploadConversation(event) {
               const file = event.target.files[0];
               if (!file) return;

               try {
                   const text = await file.text();
                   const conversationData = JSON.parse(text);

                   if (!conversationData.conversation || !Array.isArray(conversationData.conversation)) {
                       throw new Error('Invalid conversation format');
                   }

                   const conversationId = `conv_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                   
                   this.conversations.set(conversationId, conversationData);

                   this.updateTaskList();
                   this.world.showNotification('Conversation uploaded successfully!');

               } catch (error) {
                   console.error('Error uploading conversation:', error);
                   this.world.showNotification('Failed to upload conversation. Check file format.');
               }

               event.target.value = '';
           }

           async startConversationReplay(conversationId) {
               const conversation = this.conversations.get(conversationId);
               if (!conversation) return;

               this.world.showNotification(`Starting conversation replay...`);

               document.getElementById('ai-chat-interface').classList.add('active');

               const chatMessages = document.getElementById('ai-chat-messages');
               chatMessages.innerHTML = '';

               this.isReplaying = true;
               this.currentReplay = {
                   conversation: conversation,
                   currentIndex: 0
               };

               for (const message of conversation.conversation) {
                   await this.processMessage(message);
                   await this.delay(2000);
               }

               this.isReplaying = false;
               this.world.showNotification('Conversation replay completed!');
           }

           async processMessage(message) {
               if (message.role === 'user') {
                   this.addReplayMessage(message.content, 'user');
                   
               } else if (message.role === 'assistant') {
                   this.world.aiManager.showTypingIndicator();
                   
                   await this.delay(1500);
                   
                   this.world.aiManager.hideTypingIndicator();
                   this.addReplayMessage(message.content, 'ai');
                   
                   if (this.world.aiManager && this.world.aiManager.isActive) {
                       this.world.aiManager.animateTextResponse(message.content);
                   }
                   
               } else if (message.role === 'system') {
                   this.addReplayMessage(message.content, 'system');
               }
           }

           addReplayMessage(text, sender) {
               const chatMessages = document.getElementById('ai-chat-messages');
               const messageDiv = document.createElement('div');
               messageDiv.className = `ai-message ${sender} task-replay`;
               
               if (sender === 'ai') {
                   // Parse markdown for AI messages
                   const parser = new MarkdownParser();
                   messageDiv.innerHTML = parser.parse(text);
               } else {
                   messageDiv.textContent = text;
               }

               chatMessages.appendChild(messageDiv);
               chatMessages.scrollTop = chatMessages.scrollHeight;

               if (sender === 'ai' && this.world.aiManager && this.world.aiManager.isActive) {
                   this.world.aiManager.animateCompanionSpeaking();
               }
           }

           delay(ms) {
               return new Promise(resolve => setTimeout(resolve, ms));
           }
       }

       // AI Manager Class with Tool Integration
       class AIManager {
           constructor(worldInstance) {
               this.world = worldInstance;
               this.apiKey = null;
               this.endpoint = 'https://azfbusinessbot.azurewebsites.net/api/businessinsightbot_function';
               this.conversationHistory = [];
               this.isActive = false;
               this.voicePaused = false;

               this.markdownParser = new MarkdownParser();

               this.voiceManager = new VoiceManager();
               this.voiceInputManager = null;

               this.settings = this.loadSettings();

               this.chatInterface = document.getElementById('ai-chat-interface');
               this.chatMessages = document.getElementById('ai-chat-messages');
               this.chatInput = document.getElementById('ai-chat-input');
               this.companionButton = document.getElementById('ai-companion-button');

               this.companion = null;
               this.textMeshes = [];
               this.font = null;
               this.textGroup = null;
               this.textContainer = null;
               this.inactiveText = null;
               this.persistentTextGroup = null;

               this.lastVoiceResponse = null;
               this.activeTextAnimation = null;

               // Tool knowledge injection
               this.toolKnowledge = this.prepareToolKnowledge();

               this.setupEventListeners();
               this.checkCachedApiKey();
               this.applySettings();
               
               this.voiceInputManager = new VoiceInputManager(this);

               this.setupVoicePauseButton();
           }

           prepareToolKnowledge() {
               let knowledge = "\n\n[AVAILABLE TOOLS FOR SHARING]\n";
               knowledge += "You have access to these creative coding tools that you can share with users:\n\n";
               
               for (const [repo, tools] of Object.entries(GITHUB_TOOLS)) {
                   knowledge += `Repository: ${repo}\n`;
                   for (const [key, tool] of Object.entries(tools)) {
                       knowledge += `- ${tool.title} (${key}): ${tool.description}\n`;
                   }
               }
               
               knowledge += "\nWhen you think a tool would be helpful, you can recommend it to the user. ";
               knowledge += "To share a tool, mention it naturally in conversation and I'll help open it for them.";
               knowledge += "\n[END TOOL KNOWLEDGE]\n";
               
               return knowledge;
           }

           loadSettings() {
               if (this.world.settingsManager) {
                   const allSettings = this.world.settingsManager.settings;
                   return {
                       voiceEnabled: allSettings.voice.output.enabled,
                       autoSpeak: allSettings.voice.output.autoSpeak,
                       azureTTSKey: allSettings.voice.output.azureTTSKey,
                       ttsVoiceName: allSettings.voice.output.ttsVoiceName,
                       voiceInputEnabled: allSettings.voice.input.enabled,
                       continuousConversation: allSettings.voice.input.continuousConversation,
                       pushToTalkKey: allSettings.voice.input.pushToTalkKey
                   };
               }

               const settings = localStorage.getItem('nexusAISettings');
               return settings ? JSON.parse(settings) : {
                   voiceEnabled: true,
                   autoSpeak: false,
                   azureTTSKey: '',
                   ttsVoiceName: 'en-US-JennyNeural',
                   voiceInputEnabled: true,
                   continuousConversation: false,
                   pushToTalkKey: 'Space'
               };
           }

           saveSettings() {
               if (this.world.settingsManager) {
                   this.world.settingsManager.settings.voice.output.enabled = this.settings.voiceEnabled;
                   this.world.settingsManager.settings.voice.output.autoSpeak = this.settings.autoSpeak;
                   this.world.settingsManager.settings.voice.output.azureTTSKey = this.settings.azureTTSKey;
                   this.world.settingsManager.settings.voice.output.ttsVoiceName = this.settings.ttsVoiceName;
                   this.world.settingsManager.settings.voice.input.enabled = this.settings.voiceInputEnabled;
                   this.world.settingsManager.settings.voice.input.continuousConversation = this.settings.continuousConversation;
                   this.world.settingsManager.settings.voice.input.pushToTalkKey = this.settings.pushToTalkKey;
                   this.world.settingsManager.updatePreview();
               } else {
                   localStorage.setItem('nexusAISettings', JSON.stringify(this.settings));
               }
           }

           applySettingsFromManager() {
               if (this.world.settingsManager) {
                   this.settings = this.loadSettings();
                   this.applySettings();
               }
           }

           applySettings() {
               if (this.world.settingsManager) {
                   this.settings = this.loadSettings();
               }
               
               this.voiceManager.setEnabled(this.settings.voiceEnabled);
               this.voiceManager.setAutoSpeak(this.settings.autoSpeak);
               this.voiceManager.setAzureKey(this.settings.azureTTSKey);
               this.voiceManager.setVoiceName(this.settings.ttsVoiceName);

               if (this.voiceInputManager) {
                   this.voiceInputManager.setEnabled(this.settings.voiceInputEnabled);
                   this.voiceInputManager.setContinuousMode(this.settings.continuousConversation);
                   this.voiceInputManager.setPushToTalkKey(this.settings.pushToTalkKey);
               }
           }

           setupVoicePauseButton() {
               const pauseButton = document.getElementById('voice-pause-button');
               const pauseIndicator = document.getElementById('voice-paused-indicator');
               const pauseText = document.getElementById('voice-pause-text');

               pauseButton.addEventListener('click', () => {
                   this.voicePaused = !this.voicePaused;

                   if (this.voicePaused) {
                       this.voiceManager.setPaused(true);
                       this.voiceInputManager.setPaused(true);
                       
                       pauseButton.classList.add('paused');
                       pauseIndicator.classList.add('active');
                       pauseText.textContent = 'Resume Voice';
                       
                       this.showNotification('Voice activity paused for Teams call');
                   } else {
                       this.voiceManager.setPaused(false);
                       this.voiceInputManager.setPaused(false);
                       
                       pauseButton.classList.remove('paused');
                       pauseIndicator.classList.remove('active');
                       pauseText.textContent = 'Pause Voice';
                       
                       this.showNotification('Voice activity resumed');
                       
                       if (this.settings.continuousConversation && this.voiceInputManager) {
                           setTimeout(() => {
                               this.voiceInputManager.startListening();
                           }, 500);
                       }
                   }
               });

               window.addEventListener('keydown', (e) => {
                   if (e.key === 'Escape' && this.isActive) {
                       pauseButton.click();
                   }
               });
           }

           async checkCachedApiKey() {
               const cachedApiKey = this.world.settingsManager ? 
                   this.world.settingsManager.settings.api.key :
                   localStorage.getItem('nexus_ai_api_key');
                   
               if (cachedApiKey) {
                   this.apiKey = cachedApiKey;
                   this.endpoint = this.world.settingsManager.settings.api.endpoint;
                   try {
                       const response = await this.sendToAPI('System check - testing cached API key.' + this.toolKnowledge);
                       if (response.assistant_response) {
                           this.isActive = true;
                           this.companionButton.classList.add('active');
                           this.createAICompanion(true);
                           this.showNotification('AI Companion activated!');
                           
                           this.applySettingsFromManager();
                           
                           if (this.settings.continuousConversation && this.voiceInputManager && !this.voicePaused) {
                               this.voiceInputManager.startListening();
                           }
                       }
                   } catch (error) {
                       if (this.world.settingsManager) {
                           this.world.settingsManager.settings.api.key = '';
                       }
                       localStorage.removeItem('nexus_ai_api_key');
                       this.apiKey = null;
                       this.createAICompanion(false);
                   }
               } else {
                   this.createAICompanion(false);
               }
           }

           setupEventListeners() {
               this.companionButton.addEventListener('click', () => {
                   if (this.isActive) {
                       this.chatInterface.classList.toggle('active');
                       
                       if (this.world.showModeManager && this.world.showModeManager.isHost) {
                           this.world.showModeManager.broadcastAIInteraction('chat_opened');
                       }
                   } else {
                       if (!this.world.showModeManager || !this.world.showModeManager.isFollowing) {
                           document.getElementById('settings-panel').classList.add('active');
                           this.world.showNotification('Please configure your API key in the settings panel');
                       }
                   }
               });

               this.chatInput.addEventListener('keypress', (event) => {
                   if (event.key === 'Enter') {
                       if (this.world.showModeManager && this.world.showModeManager.isFollowing) {
                           this.sendViewerMessage();
                       } else {
                           this.sendMessage();
                       }
                   }
               });

               const sendButton = document.querySelector('.ai-chat-send');
               sendButton.onclick = () => {
                   if (this.world.showModeManager && this.world.showModeManager.isFollowing) {
                       this.sendViewerMessage();
                   } else {
                       this.sendMessage();
                   }
               };
           }

           sendViewerMessage() {
               const message = this.chatInput.value.trim();
               if (!message) return;

               this.addMessage(message, 'user');
               this.chatInput.value = '';

               if (this.world.showModeManager) {
                   this.world.showModeManager.sendViewerMessage(message);
               }
           }

           createAICompanion(isActive = false) {
               const companionGroup = new THREE.Group();

               const geometry = new THREE.SphereGeometry(1.5, 16, 16);
               const material = new THREE.MeshStandardMaterial({
                   color: isActive ? 0x06ffa5 : 0x666666,
                   emissive: isActive ? 0x06ffa5 : 0x666666,
                   emissiveIntensity: 0.5,
                   metalness: 0.8,
                   roughness: 0.2,
                   transparent: true,
                   opacity: 0.8
               });

               const orb = new THREE.Mesh(geometry, material);
               orb.position.y = 4;
               companionGroup.add(orb);

               orb.userData.clickable = true;
               orb.userData.isCompanion = true;

               const glowLight = new THREE.PointLight(isActive ? 0x06ffa5 : 0x666666, 2, 10);
               glowLight.position.y = 4;
               companionGroup.add(glowLight);

               const particleGeometry = new THREE.BufferGeometry();
               const particleCount = 50;
               const positions = new Float32Array(particleCount * 3);

               for (let i = 0; i < particleCount * 3; i += 3) {
                   const theta = Math.random() * Math.PI * 2;
                   const phi = Math.random() * Math.PI;
                   const radius = 2.5 + Math.random() * 1;

                   positions[i] = radius * Math.sin(phi) * Math.cos(theta);
                   positions[i + 1] = radius * Math.sin(phi) * Math.sin(theta) + 4;
                   positions[i + 2] = radius * Math.cos(phi);
               }

               particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

               const particleMaterial = new THREE.PointsMaterial({
                   color: isActive ? 0x8338ec : 0x444444,
                   size: 0.1,
                   transparent: true,
                   opacity: 0.6
               });

               const particles = new THREE.Points(particleGeometry, particleMaterial);
               companionGroup.add(particles);

               this.textContainer = new THREE.Group();
               this.textGroup = new THREE.Group();
               this.textContainer.add(this.textGroup);
               this.textContainer.position.y = 7;
               companionGroup.add(this.textContainer);

               this.persistentTextGroup = new THREE.Group();
               this.persistentTextGroup.position.y = 6.5;
               companionGroup.add(this.persistentTextGroup);

               if (!isActive) {
                   const loader = new THREE.FontLoader();
                   
                   if (window.AICompanion && window.AICompanion.fontData) {
                       const font = loader.parse(window.AICompanion.fontData);
                       this.createInactiveText(font, companionGroup);
                   } else {
                       loader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', (font) => {
                           this.createInactiveText(font, companionGroup);
                       });
                   }
               }

               companionGroup.position.set(0, 0, -WORLD_ATTRIBUTES.companionDistance);
               companionGroup.rotation.x = THREE.MathUtils.degToRad(-20);
               
               this.world.scene.add(companionGroup);

               this.companion = {
                   object: companionGroup,
                   orb: orb,
                   particles: particles,
                   light: glowLight
               };

               this.loadFont();
               this.animateCompanion();
           }

           createInactiveText(font, companionGroup) {
               const textGeometry = new THREE.TextGeometry('API Key Required', {
                   font: font,
                   size: 0.5,
                   height: 0.1,
                   curveSegments: 8,
                   bevelEnabled: true,
                   bevelThickness: 0.02,
                   bevelSize: 0.02,
                   bevelSegments: 4
               });

               textGeometry.center();

               const textMaterial = new THREE.MeshStandardMaterial({
                   color: 0xff6a00,
                   emissive: 0xff6a00,
                   emissiveIntensity: 0.3
               });

               this.inactiveText = new THREE.Mesh(textGeometry, textMaterial);
               this.inactiveText.position.y = 6;
               companionGroup.add(this.inactiveText);
           }

           loadFont() {
               const loader = new THREE.FontLoader();
               
               if (window.AICompanion && window.AICompanion.fontData) {
                   this.font = loader.parse(window.AICompanion.fontData);
               } else {
                   loader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', (font) => {
                       this.font = font;
                   });
               }
           }

           animateCompanion() {
               const animate = () => {
                   if (!this.companion) return;

                   const time = Date.now() * 0.001;

                   this.companion.orb.position.y = 4 + Math.sin(time * 2) * 0.3;
                   this.companion.particles.rotation.y = time * 0.5;
                   this.companion.light.intensity = 2 + Math.sin(time * 3) * 0.5;

                   if (this.textContainer) {
                       this.textContainer.lookAt(this.world.camera.position);
                   }
                   
                   if (this.persistentTextGroup) {
                       this.persistentTextGroup.lookAt(this.world.camera.position);
                   }

                   if (this.inactiveText) {
                       this.inactiveText.rotation.y = Math.sin(time) * 0.1;
                       this.inactiveText.position.y = 6 + Math.sin(time * 3) * 0.1;
                   }

                   if (this.isActive && this.companion && this.inactiveText) {
                       this.companion.orb.material.color.setHex(0x06ffa5);
                       this.companion.orb.material.emissive.setHex(0x06ffa5);
                       this.companion.light.color.setHex(0x06ffa5);
                       this.companion.object.remove(this.inactiveText);
                       this.inactiveText = null;
                   }

                   requestAnimationFrame(animate);
               };

               animate();
           }

           async sendToAPI(message) {
               const endpoint = this.world.settingsManager ? 
                   this.world.settingsManager.settings.api.endpoint : 
                   this.endpoint;
                   
               const headers = {
                   'Content-Type': 'application/json',
                   'x-functions-key': this.apiKey
               };

               const body = {
                   user_input: message,
                   conversation_history: this.conversationHistory
               };

               const response = await fetch(endpoint, {
                   method: 'POST',
                   headers: headers,
                   body: JSON.stringify(body)
               });

               if (!response.ok) {
                   throw new Error(`API request failed: ${response.status}`);
               }

               return await response.json();
           }

           detectToolRecommendation(text) {
               const lowerText = text.toLowerCase();
               const recommendations = [];

               for (const [repo, tools] of Object.entries(GITHUB_TOOLS)) {
                   for (const [key, tool] of Object.entries(tools)) {
                       const titleLower = tool.title.toLowerCase();
                       const descLower = tool.description.toLowerCase();
                       const keyLower = key.toLowerCase();
                       
                       // Check for tool mentions
                       if (lowerText.includes(titleLower) || 
                           lowerText.includes(keyLower) ||
                           (lowerText.includes('rainbow') && key === 'rainbow-svg-path') ||
                           (lowerText.includes('breath') && key === 'breathwork') ||
                           (lowerText.includes('fractal') && key === 'fractal-tree') ||
                           (lowerText.includes('mandala') && key === 'mandala-maker') ||
                           (lowerText.includes('particle') && key === 'particle-life') ||
                           (lowerText.includes('wave') && key === 'wave-interference') ||
                           (lowerText.includes('audio') && lowerText.includes('visual') && key === 'audio-visualizer') ||
                           (lowerText.includes('color') && (lowerText.includes('palette') || lowerText.includes('harmony')) && key === 'color-harmony')) {
                           
                           recommendations.push({
                               repo: repo,
                               key: key,
                               tool: tool,
                               url: `https://${repo.split('/')[0]}.github.io/${repo.split('/')[1]}/${tool.path}`
                           });
                       }
                   }
               }

               return recommendations;
           }

           createToolRecommendationElement(recommendation) {
               const div = document.createElement('div');
               div.className = 'tool-recommendation';
               div.innerHTML = `
                   <div class="tool-recommendation-header">
                       <span>${recommendation.tool.icon}</span>
                       <span>Tool Recommendation</span>
                   </div>
                   <div class="tool-recommendation-title">${recommendation.tool.title}</div>
                   <div class="tool-recommendation-description">${recommendation.tool.description}</div>
                   <div class="tool-recommendation-actions">
                       <button class="tool-action-btn" data-url="${recommendation.url}" data-tool='${JSON.stringify(recommendation)}'>
                           Open Here
                           <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                               <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                               <line x1="9" y1="9" x2="15" y2="15"></line>
                               <line x1="15" y1="9" x2="9" y2="15"></line>
                           </svg>
                       </button>
                       <button class="tool-action-btn secondary" onclick="window.open('${recommendation.url}', '_blank')">
                           New Tab
                           <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                               <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                               <polyline points="15 3 21 3 21 9"></polyline>
                               <line x1="10" y1="14" x2="21" y2="3"></line>
                           </svg>
                       </button>
                   </div>
               `;

               // Add event listener for open here button
               const openHereBtn = div.querySelector('.tool-action-btn[data-tool]');
               openHereBtn.addEventListener('click', () => {
                   const toolData = JSON.parse(openHereBtn.getAttribute('data-tool'));
                   this.world.toolManager.openTool({
                       url: toolData.url,
                       title: toolData.tool.title,
                       icon: toolData.tool.icon
                   });
               });

               return div;
           }

           async sendMessage() {
               const message = this.chatInput.value.trim();
               if (!message || !this.isActive) return;

               if (this.world.taskManager && this.world.taskManager.isReplaying) {
                   this.showNotification('Cannot send messages during conversation replay');
                   return;
               }

               this.addMessage(message, 'user');
               this.chatInput.value = '';

               if (this.world.showModeManager && this.world.showModeManager.isHost) {
                   this.world.showModeManager.broadcastAIInteraction('message_sent');
               }

               this.showTypingIndicator();

               this.conversationHistory.push({
                   role: 'user',
                   content: message
               });

               try {
                   // Add tool knowledge to the message
                   const enhancedMessage = message + this.toolKnowledge;
                   const response = await this.sendToAPI(enhancedMessage);

                   this.hideTypingIndicator();

                   if (response.assistant_response) {
                       // Check for tool recommendations in the response
                       const recommendations = this.detectToolRecommendation(response.assistant_response);
                       
                       // Add the AI message
                       this.addMessage(response.assistant_response, 'ai', response.voice_response);

                       // Add tool recommendations after the message
                       if (recommendations.length > 0) {
                           recommendations.forEach(rec => {
                               const recElement = this.createToolRecommendationElement(rec);
                               this.chatMessages.appendChild(recElement);
                           });
                           this.chatMessages.scrollTop = this.chatMessages.scrollHeight;
                       }

                       this.conversationHistory.push({
                           role: 'assistant',
                           content: response.assistant_response
                       });

                       if (response.voice_response) {
                           this.lastVoiceResponse = response.voice_response;
                           this.animateTextResponse(response.voice_response);
                           
                           if (this.settings.autoSpeak && !this.voicePaused) {
                               await this.voiceManager.speak(response.voice_response, this);
                               
                               if (this.settings.continuousConversation && this.voiceInputManager && !this.voicePaused) {
                                   setTimeout(() => {
                                       this.voiceInputManager.startListening();
                                   }, 500);
                               }
                           }
                       } else {
                           this.animateTextResponse(response.assistant_response);
                       }
                   }
               } catch (error) {
                   console.error('Failed to send message:', error);
                   this.hideTypingIndicator();
                   this.addMessage('Sorry, I encountered an error. Please try again.', 'ai');
               }
           }

           animateTextResponse(text) {
               if (this.activeTextAnimation) {
                   cancelAnimationFrame(this.activeTextAnimation);
                   this.activeTextAnimation = null;
               }

               this.textMeshes.forEach(mesh => {
                   if (mesh.geometry) mesh.geometry.dispose();
                   if (mesh.material) mesh.material.dispose();
                   this.textGroup.remove(mesh);
               });
               this.textMeshes = [];

               if (!this.font || !this.textGroup) return;

               const maxCharsPerLine = 40;
               const words = text.split(' ');
               const lines = [];
               let currentLine = '';

               words.forEach(word => {
                   if ((currentLine + word).length > maxCharsPerLine) {
                       if (currentLine) {
                           lines.push(currentLine.trim());
                           currentLine = '';
                       }
                   }
                   currentLine += word + ' ';
               });
               if (currentLine) {
                   lines.push(currentLine.trim());
               }

               const lineHeight = 0.8;
               const textMaterial = new THREE.MeshStandardMaterial({
                   color: 0xffffff,
                   emissive: 0x06ffa5,
                   emissiveIntensity: 0.5,
                   metalness: 0.5,
                   roughness: 0.3,
                   transparent: true,
                   opacity: 1
               });

               lines.forEach((line, index) => {
                   const textGeometry = new THREE.TextGeometry(line, {
                       font: this.font,
                       size: 0.4,
                       height: 0.05,
                       curveSegments: 8,
                       bevelEnabled: true,
                       bevelThickness: 0.01,
                       bevelSize: 0.01,
                       bevelSegments: 4
                   });

                   textGeometry.center();

                   const textMesh = new THREE.Mesh(textGeometry, textMaterial.clone());
                   textMesh.position.y = -index * lineHeight;
                   
                   this.textGroup.add(textMesh);
                   this.textMeshes.push(textMesh);
               });

               const totalHeight = lines.length * lineHeight;
               this.animateScrollingText(totalHeight, text);
           }

           animateScrollingText(totalHeight, fullText) {
               const scrollSpeed = 0.01;
               const startY = -3;
               const endY = totalHeight + 3;
               let currentY = startY;

               const animate = () => {
                   if (!this.textGroup || this.textMeshes.length === 0) return;

                   currentY += scrollSpeed;
                   this.textGroup.position.y = currentY;

                   if (currentY > endY) {
                       this.createPersistentText(fullText);
                       this.fadeOutText();
                       return;
                   }

                   this.textMeshes.forEach((mesh, index) => {
                       const meshWorldY = currentY - index * 0.8;
                       
                       if (meshWorldY < -1.5) {
                           mesh.material.opacity = Math.max(0, 1 + meshWorldY / 1.5);
                       }
                       else if (meshWorldY > 1.5) {
                           mesh.material.opacity = Math.max(0, 2 - meshWorldY / 1.5);
                       }
                       else {
                           mesh.material.opacity = 1;
                       }
                   });

                   this.activeTextAnimation = requestAnimationFrame(animate);
               };

               animate();
           }

           createPersistentText(text) {
               this.persistentTextGroup.children.forEach(child => {
                   if (child.geometry) child.geometry.dispose();
                   if (child.material) child.material.dispose();
               });
               this.persistentTextGroup.clear();

               if (!this.font) return;

               const maxLength = 100;
               const displayText = text.length > maxLength ? text.substring(0, maxLength) + '...' : text;
               
               const lines = [];
               const maxCharsPerLine = 35;
               const words = displayText.split(' ');
               let currentLine = '';

               words.forEach(word => {
                   if ((currentLine + word).length > maxCharsPerLine) {
                       if (currentLine) {
                           lines.push(currentLine.trim());
                           currentLine = '';
                       }
                   }
                   currentLine += word + ' ';
               });
               if (currentLine) {
                   lines.push(currentLine.trim());
               }

               const displayLines = lines.slice(0, 3);
               if (lines.length > 3) {
                   displayLines[2] = displayLines[2].substring(0, displayLines[2].length - 3) + '...';
               }

               const lineHeight = 0.6;
               const persistentMaterial = new THREE.MeshStandardMaterial({
                   color: 0xffffff,
                   emissive: 0x06ffa5,
                   emissiveIntensity: 0.2,
                   metalness: 0.3,
                   roughness: 0.5,
                   transparent: true,
                   opacity: 0.8
               });

               displayLines.forEach((line, index) => {
                   const textGeometry = new THREE.TextGeometry(line, {
                       font: this.font,
                       size: 0.3,
                       height: 0.03,
                       curveSegments: 6,
                       bevelEnabled: true,
                       bevelThickness: 0.01,
                       bevelSize: 0.01,
                       bevelSegments: 3
                   });

                   textGeometry.center();

                   const textMesh = new THREE.Mesh(textGeometry, persistentMaterial);
                   textMesh.position.y = -index * lineHeight;
                   
                   this.persistentTextGroup.add(textMesh);
               });

               this.persistentTextGroup.position.y = 6.5 + (displayLines.length * lineHeight) / 2;
           }

           fadeOutText() {
               let opacity = 1;
               const fadeSpeed = 0.02;
               const fade = () => {
                   opacity -= fadeSpeed;
                   
                   if (opacity <= 0) {
                       this.textMeshes.forEach(mesh => {
                           if (mesh.geometry) mesh.geometry.dispose();
                           if (mesh.material) mesh.material.dispose();
                           this.textGroup.remove(mesh);
                       });
                       this.textMeshes = [];
                       this.textGroup.position.y = 0;
                       return;
                   }

                   this.textMeshes.forEach(mesh => {
                       mesh.material.opacity = opacity;
                   });

                   requestAnimationFrame(fade);
               };

               fade();
           }

           animateCompanionSpeaking() {
               if (!this.companion) return;

               const originalScale = this.companion.orb.scale.x;
               let progress = 0;
               const animate = () => {
                   progress += 0.1;
                   if (progress > 1) return;

                   const scale = originalScale + Math.sin(progress * Math.PI) * 0.3;
                   this.companion.orb.scale.setScalar(scale);

                   this.companion.light.intensity = 3 + Math.sin(progress * Math.PI * 2) * 1;
                   this.companion.orb.material.emissiveIntensity = 0.5 + Math.sin(progress * Math.PI) * 0.3;

                   requestAnimationFrame(animate);
               };
               animate();
           }

           showTypingIndicator() {
               const typingDiv = document.createElement('div');
               typingDiv.className = 'ai-typing';
               typingDiv.id = 'ai-typing-indicator';
               typingDiv.innerHTML = `
                   <div class="typing-dot"></div>
                   <div class="typing-dot"></div>
                   <div class="typing-dot"></div>
               `;
               this.chatMessages.appendChild(typingDiv);
               this.chatMessages.scrollTop = this.chatMessages.scrollHeight;
               
               if (this.world.showModeManager && this.world.showModeManager.isHost) {
                   this.world.showModeManager.broadcastTypingIndicator(true);
               }
           }

           hideTypingIndicator() {
               const typingIndicator = document.getElementById('ai-typing-indicator');
               if (typingIndicator) {
                   typingIndicator.remove();
               }
               
               if (this.world.showModeManager && this.world.showModeManager.isHost) {
                   this.world.showModeManager.broadcastTypingIndicator(false);
               }
           }

           addMessage(text, sender, voiceResponse = null) {
               const messageDiv = document.createElement('div');
               messageDiv.className = `ai-message ${sender}`;
               
               if (sender === 'ai') {
                   messageDiv.innerHTML = this.markdownParser.parse(text);
               } else {
                   messageDiv.textContent = text;
               }

               this.chatMessages.appendChild(messageDiv);
               this.chatMessages.scrollTop = this.chatMessages.scrollHeight;
               
               if (this.world.showModeManager && this.world.showModeManager.isHost) {
                   this.world.showModeManager.broadcastChatMessage(sender, messageDiv.innerHTML, voiceResponse);
               }
           }

           showNotification(message) {
               const notification = document.createElement('div');
               notification.className = 'notification';
               notification.textContent = message;

               document.body.appendChild(notification);

               setTimeout(() => {
                   notification.style.animation = 'slideOut 0.3s ease';
                   setTimeout(() => notification.remove(), 300);
               }, 3000);
           }
       }

       // Add Font and TextGeometry support to THREE
       THREE.FontLoader = class FontLoader extends THREE.Loader {
           constructor(manager) {
               super(manager);
           }

           load(url, onLoad, onProgress, onError) {
               const scope = this;
               
               if (window.AICompanion && window.AICompanion.fontData) {
                   const font = scope.parse(window.AICompanion.fontData);
                   if (onLoad) onLoad(font);
                   return;
               }
               
               const loader = new THREE.FileLoader(this.manager);
               loader.setPath(this.path);
               loader.setRequestHeader(this.requestHeader);
               loader.setWithCredentials(this.withCredentials);
               loader.load(url, function(text) {
                   try {
                       const json = JSON.parse(text);
                       const font = scope.parse(json);
                       if (onLoad) onLoad(font);
                   } catch (e) {
                       if (onError) onError(e);
                   }
               }, onProgress, onError);
           }

           parse(json) {
               return new THREE.Font(json);
           }
       };

       THREE.Font = class Font {
           constructor(data) {
               this.type = 'Font';
               this.data = data;
           }

           generateShapes(text, size = 100) {
               const shapes = [];
               const paths = createPaths(text, size, this.data);

               for (let p = 0, pl = paths.length; p < pl; p++) {
                   Array.prototype.push.apply(shapes, paths[p].toShapes());
               }

               return shapes;
           }
       };

       THREE.TextGeometry = class TextGeometry extends THREE.ExtrudeGeometry {
           constructor(text, parameters = {}) {
               const font = parameters.font;

               if (!font || !font.data) {
                   console.error('THREE.TextGeometry: font parameter is not an instance of THREE.Font.');
                   super();
                   return;
               }

               const shapes = font.generateShapes(text, parameters.size);

               parameters.depth = parameters.height !== undefined ? parameters.height : 50;

               if (parameters.bevelThickness === undefined) parameters.bevelThickness = 10;
               if (parameters.bevelSize === undefined) parameters.bevelSize = 8;
               if (parameters.bevelEnabled === undefined) parameters.bevelEnabled = false;

               super(shapes, parameters);

               this.type = 'TextGeometry';
           }
       };

       function createPaths(text, size, data) {
           const chars = Array.from(text);
           const scale = size / data.resolution;
           const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;

           const paths = [];

           let offsetX = 0, offsetY = 0;

           for (let i = 0; i < chars.length; i++) {
               const char = chars[i];

               if (char === '\n') {
                   offsetX = 0;
                   offsetY -= line_height;
               } else {
                   const ret = createPath(char, scale, offsetX, offsetY, data);
                   if (ret) {
                       offsetX += ret.offsetX;
                       paths.push(ret.path);
                   }
               }
           }

           return paths;
       }

       function createPath(char, scale, offsetX, offsetY, data) {
           const glyph = data.glyphs[char] || data.glyphs['?'];

           if (!glyph) {
               console.error('THREE.Font: character "' + char + '" does not exists in font family ' + data.familyName + '.');
               return;
           }

           const path = new THREE.ShapePath();

           let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;

           if (glyph.o) {
               const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '));

               for (let i = 0, l = outline.length; i < l;) {
                   const action = outline[i++];

                   switch (action) {
                       case 'm':
                           x = outline[i++] * scale + offsetX;
                           y = outline[i++] * scale + offsetY;
                           path.moveTo(x, y);
                           break;

                       case 'l':
                           x = outline[i++] * scale + offsetX;
                           y = outline[i++] * scale + offsetY;
                           path.lineTo(x, y);
                           break;

                       case 'q':
                           cpx = outline[i++] * scale + offsetX;
                           cpy = outline[i++] * scale + offsetY;
                           cpx1 = outline[i++] * scale + offsetX;
                           cpy1 = outline[i++] * scale + offsetY;
                           path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
                           break;

                       case 'b':
                           cpx = outline[i++] * scale + offsetX;
                           cpy = outline[i++] * scale + offsetY;
                           cpx1 = outline[i++] * scale + offsetX;
                           cpy1 = outline[i++] * scale + offsetY;
                           cpx2 = outline[i++] * scale + offsetX;
                           cpy2 = outline[i++] * scale + offsetY;
                           path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
                           break;
                   }
               }
           }

           return { offsetX: glyph.ha * scale, path: path };
       }

       // World Navigator Class
       class WorldNavigator {
           constructor() {
               this.scene = null;
               this.camera = null;
               this.renderer = null;
               this.raycaster = new THREE.Raycaster();
               this.mouse = new THREE.Vector2();
               this.clock = new THREE.Clock();

               this.isMobile = isMobile;
               this.isIOS = isIOS;

               this.aiManager = null;
               this.taskManager = null;
               this.settingsManager = null;
               this.perspectiveManager = null;
               this.showModeManager = null;
               this.toolManager = null;

               this.tooltip = document.getElementById('companion-tooltip');

               if (this.isIOS) {
                   document.body.addEventListener('touchmove', (e) => {
                       if (e.target === document.body) {
                           e.preventDefault();
                       }
                   }, { passive: false });
               }
           }

           init() {
               this.setupScene();
               this.setupLighting();
               this.createEnvironment();
               this.setupEventListeners();

               // Initialize Settings Manager first
               this.settingsManager = new SettingsManager(this);

               // Initialize Perspective Manager
               this.perspectiveManager = new PerspectiveManager(this);

               // Initialize Show Mode Manager
               this.showModeManager = new ShowModeManager(this);

               // Initialize Tool Manager
               this.toolManager = new ToolManager(this);

               // Initialize AI manager
               this.aiManager = new AIManager(this);

               // Initialize Task Manager
               this.taskManager = new TaskManager(this);

               // Apply saved settings
               if (this.settingsManager.settings.perspective) {
                   this.perspectiveManager.applySettings(this.settingsManager.settings.perspective);
               }

               // Make WorldNavigator globally accessible
               window.worldNavigator = this;

               this.animate();
           }

           setupScene() {
               this.scene = new THREE.Scene();
               this.scene.fog = new THREE.Fog(WORLD_ATTRIBUTES.fogColor, WORLD_ATTRIBUTES.fogNear, WORLD_ATTRIBUTES.fogFar);

               this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
               this.camera.position.set(0, WORLD_ATTRIBUTES.cameraPositionY, WORLD_ATTRIBUTES.cameraPositionZ);
               this.camera.lookAt(0, 3, 0);

               this.renderer = new THREE.WebGLRenderer({ 
                   antialias: true, 
                   alpha: true,
                   powerPreference: "high-performance"
               });
               this.renderer.setSize(window.innerWidth, window.innerHeight);
               this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
               this.renderer.shadowMap.enabled = true;
               this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
               document.getElementById('three-container').appendChild(this.renderer.domElement);
           }

           setupLighting() {
               const ambientLight = new THREE.AmbientLight(WORLD_ATTRIBUTES.ambientColor, 0.6);
               this.scene.add(ambientLight);

               const dirLight = new THREE.DirectionalLight(0x8338ec, 0.8);
               dirLight.position.set(10, 20, 10);
               dirLight.castShadow = true;
               this.scene.add(dirLight);

               const spotLight = new THREE.SpotLight(0x06ffa5, 1, 30, Math.PI / 6, 0.5, 2);
               spotLight.position.set(0, 10, -5);
               spotLight.target.position.set(0, 0, -WORLD_ATTRIBUTES.companionDistance);
               this.scene.add(spotLight);
               this.scene.add(spotLight.target);
           }

           createEnvironment() {
               const groundGeometry = new THREE.PlaneGeometry(100, 100, 25, 25);
               const groundMaterial = new THREE.MeshStandardMaterial({
                   color: WORLD_ATTRIBUTES.groundColor,
                   roughness: 0.8,
                   metalness: 0.2,
                   wireframe: true,
                   transparent: true,
                   opacity: 0.3
               });

               const ground = new THREE.Mesh(groundGeometry, groundMaterial);
               ground.rotation.x = -Math.PI / 2;
               ground.receiveShadow = true;
               this.scene.add(ground);

               const solidGroundGeometry = new THREE.PlaneGeometry(100, 100);
               const solidGroundMaterial = new THREE.MeshStandardMaterial({
                   color: 0x0a0a0f,
                   roughness: 1,
                   metalness: 0
               });

               const solidGround = new THREE.Mesh(solidGroundGeometry, solidGroundMaterial);
               solidGround.rotation.x = -Math.PI / 2;
               solidGround.position.y = -0.1;
               this.scene.add(solidGround);

               const skyGeometry = new THREE.SphereGeometry(200, 16, 16);
               const skyMaterial = new THREE.MeshBasicMaterial({
                   color: WORLD_ATTRIBUTES.skyColor,
                   side: THREE.BackSide
               });
               const sky = new THREE.Mesh(skyGeometry, skyMaterial);
               this.scene.add(sky);

               const particleGeometry = new THREE.BufferGeometry();
               const particleCount = WORLD_ATTRIBUTES.particleCount;
               const positions = new Float32Array(particleCount * 3);
               const colors = new Float32Array(particleCount * 3);

               for (let i = 0; i < particleCount * 3; i += 3) {
                   positions[i] = (Math.random() - 0.5) * 80;
                   positions[i + 1] = Math.random() * 30 + 5;
                   positions[i + 2] = (Math.random() - 0.5) * 80;

                   colors[i] = Math.random() * 0.5 + 0.5;
                   colors[i + 1] = Math.random() * 0.5;
                   colors[i + 2] = Math.random() * 0.5 + 0.5;
               }

               particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
               particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

               const particleMaterial = new THREE.PointsMaterial({
                   size: 0.2,
                   transparent: true,
                   opacity: 0.8,
                   vertexColors: true,
                   blending: THREE.AdditiveBlending
               });

               const particles = new THREE.Points(particleGeometry, particleMaterial);
               this.scene.add(particles);
           }

           setupEventListeners() {
               window.addEventListener('resize', () => {
                   this.camera.aspect = window.innerWidth / window.innerHeight;
                   this.camera.updateProjectionMatrix();
                   this.renderer.setSize(window.innerWidth, window.innerHeight);
               });

               window.addEventListener('mousemove', (event) => {
                   this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                   this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                   
                   this.checkHover();
               });

               this.renderer.domElement.addEventListener('click', (event) => {
                   this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                   this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                   
                   this.checkClick();
               });

               if (this.isMobile) {
                   this.renderer.domElement.addEventListener('touchstart', (event) => {
                       const touch = event.touches[0];
                       this.mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
                       this.mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
                       
                       this.checkClick();
                   });
               }
           }

           checkHover() {
               if (this.showModeManager && this.showModeManager.isFollowing) {
                   return;
               }
               
               this.raycaster.setFromCamera(this.mouse, this.camera);
               const intersects = this.raycaster.intersectObjects(this.scene.children, true);

               let foundCompanion = false;

               for (const intersect of intersects) {
                   if (intersect.object.userData.isCompanion) {
                       foundCompanion = true;
                       this.renderer.domElement.style.cursor = 'pointer';
                       
                       const vector = new THREE.Vector3();
                       intersect.object.getWorldPosition(vector);
                       vector.project(this.camera);
                       
                       const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                       const y = (-(vector.y * 0.5) + 0.5) * window.innerHeight;
                       
                       this.tooltip.style.left = x + 'px';
                       this.tooltip.style.top = (y - 40) + 'px';
                       this.tooltip.classList.add('visible');
                       
                       break;
                   }
               }

               if (!foundCompanion) {
                   this.renderer.domElement.style.cursor = 'default';
                   this.tooltip.classList.remove('visible');
               }
           }

           checkClick() {
               if (this.showModeManager && this.showModeManager.isFollowing) {
                   return;
               }
               
               this.raycaster.setFromCamera(this.mouse, this.camera);
               const intersects = this.raycaster.intersectObjects(this.scene.children, true);

               for (const intersect of intersects) {
                   if (intersect.object.userData.isCompanion) {
                       if (this.aiManager.isActive) {
                           document.getElementById('ai-chat-interface').classList.add('active');
                           
                           if (this.showModeManager && this.showModeManager.isHost) {
                               this.showModeManager.broadcastAIInteraction('chat_opened');
                           }
                       } else {
                           document.getElementById('settings-panel').classList.add('active');
                       }
                       break;
                   }
               }
           }

           showNotification(message) {
               const notification = document.createElement('div');
               notification.className = 'notification';
               notification.textContent = message;

               document.body.appendChild(notification);

               setTimeout(() => {
                   notification.style.animation = 'slideOut 0.3s ease';
                   setTimeout(() => notification.remove(), 300);
               }, 3000);
           }

           animate() {
               requestAnimationFrame(() => this.animate());

               const time = this.clock.getElapsedTime();

               const particles = this.scene.getObjectByProperty('type', 'Points');
               if (particles) {
                   particles.rotation.y = time * 0.05;
                   particles.position.y = Math.sin(time * 0.2) * 2;
               }

               if (this.showModeManager) {
                   this.showModeManager.update();
               }

               this.renderer.render(this.scene, this.camera);
           }
       }

       // Main application initialization
       function initializeApplication() {
           const navigator = new WorldNavigator();
           navigator.init();
       }

       // Force load voices for speech synthesis
       if ('speechSynthesis' in window) {
           speechSynthesis.getVoices();
           window.speechSynthesis.onvoiceschanged = () => {
               speechSynthesis.getVoices();
           };
       }

       // iOS specific handling
       let lastY = 0;
       window.addEventListener('touchstart', (e) => {
           lastY = e.touches[0].clientY;
       }, { passive: true });

       window.addEventListener('touchmove', (e) => {
           const y = e.touches[0].clientY;
           const scrollingUp = y > lastY;
           const atTop = window.pageYOffset === 0;

           if (scrollingUp && atTop) {
               e.preventDefault();
           }
           lastY = y;
       }, { passive: false });
   </script>
</body>
</html>