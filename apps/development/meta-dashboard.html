<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Meta Analysis Dashboard - LocalFirstTools</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #0a0e27;
            --bg-secondary: #1a1f3a;
            --bg-tertiary: #2a2f4a;
            --accent-primary: #00d4ff;
            --accent-secondary: #7b2ff7;
            --accent-tertiary: #f72585;
            --text-primary: #ffffff;
            --text-secondary: #b8c5d6;
            --border-color: #3a3f5a;
            --success: #00ff88;
            --warning: #ffaa00;
            --error: #ff4444;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* Header */
        .header {
            background: rgba(26, 31, 58, 0.8);
            backdrop-filter: blur(10px);
            border-bottom: 2px solid var(--border-color);
            padding: 1.5rem 2rem;
            position: sticky;
            top: 0;
            z-index: 1000;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .header-content {
            max-width: 1600px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 2rem;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .logo-icon {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .logo-text h1 {
            font-size: 1.5rem;
            font-weight: 700;
            background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .stats-overview {
            display: flex;
            gap: 2rem;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: 700;
            background: linear-gradient(90deg, var(--accent-primary), var(--success));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .stat-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Tabs */
        .tabs-container {
            max-width: 1600px;
            margin: 2rem auto;
            padding: 0 2rem;
        }

        .tabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 2rem;
            overflow-x: auto;
            padding-bottom: 0.5rem;
        }

        .tab {
            padding: 1rem 1.5rem;
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
            font-weight: 600;
            position: relative;
            overflow: hidden;
        }

        .tab::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 212, 255, 0.2), transparent);
            transition: left 0.5s;
        }

        .tab:hover::before {
            left: 100%;
        }

        .tab:hover {
            border-color: var(--accent-primary);
            transform: translateY(-2px);
        }

        .tab.active {
            background: linear-gradient(135deg, var(--accent-secondary), var(--accent-primary));
            border-color: var(--accent-primary);
            box-shadow: 0 4px 20px rgba(0, 212, 255, 0.3);
        }

        /* Tab Content */
        .tab-content {
            display: none;
            animation: fadeIn 0.5s ease;
        }

        .tab-content.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Cards */
        .card {
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: 16px;
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
        }

        .card:hover {
            border-color: var(--accent-primary);
            box-shadow: 0 12px 48px rgba(0, 212, 255, 0.2);
        }

        .card-title {
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .card-title::before {
            content: '';
            width: 4px;
            height: 24px;
            background: linear-gradient(180deg, var(--accent-primary), var(--accent-secondary));
            border-radius: 2px;
        }

        /* Grid Layout */
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .grid-2 {
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
        }

        /* Search */
        .search-container {
            margin-bottom: 2rem;
        }

        .search-box {
            width: 100%;
            padding: 1rem 1.5rem;
            background: var(--bg-tertiary);
            border: 2px solid var(--border-color);
            border-radius: 12px;
            color: var(--text-primary);
            font-size: 1rem;
            transition: all 0.3s ease;
        }

        .search-box:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.3);
        }

        /* Filters */
        .filters {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            margin-bottom: 1.5rem;
        }

        .filter-btn {
            padding: 0.75rem 1.5rem;
            background: var(--bg-tertiary);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
        }

        .filter-btn:hover {
            border-color: var(--accent-primary);
            transform: translateY(-2px);
        }

        .filter-btn.active {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
            color: var(--bg-primary);
        }

        /* Charts */
        .chart-container {
            background: var(--bg-tertiary);
            border-radius: 12px;
            padding: 2rem;
            margin: 1.5rem 0;
            min-height: 300px;
        }

        .bar-chart {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .bar-item {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .bar-label {
            min-width: 150px;
            font-weight: 600;
            color: var(--text-secondary);
        }

        .bar-visual {
            flex: 1;
            height: 30px;
            background: var(--bg-secondary);
            border-radius: 8px;
            overflow: hidden;
            position: relative;
        }

        .bar-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-secondary), var(--accent-primary));
            border-radius: 8px;
            transition: width 1s ease;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding-right: 1rem;
            font-weight: 700;
            font-size: 0.875rem;
        }

        /* Pie Chart */
        .pie-chart {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 400px;
            position: relative;
        }

        .pie-chart svg {
            max-width: 400px;
            transform: rotate(-90deg);
        }

        .pie-legend {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            margin-top: 1.5rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }

        /* Graph Container */
        .graph-container {
            background: var(--bg-tertiary);
            border-radius: 12px;
            padding: 2rem;
            min-height: 600px;
            position: relative;
        }

        .graph-controls {
            display: flex;
            gap: 1rem;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
        }

        .graph-btn {
            padding: 0.75rem 1.5rem;
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
        }

        .graph-btn:hover {
            border-color: var(--accent-primary);
            background: var(--accent-primary);
            color: var(--bg-primary);
        }

        #graphCanvas {
            width: 100%;
            height: 500px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            background: var(--bg-primary);
            cursor: grab;
        }

        #graphCanvas:active {
            cursor: grabbing;
        }

        /* Node Details */
        .node-details {
            background: var(--bg-secondary);
            border: 2px solid var(--accent-primary);
            border-radius: 12px;
            padding: 1.5rem;
            margin-top: 1.5rem;
            display: none;
        }

        .node-details.visible {
            display: block;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateX(-20px); }
            to { opacity: 1; transform: translateX(0); }
        }

        /* Lists */
        .app-list {
            display: grid;
            gap: 1rem;
        }

        .app-item {
            background: var(--bg-tertiary);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .app-item:hover {
            border-color: var(--accent-primary);
            transform: translateX(5px);
        }

        .app-item-title {
            font-weight: 700;
            color: var(--accent-primary);
            margin-bottom: 0.5rem;
        }

        .app-item-meta {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .tag {
            background: var(--bg-secondary);
            padding: 0.25rem 0.75rem;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
            border: 1px solid var(--border-color);
        }

        .tag.category {
            background: var(--accent-secondary);
            color: white;
            border-color: var(--accent-secondary);
        }

        .tag.tech {
            background: var(--accent-primary);
            color: var(--bg-primary);
            border-color: var(--accent-primary);
        }

        /* Progress Bars */
        .progress-item {
            margin-bottom: 1.5rem;
        }

        .progress-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.5rem;
        }

        .progress-bar {
            height: 24px;
            background: var(--bg-secondary);
            border-radius: 12px;
            overflow: hidden;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-secondary), var(--accent-primary));
            border-radius: 12px;
            transition: width 1s ease;
            display: flex;
            align-items: center;
            padding-left: 1rem;
            font-weight: 700;
            font-size: 0.75rem;
        }

        /* Export Buttons */
        .export-controls {
            display: flex;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .export-btn {
            padding: 1rem 2rem;
            background: linear-gradient(135deg, var(--accent-secondary), var(--accent-primary));
            border: none;
            border-radius: 8px;
            color: white;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 212, 255, 0.3);
        }

        .export-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(0, 212, 255, 0.4);
        }

        /* Recommendations */
        .recommendation-card {
            background: linear-gradient(135deg, var(--bg-tertiary), var(--bg-secondary));
            border: 2px solid var(--accent-primary);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1rem;
        }

        .recommendation-title {
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--accent-primary);
            margin-bottom: 0.5rem;
        }

        .recommendation-apps {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-top: 1rem;
        }

        /* Heatmap */
        .heatmap {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 0.5rem;
        }

        .heatmap-cell {
            aspect-ratio: 1;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            font-weight: 700;
            transition: all 0.3s ease;
            cursor: pointer;
            padding: 0.5rem;
            text-align: center;
        }

        .heatmap-cell:hover {
            transform: scale(1.1);
            z-index: 10;
        }

        /* Loading */
        .loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 400px;
            gap: 1rem;
        }

        .spinner {
            width: 60px;
            height: 60px;
            border: 4px solid var(--border-color);
            border-top-color: var(--accent-primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Responsive */
        @media (max-width: 768px) {
            .header-content {
                flex-direction: column;
                gap: 1rem;
            }

            .stats-overview {
                width: 100%;
                justify-content: space-around;
            }

            .tabs {
                flex-wrap: nowrap;
                overflow-x: auto;
            }

            .grid, .grid-2 {
                grid-template-columns: 1fr;
            }

            .filters {
                flex-direction: column;
            }

            .export-controls {
                flex-direction: column;
            }
        }

        /* Tooltips */
        .tooltip {
            position: absolute;
            background: var(--bg-secondary);
            border: 2px solid var(--accent-primary);
            border-radius: 8px;
            padding: 0.75rem;
            pointer-events: none;
            z-index: 2000;
            display: none;
            max-width: 300px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .tooltip.visible {
            display: block;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="header">
        <div class="header-content">
            <div class="logo">
                <div class="logo-icon">üìä</div>
                <div class="logo-text">
                    <h1>Meta Analysis Dashboard</h1>
                    <p style="color: var(--text-secondary); font-size: 0.875rem;">LocalFirstTools Ecosystem</p>
                </div>
            </div>
            <div class="stats-overview" id="statsOverview">
                <div class="stat-item">
                    <div class="stat-value" id="totalApps">-</div>
                    <div class="stat-label">Total Apps</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="totalLines">-</div>
                    <div class="stat-label">Lines of Code</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="totalSize">-</div>
                    <div class="stat-label">Total Size</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Main Content -->
    <div class="tabs-container">
        <!-- Tabs -->
        <div class="tabs">
            <div class="tab active" data-tab="dependencies">üîó Dependency Graph</div>
            <div class="tab" data-tab="patterns">üéØ Pattern Analysis</div>
            <div class="tab" data-tab="gaps">üìà Category Gaps</div>
            <div class="tab" data-tab="search">üîç Cross-App Search</div>
            <div class="tab" data-tab="recommendations">üí° Recommendations</div>
            <div class="tab" data-tab="statistics">üìä Statistics</div>
            <div class="tab" data-tab="performance">‚ö° Performance</div>
        </div>

        <!-- Tab Content: Dependencies -->
        <div class="tab-content active" id="dependencies">
            <div class="card">
                <h2 class="card-title">Interactive Dependency Graph</h2>
                <p style="color: var(--text-secondary); margin-bottom: 1.5rem;">
                    Explore relationships between apps based on shared technologies and patterns. Click nodes for details.
                </p>
                <div class="graph-controls">
                    <button class="graph-btn" onclick="resetGraph()">Reset View</button>
                    <button class="graph-btn" onclick="togglePhysics()">Toggle Physics</button>
                    <select class="graph-btn" id="categoryFilter" onchange="filterByCategory()">
                        <option value="">All Categories</option>
                    </select>
                </div>
                <div class="graph-container">
                    <canvas id="graphCanvas"></canvas>
                </div>
                <div class="node-details" id="nodeDetails">
                    <h3 id="nodeTitle">Select a node</h3>
                    <div id="nodeInfo"></div>
                </div>
            </div>
        </div>

        <!-- Tab Content: Patterns -->
        <div class="tab-content" id="patterns">
            <div class="card">
                <h2 class="card-title">Common Patterns Distribution</h2>
                <div class="chart-container">
                    <div class="bar-chart" id="patternChart"></div>
                </div>
            </div>

            <div class="card">
                <h2 class="card-title">Technology Usage Heatmap</h2>
                <div id="technologyHeatmap" class="heatmap"></div>
            </div>

            <div class="card">
                <h2 class="card-title">Apps by Pattern</h2>
                <div class="filters" id="patternFilters"></div>
                <div class="app-list" id="patternAppList"></div>
            </div>
        </div>

        <!-- Tab Content: Gaps -->
        <div class="tab-content" id="gaps">
            <div class="card">
                <h2 class="card-title">Category Distribution Analysis</h2>
                <div class="chart-container">
                    <div class="pie-chart" id="categoryPieChart"></div>
                    <div class="pie-legend" id="categoryLegend"></div>
                </div>
            </div>

            <div class="card">
                <h2 class="card-title">Gap Analysis & Recommendations</h2>
                <div id="gapAnalysis"></div>
            </div>

            <div class="card">
                <h2 class="card-title">Suggested Apps to Build</h2>
                <div id="suggestedApps"></div>
            </div>
        </div>

        <!-- Tab Content: Search -->
        <div class="tab-content" id="search">
            <div class="card">
                <h2 class="card-title">Cross-App Search</h2>
                <div class="search-container">
                    <input type="text" class="search-box" id="searchInput"
                           placeholder="Search across all 180 apps by title, description, technology, or category...">
                </div>
                <div class="filters" id="searchFilters"></div>
                <div id="searchStats" style="color: var(--text-secondary); margin-bottom: 1rem;"></div>
                <div class="app-list" id="searchResults"></div>
            </div>
        </div>

        <!-- Tab Content: Recommendations -->
        <div class="tab-content" id="recommendations">
            <div class="card">
                <h2 class="card-title">Smart Recommendations</h2>
                <div id="recommendationsContent"></div>
            </div>

            <div class="card">
                <h2 class="card-title">Trending Apps</h2>
                <div id="trendingApps"></div>
            </div>

            <div class="card">
                <h2 class="card-title">Hidden Gems</h2>
                <p style="color: var(--text-secondary); margin-bottom: 1rem;">
                    High-quality apps that deserve more attention
                </p>
                <div id="hiddenGems"></div>
            </div>
        </div>

        <!-- Tab Content: Statistics -->
        <div class="tab-content" id="statistics">
            <div class="grid">
                <div class="card">
                    <h2 class="card-title">Overview Stats</h2>
                    <div id="overviewStats"></div>
                </div>
                <div class="card">
                    <h2 class="card-title">Technology Adoption</h2>
                    <div class="chart-container">
                        <div class="bar-chart" id="technologyChart"></div>
                    </div>
                </div>
            </div>

            <div class="card">
                <h2 class="card-title">Category Breakdown</h2>
                <div class="chart-container">
                    <div class="bar-chart" id="categoryChart"></div>
                </div>
            </div>

            <div class="card">
                <h2 class="card-title">Self-Contained vs External Dependencies</h2>
                <div class="chart-container">
                    <div class="pie-chart" id="dependencyPieChart"></div>
                    <div class="pie-legend" id="dependencyLegend"></div>
                </div>
            </div>

            <div class="export-controls">
                <button class="export-btn" onclick="exportJSON()">üì• Export Data (JSON)</button>
                <button class="export-btn" onclick="exportReport()">üìÑ Generate Report</button>
            </div>
        </div>

        <!-- Tab Content: Performance -->
        <div class="tab-content" id="performance">
            <div class="card">
                <h2 class="card-title">File Size Distribution</h2>
                <div id="sizeDistribution"></div>
            </div>

            <div class="card">
                <h2 class="card-title">Complexity Metrics</h2>
                <div class="chart-container">
                    <div class="bar-chart" id="complexityChart"></div>
                </div>
            </div>

            <div class="card">
                <h2 class="card-title">Load Time Estimates</h2>
                <div id="loadTimeEstimates"></div>
            </div>

            <div class="card">
                <h2 class="card-title">Optimization Suggestions</h2>
                <div id="optimizationSuggestions"></div>
            </div>
        </div>
    </div>

    <!-- Tooltip -->
    <div class="tooltip" id="tooltip"></div>

    <script>
        // Global data storage
        let metaData = null;
        let filteredApps = [];
        let graphData = { nodes: [], edges: [] };
        let graphState = {
            zoom: 1,
            offsetX: 0,
            offsetY: 0,
            isDragging: false,
            dragStart: { x: 0, y: 0 },
            physicsEnabled: true,
            selectedNode: null
        };

        // Initialize
        async function init() {
            try {
                const response = await fetch('/data/meta-analysis.json');
                metaData = await response.json();
                filteredApps = metaData.apps;

                updateHeaderStats();
                initializeTabs();
                initializeSearch();
                renderDependencyGraph();
                renderPatternAnalysis();
                renderGapAnalysis();
                renderRecommendations();
                renderStatistics();
                renderPerformanceMetrics();

            } catch (error) {
                console.error('Error loading data:', error);
                document.body.innerHTML = `
                    <div class="loading">
                        <div style="font-size: 3rem;">‚ö†Ô∏è</div>
                        <h2>Error Loading Data</h2>
                        <p style="color: var(--text-secondary);">Please ensure /data/meta-analysis.json exists</p>
                    </div>
                `;
            }
        }

        // Update header statistics
        function updateHeaderStats() {
            const totalApps = metaData.apps.length;
            const totalLines = metaData.apps.reduce((sum, app) => sum + app.lines_of_code, 0);
            const totalSize = metaData.apps.reduce((sum, app) => sum + app.file_size, 0);

            document.getElementById('totalApps').textContent = totalApps.toLocaleString();
            document.getElementById('totalLines').textContent = (totalLines / 1000).toFixed(1) + 'K';
            document.getElementById('totalSize').textContent = (totalSize / 1024 / 1024).toFixed(1) + 'MB';
        }

        // Tab Management
        function initializeTabs() {
            const tabs = document.querySelectorAll('.tab');
            const tabContents = document.querySelectorAll('.tab-content');

            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    const targetTab = tab.dataset.tab;

                    tabs.forEach(t => t.classList.remove('active'));
                    tabContents.forEach(tc => tc.classList.remove('active'));

                    tab.classList.add('active');
                    document.getElementById(targetTab).classList.add('active');
                });
            });
        }

        // Dependency Graph
        function renderDependencyGraph() {
            const canvas = document.getElementById('graphCanvas');
            const ctx = canvas.getContext('2d');

            // Set canvas size
            canvas.width = canvas.offsetWidth;
            canvas.height = 500;

            // Build graph data
            buildGraphData();

            // Populate category filter
            const categories = [...new Set(metaData.apps.map(app => app.category))];
            const categoryFilter = document.getElementById('categoryFilter');
            categories.forEach(cat => {
                const option = document.createElement('option');
                option.value = cat;
                option.textContent = cat.charAt(0).toUpperCase() + cat.slice(1);
                categoryFilter.appendChild(option);
            });

            // Draw graph
            drawGraph(ctx);

            // Setup interactions
            setupGraphInteractions(canvas);

            // Animation loop
            if (graphState.physicsEnabled) {
                requestAnimationFrame(() => animateGraph(ctx));
            }
        }

        function buildGraphData() {
            const apps = metaData.apps;
            const categoryColors = {
                'games': '#ff6b6b',
                'productivity': '#4ecdc4',
                'business': '#45b7d1',
                'development': '#96ceb4',
                'media': '#ffeaa7',
                'education': '#a29bfe',
                'ai-tools': '#fd79a8',
                'health': '#00b894',
                'utilities': '#fdcb6e',
                'other': '#74b9ff'
            };

            // Create nodes
            graphData.nodes = apps.slice(0, 50).map((app, i) => {
                const angle = (i / 50) * Math.PI * 2;
                const radius = 200;
                return {
                    id: i,
                    app: app,
                    x: 400 + Math.cos(angle) * radius,
                    y: 250 + Math.sin(angle) * radius,
                    vx: 0,
                    vy: 0,
                    color: categoryColors[app.category] || categoryColors.other,
                    radius: Math.max(5, Math.min(15, app.lines_of_code / 500))
                };
            });

            // Create edges based on shared technologies
            graphData.edges = [];
            for (let i = 0; i < graphData.nodes.length; i++) {
                for (let j = i + 1; j < graphData.nodes.length; j++) {
                    const node1 = graphData.nodes[i];
                    const node2 = graphData.nodes[j];
                    const shared = node1.app.technologies.filter(tech =>
                        node2.app.technologies.includes(tech)
                    );

                    if (shared.length > 0 || node1.app.category === node2.app.category) {
                        graphData.edges.push({
                            from: i,
                            to: j,
                            strength: shared.length + (node1.app.category === node2.app.category ? 0.5 : 0)
                        });
                    }
                }
            }
        }

        function drawGraph(ctx) {
            const canvas = ctx.canvas;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.save();
            ctx.translate(graphState.offsetX, graphState.offsetY);
            ctx.scale(graphState.zoom, graphState.zoom);

            // Draw edges
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            graphData.edges.forEach(edge => {
                const from = graphData.nodes[edge.from];
                const to = graphData.nodes[edge.to];
                ctx.beginPath();
                ctx.moveTo(from.x, from.y);
                ctx.lineTo(to.x, to.y);
                ctx.stroke();
            });

            // Draw nodes
            graphData.nodes.forEach(node => {
                ctx.fillStyle = node.color;
                ctx.beginPath();
                ctx.arc(node.x, node.y, node.radius, 0, Math.PI * 2);
                ctx.fill();

                if (graphState.selectedNode === node.id) {
                    ctx.strokeStyle = '#00d4ff';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }
            });

            ctx.restore();
        }

        function animateGraph(ctx) {
            if (!graphState.physicsEnabled) return;

            // Simple physics simulation
            const nodes = graphData.nodes;
            const edges = graphData.edges;

            // Repulsion between nodes
            for (let i = 0; i < nodes.length; i++) {
                for (let j = i + 1; j < nodes.length; j++) {
                    const node1 = nodes[i];
                    const node2 = nodes[j];
                    const dx = node2.x - node1.x;
                    const dy = node2.y - node1.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < 100) {
                        const force = (100 - distance) / 100 * 0.5;
                        const angle = Math.atan2(dy, dx);
                        node1.vx -= Math.cos(angle) * force;
                        node1.vy -= Math.sin(angle) * force;
                        node2.vx += Math.cos(angle) * force;
                        node2.vy += Math.sin(angle) * force;
                    }
                }
            }

            // Attraction along edges
            edges.forEach(edge => {
                const from = nodes[edge.from];
                const to = nodes[edge.to];
                const dx = to.x - from.x;
                const dy = to.y - from.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const force = (distance - 100) / 100 * 0.1 * edge.strength;
                const angle = Math.atan2(dy, dx);

                from.vx += Math.cos(angle) * force;
                from.vy += Math.sin(angle) * force;
                to.vx -= Math.cos(angle) * force;
                to.vy -= Math.sin(angle) * force;
            });

            // Update positions
            nodes.forEach(node => {
                node.x += node.vx;
                node.y += node.vy;
                node.vx *= 0.9; // Damping
                node.vy *= 0.9;
            });

            drawGraph(ctx);
            requestAnimationFrame(() => animateGraph(ctx));
        }

        function setupGraphInteractions(canvas) {
            canvas.addEventListener('mousedown', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = (e.clientX - rect.left - graphState.offsetX) / graphState.zoom;
                const y = (e.clientY - rect.top - graphState.offsetY) / graphState.zoom;

                // Check if clicking on a node
                let clickedNode = null;
                graphData.nodes.forEach((node, i) => {
                    const dx = x - node.x;
                    const dy = y - node.y;
                    if (Math.sqrt(dx * dx + dy * dy) < node.radius) {
                        clickedNode = i;
                    }
                });

                if (clickedNode !== null) {
                    graphState.selectedNode = clickedNode;
                    showNodeDetails(clickedNode);
                } else {
                    graphState.isDragging = true;
                    graphState.dragStart = { x: e.clientX, y: e.clientY };
                }

                drawGraph(canvas.getContext('2d'));
            });

            canvas.addEventListener('mousemove', (e) => {
                if (graphState.isDragging) {
                    graphState.offsetX += e.clientX - graphState.dragStart.x;
                    graphState.offsetY += e.clientY - graphState.dragStart.y;
                    graphState.dragStart = { x: e.clientX, y: e.clientY };
                    drawGraph(canvas.getContext('2d'));
                }
            });

            canvas.addEventListener('mouseup', () => {
                graphState.isDragging = false;
            });

            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                graphState.zoom *= delta;
                graphState.zoom = Math.max(0.1, Math.min(3, graphState.zoom));
                drawGraph(canvas.getContext('2d'));
            });
        }

        function showNodeDetails(nodeId) {
            const node = graphData.nodes[nodeId];
            const app = node.app;

            const detailsDiv = document.getElementById('nodeDetails');
            const titleDiv = document.getElementById('nodeTitle');
            const infoDiv = document.getElementById('nodeInfo');

            titleDiv.textContent = app.title || app.filename;
            infoDiv.innerHTML = `
                <p><strong>Category:</strong> ${app.category}</p>
                <p><strong>Lines of Code:</strong> ${app.lines_of_code.toLocaleString()}</p>
                <p><strong>File Size:</strong> ${(app.file_size / 1024).toFixed(1)} KB</p>
                <p><strong>Technologies:</strong> ${app.technologies.join(', ') || 'None'}</p>
                <p><strong>Import/Export:</strong> ${app.has_import_export ? 'Yes' : 'No'}</p>
                <p><strong>Self-Contained:</strong> ${app.is_self_contained ? 'Yes' : 'No'}</p>
                ${app.description ? `<p><strong>Description:</strong> ${app.description}</p>` : ''}
            `;

            detailsDiv.classList.add('visible');
        }

        function resetGraph() {
            graphState.zoom = 1;
            graphState.offsetX = 0;
            graphState.offsetY = 0;
            graphState.selectedNode = null;
            document.getElementById('nodeDetails').classList.remove('visible');
            drawGraph(document.getElementById('graphCanvas').getContext('2d'));
        }

        function togglePhysics() {
            graphState.physicsEnabled = !graphState.physicsEnabled;
            if (graphState.physicsEnabled) {
                animateGraph(document.getElementById('graphCanvas').getContext('2d'));
            }
        }

        function filterByCategory() {
            const category = document.getElementById('categoryFilter').value;
            // Rebuild graph with filtered apps
            if (category) {
                filteredApps = metaData.apps.filter(app => app.category === category);
            } else {
                filteredApps = metaData.apps;
            }
            buildGraphData();
            drawGraph(document.getElementById('graphCanvas').getContext('2d'));
        }

        // Pattern Analysis
        function renderPatternAnalysis() {
            const patterns = {
                'Import/Export': metaData.apps.filter(app => app.has_import_export).length,
                'JSON Storage': metaData.apps.filter(app => app.has_json_storage).length,
                '3D Graphics': metaData.apps.filter(app => app.has_3d).length,
                'Networking': metaData.apps.filter(app => app.has_networking).length,
                'Self-Contained': metaData.apps.filter(app => app.is_self_contained).length,
                'External Dependencies': metaData.apps.filter(app => !app.is_self_contained).length
            };

            const chartDiv = document.getElementById('patternChart');
            const maxValue = Math.max(...Object.values(patterns));

            chartDiv.innerHTML = '';
            Object.entries(patterns).forEach(([pattern, count]) => {
                const percentage = (count / metaData.apps.length * 100).toFixed(1);
                const barWidth = (count / maxValue * 100).toFixed(1);

                const barItem = document.createElement('div');
                barItem.className = 'bar-item';
                barItem.innerHTML = `
                    <div class="bar-label">${pattern}</div>
                    <div class="bar-visual">
                        <div class="bar-fill" style="width: ${barWidth}%">${count} (${percentage}%)</div>
                    </div>
                `;
                chartDiv.appendChild(barItem);
            });

            // Technology Heatmap
            renderTechnologyHeatmap();

            // Pattern Filters
            renderPatternFilters();
        }

        function renderTechnologyHeatmap() {
            const techCounts = {};
            metaData.apps.forEach(app => {
                app.technologies.forEach(tech => {
                    techCounts[tech] = (techCounts[tech] || 0) + 1;
                });
            });

            const sortedTechs = Object.entries(techCounts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 20);

            const heatmapDiv = document.getElementById('technologyHeatmap');
            const maxCount = sortedTechs[0]?.[1] || 1;

            heatmapDiv.innerHTML = '';
            sortedTechs.forEach(([tech, count]) => {
                const intensity = count / maxCount;
                const hue = 180 + (intensity * 60); // Blue to cyan gradient

                const cell = document.createElement('div');
                cell.className = 'heatmap-cell';
                cell.style.background = `hsl(${hue}, 70%, ${30 + intensity * 30}%)`;
                cell.innerHTML = `<div>${tech}</div><div style="font-size: 1.2rem; margin-top: 0.25rem;">${count}</div>`;
                cell.title = `${tech}: ${count} apps`;
                heatmapDiv.appendChild(cell);
            });
        }

        function renderPatternFilters() {
            const patterns = ['Import/Export', 'JSON Storage', '3D Graphics', 'Networking', 'Self-Contained'];
            const filtersDiv = document.getElementById('patternFilters');

            filtersDiv.innerHTML = '';
            patterns.forEach(pattern => {
                const btn = document.createElement('button');
                btn.className = 'filter-btn';
                btn.textContent = pattern;
                btn.onclick = () => filterByPattern(pattern, btn);
                filtersDiv.appendChild(btn);
            });

            // Show all apps initially
            updatePatternAppList(metaData.apps);
        }

        function filterByPattern(pattern, btn) {
            const buttons = document.querySelectorAll('#patternFilters .filter-btn');
            buttons.forEach(b => b.classList.remove('active'));
            btn.classList.add('active');

            let filtered = [];
            switch(pattern) {
                case 'Import/Export':
                    filtered = metaData.apps.filter(app => app.has_import_export);
                    break;
                case 'JSON Storage':
                    filtered = metaData.apps.filter(app => app.has_json_storage);
                    break;
                case '3D Graphics':
                    filtered = metaData.apps.filter(app => app.has_3d);
                    break;
                case 'Networking':
                    filtered = metaData.apps.filter(app => app.has_networking);
                    break;
                case 'Self-Contained':
                    filtered = metaData.apps.filter(app => app.is_self_contained);
                    break;
            }

            updatePatternAppList(filtered);
        }

        function updatePatternAppList(apps) {
            const listDiv = document.getElementById('patternAppList');
            listDiv.innerHTML = '';

            apps.slice(0, 20).forEach(app => {
                const item = document.createElement('div');
                item.className = 'app-item';
                item.innerHTML = `
                    <div class="app-item-title">${app.title || app.filename}</div>
                    <div class="app-item-meta">
                        <span class="tag category">${app.category}</span>
                        ${app.technologies.slice(0, 3).map(tech =>
                            `<span class="tag tech">${tech}</span>`
                        ).join('')}
                        <span>${(app.file_size / 1024).toFixed(1)} KB</span>
                        <span>${app.lines_of_code.toLocaleString()} lines</span>
                    </div>
                `;
                listDiv.appendChild(item);
            });

            if (apps.length > 20) {
                const moreDiv = document.createElement('div');
                moreDiv.style.cssText = 'text-align: center; color: var(--text-secondary); padding: 1rem;';
                moreDiv.textContent = `+ ${apps.length - 20} more apps`;
                listDiv.appendChild(moreDiv);
            }
        }

        // Gap Analysis
        function renderGapAnalysis() {
            const categoryCounts = {};
            metaData.apps.forEach(app => {
                categoryCounts[app.category] = (categoryCounts[app.category] || 0) + 1;
            });

            // Pie Chart
            renderCategoryPieChart(categoryCounts);

            // Gap Analysis
            const idealDistribution = {
                'productivity': 30,
                'development': 25,
                'utilities': 20,
                'business': 10,
                'games': 5,
                'media': 5,
                'education': 3,
                'health': 2
            };

            const gapsDiv = document.getElementById('gapAnalysis');
            gapsDiv.innerHTML = '';

            Object.entries(idealDistribution).forEach(([category, ideal]) => {
                const current = categoryCounts[category] || 0;
                const gap = ideal - current;
                const percentage = (current / metaData.apps.length * 100).toFixed(1);

                const progressDiv = document.createElement('div');
                progressDiv.className = 'progress-item';
                progressDiv.innerHTML = `
                    <div class="progress-header">
                        <span style="font-weight: 700; text-transform: capitalize;">${category}</span>
                        <span style="color: var(--text-secondary);">${current} apps (${percentage}%) - Target: ${ideal}</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: ${Math.min(100, current / ideal * 100)}%">
                            ${gap > 0 ? `Need ${gap} more` : 'Target met!'}
                        </div>
                    </div>
                `;
                gapsDiv.appendChild(progressDiv);
            });

            // Suggested Apps
            renderSuggestedApps();
        }

        function renderCategoryPieChart(categoryCounts) {
            const total = Object.values(categoryCounts).reduce((a, b) => a + b, 0);
            const colors = [
                '#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ffeaa7',
                '#a29bfe', '#fd79a8', '#00b894', '#fdcb6e', '#74b9ff'
            ];

            const chartDiv = document.getElementById('categoryPieChart');
            const legendDiv = document.getElementById('categoryLegend');

            let svg = '<svg viewBox="0 0 400 400" style="max-width: 400px;">';
            let currentAngle = 0;

            const sortedCategories = Object.entries(categoryCounts).sort((a, b) => b[1] - a[1]);

            sortedCategories.forEach(([category, count], i) => {
                const percentage = count / total;
                const angle = percentage * 360;
                const x1 = 200 + 180 * Math.cos((currentAngle - 90) * Math.PI / 180);
                const y1 = 200 + 180 * Math.sin((currentAngle - 90) * Math.PI / 180);
                const x2 = 200 + 180 * Math.cos((currentAngle + angle - 90) * Math.PI / 180);
                const y2 = 200 + 180 * Math.sin((currentAngle + angle - 90) * Math.PI / 180);
                const largeArc = angle > 180 ? 1 : 0;

                svg += `<path d="M 200 200 L ${x1} ${y1} A 180 180 0 ${largeArc} 1 ${x2} ${y2} Z"
                       fill="${colors[i % colors.length]}"
                       stroke="var(--bg-primary)"
                       stroke-width="2"/>`;

                currentAngle += angle;
            });

            svg += '</svg>';
            chartDiv.innerHTML = svg;

            // Legend
            legendDiv.innerHTML = '';
            sortedCategories.forEach(([category, count], i) => {
                const percentage = (count / total * 100).toFixed(1);
                const item = document.createElement('div');
                item.className = 'legend-item';
                item.innerHTML = `
                    <div class="legend-color" style="background: ${colors[i % colors.length]}"></div>
                    <span style="text-transform: capitalize; font-weight: 600;">${category}</span>
                    <span style="color: var(--text-secondary);">${count} apps (${percentage}%)</span>
                `;
                legendDiv.appendChild(item);
            });
        }

        function renderSuggestedApps() {
            const suggestions = [
                {
                    title: 'Team Collaboration Hub',
                    category: 'productivity',
                    reason: 'Missing real-time collaboration tools',
                    priority: 'High'
                },
                {
                    title: 'Code Snippet Manager',
                    category: 'development',
                    reason: 'Developers need better snippet organization',
                    priority: 'High'
                },
                {
                    title: 'Financial Dashboard',
                    category: 'business',
                    reason: 'Gap in financial tracking tools',
                    priority: 'Medium'
                },
                {
                    title: 'Habit Tracker',
                    category: 'health',
                    reason: 'Growing demand for wellness apps',
                    priority: 'Medium'
                },
                {
                    title: 'Language Learning Tool',
                    category: 'education',
                    reason: 'Educational category needs expansion',
                    priority: 'Low'
                }
            ];

            const suggestedDiv = document.getElementById('suggestedApps');
            suggestedDiv.innerHTML = '';

            suggestions.forEach(suggestion => {
                const card = document.createElement('div');
                card.className = 'recommendation-card';
                card.innerHTML = `
                    <div class="recommendation-title">${suggestion.title}</div>
                    <p style="color: var(--text-secondary); margin: 0.5rem 0;">
                        ${suggestion.reason}
                    </p>
                    <div style="display: flex; gap: 0.5rem; margin-top: 1rem;">
                        <span class="tag category">${suggestion.category}</span>
                        <span class="tag" style="background: ${
                            suggestion.priority === 'High' ? 'var(--error)' :
                            suggestion.priority === 'Medium' ? 'var(--warning)' :
                            'var(--success)'
                        }; color: white;">Priority: ${suggestion.priority}</span>
                    </div>
                `;
                suggestedDiv.appendChild(card);
            });
        }

        // Search Functionality
        function initializeSearch() {
            const searchInput = document.getElementById('searchInput');
            const searchResults = document.getElementById('searchResults');
            const searchStats = document.getElementById('searchStats');

            searchInput.addEventListener('input', (e) => {
                const query = e.target.value.toLowerCase();

                if (query.length === 0) {
                    searchResults.innerHTML = '';
                    searchStats.textContent = '';
                    return;
                }

                const results = metaData.apps.filter(app => {
                    return (
                        (app.title && app.title.toLowerCase().includes(query)) ||
                        (app.description && app.description.toLowerCase().includes(query)) ||
                        app.category.toLowerCase().includes(query) ||
                        app.technologies.some(tech => tech.toLowerCase().includes(query)) ||
                        app.filename.toLowerCase().includes(query)
                    );
                });

                searchStats.textContent = `Found ${results.length} apps matching "${query}"`;

                searchResults.innerHTML = '';
                results.slice(0, 50).forEach(app => {
                    const item = document.createElement('div');
                    item.className = 'app-item';
                    item.innerHTML = `
                        <div class="app-item-title">${highlightText(app.title || app.filename, query)}</div>
                        ${app.description ? `<p style="color: var(--text-secondary); margin: 0.5rem 0;">${highlightText(app.description, query)}</p>` : ''}
                        <div class="app-item-meta">
                            <span class="tag category">${app.category}</span>
                            ${app.technologies.slice(0, 3).map(tech =>
                                `<span class="tag tech">${highlightText(tech, query)}</span>`
                            ).join('')}
                            <span>${(app.file_size / 1024).toFixed(1)} KB</span>
                            <span>${app.lines_of_code.toLocaleString()} lines</span>
                        </div>
                    `;
                    searchResults.appendChild(item);
                });

                if (results.length > 50) {
                    const moreDiv = document.createElement('div');
                    moreDiv.style.cssText = 'text-align: center; color: var(--text-secondary); padding: 1rem;';
                    moreDiv.textContent = `+ ${results.length - 50} more results`;
                    searchResults.appendChild(moreDiv);
                }
            });

            // Search Filters
            renderSearchFilters();
        }

        function highlightText(text, query) {
            if (!text) return '';
            const regex = new RegExp(`(${query})`, 'gi');
            return text.replace(regex, '<span style="background: var(--accent-primary); color: var(--bg-primary); padding: 2px 4px; border-radius: 3px;">$1</span>');
        }

        function renderSearchFilters() {
            const categories = [...new Set(metaData.apps.map(app => app.category))];
            const filtersDiv = document.getElementById('searchFilters');

            filtersDiv.innerHTML = '<button class="filter-btn active" onclick="filterSearch(\'\', this)">All</button>';
            categories.forEach(category => {
                const btn = document.createElement('button');
                btn.className = 'filter-btn';
                btn.textContent = category.charAt(0).toUpperCase() + category.slice(1);
                btn.onclick = () => filterSearch(category, btn);
                filtersDiv.appendChild(btn);
            });
        }

        function filterSearch(category, btn) {
            const buttons = document.querySelectorAll('#searchFilters .filter-btn');
            buttons.forEach(b => b.classList.remove('active'));
            btn.classList.add('active');

            // Trigger search with current query
            const searchInput = document.getElementById('searchInput');
            searchInput.dispatchEvent(new Event('input'));
        }

        // Recommendations
        function renderRecommendations() {
            const recommendationsDiv = document.getElementById('recommendationsContent');

            // Simulate "if you liked X, try Y" recommendations
            const recommendations = [
                {
                    title: 'For Task Management Fans',
                    apps: metaData.apps.filter(app =>
                        app.category === 'productivity' && app.has_import_export
                    ).slice(0, 5)
                },
                {
                    title: 'For 3D Enthusiasts',
                    apps: metaData.apps.filter(app => app.has_3d).slice(0, 5)
                },
                {
                    title: 'For Developers',
                    apps: metaData.apps.filter(app => app.category === 'development').slice(0, 5)
                },
                {
                    title: 'Networking Enabled Apps',
                    apps: metaData.apps.filter(app => app.has_networking).slice(0, 5)
                }
            ];

            recommendationsDiv.innerHTML = '';
            recommendations.forEach(rec => {
                if (rec.apps.length > 0) {
                    const card = document.createElement('div');
                    card.className = 'recommendation-card';
                    card.innerHTML = `
                        <div class="recommendation-title">${rec.title}</div>
                        <div class="recommendation-apps">
                            ${rec.apps.map(app =>
                                `<span class="tag">${app.title || app.filename}</span>`
                            ).join('')}
                        </div>
                    `;
                    recommendationsDiv.appendChild(card);
                }
            });

            // Trending Apps (largest apps)
            renderTrendingApps();

            // Hidden Gems (high quality, small apps)
            renderHiddenGems();
        }

        function renderTrendingApps() {
            const trending = [...metaData.apps]
                .sort((a, b) => b.lines_of_code - a.lines_of_code)
                .slice(0, 10);

            const trendingDiv = document.getElementById('trendingApps');
            trendingDiv.innerHTML = '';

            trending.forEach((app, i) => {
                const item = document.createElement('div');
                item.className = 'app-item';
                item.innerHTML = `
                    <div style="display: flex; gap: 1rem; align-items: center;">
                        <div style="font-size: 1.5rem; font-weight: 700; color: var(--accent-primary); min-width: 30px;">
                            #${i + 1}
                        </div>
                        <div style="flex: 1;">
                            <div class="app-item-title">${app.title || app.filename}</div>
                            <div class="app-item-meta">
                                <span class="tag category">${app.category}</span>
                                <span>${app.lines_of_code.toLocaleString()} lines</span>
                                <span>${(app.file_size / 1024).toFixed(1)} KB</span>
                            </div>
                        </div>
                    </div>
                `;
                trendingDiv.appendChild(item);
            });
        }

        function renderHiddenGems() {
            const gems = metaData.apps.filter(app =>
                app.is_self_contained &&
                app.has_import_export &&
                app.lines_of_code > 100 &&
                app.lines_of_code < 1000 &&
                app.technologies.length > 0
            ).slice(0, 10);

            const gemsDiv = document.getElementById('hiddenGems');
            gemsDiv.innerHTML = '';

            gems.forEach(app => {
                const item = document.createElement('div');
                item.className = 'app-item';
                item.innerHTML = `
                    <div class="app-item-title">üíé ${app.title || app.filename}</div>
                    <p style="color: var(--text-secondary); margin: 0.5rem 0;">
                        Quality self-contained app with ${app.technologies.length} technologies
                    </p>
                    <div class="app-item-meta">
                        <span class="tag category">${app.category}</span>
                        ${app.technologies.slice(0, 2).map(tech =>
                            `<span class="tag tech">${tech}</span>`
                        ).join('')}
                        <span>${app.lines_of_code.toLocaleString()} lines</span>
                    </div>
                `;
                gemsDiv.appendChild(item);
            });
        }

        // Statistics
        function renderStatistics() {
            // Overview Stats
            const overviewDiv = document.getElementById('overviewStats');
            const stats = {
                'Total Apps': metaData.apps.length,
                'Total Lines of Code': metaData.apps.reduce((sum, app) => sum + app.lines_of_code, 0).toLocaleString(),
                'Total Size': (metaData.apps.reduce((sum, app) => sum + app.file_size, 0) / 1024 / 1024).toFixed(2) + ' MB',
                'Average Lines per App': Math.round(metaData.apps.reduce((sum, app) => sum + app.lines_of_code, 0) / metaData.apps.length),
                'Self-Contained Apps': metaData.apps.filter(app => app.is_self_contained).length,
                'Apps with Import/Export': metaData.apps.filter(app => app.has_import_export).length,
                '3D-Enabled Apps': metaData.apps.filter(app => app.has_3d).length,
                'Networked Apps': metaData.apps.filter(app => app.has_networking).length
            };

            overviewDiv.innerHTML = '';
            Object.entries(stats).forEach(([label, value]) => {
                const statDiv = document.createElement('div');
                statDiv.style.cssText = 'padding: 1rem; background: var(--bg-tertiary); border-radius: 8px; margin-bottom: 1rem;';
                statDiv.innerHTML = `
                    <div style="font-size: 0.875rem; color: var(--text-secondary); margin-bottom: 0.25rem;">${label}</div>
                    <div style="font-size: 1.5rem; font-weight: 700; color: var(--accent-primary);">${value}</div>
                `;
                overviewDiv.appendChild(statDiv);
            });

            // Technology Chart
            renderTechnologyChart();

            // Category Chart
            renderCategoryChart();

            // Dependency Pie Chart
            renderDependencyPieChart();
        }

        function renderTechnologyChart() {
            const techCounts = {};
            metaData.apps.forEach(app => {
                app.technologies.forEach(tech => {
                    techCounts[tech] = (techCounts[tech] || 0) + 1;
                });
            });

            const sortedTechs = Object.entries(techCounts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 15);

            const chartDiv = document.getElementById('technologyChart');
            const maxValue = sortedTechs[0]?.[1] || 1;

            chartDiv.innerHTML = '';
            sortedTechs.forEach(([tech, count]) => {
                const barWidth = (count / maxValue * 100).toFixed(1);
                const barItem = document.createElement('div');
                barItem.className = 'bar-item';
                barItem.innerHTML = `
                    <div class="bar-label">${tech}</div>
                    <div class="bar-visual">
                        <div class="bar-fill" style="width: ${barWidth}%">${count} apps</div>
                    </div>
                `;
                chartDiv.appendChild(barItem);
            });
        }

        function renderCategoryChart() {
            const categoryCounts = {};
            metaData.apps.forEach(app => {
                categoryCounts[app.category] = (categoryCounts[app.category] || 0) + 1;
            });

            const sortedCategories = Object.entries(categoryCounts).sort((a, b) => b[1] - a[1]);
            const chartDiv = document.getElementById('categoryChart');
            const maxValue = sortedCategories[0]?.[1] || 1;

            chartDiv.innerHTML = '';
            sortedCategories.forEach(([category, count]) => {
                const percentage = (count / metaData.apps.length * 100).toFixed(1);
                const barWidth = (count / maxValue * 100).toFixed(1);
                const barItem = document.createElement('div');
                barItem.className = 'bar-item';
                barItem.innerHTML = `
                    <div class="bar-label" style="text-transform: capitalize;">${category}</div>
                    <div class="bar-visual">
                        <div class="bar-fill" style="width: ${barWidth}%">${count} apps (${percentage}%)</div>
                    </div>
                `;
                chartDiv.appendChild(barItem);
            });
        }

        function renderDependencyPieChart() {
            const selfContained = metaData.apps.filter(app => app.is_self_contained).length;
            const external = metaData.apps.length - selfContained;

            const chartDiv = document.getElementById('dependencyPieChart');
            const legendDiv = document.getElementById('dependencyLegend');

            const total = metaData.apps.length;
            const selfPercentage = (selfContained / total * 100).toFixed(1);
            const externalPercentage = (external / total * 100).toFixed(1);

            chartDiv.innerHTML = `
                <svg viewBox="0 0 400 400" style="max-width: 400px;">
                    <circle cx="200" cy="200" r="180" fill="var(--success)" />
                    <path d="M 200 200 L 200 20 A 180 180 0 ${external > selfContained ? 1 : 0} 1
                             ${200 + 180 * Math.cos((externalPercentage / 100 * 360 - 90) * Math.PI / 180)}
                             ${200 + 180 * Math.sin((externalPercentage / 100 * 360 - 90) * Math.PI / 180)} Z"
                          fill="var(--error)" />
                </svg>
            `;

            legendDiv.innerHTML = `
                <div class="legend-item">
                    <div class="legend-color" style="background: var(--success)"></div>
                    <span style="font-weight: 600;">Self-Contained</span>
                    <span style="color: var(--text-secondary);">${selfContained} apps (${selfPercentage}%)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: var(--error)"></div>
                    <span style="font-weight: 600;">External Dependencies</span>
                    <span style="color: var(--text-secondary);">${external} apps (${externalPercentage}%)</span>
                </div>
            `;
        }

        // Performance Metrics
        function renderPerformanceMetrics() {
            renderSizeDistribution();
            renderComplexityMetrics();
            renderLoadTimeEstimates();
            renderOptimizationSuggestions();
        }

        function renderSizeDistribution() {
            const ranges = {
                '< 10 KB': 0,
                '10-50 KB': 0,
                '50-100 KB': 0,
                '100-500 KB': 0,
                '> 500 KB': 0
            };

            metaData.apps.forEach(app => {
                const sizeKB = app.file_size / 1024;
                if (sizeKB < 10) ranges['< 10 KB']++;
                else if (sizeKB < 50) ranges['10-50 KB']++;
                else if (sizeKB < 100) ranges['50-100 KB']++;
                else if (sizeKB < 500) ranges['100-500 KB']++;
                else ranges['> 500 KB']++;
            });

            const distDiv = document.getElementById('sizeDistribution');
            distDiv.innerHTML = '<div class="bar-chart"></div>';
            const chartDiv = distDiv.querySelector('.bar-chart');

            const maxValue = Math.max(...Object.values(ranges));

            Object.entries(ranges).forEach(([range, count]) => {
                const percentage = (count / metaData.apps.length * 100).toFixed(1);
                const barWidth = (count / maxValue * 100).toFixed(1);
                const barItem = document.createElement('div');
                barItem.className = 'bar-item';
                barItem.innerHTML = `
                    <div class="bar-label">${range}</div>
                    <div class="bar-visual">
                        <div class="bar-fill" style="width: ${barWidth}%">${count} apps (${percentage}%)</div>
                    </div>
                `;
                chartDiv.appendChild(barItem);
            });
        }

        function renderComplexityMetrics() {
            const apps = [...metaData.apps].sort((a, b) => b.lines_of_code - a.lines_of_code).slice(0, 10);

            const chartDiv = document.getElementById('complexityChart');
            const maxValue = apps[0].lines_of_code;

            chartDiv.innerHTML = '';
            apps.forEach(app => {
                const barWidth = (app.lines_of_code / maxValue * 100).toFixed(1);
                const barItem = document.createElement('div');
                barItem.className = 'bar-item';
                barItem.innerHTML = `
                    <div class="bar-label" style="max-width: 200px; overflow: hidden; text-overflow: ellipsis;">
                        ${app.title || app.filename}
                    </div>
                    <div class="bar-visual">
                        <div class="bar-fill" style="width: ${barWidth}%">
                            ${app.lines_of_code.toLocaleString()} lines
                        </div>
                    </div>
                `;
                chartDiv.appendChild(barItem);
            });
        }

        function renderLoadTimeEstimates() {
            // Estimate load times based on file size (assuming 1MB/s connection)
            const estimates = metaData.apps.map(app => ({
                app: app,
                loadTime: app.file_size / 1024 / 1024 // seconds
            })).sort((a, b) => b.loadTime - a.loadTime).slice(0, 10);

            const estimatesDiv = document.getElementById('loadTimeEstimates');
            estimatesDiv.innerHTML = '<div class="bar-chart"></div>';
            const chartDiv = estimatesDiv.querySelector('.bar-chart');

            const maxValue = estimates[0].loadTime;

            estimates.forEach(({ app, loadTime }) => {
                const barWidth = (loadTime / maxValue * 100).toFixed(1);
                const timeStr = loadTime < 1 ?
                    `${(loadTime * 1000).toFixed(0)}ms` :
                    `${loadTime.toFixed(2)}s`;

                const barItem = document.createElement('div');
                barItem.className = 'bar-item';
                barItem.innerHTML = `
                    <div class="bar-label" style="max-width: 200px; overflow: hidden; text-overflow: ellipsis;">
                        ${app.title || app.filename}
                    </div>
                    <div class="bar-visual">
                        <div class="bar-fill" style="width: ${barWidth}%">${timeStr}</div>
                    </div>
                `;
                chartDiv.appendChild(barItem);
            });
        }

        function renderOptimizationSuggestions() {
            const suggestions = [];

            // Find apps with external dependencies
            const externalDeps = metaData.apps.filter(app => !app.is_self_contained);
            if (externalDeps.length > 0) {
                suggestions.push({
                    title: 'Inline External Dependencies',
                    description: `${externalDeps.length} apps have external dependencies that could be inlined for better offline support.`,
                    priority: 'High',
                    apps: externalDeps.slice(0, 5)
                });
            }

            // Find large apps without compression
            const largeApps = metaData.apps.filter(app => app.file_size > 500 * 1024);
            if (largeApps.length > 0) {
                suggestions.push({
                    title: 'Consider Code Minification',
                    description: `${largeApps.length} apps are over 500KB and could benefit from minification.`,
                    priority: 'Medium',
                    apps: largeApps.slice(0, 5)
                });
            }

            // Apps missing import/export
            const noImportExport = metaData.apps.filter(app => !app.has_import_export && app.has_json_storage);
            if (noImportExport.length > 0) {
                suggestions.push({
                    title: 'Add Import/Export Functionality',
                    description: `${noImportExport.length} apps use storage but lack import/export features.`,
                    priority: 'Medium',
                    apps: noImportExport.slice(0, 5)
                });
            }

            const suggestionsDiv = document.getElementById('optimizationSuggestions');
            suggestionsDiv.innerHTML = '';

            suggestions.forEach(suggestion => {
                const card = document.createElement('div');
                card.className = 'recommendation-card';
                card.innerHTML = `
                    <div class="recommendation-title">${suggestion.title}</div>
                    <p style="color: var(--text-secondary); margin: 0.5rem 0 1rem 0;">
                        ${suggestion.description}
                    </p>
                    <div style="margin-bottom: 0.5rem;">
                        <span class="tag" style="background: ${
                            suggestion.priority === 'High' ? 'var(--error)' : 'var(--warning)'
                        }; color: white;">Priority: ${suggestion.priority}</span>
                    </div>
                    <div style="font-size: 0.875rem; color: var(--text-secondary);">
                        Examples: ${suggestion.apps.map(app => app.title || app.filename).join(', ')}
                    </div>
                `;
                suggestionsDiv.appendChild(card);
            });
        }

        // Export Functions
        function exportJSON() {
            const dataStr = JSON.stringify(metaData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `meta-analysis-export-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);
        }

        function exportReport() {
            const report = {
                generated: new Date().toISOString(),
                summary: {
                    total_apps: metaData.apps.length,
                    total_lines: metaData.apps.reduce((sum, app) => sum + app.lines_of_code, 0),
                    total_size: metaData.apps.reduce((sum, app) => sum + app.file_size, 0),
                    self_contained: metaData.apps.filter(app => app.is_self_contained).length,
                    with_import_export: metaData.apps.filter(app => app.has_import_export).length,
                    with_3d: metaData.apps.filter(app => app.has_3d).length,
                    with_networking: metaData.apps.filter(app => app.has_networking).length
                },
                categories: {},
                technologies: {},
                top_apps_by_size: metaData.apps
                    .sort((a, b) => b.lines_of_code - a.lines_of_code)
                    .slice(0, 10)
                    .map(app => ({
                        title: app.title || app.filename,
                        category: app.category,
                        lines: app.lines_of_code,
                        size: app.file_size
                    }))
            };

            // Count categories
            metaData.apps.forEach(app => {
                report.categories[app.category] = (report.categories[app.category] || 0) + 1;
                app.technologies.forEach(tech => {
                    report.technologies[tech] = (report.technologies[tech] || 0) + 1;
                });
            });

            const reportStr = JSON.stringify(report, null, 2);
            const reportBlob = new Blob([reportStr], { type: 'application/json' });
            const url = URL.createObjectURL(reportBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `meta-analysis-report-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);
        }

        // Initialize on load
        window.addEventListener('load', init);
    </script>
</body>
</html>
