<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visual Programming IDE</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1e1e1e;
            color: #d4d4d4;
            overflow: hidden;
            height: 100vh;
        }

        .container {
            display: grid;
            grid-template-columns: 250px 1fr 400px;
            grid-template-rows: 50px 1fr 40px;
            height: 100vh;
            gap: 0;
        }

        /* Header */
        .header {
            grid-column: 1 / -1;
            background: #252526;
            padding: 0 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid #3e3e42;
        }

        .header h1 {
            font-size: 18px;
            font-weight: 500;
            color: #cccccc;
        }

        .header-controls {
            display: flex;
            gap: 10px;
        }

        .btn {
            padding: 6px 16px;
            background: #0e639c;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: background 0.2s;
        }

        .btn:hover {
            background: #1177bb;
        }

        .btn-secondary {
            background: #3e3e42;
        }

        .btn-secondary:hover {
            background: #505050;
        }

        /* Node Library Panel */
        .node-library {
            background: #252526;
            border-right: 1px solid #3e3e42;
            overflow-y: auto;
            padding: 15px;
        }

        .node-category {
            margin-bottom: 20px;
        }

        .node-category h3 {
            font-size: 12px;
            text-transform: uppercase;
            color: #858585;
            margin-bottom: 10px;
            letter-spacing: 0.5px;
        }

        .node-item {
            background: #2d2d30;
            padding: 10px;
            margin-bottom: 8px;
            border-radius: 4px;
            cursor: grab;
            border-left: 3px solid;
            transition: all 0.2s;
        }

        .node-item:hover {
            background: #3e3e42;
            transform: translateX(4px);
        }

        .node-item:active {
            cursor: grabbing;
        }

        .node-item.variables { border-color: #4ec9b0; }
        .node-item.math { border-color: #569cd6; }
        .node-item.logic { border-color: #c586c0; }
        .node-item.control { border-color: #ce9178; }
        .node-item.functions { border-color: #dcdcaa; }

        .node-item-title {
            font-size: 13px;
            font-weight: 500;
            margin-bottom: 4px;
        }

        .node-item-desc {
            font-size: 11px;
            color: #858585;
        }

        /* Canvas Area */
        .canvas-area {
            position: relative;
            background: #1e1e1e;
            overflow: hidden;
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: default;
        }

        .canvas-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            background: #252526;
            padding: 8px;
            border-radius: 6px;
            border: 1px solid #3e3e42;
        }

        .canvas-controls button {
            width: 32px;
            height: 32px;
            background: #3e3e42;
            border: none;
            border-radius: 4px;
            color: #cccccc;
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .canvas-controls button:hover {
            background: #505050;
        }

        /* Code Preview Panel */
        .code-panel {
            background: #1e1e1e;
            border-left: 1px solid #3e3e42;
            display: flex;
            flex-direction: column;
        }

        .code-panel-header {
            background: #252526;
            padding: 12px 15px;
            border-bottom: 1px solid #3e3e42;
            font-size: 13px;
            font-weight: 500;
        }

        .code-preview {
            flex: 1;
            overflow: auto;
            padding: 15px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.6;
        }

        .code-line {
            display: block;
        }

        .keyword { color: #569cd6; }
        .string { color: #ce9178; }
        .number { color: #b5cea8; }
        .function { color: #dcdcaa; }
        .variable { color: #4ec9b0; }
        .comment { color: #6a9955; }

        /* Tabs */
        .tab {
            transition: background 0.2s, color 0.2s;
        }

        .tab:hover {
            background: #2d2d30;
        }

        .tab.active {
            background: #1e1e1e;
            border-bottom: 2px solid #007acc;
        }

        /* Execution States */
        .node-waiting {
            opacity: 0.6;
        }

        .node-executing {
            filter: drop-shadow(0 0 12px #FFD700);
            animation: pulse 0.6s ease-in-out infinite;
        }

        .node-completed {
            opacity: 0.8;
            filter: drop-shadow(0 0 8px #4CAF50);
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        /* Console Styles */
        .console-timestamp {
            color: #858585;
            font-size: 11px;
        }

        .console-success {
            color: #4CAF50;
        }

        .console-info {
            color: #2196F3;
        }

        .console-warning {
            color: #FFA726;
        }

        .console-error {
            color: #EF5350;
        }

        /* Footer */
        .footer {
            grid-column: 1 / -1;
            background: #007acc;
            padding: 0 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 12px;
        }

        .footer-status {
            display: flex;
            gap: 20px;
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: #252526;
            border: 1px solid #3e3e42;
            border-radius: 8px;
            padding: 25px;
            max-width: 500px;
            width: 90%;
        }

        .modal-header {
            font-size: 18px;
            margin-bottom: 20px;
            font-weight: 500;
        }

        .modal-body {
            margin-bottom: 20px;
        }

        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        textarea {
            width: 100%;
            min-height: 200px;
            background: #1e1e1e;
            color: #d4d4d4;
            border: 1px solid #3e3e42;
            border-radius: 4px;
            padding: 10px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 13px;
            resize: vertical;
        }

        input[type="text"] {
            width: 100%;
            background: #1e1e1e;
            color: #d4d4d4;
            border: 1px solid #3e3e42;
            border-radius: 4px;
            padding: 8px 12px;
            font-size: 13px;
            margin-bottom: 15px;
        }

        label {
            display: block;
            font-size: 13px;
            margin-bottom: 6px;
            color: #cccccc;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <h1>Visual Programming IDE</h1>
            <div class="header-controls">
                <button class="btn btn-secondary" onclick="app.loadTutorial()">Load Tutorial</button>
                <button class="btn btn-secondary" onclick="app.clear()">Clear</button>
                <button class="btn btn-secondary" onclick="app.showImportModal()">Import</button>
                <button class="btn btn-secondary" onclick="app.exportProject()">Export</button>
                <button class="btn" onclick="app.generateCode()">Generate Code</button>
                <button class="btn" id="runSimBtn" onclick="app.runSimulation()" style="background: #16a34a; margin-left: 10px;">▶ Run Simulation</button>
            </div>
        </div>

        <!-- Node Library -->
        <div class="node-library">
            <div class="node-category">
                <h3>Variables</h3>
                <div class="node-item variables" draggable="true" data-type="variable">
                    <div class="node-item-title">Variable</div>
                    <div class="node-item-desc">Store a value</div>
                </div>
            </div>

            <div class="node-category">
                <h3>Math Operations</h3>
                <div class="node-item math" draggable="true" data-type="add">
                    <div class="node-item-title">Add</div>
                    <div class="node-item-desc">Add two numbers</div>
                </div>
                <div class="node-item math" draggable="true" data-type="subtract">
                    <div class="node-item-title">Subtract</div>
                    <div class="node-item-desc">Subtract two numbers</div>
                </div>
                <div class="node-item math" draggable="true" data-type="multiply">
                    <div class="node-item-title">Multiply</div>
                    <div class="node-item-desc">Multiply two numbers</div>
                </div>
            </div>

            <div class="node-category">
                <h3>Logic</h3>
                <div class="node-item logic" draggable="true" data-type="if">
                    <div class="node-item-title">If Statement</div>
                    <div class="node-item-desc">Conditional execution</div>
                </div>
                <div class="node-item logic" draggable="true" data-type="compare">
                    <div class="node-item-title">Compare</div>
                    <div class="node-item-desc">Compare two values</div>
                </div>
            </div>

            <div class="node-category">
                <h3>Control Flow</h3>
                <div class="node-item control" draggable="true" data-type="loop">
                    <div class="node-item-title">For Loop</div>
                    <div class="node-item-desc">Repeat actions</div>
                </div>
            </div>

            <div class="node-category">
                <h3>Functions</h3>
                <div class="node-item functions" draggable="true" data-type="function">
                    <div class="node-item-title">Function</div>
                    <div class="node-item-desc">Create a function</div>
                </div>
                <div class="node-item functions" draggable="true" data-type="output">
                    <div class="node-item-title">Console Output</div>
                    <div class="node-item-desc">Print to console</div>
                </div>
            </div>
        </div>

        <!-- Canvas Area -->
        <div class="canvas-area">
            <canvas id="canvas"></canvas>
            <div class="canvas-controls">
                <button onclick="app.zoomIn()" title="Zoom In">+</button>
                <button onclick="app.zoomOut()" title="Zoom Out">−</button>
                <button onclick="app.resetView()" title="Reset View">⟲</button>
            </div>
        </div>

        <!-- Code Preview Panel -->
        <div class="code-panel">
            <div class="code-panel-header" style="display: flex; gap: 0;">
                <div class="tab active" onclick="app.switchTab('code')" style="flex: 1; padding: 12px 15px; cursor: pointer; border-right: 1px solid #3e3e42;">Code</div>
                <div class="tab" onclick="app.switchTab('console')" style="flex: 1; padding: 12px 15px; cursor: pointer;">Console</div>
            </div>
            <div class="code-preview" id="codePreview">
                <span class="comment">// Welcome to Visual Programming IDE!<br>// Drag nodes from the left panel<br>// Connect them together<br>// Watch your code generate here in real-time<br>// Double-click nodes to edit properties<br>// Click "Run Simulation" to see it execute!</span>
            </div>
            <div class="code-preview" id="consolePreview" style="display: none; font-family: 'Consolas', 'Monaco', monospace; font-size: 12px; line-height: 1.8;">
                <span style="color: #858585;">Console output will appear here when you run the simulation...</span>
            </div>
        </div>

        <!-- Footer -->
        <div class="footer">
            <div class="footer-status">
                <span>Nodes: <span id="nodeCount">0</span></span>
                <span>Connections: <span id="connectionCount">0</span></span>
            </div>
            <div>Zoom: <span id="zoomLevel">100%</span></div>
        </div>
    </div>

    <!-- Import Modal -->
    <div class="modal" id="importModal">
        <div class="modal-content">
            <div class="modal-header">Import Project</div>
            <div class="modal-body">
                <label>Paste JSON data:</label>
                <textarea id="importData"></textarea>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="app.closeImportModal()">Cancel</button>
                <button class="btn" onclick="app.importProject()">Import</button>
            </div>
        </div>
    </div>

    <script>
        // Visual Programming IDE Application
        const app = {
            canvas: null,
            ctx: null,
            nodes: new Map(),
            connections: [],
            nodeIdCounter: 0,
            connectionIdCounter: 0,

            // View state
            camera: { x: 0, y: 0, zoom: 1 },

            // Interaction state
            isDragging: false,
            isConnecting: false,
            draggedNode: null,
            selectedNode: null,
            dragOffset: { x: 0, y: 0 },
            connectingFrom: null,
            mousePos: { x: 0, y: 0 },

            // Node definitions
            nodeTypes: {
                variable: {
                    label: 'Variable',
                    color: '#4ec9b0',
                    inputs: [],
                    outputs: ['value'],
                    properties: { name: 'myVar', value: '0' },
                    codeTemplate: 'let {{name}} = {{value}};'
                },
                add: {
                    label: 'Add',
                    color: '#569cd6',
                    inputs: ['a', 'b'],
                    outputs: ['result'],
                    properties: {},
                    codeTemplate: '{{result}} = {{a}} + {{b}};'
                },
                subtract: {
                    label: 'Subtract',
                    color: '#569cd6',
                    inputs: ['a', 'b'],
                    outputs: ['result'],
                    properties: {},
                    codeTemplate: '{{result}} = {{a}} - {{b}};'
                },
                multiply: {
                    label: 'Multiply',
                    color: '#569cd6',
                    inputs: ['a', 'b'],
                    outputs: ['result'],
                    properties: {},
                    codeTemplate: '{{result}} = {{a}} * {{b}};'
                },
                if: {
                    label: 'If',
                    color: '#c586c0',
                    inputs: ['condition'],
                    outputs: ['then', 'else'],
                    properties: {},
                    codeTemplate: 'if ({{condition}}) {\n  {{then}}\n} else {\n  {{else}}\n}'
                },
                compare: {
                    label: 'Compare',
                    color: '#c586c0',
                    inputs: ['a', 'b'],
                    outputs: ['result'],
                    properties: { operator: '===' },
                    codeTemplate: '{{result}} = {{a}} {{operator}} {{b}};'
                },
                loop: {
                    label: 'For Loop',
                    color: '#ce9178',
                    inputs: ['start', 'end'],
                    outputs: ['body'],
                    properties: { variable: 'i' },
                    codeTemplate: 'for (let {{variable}} = {{start}}; {{variable}} < {{end}}; {{variable}}++) {\n  {{body}}\n}'
                },
                function: {
                    label: 'Function',
                    color: '#dcdcaa',
                    inputs: ['body'],
                    outputs: [],
                    properties: { name: 'myFunction', params: '' },
                    codeTemplate: 'function {{name}}({{params}}) {\n  {{body}}\n}'
                },
                output: {
                    label: 'Console Output',
                    color: '#dcdcaa',
                    inputs: ['value'],
                    outputs: [],
                    properties: {},
                    codeTemplate: 'console.log({{value}});'
                }
            },

            init() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');

                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());

                // Mouse events
                this.canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
                this.canvas.addEventListener('mouseup', (e) => this.onMouseUp(e));
                this.canvas.addEventListener('wheel', (e) => this.onWheel(e));
                this.canvas.addEventListener('dblclick', (e) => this.onDoubleClick(e));

                // Drag and drop from node library
                document.querySelectorAll('.node-item').forEach(item => {
                    item.addEventListener('dragstart', (e) => {
                        e.dataTransfer.setData('nodeType', e.target.dataset.type);
                    });
                });

                this.canvas.addEventListener('dragover', (e) => e.preventDefault());
                this.canvas.addEventListener('drop', (e) => this.onDrop(e));

                // Load from localStorage if available
                this.loadFromLocalStorage();

                // Auto-save every 5 seconds
                setInterval(() => this.saveToLocalStorage(), 5000);

                this.render();
            },

            resizeCanvas() {
                const rect = this.canvas.parentElement.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
                this.render();
            },

            screenToWorld(x, y) {
                return {
                    x: (x - this.camera.x) / this.camera.zoom,
                    y: (y - this.camera.y) / this.camera.zoom
                };
            },

            worldToScreen(x, y) {
                return {
                    x: x * this.camera.zoom + this.camera.x,
                    y: y * this.camera.zoom + this.camera.y
                };
            },

            createNode(type, x, y) {
                const def = this.nodeTypes[type];
                if (!def) return null;

                const node = {
                    id: this.nodeIdCounter++,
                    type,
                    x,
                    y,
                    width: 180,
                    height: 80 + Math.max(def.inputs.length, def.outputs.length) * 25,
                    properties: { ...def.properties }
                };

                this.nodes.set(node.id, node);
                this.updateStats();
                this.render();
                this.generateCode();
                return node;
            },

            deleteNode(nodeId) {
                // Remove all connections to/from this node
                this.connections = this.connections.filter(conn =>
                    conn.fromNode !== nodeId && conn.toNode !== nodeId
                );

                this.nodes.delete(nodeId);
                this.updateStats();
                this.render();
                this.generateCode();
            },

            createConnection(fromNode, fromPort, toNode, toPort) {
                // Check if connection already exists
                const exists = this.connections.some(conn =>
                    conn.fromNode === fromNode && conn.fromPort === fromPort &&
                    conn.toNode === toNode && conn.toPort === toPort
                );

                if (!exists) {
                    this.connections.push({
                        id: this.connectionIdCounter++,
                        fromNode,
                        fromPort,
                        toNode,
                        toPort
                    });
                    this.updateStats();
                    this.generateCode();
                }
            },

            getNodeAt(x, y) {
                for (const [id, node] of this.nodes) {
                    if (x >= node.x && x <= node.x + node.width &&
                        y >= node.y && y <= node.y + node.height) {
                        return node;
                    }
                }
                return null;
            },

            getPortAt(node, x, y) {
                const def = this.nodeTypes[node.type];
                const portRadius = 8;

                // Check input ports (left side)
                def.inputs.forEach((port, idx) => {
                    const portY = node.y + 50 + idx * 25;
                    const portX = node.x;
                    const dist = Math.sqrt((x - portX) ** 2 + (y - portY) ** 2);
                    if (dist < portRadius) {
                        return { type: 'input', port, index: idx };
                    }
                });

                // Check output ports (right side)
                def.outputs.forEach((port, idx) => {
                    const portY = node.y + 50 + idx * 25;
                    const portX = node.x + node.width;
                    const dist = Math.sqrt((x - portX) ** 2 + (y - portY) ** 2);
                    if (dist < portRadius) {
                        return { type: 'output', port, index: idx };
                    }
                });

                return null;
            },

            onMouseDown(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const worldPos = this.screenToWorld(x, y);

                this.mousePos = worldPos;

                const node = this.getNodeAt(worldPos.x, worldPos.y);

                if (node) {
                    const port = this.getPortAt(node, worldPos.x, worldPos.y);

                    if (port) {
                        // Start connection
                        this.isConnecting = true;
                        this.connectingFrom = {
                            node: node.id,
                            port: port.port,
                            type: port.type,
                            index: port.index
                        };
                    } else {
                        // Start dragging node
                        this.isDragging = true;
                        this.draggedNode = node;
                        this.dragOffset = {
                            x: worldPos.x - node.x,
                            y: worldPos.y - node.y
                        };
                        this.selectedNode = node;
                    }
                }

                this.render();
            },

            onMouseMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const worldPos = this.screenToWorld(x, y);

                this.mousePos = worldPos;

                if (this.isDragging && this.draggedNode) {
                    this.draggedNode.x = worldPos.x - this.dragOffset.x;
                    this.draggedNode.y = worldPos.y - this.dragOffset.y;
                    this.render();
                } else if (this.isConnecting) {
                    this.render();
                }
            },

            onMouseUp(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const worldPos = this.screenToWorld(x, y);

                if (this.isConnecting && this.connectingFrom) {
                    const targetNode = this.getNodeAt(worldPos.x, worldPos.y);

                    if (targetNode && targetNode.id !== this.connectingFrom.node) {
                        const port = this.getPortAt(targetNode, worldPos.x, worldPos.y);

                        if (port) {
                            // Create connection based on port types
                            if (this.connectingFrom.type === 'output' && port.type === 'input') {
                                this.createConnection(
                                    this.connectingFrom.node,
                                    this.connectingFrom.port,
                                    targetNode.id,
                                    port.port
                                );
                            } else if (this.connectingFrom.type === 'input' && port.type === 'output') {
                                this.createConnection(
                                    targetNode.id,
                                    port.port,
                                    this.connectingFrom.node,
                                    this.connectingFrom.port
                                );
                            }
                        }
                    }
                }

                this.isDragging = false;
                this.draggedNode = null;
                this.isConnecting = false;
                this.connectingFrom = null;
                this.render();
            },

            onWheel(e) {
                e.preventDefault();
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                const oldZoom = this.camera.zoom;
                this.camera.zoom *= delta;
                this.camera.zoom = Math.max(0.1, Math.min(3, this.camera.zoom));

                // Zoom towards mouse position
                const rect = this.canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                this.camera.x = mouseX - (mouseX - this.camera.x) * (this.camera.zoom / oldZoom);
                this.camera.y = mouseY - (mouseY - this.camera.y) * (this.camera.zoom / oldZoom);

                this.updateZoomDisplay();
                this.render();
            },

            onDoubleClick(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const worldPos = this.screenToWorld(x, y);

                const node = this.getNodeAt(worldPos.x, worldPos.y);
                if (node) {
                    this.editNodeProperties(node);
                }
            },

            onDrop(e) {
                e.preventDefault();
                const nodeType = e.dataTransfer.getData('nodeType');
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const worldPos = this.screenToWorld(x, y);

                this.createNode(nodeType, worldPos.x - 90, worldPos.y - 40);
            },

            editNodeProperties(node) {
                const def = this.nodeTypes[node.type];
                let propString = '';

                for (const [key, value] of Object.entries(node.properties)) {
                    const newValue = prompt(`Enter ${key}:`, value);
                    if (newValue !== null) {
                        node.properties[key] = newValue;
                    }
                }

                this.render();
                this.generateCode();
            },

            render() {
                const ctx = this.ctx;

                // Clear canvas
                ctx.fillStyle = '#1e1e1e';
                ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Draw grid
                this.drawGrid();

                // Draw connections
                ctx.save();
                this.connections.forEach(conn => this.drawConnection(conn));

                // Draw connection preview
                if (this.isConnecting && this.connectingFrom) {
                    const fromNode = this.nodes.get(this.connectingFrom.node);
                    if (fromNode) {
                        const def = this.nodeTypes[fromNode.type];
                        const portY = fromNode.y + 50 + this.connectingFrom.index * 25;
                        const portX = this.connectingFrom.type === 'output'
                            ? fromNode.x + fromNode.width
                            : fromNode.x;

                        const screenFrom = this.worldToScreen(portX, portY);
                        const screenTo = this.worldToScreen(this.mousePos.x, this.mousePos.y);

                        ctx.strokeStyle = '#ffffff50';
                        ctx.lineWidth = 2;
                        ctx.setLineDash([5, 5]);
                        ctx.beginPath();
                        ctx.moveTo(screenFrom.x, screenFrom.y);
                        ctx.lineTo(screenTo.x, screenTo.y);
                        ctx.stroke();
                        ctx.setLineDash([]);
                    }
                }
                ctx.restore();

                // Draw nodes
                for (const [id, node] of this.nodes) {
                    this.drawNode(node);
                }
            },

            drawGrid() {
                const ctx = this.ctx;
                const gridSize = 50 * this.camera.zoom;
                const offsetX = this.camera.x % gridSize;
                const offsetY = this.camera.y % gridSize;

                ctx.strokeStyle = '#2a2a2a';
                ctx.lineWidth = 1;

                // Vertical lines
                for (let x = offsetX; x < this.canvas.width; x += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, this.canvas.height);
                    ctx.stroke();
                }

                // Horizontal lines
                for (let y = offsetY; y < this.canvas.height; y += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(this.canvas.width, y);
                    ctx.stroke();
                }
            },

            drawNode(node) {
                const ctx = this.ctx;
                const def = this.nodeTypes[node.type];
                const screen = this.worldToScreen(node.x, node.y);
                const width = node.width * this.camera.zoom;
                const height = node.height * this.camera.zoom;

                // Apply execution state effects
                ctx.save();
                if (node.executionState === 'waiting') {
                    ctx.globalAlpha = 0.6;
                } else if (node.executionState === 'executing') {
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#FFD700';
                } else if (node.executionState === 'completed') {
                    ctx.globalAlpha = 0.8;
                    ctx.shadowBlur = 12;
                    ctx.shadowColor = '#4CAF50';
                }

                // Node body
                ctx.fillStyle = '#2d2d30';
                ctx.strokeStyle = this.selectedNode === node ? '#ffffff' :
                                  node.executionState === 'executing' ? '#FFD700' :
                                  node.executionState === 'completed' ? '#4CAF50' : '#3e3e42';
                ctx.lineWidth = node.executionState === 'executing' ? 3 : 2;
                ctx.beginPath();
                ctx.roundRect(screen.x, screen.y, width, height, 6);
                ctx.fill();
                ctx.stroke();

                // Node header
                ctx.fillStyle = def.color;
                ctx.beginPath();
                ctx.roundRect(screen.x, screen.y, width, 30 * this.camera.zoom, [6, 6, 0, 0]);
                ctx.fill();

                // Node label
                ctx.fillStyle = '#ffffff';
                ctx.font = `${14 * this.camera.zoom}px "Segoe UI"`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(def.label, screen.x + width / 2, screen.y + 15 * this.camera.zoom);

                // Input ports
                ctx.fillStyle = '#4ec9b0';
                ctx.font = `${11 * this.camera.zoom}px "Segoe UI"`;
                ctx.textAlign = 'left';
                def.inputs.forEach((port, idx) => {
                    const portY = screen.y + (50 + idx * 25) * this.camera.zoom;
                    const portX = screen.x;

                    ctx.beginPath();
                    ctx.arc(portX, portY, 6 * this.camera.zoom, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = '#cccccc';
                    ctx.fillText(port, portX + 12 * this.camera.zoom, portY);
                    ctx.fillStyle = '#4ec9b0';
                });

                // Output ports
                ctx.fillStyle = '#ce9178';
                ctx.textAlign = 'right';
                def.outputs.forEach((port, idx) => {
                    const portY = screen.y + (50 + idx * 25) * this.camera.zoom;
                    const portX = screen.x + width;

                    ctx.beginPath();
                    ctx.arc(portX, portY, 6 * this.camera.zoom, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = '#cccccc';
                    ctx.fillText(port, portX - 12 * this.camera.zoom, portY);
                    ctx.fillStyle = '#ce9178';
                });

                // Restore context state
                ctx.restore();
            },

            drawConnection(conn) {
                const ctx = this.ctx;
                const fromNode = this.nodes.get(conn.fromNode);
                const toNode = this.nodes.get(conn.toNode);

                if (!fromNode || !toNode) return;

                const fromDef = this.nodeTypes[fromNode.type];
                const toDef = this.nodeTypes[toNode.type];

                const fromIdx = fromDef.outputs.indexOf(conn.fromPort);
                const toIdx = toDef.inputs.indexOf(conn.toPort);

                const fromY = fromNode.y + 50 + fromIdx * 25;
                const fromX = fromNode.x + fromNode.width;
                const toY = toNode.y + 50 + toIdx * 25;
                const toX = toNode.x;

                const screenFrom = this.worldToScreen(fromX, fromY);
                const screenTo = this.worldToScreen(toX, toY);

                // Bezier curve
                const midX = (screenFrom.x + screenTo.x) / 2;

                ctx.strokeStyle = '#569cd6';
                ctx.lineWidth = 2 * this.camera.zoom;
                ctx.beginPath();
                ctx.moveTo(screenFrom.x, screenFrom.y);
                ctx.bezierCurveTo(
                    midX, screenFrom.y,
                    midX, screenTo.y,
                    screenTo.x, screenTo.y
                );
                ctx.stroke();
            },

            // Code Generation using Topological Sort
            generateCode() {
                if (this.nodes.size === 0) {
                    document.getElementById('codePreview').innerHTML =
                        '<span class="comment">// Your generated code will appear here</span>';
                    return;
                }

                // Build dependency graph
                const deps = new Map();
                const inDegree = new Map();

                for (const [id, node] of this.nodes) {
                    deps.set(id, []);
                    inDegree.set(id, 0);
                }

                for (const conn of this.connections) {
                    deps.get(conn.fromNode).push(conn.toNode);
                    inDegree.set(conn.toNode, inDegree.get(conn.toNode) + 1);
                }

                // Topological sort (Kahn's algorithm)
                const queue = [];
                const sorted = [];

                for (const [id, degree] of inDegree) {
                    if (degree === 0) queue.push(id);
                }

                while (queue.length > 0) {
                    const nodeId = queue.shift();
                    sorted.push(nodeId);

                    for (const neighbor of deps.get(nodeId)) {
                        inDegree.set(neighbor, inDegree.get(neighbor) - 1);
                        if (inDegree.get(neighbor) === 0) {
                            queue.push(neighbor);
                        }
                    }
                }

                // Generate code from sorted nodes
                let code = [];

                sorted.forEach(nodeId => {
                    const node = this.nodes.get(nodeId);
                    const def = this.nodeTypes[node.type];
                    let line = def.codeTemplate;

                    // Replace properties
                    for (const [key, value] of Object.entries(node.properties)) {
                        line = line.replace(new RegExp(`{{${key}}}`, 'g'), value);
                    }

                    // Replace inputs from connections
                    def.inputs.forEach(input => {
                        const conn = this.connections.find(c =>
                            c.toNode === nodeId && c.toPort === input
                        );
                        if (conn) {
                            const fromNode = this.nodes.get(conn.fromNode);
                            const placeholder = `result_${conn.fromNode}_${conn.fromPort}`;
                            line = line.replace(new RegExp(`{{${input}}}`, 'g'), placeholder);
                        } else {
                            line = line.replace(new RegExp(`{{${input}}}`, 'g'), '0');
                        }
                    });

                    // Replace outputs with unique names
                    def.outputs.forEach(output => {
                        const placeholder = `result_${nodeId}_${output}`;
                        line = line.replace(new RegExp(`{{${output}}}`, 'g'), placeholder);
                    });

                    code.push(line);
                });

                // Syntax highlight the code
                const highlighted = this.highlightCode(code.join('\n'));
                document.getElementById('codePreview').innerHTML = highlighted;
            },

            highlightCode(code) {
                return code
                    .replace(/\b(let|const|var|function|if|else|for|while|return)\b/g, '<span class="keyword">$1</span>')
                    .replace(/\b(\d+)\b/g, '<span class="number">$1</span>')
                    .replace(/(['"`])(.*?)\1/g, '<span class="string">$1$2$1</span>')
                    .replace(/\b([a-zA-Z_][a-zA-Z0-9_]*)\s*\(/g, '<span class="function">$1</span>(')
                    .replace(/\n/g, '<br>');
            },

            updateStats() {
                document.getElementById('nodeCount').textContent = this.nodes.size;
                document.getElementById('connectionCount').textContent = this.connections.length;
            },

            updateZoomDisplay() {
                document.getElementById('zoomLevel').textContent =
                    Math.round(this.camera.zoom * 100) + '%';
            },

            zoomIn() {
                this.camera.zoom = Math.min(3, this.camera.zoom * 1.2);
                this.updateZoomDisplay();
                this.render();
            },

            zoomOut() {
                this.camera.zoom = Math.max(0.1, this.camera.zoom / 1.2);
                this.updateZoomDisplay();
                this.render();
            },

            resetView() {
                this.camera = { x: 0, y: 0, zoom: 1 };
                this.updateZoomDisplay();
                this.render();
            },

            clear() {
                if (confirm('Clear all nodes and connections?')) {
                    this.nodes.clear();
                    this.connections = [];
                    this.nodeIdCounter = 0;
                    this.connectionIdCounter = 0;
                    this.selectedNode = null;
                    this.updateStats();
                    this.render();
                    this.generateCode();
                }
            },

            loadTutorial() {
                // Clear everything first
                this.nodes.clear();
                this.connections = [];
                this.nodeIdCounter = 0;
                this.connectionIdCounter = 0;
                this.selectedNode = null;

                // Load the Hello World example
                this.createHelloWorldExample();
            },

            exportProject() {
                const data = {
                    nodes: Array.from(this.nodes.entries()).map(([id, node]) => ({
                        id,
                        ...node
                    })),
                    connections: this.connections,
                    camera: this.camera,
                    version: '1.0.0'
                };

                const json = JSON.stringify(data, null, 2);
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'visual-program.json';
                a.click();
                URL.revokeObjectURL(url);
            },

            showImportModal() {
                document.getElementById('importModal').classList.add('active');
            },

            closeImportModal() {
                document.getElementById('importModal').classList.remove('active');
            },

            importProject() {
                try {
                    const json = document.getElementById('importData').value;
                    const data = JSON.parse(json);

                    this.nodes.clear();
                    this.connections = [];

                    data.nodes.forEach(nodeData => {
                        const { id, ...node } = nodeData;
                        this.nodes.set(id, node);
                        this.nodeIdCounter = Math.max(this.nodeIdCounter, id + 1);
                    });

                    this.connections = data.connections;
                    this.connectionIdCounter = data.connections.length;

                    if (data.camera) {
                        this.camera = data.camera;
                    }

                    this.closeImportModal();
                    this.updateStats();
                    this.updateZoomDisplay();
                    this.render();
                    this.generateCode();
                } catch (err) {
                    alert('Invalid JSON data: ' + err.message);
                }
            },

            saveToLocalStorage() {
                const data = {
                    nodes: Array.from(this.nodes.entries()),
                    connections: this.connections,
                    camera: this.camera,
                    nodeIdCounter: this.nodeIdCounter,
                    connectionIdCounter: this.connectionIdCounter
                };
                localStorage.setItem('visualProgrammingIDE', JSON.stringify(data));
            },

            loadFromLocalStorage() {
                const saved = localStorage.getItem('visualProgrammingIDE');
                if (saved) {
                    try {
                        const data = JSON.parse(saved);
                        this.nodes = new Map(data.nodes);
                        this.connections = data.connections || [];
                        this.camera = data.camera || { x: 0, y: 0, zoom: 1 };
                        this.nodeIdCounter = data.nodeIdCounter || 0;
                        this.connectionIdCounter = data.connectionIdCounter || 0;
                        this.updateStats();
                        this.updateZoomDisplay();
                        this.generateCode();
                    } catch (err) {
                        console.error('Failed to load from localStorage:', err);
                    }
                } else {
                    // No saved data - create Hello World example
                    this.createHelloWorldExample();
                }
            },

            createHelloWorldExample() {
                // Agent Civilization Upgrade Script - Simplified Visual Flow
                // Cleaner layout with better spacing

                const COL1 = 50;   // First column (config)
                const COL2 = 380;  // Second column (operations)
                const COL3 = 710;  // Third column (output)
                const SPACING = 180; // Vertical spacing

                // Row 1: Configuration
                const repoUrlVar = this.createNode('variable', COL1, SPACING * 0);
                if (repoUrlVar) {
                    repoUrlVar.properties.name = 'repoUrl';
                    repoUrlVar.properties.value = '"github.com/user/ca-agent"';
                }

                const headerOut = this.createNode('output', COL2, SPACING * 0);
                if (headerOut && repoUrlVar) {
                    this.createConnection(repoUrlVar.id, 'value', headerOut.id, 'value');
                }

                // Row 2: Clone operation
                const cloneMsg = this.createNode('variable', COL1, SPACING * 1);
                if (cloneMsg) {
                    cloneMsg.properties.name = 'cloneMsg';
                    cloneMsg.properties.value = '"Cloning repository..."';
                }

                const cloneOut = this.createNode('output', COL2, SPACING * 1);
                if (cloneOut && cloneMsg) {
                    this.createConnection(cloneMsg.id, 'value', cloneOut.id, 'value');
                }

                // Row 3: Backup operation
                const backupMsg = this.createNode('variable', COL1, SPACING * 2);
                if (backupMsg) {
                    backupMsg.properties.name = 'backupMsg';
                    backupMsg.properties.value = '"Creating backup..."';
                }

                const backupOut = this.createNode('output', COL2, SPACING * 2);
                if (backupOut && backupMsg) {
                    this.createConnection(backupMsg.id, 'value', backupOut.id, 'value');
                }

                // Row 4: Agent creation
                const agentCount = this.createNode('variable', COL1, SPACING * 3);
                if (agentCount) {
                    agentCount.properties.name = 'agentCount';
                    agentCount.properties.value = '6';
                }

                const agentMsg = this.createNode('variable', COL1, SPACING * 3.8);
                if (agentMsg) {
                    agentMsg.properties.name = 'agentLabel';
                    agentMsg.properties.value = '" agents created"';
                }

                const agentAdd = this.createNode('add', COL2, SPACING * 3.4);
                const agentOut = this.createNode('output', COL3, SPACING * 3.4);

                if (agentCount && agentAdd) {
                    this.createConnection(agentCount.id, 'value', agentAdd.id, 'a');
                }
                if (agentMsg && agentAdd) {
                    this.createConnection(agentMsg.id, 'value', agentAdd.id, 'b');
                }
                if (agentAdd && agentOut) {
                    this.createConnection(agentAdd.id, 'result', agentOut.id, 'value');
                }

                // Row 5: Deployment decision
                const deployCheck = this.createNode('if', COL2, SPACING * 5);

                const deployMsg = this.createNode('variable', COL3, SPACING * 4.5);
                if (deployMsg) {
                    deployMsg.properties.name = 'deployMsg';
                    deployMsg.properties.value = '"Deploying..."';
                }

                const skipMsg = this.createNode('variable', COL3, SPACING * 5.5);
                if (skipMsg) {
                    skipMsg.properties.name = 'skipMsg';
                    skipMsg.properties.value = '"Skipped"';
                }

                // Row 6: Success message
                const successMsg = this.createNode('variable', COL1, SPACING * 6.5);
                if (successMsg) {
                    successMsg.properties.name = 'successMsg';
                    successMsg.properties.value = '"✅ Upgrade Complete!"';
                }

                const successOut = this.createNode('output', COL2, SPACING * 6.5);
                if (successMsg && successOut) {
                    this.createConnection(successMsg.id, 'value', successOut.id, 'value');
                }

                // Set better camera position - centered and zoomed in
                this.camera.x = 200;
                this.camera.y = 100;
                this.camera.zoom = 1.0; // Full zoom for better visibility

                this.updateStats();
                this.updateZoomDisplay();
                this.render();
                this.generateCode();
            },

            // ========== EXECUTION SIMULATION ==========

            executionState: {
                isRunning: false,
                currentIndex: 0,
                executionOrder: [],
                consoleOutput: []
            },

            switchTab(tab) {
                // Update tab styling
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                event.target.classList.add('active');

                // Show/hide panels
                if (tab === 'code') {
                    document.getElementById('codePreview').style.display = 'block';
                    document.getElementById('consolePreview').style.display = 'none';
                } else {
                    document.getElementById('codePreview').style.display = 'none';
                    document.getElementById('consolePreview').style.display = 'block';
                }
            },

            logToConsole(message, type = 'info') {
                const timestamp = new Date().toLocaleTimeString('en-US', { hour12: false, fractionalSecondDigits: 3 });
                const icon = {
                    'info': 'ℹ',
                    'success': '✓',
                    'warning': '⚠',
                    'error': '✗',
                    'progress': '⟳'
                }[type];

                const colorClass = `console-${type}`;
                const logEntry = `<div><span class="console-timestamp">[${timestamp}]</span> <span class="${colorClass}">${icon}</span> ${message}</div>`;

                this.executionState.consoleOutput.push(logEntry);

                const consoleEl = document.getElementById('consolePreview');
                consoleEl.innerHTML = this.executionState.consoleOutput.join('');
                consoleEl.scrollTop = consoleEl.scrollHeight;
            },

            async runSimulation() {
                if (this.executionState.isRunning) return;

                // Switch to console tab
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab')[1].classList.add('active');
                document.getElementById('codePreview').style.display = 'none';
                document.getElementById('consolePreview').style.display = 'block';

                // Reset state
                this.executionState.isRunning = true;
                this.executionState.currentIndex = 0;
                this.executionState.consoleOutput = [];

                // Clear node states
                for (const [id, node] of this.nodes) {
                    node.executionState = 'waiting';
                }

                // Update button
                const btn = document.getElementById('runSimBtn');
                btn.textContent = '⏸ Running...';
                btn.style.background = '#ef4444';

                this.logToConsole('🧬 Agent Civilization Upgrade Script - Execution Started', 'progress');
                this.logToConsole('Initializing execution environment...', 'info');

                // Build execution order
                await this.sleep(300);
                this.logToConsole('Building dependency graph...', 'info');

                const deps = new Map();
                const inDegree = new Map();

                for (const [id, node] of this.nodes) {
                    deps.set(id, []);
                    inDegree.set(id, 0);
                }

                for (const conn of this.connections) {
                    deps.get(conn.fromNode).push(conn.toNode);
                    inDegree.set(conn.toNode, inDegree.get(conn.toNode) + 1);
                }

                // Topological sort
                const queue = [];
                const sorted = [];

                for (const [id, degree] of inDegree) {
                    if (degree === 0) queue.push(id);
                }

                while (queue.length > 0) {
                    const nodeId = queue.shift();
                    sorted.push(nodeId);

                    for (const neighbor of deps.get(nodeId)) {
                        inDegree.set(neighbor, inDegree.get(neighbor) - 1);
                        if (inDegree.get(neighbor) === 0) {
                            queue.push(neighbor);
                        }
                    }
                }

                this.executionState.executionOrder = sorted;
                this.logToConsole(`Found ${sorted.length} nodes to execute`, 'success');
                await this.sleep(500);

                // Execute each node
                for (let i = 0; i < sorted.length; i++) {
                    const nodeId = sorted[i];
                    const node = this.nodes.get(nodeId);
                    const def = this.nodeTypes[node.type];

                    // Mark as executing
                    node.executionState = 'executing';
                    this.render();

                    this.logToConsole(`[${def.label}#${nodeId}] Executing node...`, 'progress');
                    await this.sleep(400);

                    // Simulate execution based on node type
                    if (node.type === 'variable') {
                        this.logToConsole(`[${def.label}#${nodeId}] Set ${node.properties.name} = ${node.properties.value}`, 'success');
                    } else if (node.type === 'output') {
                        this.logToConsole(`[${def.label}#${nodeId}] Console output: ${node.properties.name || 'value'}`, 'info');
                        this.logToConsole(`>>> Output: ${node.properties.name || 'result'}`, 'success');
                    } else if (node.type === 'add' || node.type === 'subtract' || node.type === 'multiply') {
                        this.logToConsole(`[${def.label}#${nodeId}] Performing ${def.label.toLowerCase()} operation`, 'info');
                        this.logToConsole(`[${def.label}#${nodeId}] Result computed successfully`, 'success');
                    } else if (node.type === 'if') {
                        this.logToConsole(`[${def.label}#${nodeId}] Evaluating condition...`, 'progress');
                        await this.sleep(200);
                        this.logToConsole(`[${def.label}#${nodeId}] Taking branch path`, 'success');
                    } else if (node.type === 'loop') {
                        const iterations = 5;
                        this.logToConsole(`[${def.label}#${nodeId}] Starting loop (${iterations} iterations)`, 'progress');
                        for (let j = 1; j <= iterations; j++) {
                            await this.sleep(150);
                            this.logToConsole(`[${def.label}#${nodeId}] Iteration ${j}/${iterations}`, 'info');
                        }
                        this.logToConsole(`[${def.label}#${nodeId}] Loop completed`, 'success');
                    } else if (node.type === 'function') {
                        this.logToConsole(`[${def.label}#${nodeId}] Calling function '${node.properties.name}'`, 'progress');
                        await this.sleep(300);
                        this.logToConsole(`[${def.label}#${nodeId}] Function executed successfully`, 'success');
                    }

                    // Mark as completed
                    node.executionState = 'completed';
                    this.render();
                    await this.sleep(200);
                }

                // Execution complete
                this.logToConsole('━'.repeat(60), 'info');
                this.logToConsole('✅ Agent Civilization Upgraded Successfully!', 'success');
                this.logToConsole(`Execution completed in ${(sorted.length * 0.6).toFixed(2)} seconds`, 'info');
                this.logToConsole(`${sorted.length} nodes executed, 0 errors`, 'success');

                // Reset button
                btn.textContent = '▶ Run Simulation';
                btn.style.background = '#16a34a';
                this.executionState.isRunning = false;
            },

            sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        };

        // Initialize on page load
        window.addEventListener('DOMContentLoaded', () => app.init());
    </script>
</body>
</html>