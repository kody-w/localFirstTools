<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Watch Party Sync - P2P Synchronized Viewing</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0d0d0d 0%, #1a0a2e 50%, #0d1a2e 100%);
            min-height: 100vh;
            color: #fff;
        }

        .header {
            text-align: center;
            padding: 15px 20px;
            background: rgba(0,0,0,0.4);
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .header h1 {
            font-size: 1.6rem;
            background: linear-gradient(90deg, #ff6b6b, #feca57, #48dbfb);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            color: transparent;
        }

        .header p {
            color: #888;
            margin-top: 5px;
            font-size: 0.85rem;
        }

        .party-badge {
            display: inline-block;
            background: linear-gradient(90deg, #ff6b6b, #feca57);
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.7rem;
            margin-top: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #000;
            font-weight: bold;
        }

        .main-container {
            display: grid;
            grid-template-columns: 1fr 320px;
            height: calc(100vh - 100px);
            gap: 0;
        }

        @media (max-width: 900px) {
            .main-container {
                grid-template-columns: 1fr;
                height: auto;
            }
        }

        /* Video Section */
        .video-section {
            background: #000;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .video-wrapper {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #111;
            position: relative;
            min-height: 300px;
        }

        #mainVideo {
            max-width: 100%;
            max-height: 100%;
            width: 100%;
        }

        #youtubeContainer {
            width: 100%;
            height: 100%;
            position: relative;
        }

        #youtubeContainer iframe {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        /* ============ FACETIME-STYLE VIDEO GRID ============ */
        .video-grid-container {
            position: absolute;
            top: 50px;
            left: 10px;
            right: 10px;
            bottom: 80px;
            display: grid;
            gap: 8px;
            z-index: 100;
            pointer-events: none;
        }

        .video-grid-container.hidden {
            display: none;
        }

        /* Grid layouts based on participant count */
        .video-grid-container.grid-1 { grid-template-columns: 1fr; }
        .video-grid-container.grid-2 { grid-template-columns: 1fr 1fr; }
        .video-grid-container.grid-3 { grid-template-columns: 1fr 1fr; grid-template-rows: 1fr 1fr; }
        .video-grid-container.grid-4 { grid-template-columns: 1fr 1fr; grid-template-rows: 1fr 1fr; }
        .video-grid-container.grid-5,
        .video-grid-container.grid-6 { grid-template-columns: 1fr 1fr 1fr; grid-template-rows: 1fr 1fr; }

        .participant-video {
            position: relative;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            border-radius: 16px;
            overflow: hidden;
            border: 3px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            pointer-events: auto;
            min-height: 120px;
        }

        .participant-video.speaking {
            border-color: #06ffa5;
            box-shadow: 0 0 20px rgba(6, 255, 165, 0.4);
        }

        .participant-video.local {
            border-color: rgba(72, 219, 251, 0.6);
        }

        .participant-video.no-video {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .participant-video video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .participant-video .avatar-placeholder {
            display: none;
        }

        .participant-video.no-video .avatar-placeholder {
            display: flex;
        }

        .participant-video.no-video video {
            display: none;
        }

        .participant-video.local video {
            transform: scaleX(-1); /* Mirror self-view */
        }

        .participant-video .avatar-placeholder {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: linear-gradient(135deg, #ff6b6b, #feca57);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            color: white;
            text-transform: uppercase;
        }

        .participant-video .participant-info {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(transparent, rgba(0,0,0,0.85));
            padding: 20px 12px 10px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .participant-video .participant-name {
            font-size: 0.85rem;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .participant-video .speaking-indicator {
            width: 10px;
            height: 10px;
            background: #06ffa5;
            border-radius: 50%;
            animation: speakPulse 0.5s infinite;
            display: none;
        }

        .participant-video.speaking .speaking-indicator {
            display: block;
        }

        @keyframes speakPulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.3); opacity: 0.7; }
        }

        .participant-video .muted-icon {
            font-size: 0.9rem;
            opacity: 0.7;
        }

        /* ============ CALL CONTROLS BAR ============ */
        .call-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 80px;
            background: linear-gradient(transparent, rgba(0,0,0,0.95));
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            padding: 0 20px;
            z-index: 200;
        }

        .call-btn {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            font-size: 1.4rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            position: relative;
        }

        .call-btn:hover {
            transform: scale(1.1);
        }

        .call-btn:active {
            transform: scale(0.95);
        }

        .call-btn.video-btn {
            background: rgba(255, 255, 255, 0.15);
            color: white;
        }

        .call-btn.video-btn.active {
            background: #48dbfb;
            color: #000;
        }

        .call-btn.video-btn.off {
            background: rgba(255, 68, 68, 0.3);
            color: #ff4444;
        }

        .call-btn.mic-btn {
            background: rgba(255, 255, 255, 0.15);
            color: white;
        }

        .call-btn.mic-btn.muted {
            background: rgba(255, 68, 68, 0.3);
            color: #ff4444;
        }

        /* Press-to-talk button */
        .call-btn.ptt-btn {
            background: rgba(255, 255, 255, 0.15);
            color: white;
            width: 70px;
            height: 70px;
            font-size: 1.6rem;
        }

        .call-btn.ptt-btn:hover {
            background: rgba(6, 255, 165, 0.2);
        }

        .call-btn.ptt-btn.talking {
            background: linear-gradient(135deg, #06ffa5, #00d98b);
            color: #000;
            box-shadow: 0 0 30px rgba(6, 255, 165, 0.6);
            animation: talkingPulse 0.3s infinite;
        }

        @keyframes talkingPulse {
            0%, 100% { box-shadow: 0 0 20px rgba(6, 255, 165, 0.6); }
            50% { box-shadow: 0 0 40px rgba(6, 255, 165, 0.8); }
        }

        .call-btn.ptt-btn .ptt-label {
            position: absolute;
            bottom: -22px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.65rem;
            white-space: nowrap;
            opacity: 0.7;
        }

        .call-btn.end-btn {
            background: #ff4444;
            color: white;
        }

        .call-btn.end-btn:hover {
            background: #ff2222;
        }

        /* Tooltip for buttons */
        .call-btn::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 65px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 5px 10px;
            border-radius: 6px;
            font-size: 0.75rem;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
        }

        .call-btn:hover::after {
            opacity: 1;
        }

        /* ============ LIVE INDICATOR ============ */
        .live-badge {
            position: absolute;
            top: 10px;
            left: 10px;
            background: #ff4444;
            color: white;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 5px;
            z-index: 150;
        }

        .live-badge .live-dot {
            width: 6px;
            height: 6px;
            background: white;
            border-radius: 50%;
            animation: livePulse 1s infinite;
        }

        @keyframes livePulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Hide webcam controls in FaceTime mode */
        .facetime-mode .webcam-toggle-btn,
        .facetime-mode #localWebcam,
        .facetime-mode #remoteWebcamsContainer {
            display: none !important;
        }

        .video-placeholder {
            text-align: center;
            color: #666;
            padding: 40px;
        }

        .video-placeholder h3 {
            font-size: 1.5rem;
            margin-bottom: 10px;
            color: #888;
        }

        .sync-indicator {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.8);
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.75rem;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .sync-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ff4444;
        }

        .sync-dot.connected { background: #00cc66; }
        .sync-dot.syncing { background: #ffaa00; animation: pulse 1s infinite; }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .viewer-count {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.8);
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.75rem;
        }

        /* Video Controls */
        .video-controls {
            background: rgba(0,0,0,0.9);
            padding: 15px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }

        .video-url-input {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .video-url-input input {
            flex: 1;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            padding: 10px 15px;
            color: white;
            font-size: 0.9rem;
        }

        .video-url-input input::placeholder { color: #666; }
        .video-url-input input:focus { outline: none; border-color: #48dbfb; }

        .playback-controls {
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .control-btn {
            background: rgba(255,255,255,0.1);
            border: none;
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.2s;
        }

        .control-btn:hover { background: rgba(255,255,255,0.2); }
        .control-btn.primary { background: linear-gradient(90deg, #ff6b6b, #feca57); color: #000; }
        .control-btn:disabled { opacity: 0.5; cursor: not-allowed; }

        .progress-container {
            flex: 1;
            min-width: 200px;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: rgba(255,255,255,0.2);
            border-radius: 3px;
            cursor: pointer;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff6b6b, #feca57);
            border-radius: 3px;
            width: 0%;
            transition: width 0.1s;
        }

        .time-display {
            font-size: 0.8rem;
            color: #888;
            margin-top: 5px;
        }

        /* Sidebar */
        .sidebar {
            background: rgba(0,0,0,0.6);
            display: flex;
            flex-direction: column;
            border-left: 1px solid rgba(255,255,255,0.1);
        }

        .sidebar-tabs {
            display: flex;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .sidebar-tab {
            flex: 1;
            padding: 12px;
            background: transparent;
            border: none;
            color: #888;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s;
        }

        .sidebar-tab.active {
            color: #fff;
            background: rgba(255,255,255,0.1);
            border-bottom: 2px solid #48dbfb;
        }

        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            display: none;
        }

        .sidebar-content.active { display: flex; flex-direction: column; }

        /* Chat Panel */
        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
        }

        .chat-message {
            margin-bottom: 12px;
            animation: fadeIn 0.3s;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .chat-message .sender {
            font-size: 0.75rem;
            color: #48dbfb;
            margin-bottom: 3px;
        }

        .chat-message .text {
            background: rgba(255,255,255,0.1);
            padding: 8px 12px;
            border-radius: 12px;
            font-size: 0.85rem;
            word-wrap: break-word;
        }

        .chat-message.system .text {
            background: rgba(255,107,107,0.2);
            color: #ff6b6b;
            font-style: italic;
        }

        .chat-input-container {
            padding: 15px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }

        .chat-input-container input {
            width: 100%;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 20px;
            padding: 10px 15px;
            color: white;
            font-size: 0.9rem;
        }

        .chat-input-container input:focus { outline: none; border-color: #48dbfb; }

        /* Reactions */
        .reactions-bar {
            display: flex;
            gap: 5px;
            padding: 10px 15px;
            border-top: 1px solid rgba(255,255,255,0.1);
            flex-wrap: wrap;
        }

        .reaction-btn {
            background: rgba(255,255,255,0.1);
            border: none;
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .reaction-btn:hover { transform: scale(1.2); background: rgba(255,255,255,0.2); }

        /* Invite Panel */
        .invite-panel {
            padding: 20px;
        }

        .invite-panel h3 {
            color: #48dbfb;
            margin-bottom: 15px;
            font-size: 1rem;
        }

        .qr-container {
            background: white;
            padding: 15px;
            border-radius: 12px;
            text-align: center;
            margin-bottom: 15px;
        }

        .qr-container canvas, .qr-container img {
            max-width: 180px;
            height: auto;
        }

        .qr-placeholder {
            color: #666;
            padding: 40px 20px;
            font-size: 0.85rem;
        }

        .shareable-url {
            background: rgba(0,0,0,0.4);
            padding: 10px;
            border-radius: 8px;
            font-size: 0.7rem;
            font-family: monospace;
            word-break: break-all;
            margin-bottom: 15px;
            max-height: 60px;
            overflow-y: auto;
            color: #aaa;
        }

        .invite-buttons {
            display: flex;
            gap: 10px;
        }

        .invite-buttons button {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s;
        }

        .btn-copy {
            background: linear-gradient(90deg, #48dbfb, #0abde3);
            color: #000;
        }

        .btn-share {
            background: rgba(255,255,255,0.1);
            color: white;
            border: 1px solid rgba(255,255,255,0.2) !important;
        }

        /* Viewers Panel */
        .viewers-panel {
            padding: 20px;
        }

        .viewer-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            margin-bottom: 8px;
        }

        .viewer-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: linear-gradient(135deg, #ff6b6b, #feca57);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9rem;
        }

        .viewer-info {
            flex: 1;
        }

        .viewer-name {
            font-size: 0.9rem;
            font-weight: 500;
        }

        .viewer-status {
            font-size: 0.75rem;
            color: #888;
        }

        .host-badge {
            background: #feca57;
            color: #000;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.65rem;
            font-weight: bold;
        }

        /* Floating Reactions */
        .floating-reaction {
            position: fixed;
            font-size: 2rem;
            animation: floatUp 2s ease-out forwards;
            pointer-events: none;
            z-index: 1000;
        }

        @keyframes floatUp {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-200px) scale(1.5); }
        }

        /* Toast */
        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #333;
            color: white;
            padding: 12px 24px;
            border-radius: 25px;
            animation: slideUp 0.3s ease;
            z-index: 1000;
        }

        @keyframes slideUp {
            from { transform: translateX(-50%) translateY(20px); opacity: 0; }
            to { transform: translateX(-50%) translateY(0); opacity: 1; }
        }

        /* Data Controls */
        .data-controls {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1000;
            display: flex;
            gap: 8px;
        }

        .data-controls button {
            background: rgba(0,0,0,0.6);
            border: 1px solid rgba(255,255,255,0.2);
            color: white;
            padding: 6px 12px;
            border-radius: 15px;
            cursor: pointer;
            font-size: 0.75rem;
        }

        /* Setup Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .modal-overlay.hidden { display: none; }

        .modal {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            border-radius: 20px;
            padding: 30px;
            max-width: 450px;
            width: 90%;
            text-align: center;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .modal h2 {
            background: linear-gradient(90deg, #ff6b6b, #feca57, #48dbfb);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            color: transparent;
            margin-bottom: 10px;
        }

        .modal p {
            color: #888;
            margin-bottom: 25px;
            font-size: 0.9rem;
        }

        .modal-input {
            width: 100%;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 10px;
            padding: 12px 15px;
            color: white;
            font-size: 1rem;
            margin-bottom: 20px;
        }

        .modal-input:focus { outline: none; border-color: #48dbfb; }

        .modal-buttons {
            display: flex;
            gap: 15px;
        }

        .modal-buttons button {
            flex: 1;
            padding: 12px 20px;
            border: none;
            border-radius: 25px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .modal-buttons .btn-host {
            background: linear-gradient(90deg, #ff6b6b, #feca57);
            color: #000;
            font-weight: bold;
        }

        .modal-buttons .btn-join {
            background: rgba(255,255,255,0.1);
            color: white;
            border: 1px solid rgba(255,255,255,0.3);
        }

        .modal-buttons button:hover { transform: scale(1.02); }

        /* ============ SCREEN SHARE BUTTON ============ */
        .call-btn.screen-btn {
            background: rgba(255, 255, 255, 0.15);
            color: white;
        }

        .call-btn.screen-btn.active {
            background: #9b59b6;
            color: white;
            animation: screenSharePulse 2s infinite;
        }

        @keyframes screenSharePulse {
            0%, 100% { box-shadow: 0 0 10px rgba(155, 89, 182, 0.5); }
            50% { box-shadow: 0 0 25px rgba(155, 89, 182, 0.8); }
        }

        /* ============ RAISE HAND BUTTON ============ */
        .call-btn.hand-btn {
            background: rgba(255, 255, 255, 0.15);
            color: white;
        }

        .call-btn.hand-btn.raised {
            background: #f39c12;
            color: white;
            animation: handWave 0.5s infinite;
        }

        @keyframes handWave {
            0%, 100% { transform: rotate(-5deg); }
            50% { transform: rotate(5deg); }
        }

        .participant-video .hand-raised-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 1.5rem;
            animation: handWave 0.5s infinite;
            display: none;
        }

        .participant-video.hand-raised .hand-raised-indicator {
            display: block;
        }

        /* ============ AUDIO LEVEL INDICATOR ============ */
        .participant-video .audio-level-bar {
            position: absolute;
            left: 8px;
            top: 50%;
            transform: translateY(-50%);
            width: 4px;
            height: 60px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            overflow: hidden;
        }

        .participant-video .audio-level-fill {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(to top, #06ffa5, #48dbfb);
            border-radius: 2px;
            transition: height 0.05s ease-out;
            height: 0%;
        }

        /* ============ CONNECTION QUALITY ============ */
        .connection-quality {
            position: absolute;
            top: 10px;
            right: 70px;
            background: rgba(0, 0, 0, 0.8);
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.7rem;
            display: flex;
            align-items: center;
            gap: 5px;
            z-index: 150;
        }

        .connection-bars {
            display: flex;
            align-items: flex-end;
            gap: 2px;
            height: 12px;
        }

        .connection-bar {
            width: 3px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 1px;
        }

        .connection-bar:nth-child(1) { height: 4px; }
        .connection-bar:nth-child(2) { height: 7px; }
        .connection-bar:nth-child(3) { height: 10px; }
        .connection-bar:nth-child(4) { height: 12px; }

        .connection-quality.excellent .connection-bar { background: #06ffa5; }
        .connection-quality.good .connection-bar:nth-child(-n+3) { background: #48dbfb; }
        .connection-quality.fair .connection-bar:nth-child(-n+2) { background: #f39c12; }
        .connection-quality.poor .connection-bar:nth-child(1) { background: #ff4444; }

        /* ============ FULLSCREEN MODE ============ */
        .fullscreen-btn {
            position: absolute;
            bottom: 90px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            border: none;
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.2rem;
            z-index: 150;
            transition: all 0.2s;
        }

        .fullscreen-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        .video-section.fullscreen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 3000;
        }

        .video-section.fullscreen .video-wrapper {
            height: 100vh;
        }

        .video-section.fullscreen .video-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(transparent, rgba(0, 0, 0, 0.95));
        }

        /* ============ CHAT IMPROVEMENTS ============ */
        .chat-message .timestamp {
            font-size: 0.65rem;
            color: #666;
            margin-left: 8px;
        }

        .chat-message .message-reactions {
            display: flex;
            gap: 4px;
            margin-top: 4px;
            flex-wrap: wrap;
        }

        .chat-message .msg-reaction {
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .chat-message .msg-reaction:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .chat-message .add-reaction-btn {
            background: transparent;
            border: 1px dashed rgba(255, 255, 255, 0.3);
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.7rem;
            cursor: pointer;
            opacity: 0;
            transition: all 0.2s;
        }

        .chat-message:hover .add-reaction-btn {
            opacity: 1;
        }

        /* ============ KEYBOARD SHORTCUT HINTS ============ */
        .shortcut-hints {
            position: fixed;
            bottom: 100px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px;
            border-radius: 12px;
            font-size: 0.75rem;
            z-index: 100;
            display: none;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .shortcut-hints.visible {
            display: block;
            animation: fadeIn 0.3s;
        }

        .shortcut-hints h4 {
            color: #48dbfb;
            margin-bottom: 10px;
            font-size: 0.8rem;
        }

        .shortcut-item {
            display: flex;
            justify-content: space-between;
            gap: 20px;
            margin-bottom: 6px;
        }

        .shortcut-key {
            background: rgba(255, 255, 255, 0.15);
            padding: 2px 8px;
            border-radius: 4px;
            font-family: monospace;
        }

        /* ============ TYPING INDICATOR ============ */
        .typing-indicator {
            padding: 8px 15px;
            font-size: 0.75rem;
            color: #888;
            font-style: italic;
            display: none;
        }

        .typing-indicator.visible {
            display: block;
        }

        .typing-dots {
            display: inline-flex;
            gap: 3px;
        }

        .typing-dots span {
            width: 4px;
            height: 4px;
            background: #888;
            border-radius: 50%;
            animation: typingBounce 1s infinite;
        }

        .typing-dots span:nth-child(2) { animation-delay: 0.2s; }
        .typing-dots span:nth-child(3) { animation-delay: 0.4s; }

        @keyframes typingBounce {
            0%, 60%, 100% { transform: translateY(0); }
            30% { transform: translateY(-4px); }
        }

        /* ============ RECONNECTING OVERLAY ============ */
        .reconnecting-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2500;
            display: none;
        }

        .reconnecting-overlay.visible {
            display: flex;
        }

        .reconnecting-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255, 255, 255, 0.2);
            border-top-color: #48dbfb;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .reconnecting-overlay p {
            color: #888;
            font-size: 0.9rem;
        }

        .reconnecting-overlay .retry-count {
            color: #48dbfb;
            margin-top: 10px;
            font-size: 0.8rem;
        }

        /* ============ NOTIFICATION BADGE ============ */
        .sidebar-tab .notification-badge {
            background: #ff4444;
            color: white;
            font-size: 0.6rem;
            padding: 2px 5px;
            border-radius: 8px;
            margin-left: 5px;
            display: none;
        }

        .sidebar-tab .notification-badge.visible {
            display: inline;
        }
    </style>
</head>
<body>
    <div class="data-controls">
        <button onclick="exportData()">Export</button>
        <button onclick="document.getElementById('importFile').click()">Import</button>
        <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importData(event)">
    </div>

    <!-- Setup Modal -->
    <div id="setupModal" class="modal-overlay">
        <div class="modal">
            <h2>Watch Party</h2>
            <p>Watch videos together in perfect sync. No accounts needed!</p>
            <input type="text" id="nicknameInput" class="modal-input" placeholder="Your nickname..." maxlength="20">
            <div class="modal-buttons">
                <button class="btn-host" onclick="hostParty()">Host Party</button>
                <button class="btn-join" onclick="showJoinInput()">Join Party</button>
            </div>
            <div id="joinInputContainer" style="display: none; margin-top: 20px;">
                <input type="text" id="joinCodeInput" class="modal-input" placeholder="Paste invite link or party code...">
                <button class="btn-host" onclick="joinParty()" style="width: 100%; border-radius: 25px; padding: 12px; border: none; cursor: pointer;">Join</button>
            </div>
        </div>
    </div>

    <div class="header">
        <h1>Watch Party Sync</h1>
        <p>Synchronized viewing with friends - no accounts, pure P2P</p>
        <div class="party-badge">Zero Servers</div>
    </div>

    <div class="main-container">
        <!-- Video Section -->
        <div class="video-section">
            <div class="video-wrapper">
                <div class="sync-indicator">
                    <div id="syncDot" class="sync-dot"></div>
                    <span id="syncStatus">Not Connected</span>
                </div>
                <div id="viewerCount" class="viewer-count">1 viewer</div>

                <!-- Connection Quality Indicator -->
                <div id="connectionQuality" class="connection-quality excellent" style="display: none;">
                    <div class="connection-bars">
                        <div class="connection-bar"></div>
                        <div class="connection-bar"></div>
                        <div class="connection-bar"></div>
                        <div class="connection-bar"></div>
                    </div>
                    <span id="connectionPing">--ms</span>
                </div>

                <!-- Fullscreen Button -->
                <button id="fullscreenBtn" class="fullscreen-btn" onclick="toggleFullscreen()" title="Toggle Fullscreen (F)">
                    ‚õ∂
                </button>

                <video id="mainVideo" style="display: none;"></video>
                <div id="youtubeContainer" style="display: none; width: 100%; height: 100%;">
                    <div id="youtubePlayer"></div>
                </div>
                <div id="videoPlaceholder" class="video-placeholder">
                    <h3>No Video Loaded</h3>
                    <p>Paste a YouTube link or video URL below</p>
                    <p style="color: #48dbfb; margin-top: 10px; font-size: 0.85rem;">Supports: YouTube, MP4, WebM</p>
                </div>

                <!-- Live Badge -->
                <div id="liveBadge" class="live-badge" style="display: none;">
                    <div class="live-dot"></div>
                    <span>LIVE</span>
                </div>

                <!-- FaceTime-style Video Grid for all participants -->
                <div id="videoGrid" class="video-grid-container hidden grid-1">
                    <!-- Local participant (self) -->
                    <div id="localParticipant" class="participant-video local no-video">
                        <video id="localWebcamVideo" autoplay muted playsinline></video>
                        <div class="avatar-placeholder" id="localAvatar">?</div>
                        <div class="audio-level-bar">
                            <div class="audio-level-fill" id="localAudioLevel"></div>
                        </div>
                        <span class="hand-raised-indicator">‚úã</span>
                        <div class="participant-info">
                            <span class="participant-name">
                                <span id="localNickname">You</span>
                                <span class="speaking-indicator"></span>
                            </span>
                            <span class="muted-icon" id="localMutedIcon">üé§</span>
                        </div>
                    </div>
                    <!-- Remote participants will be added dynamically -->
                </div>

                <!-- FaceTime-style Call Controls -->
                <div id="callControls" class="call-controls" style="display: none;">
                    <button class="call-btn video-btn" id="videoToggleBtn" onclick="toggleVideo()" data-tooltip="Video (V)">
                        üìπ
                    </button>
                    <button class="call-btn mic-btn" id="micToggleBtn" onclick="toggleMic()" data-tooltip="Mute (M)">
                        üé§
                    </button>
                    <button class="call-btn screen-btn" id="screenShareBtn" onclick="toggleScreenShare()" data-tooltip="Screen Share (S)">
                        üñ•Ô∏è
                    </button>
                    <button class="call-btn ptt-btn" id="pttBtn" onmousedown="startTalking()" onmouseup="stopTalking()" ontouchstart="startTalking()" ontouchend="stopTalking()" data-tooltip="Hold to Talk (Space)">
                        üó£Ô∏è
                        <span class="ptt-label">PUSH TO TALK</span>
                    </button>
                    <button class="call-btn hand-btn" id="raiseHandBtn" onclick="toggleRaiseHand()" data-tooltip="Raise Hand (H)">
                        ‚úã
                    </button>
                    <button class="call-btn end-btn" id="endCallBtn" onclick="endCall()" data-tooltip="Leave Call">
                        üìû
                    </button>
                </div>
            </div>

            <div class="video-controls">
                <div class="video-url-input">
                    <input type="text" id="videoUrlInput" placeholder="Paste YouTube link or video URL...">
                    <button class="control-btn primary" onclick="loadVideo()">Load</button>
                    <label class="control-btn" style="cursor: pointer;">
                        Upload
                        <input type="file" accept="video/*" style="display: none;" onchange="loadLocalVideo(event)">
                    </label>
                </div>

                <div class="playback-controls">
                    <button id="playPauseBtn" class="control-btn" onclick="togglePlayPause()" disabled>Play</button>
                    <button class="control-btn" onclick="skip(-10)" disabled id="skipBackBtn">-10s</button>
                    <button class="control-btn" onclick="skip(10)" disabled id="skipFwdBtn">+10s</button>

                    <div class="progress-container">
                        <div class="progress-bar" onclick="seekVideo(event)" id="progressBar">
                            <div class="progress-fill" id="progressFill"></div>
                        </div>
                        <div class="time-display">
                            <span id="currentTime">0:00</span> / <span id="duration">0:00</span>
                        </div>
                    </div>

                    <button id="syncBtn" class="control-btn" onclick="requestSync()" disabled>Sync</button>
                </div>
            </div>
        </div>

        <!-- Sidebar -->
        <div class="sidebar">
            <div class="sidebar-tabs">
                <button class="sidebar-tab active" onclick="switchSidebarTab('chat')">Chat<span id="chatBadge" class="notification-badge">0</span></button>
                <button class="sidebar-tab" onclick="switchSidebarTab('invite')">Invite</button>
                <button class="sidebar-tab" onclick="switchSidebarTab('viewers')">Viewers</button>
            </div>

            <!-- Chat Panel -->
            <div id="chatPanel" class="sidebar-content active">
                <div class="chat-messages" id="chatMessages"></div>
                <div id="typingIndicator" class="typing-indicator">
                    <span id="typingNames">Someone</span> is typing<span class="typing-dots"><span></span><span></span><span></span></span>
                </div>
                <div class="reactions-bar">
                    <button class="reaction-btn" onclick="sendReaction('fire')">üî•</button>
                    <button class="reaction-btn" onclick="sendReaction('laugh')">üòÇ</button>
                    <button class="reaction-btn" onclick="sendReaction('wow')">üòÆ</button>
                    <button class="reaction-btn" onclick="sendReaction('sad')">üò¢</button>
                    <button class="reaction-btn" onclick="sendReaction('heart')">‚ù§Ô∏è</button>
                    <button class="reaction-btn" onclick="sendReaction('clap')">üëè</button>
                </div>
                <div class="chat-input-container">
                    <input type="text" id="chatInput" placeholder="Type a message..." onkeypress="handleChatKeypress(event)">
                </div>
            </div>

            <!-- Invite Panel -->
            <div id="invitePanel" class="sidebar-content">
                <div class="invite-panel">
                    <h3>Invite Friends</h3>
                    <div class="qr-container" id="qrContainer">
                        <div class="qr-placeholder">Start hosting to generate invite QR code</div>
                    </div>
                    <div class="shareable-url" id="shareableUrl">Invite link will appear here...</div>
                    <div class="invite-buttons">
                        <button class="btn-copy" onclick="copyInviteLink()">Copy Link</button>
                        <button class="btn-share" onclick="shareInvite()">Share</button>
                    </div>
                </div>
            </div>

            <!-- Viewers Panel -->
            <div id="viewersPanel" class="sidebar-content">
                <div class="viewers-panel" id="viewersList">
                    <!-- Viewers will be listed here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Keyboard Shortcuts Panel -->
    <div id="shortcutHints" class="shortcut-hints">
        <h4>Keyboard Shortcuts</h4>
        <div class="shortcut-item"><span>Push to Talk</span><span class="shortcut-key">Space</span></div>
        <div class="shortcut-item"><span>Toggle Video</span><span class="shortcut-key">V</span></div>
        <div class="shortcut-item"><span>Toggle Mute</span><span class="shortcut-key">M</span></div>
        <div class="shortcut-item"><span>Screen Share</span><span class="shortcut-key">S</span></div>
        <div class="shortcut-item"><span>Raise Hand</span><span class="shortcut-key">H</span></div>
        <div class="shortcut-item"><span>Fullscreen</span><span class="shortcut-key">F</span></div>
        <div class="shortcut-item"><span>Show/Hide Hints</span><span class="shortcut-key">?</span></div>
    </div>

    <!-- Reconnecting Overlay -->
    <div id="reconnectingOverlay" class="reconnecting-overlay">
        <div class="reconnecting-spinner"></div>
        <p>Connection lost. Reconnecting...</p>
        <span id="retryCount" class="retry-count">Attempt 1 of 5</span>
    </div>

    <!-- PeerJS Library -->
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>

    <script>
        // ==================== APP CONFIG ====================
        const APP_NAME = 'watch-party-sync';
        let appData = JSON.parse(localStorage.getItem(APP_NAME) || '{"parties": [], "nickname": ""}');

        // ==================== STATE ====================
        let peer = null;
        let peerId = null;
        let connections = [];
        let isHost = false;
        let nickname = '';
        let viewers = [];
        let currentShareableUrl = '';

        // Video state
        let videoLoaded = false;
        let isSyncing = false;
        let isYouTube = false;
        let ytPlayer = null;
        let ytReady = false;
        let ytProgressInterval = null;

        // Webcam state
        let webcamStream = null;
        let webcamEnabled = false;
        let mediaCalls = [];  // PeerJS media calls for streaming webcam

        // FaceTime mode state
        let videoEnabled = false;
        let micEnabled = false;
        let isTalking = false;
        let audioStream = null;
        let localVideoStream = null;
        let remoteParticipants = new Map();  // peerId -> { stream, nickname, videoElement }
        let audioAnalyser = null;
        let audioContext = null;
        let speakingCheckInterval = null;

        // Enhanced features state
        let screenShareStream = null;
        let screenShareEnabled = false;
        let handRaised = false;
        let isFullscreen = false;
        let typingTimeout = null;
        let typingUsers = new Set();
        let unreadChatCount = 0;
        let chatTabActive = true;
        let reconnectAttempts = 0;
        let maxReconnectAttempts = 5;
        let reconnectTimeout = null;
        let lastHostId = null;
        let pingInterval = null;
        let lastPingTime = 0;
        let audioLevelInterval = null;

        // Notification sounds (base64 encoded short beeps)
        const SOUNDS = {
            join: 'data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdH2IkI+NhHpxbWx2goySlI+JgHdwbXF7houQkY6GfXNrZ2t1goyUmJeRiX5za2dqc36JkpaTjoR4bmZlbHeCjZaXlI2BdWxoaXB8iJCTkY2DdmtlZG15g46Tlo+JfnJqZmhye4aOkpKOhXlvaWdrdYCKkZSRjIF3bmlobnl/iZCSkIuBdW1panF7g4uQj4uEenBqaGtzfYaOj42JgHVtaWltdn+HjI6LhX10bmtqb3eBho2PjIiAdG1ram5zgYaLjYuGgHZwbmxwc3+FioyKhYB2cG5scXV+g4mLioWAdXBubXF2foWJi4mEf3VwbnB0eICFiYqHgn12cXB0eH2Dh4mHg391cnF0d3t/hIeHhIB8eHV1eHp+goWGhYN/fHh3eHp8gIKFhYSBf3x5eHl7fYGDhIOCgH17eXl6fH6BgoOCgX9+fHp6e3x+gIGCgYCAf318e3t8fX+AgoGBgIB+fXx8fH1+gIGBgYCAf358fHx9fn+AgYGAf39+fXx9fX5+f4CAgICAf358fX1+fn9/gICAf39+fX19fn5/f4CAgH9/fn5+fn5+f3+AgIB/f35+fn5+fn9/f4CAf39/fn5+fn5/f3+Af39/f35+fn5+f39/f4B/f39+fn5+fn9/f39/f39/fn5+fn5/f39/f39/f35+fn5+f39/f39/f39+fn5+fn9/f39/f39/fn5+fn5/f39/f39/f35+fn5+f39/f39/f39+fn5+',
            leave: 'data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAAB/f39/fn5+fn5/f39/f39/f35+fn5+f39/f39/f39+fn5+fn9/f39/f39/fn5+fn5/f39/f39/f35+fn5+f39/f39/f39+fn5+fn9/f39/f39/fn5+fn5/f39/f39/f39+fn5+f3+AgIB/f39/fn5+fn5/f4CAgH9/f39+fn5+fn9/f4CAf39/f35+fn5+f3+AgIB/f3+Af359fX5+f4CAgYCAf399fHx9fn+AgYKBgH9+fXx8fX5/gIGBgYB/fn18fH1+f4CBgYGAf358fHx9fn+BgoKBgH9+fHt7fX6AgYOCgYB+fHp6e31/gYODgoF/fXp5ent+gIOEg4KAfnx5eXp8foGEhIOBf3x5d3h6fYCDhYSDgX56d3Z4en2Bg4aFg4B8eHZ1d3p9goWGhYOAfHh1dXd5fIGFh4aEgX15dXR2eXyBhYiHhIJ+eXV0dnh7gIWIiIWCfnl0c3V3e4CFiImGg396dXNzdnp/hImKh4SAfnhzc3V4fIKHioqHg398d3NzdXl9goiKioeDf3t3dHR2en6EiYuKhoN/e3d0dHZ6foSJi4qHg398d3R0dnp+hImLioeDf3t4dXV3e3+FiYuKh4OAfHl2dnl8gIWJi4qHg4B8eXZ3eXyAhYmLioeDgHx5dnZ5e4CFiYuKh4OAfHl3dnh7gIWJi4qHg4B8eXd3eXuAhYmLioeDgHx5d3d5e3+FiIqJhoN/fHl3d3l7f4SIiomGg398eXd3eXt/hIiKiYaDf3x5d3d5e3+EiImJhoN/',
            hand: 'data:audio/wav;base64,UklGRl4FAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YToFAAB/fn18e3p5eHd2dXRzcnFwb25tbGtqaWhnZmVkY2JhYF9eXVxbWllYV1ZVVFNSUVBPTk1MS0pJSEdGRURDQkFAPz49PDs6OTg3NjU0MzIxMC8uLSwrKikoJyYlJCMiISAfHh0cGxoZGBcWFRQTEhEQDw4NDAsKCQgHBgUEAwIBAQECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWltcXV5fYGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6e3x9fn+AgYKDhIWGh4iJiouMjY6PkJGSk5SVlpeYmZqbnJ2en6ChoqOkpaanqKmqq6ytrq+wsbKztLW2t7i5uru8vb6/wMHCw8TFxsfIycrLzM3Oz9DR0tPU1dbX2Nna29zd3t/g4eLj5OXm5+jp6uvs7e7v8PHy8/T19vf4+fr7/P3+/v39/Pv6+fj39vX08/Lx8O/u7ezr6uno5+bl5OPi4eDf3t3c29rZ2NfW1dTT0tHQz87NzMvKycjHxsXEw8LBwL++vby7urm4t7a1tLOysbCvrq2sq6qpqKempaOioaCfnp2cm5qZmJeWlZSTkpGQj46NjIuKiYiHhoWEg4KBgH9+fXx7enl4d3Z1dA=='
        };

        // ==================== PEER SETUP ====================

        function initPeer() {
            return new Promise((resolve, reject) => {
                peer = new Peer();

                peer.on('open', (id) => {
                    peerId = id;
                    console.log('My peer ID:', id);
                    resolve(id);
                });

                peer.on('error', (err) => {
                    console.error('Peer error:', err);
                    showToast('Connection error: ' + err.type, 'error');
                    reject(err);
                });

                peer.on('connection', (conn) => {
                    handleIncomingConnection(conn);
                });

                // Handle incoming media calls (webcam streams)
                peer.on('call', (call) => {
                    handleIncomingCall(call);
                });
            });
        }

        function handleIncomingConnection(conn) {
            console.log('Incoming connection from:', conn.peer);

            conn.on('open', () => {
                connections.push(conn);
                updateViewerCount();

                // Send current state to new viewer
                if (isHost) {
                    sendToConnection(conn, {
                        type: 'init',
                        hostNickname: nickname,
                        videoUrl: document.getElementById('videoUrlInput').value,
                        videoState: getVideoState(),
                        viewers: viewers
                    });
                }

                // Stream our video/audio to new peer if we have any
                setTimeout(() => {
                    if (localVideoStream || (audioStream && isTalking)) {
                        streamToPeer(conn.peer);
                    }
                }, 500);

                // Add placeholder for new participant
                const newNickname = conn.metadata?.nickname || 'Guest';
                addRemoteParticipant(conn.peer, newNickname, null);

                addSystemMessage(`${newNickname} joined the party!`);
            });

            conn.on('data', (data) => {
                handleMessage(conn, data);
            });

            conn.on('close', () => {
                connections = connections.filter(c => c !== conn);
                viewers = viewers.filter(v => v.peerId !== conn.peer);
                updateViewerCount();
                updateViewersList();
                broadcastViewers();

                // Remove from video grid
                removeRemoteParticipant(conn.peer);

                // Remove audio element if any
                const audioEl = document.getElementById(`audio-${conn.peer}`);
                if (audioEl) audioEl.remove();

                addSystemMessage(`${conn.metadata?.nickname || 'Someone'} left the party`);
            });
        }

        function connectToPeer(hostId) {
            return new Promise((resolve, reject) => {
                const conn = peer.connect(hostId, {
                    metadata: { nickname: nickname }
                });

                conn.on('open', () => {
                    connections.push(conn);
                    console.log('Connected to host:', hostId);

                    // Send join message
                    sendToConnection(conn, {
                        type: 'join',
                        nickname: nickname,
                        peerId: peerId
                    });

                    resolve(conn);
                });

                conn.on('data', (data) => {
                    handleMessage(conn, data);
                });

                conn.on('close', () => {
                    connections = connections.filter(c => c !== conn);
                    updateSyncStatus('disconnected');
                    showToast('Disconnected from host');
                });

                conn.on('error', reject);
            });
        }

        // ==================== MESSAGE HANDLING ====================

        function handleMessage(conn, data) {
            console.log('Received:', data.type);

            switch (data.type) {
                case 'init':
                    // Initial state from host
                    if (data.videoUrl) {
                        document.getElementById('videoUrlInput').value = data.videoUrl;
                        loadVideo(false); // Don't broadcast
                    }
                    if (data.videoState) {
                        applyVideoState(data.videoState);
                    }
                    viewers = data.viewers || [];
                    updateViewersList();
                    updateSyncStatus('connected');
                    break;

                case 'join':
                    // New viewer joined (host receives this)
                    viewers.push({
                        peerId: data.peerId,
                        nickname: data.nickname,
                        isHost: false
                    });
                    updateViewersList();
                    broadcastViewers();
                    break;

                case 'viewers':
                    // Updated viewers list
                    viewers = data.viewers;
                    updateViewersList();
                    break;

                case 'video-load':
                    document.getElementById('videoUrlInput').value = data.url;
                    loadVideo(false);
                    break;

                case 'play':
                    playVideo(false);
                    if (data.time !== undefined) {
                        seekToTime(data.time);
                    }
                    break;

                case 'pause':
                    pauseVideo(false);
                    if (data.time !== undefined) {
                        seekToTime(data.time);
                    }
                    break;

                case 'seek':
                    seekToTime(data.time);
                    break;

                case 'sync':
                    applyVideoState(data.state);
                    break;

                case 'sync-request':
                    if (isHost) {
                        broadcast({ type: 'sync', state: getVideoState() });
                    }
                    break;

                case 'chat':
                    addChatMessage(data.nickname, data.message);
                    break;

                case 'reaction':
                    showFloatingReaction(data.emoji);
                    break;

                case 'webcam-stopped':
                    // Host stopped their webcam (legacy)
                    break;

                case 'video-state':
                    // Participant toggled their video
                    const pVideo = document.getElementById(`participant-${data.peerId}`);
                    if (pVideo) {
                        if (data.videoEnabled) {
                            pVideo.classList.remove('no-video');
                        } else {
                            pVideo.classList.add('no-video');
                        }
                    }
                    break;

                case 'ptt-start':
                    // Someone started talking
                    setParticipantSpeaking(data.peerId, true);
                    addSystemMessage(`${data.nickname || 'Someone'} is talking...`);
                    break;

                case 'ptt-stop':
                    // Someone stopped talking
                    setParticipantSpeaking(data.peerId, false);
                    break;

                case 'hand-raise':
                    setParticipantHandRaised(data.peerId, data.raised);
                    if (data.raised) {
                        playSound('hand');
                        addSystemMessage(`${data.nickname || 'Someone'} raised their hand`);
                    }
                    break;

                case 'screen-share':
                    if (data.sharing) {
                        addSystemMessage(`${data.nickname || 'Someone'} started screen sharing`);
                    } else {
                        addSystemMessage(`${data.nickname || 'Someone'} stopped screen sharing`);
                    }
                    break;

                case 'typing':
                    handleTypingIndicator(data.nickname, data.isTyping);
                    break;

                case 'ping':
                    // Respond to ping with pong
                    sendToConnection(conn, { type: 'pong', timestamp: data.timestamp });
                    break;

                case 'pong':
                    // Calculate ping
                    const ping = Date.now() - data.timestamp;
                    updateConnectionQuality(ping);
                    break;

                case 'chat-reaction':
                    addReactionToMessage(data.messageId, data.emoji);
                    break;
            }
        }

        function sendToConnection(conn, data) {
            if (conn.open) {
                conn.send(data);
            }
        }

        function broadcast(data) {
            connections.forEach(conn => sendToConnection(conn, data));
        }

        function broadcastViewers() {
            broadcast({ type: 'viewers', viewers: viewers });
        }

        // ==================== HOST / JOIN ====================

        async function hostParty() {
            nickname = document.getElementById('nicknameInput').value.trim() || 'Host';
            appData.nickname = nickname;
            saveData();

            isHost = true;
            document.getElementById('setupModal').classList.add('hidden');

            try {
                await initPeer();

                viewers = [{
                    peerId: peerId,
                    nickname: nickname,
                    isHost: true
                }];

                updateViewersList();
                generateInviteQR();
                updateSyncStatus('connected');
                showToast('Party started! Share the invite link.');
                enableControls(true);

                // Show FaceTime UI
                showFaceTimeUI();

                // Start connection quality monitoring
                startPingMonitoring();

            } catch (err) {
                showToast('Failed to start party: ' + err.message, 'error');
            }
        }

        function showJoinInput() {
            document.getElementById('joinInputContainer').style.display = 'block';

            // Check URL for party code
            const urlParams = new URLSearchParams(window.location.search);
            const partyCode = urlParams.get('party');
            if (partyCode) {
                document.getElementById('joinCodeInput').value = partyCode;
            }
        }

        async function joinParty() {
            nickname = document.getElementById('nicknameInput').value.trim() || 'Guest';
            appData.nickname = nickname;
            saveData();

            let joinInput = document.getElementById('joinCodeInput').value.trim();

            // Extract party code from URL if full URL pasted
            if (joinInput.includes('?party=')) {
                const url = new URL(joinInput);
                joinInput = url.searchParams.get('party');
            }

            if (!joinInput) {
                showToast('Please enter a party code or link', 'error');
                return;
            }

            isHost = false;
            document.getElementById('setupModal').classList.add('hidden');
            updateSyncStatus('syncing');

            try {
                await initPeer();
                await connectToPeer(joinInput);

                // Save host ID for auto-reconnection
                lastHostId = joinInput;

                showToast('Joined the party!');
                enableControls(false); // Viewers have limited controls

                // Show FaceTime UI
                showFaceTimeUI();

                // Start connection quality monitoring
                startPingMonitoring();

                // Clean URL
                window.history.replaceState({}, document.title, window.location.pathname);

            } catch (err) {
                showToast('Failed to join: ' + err.message, 'error');
                document.getElementById('setupModal').classList.remove('hidden');
            }
        }

        // ==================== YOUTUBE SUPPORT ====================

        // Extract YouTube video ID from various URL formats
        function getYouTubeVideoId(url) {
            const patterns = [
                /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/|youtube\.com\/v\/|youtube\.com\/shorts\/)([a-zA-Z0-9_-]{11})/,
                /^([a-zA-Z0-9_-]{11})$/  // Just the ID
            ];
            for (const pattern of patterns) {
                const match = url.match(pattern);
                if (match) return match[1];
            }
            return null;
        }

        // Load YouTube IFrame API
        function loadYouTubeAPI() {
            return new Promise((resolve, reject) => {
                if (window.YT && window.YT.Player) {
                    resolve();
                    return;
                }

                // Set up callback before loading script
                window.onYouTubeIframeAPIReady = () => {
                    console.log('YouTube API ready');
                    resolve();
                };

                const script = document.createElement('script');
                script.src = 'https://www.youtube.com/iframe_api';
                script.onerror = reject;
                document.head.appendChild(script);

                // Timeout fallback
                setTimeout(() => reject(new Error('YouTube API load timeout')), 10000);
            });
        }

        // Create YouTube player
        function createYouTubePlayer(videoId) {
            return new Promise((resolve, reject) => {
                try {
                    // Clear any existing player
                    if (ytPlayer) {
                        ytPlayer.destroy();
                        ytPlayer = null;
                    }

                    const container = document.getElementById('youtubePlayer');
                    container.innerHTML = '';

                    ytPlayer = new YT.Player('youtubePlayer', {
                        width: '100%',
                        height: '100%',
                        videoId: videoId,
                        playerVars: {
                            autoplay: 0,
                            controls: 0,  // Hide YouTube controls (we use our own)
                            disablekb: 1, // Disable keyboard controls
                            modestbranding: 1,
                            rel: 0,
                            fs: 0,
                            playsinline: 1
                        },
                        events: {
                            onReady: (event) => {
                                ytReady = true;
                                videoLoaded = true;
                                enablePlaybackControls(true);
                                updateYouTubeDuration();
                                startYouTubeProgressUpdate();
                                showToast('YouTube video loaded!');
                                resolve(event.target);
                            },
                            onStateChange: (event) => {
                                handleYouTubeStateChange(event);
                            },
                            onError: (event) => {
                                console.error('YouTube error:', event.data);
                                showToast('YouTube video error', 'error');
                                reject(new Error('YouTube error: ' + event.data));
                            }
                        }
                    });
                } catch (err) {
                    reject(err);
                }
            });
        }

        function handleYouTubeStateChange(event) {
            // YT.PlayerState: UNSTARTED (-1), ENDED (0), PLAYING (1), PAUSED (2), BUFFERING (3), CUED (5)
            if (event.data === YT.PlayerState.PLAYING) {
                document.getElementById('playPauseBtn').textContent = 'Pause';
            } else if (event.data === YT.PlayerState.PAUSED) {
                document.getElementById('playPauseBtn').textContent = 'Play';
            }
        }

        function startYouTubeProgressUpdate() {
            if (ytProgressInterval) clearInterval(ytProgressInterval);
            ytProgressInterval = setInterval(() => {
                if (ytPlayer && ytReady) {
                    updateYouTubeProgress();
                }
            }, 250);
        }

        function updateYouTubeProgress() {
            if (!ytPlayer || !ytReady) return;
            try {
                const currentTime = ytPlayer.getCurrentTime();
                const duration = ytPlayer.getDuration();
                const progress = (currentTime / duration) * 100;
                document.getElementById('progressFill').style.width = progress + '%';
                document.getElementById('currentTime').textContent = formatTime(currentTime);
            } catch (e) {}
        }

        function updateYouTubeDuration() {
            if (!ytPlayer || !ytReady) return;
            try {
                const duration = ytPlayer.getDuration();
                document.getElementById('duration').textContent = formatTime(duration);
            } catch (e) {}
        }

        // ==================== VIDEO CONTROLS ====================

        function loadVideo(shouldBroadcast = true) {
            const url = document.getElementById('videoUrlInput').value.trim();
            if (!url) {
                showToast('Please enter a video URL', 'error');
                return;
            }

            // Check if it's a YouTube URL
            const ytVideoId = getYouTubeVideoId(url);

            if (ytVideoId) {
                // Load as YouTube
                isYouTube = true;
                document.getElementById('mainVideo').style.display = 'none';
                document.getElementById('youtubeContainer').style.display = 'block';
                document.getElementById('videoPlaceholder').style.display = 'none';

                loadYouTubeAPI()
                    .then(() => createYouTubePlayer(ytVideoId))
                    .catch(err => {
                        showToast('Failed to load YouTube: ' + err.message, 'error');
                        console.error(err);
                    });
            } else {
                // Load as regular video
                isYouTube = false;
                if (ytProgressInterval) clearInterval(ytProgressInterval);

                document.getElementById('youtubeContainer').style.display = 'none';
                const video = document.getElementById('mainVideo');
                video.src = url;
                video.style.display = 'block';
                document.getElementById('videoPlaceholder').style.display = 'none';

                video.onloadedmetadata = () => {
                    videoLoaded = true;
                    enablePlaybackControls(true);
                    updateDuration();
                    showToast('Video loaded!');
                };

                video.onerror = () => {
                    showToast('Failed to load video. Check the URL.', 'error');
                };

                video.ontimeupdate = updateProgress;
            }

            if (shouldBroadcast && isHost) {
                broadcast({ type: 'video-load', url: url });
            }
        }

        function loadLocalVideo(event) {
            const file = event.target.files[0];
            if (!file) return;

            isYouTube = false;
            if (ytProgressInterval) clearInterval(ytProgressInterval);

            const url = URL.createObjectURL(file);
            document.getElementById('videoUrlInput').value = `[Local: ${file.name}]`;

            document.getElementById('youtubeContainer').style.display = 'none';
            const video = document.getElementById('mainVideo');
            video.src = url;
            video.style.display = 'block';
            document.getElementById('videoPlaceholder').style.display = 'none';

            video.onloadedmetadata = () => {
                videoLoaded = true;
                enablePlaybackControls(true);
                updateDuration();
                showToast('Local video loaded!');
            };

            video.ontimeupdate = updateProgress;

            if (connections.length > 0) {
                addSystemMessage('Note: Local videos cannot be synced. Use a YouTube or direct URL for sync.');
            }
        }

        function togglePlayPause() {
            if (isYouTube && ytPlayer && ytReady) {
                const state = ytPlayer.getPlayerState();
                if (state === YT.PlayerState.PLAYING) {
                    pauseVideo(true);
                } else {
                    playVideo(true);
                }
            } else {
                const video = document.getElementById('mainVideo');
                if (video.paused) {
                    playVideo(true);
                } else {
                    pauseVideo(true);
                }
            }
        }

        function playVideo(shouldBroadcast = true) {
            if (isYouTube && ytPlayer && ytReady) {
                ytPlayer.playVideo();
            } else {
                const video = document.getElementById('mainVideo');
                video.play();
            }
            document.getElementById('playPauseBtn').textContent = 'Pause';

            if (shouldBroadcast && isHost) {
                broadcast({ type: 'play', time: getCurrentTime() });
            }
        }

        function pauseVideo(shouldBroadcast = true) {
            if (isYouTube && ytPlayer && ytReady) {
                ytPlayer.pauseVideo();
            } else {
                const video = document.getElementById('mainVideo');
                video.pause();
            }
            document.getElementById('playPauseBtn').textContent = 'Play';

            if (shouldBroadcast && isHost) {
                broadcast({ type: 'pause', time: getCurrentTime() });
            }
        }

        function skip(seconds) {
            const currentTime = getCurrentTime();
            const duration = getDuration();
            const newTime = Math.max(0, Math.min(duration, currentTime + seconds));
            seekToTime(newTime);

            if (isHost) {
                broadcast({ type: 'seek', time: newTime });
            }
        }

        function seekVideo(event) {
            if (!isHost) return; // Only host can seek

            const bar = document.getElementById('progressBar');
            const rect = bar.getBoundingClientRect();
            const pos = (event.clientX - rect.left) / rect.width;

            const duration = getDuration();
            const newTime = pos * duration;
            seekToTime(newTime);

            broadcast({ type: 'seek', time: newTime });
        }

        function seekToTime(time) {
            if (isYouTube && ytPlayer && ytReady) {
                ytPlayer.seekTo(time, true);
            } else {
                const video = document.getElementById('mainVideo');
                video.currentTime = time;
            }
        }

        function getCurrentTime() {
            if (isYouTube && ytPlayer && ytReady) {
                return ytPlayer.getCurrentTime();
            } else {
                return document.getElementById('mainVideo').currentTime;
            }
        }

        function getDuration() {
            if (isYouTube && ytPlayer && ytReady) {
                return ytPlayer.getDuration();
            } else {
                return document.getElementById('mainVideo').duration;
            }
        }

        function isPaused() {
            if (isYouTube && ytPlayer && ytReady) {
                return ytPlayer.getPlayerState() !== YT.PlayerState.PLAYING;
            } else {
                return document.getElementById('mainVideo').paused;
            }
        }

        function requestSync() {
            if (!isHost && connections.length > 0) {
                connections[0].send({ type: 'sync-request' });
                showToast('Requesting sync...');
            } else if (isHost) {
                broadcast({ type: 'sync', state: getVideoState() });
                showToast('Synced all viewers');
            }
        }

        function getVideoState() {
            return {
                currentTime: getCurrentTime(),
                paused: isPaused(),
                isYouTube: isYouTube
            };
        }

        function applyVideoState(state) {
            const currentTime = getCurrentTime();
            if (Math.abs(currentTime - state.currentTime) > 1) {
                seekToTime(state.currentTime);
            }
            if (state.paused && !isPaused()) {
                pauseVideo(false);
            } else if (!state.paused && isPaused()) {
                playVideo(false);
            }
        }

        function updateProgress() {
            const video = document.getElementById('mainVideo');
            const progress = (video.currentTime / video.duration) * 100;
            document.getElementById('progressFill').style.width = progress + '%';
            document.getElementById('currentTime').textContent = formatTime(video.currentTime);
        }

        function updateDuration() {
            const video = document.getElementById('mainVideo');
            document.getElementById('duration').textContent = formatTime(video.duration);
        }

        function formatTime(seconds) {
            if (isNaN(seconds)) return '0:00';
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function enableControls(full) {
            document.getElementById('syncBtn').disabled = false;
            if (full) {
                enablePlaybackControls(videoLoaded);
            }
        }

        function enablePlaybackControls(enabled) {
            document.getElementById('playPauseBtn').disabled = !enabled;
            document.getElementById('skipBackBtn').disabled = !enabled || !isHost;
            document.getElementById('skipFwdBtn').disabled = !enabled || !isHost;
        }

        // ==================== CHAT & REACTIONS ====================

        function handleChatKeypress(event) {
            if (event.key === 'Enter') {
                const input = document.getElementById('chatInput');
                const message = input.value.trim();
                if (message) {
                    addChatMessage(nickname, message);
                    broadcast({ type: 'chat', nickname: nickname, message: message });
                    input.value = '';
                    // Clear typing indicator
                    broadcast({ type: 'typing', nickname: nickname, isTyping: false });
                }
            } else {
                // Trigger typing indicator
                handleChatTyping();
            }
        }

        function addChatMessage(sender, text) {
            addChatMessageWithFeatures(sender, text, sender === nickname);
        }

        function addSystemMessage(text) {
            const container = document.getElementById('chatMessages');
            const msg = document.createElement('div');
            msg.className = 'chat-message system';
            msg.innerHTML = `<div class="text">${escapeHtml(text)}</div>`;
            container.appendChild(msg);
            container.scrollTop = container.scrollHeight;

            // Play sounds for join/leave events
            if (text.includes('joined')) {
                playSound('join');
            } else if (text.includes('left')) {
                playSound('leave');
            }
        }

        function sendReaction(type) {
            const emojis = {
                'fire': 'üî•', 'laugh': 'üòÇ', 'wow': 'üòÆ',
                'sad': 'üò¢', 'heart': '‚ù§Ô∏è', 'clap': 'üëè'
            };
            const emoji = emojis[type];
            showFloatingReaction(emoji);
            broadcast({ type: 'reaction', emoji: emoji });
        }

        function showFloatingReaction(emoji) {
            const reaction = document.createElement('div');
            reaction.className = 'floating-reaction';
            reaction.textContent = emoji;
            reaction.style.left = (Math.random() * 60 + 20) + '%';
            reaction.style.bottom = '100px';
            document.body.appendChild(reaction);
            setTimeout(() => reaction.remove(), 2000);
        }

        // ==================== WEBCAM STREAMING ====================

        async function toggleWebcam() {
            if (webcamEnabled) {
                stopWebcam();
            } else {
                await startWebcam();
            }
        }

        async function startWebcam() {
            try {
                webcamStream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 320, height: 240, facingMode: 'user' },
                    audio: false  // Audio handled separately if needed
                });

                // Show local preview
                const localVideo = document.getElementById('localWebcamVideo');
                localVideo.srcObject = webcamStream;
                document.getElementById('localWebcam').classList.remove('hidden');

                // Update button state
                webcamEnabled = true;
                const btn = document.getElementById('webcamToggleBtn');
                btn.classList.add('active');
                document.getElementById('webcamBtnText').textContent = 'Stop Cam';

                // Stream to all connected peers
                if (isHost) {
                    connections.forEach(conn => {
                        streamWebcamToPeer(conn.peer);
                    });
                    addSystemMessage('Webcam started - viewers can see your reaction!');
                }

                showToast('Webcam started!');

            } catch (err) {
                console.error('Webcam error:', err);
                showToast('Failed to access webcam: ' + err.message, 'error');
            }
        }

        function stopWebcam() {
            if (webcamStream) {
                webcamStream.getTracks().forEach(track => track.stop());
                webcamStream = null;
            }

            // Hide local preview
            document.getElementById('localWebcam').classList.add('hidden');
            document.getElementById('localWebcamVideo').srcObject = null;

            // Update button state
            webcamEnabled = false;
            const btn = document.getElementById('webcamToggleBtn');
            btn.classList.remove('active');
            document.getElementById('webcamBtnText').textContent = 'Start Cam';

            // Close all media calls
            mediaCalls.forEach(call => {
                try { call.close(); } catch (e) {}
            });
            mediaCalls = [];

            // Notify viewers
            if (isHost) {
                broadcast({ type: 'webcam-stopped' });
                addSystemMessage('Webcam stopped');
            }

            showToast('Webcam stopped');
        }

        function streamWebcamToPeer(peerId) {
            if (!webcamStream || !peer) return;

            console.log('Streaming webcam to:', peerId);

            const call = peer.call(peerId, webcamStream, {
                metadata: { nickname: nickname, type: 'webcam' }
            });

            call.on('error', (err) => {
                console.error('Media call error:', err);
            });

            call.on('close', () => {
                mediaCalls = mediaCalls.filter(c => c !== call);
            });

            mediaCalls.push(call);
        }

        function handleIncomingCall(call) {
            console.log('Incoming call from:', call.peer, call.metadata);

            // Answer the call - send our streams back if we have any
            const tracksToSend = [];
            if (localVideoStream) {
                localVideoStream.getVideoTracks().forEach(t => tracksToSend.push(t));
            }
            if (audioStream && isTalking) {
                audioStream.getAudioTracks().forEach(t => tracksToSend.push(t));
            }

            if (tracksToSend.length > 0) {
                call.answer(new MediaStream(tracksToSend));
            } else {
                call.answer();
            }

            call.on('stream', (remoteStream) => {
                const callerNickname = call.metadata?.nickname || 'Guest';
                const callerPeerId = call.metadata?.peerId || call.peer;
                const callType = call.metadata?.type || 'facetime';

                console.log('Received stream from:', callerNickname, 'type:', callType);

                // Add to FaceTime video grid
                if (callType === 'facetime' || callType === 'ptt-audio') {
                    addRemoteParticipant(callerPeerId, callerNickname, remoteStream);

                    // Play audio for PTT
                    if (remoteStream.getAudioTracks().length > 0) {
                        playRemoteAudio(remoteStream, callerPeerId);
                    }

                    addSystemMessage(`${callerNickname} joined the video call!`);
                } else {
                    // Legacy webcam handling
                    displayRemoteWebcam(remoteStream, callerNickname, call.peer);
                }
            });

            call.on('close', () => {
                const callerPeerId = call.metadata?.peerId || call.peer;
                removeRemoteParticipant(callerPeerId);
            });

            call.on('error', (err) => {
                console.error('Incoming call error:', err);
            });
        }

        // Play audio from remote participant
        function playRemoteAudio(stream, peerId) {
            // Remove existing audio element if any
            let existingAudio = document.getElementById(`audio-${peerId}`);
            if (existingAudio) {
                existingAudio.remove();
            }

            // Create hidden audio element to play the audio
            const audio = document.createElement('audio');
            audio.id = `audio-${peerId}`;
            audio.srcObject = stream;
            audio.autoplay = true;
            audio.style.display = 'none';
            document.body.appendChild(audio);
        }

        function displayRemoteWebcam(stream, name, peerId) {
            const container = document.getElementById('remoteWebcamsContainer');

            // Remove existing webcam from this peer if any
            removeRemoteWebcam(peerId);

            // Create webcam overlay
            const overlay = document.createElement('div');
            overlay.className = 'webcam-overlay remote';
            overlay.id = `webcam-${peerId}`;
            overlay.innerHTML = `
                <video autoplay playsinline></video>
                <div class="webcam-label">
                    <div class="live-indicator"></div>
                    <span>${escapeHtml(name)}</span>
                </div>
            `;

            const video = overlay.querySelector('video');
            video.srcObject = stream;

            container.appendChild(overlay);

            addSystemMessage(`${name}'s webcam is now live!`);
        }

        function removeRemoteWebcam(peerId) {
            const existing = document.getElementById(`webcam-${peerId}`);
            if (existing) {
                existing.remove();
            }
        }

        // Drag functionality for webcam overlay (kept for backwards compatibility)
        function initWebcamDrag() {
            // No longer needed in FaceTime mode
        }

        // ==================== FACETIME MODE - VIDEO & AUDIO ====================

        function showFaceTimeUI() {
            document.getElementById('videoGrid').classList.remove('hidden');
            document.getElementById('callControls').style.display = 'flex';
            document.getElementById('liveBadge').style.display = 'flex';
            document.getElementById('localNickname').textContent = nickname || 'You';
            document.getElementById('localAvatar').textContent = (nickname || 'U').charAt(0).toUpperCase();
            updateVideoGrid();
        }

        function hideFaceTimeUI() {
            document.getElementById('videoGrid').classList.add('hidden');
            document.getElementById('callControls').style.display = 'none';
            document.getElementById('liveBadge').style.display = 'none';
        }

        async function toggleVideo() {
            const btn = document.getElementById('videoToggleBtn');
            const localParticipant = document.getElementById('localParticipant');
            const localVideo = document.getElementById('localWebcamVideo');

            if (videoEnabled) {
                // Stop video
                if (localVideoStream) {
                    localVideoStream.getVideoTracks().forEach(track => track.stop());
                }
                localVideo.srcObject = null;
                localParticipant.classList.add('no-video');
                btn.classList.remove('active');
                btn.classList.add('off');
                btn.innerHTML = 'üì∑';
                videoEnabled = false;

                // Notify peers
                broadcast({ type: 'video-state', peerId: peerId, videoEnabled: false });
            } else {
                // Start video
                try {
                    localVideoStream = await navigator.mediaDevices.getUserMedia({
                        video: { width: 640, height: 480, facingMode: 'user' },
                        audio: false
                    });

                    localVideo.srcObject = localVideoStream;
                    localParticipant.classList.remove('no-video');
                    btn.classList.add('active');
                    btn.classList.remove('off');
                    btn.innerHTML = 'üìπ';
                    videoEnabled = true;

                    // Stream video to all connected peers
                    streamMediaToAllPeers();

                    // Notify peers
                    broadcast({ type: 'video-state', peerId: peerId, videoEnabled: true });
                    showToast('Video started!');
                } catch (err) {
                    console.error('Video error:', err);
                    showToast('Failed to access camera: ' + err.message, 'error');
                }
            }
        }

        function toggleMic() {
            const btn = document.getElementById('micToggleBtn');
            const localMuted = document.getElementById('localMutedIcon');

            if (micEnabled) {
                // Mute
                if (audioStream) {
                    audioStream.getAudioTracks().forEach(track => track.enabled = false);
                }
                btn.classList.add('muted');
                btn.innerHTML = 'üîá';
                localMuted.textContent = 'üîá';
                micEnabled = false;
                showToast('Mic muted');
            } else {
                // Unmute
                if (audioStream) {
                    audioStream.getAudioTracks().forEach(track => track.enabled = true);
                }
                btn.classList.remove('muted');
                btn.innerHTML = 'üé§';
                localMuted.textContent = 'üé§';
                micEnabled = true;
                showToast('Mic unmuted');
            }
        }

        // ==================== PRESS-TO-TALK ====================

        async function startTalking() {
            if (isTalking) return;
            isTalking = true;

            const pttBtn = document.getElementById('pttBtn');
            pttBtn.classList.add('talking');
            document.getElementById('localParticipant').classList.add('speaking');

            try {
                // Get audio stream if not already
                if (!audioStream) {
                    audioStream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: true
                        },
                        video: false
                    });

                    // Set up audio analyser for speaking detection
                    setupAudioAnalyser(audioStream);
                }

                // Enable audio tracks
                audioStream.getAudioTracks().forEach(track => track.enabled = true);

                // Stream audio to all peers
                streamAudioToAllPeers();

                // Start audio level monitoring
                startAudioLevelMonitoring();

                // Notify others we're speaking
                broadcast({ type: 'ptt-start', peerId: peerId, nickname: nickname });

            } catch (err) {
                console.error('PTT error:', err);
                showToast('Microphone access denied', 'error');
                isTalking = false;
                pttBtn.classList.remove('talking');
            }
        }

        function stopTalking() {
            if (!isTalking) return;
            isTalking = false;

            const pttBtn = document.getElementById('pttBtn');
            pttBtn.classList.remove('talking');
            document.getElementById('localParticipant').classList.remove('speaking');

            // Mute audio tracks but keep stream
            if (audioStream) {
                audioStream.getAudioTracks().forEach(track => track.enabled = false);
            }

            // Stop audio level monitoring
            stopAudioLevelMonitoring();

            // Notify others we stopped speaking
            broadcast({ type: 'ptt-stop', peerId: peerId });
        }

        function setupAudioAnalyser(stream) {
            if (audioContext) audioContext.close();

            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const source = audioContext.createMediaStreamSource(stream);
            audioAnalyser = audioContext.createAnalyser();
            audioAnalyser.fftSize = 256;
            source.connect(audioAnalyser);
        }

        // ==================== MULTI-WAY STREAMING ====================

        function streamMediaToAllPeers() {
            connections.forEach(conn => {
                streamToPeer(conn.peer);
            });
        }

        function streamAudioToAllPeers() {
            if (!audioStream) return;
            connections.forEach(conn => {
                streamAudioToPeer(conn.peer);
            });
        }

        function streamToPeer(targetPeerId) {
            if (!peer) return;

            // Combine video and audio streams if available
            const tracks = [];
            if (localVideoStream) {
                localVideoStream.getVideoTracks().forEach(t => tracks.push(t));
            }
            if (audioStream && isTalking) {
                audioStream.getAudioTracks().forEach(t => tracks.push(t));
            }

            if (tracks.length === 0) return;

            const combinedStream = new MediaStream(tracks);

            console.log('Streaming to peer:', targetPeerId, 'tracks:', tracks.length);

            const call = peer.call(targetPeerId, combinedStream, {
                metadata: { nickname: nickname, peerId: peerId, type: 'facetime' }
            });

            call.on('error', err => console.error('Call error:', err));
            call.on('close', () => {
                mediaCalls = mediaCalls.filter(c => c !== call);
            });

            mediaCalls.push(call);
        }

        function streamAudioToPeer(targetPeerId) {
            if (!peer || !audioStream) return;

            // Check if we already have a call to this peer
            const existingCall = mediaCalls.find(c => c.peer === targetPeerId);
            if (existingCall) {
                // Update existing call's stream if possible
                return;
            }

            const call = peer.call(targetPeerId, audioStream, {
                metadata: { nickname: nickname, peerId: peerId, type: 'ptt-audio' }
            });

            call.on('error', err => console.error('Audio call error:', err));
            call.on('close', () => {
                mediaCalls = mediaCalls.filter(c => c !== call);
            });

            mediaCalls.push(call);
        }

        // ==================== PARTICIPANT MANAGEMENT ====================

        function addRemoteParticipant(peerId, nickname, stream) {
            const grid = document.getElementById('videoGrid');

            // Remove existing if any
            removeRemoteParticipant(peerId);

            const participant = document.createElement('div');
            participant.className = 'participant-video';
            participant.id = `participant-${peerId}`;

            const hasVideo = stream && stream.getVideoTracks().length > 0;
            if (!hasVideo) {
                participant.classList.add('no-video');
            }

            participant.innerHTML = `
                <video autoplay playsinline></video>
                <div class="avatar-placeholder">${(nickname || 'G').charAt(0).toUpperCase()}</div>
                <div class="audio-level-bar">
                    <div class="audio-level-fill"></div>
                </div>
                <span class="hand-raised-indicator">‚úã</span>
                <div class="participant-info">
                    <span class="participant-name">
                        <span>${escapeHtml(nickname || 'Guest')}</span>
                        <span class="speaking-indicator"></span>
                    </span>
                    <span class="muted-icon">üé§</span>
                </div>
            `;

            const video = participant.querySelector('video');
            if (stream) {
                video.srcObject = stream;
            }

            grid.appendChild(participant);

            remoteParticipants.set(peerId, {
                element: participant,
                video: video,
                nickname: nickname,
                stream: stream
            });

            updateVideoGrid();
        }

        function removeRemoteParticipant(peerId) {
            const existing = document.getElementById(`participant-${peerId}`);
            if (existing) {
                existing.remove();
            }
            remoteParticipants.delete(peerId);
            updateVideoGrid();
        }

        function updateVideoGrid() {
            const grid = document.getElementById('videoGrid');
            const count = remoteParticipants.size + 1; // +1 for local

            // Remove old grid classes
            grid.classList.remove('grid-1', 'grid-2', 'grid-3', 'grid-4', 'grid-5', 'grid-6');

            // Add appropriate grid class
            if (count === 1) grid.classList.add('grid-1');
            else if (count === 2) grid.classList.add('grid-2');
            else if (count === 3) grid.classList.add('grid-3');
            else if (count === 4) grid.classList.add('grid-4');
            else grid.classList.add('grid-6'); // 5-6 participants
        }

        function setParticipantSpeaking(peerId, speaking) {
            const participant = document.getElementById(`participant-${peerId}`);
            if (participant) {
                if (speaking) {
                    participant.classList.add('speaking');
                } else {
                    participant.classList.remove('speaking');
                }
            }
        }

        function endCall() {
            // Stop all streams
            if (localVideoStream) {
                localVideoStream.getTracks().forEach(t => t.stop());
                localVideoStream = null;
            }
            if (audioStream) {
                audioStream.getTracks().forEach(t => t.stop());
                audioStream = null;
            }
            if (screenShareStream) {
                screenShareStream.getTracks().forEach(t => t.stop());
                screenShareStream = null;
            }
            if (audioContext) {
                audioContext.close();
                audioContext = null;
            }

            // Stop monitoring intervals
            stopPingMonitoring();
            stopAudioLevelMonitoring();

            // Close all media calls
            mediaCalls.forEach(call => {
                try { call.close(); } catch (e) {}
            });
            mediaCalls = [];

            // Close all data connections
            connections.forEach(conn => {
                try { conn.close(); } catch (e) {}
            });
            connections = [];

            // Reset state
            videoEnabled = false;
            micEnabled = false;
            isTalking = false;
            screenShareEnabled = false;
            handRaised = false;
            remoteParticipants.clear();

            // Reset UI
            hideFaceTimeUI();
            document.getElementById('localWebcamVideo').srcObject = null;
            document.getElementById('localParticipant').classList.add('no-video');

            // Destroy peer
            if (peer) {
                peer.destroy();
                peer = null;
            }

            // Show setup modal
            document.getElementById('setupModal').classList.remove('hidden');
            updateSyncStatus('disconnected');

            showToast('Call ended');
        }

        // ==================== SCREEN SHARING ====================

        async function toggleScreenShare() {
            const btn = document.getElementById('screenShareBtn');

            if (screenShareEnabled) {
                stopScreenShare();
            } else {
                try {
                    screenShareStream = await navigator.mediaDevices.getDisplayMedia({
                        video: { cursor: 'always' },
                        audio: true
                    });

                    screenShareEnabled = true;
                    btn.classList.add('active');

                    // Handle when user stops sharing via browser UI
                    screenShareStream.getVideoTracks()[0].onended = () => {
                        stopScreenShare();
                    };

                    // Stream to all peers
                    connections.forEach(conn => {
                        const call = peer.call(conn.peer, screenShareStream, {
                            metadata: { nickname: nickname, peerId: peerId, type: 'screen-share' }
                        });
                        mediaCalls.push(call);
                    });

                    broadcast({ type: 'screen-share', peerId: peerId, nickname: nickname, sharing: true });
                    showToast('Screen sharing started!');

                } catch (err) {
                    console.error('Screen share error:', err);
                    if (err.name !== 'AbortError') {
                        showToast('Screen share failed: ' + err.message, 'error');
                    }
                }
            }
        }

        function stopScreenShare() {
            if (screenShareStream) {
                screenShareStream.getTracks().forEach(t => t.stop());
                screenShareStream = null;
            }

            screenShareEnabled = false;
            document.getElementById('screenShareBtn').classList.remove('active');

            broadcast({ type: 'screen-share', peerId: peerId, nickname: nickname, sharing: false });
            showToast('Screen sharing stopped');
        }

        // ==================== RAISE HAND ====================

        function toggleRaiseHand() {
            handRaised = !handRaised;
            const btn = document.getElementById('raiseHandBtn');
            const localParticipant = document.getElementById('localParticipant');

            if (handRaised) {
                btn.classList.add('raised');
                localParticipant.classList.add('hand-raised');
                playSound('hand');
            } else {
                btn.classList.remove('raised');
                localParticipant.classList.remove('hand-raised');
            }

            broadcast({ type: 'hand-raise', peerId: peerId, nickname: nickname, raised: handRaised });
        }

        function setParticipantHandRaised(peerId, raised) {
            const participant = document.getElementById(`participant-${peerId}`);
            if (participant) {
                if (raised) {
                    participant.classList.add('hand-raised');
                } else {
                    participant.classList.remove('hand-raised');
                }
            }
        }

        // ==================== FULLSCREEN ====================

        function toggleFullscreen() {
            const videoSection = document.querySelector('.video-section');

            if (!isFullscreen) {
                if (videoSection.requestFullscreen) {
                    videoSection.requestFullscreen();
                } else if (videoSection.webkitRequestFullscreen) {
                    videoSection.webkitRequestFullscreen();
                }
                videoSection.classList.add('fullscreen');
                document.getElementById('fullscreenBtn').innerHTML = '‚õ∂';
                isFullscreen = true;
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                }
                videoSection.classList.remove('fullscreen');
                document.getElementById('fullscreenBtn').innerHTML = '‚õ∂';
                isFullscreen = false;
            }
        }

        // Handle fullscreen exit via ESC
        document.addEventListener('fullscreenchange', () => {
            if (!document.fullscreenElement) {
                document.querySelector('.video-section').classList.remove('fullscreen');
                isFullscreen = false;
            }
        });

        // ==================== KEYBOARD SHORTCUTS ====================

        document.addEventListener('keydown', (e) => {
            // Don't trigger shortcuts when typing in input fields
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                return;
            }

            switch (e.key.toLowerCase()) {
                case ' ': // Space - PTT
                    e.preventDefault();
                    if (!isTalking) startTalking();
                    break;
                case 'v': // Toggle video
                    e.preventDefault();
                    toggleVideo();
                    break;
                case 'm': // Toggle mute
                    e.preventDefault();
                    toggleMic();
                    break;
                case 's': // Screen share
                    e.preventDefault();
                    toggleScreenShare();
                    break;
                case 'h': // Raise hand
                    e.preventDefault();
                    toggleRaiseHand();
                    break;
                case 'f': // Fullscreen
                    e.preventDefault();
                    toggleFullscreen();
                    break;
                case '?': // Show shortcuts
                    e.preventDefault();
                    toggleShortcutHints();
                    break;
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === ' ' && isTalking) {
                stopTalking();
            }
        });

        function toggleShortcutHints() {
            const hints = document.getElementById('shortcutHints');
            hints.classList.toggle('visible');
        }

        // ==================== CONNECTION QUALITY ====================

        function startPingMonitoring() {
            pingInterval = setInterval(() => {
                lastPingTime = Date.now();
                broadcast({ type: 'ping', timestamp: lastPingTime });
            }, 5000);
        }

        function stopPingMonitoring() {
            if (pingInterval) {
                clearInterval(pingInterval);
                pingInterval = null;
            }
        }

        function updateConnectionQuality(ping) {
            const quality = document.getElementById('connectionQuality');
            const pingDisplay = document.getElementById('connectionPing');

            quality.style.display = 'flex';
            pingDisplay.textContent = `${ping}ms`;

            // Remove old classes
            quality.classList.remove('excellent', 'good', 'fair', 'poor');

            if (ping < 50) {
                quality.classList.add('excellent');
            } else if (ping < 150) {
                quality.classList.add('good');
            } else if (ping < 300) {
                quality.classList.add('fair');
            } else {
                quality.classList.add('poor');
            }
        }

        // ==================== AUDIO LEVEL VISUALIZATION ====================

        function startAudioLevelMonitoring() {
            if (!audioAnalyser) return;

            const dataArray = new Uint8Array(audioAnalyser.frequencyBinCount);

            audioLevelInterval = setInterval(() => {
                if (audioAnalyser && isTalking) {
                    audioAnalyser.getByteFrequencyData(dataArray);
                    const average = dataArray.reduce((a, b) => a + b) / dataArray.length;
                    const level = Math.min(100, (average / 128) * 100);

                    document.getElementById('localAudioLevel').style.height = level + '%';
                } else {
                    document.getElementById('localAudioLevel').style.height = '0%';
                }
            }, 50);
        }

        function stopAudioLevelMonitoring() {
            if (audioLevelInterval) {
                clearInterval(audioLevelInterval);
                audioLevelInterval = null;
            }
            document.getElementById('localAudioLevel').style.height = '0%';
        }

        // ==================== TYPING INDICATOR ====================

        function handleChatTyping() {
            clearTimeout(typingTimeout);
            broadcast({ type: 'typing', nickname: nickname, isTyping: true });

            typingTimeout = setTimeout(() => {
                broadcast({ type: 'typing', nickname: nickname, isTyping: false });
            }, 2000);
        }

        function handleTypingIndicator(user, isTyping) {
            if (isTyping) {
                typingUsers.add(user);
            } else {
                typingUsers.delete(user);
            }

            const indicator = document.getElementById('typingIndicator');
            const namesSpan = document.getElementById('typingNames');

            if (typingUsers.size > 0) {
                const names = Array.from(typingUsers);
                if (names.length === 1) {
                    namesSpan.textContent = names[0];
                } else if (names.length === 2) {
                    namesSpan.textContent = names.join(' and ');
                } else {
                    namesSpan.textContent = 'Several people';
                }
                indicator.classList.add('visible');
            } else {
                indicator.classList.remove('visible');
            }
        }

        // ==================== NOTIFICATION SOUNDS ====================

        function playSound(type) {
            try {
                const audio = new Audio(SOUNDS[type]);
                audio.volume = 0.3;
                audio.play().catch(() => {}); // Ignore autoplay errors
            } catch (e) {}
        }

        // ==================== AUTO-RECONNECTION ====================

        function attemptReconnect() {
            if (!lastHostId || isHost) return;

            reconnectAttempts++;

            if (reconnectAttempts > maxReconnectAttempts) {
                document.getElementById('reconnectingOverlay').classList.remove('visible');
                showToast('Could not reconnect. Please rejoin.', 'error');
                document.getElementById('setupModal').classList.remove('hidden');
                return;
            }

            document.getElementById('reconnectingOverlay').classList.add('visible');
            document.getElementById('retryCount').textContent = `Attempt ${reconnectAttempts} of ${maxReconnectAttempts}`;

            setTimeout(async () => {
                try {
                    if (peer && peer.destroyed) {
                        await initPeer();
                    }
                    await connectToPeer(lastHostId);

                    document.getElementById('reconnectingOverlay').classList.remove('visible');
                    reconnectAttempts = 0;
                    showToast('Reconnected!');
                } catch (err) {
                    attemptReconnect();
                }
            }, 2000 * reconnectAttempts);
        }

        // ==================== CHAT IMPROVEMENTS ====================

        let messageIdCounter = 0;

        function addChatMessageWithFeatures(sender, text, isOwn = false) {
            const container = document.getElementById('chatMessages');
            const msg = document.createElement('div');
            const msgId = `msg-${++messageIdCounter}`;
            msg.className = 'chat-message';
            msg.id = msgId;

            const timestamp = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

            msg.innerHTML = `
                <div class="sender">${escapeHtml(sender)}<span class="timestamp">${timestamp}</span></div>
                <div class="text">${escapeHtml(text)}</div>
                <div class="message-reactions" id="reactions-${msgId}">
                    <button class="add-reaction-btn" onclick="showReactionPicker('${msgId}')">+</button>
                </div>
            `;
            container.appendChild(msg);
            container.scrollTop = container.scrollHeight;

            // Update unread count if not on chat tab
            if (!chatTabActive) {
                unreadChatCount++;
                updateChatBadge();
            }

            return msgId;
        }

        function updateChatBadge() {
            const badge = document.getElementById('chatBadge');
            if (unreadChatCount > 0) {
                badge.textContent = unreadChatCount > 9 ? '9+' : unreadChatCount;
                badge.classList.add('visible');
            } else {
                badge.classList.remove('visible');
            }
        }

        function showReactionPicker(messageId) {
            const reactions = ['üëç', '‚ù§Ô∏è', 'üòÇ', 'üòÆ', 'üò¢', 'üéâ'];
            const picker = document.createElement('div');
            picker.style.cssText = 'position: absolute; background: #333; padding: 5px; border-radius: 8px; display: flex; gap: 5px; z-index: 1000;';

            reactions.forEach(emoji => {
                const btn = document.createElement('button');
                btn.textContent = emoji;
                btn.style.cssText = 'background: none; border: none; cursor: pointer; font-size: 1rem;';
                btn.onclick = () => {
                    addReactionToMessage(messageId, emoji);
                    broadcast({ type: 'chat-reaction', messageId, emoji });
                    picker.remove();
                };
                picker.appendChild(btn);
            });

            const msgEl = document.getElementById(messageId);
            msgEl.appendChild(picker);

            setTimeout(() => picker.remove(), 5000);
        }

        function addReactionToMessage(messageId, emoji) {
            const reactionsContainer = document.getElementById(`reactions-${messageId}`);
            if (!reactionsContainer) return;

            // Check if reaction already exists
            const existingReaction = reactionsContainer.querySelector(`[data-emoji="${emoji}"]`);
            if (existingReaction) {
                const count = parseInt(existingReaction.dataset.count || 1) + 1;
                existingReaction.dataset.count = count;
                existingReaction.textContent = `${emoji} ${count}`;
            } else {
                const reaction = document.createElement('span');
                reaction.className = 'msg-reaction';
                reaction.dataset.emoji = emoji;
                reaction.dataset.count = 1;
                reaction.textContent = emoji;
                reactionsContainer.insertBefore(reaction, reactionsContainer.lastElementChild);
            }
        }

        // ==================== QR CODE & SHARING ====================

        function loadQRiousLibrary() {
            return new Promise((resolve, reject) => {
                if (window.QRious) {
                    resolve();
                    return;
                }
                const script = document.createElement('script');
                script.src = 'https://cdnjs.cloudflare.com/ajax/libs/qrious/4.0.2/qrious.min.js';
                script.onload = resolve;
                script.onerror = reject;
                document.head.appendChild(script);
            });
        }

        function generateInviteQR() {
            if (!peerId) return;

            const container = document.getElementById('qrContainer');
            const baseUrl = window.location.origin + window.location.pathname;
            currentShareableUrl = `${baseUrl}?party=${peerId}`;

            document.getElementById('shareableUrl').textContent = currentShareableUrl;

            container.innerHTML = '<div style="color: #666; padding: 20px;">Generating QR...</div>';

            loadQRiousLibrary().then(() => {
                container.innerHTML = '';
                const canvas = document.createElement('canvas');
                container.appendChild(canvas);

                new window.QRious({
                    element: canvas,
                    value: currentShareableUrl,
                    size: 180,
                    background: 'white',
                    foreground: 'black',
                    level: 'H'
                });
            }).catch(() => {
                // Fallback to API
                container.innerHTML = '';
                const img = document.createElement('img');
                img.src = `https://api.qrserver.com/v1/create-qr-code/?size=180x180&ecc=H&data=${encodeURIComponent(currentShareableUrl)}`;
                img.alt = 'Invite QR Code';
                container.appendChild(img);
            });
        }

        function copyInviteLink() {
            if (!currentShareableUrl) {
                showToast('No invite link yet', 'error');
                return;
            }
            navigator.clipboard.writeText(currentShareableUrl).then(() => {
                showToast('Link copied!');
            }).catch(() => {
                // Fallback
                const ta = document.createElement('textarea');
                ta.value = currentShareableUrl;
                document.body.appendChild(ta);
                ta.select();
                document.execCommand('copy');
                document.body.removeChild(ta);
                showToast('Link copied!');
            });
        }

        function shareInvite() {
            if (!currentShareableUrl) return;

            if (navigator.share) {
                navigator.share({
                    title: 'Join my Watch Party!',
                    text: 'Click to watch videos together in sync',
                    url: currentShareableUrl
                }).catch(() => copyInviteLink());
            } else {
                copyInviteLink();
            }
        }

        // ==================== UI HELPERS ====================

        function switchSidebarTab(tabName) {
            document.querySelectorAll('.sidebar-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.sidebar-content').forEach(c => c.classList.remove('active'));

            event.target.classList.add('active');
            document.getElementById(tabName + 'Panel').classList.add('active');

            // Track chat tab activity
            chatTabActive = (tabName === 'chat');
            if (chatTabActive) {
                unreadChatCount = 0;
                updateChatBadge();
            }
        }

        function updateSyncStatus(status) {
            const dot = document.getElementById('syncDot');
            const text = document.getElementById('syncStatus');

            dot.className = 'sync-dot';
            switch (status) {
                case 'connected':
                    dot.classList.add('connected');
                    text.textContent = isHost ? 'Hosting' : 'Connected';
                    break;
                case 'syncing':
                    dot.classList.add('syncing');
                    text.textContent = 'Connecting...';
                    break;
                default:
                    text.textContent = 'Not Connected';
            }
        }

        function updateViewerCount() {
            const count = isHost ? connections.length + 1 : connections.length + 1;
            document.getElementById('viewerCount').textContent = count + (count === 1 ? ' viewer' : ' viewers');
        }

        function updateViewersList() {
            const container = document.getElementById('viewersList');
            container.innerHTML = '';

            const allViewers = isHost ? viewers : [{ nickname: nickname, isHost: false, peerId: peerId }, ...viewers];

            allViewers.forEach(v => {
                const item = document.createElement('div');
                item.className = 'viewer-item';
                item.innerHTML = `
                    <div class="viewer-avatar">${v.nickname.charAt(0).toUpperCase()}</div>
                    <div class="viewer-info">
                        <div class="viewer-name">${escapeHtml(v.nickname)}</div>
                        <div class="viewer-status">${v.isHost ? 'Host' : 'Watching'}</div>
                    </div>
                    ${v.isHost ? '<span class="host-badge">HOST</span>' : ''}
                `;
                container.appendChild(item);
            });
        }

        function showToast(message, type = 'info') {
            const toast = document.createElement('div');
            toast.className = 'toast';
            toast.textContent = message;
            if (type === 'error') toast.style.background = '#ff4444';
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 3000);
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // ==================== DATA PERSISTENCE ====================

        function saveData() {
            localStorage.setItem(APP_NAME, JSON.stringify(appData));
        }

        function exportData() {
            const dataStr = JSON.stringify(appData, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `${APP_NAME}-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);
        }

        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    appData = JSON.parse(e.target.result);
                    saveData();
                    showToast('Data imported!');
                } catch {
                    showToast('Invalid file', 'error');
                }
            };
            reader.readAsText(file);
        }

        // ==================== INITIALIZATION ====================

        // Pre-fill nickname if saved
        if (appData.nickname) {
            document.getElementById('nicknameInput').value = appData.nickname;
        }

        // Check for party code in URL
        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.get('party')) {
            showJoinInput();
            document.getElementById('joinCodeInput').value = urlParams.get('party');
        }

        console.log('üé¨ Watch Party Sync - P2P Synchronized Viewing');
        console.log('üîó No servers. No accounts. Just vibes.');
        console.log('');
        console.log('üìπ FaceTime-style video calls for ALL participants');
        console.log('üó£Ô∏è Press-to-talk voice chat (Space bar)');
        console.log('üñ•Ô∏è Screen sharing support');
        console.log('‚úã Raise hand feature');
        console.log('‚å®Ô∏è Keyboard shortcuts (press ? for help)');
        console.log('üìä Connection quality indicator');
        console.log('üîä Audio level visualization');
        console.log('üí¨ Chat with timestamps & reactions');
        console.log('üîÑ Auto-reconnection on disconnect');
        console.log('üîî Sound notifications');
        console.log('');
        console.log('üåê P2P mesh network - everyone sees everyone!');
    </script>
</body>
</html>
