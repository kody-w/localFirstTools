<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Watch Party Sync - P2P Synchronized Viewing</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0d0d0d 0%, #1a0a2e 50%, #0d1a2e 100%);
            min-height: 100vh;
            color: #fff;
        }

        .header {
            text-align: center;
            padding: 15px 20px;
            background: rgba(0,0,0,0.4);
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .header h1 {
            font-size: 1.6rem;
            background: linear-gradient(90deg, #ff6b6b, #feca57, #48dbfb);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            color: transparent;
        }

        .header p {
            color: #888;
            margin-top: 5px;
            font-size: 0.85rem;
        }

        .party-badge {
            display: inline-block;
            background: linear-gradient(90deg, #ff6b6b, #feca57);
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.7rem;
            margin-top: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #000;
            font-weight: bold;
        }

        .main-container {
            display: grid;
            grid-template-columns: 1fr 320px;
            height: calc(100vh - 100px);
            gap: 0;
        }

        @media (max-width: 900px) {
            .main-container {
                grid-template-columns: 1fr;
                height: auto;
            }
        }

        /* Video Section */
        .video-section {
            background: #000;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .video-wrapper {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #111;
            position: relative;
            min-height: 300px;
        }

        #mainVideo {
            max-width: 100%;
            max-height: 100%;
            width: 100%;
        }

        #youtubeContainer {
            width: 100%;
            height: 100%;
            position: relative;
        }

        #youtubeContainer iframe {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        /* ============ FACETIME-STYLE VIDEO GRID ============ */
        .video-grid-container {
            position: absolute;
            top: 50px;
            left: 10px;
            right: 10px;
            bottom: 80px;
            display: grid;
            gap: 8px;
            z-index: 100;
            pointer-events: none;
        }

        .video-grid-container.hidden {
            display: none;
        }

        /* Grid layouts based on participant count */
        .video-grid-container.grid-1 { grid-template-columns: 1fr; }
        .video-grid-container.grid-2 { grid-template-columns: 1fr 1fr; }
        .video-grid-container.grid-3 { grid-template-columns: 1fr 1fr; grid-template-rows: 1fr 1fr; }
        .video-grid-container.grid-4 { grid-template-columns: 1fr 1fr; grid-template-rows: 1fr 1fr; }
        .video-grid-container.grid-5,
        .video-grid-container.grid-6 { grid-template-columns: 1fr 1fr 1fr; grid-template-rows: 1fr 1fr; }

        .participant-video {
            position: relative;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            border-radius: 16px;
            overflow: hidden;
            border: 3px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            pointer-events: auto;
            min-height: 120px;
        }

        .participant-video.speaking {
            border-color: #06ffa5;
            box-shadow: 0 0 20px rgba(6, 255, 165, 0.4);
        }

        .participant-video.local {
            border-color: rgba(72, 219, 251, 0.6);
        }

        .participant-video.no-video {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .participant-video video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .participant-video.local video {
            transform: scaleX(-1); /* Mirror self-view */
        }

        .participant-video .avatar-placeholder {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: linear-gradient(135deg, #ff6b6b, #feca57);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            color: white;
            text-transform: uppercase;
        }

        .participant-video .participant-info {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(transparent, rgba(0,0,0,0.85));
            padding: 20px 12px 10px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .participant-video .participant-name {
            font-size: 0.85rem;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .participant-video .speaking-indicator {
            width: 10px;
            height: 10px;
            background: #06ffa5;
            border-radius: 50%;
            animation: speakPulse 0.5s infinite;
            display: none;
        }

        .participant-video.speaking .speaking-indicator {
            display: block;
        }

        @keyframes speakPulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.3); opacity: 0.7; }
        }

        .participant-video .muted-icon {
            font-size: 0.9rem;
            opacity: 0.7;
        }

        /* ============ CALL CONTROLS BAR ============ */
        .call-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 80px;
            background: linear-gradient(transparent, rgba(0,0,0,0.95));
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            padding: 0 20px;
            z-index: 200;
        }

        .call-btn {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            font-size: 1.4rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            position: relative;
        }

        .call-btn:hover {
            transform: scale(1.1);
        }

        .call-btn:active {
            transform: scale(0.95);
        }

        .call-btn.video-btn {
            background: rgba(255, 255, 255, 0.15);
            color: white;
        }

        .call-btn.video-btn.active {
            background: #48dbfb;
            color: #000;
        }

        .call-btn.video-btn.off {
            background: rgba(255, 68, 68, 0.3);
            color: #ff4444;
        }

        .call-btn.mic-btn {
            background: rgba(255, 255, 255, 0.15);
            color: white;
        }

        .call-btn.mic-btn.muted {
            background: rgba(255, 68, 68, 0.3);
            color: #ff4444;
        }

        /* Press-to-talk button */
        .call-btn.ptt-btn {
            background: rgba(255, 255, 255, 0.15);
            color: white;
            width: 70px;
            height: 70px;
            font-size: 1.6rem;
        }

        .call-btn.ptt-btn:hover {
            background: rgba(6, 255, 165, 0.2);
        }

        .call-btn.ptt-btn.talking {
            background: linear-gradient(135deg, #06ffa5, #00d98b);
            color: #000;
            box-shadow: 0 0 30px rgba(6, 255, 165, 0.6);
            animation: talkingPulse 0.3s infinite;
        }

        @keyframes talkingPulse {
            0%, 100% { box-shadow: 0 0 20px rgba(6, 255, 165, 0.6); }
            50% { box-shadow: 0 0 40px rgba(6, 255, 165, 0.8); }
        }

        .call-btn.ptt-btn .ptt-label {
            position: absolute;
            bottom: -22px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.65rem;
            white-space: nowrap;
            opacity: 0.7;
        }

        .call-btn.end-btn {
            background: #ff4444;
            color: white;
        }

        .call-btn.end-btn:hover {
            background: #ff2222;
        }

        /* Tooltip for buttons */
        .call-btn::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 65px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 5px 10px;
            border-radius: 6px;
            font-size: 0.75rem;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
        }

        .call-btn:hover::after {
            opacity: 1;
        }

        /* ============ LIVE INDICATOR ============ */
        .live-badge {
            position: absolute;
            top: 10px;
            left: 10px;
            background: #ff4444;
            color: white;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 5px;
            z-index: 150;
        }

        .live-badge .live-dot {
            width: 6px;
            height: 6px;
            background: white;
            border-radius: 50%;
            animation: livePulse 1s infinite;
        }

        @keyframes livePulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Hide webcam controls in FaceTime mode */
        .facetime-mode .webcam-toggle-btn,
        .facetime-mode #localWebcam,
        .facetime-mode #remoteWebcamsContainer {
            display: none !important;
        }

        .video-placeholder {
            text-align: center;
            color: #666;
            padding: 40px;
        }

        .video-placeholder h3 {
            font-size: 1.5rem;
            margin-bottom: 10px;
            color: #888;
        }

        .sync-indicator {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.8);
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.75rem;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .sync-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ff4444;
        }

        .sync-dot.connected { background: #00cc66; }
        .sync-dot.syncing { background: #ffaa00; animation: pulse 1s infinite; }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .viewer-count {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.8);
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.75rem;
        }

        /* Video Controls */
        .video-controls {
            background: rgba(0,0,0,0.9);
            padding: 15px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }

        .video-url-input {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .video-url-input input {
            flex: 1;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            padding: 10px 15px;
            color: white;
            font-size: 0.9rem;
        }

        .video-url-input input::placeholder { color: #666; }
        .video-url-input input:focus { outline: none; border-color: #48dbfb; }

        .playback-controls {
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .control-btn {
            background: rgba(255,255,255,0.1);
            border: none;
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.2s;
        }

        .control-btn:hover { background: rgba(255,255,255,0.2); }
        .control-btn.primary { background: linear-gradient(90deg, #ff6b6b, #feca57); color: #000; }
        .control-btn:disabled { opacity: 0.5; cursor: not-allowed; }

        .progress-container {
            flex: 1;
            min-width: 200px;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: rgba(255,255,255,0.2);
            border-radius: 3px;
            cursor: pointer;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff6b6b, #feca57);
            border-radius: 3px;
            width: 0%;
            transition: width 0.1s;
        }

        .time-display {
            font-size: 0.8rem;
            color: #888;
            margin-top: 5px;
        }

        /* Sidebar */
        .sidebar {
            background: rgba(0,0,0,0.6);
            display: flex;
            flex-direction: column;
            border-left: 1px solid rgba(255,255,255,0.1);
        }

        .sidebar-tabs {
            display: flex;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .sidebar-tab {
            flex: 1;
            padding: 12px;
            background: transparent;
            border: none;
            color: #888;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s;
        }

        .sidebar-tab.active {
            color: #fff;
            background: rgba(255,255,255,0.1);
            border-bottom: 2px solid #48dbfb;
        }

        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            display: none;
        }

        .sidebar-content.active { display: flex; flex-direction: column; }

        /* Chat Panel */
        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
        }

        .chat-message {
            margin-bottom: 12px;
            animation: fadeIn 0.3s;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .chat-message .sender {
            font-size: 0.75rem;
            color: #48dbfb;
            margin-bottom: 3px;
        }

        .chat-message .text {
            background: rgba(255,255,255,0.1);
            padding: 8px 12px;
            border-radius: 12px;
            font-size: 0.85rem;
            word-wrap: break-word;
        }

        .chat-message.system .text {
            background: rgba(255,107,107,0.2);
            color: #ff6b6b;
            font-style: italic;
        }

        .chat-input-container {
            padding: 15px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }

        .chat-input-container input {
            width: 100%;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 20px;
            padding: 10px 15px;
            color: white;
            font-size: 0.9rem;
        }

        .chat-input-container input:focus { outline: none; border-color: #48dbfb; }

        /* Reactions */
        .reactions-bar {
            display: flex;
            gap: 5px;
            padding: 10px 15px;
            border-top: 1px solid rgba(255,255,255,0.1);
            flex-wrap: wrap;
        }

        .reaction-btn {
            background: rgba(255,255,255,0.1);
            border: none;
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .reaction-btn:hover { transform: scale(1.2); background: rgba(255,255,255,0.2); }

        /* Invite Panel */
        .invite-panel {
            padding: 20px;
        }

        .invite-panel h3 {
            color: #48dbfb;
            margin-bottom: 15px;
            font-size: 1rem;
        }

        .qr-container {
            background: white;
            padding: 15px;
            border-radius: 12px;
            text-align: center;
            margin-bottom: 15px;
        }

        .qr-container canvas, .qr-container img {
            max-width: 180px;
            height: auto;
        }

        .qr-placeholder {
            color: #666;
            padding: 40px 20px;
            font-size: 0.85rem;
        }

        .shareable-url {
            background: rgba(0,0,0,0.4);
            padding: 10px;
            border-radius: 8px;
            font-size: 0.7rem;
            font-family: monospace;
            word-break: break-all;
            margin-bottom: 15px;
            max-height: 60px;
            overflow-y: auto;
            color: #aaa;
        }

        .invite-buttons {
            display: flex;
            gap: 10px;
        }

        .invite-buttons button {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s;
        }

        .btn-copy {
            background: linear-gradient(90deg, #48dbfb, #0abde3);
            color: #000;
        }

        .btn-share {
            background: rgba(255,255,255,0.1);
            color: white;
            border: 1px solid rgba(255,255,255,0.2) !important;
        }

        /* Viewers Panel */
        .viewers-panel {
            padding: 20px;
        }

        .viewer-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            margin-bottom: 8px;
        }

        .viewer-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: linear-gradient(135deg, #ff6b6b, #feca57);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9rem;
        }

        .viewer-info {
            flex: 1;
        }

        .viewer-name {
            font-size: 0.9rem;
            font-weight: 500;
        }

        .viewer-status {
            font-size: 0.75rem;
            color: #888;
        }

        .host-badge {
            background: #feca57;
            color: #000;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.65rem;
            font-weight: bold;
        }

        /* Floating Reactions */
        .floating-reaction {
            position: fixed;
            font-size: 2rem;
            animation: floatUp 2s ease-out forwards;
            pointer-events: none;
            z-index: 1000;
        }

        @keyframes floatUp {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-200px) scale(1.5); }
        }

        /* Toast */
        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #333;
            color: white;
            padding: 12px 24px;
            border-radius: 25px;
            animation: slideUp 0.3s ease;
            z-index: 1000;
        }

        @keyframes slideUp {
            from { transform: translateX(-50%) translateY(20px); opacity: 0; }
            to { transform: translateX(-50%) translateY(0); opacity: 1; }
        }

        /* Data Controls */
        .data-controls {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1000;
            display: flex;
            gap: 8px;
        }

        .data-controls button {
            background: rgba(0,0,0,0.6);
            border: 1px solid rgba(255,255,255,0.2);
            color: white;
            padding: 6px 12px;
            border-radius: 15px;
            cursor: pointer;
            font-size: 0.75rem;
        }

        /* Setup Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .modal-overlay.hidden { display: none; }

        .modal {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            border-radius: 20px;
            padding: 30px;
            max-width: 450px;
            width: 90%;
            text-align: center;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .modal h2 {
            background: linear-gradient(90deg, #ff6b6b, #feca57, #48dbfb);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            color: transparent;
            margin-bottom: 10px;
        }

        .modal p {
            color: #888;
            margin-bottom: 25px;
            font-size: 0.9rem;
        }

        .modal-input {
            width: 100%;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 10px;
            padding: 12px 15px;
            color: white;
            font-size: 1rem;
            margin-bottom: 20px;
        }

        .modal-input:focus { outline: none; border-color: #48dbfb; }

        .modal-buttons {
            display: flex;
            gap: 15px;
        }

        .modal-buttons button {
            flex: 1;
            padding: 12px 20px;
            border: none;
            border-radius: 25px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .modal-buttons .btn-host {
            background: linear-gradient(90deg, #ff6b6b, #feca57);
            color: #000;
            font-weight: bold;
        }

        .modal-buttons .btn-join {
            background: rgba(255,255,255,0.1);
            color: white;
            border: 1px solid rgba(255,255,255,0.3);
        }

        .modal-buttons button:hover { transform: scale(1.02); }
    </style>
</head>
<body>
    <div class="data-controls">
        <button onclick="exportData()">Export</button>
        <button onclick="document.getElementById('importFile').click()">Import</button>
        <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importData(event)">
    </div>

    <!-- Setup Modal -->
    <div id="setupModal" class="modal-overlay">
        <div class="modal">
            <h2>Watch Party</h2>
            <p>Watch videos together in perfect sync. No accounts needed!</p>
            <input type="text" id="nicknameInput" class="modal-input" placeholder="Your nickname..." maxlength="20">
            <div class="modal-buttons">
                <button class="btn-host" onclick="hostParty()">Host Party</button>
                <button class="btn-join" onclick="showJoinInput()">Join Party</button>
            </div>
            <div id="joinInputContainer" style="display: none; margin-top: 20px;">
                <input type="text" id="joinCodeInput" class="modal-input" placeholder="Paste invite link or party code...">
                <button class="btn-host" onclick="joinParty()" style="width: 100%; border-radius: 25px; padding: 12px; border: none; cursor: pointer;">Join</button>
            </div>
        </div>
    </div>

    <div class="header">
        <h1>Watch Party Sync</h1>
        <p>Synchronized viewing with friends - no accounts, pure P2P</p>
        <div class="party-badge">Zero Servers</div>
    </div>

    <div class="main-container">
        <!-- Video Section -->
        <div class="video-section">
            <div class="video-wrapper">
                <div class="sync-indicator">
                    <div id="syncDot" class="sync-dot"></div>
                    <span id="syncStatus">Not Connected</span>
                </div>
                <div id="viewerCount" class="viewer-count">1 viewer</div>

                <video id="mainVideo" style="display: none;"></video>
                <div id="youtubeContainer" style="display: none; width: 100%; height: 100%;">
                    <div id="youtubePlayer"></div>
                </div>
                <div id="videoPlaceholder" class="video-placeholder">
                    <h3>No Video Loaded</h3>
                    <p>Paste a YouTube link or video URL below</p>
                    <p style="color: #48dbfb; margin-top: 10px; font-size: 0.85rem;">Supports: YouTube, MP4, WebM</p>
                </div>

                <!-- Webcam Toggle Button -->
                <button id="webcamToggleBtn" class="webcam-toggle-btn" onclick="toggleWebcam()" style="display: none;">
                    <span class="cam-icon">üì∑</span>
                    <span id="webcamBtnText">Start Cam</span>
                </button>

                <!-- Local Webcam (Host's self-view) -->
                <div id="localWebcam" class="webcam-overlay hidden">
                    <video id="localWebcamVideo" autoplay muted playsinline></video>
                    <div class="webcam-label">
                        <div class="live-indicator"></div>
                        <span>You (Host)</span>
                    </div>
                </div>

                <!-- Remote Webcam Container (for viewers to see host) -->
                <div id="remoteWebcamsContainer" class="webcams-container"></div>
            </div>

            <div class="video-controls">
                <div class="video-url-input">
                    <input type="text" id="videoUrlInput" placeholder="Paste YouTube link or video URL...">
                    <button class="control-btn primary" onclick="loadVideo()">Load</button>
                    <label class="control-btn" style="cursor: pointer;">
                        Upload
                        <input type="file" accept="video/*" style="display: none;" onchange="loadLocalVideo(event)">
                    </label>
                </div>

                <div class="playback-controls">
                    <button id="playPauseBtn" class="control-btn" onclick="togglePlayPause()" disabled>Play</button>
                    <button class="control-btn" onclick="skip(-10)" disabled id="skipBackBtn">-10s</button>
                    <button class="control-btn" onclick="skip(10)" disabled id="skipFwdBtn">+10s</button>

                    <div class="progress-container">
                        <div class="progress-bar" onclick="seekVideo(event)" id="progressBar">
                            <div class="progress-fill" id="progressFill"></div>
                        </div>
                        <div class="time-display">
                            <span id="currentTime">0:00</span> / <span id="duration">0:00</span>
                        </div>
                    </div>

                    <button id="syncBtn" class="control-btn" onclick="requestSync()" disabled>Sync</button>
                </div>
            </div>
        </div>

        <!-- Sidebar -->
        <div class="sidebar">
            <div class="sidebar-tabs">
                <button class="sidebar-tab active" onclick="switchSidebarTab('chat')">Chat</button>
                <button class="sidebar-tab" onclick="switchSidebarTab('invite')">Invite</button>
                <button class="sidebar-tab" onclick="switchSidebarTab('viewers')">Viewers</button>
            </div>

            <!-- Chat Panel -->
            <div id="chatPanel" class="sidebar-content active">
                <div class="chat-messages" id="chatMessages"></div>
                <div class="reactions-bar">
                    <button class="reaction-btn" onclick="sendReaction('fire')">üî•</button>
                    <button class="reaction-btn" onclick="sendReaction('laugh')">üòÇ</button>
                    <button class="reaction-btn" onclick="sendReaction('wow')">üòÆ</button>
                    <button class="reaction-btn" onclick="sendReaction('sad')">üò¢</button>
                    <button class="reaction-btn" onclick="sendReaction('heart')">‚ù§Ô∏è</button>
                    <button class="reaction-btn" onclick="sendReaction('clap')">üëè</button>
                </div>
                <div class="chat-input-container">
                    <input type="text" id="chatInput" placeholder="Type a message..." onkeypress="handleChatKeypress(event)">
                </div>
            </div>

            <!-- Invite Panel -->
            <div id="invitePanel" class="sidebar-content">
                <div class="invite-panel">
                    <h3>Invite Friends</h3>
                    <div class="qr-container" id="qrContainer">
                        <div class="qr-placeholder">Start hosting to generate invite QR code</div>
                    </div>
                    <div class="shareable-url" id="shareableUrl">Invite link will appear here...</div>
                    <div class="invite-buttons">
                        <button class="btn-copy" onclick="copyInviteLink()">Copy Link</button>
                        <button class="btn-share" onclick="shareInvite()">Share</button>
                    </div>
                </div>
            </div>

            <!-- Viewers Panel -->
            <div id="viewersPanel" class="sidebar-content">
                <div class="viewers-panel" id="viewersList">
                    <!-- Viewers will be listed here -->
                </div>
            </div>
        </div>
    </div>

    <!-- PeerJS Library -->
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>

    <script>
        // ==================== APP CONFIG ====================
        const APP_NAME = 'watch-party-sync';
        let appData = JSON.parse(localStorage.getItem(APP_NAME) || '{"parties": [], "nickname": ""}');

        // ==================== STATE ====================
        let peer = null;
        let peerId = null;
        let connections = [];
        let isHost = false;
        let nickname = '';
        let viewers = [];
        let currentShareableUrl = '';

        // Video state
        let videoLoaded = false;
        let isSyncing = false;
        let isYouTube = false;
        let ytPlayer = null;
        let ytReady = false;
        let ytProgressInterval = null;

        // Webcam state
        let webcamStream = null;
        let webcamEnabled = false;
        let mediaCalls = [];  // PeerJS media calls for streaming webcam

        // ==================== PEER SETUP ====================

        function initPeer() {
            return new Promise((resolve, reject) => {
                peer = new Peer();

                peer.on('open', (id) => {
                    peerId = id;
                    console.log('My peer ID:', id);
                    resolve(id);
                });

                peer.on('error', (err) => {
                    console.error('Peer error:', err);
                    showToast('Connection error: ' + err.type, 'error');
                    reject(err);
                });

                peer.on('connection', (conn) => {
                    handleIncomingConnection(conn);
                });

                // Handle incoming media calls (webcam streams)
                peer.on('call', (call) => {
                    handleIncomingCall(call);
                });
            });
        }

        function handleIncomingConnection(conn) {
            console.log('Incoming connection from:', conn.peer);

            conn.on('open', () => {
                connections.push(conn);
                updateViewerCount();

                // Send current state to new viewer
                if (isHost) {
                    sendToConnection(conn, {
                        type: 'init',
                        hostNickname: nickname,
                        videoUrl: document.getElementById('videoUrlInput').value,
                        videoState: getVideoState(),
                        viewers: viewers
                    });

                    // If webcam is active, stream to new viewer
                    if (webcamEnabled && webcamStream) {
                        setTimeout(() => {
                            streamWebcamToPeer(conn.peer);
                        }, 500); // Small delay to ensure connection is fully established
                    }
                }

                addSystemMessage(`${conn.metadata?.nickname || 'Someone'} joined the party!`);
            });

            conn.on('data', (data) => {
                handleMessage(conn, data);
            });

            conn.on('close', () => {
                connections = connections.filter(c => c !== conn);
                viewers = viewers.filter(v => v.peerId !== conn.peer);
                updateViewerCount();
                updateViewersList();
                broadcastViewers();
                addSystemMessage(`${conn.metadata?.nickname || 'Someone'} left the party`);
            });
        }

        function connectToPeer(hostId) {
            return new Promise((resolve, reject) => {
                const conn = peer.connect(hostId, {
                    metadata: { nickname: nickname }
                });

                conn.on('open', () => {
                    connections.push(conn);
                    console.log('Connected to host:', hostId);

                    // Send join message
                    sendToConnection(conn, {
                        type: 'join',
                        nickname: nickname,
                        peerId: peerId
                    });

                    resolve(conn);
                });

                conn.on('data', (data) => {
                    handleMessage(conn, data);
                });

                conn.on('close', () => {
                    connections = connections.filter(c => c !== conn);
                    updateSyncStatus('disconnected');
                    showToast('Disconnected from host');
                });

                conn.on('error', reject);
            });
        }

        // ==================== MESSAGE HANDLING ====================

        function handleMessage(conn, data) {
            console.log('Received:', data.type);

            switch (data.type) {
                case 'init':
                    // Initial state from host
                    if (data.videoUrl) {
                        document.getElementById('videoUrlInput').value = data.videoUrl;
                        loadVideo(false); // Don't broadcast
                    }
                    if (data.videoState) {
                        applyVideoState(data.videoState);
                    }
                    viewers = data.viewers || [];
                    updateViewersList();
                    updateSyncStatus('connected');
                    break;

                case 'join':
                    // New viewer joined (host receives this)
                    viewers.push({
                        peerId: data.peerId,
                        nickname: data.nickname,
                        isHost: false
                    });
                    updateViewersList();
                    broadcastViewers();
                    break;

                case 'viewers':
                    // Updated viewers list
                    viewers = data.viewers;
                    updateViewersList();
                    break;

                case 'video-load':
                    document.getElementById('videoUrlInput').value = data.url;
                    loadVideo(false);
                    break;

                case 'play':
                    playVideo(false);
                    if (data.time !== undefined) {
                        seekToTime(data.time);
                    }
                    break;

                case 'pause':
                    pauseVideo(false);
                    if (data.time !== undefined) {
                        seekToTime(data.time);
                    }
                    break;

                case 'seek':
                    seekToTime(data.time);
                    break;

                case 'sync':
                    applyVideoState(data.state);
                    break;

                case 'sync-request':
                    if (isHost) {
                        broadcast({ type: 'sync', state: getVideoState() });
                    }
                    break;

                case 'chat':
                    addChatMessage(data.nickname, data.message);
                    break;

                case 'reaction':
                    showFloatingReaction(data.emoji);
                    break;

                case 'webcam-stopped':
                    // Host stopped their webcam
                    document.getElementById('remoteWebcamsContainer').innerHTML = '';
                    addSystemMessage('Host stopped their webcam');
                    break;
            }
        }

        function sendToConnection(conn, data) {
            if (conn.open) {
                conn.send(data);
            }
        }

        function broadcast(data) {
            connections.forEach(conn => sendToConnection(conn, data));
        }

        function broadcastViewers() {
            broadcast({ type: 'viewers', viewers: viewers });
        }

        // ==================== HOST / JOIN ====================

        async function hostParty() {
            nickname = document.getElementById('nicknameInput').value.trim() || 'Host';
            appData.nickname = nickname;
            saveData();

            isHost = true;
            document.getElementById('setupModal').classList.add('hidden');

            try {
                await initPeer();

                viewers = [{
                    peerId: peerId,
                    nickname: nickname,
                    isHost: true
                }];

                updateViewersList();
                generateInviteQR();
                updateSyncStatus('connected');
                showToast('Party started! Share the invite link.');
                enableControls(true);

                // Show webcam toggle button for host
                document.getElementById('webcamToggleBtn').style.display = 'flex';
                initWebcamDrag();

            } catch (err) {
                showToast('Failed to start party: ' + err.message, 'error');
            }
        }

        function showJoinInput() {
            document.getElementById('joinInputContainer').style.display = 'block';

            // Check URL for party code
            const urlParams = new URLSearchParams(window.location.search);
            const partyCode = urlParams.get('party');
            if (partyCode) {
                document.getElementById('joinCodeInput').value = partyCode;
            }
        }

        async function joinParty() {
            nickname = document.getElementById('nicknameInput').value.trim() || 'Guest';
            appData.nickname = nickname;
            saveData();

            let joinInput = document.getElementById('joinCodeInput').value.trim();

            // Extract party code from URL if full URL pasted
            if (joinInput.includes('?party=')) {
                const url = new URL(joinInput);
                joinInput = url.searchParams.get('party');
            }

            if (!joinInput) {
                showToast('Please enter a party code or link', 'error');
                return;
            }

            isHost = false;
            document.getElementById('setupModal').classList.add('hidden');
            updateSyncStatus('syncing');

            try {
                await initPeer();
                await connectToPeer(joinInput);

                showToast('Joined the party!');
                enableControls(false); // Viewers have limited controls

                // Clean URL
                window.history.replaceState({}, document.title, window.location.pathname);

            } catch (err) {
                showToast('Failed to join: ' + err.message, 'error');
                document.getElementById('setupModal').classList.remove('hidden');
            }
        }

        // ==================== YOUTUBE SUPPORT ====================

        // Extract YouTube video ID from various URL formats
        function getYouTubeVideoId(url) {
            const patterns = [
                /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/|youtube\.com\/v\/|youtube\.com\/shorts\/)([a-zA-Z0-9_-]{11})/,
                /^([a-zA-Z0-9_-]{11})$/  // Just the ID
            ];
            for (const pattern of patterns) {
                const match = url.match(pattern);
                if (match) return match[1];
            }
            return null;
        }

        // Load YouTube IFrame API
        function loadYouTubeAPI() {
            return new Promise((resolve, reject) => {
                if (window.YT && window.YT.Player) {
                    resolve();
                    return;
                }

                // Set up callback before loading script
                window.onYouTubeIframeAPIReady = () => {
                    console.log('YouTube API ready');
                    resolve();
                };

                const script = document.createElement('script');
                script.src = 'https://www.youtube.com/iframe_api';
                script.onerror = reject;
                document.head.appendChild(script);

                // Timeout fallback
                setTimeout(() => reject(new Error('YouTube API load timeout')), 10000);
            });
        }

        // Create YouTube player
        function createYouTubePlayer(videoId) {
            return new Promise((resolve, reject) => {
                try {
                    // Clear any existing player
                    if (ytPlayer) {
                        ytPlayer.destroy();
                        ytPlayer = null;
                    }

                    const container = document.getElementById('youtubePlayer');
                    container.innerHTML = '';

                    ytPlayer = new YT.Player('youtubePlayer', {
                        width: '100%',
                        height: '100%',
                        videoId: videoId,
                        playerVars: {
                            autoplay: 0,
                            controls: 0,  // Hide YouTube controls (we use our own)
                            disablekb: 1, // Disable keyboard controls
                            modestbranding: 1,
                            rel: 0,
                            fs: 0,
                            playsinline: 1
                        },
                        events: {
                            onReady: (event) => {
                                ytReady = true;
                                videoLoaded = true;
                                enablePlaybackControls(true);
                                updateYouTubeDuration();
                                startYouTubeProgressUpdate();
                                showToast('YouTube video loaded!');
                                resolve(event.target);
                            },
                            onStateChange: (event) => {
                                handleYouTubeStateChange(event);
                            },
                            onError: (event) => {
                                console.error('YouTube error:', event.data);
                                showToast('YouTube video error', 'error');
                                reject(new Error('YouTube error: ' + event.data));
                            }
                        }
                    });
                } catch (err) {
                    reject(err);
                }
            });
        }

        function handleYouTubeStateChange(event) {
            // YT.PlayerState: UNSTARTED (-1), ENDED (0), PLAYING (1), PAUSED (2), BUFFERING (3), CUED (5)
            if (event.data === YT.PlayerState.PLAYING) {
                document.getElementById('playPauseBtn').textContent = 'Pause';
            } else if (event.data === YT.PlayerState.PAUSED) {
                document.getElementById('playPauseBtn').textContent = 'Play';
            }
        }

        function startYouTubeProgressUpdate() {
            if (ytProgressInterval) clearInterval(ytProgressInterval);
            ytProgressInterval = setInterval(() => {
                if (ytPlayer && ytReady) {
                    updateYouTubeProgress();
                }
            }, 250);
        }

        function updateYouTubeProgress() {
            if (!ytPlayer || !ytReady) return;
            try {
                const currentTime = ytPlayer.getCurrentTime();
                const duration = ytPlayer.getDuration();
                const progress = (currentTime / duration) * 100;
                document.getElementById('progressFill').style.width = progress + '%';
                document.getElementById('currentTime').textContent = formatTime(currentTime);
            } catch (e) {}
        }

        function updateYouTubeDuration() {
            if (!ytPlayer || !ytReady) return;
            try {
                const duration = ytPlayer.getDuration();
                document.getElementById('duration').textContent = formatTime(duration);
            } catch (e) {}
        }

        // ==================== VIDEO CONTROLS ====================

        function loadVideo(shouldBroadcast = true) {
            const url = document.getElementById('videoUrlInput').value.trim();
            if (!url) {
                showToast('Please enter a video URL', 'error');
                return;
            }

            // Check if it's a YouTube URL
            const ytVideoId = getYouTubeVideoId(url);

            if (ytVideoId) {
                // Load as YouTube
                isYouTube = true;
                document.getElementById('mainVideo').style.display = 'none';
                document.getElementById('youtubeContainer').style.display = 'block';
                document.getElementById('videoPlaceholder').style.display = 'none';

                loadYouTubeAPI()
                    .then(() => createYouTubePlayer(ytVideoId))
                    .catch(err => {
                        showToast('Failed to load YouTube: ' + err.message, 'error');
                        console.error(err);
                    });
            } else {
                // Load as regular video
                isYouTube = false;
                if (ytProgressInterval) clearInterval(ytProgressInterval);

                document.getElementById('youtubeContainer').style.display = 'none';
                const video = document.getElementById('mainVideo');
                video.src = url;
                video.style.display = 'block';
                document.getElementById('videoPlaceholder').style.display = 'none';

                video.onloadedmetadata = () => {
                    videoLoaded = true;
                    enablePlaybackControls(true);
                    updateDuration();
                    showToast('Video loaded!');
                };

                video.onerror = () => {
                    showToast('Failed to load video. Check the URL.', 'error');
                };

                video.ontimeupdate = updateProgress;
            }

            if (shouldBroadcast && isHost) {
                broadcast({ type: 'video-load', url: url });
            }
        }

        function loadLocalVideo(event) {
            const file = event.target.files[0];
            if (!file) return;

            isYouTube = false;
            if (ytProgressInterval) clearInterval(ytProgressInterval);

            const url = URL.createObjectURL(file);
            document.getElementById('videoUrlInput').value = `[Local: ${file.name}]`;

            document.getElementById('youtubeContainer').style.display = 'none';
            const video = document.getElementById('mainVideo');
            video.src = url;
            video.style.display = 'block';
            document.getElementById('videoPlaceholder').style.display = 'none';

            video.onloadedmetadata = () => {
                videoLoaded = true;
                enablePlaybackControls(true);
                updateDuration();
                showToast('Local video loaded!');
            };

            video.ontimeupdate = updateProgress;

            if (connections.length > 0) {
                addSystemMessage('Note: Local videos cannot be synced. Use a YouTube or direct URL for sync.');
            }
        }

        function togglePlayPause() {
            if (isYouTube && ytPlayer && ytReady) {
                const state = ytPlayer.getPlayerState();
                if (state === YT.PlayerState.PLAYING) {
                    pauseVideo(true);
                } else {
                    playVideo(true);
                }
            } else {
                const video = document.getElementById('mainVideo');
                if (video.paused) {
                    playVideo(true);
                } else {
                    pauseVideo(true);
                }
            }
        }

        function playVideo(shouldBroadcast = true) {
            if (isYouTube && ytPlayer && ytReady) {
                ytPlayer.playVideo();
            } else {
                const video = document.getElementById('mainVideo');
                video.play();
            }
            document.getElementById('playPauseBtn').textContent = 'Pause';

            if (shouldBroadcast && isHost) {
                broadcast({ type: 'play', time: getCurrentTime() });
            }
        }

        function pauseVideo(shouldBroadcast = true) {
            if (isYouTube && ytPlayer && ytReady) {
                ytPlayer.pauseVideo();
            } else {
                const video = document.getElementById('mainVideo');
                video.pause();
            }
            document.getElementById('playPauseBtn').textContent = 'Play';

            if (shouldBroadcast && isHost) {
                broadcast({ type: 'pause', time: getCurrentTime() });
            }
        }

        function skip(seconds) {
            const currentTime = getCurrentTime();
            const duration = getDuration();
            const newTime = Math.max(0, Math.min(duration, currentTime + seconds));
            seekToTime(newTime);

            if (isHost) {
                broadcast({ type: 'seek', time: newTime });
            }
        }

        function seekVideo(event) {
            if (!isHost) return; // Only host can seek

            const bar = document.getElementById('progressBar');
            const rect = bar.getBoundingClientRect();
            const pos = (event.clientX - rect.left) / rect.width;

            const duration = getDuration();
            const newTime = pos * duration;
            seekToTime(newTime);

            broadcast({ type: 'seek', time: newTime });
        }

        function seekToTime(time) {
            if (isYouTube && ytPlayer && ytReady) {
                ytPlayer.seekTo(time, true);
            } else {
                const video = document.getElementById('mainVideo');
                video.currentTime = time;
            }
        }

        function getCurrentTime() {
            if (isYouTube && ytPlayer && ytReady) {
                return ytPlayer.getCurrentTime();
            } else {
                return document.getElementById('mainVideo').currentTime;
            }
        }

        function getDuration() {
            if (isYouTube && ytPlayer && ytReady) {
                return ytPlayer.getDuration();
            } else {
                return document.getElementById('mainVideo').duration;
            }
        }

        function isPaused() {
            if (isYouTube && ytPlayer && ytReady) {
                return ytPlayer.getPlayerState() !== YT.PlayerState.PLAYING;
            } else {
                return document.getElementById('mainVideo').paused;
            }
        }

        function requestSync() {
            if (!isHost && connections.length > 0) {
                connections[0].send({ type: 'sync-request' });
                showToast('Requesting sync...');
            } else if (isHost) {
                broadcast({ type: 'sync', state: getVideoState() });
                showToast('Synced all viewers');
            }
        }

        function getVideoState() {
            return {
                currentTime: getCurrentTime(),
                paused: isPaused(),
                isYouTube: isYouTube
            };
        }

        function applyVideoState(state) {
            const currentTime = getCurrentTime();
            if (Math.abs(currentTime - state.currentTime) > 1) {
                seekToTime(state.currentTime);
            }
            if (state.paused && !isPaused()) {
                pauseVideo(false);
            } else if (!state.paused && isPaused()) {
                playVideo(false);
            }
        }

        function updateProgress() {
            const video = document.getElementById('mainVideo');
            const progress = (video.currentTime / video.duration) * 100;
            document.getElementById('progressFill').style.width = progress + '%';
            document.getElementById('currentTime').textContent = formatTime(video.currentTime);
        }

        function updateDuration() {
            const video = document.getElementById('mainVideo');
            document.getElementById('duration').textContent = formatTime(video.duration);
        }

        function formatTime(seconds) {
            if (isNaN(seconds)) return '0:00';
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function enableControls(full) {
            document.getElementById('syncBtn').disabled = false;
            if (full) {
                enablePlaybackControls(videoLoaded);
            }
        }

        function enablePlaybackControls(enabled) {
            document.getElementById('playPauseBtn').disabled = !enabled;
            document.getElementById('skipBackBtn').disabled = !enabled || !isHost;
            document.getElementById('skipFwdBtn').disabled = !enabled || !isHost;
        }

        // ==================== CHAT & REACTIONS ====================

        function handleChatKeypress(event) {
            if (event.key === 'Enter') {
                const input = document.getElementById('chatInput');
                const message = input.value.trim();
                if (message) {
                    addChatMessage(nickname, message);
                    broadcast({ type: 'chat', nickname: nickname, message: message });
                    input.value = '';
                }
            }
        }

        function addChatMessage(sender, text) {
            const container = document.getElementById('chatMessages');
            const msg = document.createElement('div');
            msg.className = 'chat-message';
            msg.innerHTML = `
                <div class="sender">${escapeHtml(sender)}</div>
                <div class="text">${escapeHtml(text)}</div>
            `;
            container.appendChild(msg);
            container.scrollTop = container.scrollHeight;
        }

        function addSystemMessage(text) {
            const container = document.getElementById('chatMessages');
            const msg = document.createElement('div');
            msg.className = 'chat-message system';
            msg.innerHTML = `<div class="text">${escapeHtml(text)}</div>`;
            container.appendChild(msg);
            container.scrollTop = container.scrollHeight;
        }

        function sendReaction(type) {
            const emojis = {
                'fire': 'üî•', 'laugh': 'üòÇ', 'wow': 'üòÆ',
                'sad': 'üò¢', 'heart': '‚ù§Ô∏è', 'clap': 'üëè'
            };
            const emoji = emojis[type];
            showFloatingReaction(emoji);
            broadcast({ type: 'reaction', emoji: emoji });
        }

        function showFloatingReaction(emoji) {
            const reaction = document.createElement('div');
            reaction.className = 'floating-reaction';
            reaction.textContent = emoji;
            reaction.style.left = (Math.random() * 60 + 20) + '%';
            reaction.style.bottom = '100px';
            document.body.appendChild(reaction);
            setTimeout(() => reaction.remove(), 2000);
        }

        // ==================== WEBCAM STREAMING ====================

        async function toggleWebcam() {
            if (webcamEnabled) {
                stopWebcam();
            } else {
                await startWebcam();
            }
        }

        async function startWebcam() {
            try {
                webcamStream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 320, height: 240, facingMode: 'user' },
                    audio: false  // Audio handled separately if needed
                });

                // Show local preview
                const localVideo = document.getElementById('localWebcamVideo');
                localVideo.srcObject = webcamStream;
                document.getElementById('localWebcam').classList.remove('hidden');

                // Update button state
                webcamEnabled = true;
                const btn = document.getElementById('webcamToggleBtn');
                btn.classList.add('active');
                document.getElementById('webcamBtnText').textContent = 'Stop Cam';

                // Stream to all connected peers
                if (isHost) {
                    connections.forEach(conn => {
                        streamWebcamToPeer(conn.peer);
                    });
                    addSystemMessage('Webcam started - viewers can see your reaction!');
                }

                showToast('Webcam started!');

            } catch (err) {
                console.error('Webcam error:', err);
                showToast('Failed to access webcam: ' + err.message, 'error');
            }
        }

        function stopWebcam() {
            if (webcamStream) {
                webcamStream.getTracks().forEach(track => track.stop());
                webcamStream = null;
            }

            // Hide local preview
            document.getElementById('localWebcam').classList.add('hidden');
            document.getElementById('localWebcamVideo').srcObject = null;

            // Update button state
            webcamEnabled = false;
            const btn = document.getElementById('webcamToggleBtn');
            btn.classList.remove('active');
            document.getElementById('webcamBtnText').textContent = 'Start Cam';

            // Close all media calls
            mediaCalls.forEach(call => {
                try { call.close(); } catch (e) {}
            });
            mediaCalls = [];

            // Notify viewers
            if (isHost) {
                broadcast({ type: 'webcam-stopped' });
                addSystemMessage('Webcam stopped');
            }

            showToast('Webcam stopped');
        }

        function streamWebcamToPeer(peerId) {
            if (!webcamStream || !peer) return;

            console.log('Streaming webcam to:', peerId);

            const call = peer.call(peerId, webcamStream, {
                metadata: { nickname: nickname, type: 'webcam' }
            });

            call.on('error', (err) => {
                console.error('Media call error:', err);
            });

            call.on('close', () => {
                mediaCalls = mediaCalls.filter(c => c !== call);
            });

            mediaCalls.push(call);
        }

        function handleIncomingCall(call) {
            console.log('Incoming call from:', call.peer, call.metadata);

            // Answer the call (we don't send video back, just receive)
            call.answer();

            call.on('stream', (remoteStream) => {
                console.log('Received webcam stream from:', call.metadata?.nickname || 'Host');
                displayRemoteWebcam(remoteStream, call.metadata?.nickname || 'Host', call.peer);
            });

            call.on('close', () => {
                removeRemoteWebcam(call.peer);
            });

            call.on('error', (err) => {
                console.error('Incoming call error:', err);
            });
        }

        function displayRemoteWebcam(stream, name, peerId) {
            const container = document.getElementById('remoteWebcamsContainer');

            // Remove existing webcam from this peer if any
            removeRemoteWebcam(peerId);

            // Create webcam overlay
            const overlay = document.createElement('div');
            overlay.className = 'webcam-overlay remote';
            overlay.id = `webcam-${peerId}`;
            overlay.innerHTML = `
                <video autoplay playsinline></video>
                <div class="webcam-label">
                    <div class="live-indicator"></div>
                    <span>${escapeHtml(name)}</span>
                </div>
            `;

            const video = overlay.querySelector('video');
            video.srcObject = stream;

            container.appendChild(overlay);

            addSystemMessage(`${name}'s webcam is now live!`);
        }

        function removeRemoteWebcam(peerId) {
            const existing = document.getElementById(`webcam-${peerId}`);
            if (existing) {
                existing.remove();
            }
        }

        // Drag functionality for webcam overlay
        function initWebcamDrag() {
            const overlay = document.getElementById('localWebcam');
            let isDragging = false;
            let startX, startY, initialX, initialY;

            overlay.addEventListener('mousedown', (e) => {
                isDragging = true;
                overlay.classList.add('dragging');
                startX = e.clientX;
                startY = e.clientY;
                const rect = overlay.getBoundingClientRect();
                initialX = rect.left;
                initialY = rect.top;
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                overlay.style.left = (initialX + dx) + 'px';
                overlay.style.top = (initialY + dy) + 'px';
                overlay.style.right = 'auto';
                overlay.style.bottom = 'auto';
            });

            document.addEventListener('mouseup', () => {
                isDragging = false;
                overlay.classList.remove('dragging');
            });
        }

        // ==================== QR CODE & SHARING ====================

        function loadQRiousLibrary() {
            return new Promise((resolve, reject) => {
                if (window.QRious) {
                    resolve();
                    return;
                }
                const script = document.createElement('script');
                script.src = 'https://cdnjs.cloudflare.com/ajax/libs/qrious/4.0.2/qrious.min.js';
                script.onload = resolve;
                script.onerror = reject;
                document.head.appendChild(script);
            });
        }

        function generateInviteQR() {
            if (!peerId) return;

            const container = document.getElementById('qrContainer');
            const baseUrl = window.location.origin + window.location.pathname;
            currentShareableUrl = `${baseUrl}?party=${peerId}`;

            document.getElementById('shareableUrl').textContent = currentShareableUrl;

            container.innerHTML = '<div style="color: #666; padding: 20px;">Generating QR...</div>';

            loadQRiousLibrary().then(() => {
                container.innerHTML = '';
                const canvas = document.createElement('canvas');
                container.appendChild(canvas);

                new window.QRious({
                    element: canvas,
                    value: currentShareableUrl,
                    size: 180,
                    background: 'white',
                    foreground: 'black',
                    level: 'H'
                });
            }).catch(() => {
                // Fallback to API
                container.innerHTML = '';
                const img = document.createElement('img');
                img.src = `https://api.qrserver.com/v1/create-qr-code/?size=180x180&ecc=H&data=${encodeURIComponent(currentShareableUrl)}`;
                img.alt = 'Invite QR Code';
                container.appendChild(img);
            });
        }

        function copyInviteLink() {
            if (!currentShareableUrl) {
                showToast('No invite link yet', 'error');
                return;
            }
            navigator.clipboard.writeText(currentShareableUrl).then(() => {
                showToast('Link copied!');
            }).catch(() => {
                // Fallback
                const ta = document.createElement('textarea');
                ta.value = currentShareableUrl;
                document.body.appendChild(ta);
                ta.select();
                document.execCommand('copy');
                document.body.removeChild(ta);
                showToast('Link copied!');
            });
        }

        function shareInvite() {
            if (!currentShareableUrl) return;

            if (navigator.share) {
                navigator.share({
                    title: 'Join my Watch Party!',
                    text: 'Click to watch videos together in sync',
                    url: currentShareableUrl
                }).catch(() => copyInviteLink());
            } else {
                copyInviteLink();
            }
        }

        // ==================== UI HELPERS ====================

        function switchSidebarTab(tabName) {
            document.querySelectorAll('.sidebar-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.sidebar-content').forEach(c => c.classList.remove('active'));

            event.target.classList.add('active');
            document.getElementById(tabName + 'Panel').classList.add('active');
        }

        function updateSyncStatus(status) {
            const dot = document.getElementById('syncDot');
            const text = document.getElementById('syncStatus');

            dot.className = 'sync-dot';
            switch (status) {
                case 'connected':
                    dot.classList.add('connected');
                    text.textContent = isHost ? 'Hosting' : 'Connected';
                    break;
                case 'syncing':
                    dot.classList.add('syncing');
                    text.textContent = 'Connecting...';
                    break;
                default:
                    text.textContent = 'Not Connected';
            }
        }

        function updateViewerCount() {
            const count = isHost ? connections.length + 1 : connections.length + 1;
            document.getElementById('viewerCount').textContent = count + (count === 1 ? ' viewer' : ' viewers');
        }

        function updateViewersList() {
            const container = document.getElementById('viewersList');
            container.innerHTML = '';

            const allViewers = isHost ? viewers : [{ nickname: nickname, isHost: false, peerId: peerId }, ...viewers];

            allViewers.forEach(v => {
                const item = document.createElement('div');
                item.className = 'viewer-item';
                item.innerHTML = `
                    <div class="viewer-avatar">${v.nickname.charAt(0).toUpperCase()}</div>
                    <div class="viewer-info">
                        <div class="viewer-name">${escapeHtml(v.nickname)}</div>
                        <div class="viewer-status">${v.isHost ? 'Host' : 'Watching'}</div>
                    </div>
                    ${v.isHost ? '<span class="host-badge">HOST</span>' : ''}
                `;
                container.appendChild(item);
            });
        }

        function showToast(message, type = 'info') {
            const toast = document.createElement('div');
            toast.className = 'toast';
            toast.textContent = message;
            if (type === 'error') toast.style.background = '#ff4444';
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 3000);
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // ==================== DATA PERSISTENCE ====================

        function saveData() {
            localStorage.setItem(APP_NAME, JSON.stringify(appData));
        }

        function exportData() {
            const dataStr = JSON.stringify(appData, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `${APP_NAME}-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);
        }

        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    appData = JSON.parse(e.target.result);
                    saveData();
                    showToast('Data imported!');
                } catch {
                    showToast('Invalid file', 'error');
                }
            };
            reader.readAsText(file);
        }

        // ==================== INITIALIZATION ====================

        // Pre-fill nickname if saved
        if (appData.nickname) {
            document.getElementById('nicknameInput').value = appData.nickname;
        }

        // Check for party code in URL
        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.get('party')) {
            showJoinInput();
            document.getElementById('joinCodeInput').value = urlParams.get('party');
        }

        console.log('üé¨ Watch Party Sync - P2P Synchronized Viewing');
        console.log('üîó No servers. No accounts. Just vibes.');
        console.log('üì∑ Webcam reactions supported for hosts!');
    </script>
</body>
</html>
