<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Infinite Library - Quantum World</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', 'Times New Roman', serif;
            background: linear-gradient(135deg, #1a0f0a 0%, #2d1810 50%, #1a0f0a 100%);
            color: #e8d7b8;
            overflow: hidden;
            position: relative;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
            cursor: crosshair;
        }

        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        .ui-panel {
            pointer-events: all;
            background: rgba(26, 15, 10, 0.9);
            border: 2px solid rgba(232, 183, 120, 0.4);
            border-radius: 8px;
            padding: 15px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5), 0 0 30px rgba(232, 183, 120, 0.1);
        }

        #top-left-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            max-width: 350px;
        }

        #top-left-panel h1 {
            font-size: 1.4rem;
            color: #e8b778;
            margin-bottom: 10px;
            text-shadow: 0 0 20px rgba(232, 183, 120, 0.6);
            font-weight: normal;
        }

        #stats {
            font-size: 0.85rem;
            line-height: 1.8;
            color: #c4a572;
        }

        #stats div {
            margin: 5px 0;
        }

        #top-right-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            max-width: 300px;
        }

        #controls-section h3 {
            color: #e8b778;
            margin-bottom: 10px;
            font-size: 1rem;
            font-weight: normal;
        }

        .control-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
            font-size: 0.8rem;
        }

        .control-key {
            color: #d4a574;
            font-weight: bold;
            font-family: 'Courier New', monospace;
        }

        #spell-editor-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 450px;
            max-height: 400px;
            display: none;
        }

        #spell-editor-panel.visible {
            display: block;
        }

        #spell-editor-panel h3 {
            color: #e8b778;
            margin-bottom: 10px;
            font-size: 1rem;
        }

        #spell-code {
            width: 100%;
            height: 250px;
            background: rgba(10, 5, 3, 0.9);
            border: 1px solid rgba(232, 183, 120, 0.3);
            border-radius: 4px;
            color: #e8d7b8;
            padding: 10px;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            resize: vertical;
        }

        .button-row {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .action-button {
            background: linear-gradient(135deg, #8b5a2b 0%, #654321 100%);
            border: 2px solid rgba(232, 183, 120, 0.4);
            border-radius: 6px;
            padding: 8px 16px;
            color: #e8d7b8;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(139, 90, 43, 0.3);
            font-weight: 600;
            flex: 1;
        }

        .action-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(232, 183, 120, 0.4);
            border-color: rgba(232, 183, 120, 0.7);
            background: linear-gradient(135deg, #9b6a3b 0%, #754321 100%);
        }

        .action-button:active {
            transform: translateY(0);
        }

        #genre-panel {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 300px;
            max-height: 350px;
        }

        #genre-list {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
        }

        .genre-item {
            padding: 8px;
            margin: 5px 0;
            background: rgba(232, 183, 120, 0.1);
            border-left: 3px solid;
            border-radius: 4px;
            font-size: 0.8rem;
        }

        #marginalia-panel {
            position: absolute;
            left: 50%;
            bottom: 20px;
            transform: translateX(-50%);
            width: 400px;
            display: none;
        }

        #marginalia-panel.visible {
            display: block;
        }

        #marginalia-text {
            width: 100%;
            height: 80px;
            background: rgba(10, 5, 3, 0.9);
            border: 1px solid rgba(232, 183, 120, 0.3);
            border-radius: 4px;
            color: #e8d7b8;
            padding: 10px;
            font-family: 'Georgia', serif;
            font-size: 0.85rem;
            resize: none;
        }

        #connection-status {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 8px 20px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            border: 2px solid;
        }

        #connection-status.connected {
            background: rgba(101, 163, 13, 0.2);
            border-color: #65a30d;
            color: #a3e635;
        }

        #connection-status.offline {
            background: rgba(220, 38, 38, 0.2);
            border-color: #dc2626;
            color: #fca5a5;
        }

        #reading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        #reading-overlay.visible {
            display: flex;
        }

        .book-page {
            background: rgba(232, 215, 184, 0.95);
            border: 3px solid #8b5a2b;
            border-radius: 10px;
            padding: 40px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            color: #2d1810;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
        }

        .book-page h2 {
            color: #654321;
            margin-bottom: 20px;
            font-size: 1.5rem;
            text-align: center;
            border-bottom: 2px solid #8b5a2b;
            padding-bottom: 10px;
        }

        .book-page pre {
            background: rgba(45, 24, 16, 0.1);
            border: 1px solid #8b5a2b;
            border-radius: 4px;
            padding: 15px;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            color: #2d1810;
        }

        #modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        #modal-overlay.visible {
            display: flex;
        }

        .modal-content {
            background: linear-gradient(135deg, #2d1810 0%, #3d2820 100%);
            border: 3px solid rgba(232, 183, 120, 0.5);
            border-radius: 12px;
            padding: 30px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-content h2 {
            color: #e8b778;
            margin-bottom: 20px;
            text-shadow: 0 0 15px rgba(232, 183, 120, 0.5);
        }

        .modal-content textarea {
            width: 100%;
            min-height: 200px;
            background: rgba(10, 5, 3, 0.9);
            border: 2px solid rgba(232, 183, 120, 0.3);
            border-radius: 6px;
            color: #e8d7b8;
            padding: 12px;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            resize: vertical;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        #notification {
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(139, 90, 43, 0.95);
            border: 2px solid #e8b778;
            border-radius: 8px;
            padding: 15px 25px;
            color: #e8d7b8;
            font-size: 0.9rem;
            z-index: 999;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        #notification.visible {
            opacity: 1;
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(10, 5, 3, 0.5);
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(232, 183, 120, 0.5);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(232, 183, 120, 0.7);
        }

        @media (max-width: 768px) {
            #top-right-panel {
                display: none;
            }

            #spell-editor-panel,
            #genre-panel,
            #marginalia-panel {
                width: calc(100% - 40px);
                max-width: none;
            }

            #spell-editor-panel {
                left: 20px;
                right: 20px;
            }
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.5rem;
            color: #e8b778;
            text-shadow: 0 0 20px rgba(232, 183, 120, 0.8);
        }

        /* Merge animation effect */
        @keyframes merge-glow {
            0%, 100% { box-shadow: 0 0 20px rgba(232, 183, 120, 0.3); }
            50% { box-shadow: 0 0 40px rgba(232, 183, 120, 0.8), 0 0 60px rgba(139, 90, 43, 0.5); }
        }

        .merging {
            animation: merge-glow 2s infinite;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <div id="ui-overlay">
        <div id="top-left-panel" class="ui-panel">
            <h1>üìö The Infinite Library</h1>
            <div id="stats">
                <div>Position: <span id="player-pos">0, 0, 0</span></div>
                <div>Current Section: <span id="current-section">Unknown</span></div>
                <div>Books Nearby: <span id="nearby-books">0</span></div>
                <div>Spells Known: <span id="spells-count">1</span></div>
                <div>Genres Created: <span id="genres-count">0</span></div>
                <div>Marginalia Left: <span id="marginalia-count">0</span></div>
            </div>
        </div>

        <div id="top-right-panel" class="ui-panel">
            <div id="controls-section">
                <h3>Controls</h3>
                <div class="control-row">
                    <span class="control-key">WASD</span>
                    <span>Float/Move</span>
                </div>
                <div class="control-row">
                    <span class="control-key">SPACE</span>
                    <span>Ascend</span>
                </div>
                <div class="control-row">
                    <span class="control-key">SHIFT</span>
                    <span>Descend</span>
                </div>
                <div class="control-row">
                    <span class="control-key">E</span>
                    <span>Open Spell Book</span>
                </div>
                <div class="control-row">
                    <span class="control-key">R</span>
                    <span>Read Nearby Book</span>
                </div>
                <div class="control-row">
                    <span class="control-key">M</span>
                    <span>Leave Marginalia</span>
                </div>
                <div class="control-row">
                    <span class="control-key">CLICK</span>
                    <span>Cast Spell</span>
                </div>
            </div>
        </div>

        <div id="connection-status" class="offline">üåê Solo Mode</div>

        <div id="spell-editor-panel" class="ui-panel">
            <h3>‚ú® Your Spell Book</h3>
            <textarea id="spell-code" placeholder="// Write your spell code here...
// Available functions:
// - createLight(color, intensity)
// - changeGravity(amount)
// - spawnParticles(count, color)
// - modifyShelf(color)
// - giveEffect(targetBook, effectName)

createLight('#ffd700', 2);
spawnParticles(50, '#ff69b4');">// My first spell
createLight('#ffd700', 2);
spawnParticles(50, '#ff69b4');</textarea>
            <div class="button-row">
                <button class="action-button" id="save-spell-btn">Save Spell</button>
                <button class="action-button" id="close-spell-btn">Close</button>
            </div>
        </div>

        <div id="marginalia-panel" class="ui-panel">
            <h3>üìù Leave Marginalia</h3>
            <textarea id="marginalia-text" placeholder="Write your annotation here..."></textarea>
            <div class="button-row">
                <button class="action-button" id="save-marginalia-btn">Leave Note</button>
                <button class="action-button" id="close-marginalia-btn">Cancel</button>
            </div>
        </div>

        <div id="genre-panel" class="ui-panel">
            <h3>üé≠ Genre Collection</h3>
            <div id="genre-list">
                <div style="color: #c4a572; font-size: 0.8rem; font-style: italic;">
                    Merge with other books to create new genres...
                </div>
            </div>
            <div class="button-row" style="margin-top: 10px;">
                <button class="action-button" id="export-btn">Export Data</button>
                <button class="action-button" id="import-btn">Import Data</button>
            </div>
        </div>
    </div>

    <div id="reading-overlay">
        <div class="book-page">
            <h2 id="book-title">Book Title</h2>
            <div id="book-content"></div>
            <div class="button-row" style="margin-top: 20px;">
                <button class="action-button" id="execute-spell-btn">Execute Spell</button>
                <button class="action-button" id="close-book-btn">Close Book</button>
            </div>
        </div>
    </div>

    <div id="modal-overlay">
        <div class="modal-content">
            <h2 id="modal-title">Modal</h2>
            <div id="modal-body"></div>
            <div class="modal-buttons">
                <button class="action-button" id="modal-close">Close</button>
                <button class="action-button" id="modal-action" style="display: none;">Action</button>
            </div>
        </div>
    </div>

    <div id="notification"></div>

    <script>
        // ===== MINIMAL THREE.JS IMPLEMENTATION =====
        'use strict';

        const THREE = {
            Vector3: class {
                constructor(x = 0, y = 0, z = 0) {
                    this.x = x; this.y = y; this.z = z;
                }
                set(x, y, z) { this.x = x; this.y = y; this.z = z; return this; }
                clone() { return new THREE.Vector3(this.x, this.y, this.z); }
                copy(v) { this.x = v.x; this.y = v.y; this.z = v.z; return this; }
                add(v) { this.x += v.x; this.y += v.y; this.z += v.z; return this; }
                sub(v) { this.x -= v.x; this.y -= v.y; this.z -= v.z; return this; }
                multiplyScalar(s) { this.x *= s; this.y *= s; this.z *= s; return this; }
                length() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z); }
                normalize() { const len = this.length() || 1; return this.multiplyScalar(1 / len); }
                distanceTo(v) { const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z; return Math.sqrt(dx * dx + dy * dy + dz * dz); }
                dot(v) { return this.x * v.x + this.y * v.y + this.z * v.z; }
                lerp(v, alpha) { this.x += (v.x - this.x) * alpha; this.y += (v.y - this.y) * alpha; this.z += (v.z - this.z) * alpha; return this; }
            },
            Color: class {
                constructor(r, g, b) {
                    if (typeof r === 'string') this.setStyle(r);
                    else { this.r = r || 1; this.g = g || 1; this.b = b || 1; }
                }
                setStyle(style) {
                    const m = /^#([0-9a-f]{6})$/i.exec(style);
                    if (m) {
                        const hex = parseInt(m[1], 16);
                        this.r = ((hex >> 16) & 255) / 255;
                        this.g = ((hex >> 8) & 255) / 255;
                        this.b = (hex & 255) / 255;
                    }
                    return this;
                }
                getHex() { return (this.r * 255) << 16 ^ (this.g * 255) << 8 ^ (this.b * 255) << 0; }
                toHexString() { return '#' + ('000000' + this.getHex().toString(16)).slice(-6); }
            },
            MathUtils: {
                randFloat: (min, max) => min + Math.random() * (max - min),
                randInt: (min, max) => Math.floor(min + Math.random() * (max - min + 1)),
                clamp: (value, min, max) => Math.max(min, Math.min(max, value))
            }
        };

        // ===== THE INFINITE LIBRARY APPLICATION =====

        class InfiniteLibrary {
            constructor() {
                // Core rendering
                this.canvas = null;
                this.ctx = null;

                // Player state (as a sentient book)
                this.player = {
                    position: new THREE.Vector3(0, 0, 0),
                    velocity: new THREE.Vector3(0, 0, 0),
                    rotation: { pitch: 0, yaw: 0 },
                    title: this.generateBookTitle(),
                    author: this.generateAuthorName(),
                    genre: 'Mystery',
                    color: new THREE.Color(0.6, 0.4, 0.2),
                    pages: [],
                    currentSpell: '// My first spell\ncreateLight(\'#ffd700\', 2);\nspawnParticles(50, \'#ff69b4\');',
                    isOpen: false,
                    genresCreated: [],
                    marginalia: []
                };

                // World state
                this.shelves = [];
                this.chunks = new Map();
                this.books = [];
                this.marginaliaNotes = [];
                this.particles = [];
                this.lights = [];
                this.subWorlds = [];

                // Fractal generation
                this.seed = Math.floor(Math.random() * 1000000);
                this.chunkSize = 50;
                this.renderDistance = 150;

                // Input
                this.keys = {};
                this.mouse = { locked: false, deltaX: 0, deltaY: 0 };

                // Network (P2P)
                this.peerId = 'book_' + Math.random().toString(36).substr(2, 9);
                this.peers = new Map();

                // Time
                this.clock = { start: Date.now(), last: Date.now() };

                // Merge state
                this.mergeTarget = null;
                this.mergeProgress = 0;

                this.init();
            }

            init() {
                console.log('üìö Initializing The Infinite Library...');
                this.setupCanvas();
                this.loadState();
                this.generateInitialChunks();
                this.setupControls();
                this.setupUI();
                this.animate();
                this.showNotification('Welcome to The Infinite Library. You are now a sentient book.');
            }

            setupCanvas() {
                const container = document.getElementById('canvas-container');
                this.canvas = document.createElement('canvas');
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.ctx = this.canvas.getContext('2d');
                container.appendChild(this.canvas);

                window.addEventListener('resize', () => {
                    this.canvas.width = window.innerWidth;
                    this.canvas.height = window.innerHeight;
                });
            }

            generateInitialChunks() {
                // Generate chunks around starting position
                for (let x = -2; x <= 2; x++) {
                    for (let y = -2; y <= 2; y++) {
                        for (let z = -2; z <= 2; z++) {
                            this.generateChunk(x, y, z);
                        }
                    }
                }

                // Spawn some NPC books
                for (let i = 0; i < 5; i++) {
                    this.spawnBook(
                        new THREE.Vector3(
                            THREE.MathUtils.randFloat(-30, 30),
                            THREE.MathUtils.randFloat(-30, 30),
                            THREE.MathUtils.randFloat(-30, 30)
                        )
                    );
                }
            }

            generateChunk(cx, cy, cz) {
                const key = `${cx},${cy},${cz}`;
                if (this.chunks.has(key)) return;

                const chunk = {
                    x: cx, y: cy, z: cz,
                    shelves: [],
                    section: this.determineSection(cx, cy, cz)
                };

                // Generate shelves using fractal/recursive algorithm
                const shelfCount = THREE.MathUtils.randInt(10, 20);
                for (let i = 0; i < shelfCount; i++) {
                    const shelf = this.generateShelf(cx, cy, cz, i);
                    chunk.shelves.push(shelf);
                    this.shelves.push(shelf);
                }

                this.chunks.set(key, chunk);
            }

            generateShelf(cx, cy, cz, index) {
                const baseX = cx * this.chunkSize;
                const baseY = cy * this.chunkSize;
                const baseZ = cz * this.chunkSize;

                // Seeded random for consistency
                const hash = this.hashCoords(cx, cy, cz, index);

                return {
                    position: new THREE.Vector3(
                        baseX + (hash % this.chunkSize),
                        baseY + ((hash >> 8) % this.chunkSize),
                        baseZ + ((hash >> 16) % this.chunkSize)
                    ),
                    rotation: hash % 4,
                    length: 10 + (hash % 20),
                    height: 5 + (hash % 10),
                    color: this.getShelfColor(cx, cy, cz),
                    bookCount: THREE.MathUtils.randInt(5, 15)
                };
            }

            determineSection(cx, cy, cz) {
                const sections = [
                    'Ancient Mysteries', 'Modern Fiction', 'Quantum Philosophy',
                    'Lost Histories', 'Future Prophecies', 'Forbidden Knowledge',
                    'Children\'s Tales', 'Mathematical Proofs', 'Poetry & Verse',
                    'Cosmic Horror', 'Romance & Drama', 'Technical Manuals'
                ];
                const hash = this.hashCoords(cx, cy, cz, 0);
                return sections[hash % sections.length];
            }

            getShelfColor(cx, cy, cz) {
                const hash = this.hashCoords(cx, cy, cz, 0);
                const hue = (hash % 60) / 60;
                const lightness = 0.2 + (hash % 30) / 100;
                return this.hslToRgb(hue, 0.4, lightness);
            }

            hashCoords(x, y, z, seed) {
                let hash = this.seed + seed;
                hash = ((hash << 5) - hash) + x;
                hash = ((hash << 5) - hash) + y;
                hash = ((hash << 5) - hash) + z;
                return Math.abs(hash);
            }

            spawnBook(position, isPlayer = false) {
                const book = {
                    position: position.clone(),
                    velocity: new THREE.Vector3(0, 0, 0),
                    title: this.generateBookTitle(),
                    author: this.generateAuthorName(),
                    genre: this.randomGenre(),
                    color: new THREE.Color(Math.random(), Math.random(), Math.random()),
                    spell: this.generateRandomSpell(),
                    isPlayer: isPlayer,
                    isOpen: false,
                    rotation: Math.random() * Math.PI * 2,
                    floatOffset: Math.random() * Math.PI * 2
                };

                if (!isPlayer) {
                    this.books.push(book);
                }

                return book;
            }

            generateBookTitle() {
                const prefixes = ['The', 'A', 'An', 'Tales of', 'Chronicles of', 'The Secret', 'The Lost'];
                const subjects = ['Infinite', 'Eternal', 'Forgotten', 'Hidden', 'Ancient', 'Mystical', 'Quantum'];
                const nouns = ['Library', 'Archives', 'Codex', 'Tome', 'Manuscript', 'Scrolls', 'Pages', 'Words'];

                return `${prefixes[Math.floor(Math.random() * prefixes.length)]} ${subjects[Math.floor(Math.random() * subjects.length)]} ${nouns[Math.floor(Math.random() * nouns.length)]}`;
            }

            generateAuthorName() {
                const firsts = ['Jorge', 'Gabriel', 'Umberto', 'Italo', 'Vladimir', 'Franz', 'Hermann', 'Aldous'];
                const lasts = ['Borges', 'Marquez', 'Eco', 'Calvino', 'Nabokov', 'Kafka', 'Hesse', 'Huxley'];

                return `${firsts[Math.floor(Math.random() * firsts.length)]} ${lasts[Math.floor(Math.random() * lasts.length)]}`;
            }

            randomGenre() {
                const genres = ['Mystery', 'Fantasy', 'Science Fiction', 'Horror', 'Romance', 'Philosophy', 'Poetry', 'History'];
                return genres[Math.floor(Math.random() * genres.length)];
            }

            generateRandomSpell() {
                const spells = [
                    'createLight(\'#ff6b6b\', 3);\nspawnParticles(100, \'#4ecdc4\');',
                    'changeGravity(0.5);\nmodifyShelf(\'#ffd93d\');',
                    'spawnParticles(200, \'#a8dadc\');\ncreateLight(\'#457b9d\', 2);',
                    'modifyShelf(\'#e63946\');\ncreateLight(\'#f1faee\', 1);'
                ];
                return spells[Math.floor(Math.random() * spells.length)];
            }

            setupControls() {
                // Keyboard
                window.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;

                    if (e.code === 'KeyE') {
                        e.preventDefault();
                        this.toggleSpellEditor();
                    }
                    if (e.code === 'KeyR') {
                        e.preventDefault();
                        this.readNearbyBook();
                    }
                    if (e.code === 'KeyM') {
                        e.preventDefault();
                        this.toggleMarginalia();
                    }
                });

                window.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                });

                // Mouse
                this.canvas.addEventListener('click', () => {
                    if (!this.mouse.locked) {
                        this.canvas.requestPointerLock();
                    } else {
                        this.castSpell();
                    }
                });

                document.addEventListener('pointerlockchange', () => {
                    this.mouse.locked = document.pointerLockElement === this.canvas;
                });

                document.addEventListener('mousemove', (e) => {
                    if (this.mouse.locked) {
                        this.mouse.deltaX = e.movementX;
                        this.mouse.deltaY = e.movementY;
                    }
                });
            }

            setupUI() {
                document.getElementById('save-spell-btn').addEventListener('click', () => {
                    this.player.currentSpell = document.getElementById('spell-code').value;
                    this.showNotification('Spell saved to your book');
                    this.toggleSpellEditor();
                });

                document.getElementById('close-spell-btn').addEventListener('click', () => {
                    this.toggleSpellEditor();
                });

                document.getElementById('save-marginalia-btn').addEventListener('click', () => {
                    this.saveMarginalia();
                });

                document.getElementById('close-marginalia-btn').addEventListener('click', () => {
                    this.toggleMarginalia();
                });

                document.getElementById('execute-spell-btn').addEventListener('click', () => {
                    this.executeReadSpell();
                });

                document.getElementById('close-book-btn').addEventListener('click', () => {
                    this.closeReadingOverlay();
                });

                document.getElementById('export-btn').addEventListener('click', () => {
                    this.exportData();
                });

                document.getElementById('import-btn').addEventListener('click', () => {
                    this.showImportModal();
                });

                document.getElementById('modal-close').addEventListener('click', () => {
                    this.hideModal();
                });

                this.updateStats();
            }

            animate() {
                requestAnimationFrame(() => this.animate());

                const now = Date.now();
                const delta = (now - this.clock.last) / 1000;
                this.clock.last = now;

                this.updatePlayer(delta);
                this.updateBooks(delta);
                this.updateParticles(delta);
                this.updateChunks();
                this.checkMerge();
                this.render();
                this.updateStats();
            }

            updatePlayer(delta) {
                const speed = 20;
                const rotSpeed = 0.002;

                // Camera rotation
                this.player.rotation.yaw -= this.mouse.deltaX * rotSpeed;
                this.player.rotation.pitch -= this.mouse.deltaY * rotSpeed;
                this.player.rotation.pitch = THREE.MathUtils.clamp(this.player.rotation.pitch, -Math.PI / 2, Math.PI / 2);
                this.mouse.deltaX = 0;
                this.mouse.deltaY = 0;

                // Movement
                const forward = new THREE.Vector3(
                    -Math.sin(this.player.rotation.yaw),
                    0,
                    -Math.cos(this.player.rotation.yaw)
                );
                const right = new THREE.Vector3(
                    Math.cos(this.player.rotation.yaw),
                    0,
                    -Math.sin(this.player.rotation.yaw)
                );

                const movement = new THREE.Vector3(0, 0, 0);

                if (this.keys.KeyW) movement.add(forward);
                if (this.keys.KeyS) movement.sub(forward);
                if (this.keys.KeyD) movement.add(right);
                if (this.keys.KeyA) movement.sub(right);
                if (this.keys.Space) movement.y += 1;
                if (this.keys.ShiftLeft || this.keys.ShiftRight) movement.y -= 1;

                if (movement.length() > 0) {
                    movement.normalize().multiplyScalar(speed * delta);
                    this.player.velocity.lerp(movement, 0.1);
                } else {
                    this.player.velocity.multiplyScalar(0.9);
                }

                this.player.position.add(this.player.velocity);
            }

            updateBooks(delta) {
                const time = (Date.now() - this.clock.start) / 1000;

                this.books.forEach((book, index) => {
                    // Gentle floating
                    book.floatOffset += delta;
                    book.position.y += Math.sin(book.floatOffset * 2) * 0.01;

                    // Slow rotation
                    book.rotation += delta * 0.1;

                    // Drift slowly
                    book.velocity.x += (Math.random() - 0.5) * 0.01;
                    book.velocity.z += (Math.random() - 0.5) * 0.01;
                    book.velocity.multiplyScalar(0.99);
                    book.position.add(book.velocity);
                });
            }

            updateParticles(delta) {
                this.particles = this.particles.filter(p => {
                    p.life -= delta;
                    p.position.add(p.velocity);
                    p.velocity.multiplyScalar(0.98);
                    return p.life > 0;
                });
            }

            updateChunks() {
                // Chunk-based loading for infinite world
                const px = Math.floor(this.player.position.x / this.chunkSize);
                const py = Math.floor(this.player.position.y / this.chunkSize);
                const pz = Math.floor(this.player.position.z / this.chunkSize);

                const loadRadius = 3;

                for (let x = px - loadRadius; x <= px + loadRadius; x++) {
                    for (let y = py - loadRadius; y <= py + loadRadius; y++) {
                        for (let z = pz - loadRadius; z <= pz + loadRadius; z++) {
                            this.generateChunk(x, y, z);
                        }
                    }
                }

                // Unload distant chunks (performance)
                const unloadRadius = 5;
                for (const [key, chunk] of this.chunks) {
                    if (Math.abs(chunk.x - px) > unloadRadius ||
                        Math.abs(chunk.y - py) > unloadRadius ||
                        Math.abs(chunk.z - pz) > unloadRadius) {
                        // Would unload here in production
                        // this.chunks.delete(key);
                    }
                }
            }

            checkMerge() {
                // Check if near another book for merging
                let nearest = null;
                let nearestDist = 10;

                this.books.forEach(book => {
                    const dist = this.player.position.distanceTo(book.position);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearest = book;
                    }
                });

                if (nearest && nearestDist < 5) {
                    this.mergeTarget = nearest;
                    this.mergeProgress += 0.01;

                    if (this.mergeProgress >= 1) {
                        this.performMerge(nearest);
                        this.mergeProgress = 0;
                        this.mergeTarget = null;
                    }
                } else {
                    this.mergeTarget = null;
                    this.mergeProgress = 0;
                }
            }

            performMerge(otherBook) {
                // Create new genre by blending
                const newGenre = `${this.player.genre}-${otherBook.genre} Fusion`;

                const genre = {
                    name: newGenre,
                    parentGenres: [this.player.genre, otherBook.genre],
                    color: new THREE.Color(
                        (this.player.color.r + otherBook.color.r) / 2,
                        (this.player.color.g + otherBook.color.g) / 2,
                        (this.player.color.b + otherBook.color.b) / 2
                    ),
                    createdAt: Date.now(),
                    spell: this.blendSpells(this.player.currentSpell, otherBook.spell)
                };

                this.player.genresCreated.push(genre);
                this.showNotification(`Created new genre: ${newGenre}!`);
                this.updateGenreList();

                // Visual effect
                this.spawnParticles(100, genre.color.toHexString(), this.player.position);
            }

            blendSpells(spell1, spell2) {
                // Combine both spells
                return `// Blended spell\n${spell1}\n\n// From merged book:\n${spell2}`;
            }

            castSpell() {
                if (!this.mouse.locked) return;

                try {
                    this.executeSandboxedCode(this.player.currentSpell);
                    this.showNotification('Spell cast!');
                } catch (error) {
                    this.showNotification('Spell failed: ' + error.message);
                }
            }

            executeSandboxedCode(code) {
                // Sandboxed execution with limited API
                const sandbox = {
                    createLight: (color, intensity) => {
                        this.lights.push({
                            position: this.player.position.clone(),
                            color: new THREE.Color(color),
                            intensity: intensity,
                            life: 5
                        });
                    },
                    changeGravity: (amount) => {
                        // Placeholder - would affect physics
                        this.showNotification(`Gravity changed by ${amount}`);
                    },
                    spawnParticles: (count, color) => {
                        this.spawnParticles(count, color, this.player.position);
                    },
                    modifyShelf: (color) => {
                        // Find nearest shelf and change color
                        let nearest = null;
                        let nearestDist = Infinity;
                        this.shelves.forEach(shelf => {
                            const dist = this.player.position.distanceTo(shelf.position);
                            if (dist < nearestDist) {
                                nearestDist = dist;
                                nearest = shelf;
                            }
                        });
                        if (nearest && nearestDist < 30) {
                            nearest.color = color;
                        }
                    },
                    giveEffect: (targetBook, effectName) => {
                        this.showNotification(`Effect '${effectName}' applied`);
                    }
                };

                // Execute with timeout
                const func = new Function(...Object.keys(sandbox), code);
                const timeout = setTimeout(() => {
                    throw new Error('Spell execution timeout');
                }, 1000);

                try {
                    func(...Object.values(sandbox));
                } finally {
                    clearTimeout(timeout);
                }
            }

            readNearbyBook() {
                let nearest = null;
                let nearestDist = 20;

                this.books.forEach(book => {
                    const dist = this.player.position.distanceTo(book.position);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearest = book;
                    }
                });

                if (nearest) {
                    this.showReadingOverlay(nearest);
                } else {
                    this.showNotification('No books nearby to read');
                }
            }

            showReadingOverlay(book) {
                document.getElementById('book-title').textContent = book.title;
                document.getElementById('book-content').innerHTML = `
                    <p><strong>Author:</strong> ${book.author}</p>
                    <p><strong>Genre:</strong> ${book.genre}</p>
                    <p style="margin: 20px 0; font-style: italic;">
                        "In the infinite library, every book contains a spell, a fragment of reality waiting to be read..."
                    </p>
                    <p><strong>Spell Code:</strong></p>
                    <pre>${this.escapeHtml(book.spell)}</pre>
                `;
                this.currentReadBook = book;
                document.getElementById('reading-overlay').classList.add('visible');
            }

            closeReadingOverlay() {
                document.getElementById('reading-overlay').classList.remove('visible');
                this.currentReadBook = null;
            }

            executeReadSpell() {
                if (!this.currentReadBook) return;

                try {
                    this.executeSandboxedCode(this.currentReadBook.spell);
                    this.showNotification(`Executed ${this.currentReadBook.title}'s spell!`);
                } catch (error) {
                    this.showNotification('Spell execution failed: ' + error.message);
                }
            }

            toggleSpellEditor() {
                const panel = document.getElementById('spell-editor-panel');
                panel.classList.toggle('visible');
            }

            toggleMarginalia() {
                const panel = document.getElementById('marginalia-panel');
                panel.classList.toggle('visible');
            }

            saveMarginalia() {
                const text = document.getElementById('marginalia-text').value.trim();
                if (!text) return;

                const note = {
                    text: text,
                    position: this.player.position.clone(),
                    author: this.player.author,
                    timestamp: Date.now(),
                    votes: 0
                };

                this.marginaliaNotes.push(note);
                this.player.marginalia.push(note);

                // Check for reality manifestation (multiple notes in same area)
                this.checkRealityManifestation(note.position);

                this.showNotification('Marginalia left');
                document.getElementById('marginalia-text').value = '';
                this.toggleMarginalia();
            }

            checkRealityManifestation(position) {
                // Count nearby marginalia
                const radius = 20;
                const nearby = this.marginaliaNotes.filter(note =>
                    note.position.distanceTo(position) < radius
                );

                if (nearby.length >= 3) {
                    // Manifest reality - create special shelf or portal
                    this.showNotification('Reality manifests from accumulated marginalia!');
                    this.spawnParticles(200, '#ffd700', position);
                }
            }

            spawnParticles(count, color, position) {
                for (let i = 0; i < count; i++) {
                    this.particles.push({
                        position: position.clone(),
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 5,
                            (Math.random() - 0.5) * 5,
                            (Math.random() - 0.5) * 5
                        ),
                        color: color,
                        life: 2 + Math.random() * 2,
                        size: 2 + Math.random() * 3
                    });
                }
            }

            render() {
                const ctx = this.ctx;
                const w = this.canvas.width;
                const h = this.canvas.height;

                // Clear with library atmosphere
                ctx.fillStyle = '#1a0f0a';
                ctx.fillRect(0, 0, w, h);

                // Draw shelves
                this.shelves.forEach(shelf => {
                    if (this.player.position.distanceTo(shelf.position) > this.renderDistance) return;

                    const projected = this.project(shelf.position);
                    if (!projected) return;

                    ctx.fillStyle = shelf.color || '#8b5a2b';
                    ctx.fillRect(projected.x - 30, projected.y - 10, 60, 20);

                    // Draw book spines
                    for (let i = 0; i < shelf.bookCount; i++) {
                        ctx.fillStyle = this.randomBookSpineColor();
                        ctx.fillRect(projected.x - 30 + i * 5, projected.y - 10, 4, 20);
                    }
                });

                // Draw other books
                this.books.forEach(book => {
                    const projected = this.project(book.position);
                    if (!projected) return;

                    // Draw book
                    ctx.save();
                    ctx.translate(projected.x, projected.y);
                    ctx.rotate(book.rotation);

                    const w = book.isOpen ? 30 : 20;
                    const h = book.isOpen ? 25 : 15;

                    ctx.fillStyle = book.color.toHexString();
                    ctx.fillRect(-w/2, -h/2, w, h);

                    // Outline
                    ctx.strokeStyle = '#e8b778';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(-w/2, -h/2, w, h);

                    ctx.restore();

                    // Label
                    ctx.fillStyle = '#e8d7b8';
                    ctx.font = '10px Georgia';
                    ctx.textAlign = 'center';
                    ctx.fillText(book.title.substring(0, 15), projected.x, projected.y + 25);
                });

                // Draw marginalia notes
                this.marginaliaNotes.forEach(note => {
                    const projected = this.project(note.position);
                    if (!projected) return;

                    ctx.fillStyle = 'rgba(232, 183, 120, 0.7)';
                    ctx.font = 'italic 11px Georgia';
                    ctx.textAlign = 'center';
                    ctx.fillText(note.text.substring(0, 20) + '...', projected.x, projected.y);
                });

                // Draw particles
                this.particles.forEach(p => {
                    const projected = this.project(p.position);
                    if (!projected) return;

                    ctx.fillStyle = p.color;
                    ctx.globalAlpha = p.life / 4;
                    ctx.beginPath();
                    ctx.arc(projected.x, projected.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                });

                // Draw lights
                this.lights.forEach((light, index) => {
                    const projected = this.project(light.position);
                    if (!projected) return;

                    const grad = ctx.createRadialGradient(projected.x, projected.y, 0, projected.x, projected.y, 100);
                    grad.addColorStop(0, light.color.toHexString());
                    grad.addColorStop(1, 'rgba(0,0,0,0)');

                    ctx.globalAlpha = light.intensity / 5;
                    ctx.fillStyle = grad;
                    ctx.fillRect(projected.x - 100, projected.y - 100, 200, 200);
                    ctx.globalAlpha = 1;

                    light.life -= 0.016;
                    if (light.life <= 0) {
                        this.lights.splice(index, 1);
                    }
                });

                // Draw merge effect
                if (this.mergeTarget && this.mergeProgress > 0) {
                    const targetProj = this.project(this.mergeTarget.position);
                    const playerProj = this.project(this.player.position);

                    if (targetProj && playerProj) {
                        ctx.strokeStyle = `rgba(232, 183, 120, ${this.mergeProgress})`;
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(playerProj.x, playerProj.y);
                        ctx.lineTo(targetProj.x, targetProj.y);
                        ctx.stroke();
                    }
                }

                // Draw crosshair
                ctx.strokeStyle = '#e8b778';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(w/2 - 10, h/2);
                ctx.lineTo(w/2 + 10, h/2);
                ctx.moveTo(w/2, h/2 - 10);
                ctx.lineTo(w/2, h/2 + 10);
                ctx.stroke();
            }

            project(pos) {
                // Simple 3D to 2D projection
                const cam = this.player.position;
                const pitch = this.player.rotation.pitch;
                const yaw = this.player.rotation.yaw;

                // Translate to camera space
                let x = pos.x - cam.x;
                let y = pos.y - cam.y;
                let z = pos.z - cam.z;

                // Rotate by yaw
                let rotX = x * Math.cos(yaw) - z * Math.sin(yaw);
                let rotZ = x * Math.sin(yaw) + z * Math.cos(yaw);

                // Rotate by pitch
                let rotY = y * Math.cos(pitch) - rotZ * Math.sin(pitch);
                rotZ = y * Math.sin(pitch) + rotZ * Math.cos(pitch);

                // Behind camera
                if (rotZ <= 0.1) return null;

                // Perspective projection
                const scale = 500 / rotZ;
                const screenX = this.canvas.width / 2 + rotX * scale;
                const screenY = this.canvas.height / 2 - rotY * scale;

                return { x: screenX, y: screenY };
            }

            randomBookSpineColor() {
                const colors = ['#8b4513', '#654321', '#d2691e', '#8b5a2b', '#a0522d', '#cd853f'];
                return colors[Math.floor(Math.random() * colors.length)];
            }

            hslToRgb(h, s, l) {
                let r, g, b;
                if (s === 0) {
                    r = g = b = l;
                } else {
                    const hue2rgb = (p, q, t) => {
                        if (t < 0) t += 1;
                        if (t > 1) t -= 1;
                        if (t < 1/6) return p + (q - p) * 6 * t;
                        if (t < 1/2) return q;
                        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                        return p;
                    };
                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;
                    r = hue2rgb(p, q, h + 1/3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1/3);
                }
                return `rgb(${Math.round(r * 255)}, ${Math.round(g * 255)}, ${Math.round(b * 255)})`;
            }

            updateStats() {
                const chunkKey = this.getCurrentChunkKey();
                const chunk = this.chunks.get(chunkKey);

                document.getElementById('player-pos').textContent =
                    `${Math.floor(this.player.position.x)}, ${Math.floor(this.player.position.y)}, ${Math.floor(this.player.position.z)}`;
                document.getElementById('current-section').textContent = chunk ? chunk.section : 'Unknown';
                document.getElementById('nearby-books').textContent = this.getNearbyBookCount();
                document.getElementById('spells-count').textContent = '1';
                document.getElementById('genres-count').textContent = this.player.genresCreated.length;
                document.getElementById('marginalia-count').textContent = this.player.marginalia.length;
            }

            getCurrentChunkKey() {
                const cx = Math.floor(this.player.position.x / this.chunkSize);
                const cy = Math.floor(this.player.position.y / this.chunkSize);
                const cz = Math.floor(this.player.position.z / this.chunkSize);
                return `${cx},${cy},${cz}`;
            }

            getNearbyBookCount() {
                return this.books.filter(book =>
                    this.player.position.distanceTo(book.position) < 50
                ).length;
            }

            updateGenreList() {
                const list = document.getElementById('genre-list');
                if (this.player.genresCreated.length === 0) {
                    list.innerHTML = '<div style="color: #c4a572; font-size: 0.8rem; font-style: italic;">Merge with other books to create new genres...</div>';
                    return;
                }

                list.innerHTML = this.player.genresCreated.map(genre => `
                    <div class="genre-item" style="border-color: ${genre.color.toHexString()}">
                        <strong>${genre.name}</strong><br>
                        <span style="font-size: 0.75rem; opacity: 0.8;">${genre.parentGenres.join(' + ')}</span>
                    </div>
                `).join('');
            }

            showNotification(message) {
                const notif = document.getElementById('notification');
                notif.textContent = message;
                notif.classList.add('visible');

                setTimeout(() => {
                    notif.classList.remove('visible');
                }, 3000);
            }

            exportData() {
                const data = {
                    version: '1.0',
                    timestamp: Date.now(),
                    player: {
                        position: { x: this.player.position.x, y: this.player.position.y, z: this.player.position.z },
                        title: this.player.title,
                        author: this.player.author,
                        genre: this.player.genre,
                        currentSpell: this.player.currentSpell,
                        genresCreated: this.player.genresCreated,
                        marginalia: this.player.marginalia
                    },
                    seed: this.seed
                };

                const json = JSON.stringify(data, null, 2);

                this.showModal('Export Library Data', `
                    <p style="margin-bottom: 15px; color: #c4a572;">Copy this JSON data to save your library:</p>
                    <textarea readonly style="width: 100%; min-height: 300px;">${this.escapeHtml(json)}</textarea>
                `);

                console.log('üì§ Exported library data');
            }

            showImportModal() {
                this.showModal('Import Library Data', `
                    <p style="margin-bottom: 15px; color: #c4a572;">Paste JSON library data below:</p>
                    <textarea id="import-data" style="width: 100%; min-height: 300px;" placeholder="Paste JSON here..."></textarea>
                `, () => {
                    const data = document.getElementById('import-data').value;
                    this.importData(data);
                });
            }

            importData(jsonData) {
                try {
                    const data = JSON.parse(jsonData);

                    if (data.player) {
                        this.player.position.set(data.player.position.x, data.player.position.y, data.player.position.z);
                        this.player.title = data.player.title || this.player.title;
                        this.player.author = data.player.author || this.player.author;
                        this.player.genre = data.player.genre || this.player.genre;
                        this.player.currentSpell = data.player.currentSpell || this.player.currentSpell;
                        this.player.genresCreated = data.player.genresCreated || [];
                        this.player.marginalia = data.player.marginalia || [];
                    }

                    if (data.seed) {
                        this.seed = data.seed;
                    }

                    this.updateGenreList();
                    this.updateStats();
                    this.hideModal();
                    this.showNotification('Library data imported successfully');
                    console.log('üì• Imported library data');

                } catch (error) {
                    console.error('Import failed:', error);
                    alert('Failed to import data. Please check the JSON format.');
                }
            }

            showModal(title, bodyHTML, actionCallback = null) {
                document.getElementById('modal-title').textContent = title;
                document.getElementById('modal-body').innerHTML = bodyHTML;
                document.getElementById('modal-overlay').classList.add('visible');

                const actionBtn = document.getElementById('modal-action');
                if (actionCallback) {
                    actionBtn.style.display = 'block';
                    actionBtn.textContent = 'Import';
                    actionBtn.onclick = actionCallback;
                } else {
                    actionBtn.style.display = 'none';
                }
            }

            hideModal() {
                document.getElementById('modal-overlay').classList.remove('visible');
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            saveState() {
                const state = {
                    player: {
                        position: { x: this.player.position.x, y: this.player.position.y, z: this.player.position.z },
                        title: this.player.title,
                        author: this.player.author,
                        genre: this.player.genre,
                        currentSpell: this.player.currentSpell,
                        genresCreated: this.player.genresCreated,
                        marginalia: this.player.marginalia
                    },
                    seed: this.seed
                };

                localStorage.setItem('infinite_library_state', JSON.stringify(state));
            }

            loadState() {
                const saved = localStorage.getItem('infinite_library_state');
                if (!saved) return;

                try {
                    const state = JSON.parse(saved);

                    if (state.player) {
                        this.player.title = state.player.title || this.player.title;
                        this.player.author = state.player.author || this.player.author;
                        this.player.genre = state.player.genre || this.player.genre;
                        this.player.currentSpell = state.player.currentSpell || this.player.currentSpell;
                        this.player.genresCreated = state.player.genresCreated || [];
                        this.player.marginalia = state.player.marginalia || [];

                        document.getElementById('spell-code').value = this.player.currentSpell;
                    }

                    if (state.seed) {
                        this.seed = state.seed;
                    }

                    this.updateGenreList();

                } catch (error) {
                    console.error('Failed to load state:', error);
                }
            }
        }

        // ===== APPLICATION START =====

        let library = null;

        window.addEventListener('load', () => {
            library = new InfiniteLibrary();
        });

        window.addEventListener('beforeunload', () => {
            if (library) {
                library.saveState();
            }
        });
    </script>
</body>
</html>
