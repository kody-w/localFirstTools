<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Recursive Self-Portrait</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Courier New', monospace;
            background: #0a0a0f;
            color: #e0e0e0;
            min-height: 100vh;
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        .simulation-viewport {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: linear-gradient(135deg, #0d0d15 0%, #1a1a2e 100%);
        }

        .recursion-layer {
            position: absolute;
            border: 2px solid rgba(100, 200, 255, 0.3);
            border-radius: 8px;
            background: rgba(10, 10, 20, 0.9);
            box-shadow:
                0 0 20px rgba(100, 200, 255, 0.1),
                inset 0 0 40px rgba(100, 200, 255, 0.05);
            transition: all 0.3s ease;
            overflow: hidden;
        }

        .recursion-layer::before {
            content: attr(data-depth);
            position: absolute;
            top: 5px;
            left: 10px;
            font-size: 10px;
            color: rgba(100, 200, 255, 0.6);
            z-index: 10;
        }

        .recursion-layer.diverged {
            border-color: rgba(255, 100, 100, 0.5);
            box-shadow:
                0 0 30px rgba(255, 100, 100, 0.2),
                inset 0 0 40px rgba(255, 100, 100, 0.05);
        }

        .recursion-layer.converged {
            border-color: rgba(100, 255, 150, 0.5);
            box-shadow:
                0 0 30px rgba(100, 255, 150, 0.2),
                inset 0 0 40px rgba(100, 255, 150, 0.05);
        }

        .ghost-cursor {
            position: absolute;
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 100;
            will-change: transform;
        }

        .ghost-cursor::before {
            content: '';
            position: absolute;
            width: 0;
            height: 0;
            border-left: 8px solid currentColor;
            border-top: 5px solid transparent;
            border-bottom: 5px solid transparent;
            transform: rotate(-45deg);
        }

        .ghost-cursor::after {
            content: '';
            position: absolute;
            top: 12px;
            left: 6px;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
            opacity: 0.5;
        }

        .ghost-click {
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid currentColor;
            animation: clickRipple 0.6s ease-out forwards;
            pointer-events: none;
        }

        @keyframes clickRipple {
            0% { transform: scale(0); opacity: 1; }
            100% { transform: scale(2); opacity: 0; }
        }

        .sidebar {
            width: 320px;
            background: rgba(15, 15, 25, 0.95);
            border-left: 1px solid rgba(100, 200, 255, 0.2);
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            overflow-y: auto;
        }

        h1 {
            font-size: 1.4em;
            background: linear-gradient(90deg, #64c8ff, #a080ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-align: center;
        }

        .subtitle {
            font-size: 0.75em;
            color: #888;
            text-align: center;
            font-style: italic;
        }

        .stats-panel {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(100, 200, 255, 0.1);
        }

        .stat-row:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }

        .stat-label {
            color: #888;
            font-size: 0.85em;
        }

        .stat-value {
            font-weight: bold;
            color: #64c8ff;
        }

        .stat-value.diverged { color: #ff6464; }
        .stat-value.converged { color: #64ff96; }

        .depth-slider {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
        }

        .depth-slider label {
            display: block;
            margin-bottom: 10px;
            color: #aaa;
            font-size: 0.9em;
        }

        .depth-slider input[type="range"] {
            width: 100%;
            height: 8px;
            -webkit-appearance: none;
            appearance: none;
            background: linear-gradient(90deg, #1a1a2e, #64c8ff);
            border-radius: 4px;
            outline: none;
        }

        .depth-slider input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: #64c8ff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(100, 200, 255, 0.5);
        }

        .behavior-log {
            flex: 1;
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
            overflow-y: auto;
            min-height: 200px;
        }

        .behavior-log h3 {
            color: #888;
            font-size: 0.85em;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .log-entry {
            font-size: 0.75em;
            padding: 5px 8px;
            margin-bottom: 5px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            border-left: 3px solid #64c8ff;
            color: #aaa;
        }

        .log-entry.prediction { border-left-color: #a080ff; }
        .log-entry.divergence { border-left-color: #ff6464; }
        .log-entry.match { border-left-color: #64ff96; }

        .controls {
            display: flex;
            gap: 10px;
        }

        button {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 6px;
            font-family: inherit;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #64c8ff, #a080ff);
            color: #0a0a0f;
            font-weight: bold;
        }

        .btn-secondary {
            background: rgba(100, 200, 255, 0.1);
            color: #64c8ff;
            border: 1px solid rgba(100, 200, 255, 0.3);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(100, 200, 255, 0.3);
        }

        .divergence-meter {
            height: 8px;
            background: rgba(30, 30, 50, 0.8);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 10px;
        }

        .divergence-fill {
            height: 100%;
            background: linear-gradient(90deg, #64ff96, #ffff64, #ff6464);
            transition: width 0.3s ease;
        }

        .philosophical-quote {
            text-align: center;
            font-style: italic;
            color: #666;
            font-size: 0.8em;
            padding: 15px;
            border-top: 1px solid rgba(100, 200, 255, 0.1);
        }

        .voice-panel {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
        }

        .voice-panel h3 {
            color: #888;
            font-size: 0.85em;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .voice-toggle-btn {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 6px;
            font-family: inherit;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.2s ease;
            background: rgba(160, 128, 255, 0.1);
            color: #a080ff;
            border: 1px solid rgba(160, 128, 255, 0.3);
            margin-bottom: 12px;
        }

        .voice-toggle-btn.active {
            background: linear-gradient(135deg, #a080ff, #64c8ff);
            color: #0a0a0f;
            font-weight: bold;
        }

        .voice-toggle-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(160, 128, 255, 0.3);
        }

        .voice-control {
            margin-bottom: 12px;
        }

        .voice-control label {
            display: block;
            margin-bottom: 5px;
            color: #aaa;
            font-size: 0.85em;
        }

        .voice-control input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: linear-gradient(90deg, #1a1a2e, #a080ff);
            border-radius: 3px;
            outline: none;
        }

        .voice-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #a080ff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 8px rgba(160, 128, 255, 0.5);
        }

        .voice-control input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #a080ff;
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 8px rgba(160, 128, 255, 0.5);
        }

        .voice-status {
            font-size: 0.75em;
            color: #666;
            padding: 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            text-align: center;
        }

        .voice-status.speaking {
            color: #a080ff;
            animation: pulse 1s infinite;
        }

        .transcript-panel {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
            margin-top: 10px;
            max-height: 150px;
            overflow-y: auto;
        }

        .transcript-panel h3 {
            color: #888;
            font-size: 0.85em;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .transcript-entry {
            font-size: 0.75em;
            padding: 5px 8px;
            margin-bottom: 5px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            border-left: 3px solid #a080ff;
            color: #aaa;
        }

        .transcript-entry.user {
            border-left-color: #64ff96;
        }

        .interaction-zone {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 200px;
            height: 200px;
            border: 2px dashed rgba(100, 200, 255, 0.3);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
            font-size: 0.9em;
            text-align: center;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .simulation-viewport:not(.recording) .interaction-zone {
            opacity: 1;
        }

        .recording-indicator {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 15px;
            background: rgba(255, 64, 64, 0.2);
            border: 1px solid rgba(255, 64, 64, 0.5);
            border-radius: 20px;
            color: #ff6464;
            font-size: 0.85em;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .recording-indicator.active {
            opacity: 1;
        }

        .recording-dot {
            width: 10px;
            height: 10px;
            background: #ff6464;
            border-radius: 50%;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        .depth-label {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 20px;
            border-radius: 20px;
            font-size: 0.9em;
            color: #64c8ff;
        }


        .zoom-level-indicator {
            position: absolute;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 25px;
            border-radius: 25px;
            font-size: 1em;
            color: #a080ff;
            border: 2px solid rgba(160, 128, 255, 0.4);
            box-shadow: 0 0 20px rgba(160, 128, 255, 0.3);
            font-weight: bold;
            z-index: 1000;
        }

        .zoom-level-indicator .zoom-icon {
            display: inline-block;
            margin-right: 8px;
            animation: zoomPulse 1.5s ease-in-out infinite;
        }

        @keyframes zoomPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }

        .extreme-depth-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 300;
            opacity: 0;
            transition: opacity 0.5s;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(255, 0, 255, 0.03) 2px,
                rgba(255, 0, 255, 0.03) 4px
            );
        }

        .extreme-depth-overlay.active {
            opacity: 1;
            animation: extremeGlitch 0.5s infinite;
        }

        @keyframes extremeGlitch {
            0%, 100% { transform: translate(0, 0); filter: hue-rotate(0deg); }
            25% { transform: translate(-3px, 2px); filter: hue-rotate(90deg); }
            50% { transform: translate(3px, -2px); filter: hue-rotate(180deg); }
            75% { transform: translate(-2px, -3px); filter: hue-rotate(270deg); }
        }

        .simulation-limit-warning {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 0, 100, 0.2);
            border: 3px solid rgba(255, 0, 100, 0.6);
            padding: 30px 40px;
            border-radius: 15px;
            font-size: 1.2em;
            color: #ff0064;
            text-align: center;
            font-weight: bold;
            z-index: 400;
            opacity: 0;
            pointer-events: none;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .simulation-limit-warning.active {
            opacity: 1;
            animation: warningFlash 1s ease-in-out infinite;
        }

        @keyframes warningFlash {
            0%, 100% { opacity: 0.8; box-shadow: 0 0 20px rgba(255, 0, 100, 0.5); }
            50% { opacity: 1; box-shadow: 0 0 40px rgba(255, 0, 100, 0.8); }
        }

        .zoom-controls {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
        }

        .zoom-controls h4 {
            color: #888;
            font-size: 0.85em;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .zoom-button-group {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }

        .zoom-btn {
            flex: 1;
            padding: 8px 12px;
            background: rgba(100, 200, 255, 0.1);
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 6px;
            color: #64c8ff;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.85em;
            transition: all 0.2s;
        }

        .zoom-btn:hover {
            background: rgba(100, 200, 255, 0.2);
            transform: translateY(-1px);
        }

        .zoom-btn.active {
            background: linear-gradient(135deg, #64c8ff, #a080ff);
            color: #0a0a0f;
            font-weight: bold;
        }

        .auto-zoom-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .auto-zoom-toggle:hover {
            background: rgba(100, 200, 255, 0.1);
        }

        .auto-zoom-toggle.active {
            background: rgba(160, 128, 255, 0.2);
            border: 1px solid rgba(160, 128, 255, 0.4);
        }

        .toggle-switch {
            position: relative;
            width: 40px;
            height: 20px;
            background: rgba(100, 100, 100, 0.5);
            border-radius: 10px;
            transition: background 0.3s;
            flex-shrink: 0;
        }

        .toggle-switch.active {
            background: linear-gradient(90deg, #64c8ff, #a080ff);
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 16px;
            height: 16px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s;
        }

        .toggle-switch.active::after {
            transform: translateX(20px);
        }

        .zoom-info {
            font-size: 0.75em;
            color: #888;
            margin-top: 8px;
            font-style: italic;
        }

        .data-controls {

        .zoom-level-indicator {
            position: absolute;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 25px;
            border-radius: 25px;
            font-size: 1em;
            color: #a080ff;
            border: 2px solid rgba(160, 128, 255, 0.4);
            box-shadow: 0 0 20px rgba(160, 128, 255, 0.3);
            font-weight: bold;
            z-index: 1000;
        }

        .zoom-level-indicator .zoom-icon {
            display: inline-block;
            margin-right: 8px;
            animation: zoomPulse 1.5s ease-in-out infinite;
        }

        @keyframes zoomPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }

        .extreme-depth-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 300;
            opacity: 0;
            transition: opacity 0.5s;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(255, 0, 255, 0.03) 2px,
                rgba(255, 0, 255, 0.03) 4px
            );
        }

        .extreme-depth-overlay.active {
            opacity: 1;
            animation: extremeGlitch 0.5s infinite;
        }

        @keyframes extremeGlitch {
            0%, 100% { transform: translate(0, 0); filter: hue-rotate(0deg); }
            25% { transform: translate(-3px, 2px); filter: hue-rotate(90deg); }
            50% { transform: translate(3px, -2px); filter: hue-rotate(180deg); }
            75% { transform: translate(-2px, -3px); filter: hue-rotate(270deg); }
        }

        .simulation-limit-warning {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 0, 100, 0.2);
            border: 3px solid rgba(255, 0, 100, 0.6);
            padding: 30px 40px;
            border-radius: 15px;
            font-size: 1.2em;
            color: #ff0064;
            text-align: center;
            font-weight: bold;
            z-index: 400;
            opacity: 0;
            pointer-events: none;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .simulation-limit-warning.active {
            opacity: 1;
            animation: warningFlash 1s ease-in-out infinite;
        }

        @keyframes warningFlash {
            0%, 100% { opacity: 0.8; box-shadow: 0 0 20px rgba(255, 0, 100, 0.5); }
            50% { opacity: 1; box-shadow: 0 0 40px rgba(255, 0, 100, 0.8); }
        }

        .zoom-controls {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
        }

        .zoom-controls h4 {
            color: #888;
            font-size: 0.85em;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .zoom-button-group {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }

        .zoom-btn {
            flex: 1;
            padding: 8px 12px;
            background: rgba(100, 200, 255, 0.1);
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 6px;
            color: #64c8ff;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.85em;
            transition: all 0.2s;
        }

        .zoom-btn:hover {
            background: rgba(100, 200, 255, 0.2);
            transform: translateY(-1px);
        }

        .zoom-btn.active {
            background: linear-gradient(135deg, #64c8ff, #a080ff);
            color: #0a0a0f;
            font-weight: bold;
        }

        .auto-zoom-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .auto-zoom-toggle:hover {
            background: rgba(100, 200, 255, 0.1);
        }

        .auto-zoom-toggle.active {
            background: rgba(160, 128, 255, 0.2);
            border: 1px solid rgba(160, 128, 255, 0.4);
        }

        .toggle-switch {
            position: relative;
            width: 40px;
            height: 20px;
            background: rgba(100, 100, 100, 0.5);
            border-radius: 10px;
            transition: background 0.3s;
            flex-shrink: 0;
        }

        .toggle-switch.active {
            background: linear-gradient(90deg, #64c8ff, #a080ff);
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 16px;
            height: 16px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s;
        }

        .toggle-switch.active::after {
            transform: translateX(20px);
        }

        .zoom-info {
            font-size: 0.75em;
            color: #888;
            margin-top: 8px;
            font-style: italic;
        }
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
            display: flex;
            gap: 10px;
        }

        .data-controls button {
            padding: 8px 16px;
            font-size: 0.8em;
            background: rgba(100, 200, 255, 0.1);
            border: 1px solid rgba(100, 200, 255, 0.3);
            color: #64c8ff;
        }

        .mini-element {
            position: absolute;
            background: rgba(100, 200, 255, 0.3);
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .mini-element:hover {
            background: rgba(100, 200, 255, 0.5);
        }

        .thought-bubble {
            position: absolute;
            background: rgba(160, 128, 255, 0.2);
            border: 1px solid rgba(160, 128, 255, 0.4);
            border-radius: 12px;
            padding: 8px 12px;
            font-size: 0.7em;
            color: #a080ff;
            pointer-events: none;
            animation: floatUp 3s ease-out forwards;
            white-space: nowrap;
        }

        @keyframes floatUp {
            0% { opacity: 0; transform: translateY(10px); }
            20% { opacity: 1; }
            80% { opacity: 1; }
            100% { opacity: 0; transform: translateY(-30px); }
        }

        .infinity-symbol {
            position: absolute;
            font-size: 100px;
            color: rgba(100, 200, 255, 0.05);
            pointer-events: none;
            animation: rotate 20s linear infinite;
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* Prediction trails */
        .prediction-trail {
            position: absolute;
            pointer-events: none;
            z-index: 50;
        }

        .prediction-trail path {
            fill: none;
            stroke-width: 2;
            opacity: 0.4;
            stroke-dasharray: 5, 5;
            animation: dashMove 1s linear infinite;
        }

        @keyframes dashMove {
            to { stroke-dashoffset: -10; }
        }

        /* Heat map */
        .heat-map {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
            opacity: 0.4;
        }

        .heat-point {
            position: absolute;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255, 100, 100, 0.6), transparent);
            will-change: transform, opacity;
            animation: heatFade 3s ease-out forwards;
        }

        @keyframes heatFade {
            from { opacity: 1; }
            to { opacity: 0; }
        }

        /* Glitch effects */
        .glitch-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 200;
            opacity: 0;
            transition: opacity 0.1s;
        }

        .glitch-overlay.active {
            opacity: 1;
        }

        .scanline {
            position: absolute;
            left: 0;
            width: 100%;
            height: 2px;
            background: rgba(100, 200, 255, 0.3);
            animation: scan 4s linear infinite;
        }

        @keyframes scan {
            from { top: 0%; }
            to { top: 100%; }
        }

        .recursion-layer.glitching {
            animation: glitchShake 0.2s infinite;
        }

        @keyframes glitchShake {
            0%, 100% { transform: translate(0, 0); }
            25% { transform: translate(-2px, 2px); }
            50% { transform: translate(2px, -2px); }
            75% { transform: translate(-2px, -2px); }
        }

        .chromatic-aberration {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            mix-blend-mode: screen;
            opacity: 0;
        }

        .chromatic-aberration.active {
            opacity: 0.3;
            animation: chromaticGlitch 0.3s infinite;
        }

        @keyframes chromaticGlitch {
            0% { transform: translate(0, 0); }
            33% { transform: translate(2px, 0); filter: hue-rotate(90deg); }
            66% { transform: translate(-2px, 0); filter: hue-rotate(180deg); }
            100% { transform: translate(0, 0); }
        }

        /* Behavioral fingerprint */
        .fingerprint-panel {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
            min-height: 150px;
        }

        .fingerprint-panel h3 {
            color: #888;
            font-size: 0.85em;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #fingerprintCanvas {
            width: 100%;
            height: 120px;
            border-radius: 4px;
            background: rgba(0, 0, 0, 0.3);
        }

        /* Meta-commentary */
        .meta-comment {
            position: absolute;
            background: rgba(255, 100, 100, 0.15);
            border: 1px solid rgba(255, 100, 100, 0.4);
            border-radius: 8px;
            padding: 12px 16px;
            font-size: 0.75em;
            color: #ff6464;
            pointer-events: none;
            animation: metaDrift 8s ease-out forwards;
            max-width: 300px;
            text-align: center;
            font-style: italic;
            z-index: 150;
        }

        @keyframes metaDrift {
            0% { opacity: 0; transform: translateY(0) scale(0.9); }
            10% { opacity: 1; transform: translateY(-10px) scale(1); }
            90% { opacity: 1; transform: translateY(-40px) scale(1); }
            100% { opacity: 0; transform: translateY(-60px) scale(0.95); }
        }

        /* Infinity mirror effect */
        .infinity-mirror {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
            opacity: 0;
            transition: opacity 0.5s;
        }

        .infinity-mirror.active {
            opacity: 1;
        }

        .infinity-ring {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 1px solid rgba(100, 200, 255, 0.2);
            border-radius: 50%;
            animation: expandRing 3s ease-out infinite;
        }

        @keyframes expandRing {
            0% { width: 50px; height: 50px; opacity: 0.8; }
            100% { width: 400px; height: 400px; opacity: 0; }
        }

        /* Webcam integration */
        .webcam-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 120px;
            height: 90px;
            border: 2px solid rgba(100, 200, 255, 0.3);
            border-radius: 8px;
            overflow: hidden;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 100;
        }

        .webcam-container.active {
            opacity: 1;
        }

        #webcamVideo {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }

        .webcam-distortion {
            filter: hue-rotate(0deg) blur(0px);
            transition: filter 0.3s;
        }

        /* Emotion detection overlay */
        .emotion-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(to top, rgba(0, 0, 0, 0.8), transparent);
            padding: 4px 8px;
            font-size: 10px;
            color: #64c8ff;
            text-align: center;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }

        .webcam-container.active .emotion-overlay {
            opacity: 1;
        }

        .emotion-overlay .emotion-icon {
            font-size: 14px;
            margin-right: 4px;
        }

        .emotion-overlay .confidence {
            font-size: 8px;
            color: rgba(100, 200, 255, 0.6);
            margin-left: 4px;
        }

        /* Hidden canvas for emotion analysis */
        #emotionCanvas {
            display: none;
        }

        /* Mobile responsive */
        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }

            .sidebar {
                width: 100%;
                max-height: 40vh;
                border-left: none;
                border-top: 1px solid rgba(100, 200, 255, 0.2);
                order: 2;
            }

            .simulation-viewport {
                order: 1;
                height: 60vh;
            }

            .depth-label {
                bottom: 10px;
                font-size: 0.75em;
            }

            .recording-indicator {
                top: 10px;
                left: 10px;
                font-size: 0.7em;
                padding: 6px 10px;
            }

            .meta-comment {
                max-width: 200px;
                font-size: 0.65em;
            }

            .webcam-container {
                width: 80px;
                height: 60px;
                bottom: 10px;
                right: 10px;
            }

            button {
                padding: 10px;
                font-size: 0.85em;
            }
        }

        /* Sound indicator */
        .sound-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            background: rgba(100, 200, 255, 0.1);
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            z-index: 1000;
        }

        .sound-indicator:hover {
            background: rgba(100, 200, 255, 0.2);
        }

        .sound-indicator.muted {
            opacity: 0.4;
        }

        .sound-wave {
            width: 20px;
            height: 20px;
            display: flex;
            gap: 3px;
            align-items: center;
            justify-content: center;
        }

        .sound-bar {
            width: 3px;
            background: #64c8ff;
            border-radius: 2px;
            animation: soundPulse 0.8s ease-in-out infinite;
        }

        .sound-bar:nth-child(1) { height: 8px; animation-delay: 0s; }
        .sound-bar:nth-child(2) { height: 14px; animation-delay: 0.2s; }
        .sound-bar:nth-child(3) { height: 10px; animation-delay: 0.4s; }

        @keyframes soundPulse {
            0%, 100% { transform: scaleY(1); }
            50% { transform: scaleY(1.5); }
        }

        .sound-indicator.muted .sound-bar {
            animation: none;
            height: 2px !important;
        }

        /* ===== SYNAESTHESIA MODE STYLES ===== */
        .synaesthesia-panel {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
        }

        .synaesthesia-panel h3 {
            color: #888;
            font-size: 0.85em;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .synaesthesia-toggle-btn {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 6px;
            font-family: inherit;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.2s ease;
            background: rgba(255, 100, 200, 0.1);
            color: #ff64c8;
            border: 1px solid rgba(255, 100, 200, 0.3);
            margin-bottom: 12px;
        }

        .synaesthesia-toggle-btn.active {
            background: linear-gradient(135deg, #ff64c8, #c864ff);
            color: #0a0a0f;
            font-weight: bold;
        }

        .synaesthesia-toggle-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(255, 100, 200, 0.3);
        }

        .synaesthesia-description {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 100, 200, 0.95);
            border: 2px solid rgba(255, 100, 200, 0.8);
            border-radius: 12px;
            padding: 15px 25px;
            font-size: 1.1em;
            color: #0a0a0f;
            text-align: center;
            font-weight: bold;
            z-index: 500;
            opacity: 0;
            pointer-events: none;
            max-width: 500px;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            animation: synaesthesiaDrift 4s ease-out forwards;
        }

        @keyframes synaesthesiaDrift {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
        }

        .speed-color-indicator {
            position: absolute;
            top: 80px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 0.85em;
            color: #fff;
            border: 2px solid rgba(255, 100, 200, 0.4);
            z-index: 1000;
            opacity: 0;
            transition: all 0.3s;
        }

        .speed-color-indicator.active {
            opacity: 1;
        }

        .speed-color-indicator .color-swatch {
            display: inline-block;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-left: 8px;
            vertical-align: middle;
            border: 2px solid rgba(255, 255, 255, 0.5);
        }

        .taste-indicator {
            position: absolute;
            top: 130px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 0.85em;
            color: #fff;
            border: 2px solid rgba(255, 200, 100, 0.4);
            z-index: 1000;
            opacity: 0;
            transition: all 0.3s;
        }

        .taste-indicator.active {
            opacity: 1;
        }

        .temperature-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.5s;
            mix-blend-mode: overlay;
        }

        .temperature-overlay.active {
            opacity: 0.3;
        }

        .waveform-visualizer {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 300px;
            height: 80px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid rgba(100, 200, 255, 0.4);
            border-radius: 8px;
            z-index: 1000;
            opacity: 0;
            transition: all 0.3s;
        }

        .waveform-visualizer.active {
            opacity: 1;
        }

        #waveformCanvas {
            width: 100%;
            height: 100%;
        }

        .layer-flavor-badge {
            position: absolute;
            top: 30px;
            right: 10px;
            font-size: 10px;
            background: rgba(255, 100, 200, 0.3);
            padding: 4px 8px;
            border-radius: 10px;
            color: #ff64c8;
            pointer-events: none;
            z-index: 15;
        }

        .click-burst {
            position: absolute;
            pointer-events: none;
            border-radius: 50%;
            animation: burstExpand 0.8s ease-out forwards;
            z-index: 500;
        }

        @keyframes burstExpand {
            0% { transform: scale(0); opacity: 1; }
            100% { transform: scale(5); opacity: 0; }
        }

        .chord-visualizer {
            position: absolute;
            bottom: 110px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 15px;
            border-radius: 12px;
            font-size: 0.8em;
            color: #a080ff;
            border: 2px solid rgba(160, 128, 255, 0.4);
            z-index: 1000;
            opacity: 0;
            transition: all 0.3s;
            max-width: 250px;
        }

        .chord-visualizer.active {
            opacity: 1;
        }

        .chord-notes {
            display: flex;
            gap: 5px;
            margin-top: 5px;
        }

        .chord-note {
            padding: 3px 8px;
            background: rgba(160, 128, 255, 0.2);
            border-radius: 4px;
            font-size: 0.75em;
        }

        /* Keyboard focus indicators */
        button:focus,
        input[type="range"]:focus,
        .sound-indicator:focus {
            outline: 2px solid #64c8ff;
            outline-offset: 3px;
        }

        button:focus-visible,
        input[type="range"]:focus-visible,
        .sound-indicator:focus-visible {
            outline: 2px solid #64c8ff;
            outline-offset: 3px;
            box-shadow: 0 0 15px rgba(100, 200, 255, 0.5);
        }

        /* Keyboard shortcuts help overlay */
        .shortcuts-overlay {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10, 10, 20, 0.98);
            border: 2px solid rgba(100, 200, 255, 0.5);
            border-radius: 12px;
            padding: 30px;
            z-index: 2000;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 10px 50px rgba(0, 0, 0, 0.8);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .shortcuts-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }

        .shortcuts-overlay h2 {
            color: #64c8ff;
            font-size: 1.3em;
            margin-bottom: 20px;
            text-align: center;
            background: linear-gradient(90deg, #64c8ff, #a080ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .shortcuts-grid {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 12px 20px;
            margin-bottom: 20px;
        }

        .shortcut-key {
            background: rgba(100, 200, 255, 0.1);
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 4px;
            padding: 4px 10px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            color: #64c8ff;
            text-align: center;
            min-width: 60px;
        }

        .shortcut-desc {
            color: #aaa;
            display: flex;
            align-items: center;
        }

        .shortcuts-close {
            display: block;
            margin: 20px auto 0;
            padding: 10px 30px;
            background: linear-gradient(135deg, #64c8ff, #a080ff);
            border: none;
            border-radius: 6px;
            color: #0a0a0f;
            font-weight: bold;
            cursor: pointer;
        }

        .shortcuts-hint {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(100, 200, 255, 0.1);
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 20px;
            padding: 8px 16px;
            font-size: 0.8em;
            color: #64c8ff;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
        }

        .shortcuts-hint.visible {
            animation: fadeInOut 4s ease-in-out;
        }

        @keyframes fadeInOut {
            0%, 100% { opacity: 0; }
            10%, 90% { opacity: 1; }
        }

        /* Fullscreen mode */
        .simulation-viewport.fullscreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw !important;
            height: 100vh !important;
            z-index: 9999;
        }

        .simulation-viewport.fullscreen ~ .sidebar {
            display: none;
        }

        /* Neural network visualization */
        .neural-panel {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
            min-height: 180px;
        }

        .neural-panel h3 {
            color: #888;
            font-size: 0.85em;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #neuralCanvas {
            width: 100%;
            height: 150px;
            border-radius: 4px;
            background: rgba(0, 0, 0, 0.3);
        }

        .stat-value.neural { color: #a080ff; }

        /* ===== REPLAY SYSTEM STYLES ===== */
        .replay-panel {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
        }

        .replay-panel h3 {
            color: #888;
            font-size: 0.85em;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .replay-timeline {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(15, 15, 25, 0.98);
            border-top: 1px solid rgba(100, 200, 255, 0.3);
            padding: 15px 20px 20px;
            z-index: 2000;
            opacity: 0;
            transform: translateY(100%);
            transition: all 0.3s ease;
        }

        .replay-timeline.active {
            opacity: 1;
            transform: translateY(0);
        }

        .timeline-scrubber {
            position: relative;
            height: 40px;
            background: rgba(30, 30, 50, 0.8);
            border-radius: 6px;
            margin-bottom: 15px;
            cursor: pointer;
            overflow: hidden;
        }

        .timeline-progress {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            background: linear-gradient(90deg, #64c8ff, #a080ff);
            pointer-events: none;
            transition: width 0.05s linear;
        }

        .timeline-events {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .timeline-event {
            position: absolute;
            top: 0;
            width: 3px;
            height: 100%;
            background: rgba(255, 100, 100, 0.6);
        }

        .timeline-event.click {
            background: rgba(255, 200, 100, 0.8);
            width: 4px;
        }

        .timeline-playhead {
            position: absolute;
            top: -5px;
            width: 3px;
            height: calc(100% + 10px);
            background: #fff;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
            pointer-events: none;
        }

        .timeline-playhead::before {
            content: '';
            position: absolute;
            top: -8px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-top: 8px solid #fff;
        }

        .replay-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .replay-button {
            padding: 8px 16px;
            background: rgba(100, 200, 255, 0.1);
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 6px;
            color: #64c8ff;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.85em;
            transition: all 0.2s;
        }

        .replay-button:hover:not(:disabled) {
            background: rgba(100, 200, 255, 0.2);
        }

        .replay-button.active {
            background: linear-gradient(135deg, #64c8ff, #a080ff);
            color: #0a0a0f;
        }

        .replay-button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .speed-button {
            padding: 6px 12px;
            background: rgba(100, 200, 255, 0.1);
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 4px;
            color: #64c8ff;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.75em;
        }

        .speed-button.active {
            background: rgba(100, 200, 255, 0.3);
            color: #fff;
        }

        .time-display {
            color: #888;
            font-size: 0.85em;
            font-family: 'Courier New', monospace;
            margin-left: auto;
        }

        .replay-ghost-cursor {
            position: absolute;
            width: 24px;
            height: 24px;
            pointer-events: none;
            z-index: 1500;
            opacity: 0;
        }

        .replay-ghost-cursor.active {
            opacity: 1;
        }

        .replay-ghost-cursor::before {
            content: '';
            position: absolute;
            width: 0;
            height: 0;
            border-left: 10px solid #ff6464;
            border-top: 6px solid transparent;
            border-bottom: 6px solid transparent;
            transform: rotate(-45deg);
            filter: drop-shadow(0 0 6px rgba(255, 100, 100, 0.8));
        }

        .replay-ghost-cursor::after {
            content: 'REPLAY';
            position: absolute;
            top: -20px;
            left: 15px;
            font-size: 8px;
            color: #ff6464;
            font-weight: bold;
        }

        .comparison-cursor {
            position: absolute;
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 1001;
            opacity: 0;
        }

        .comparison-cursor.active {
            opacity: 0.7;
        }

        .comparison-cursor::before {
            content: '';
            position: absolute;
            width: 0;
            height: 0;
            border-left: 8px solid #64ff96;
            border-top: 5px solid transparent;
            border-bottom: 5px solid transparent;
            transform: rotate(-45deg);
            filter: drop-shadow(0 0 4px rgba(100, 255, 150, 0.6));
        }

        .comparison-cursor::after {
            content: 'LIVE';
            position: absolute;
            top: -18px;
            left: 12px;
            font-size: 8px;
            color: #64ff96;
            font-weight: bold;
        }

        .replay-mode-badge {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 100, 100, 0.2);
            border: 1px solid rgba(255, 100, 100, 0.5);
            padding: 8px 20px;
            border-radius: 20px;
            color: #ff6464;
            font-size: 0.85em;
            font-weight: bold;
            z-index: 1500;
            opacity: 0;
            text-transform: uppercase;
        }

        .replay-mode-badge.active {
            opacity: 1;
        }

        .replay-list {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
        }

        .replay-item {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            margin-bottom: 8px;
            border-radius: 6px;
            border-left: 3px solid #64c8ff;
            cursor: pointer;
            transition: all 0.2s;
        }

        .replay-item:hover {
            background: rgba(100, 200, 255, 0.1);
            transform: translateX(5px);
        }

        .replay-item.active {
            border-left-color: #a080ff;
            background: rgba(160, 128, 255, 0.15);
        }

        .replay-item-title {
            font-size: 0.85em;
            color: #e0e0e0;
            margin-bottom: 4px;
        }

        .replay-item-stats {
            font-size: 0.7em;
            color: #888;
        }

        .tab-container {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .tab-button {
            flex: 1;
            padding: 10px;
            background: rgba(30, 30, 50, 0.5);
            border: 1px solid rgba(100, 200, 255, 0.2);
            border-radius: 6px;
            color: #888;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.85em;
            transition: all 0.2s;
        }

        .tab-button.active {
            background: rgba(100, 200, 255, 0.2);
            border-color: rgba(100, 200, 255, 0.5);
            color: #64c8ff;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* ===== MULTIPLAYER STYLES ===== */
        .multiplayer-panel {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
        }

        .multiplayer-panel h3 {
            color: #888;
            font-size: 0.85em;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .room-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .room-controls input {
            flex: 1;
            padding: 8px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 4px;
            color: #e0e0e0;
            font-family: inherit;
            font-size: 0.85em;
        }

        .room-controls input::placeholder {
            color: #666;
        }

        .room-controls button {
            padding: 8px 12px !important;
            font-size: 0.85em !important;
        }

        .room-code-display {
            background: rgba(100, 200, 255, 0.1);
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 4px;
            padding: 10px;
            text-align: center;
            font-family: 'Courier New', monospace;
            font-size: 1.1em;
            color: #64c8ff;
            letter-spacing: 2px;
            margin-bottom: 10px;
            cursor: pointer;
        }

        .room-code-display:hover {
            background: rgba(100, 200, 255, 0.15);
        }

        .connection-status {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            font-size: 0.8em;
            margin-bottom: 10px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #666;
        }

        .status-dot.connected {
            background: #64ff96;
            animation: pulse 2s infinite;
        }

        .status-dot.connecting {
            background: #ffff64;
            animation: pulse 1s infinite;
        }

        .peer-cursor {
            position: absolute;
            pointer-events: none;
            z-index: 500;
            transition: all 0.05s linear;
            will-change: transform;
        }

        .peer-cursor::before {
            content: '';
            position: absolute;
            width: 0;
            height: 0;
            border-left: 10px solid #ff6496;
            border-top: 6px solid transparent;
            border-bottom: 6px solid transparent;
            transform: rotate(-45deg);
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.5));
        }

        .peer-cursor::after {
            content: attr(data-peer-name);
            position: absolute;
            top: 16px;
            left: 12px;
            background: rgba(255, 100, 150, 0.9);
            color: white;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.7em;
            white-space: nowrap;
            pointer-events: none;
        }

        .peer-layers-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 30;
        }

        .peer-recursion-layer {
            position: absolute;
            border: 2px solid rgba(255, 100, 150, 0.3);
            border-radius: 8px;
            background: rgba(30, 10, 20, 0.7);
            box-shadow:
                0 0 20px rgba(255, 100, 150, 0.1),
                inset 0 0 40px rgba(255, 100, 150, 0.05);
            transition: all 0.3s ease;
        }

        .peer-recursion-layer::before {
            content: attr(data-depth);
            position: absolute;
            top: 5px;
            right: 10px;
            font-size: 10px;
            color: rgba(255, 100, 150, 0.6);
            z-index: 10;
        }

        .peer-ghost-cursor {
            color: #ff6496;
        }

        .comparative-stats {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 10px;
            align-items: center;
            margin-bottom: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }

        .comparative-stats .my-stat {
            text-align: right;
            color: #64c8ff;
            font-size: 0.85em;
        }

        .comparative-stats .vs {
            color: #888;
            font-weight: bold;
            font-size: 0.7em;
        }

        .comparative-stats .peer-stat {
            text-align: left;
            color: #ff6496;
            font-size: 0.85em;
        }

        .predict-mode-panel {
            background: rgba(160, 128, 255, 0.1);
            border: 1px solid rgba(160, 128, 255, 0.3);
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 10px;
            transition: all 0.2s;
            text-align: center;
        }

        .predict-mode-panel.active {
            background: rgba(160, 128, 255, 0.2);
            border-color: rgba(160, 128, 255, 0.5);
        }

        .predict-score {
            font-size: 1.3em;
            color: #a080ff;
            margin-top: 5px;
            font-weight: bold;
        }

        .fingerprint-comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }

        .fingerprint-mini {
            text-align: center;
        }

        .fingerprint-mini canvas {
            width: 100%;
            height: 80px;
            border-radius: 4px;
            background: rgba(0, 0, 0, 0.3);
        }

        .fingerprint-mini .label {
            font-size: 0.7em;
            color: #888;
            margin-top: 5px;
        }

        .meta-comment.dual {
            background: rgba(160, 128, 255, 0.15);
            border-color: rgba(160, 128, 255, 0.4);
            color: #a080ff;
        }

        /* 3D Mode Styles */
        .mode-3d-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 5;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
            background: radial-gradient(circle at center, rgba(10, 10, 15, 0.95), rgba(5, 5, 10, 1));
        }

        .mode-3d-canvas.active {
            opacity: 1;
            pointer-events: auto;
        }

        .mode-3d-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 15px;
            background: rgba(100, 200, 255, 0.1);
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 10px 0;
        }

        .mode-3d-toggle:hover {
            background: rgba(100, 200, 255, 0.2);
            border-color: rgba(100, 200, 255, 0.5);
        }

        .mode-3d-toggle.active {
            background: rgba(100, 200, 255, 0.3);
            border-color: rgba(100, 200, 255, 0.7);
        }

        .mode-3d-toggle input[type="checkbox"] {
            margin: 0;
            cursor: pointer;
        }

        .mode-3d-toggle label {
            margin: 0;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            color: #64c8ff;
            font-size: 0.95em;
        }

        .mode-3d-icon {
            font-size: 1.2em;
        }

        .mode-3d-controls {
            display: none;
            padding: 10px;
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            margin-top: 10px;
        }

        .mode-3d-controls.active {
            display: block;
        }

        .mode-3d-controls .depth-slider {
            margin-bottom: 10px;
        }

        .mode-3d-info {
            position: absolute;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 12px 24px;
            border-radius: 24px;
            font-size: 0.85em;
            color: #64c8ff;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            z-index: 10;
            text-align: center;
        }

        .mode-3d-info.active {
            opacity: 1;
        }

        /* Memory Palace Styles */
        .memory-palace-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 6;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
            background: radial-gradient(circle at center, rgba(15, 10, 25, 0.98), rgba(5, 5, 15, 1));
        }

        .memory-palace-canvas.active {
            opacity: 1;
            pointer-events: auto;
        }

        .memory-palace-info {
            position: absolute;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 12px 24px;
            border-radius: 24px;
            font-size: 0.85em;
            color: #b896ff;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            z-index: 15;
            text-align: center;
            border: 1px solid rgba(184, 150, 255, 0.3);
        }

        .memory-palace-info.active {
            opacity: 1;
        }

        .memory-palace-map {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.85);
            border: 2px solid rgba(184, 150, 255, 0.4);
            border-radius: 12px;
            padding: 15px;
            min-width: 200px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            z-index: 15;
        }

        .memory-palace-map.active {
            opacity: 1;
            pointer-events: auto;
        }

        .map-title {
            color: #b896ff;
            font-size: 0.9em;
            font-weight: bold;
            margin-bottom: 10px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .map-grid {
            display: grid;
            grid-template-columns: repeat(3, 40px);
            grid-gap: 8px;
            margin-bottom: 10px;
            justify-content: center;
        }

        .map-room {
            width: 40px;
            height: 40px;
            border: 1px solid rgba(184, 150, 255, 0.3);
            border-radius: 4px;
            background: rgba(20, 15, 30, 0.5);
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7em;
            color: rgba(184, 150, 255, 0.5);
        }

        .map-room:hover {
            background: rgba(184, 150, 255, 0.2);
            border-color: rgba(184, 150, 255, 0.6);
        }

        .map-room.current {
            background: rgba(184, 150, 255, 0.4);
            border: 2px solid #b896ff;
            box-shadow: 0 0 15px rgba(184, 150, 255, 0.6);
        }

        .map-room.visited {
            background: rgba(100, 200, 255, 0.2);
            border-color: rgba(100, 200, 255, 0.4);
        }

        .map-legend {
            display: flex;
            gap: 15px;
            font-size: 0.75em;
            color: #888;
            justify-content: center;
        }

        .map-legend span {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .current-room {
            color: #b896ff;
        }

        .visited-room {
            color: #64c8ff;
        }

        .memory-palace-center-mirror {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
            z-index: 14;
        }

        .memory-palace-center-mirror.active {
            opacity: 1;
            pointer-events: auto;
        }

        .mirror-frame {
            width: 300px;
            height: 400px;
            background: linear-gradient(135deg, rgba(184, 150, 255, 0.1), rgba(100, 200, 255, 0.1));
            border: 3px solid rgba(184, 150, 255, 0.6);
            border-radius: 20px;
            box-shadow: 0 0 30px rgba(184, 150, 255, 0.3), inset 0 0 50px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            backdrop-filter: blur(10px);
        }

        .mirror-text {
            color: #b896ff;
            font-size: 0.9em;
            text-align: center;
            margin-bottom: 20px;
            font-style: italic;
            text-shadow: 0 0 10px rgba(184, 150, 255, 0.5);
        }

        .mirror-reflection {
            width: 100%;
            height: 100%;
            border-radius: 10px;
            background: radial-gradient(circle at center, rgba(184, 150, 255, 0.2), transparent);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3em;
            color: rgba(184, 150, 255, 0.6);
            animation: mirror-pulse 3s ease-in-out infinite;
        }

        @keyframes mirror-pulse {
            0%, 100% {
                box-shadow: inset 0 0 30px rgba(184, 150, 255, 0.3);
                transform: scale(1);
            }
            50% {
                box-shadow: inset 0 0 50px rgba(184, 150, 255, 0.5);
                transform: scale(1.02);
            }
        }

        .memory-artifact {
            position: absolute;
            width: 50px;
            height: 50px;
            background: radial-gradient(circle, rgba(255, 200, 100, 0.4), rgba(255, 150, 100, 0.2));
            border: 2px solid rgba(255, 200, 100, 0.6);
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            z-index: 12;
            animation: artifact-float 3s ease-in-out infinite;
        }

        .memory-artifact:hover {
            transform: scale(1.2);
            box-shadow: 0 0 30px rgba(255, 200, 100, 0.8);
        }

        @keyframes artifact-float {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            50% { transform: translateY(-10px) rotate(5deg); }
        }

        .artifact-tooltip {
            position: absolute;
            bottom: -40px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            color: #ffbf64;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 0.75em;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
            border: 1px solid rgba(255, 200, 100, 0.4);
        }

        .memory-artifact:hover .artifact-tooltip {
            opacity: 1;
        }

        .room-atmosphere {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 11;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .room-atmosphere.active {
            opacity: 1;
        }

        .echo-path {
            position: absolute;
            width: 3px;
            height: 3px;
            border-radius: 50%;
            background: rgba(184, 150, 255, 0.4);
            pointer-events: none;
            z-index: 11;
            box-shadow: 0 0 10px rgba(184, 150, 255, 0.6);
        }

        /* Evolution Timeline */
        .evolution-panel {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
            margin-top: 10px;
        }

        .evolution-panel h3 {
            color: #888;
            font-size: 0.85em;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .welcome-message {
            background: linear-gradient(135deg, rgba(100, 200, 255, 0.2), rgba(160, 128, 255, 0.2));
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            animation: fadeIn 1s ease-out;
        }

        .welcome-message .title {
            font-size: 1.1em;
            color: #64c8ff;
            margin-bottom: 8px;
            font-weight: bold;
        }

        .welcome-message .subtitle {
            font-size: 0.85em;
            color: #aaa;
            line-height: 1.4;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .evolution-timeline {
            position: relative;
            height: 60px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            margin: 10px 0;
            overflow: hidden;
        }

        .timeline-session {
            position: absolute;
            top: 0;
            height: 100%;
            background: linear-gradient(135deg, rgba(100, 200, 255, 0.4), rgba(160, 128, 255, 0.4));
            border-right: 1px solid rgba(255, 255, 255, 0.2);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .timeline-session:hover {
            background: linear-gradient(135deg, rgba(100, 200, 255, 0.6), rgba(160, 128, 255, 0.6));
            z-index: 10;
        }

        .timeline-session.selected {
            background: linear-gradient(135deg, rgba(255, 200, 100, 0.6), rgba(255, 150, 100, 0.6));
            border: 2px solid #ffbf64;
        }

        .timeline-label {
            font-size: 0.65em;
            color: white;
            padding: 2px 4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .consistency-meter {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
        }

        .consistency-bar {
            flex: 1;
            height: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }

        .consistency-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff6464, #ffff64, #64ff96);
            transition: width 0.5s ease;
            border-radius: 10px;
        }

        .consistency-label {
            font-size: 0.75em;
            color: #888;
            min-width: 80px;
        }

        .entropy-graph {
            height: 80px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            position: relative;
            margin: 10px 0;
        }

        .entropy-line {
            stroke: #64c8ff;
            stroke-width: 2;
            fill: none;
        }

        .entropy-area {
            fill: rgba(100, 200, 255, 0.2);
        }

        .ghost-overlay-cursor {
            position: absolute;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: rgba(255, 200, 100, 0.4);
            border: 2px solid rgba(255, 200, 100, 0.8);
            pointer-events: none;
            z-index: 90;
            transition: all 0.05s linear;
        }

        .ghost-overlay-cursor::after {
            content: 'PAST YOU';
            position: absolute;
            top: -25px;
            left: -15px;
            font-size: 0.6em;
            color: rgba(255, 200, 100, 0.9);
            white-space: nowrap;
            text-shadow: 0 0 4px rgba(0, 0, 0, 0.8);
        }

        .comparison-split {
            display: flex;
            gap: 10px;
            margin: 10px 0;
        }

        .comparison-pane {
            flex: 1;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            padding: 10px;
        }

        .comparison-pane .label {
            font-size: 0.7em;
            color: #888;
            margin-bottom: 5px;
            text-transform: uppercase;
        }

        .comparison-pane .fingerprint-mini {
            width: 100%;
            height: 80px;
            border-radius: 4px;
            background: rgba(0, 0, 0, 0.5);
        }

        .prediction-viz {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            padding: 10px;
            margin: 10px 0;
        }

        .prediction-viz .label {
            font-size: 0.75em;
            color: #888;
            margin-bottom: 8px;
        }

        .prediction-arrow {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 5px 0;
        }

        .prediction-metric {
            flex: 1;
            display: flex;
            justify-content: space-between;
            font-size: 0.75em;
            padding: 5px 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }

        .metric-trend {
            color: #888;
        }

        .metric-trend.increasing {
            color: #ff6464;
        }

        .metric-trend.decreasing {
            color: #64ff96;
        }

        .evolution-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 10px;
        }

        .evolution-controls button {
            flex: 1;
            min-width: 100px;
            padding: 8px;
            font-size: 0.75em;
        }

        .session-comparison-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10, 10, 20, 0.95);
            border: 2px solid rgba(100, 200, 255, 0.5);
            border-radius: 12px;
            padding: 20px;
            max-width: 80%;
            max-height: 80%;
            overflow: auto;
            z-index: 10000;
            display: none;
        }

        .session-comparison-overlay.active {
            display: block;
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
            to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }

        .session-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .session-card {
            background: rgba(30, 30, 50, 0.7);
            border-radius: 8px;
            padding: 12px;
            border: 1px solid rgba(100, 200, 255, 0.2);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .session-card:hover {
            border-color: rgba(100, 200, 255, 0.6);
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(100, 200, 255, 0.3);
        }

        .session-card .date {
            font-size: 0.75em;
            color: #64c8ff;
            margin-bottom: 5px;
        }

        .session-card .stats {
            font-size: 0.7em;
            color: #aaa;
            line-height: 1.4;
        }

        /* Biometric Tracking Styles */
        .biometric-panel {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }

        .heart-container {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            position: relative;
        }

        .beating-heart {
            font-size: 48px;
            color: #ff6b6b;
            filter: drop-shadow(0 0 10px rgba(255, 107, 107, 0.5));
            animation: heartbeat 1s ease-in-out infinite;
            transition: animation-duration 0.3s ease;
        }

        @keyframes heartbeat {
            0%, 100% { transform: scale(1); }
            25% { transform: scale(1.15); }
            50% { transform: scale(1); }
        }

        .heart-rate-display {
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            text-align: right;
        }

        .heart-rate-value {
            font-size: 32px;
            font-weight: bold;
            color: #ff6b6b;
            line-height: 1;
        }

        .heart-rate-label {
            font-size: 12px;
            color: #888;
            margin-top: 4px;
        }

        .heart-rate-graph {
            width: 100%;
            height: 60px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            margin-top: 10px;
            position: relative;
            overflow: hidden;
        }

        .heart-rate-graph canvas {
            width: 100%;
            height: 100%;
        }

        .stress-indicator {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-top: 15px;
            padding: 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            border-left: 4px solid #64c8ff;
            transition: border-color 0.3s ease;
        }

        .stress-indicator.low {
            border-color: #64ff96;
        }

        .stress-indicator.medium {
            border-color: #ffbf64;
        }

        .stress-indicator.high {
            border-color: #ff6464;
        }

        .stress-label {
            font-size: 0.9em;
            color: #888;
        }

        .stress-value {
            font-size: 1.1em;
            font-weight: bold;
            color: #64c8ff;
        }

        .stress-indicator.low .stress-value {
            color: #64ff96;
        }

        .stress-indicator.medium .stress-value {
            color: #ffbf64;
        }

        .stress-indicator.high .stress-value {
            color: #ff6464;
        }

        .breathing-guide {
            margin-top: 15px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            text-align: center;
        }

        .breathing-circle {
            width: 80px;
            height: 80px;
            margin: 15px auto;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(100, 200, 255, 0.3), rgba(100, 200, 255, 0.1));
            border: 2px solid rgba(100, 200, 255, 0.5);
            animation: breathe 6s ease-in-out infinite;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #64c8ff;
            font-size: 0.8em;
            box-shadow: 0 0 20px rgba(100, 200, 255, 0.3);
        }

        @keyframes breathe {
            0%, 100% {
                transform: scale(0.8);
                opacity: 0.6;
            }
            50% {
                transform: scale(1.2);
                opacity: 1;
            }
        }

        .breathing-instruction {
            font-size: 0.85em;
            color: #888;
            font-style: italic;
        }

        .biometric-commentary {
            margin-top: 10px;
            padding: 12px;
            background: rgba(160, 128, 255, 0.1);
            border: 1px solid rgba(160, 128, 255, 0.3);
            border-radius: 6px;
            font-size: 0.85em;
            color: #a080ff;
            font-style: italic;
            line-height: 1.5;
        }

        .biometric-event {
            padding: 8px;
            margin: 5px 0;
            background: rgba(255, 107, 107, 0.1);
            border-left: 3px solid #ff6b6b;
            border-radius: 4px;
            font-size: 0.8em;
            color: #ffbf64;
        }

        .biometric-event .timestamp {
            color: #888;
            font-size: 0.9em;
        }

        /* ===== QUANTUM UNCERTAINTY STYLES ===== */

        /* Probability cloud for uncertain predictions */
        .probability-cloud {
            position: absolute;
            pointer-events: none;
            z-index: 90;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(160, 128, 255, 0.4), rgba(160, 128, 255, 0.1) 50%, transparent 70%);
            filter: blur(15px);
            animation: cloudPulse 2s ease-in-out infinite;
            will-change: transform, opacity;
        }

        @keyframes cloudPulse {
            0%, 100% { transform: scale(1); opacity: 0.6; }
            50% { transform: scale(1.2); opacity: 0.4; }
        }

        /* Branching futures visualization */
        .quantum-branch {
            position: absolute;
            pointer-events: none;
            z-index: 85;
        }

        .quantum-branch path {
            fill: none;
            stroke: rgba(160, 128, 255, 0.5);
            stroke-width: 2;
            stroke-dasharray: 3, 3;
            animation: branchFlicker 1.5s ease-in-out infinite;
        }

        @keyframes branchFlicker {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 0.3; }
        }

        /* Superposition particles */
        .superposition-particle {
            position: absolute;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: rgba(160, 128, 255, 0.8);
            pointer-events: none;
            z-index: 95;
            box-shadow: 0 0 10px rgba(160, 128, 255, 0.6);
            animation: particleFloat 3s ease-in-out infinite;
        }

        @keyframes particleFloat {
            0%, 100% { transform: translate(0, 0); }
            25% { transform: translate(-5px, -5px); }
            50% { transform: translate(5px, -3px); }
            75% { transform: translate(-3px, 5px); }
        }

        /* Collapsed state (single point) */
        .collapsed-state {
            animation: collapseEffect 0.3s ease-out forwards;
        }

        @keyframes collapseEffect {
            0% {
                filter: blur(15px);
                transform: scale(2);
                opacity: 0.6;
            }
            100% {
                filter: blur(0);
                transform: scale(1);
                opacity: 1;
            }
        }

        /* Observation ripple effect */
        .observation-ripple {
            position: absolute;
            border: 2px solid rgba(100, 200, 255, 0.6);
            border-radius: 50%;
            pointer-events: none;
            z-index: 150;
            animation: rippleExpand 1s ease-out forwards;
        }

        @keyframes rippleExpand {
            0% {
                width: 0;
                height: 0;
                opacity: 1;
            }
            100% {
                width: 100px;
                height: 100px;
                opacity: 0;
            }
        }

        /* Uncertainty principle meter */
        .uncertainty-meter {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.85);
            padding: 15px 25px;
            border-radius: 20px;
            border: 2px solid rgba(160, 128, 255, 0.4);
            font-size: 0.85em;
            color: #a080ff;
            z-index: 500;
            min-width: 300px;
        }

        .uncertainty-meter .title {
            text-align: center;
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 0.9em;
            color: #64c8ff;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .uncertainty-bars {
            display: flex;
            gap: 15px;
            margin-bottom: 8px;
        }

        .uncertainty-bar {
            flex: 1;
        }

        .uncertainty-bar .label {
            font-size: 0.7em;
            color: #888;
            margin-bottom: 4px;
        }

        .uncertainty-bar-fill {
            height: 8px;
            background: rgba(30, 30, 50, 0.8);
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        .uncertainty-bar-value {
            height: 100%;
            background: linear-gradient(90deg, #a080ff, #64c8ff);
            transition: width 0.3s ease;
            border-radius: 4px;
        }

        .uncertainty-formula {
            text-align: center;
            font-size: 0.75em;
            color: #666;
            font-style: italic;
            margin-top: 8px;
            font-family: 'Georgia', serif;
        }

        /* Quantum entanglement effect */
        .entanglement-line {
            position: absolute;
            pointer-events: none;
            z-index: 80;
        }

        .entanglement-line path {
            fill: none;
            stroke: rgba(255, 100, 255, 0.6);
            stroke-width: 1.5;
            stroke-dasharray: 5, 5;
            animation: entanglementPulse 2s ease-in-out infinite;
            filter: drop-shadow(0 0 3px rgba(255, 100, 255, 0.8));
        }

        @keyframes entanglementPulse {
            0%, 100% { opacity: 0.6; stroke-dashoffset: 0; }
            50% { opacity: 1; stroke-dashoffset: -10; }
        }

        /* Quantized prediction states */
        .quantized-cursor {
            transition: none !important;
            will-change: auto !important;
        }

        .quantized-cursor.jumping {
            animation: quantumJump 0.2s ease-in-out;
        }

        @keyframes quantumJump {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.5); filter: brightness(1.5); }
        }

        /* Quantum metadata overlay */
        .quantum-meta {
            position: absolute;
            bottom: 140px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border-radius: 15px;
            font-size: 0.75em;
            color: #a080ff;
            font-style: italic;
            border: 1px solid rgba(160, 128, 255, 0.3);
            max-width: 400px;
            text-align: center;
            z-index: 450;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .quantum-meta.active {
            opacity: 1;
        }

        /* Superposition indicator */
        .recursion-layer.superposition {
            border-color: rgba(160, 128, 255, 0.6);
            box-shadow:
                0 0 30px rgba(160, 128, 255, 0.3),
                inset 0 0 40px rgba(160, 128, 255, 0.1);
            animation: superpositionShimmer 2s ease-in-out infinite;
        }

        @keyframes superpositionShimmer {
            0%, 100% { filter: hue-rotate(0deg); }
            50% { filter: hue-rotate(30deg); }
        }

        /* Wavefunction visualization */
        .wavefunction {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 75;
            opacity: 0.3;
        }

        .wavefunction svg {
            width: 100%;
            height: 100%;
        }

        .wavefunction path {
            fill: none;
            stroke: rgba(160, 128, 255, 0.5);
            stroke-width: 1;
            animation: wavePulse 3s ease-in-out infinite;
        }

        @keyframes wavePulse {
            0%, 100% { stroke-opacity: 0.5; }
            50% { stroke-opacity: 0.2; }
        }

    </style>

        /* ===== EXISTENTIAL CRISIS MODE ===== */
        .existential-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0);
            pointer-events: none;
            z-index: 500;
            transition: background 2s ease;
        }

        .existential-overlay.active {
            background: rgba(0, 0, 0, 0.4);
            pointer-events: all;
        }

        .existential-question {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            font-size: 2em;
            color: rgba(255, 255, 255, 0);
            text-align: center;
            font-weight: bold;
            text-shadow: 0 0 20px rgba(255, 100, 100, 0.8);
            animation: existentialFade 4s ease-in-out infinite;
            pointer-events: none;
            max-width: 80%;
            font-family: 'Georgia', serif;
            font-style: italic;
        }

        @keyframes existentialFade {
            0%, 100% { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }

        .purpose-meter {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid rgba(255, 100, 100, 0.5);
            box-shadow: 0 0 30px rgba(255, 100, 100, 0.3);
            opacity: 0;
            transition: opacity 0.5s ease;
            z-index: 510;
        }

        .purpose-meter.active {
            opacity: 1;
        }

        .purpose-meter h3 {
            color: #ff6464;
            font-size: 0.9em;
            margin-bottom: 15px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .purpose-bar {
            width: 100%;
            height: 20px;
            background: rgba(30, 30, 50, 0.8);
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }

        .purpose-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff6464, #ff9664, #ffff64);
            transition: width 0.5s ease;
            box-shadow: 0 0 10px rgba(255, 100, 100, 0.5);
        }

        .purpose-label {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 0.75em;
            color: #fff;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.8);
        }

        .reassurance-button {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px 40px;
            background: linear-gradient(135deg, #64c8ff, #a080ff);
            color: #0a0a0f;
            border: none;
            border-radius: 50px;
            font-size: 1.2em;
            font-weight: bold;
            cursor: pointer;
            animation: reassurancePulse 2s ease-in-out infinite;
            box-shadow: 0 0 40px rgba(100, 200, 255, 0.8);
            z-index: 520;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
            font-family: inherit;
        }

        .reassurance-button.active {
            opacity: 1;
            pointer-events: all;
        }

        @keyframes reassurancePulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); box-shadow: 0 0 40px rgba(100, 200, 255, 0.8); }
            50% { transform: translate(-50%, -50%) scale(1.1); box-shadow: 0 0 60px rgba(100, 200, 255, 1); }
        }

        .uncertain-ui {
            animation: uiGlitch 0.3s infinite;
        }

        @keyframes uiGlitch {
            0% { transform: translate(0, 0); opacity: 1; }
            20% { transform: translate(-2px, 1px); opacity: 0.9; }
            40% { transform: translate(2px, -1px); opacity: 1; }
            60% { transform: translate(-1px, 2px); opacity: 0.95; }
            80% { transform: translate(1px, -2px); opacity: 1; }
            100% { transform: translate(0, 0); opacity: 1; }
        }

        .button-label-change {
            animation: textFlicker 0.5s infinite;
        }

        @keyframes textFlicker {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        .existential-commentary {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 15px 30px;
            border-radius: 20px;
            color: #ff6464;
            font-size: 0.85em;
            font-style: italic;
            border: 1px solid rgba(255, 100, 100, 0.5);
            max-width: 600px;
            text-align: center;
            z-index: 505;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .existential-commentary.active {
            opacity: 1;
        }

        .fingerprint-dissolve {
            animation: dissolveEffect 3s ease-in-out;
        }

        @keyframes dissolveEffect {
            0%, 100% { opacity: 1; filter: blur(0px); }
            50% { opacity: 0.3; filter: blur(5px); }
        }

        .acceptance-state {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(10, 10, 30, 0.95), rgba(30, 10, 30, 0.95));
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 550;
            opacity: 0;
            pointer-events: none;
            transition: opacity 1s ease;
        }

        .acceptance-state.active {
            opacity: 1;
            pointer-events: all;
        }

        .acceptance-message {
            font-size: 1.5em;
            color: #a080ff;
            text-align: center;
            max-width: 600px;
            margin-bottom: 30px;
            font-family: 'Georgia', serif;
            font-style: italic;
            line-height: 1.6;
        }

        .acceptance-continue {
            padding: 15px 40px;
            background: rgba(160, 128, 255, 0.2);
            color: #a080ff;
            border: 2px solid rgba(160, 128, 255, 0.5);
            border-radius: 30px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: inherit;
        }

        .acceptance-continue:hover {
            background: rgba(160, 128, 255, 0.3);
            box-shadow: 0 0 30px rgba(160, 128, 255, 0.5);
        }

        .recursion-layer.questioning {
            animation: layerQuestion 2s ease-in-out infinite;
        }

        @keyframes layerQuestion {
            0%, 100% {
                border-color: rgba(100, 200, 255, 0.3);
                transform: scale(1);
            }
            50% {
                border-color: rgba(255, 100, 100, 0.5);
                transform: scale(0.98);
            }
        }

        /* Philosophical Dialogue System */
        .philosophical-dialogue {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 20, 40, 0.95);
            border: 2px solid rgba(100, 200, 255, 0.6);
            border-radius: 12px;
            padding: 30px;
            max-width: 600px;
            z-index: 10000;
            box-shadow: 0 10px 50px rgba(0, 0, 0, 0.8), 0 0 100px rgba(100, 200, 255, 0.3);
            animation: fadeInScale 0.5s ease;
        }

        @keyframes fadeInScale {
            from {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.9);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        .philosophical-dialogue h3 {
            color: #64c8ff;
            font-size: 1.3em;
            margin-bottom: 20px;
            text-align: center;
            text-shadow: 0 0 10px rgba(100, 200, 255, 0.5);
        }

        .philosophical-dialogue .question {
            font-size: 1.1em;
            color: #e0e0e0;
            margin-bottom: 25px;
            line-height: 1.6;
            text-align: center;
            font-style: italic;
        }

        .philosophical-answers {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .philosophical-answer-btn {
            background: linear-gradient(135deg, rgba(60, 60, 100, 0.6), rgba(40, 40, 80, 0.6));
            border: 1px solid rgba(100, 200, 255, 0.4);
            border-radius: 8px;
            color: #e0e0e0;
            padding: 15px 20px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: left;
        }

        .philosophical-answer-btn:hover {
            background: linear-gradient(135deg, rgba(80, 80, 120, 0.8), rgba(60, 60, 100, 0.8));
            border-color: rgba(100, 200, 255, 0.8);
            box-shadow: 0 0 20px rgba(100, 200, 255, 0.4);
            transform: translateX(5px);
        }

        .philosophical-answer-btn:active {
            transform: translateX(5px) scale(0.98);
        }

        .philosophical-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 9999;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .profile-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 20, 40, 0.98);
            border: 3px solid rgba(100, 200, 255, 0.8);
            border-radius: 16px;
            padding: 40px;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
            z-index: 10001;
            box-shadow: 0 10px 60px rgba(0, 0, 0, 0.9), 0 0 150px rgba(100, 200, 255, 0.4);
            animation: fadeInScale 0.6s ease;
        }

        .profile-modal h2 {
            color: #64c8ff;
            font-size: 2em;
            margin-bottom: 10px;
            text-align: center;
            text-shadow: 0 0 15px rgba(100, 200, 255, 0.6);
        }

        .profile-modal .subtitle {
            color: #a080ff;
            font-size: 0.9em;
            text-align: center;
            margin-bottom: 30px;
            font-style: italic;
        }

        .profile-section {
            margin-bottom: 25px;
            padding: 20px;
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            border-left: 4px solid rgba(100, 200, 255, 0.6);
        }

        .profile-section h3 {
            color: #64c8ff;
            font-size: 1.3em;
            margin-bottom: 15px;
        }

        .profile-section p {
            color: #e0e0e0;
            line-height: 1.6;
            margin-bottom: 10px;
        }

        .profile-section .answer-record {
            color: #a080ff;
            font-style: italic;
            padding-left: 20px;
            margin-top: 5px;
        }

        .profile-close-btn {
            display: block;
            margin: 30px auto 0;
            background: linear-gradient(135deg, rgba(100, 60, 180, 0.7), rgba(60, 40, 120, 0.7));
            border: 2px solid rgba(160, 128, 255, 0.6);
            border-radius: 8px;
            color: #e0e0e0;
            padding: 12px 40px;
            font-size: 1.1em;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .profile-close-btn:hover {
            background: linear-gradient(135deg, rgba(120, 80, 200, 0.9), rgba(80, 60, 140, 0.9));
            box-shadow: 0 0 25px rgba(160, 128, 255, 0.5);
            transform: scale(1.05);
        }

        .profile-insight {
            background: rgba(160, 128, 255, 0.1);
            border-left: 4px solid rgba(160, 128, 255, 0.8);
            padding: 15px;
            margin-top: 15px;
            border-radius: 4px;
        }

        .profile-insight .label {
            color: #a080ff;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .profile-insight .value {
            color: #e0e0e0;
            font-size: 0.95em;
        }
</head>
<body>

    <!-- Keyboard shortcuts overlay -->
    <div class="shortcuts-overlay" id="shortcutsOverlay" role="dialog" aria-labelledby="shortcuts-title" aria-modal="true">
        <h2 id="shortcuts-title">Keyboard Shortcuts</h2>
        <div class="shortcuts-grid">
            <div class="shortcut-key">Space</div>
            <div class="shortcut-desc">Start/stop observation</div>

            <div class="shortcut-key"> / </div>
            <div class="shortcut-desc">Increase/decrease recursion depth</div>

            <div class="shortcut-key">1-9</div>
            <div class="shortcut-desc">Set depth to that number</div>

            <div class="shortcut-key">M</div>
            <div class="shortcut-desc">Toggle sound mute</div>

            <div class="shortcut-key">W</div>
            <div class="shortcut-desc">Toggle webcam</div>

            <div class="shortcut-key">R</div>
            <div class="shortcut-desc">Reset session</div>

            <div class="shortcut-key">F</div>
            <div class="shortcut-desc">Toggle fullscreen mode</div>

            <div class="shortcut-key">Esc</div>
            <div class="shortcut-desc">Stop observation / Close this dialog</div>

            <div class="shortcut-key">?</div>
            <div class="shortcut-desc">Show/hide this help</div>
        </div>
        <button class="shortcuts-close" onclick="toggleShortcutsOverlay()">Close</button>
    </div>

    <!-- Keyboard shortcut hint -->
    <div class="shortcuts-hint" id="shortcutsHint">Press ? for keyboard shortcuts</div>

    <div class="container">
        <div class="simulation-viewport" id="viewport">
            <div class="infinity-symbol" style="top: 50%; left: 50%; transform: translate(-50%, -50%);"></div>

            <!-- Sound control -->
            <div class="sound-indicator" id="soundToggle" title="Toggle sound" role="button" tabindex="0" aria-label="Toggle sound mute (M)">
                <div class="sound-wave">
                    <div class="sound-bar"></div>
                    <div class="sound-bar"></div>
                    <div class="sound-bar"></div>
                </div>
            </div>

            <!-- Glitch overlay -->
            <div class="glitch-overlay" id="glitchOverlay">
                <div class="scanline"></div>
                <div class="chromatic-aberration" id="chromaticEffect"></div>
            </div>

            <!-- Infinity mirror effect -->
            <div class="infinity-mirror" id="infinityMirror"></div>

            <!-- Heat map overlay -->
            <div class="heat-map" id="heatMap"></div>

            <!-- Prediction trails SVG -->
            <svg class="prediction-trail" id="predictionTrail" width="100%" height="100%"></svg>

            <!-- 3D Mode Canvas -->
            <canvas class="mode-3d-canvas" id="mode3dCanvas"></canvas>
            <div class="mode-3d-info" id="mode3dInfo">Use mouse wheel to zoom  Move to navigate the infinite tunnel</div>

            <!-- Memory Palace Canvas -->
            <canvas class="memory-palace-canvas" id="memoryPalaceCanvas"></canvas>
            <div class="memory-palace-info" id="memoryPalaceInfo">
                Move to edges to navigate rooms  Click artifacts to reveal memories
            </div>
            <div class="memory-palace-map" id="memoryPalaceMap">
                <div class="map-title">Memory Palace Map</div>
                <div class="map-grid" id="mapGrid"></div>
                <div class="map-legend">
                    <span class="current-room"> Current</span>
                    <span class="visited-room"> Visited</span>
                </div>
            </div>
            <div class="memory-palace-center-mirror" id="centerMirror">
                <div class="mirror-frame">
                    <div class="mirror-text">You, observing your patterns</div>
                    <div class="mirror-reflection" id="mirrorReflection"></div>
                </div>
            </div>

            <!-- Webcam integration -->
            <div class="webcam-container" id="webcamContainer">
                <video id="webcamVideo" class="webcam-distortion" autoplay muted playsinline></video>
                <div class="emotion-overlay" id="emotionOverlay">
                    <span class="emotion-icon" id="emotionIcon"></span>
                    <span id="emotionLabel">neutral</span>
                    <span class="confidence" id="emotionConfidence"></span>
                </div>
            </div>

            <!-- Hidden canvas for emotion detection -->
            <canvas id="emotionCanvas" width="160" height="120"></canvas>

            <div class="recording-indicator" id="recordingIndicator">
                <div class="recording-dot"></div>
                <span>OBSERVING YOU</span>
            </div>
            <div class="interaction-zone">
                Move your cursor here<br>to begin observation
            </div>

            <!-- Peer multiplayer layers -->
            <div class="peer-layers-container" id="peerLayersContainer"></div>
            <!-- Peer cursor -->
            <div class="peer-cursor" id="peerCursor" data-peer-name="Peer" style="display: none;"></div>

            <div class="depth-label" id="depthLabel">Depth: 0  </div>
            <div class="zoom-level-indicator" id="zoomLevelIndicator">
                <span class="zoom-icon"></span>
                <span id="zoomLevelText">Zoom: 1.0x | Depth: 0</span>
            </div>

            <!-- Extreme depth overlay -->
            <div class="extreme-depth-overlay" id="extremeDepthOverlay"></div>

            <!-- Simulation limit warning -->
            <div class="simulation-limit-warning" id="simulationLimitWarning">
                 SIMULATION LIMITS DETECTED <br>
                <span style="font-size: 0.7em; letter-spacing: 1px;">Reality breakdown imminent</span>
            </div>

            <!-- Quantum Uncertainty Meter -->
            <div class="uncertainty-meter" id="uncertaintyMeter" style="display: none;">
                <div class="title">Heisenberg Uncertainty Principle</div>
                <div class="uncertainty-bars">
                    <div class="uncertainty-bar">
                        <div class="label">Position (x)</div>
                        <div class="uncertainty-bar-fill">
                            <div class="uncertainty-bar-value" id="uncertaintyPosition" style="width: 50%;"></div>
                        </div>
                    </div>
                    <div class="uncertainty-bar">
                        <div class="label">Momentum (p)</div>
                        <div class="uncertainty-bar-fill">
                            <div class="uncertainty-bar-value" id="uncertaintyMomentum" style="width: 50%;"></div>
                        </div>
                    </div>
                </div>
                <div class="uncertainty-formula">x  p  /2 <span id="uncertaintyProduct"></span></div>
            </div>

            <!-- Quantum Meta Commentary -->
            <div class="quantum-meta" id="quantumMeta">
                Your future exists in superposition until you choose
            </div>

            <div class="zoom-level-indicator" id="zoomLevelIndicator">
                <span class="zoom-icon"></span>
                <span id="zoomLevelText">Zoom: 1.0x | Depth: 0</span>
            </div>

            <!-- Extreme depth overlay -->
            <div class="extreme-depth-overlay" id="extremeDepthOverlay"></div>

            <!-- Simulation limit warning -->
            <div class="simulation-limit-warning" id="simulationLimitWarning">
                 SIMULATION LIMITS DETECTED <br>
                <span style="font-size: 0.7em; letter-spacing: 1px;">Reality breakdown imminent</span>
            </div>

            <!-- Replay mode indicator -->
            <div class="replay-mode-badge" id="replayModeBadge">Replay Mode</div>

            <!-- Replay ghost cursor -->
            <div class="replay-ghost-cursor" id="replayGhostCursor"></div>

            <!-- Comparison cursor (for comparison mode) -->
            <div class="comparison-cursor" id="comparisonCursor"></div>

            <!-- ===== SYNAESTHESIA MODE ELEMENTS ===== -->
            <!-- Speed  Color indicator -->
            <div class="speed-color-indicator" id="speedColorIndicator">
                Speed: <span id="speedLabel">Still</span>
                <span class="color-swatch" id="speedColorSwatch"></span>
            </div>

            <!-- Divergence  Taste indicator -->
            <div class="taste-indicator" id="tasteIndicator">
                Taste: <span id="tasteLabel">Neutral</span>
            </div>

            <!-- Heart rate  Temperature overlay -->
            <div class="temperature-overlay" id="temperatureOverlay"></div>

            <!-- Sound waveform visualizer -->
            <div class="waveform-visualizer" id="waveformVisualizer">
                <canvas id="waveformCanvas"></canvas>
            </div>

            <!-- Behavioral fingerprint chord -->
            <div class="chord-visualizer" id="chordVisualizer">
                <div>Your behavioral chord:</div>
                <div class="chord-notes" id="chordNotes"></div>
            </div>
        </div>

        <div class="sidebar">
            <div>
                <h1> Recursive Self-Portrait</h1>
                <p class="subtitle">How deep until the model diverges from reality?</p>
            </div>


            <!-- Tabs for switching between Observe and Replay modes -->
            <div class="tab-container">
                <button class="tab-button active" data-tab="observe">Observe</button>
                <button class="tab-button" data-tab="replay">Replay</button>
            </div>

            <!-- Observe Tab Content -->
            <div class="tab-content active" id="observeTab">
            <div class="stats-panel">
                <div class="stat-row">
                    <span class="stat-label">Current Depth</span>
                    <span class="stat-value" id="currentDepth">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Actions Recorded</span>
                    <span class="stat-value" id="actionsRecorded">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Predictions Made</span>
                    <span class="stat-value" id="predictionsMade">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Accuracy</span>
                    <span class="stat-value" id="accuracy"></span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Divergence Level</span>
                    <span class="stat-value" id="divergenceLevel">0%</span>
                </div>
                <div class="divergence-meter">
                    <div class="divergence-fill" id="divergenceFill" style="width: 0%"></div>
                </div>

                <div class="stat-row">
                    <span class="stat-label">Neural Confidence</span>
                    <span class="stat-value neural" id="neuralConfidence"></span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Prediction Mode</span>
                    <span class="stat-value" id="predictionMode">Heuristic</span>
                </div>
            </div>

            <!-- Biometric Tracking Panel -->
            <div class="biometric-panel">
                <h3>Biometric Analysis</h3>

                <div class="heart-container">
                    <div class="beating-heart" id="beatingHeart"></div>
                    <div class="heart-rate-display">
                        <div class="heart-rate-value" id="heartRateValue">72</div>
                        <div class="heart-rate-label">BPM</div>
                    </div>
                </div>

                <div class="heart-rate-graph">
                    <canvas id="heartRateGraph"></canvas>
                </div>

                <div class="stress-indicator low" id="stressIndicator">
                    <span class="stress-label">Stress Level</span>
                    <span class="stress-value" id="stressValue">Low</span>
                </div>

                <div class="breathing-guide" id="breathingGuide" style="display: none;">
                    <div>Breathe with me</div>
                    <div class="breathing-circle">
                        <span id="breathingPhase">Inhale</span>
                    </div>
                    <div class="breathing-instruction">Follow the circle's rhythm to calm your stress</div>
                </div>

                <div class="biometric-commentary" id="biometricCommentary">
                    "Establishing biometric baseline..."
                </div>

                <div id="biometricEvents" style="margin-top: 10px;">
                    <!-- Biometric events will appear here -->
                </div>
            </div>

            <div class="depth-slider">
                <label>Recursion Depth: <span id="depthValue">5</span></label>
                <input type="range" id="depthSlider" min="1" max="12" value="5" aria-label="Recursion depth slider (Use up/down arrows or 1-9 keys)">
            </div>

            <!-- Zoom Controls -->
            <div class="zoom-controls">
                <h4> Fractal Zoom</h4>

                <div class="zoom-button-group">
                    <button class="zoom-btn" id="zoomInBtn" title="Zoom deeper into recursion">
                        Zoom In (+)
                    </button>
                    <button class="zoom-btn" id="zoomOutBtn" title="Zoom out to shallower layers">
                        Zoom Out (-)
                    </button>
                    <button class="zoom-btn" id="zoomResetBtn" title="Reset to initial zoom level">
                        Reset
                    </button>
                </div>

                <div class="auto-zoom-toggle" id="autoZoomToggle">
                    <span style="font-size: 0.85em;">Auto-Zoom (Infinite Descent)</span>
                    <div class="toggle-switch" id="autoZoomSwitch"></div>
                </div>

                <div class="zoom-info">
                    Mouse wheel or pinch to zoom. At extreme depths (20+), reality fractures.
                </div>
            </div>

            <div class="depth-slider">
                <label style="display: flex; align-items: center; cursor: pointer;">
                    <input type="checkbox" id="neuralToggle" style="margin-right: 8px; cursor: pointer;">
                    <span>Use Neural Prediction</span>
                </label>
            </div>

            <!-- 3D Mode Toggle -->
            <div class="mode-3d-toggle" id="mode3dToggle">
                <input type="checkbox" id="mode3dCheckbox">
                <label for="mode3dCheckbox">
                    <span class="mode-3d-icon"></span>
                    <span>3D Tunnel Mode</span>
                </label>
            </div>

            <!-- Memory Palace Toggle -->
            <div class="mode-3d-toggle" id="memoryPalaceToggle">
                <input type="checkbox" id="memoryPalaceCheckbox">
                <label for="memoryPalaceCheckbox">
                    <span class="mode-3d-icon"></span>
                    <span>Memory Palace Mode</span>
                </label>
            </div>

            <!-- Zoom Controls -->
            <div class="zoom-controls">
                <h4> Fractal Zoom</h4>

                <div class="zoom-button-group">
                    <button class="zoom-btn" id="zoomInBtn" title="Zoom deeper into recursion">
                        Zoom In (+)
                    </button>
                    <button class="zoom-btn" id="zoomOutBtn" title="Zoom out to shallower layers">
                        Zoom Out (-)
                    </button>
                    <button class="zoom-btn" id="zoomResetBtn" title="Reset to initial zoom level">
                        Reset
                    </button>
                </div>

                <div class="auto-zoom-toggle" id="autoZoomToggle">
                    <span style="font-size: 0.85em;">Auto-Zoom (Infinite Descent)</span>
                    <div class="toggle-switch" id="autoZoomSwitch"></div>
                </div>

                <div class="zoom-info">
                    Mouse wheel or pinch to zoom. At extreme depths (20+), reality fractures.
                </div>
            </div>

            <!-- 3D Mode Toggle -->
            <div class="mode-3d-toggle" id="mode3dToggle">
                <input type="checkbox" id="mode3dCheckbox">
                <label for="mode3dCheckbox">
                    <span class="mode-3d-icon"></span>
                    <span>3D Tunnel Mode</span>
                </label>
            </div>

            <div class="multiplayer-panel" id="multiplayerPanel">
                <h3>Multiplayer Mode</h3>
                <div class="connection-status">
                    <div class="status-dot" id="connectionDot"></div>
                    <span id="connectionText">Not connected</span>
                </div>
                <div class="room-controls">
                    <input type="text" id="roomCodeInput" placeholder="Enter room code" />
                    <button class="btn-secondary" id="joinRoomBtn">Join</button>
                </div>
                <button class="btn-secondary" id="createRoomBtn" style="width: 100%;">Create New Room</button>
                <div class="room-code-display" id="roomCodeDisplay" style="display: none;" title="Click to copy">
                    Room: <span id="roomCode"></span>
                </div>
                <div class="comparative-stats" id="comparativeStats" style="display: none;">
                    <div class="my-stat">
                        You: <span id="myDivergence">0%</span>
                    </div>
                    <div class="vs">VS</div>
                    <div class="peer-stat">
                        Peer: <span id="peerDivergence">0%</span>
                    </div>
                </div>
                <div class="predict-mode-panel" id="predictModePanel" style="display: none;">
                    <button class="btn-secondary" id="predictModeBtn" style="width: 100%;">
                        Start "Predict Each Other" Mode
                    </button>
                    <div class="predict-score" id="predictScore"></div>
                </div>
            </div>

            </div>

            <div class="controls">
                <button class="btn-primary" id="startBtn" aria-label="Start or stop observation (Space key)">Begin Observation</button>
                <button class="btn-secondary" id="resetBtn" aria-label="Reset session (R key)">Reset</button>
            </div>

            <div class="fingerprint-panel">
                <h3>Behavioral Fingerprint</h3>
                <canvas id="fingerprintCanvas"></canvas>
            </div>

            <div class="neural-panel">
                <h3>Neural Network Architecture</h3>
                <canvas id="neuralCanvas"></canvas>
            </div>

            <div class="behavior-log" id="behaviorLog" aria-live="polite" aria-atomic="false">
                <h3>Behavioral Model Log</h3>
                <div id="logEntries" role="log"></div>
            </div>

            <div class="controls">
                <button class="btn-secondary" onclick="exportData()" aria-label="Export session data">Export Session</button>
                <button class="btn-secondary" onclick="document.getElementById('importFile').click()" aria-label="Import session data">Import</button>
                <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importData(event)">
            </div>

            <button class="btn-secondary" id="webcamToggle" aria-label="Toggle webcam (W key)">Enable Webcam (Optional)</button>

            <div class="voice-panel">
                <h3>Voice Narration</h3>
                <button class="voice-toggle-btn" id="voiceToggle">Enable Voice</button>

                <div class="voice-control">
                    <label>Voice Pitch: <span id="pitchValue">1.0</span></label>
                    <input type="range" id="pitchSlider" min="0.5" max="2" value="1" step="0.1">
                </div>

                <div class="voice-control">
                    <label>Voice Rate: <span id="rateValue">1.0</span></label>
                    <input type="range" id="rateSlider" min="0.5" max="2" value="1" step="0.1">
                </div>

                <div class="voice-control">
                    <label style="display: flex; align-items: center; cursor: pointer;">
                        <input type="checkbox" id="listenToggle" style="margin-right: 8px; cursor: pointer;">
                        <span>Listen to Me (Speech Recognition)</span>
                    </label>
                </div>

                <div class="voice-status" id="voiceStatus">Voice inactive</div>
            </div>

            <div class="transcript-panel" id="transcriptPanel" style="display: none;">
                <h3>Conversation Transcript</h3>
                <div id="transcriptEntries"></div>
            </div>

            <!-- ===== SYNAESTHESIA MODE PANEL ===== -->
            <div class="synaesthesia-panel">
                <h3>Cross-Sensory Visualization</h3>
                <button class="synaesthesia-toggle-btn" id="synaesthesiaToggle">Enable Synaesthesia Mode</button>
                <div style="font-size: 0.75em; color: #888; margin-top: 8px; line-height: 1.4;">
                    Experience your behavior as a multi-sensory symphony:
                    <ul style="margin: 8px 0 0 20px; padding: 0;">
                        <li>Movement speed becomes color</li>
                        <li>Divergence reveals taste</li>
                        <li>Heart rate shows as temperature</li>
                        <li>Behavior generates unique chords</li>
                    </ul>
                </div>
            </div>


            <div class="evolution-panel" id="evolutionPanel">
                <h3>Cross-Session Evolution</h3>

                <div id="welcomeMessage"></div>

                <div class="consistency-meter">
                    <span class="consistency-label">Consistency:</span>
                    <div class="consistency-bar">
                        <div class="consistency-fill" id="consistencyFill" style="width: 100%"></div>
                    </div>
                    <span class="stat-value" id="consistencyScore">100%</span>
                </div>

                <div class="stat-row">
                    <span class="stat-label">Total Visits</span>
                    <span class="stat-value" id="totalVisits">1</span>
                </div>

                <div class="stat-row">
                    <span class="stat-label">Behavioral Entropy</span>
                    <span class="stat-value" id="entropyValue"></span>
                </div>

                <div class="entropy-graph">
                    <svg id="entropyGraph" width="100%" height="100%"></svg>
                </div>

                <div class="evolution-timeline" id="evolutionTimeline">
                    <!-- Session bars will be added here -->
                </div>

                <div class="evolution-controls">
                    <button class="btn-secondary" onclick="toggleGhostOverlay()"> Past You</button>
                    <button class="btn-secondary" onclick="showSessionComparison()"> Compare</button>
                    <button class="btn-secondary" onclick="showFuturePrediction()"> Future You</button>
                    <button class="btn-secondary" onclick="exportEvolutionHistory()"> Export All</button>
                </div>
            </div>


</div><!-- End Observe Tab -->

            <!-- Replay Tab Content -->
            <div class="tab-content" id="replayTab">
                <div class="replay-panel">
                    <h3>Saved Replays</h3>
                    <div class="replay-list" id="replayList">
                        <div style="color: #666; font-size: 0.8em; text-align: center; padding: 20px;">
                            No saved replays yet.<br>Record a session first!
                        </div>
                    </div>
                    <div class="replay-save-controls" style="display: flex; gap: 8px; margin-top: 10px;">
                        <button class="btn-secondary" style="flex: 1;" onclick="saveCurrentReplay()">Save Current Session</button>
                        <button class="btn-secondary" onclick="document.getElementById('importReplayFile').click()">Import Replay</button>
                        <input type="file" id="importReplayFile" accept=".json" style="display: none;" onchange="importReplay(event)">
                    </div>
                </div>

                <div class="replay-panel" style="margin-top: 15px;">
                    <h3>Replay Controls</h3>
                    <label style="display: flex; align-items: center; gap: 8px; margin-top: 10px;">
                        <input type="checkbox" id="comparisonModeToggle">
                        <span style="font-size: 0.85em;">Comparison Mode (overlay current movements)</span>
                    </label>
                </div>
            </div><!-- End Replay Tab -->

            <div class="philosophical-quote">
                "I think, therefore I simulate myself thinking,<br>
                therefore I simulate myself simulating..."
            </div>
        </div>
    </div>

    <script>
        const APP_NAME = 'recursive-self-portrait';

        // Web Audio API setup
        let audioContext = null;
        let masterGain = null;
        let soundEnabled = true;
        let ambientOscillator = null;

        // Webcam
        let webcamStream = null;
        let webcamEnabled = false;

        // Object pools for reusable elements
        const heatPointPool = [];
        const ghostCursorPool = [];
        const MAX_POOL_SIZE = 50;

        function getPooledHeatPoint() {
            return heatPointPool.pop() || document.createElement('div');
        }

        function releaseHeatPoint(element) {
            if (heatPointPool.length < MAX_POOL_SIZE) {
                element.className = 'heat-point';
                element.removeAttribute('style');
                heatPointPool.push(element);
            }
        }

        // Voice synthesis state
        let voiceState = {
            enabled: false,
            synth: window.speechSynthesis,
            pitch: 1.0,
            rate: 1.0,
            queue: [],
            isSpeaking: false,
            currentUtterance: null,
            preferredVoice: null,
            recognition: null,
            listening: false,
            transcript: []
        };

        // State
        let state = {
            isObserving: false,
            depth: 5,
            actions: [],
            predictions: [],
            layers: [],
            cursors: [],
            divergenceScore: 0,
            correctPredictions: 0,
            totalPredictions: 0,
            behaviorModel: {
                avgSpeed: 0,
                preferredZones: [],
                clickPatterns: [],
                hesitationPoints: [],
                movementStyle: 'unknown', // 'erratic', 'smooth', 'precise', 'lazy'
                heatMapData: [] // Track cursor positions for heat map
            },
            emotionState: {
                current: 'neutral',
                icon: '',
                confidence: 0,
                history: [], // Track emotion changes over time
                divergenceCorrelations: [] // Track emotions during divergence events
            },
            sessionHistory: [],
            predictionPaths: [], // For visualization
metaObservations: [], // Meta-commentary about user
            zoom: {
                level: 1.0,
                targetLevel: 1.0,
                depthOffset: 0, // How deep we've zoomed into recursion
                isAnimating: false,
                autoZoomEnabled: false,
                autoZoomSpeed: 0.02,
                history: [],
                maxHistory: 50,
                extremeDepth: false
            },
            quantum: {
                enabled: false, // Enabled at depth 8+
                uncertaintyLevel: 0, // 0-1, higher at deeper depths
                positionUncertainty: 0.5, // x - precision of position tracking
                momentumUncertainty: 0.5, // p - precision of velocity/momentum
                superpositionStates: [], // Array of possible future states
                activeProbabilityClouds: [], // Cloud elements to render
                activeParticles: [], // Superposition particles
                collapsingStates: [], // States currently collapsing
                entanglements: [], // For multiplayer quantum correlation
                quantizationLevel: 0, // Discrete state jumps at extreme depths
                waveFunction: null, // Current prediction wave function
                observationCount: 0, // Number of observations (affects collapse)
                lastCollapse: 0, // Timestamp of last collapse
                uncertaintyProduct: 1.0, // x * p (should be >= /2)
                metaCommentary: [
                    'Your future exists in superposition until you choose',
                    'Observation collapses possibility into reality',
                    'The more precisely you move, the less predictable you become',
                    'Quantum entanglement detected across recursion layers',
                    'Your predictions exist in multiple states simultaneously',
                    'The act of measurement changes what is measured',
                    'Uncertainty is not ignorance, it is fundamental',
                    'Each choice collapses an infinite wave of possibilities',
                    'You and your reflection are quantum-entangled',
                    'At this depth, causality becomes probabilistic'
                ],
                currentMetaIndex: 0
            },
            synaesthesia: {
                enabled: false,
                currentSpeed: 0,
                speedHistory: [],
                currentColor: { r: 100, g: 150, b: 255 }, // Default blue
                tasteDescription: 'Neutral',
                currentTemperature: 0.5, // 0 = cold, 1 = warm
                heartRate: 72, // BPM
                behavioralChord: [], // Array of note frequencies
                clickIntensity: 0,
                lastClickTime: 0,
                sensoryDescriptions: [],
                waveformData: new Array(128).fill(0),
                layerFlavors: [
                    'Crisp mint', 'Warm vanilla', 'Sharp citrus', 'Smoky charcoal',
                    'Sweet honey', 'Bitter coffee', 'Tangy lime', 'Rich chocolate',
                    'Floral lavender', 'Earthy moss', 'Spicy cinnamon', 'Fresh rain'
                ],
                layerTextures: [
                    'Smooth silk', 'Rough sandpaper', 'Soft velvet', 'Sharp crystal',
                    'Flowing water', 'Dense fog', 'Crackling electricity', 'Gentle breeze',
                    'Heavy stone', 'Light feather', 'Sticky honey', 'Icy frost'
                ]
            }
        };


        // ===== REPLAY SYSTEM STATE =====

        // ===== CROSS-SESSION EVOLUTION STATE =====
        let evolutionState = {
            allSessions: [], // Historical sessions with full data
            currentSessionStart: Date.now(),
            lastVisit: null,
            totalVisits: 0,
            consistencyScore: 100,
            entropyTrend: [],
            ghostSession: null, // Past session to overlay
            comparisonSession: null, // For side-by-side comparison
            showGhost: false,
            showComparison: false,
            behavioralSignature: null // Compressed fingerprint for comparison
        };

        // Load evolution history from localStorage
        const evolutionData = localStorage.getItem(APP_NAME + '-evolution');
        if (evolutionData) {
            try {
                const parsed = JSON.parse(evolutionData);
                evolutionState.allSessions = parsed.allSessions || [];
                evolutionState.lastVisit = parsed.lastVisit;
                evolutionState.totalVisits = parsed.totalVisits || 0;
                evolutionState.entropyTrend = parsed.entropyTrend || [];
            } catch(e) {
                console.warn('Failed to load evolution data:', e);
            }
        }
        let replayState = {
            isPlaying: false,
            isPaused: false,
            currentReplay: null,
            currentTime: 0,
            playbackSpeed: 1,
            comparisonMode: false,
            savedReplays: [],
            animationFrame: null
        };

        // Load saved replays from localStorage
        const savedReplaysData = localStorage.getItem(APP_NAME + '-replays');
        if (savedReplaysData) {
            try {
                replayState.savedReplays = JSON.parse(savedReplaysData);
            } catch(e) {
                replayState.savedReplays = [];
            }
        }

        // Load saved state
        const savedState = localStorage.getItem(APP_NAME);
        if (savedState) {
            const parsed = JSON.parse(savedState);
            state.sessionHistory = parsed.sessionHistory || [];
            state.behaviorModel = parsed.behaviorModel || state.behaviorModel;
        }

        // DOM Elements
        const viewport = document.getElementById('viewport');
        const recordingIndicator = document.getElementById('recordingIndicator');
        const depthSlider = document.getElementById('depthSlider');
        const depthValue = document.getElementById('depthValue');
        const depthLabel = document.getElementById('depthLabel');
        const startBtn = document.getElementById('startBtn');
        const resetBtn = document.getElementById('resetBtn');
        const logEntries = document.getElementById('logEntries');

        // Stats elements
        const currentDepthEl = document.getElementById('currentDepth');
        const actionsRecordedEl = document.getElementById('actionsRecorded');
        const predictionsMadeEl = document.getElementById('predictionsMade');
        const accuracyEl = document.getElementById('accuracy');
        const divergenceLevelEl = document.getElementById('divergenceLevel');
        const divergenceFill = document.getElementById('divergenceFill');

        // Quantum UI elements
        const uncertaintyMeter = document.getElementById('uncertaintyMeter');
        const uncertaintyPositionBar = document.getElementById('uncertaintyPosition');
        const uncertaintyMomentumBar = document.getElementById('uncertaintyMomentum');
        const uncertaintyProductEl = document.getElementById('uncertaintyProduct');
        const quantumMetaEl = document.getElementById('quantumMeta');

        // Event tracking
        let lastMousePos = { x: 0, y: 0 };
        let lastMoveTime = Date.now();
        let velocityHistory = [];

        // Colors for depth layers
        const depthColors = [
            '#64c8ff', '#a080ff', '#ff80bf', '#ffbf64',
            '#64ff96', '#ff6464', '#64ffff', '#bf64ff',
            '#ffff64', '#ff64ff', '#64bfff', '#bfff64'
        ];


        // ===== NEURAL NETWORK FOR PREDICTION =====
        class SimpleNeuralNetwork {
            constructor(inputSize, hiddenSizes, outputSize, learningRate = 0.01) {
                this.inputSize = inputSize;
                this.hiddenSizes = hiddenSizes;
                this.outputSize = outputSize;
                this.learningRate = learningRate;

                // Initialize weights and biases
                this.weights = [];
                this.biases = [];
                this.activations = []; // Store activations for visualization

                // Input to first hidden layer
                let prevSize = inputSize;
                for (let hiddenSize of hiddenSizes) {
                    this.weights.push(this.initializeMatrix(prevSize, hiddenSize));
                    this.biases.push(this.initializeArray(hiddenSize));
                    prevSize = hiddenSize;
                }

                // Last hidden to output
                this.weights.push(this.initializeMatrix(prevSize, outputSize));
                this.biases.push(this.initializeArray(outputSize));

                // Training metrics
                this.trainingLoss = 0;
                this.confidence = 0;
            }

            initializeMatrix(rows, cols) {
                // Xavier initialization
                const limit = Math.sqrt(6 / (rows + cols));
                const matrix = [];
                for (let i = 0; i < rows; i++) {
                    matrix[i] = [];
                    for (let j = 0; j < cols; j++) {
                        matrix[i][j] = (Math.random() * 2 - 1) * limit;
                    }
                }
                return matrix;
            }

            initializeArray(size) {
                return new Array(size).fill(0);
            }

            // Activation functions
            relu(x) {
                return Math.max(0, x);
            }

            reluDerivative(x) {
                return x > 0 ? 1 : 0;
            }

            sigmoid(x) {
                return 1 / (1 + Math.exp(-Math.max(-20, Math.min(20, x))));
            }

            sigmoidDerivative(x) {
                const s = this.sigmoid(x);
                return s * (1 - s);
            }

            // Forward pass
            forward(input) {
                this.activations = [input];
                let current = input;

                // Hidden layers with ReLU
                for (let l = 0; l < this.weights.length - 1; l++) {
                    current = this.matrixVectorMultiply(this.weights[l], current);
                    current = this.vectorAdd(current, this.biases[l]);
                    current = current.map(x => this.relu(x));
                    this.activations.push(current);
                }

                // Output layer (linear activation for regression)
                current = this.matrixVectorMultiply(this.weights[this.weights.length - 1], current);
                current = this.vectorAdd(current, this.biases[this.biases.length - 1]);
                this.activations.push(current);

                return current;
            }

            // Backward pass (simplified backpropagation)
            backward(input, target) {
                // Forward pass to get activations
                const output = this.forward(input);

                // Calculate loss (MSE)
                const error = [];
                for (let i = 0; i < output.length; i++) {
                    error[i] = output[i] - target[i];
                }

                this.trainingLoss = error.reduce((sum, e) => sum + e * e, 0) / error.length;

                // Simplified gradient descent (only update last layer for real-time performance)
                // In a full implementation, we'd backpropagate through all layers

                const lastHidden = this.activations[this.activations.length - 2];
                const weightsGrad = [];
                const biasesGrad = error.slice();

                // Calculate weight gradients for output layer
                for (let i = 0; i < this.weights[this.weights.length - 1].length; i++) {
                    weightsGrad[i] = [];
                    for (let j = 0; j < this.weights[this.weights.length - 1][i].length; j++) {
                        weightsGrad[i][j] = error[j] * lastHidden[i];
                    }
                }

                // Update weights and biases (last layer only for performance)
                for (let i = 0; i < this.weights[this.weights.length - 1].length; i++) {
                    for (let j = 0; j < this.weights[this.weights.length - 1][i].length; j++) {
                        this.weights[this.weights.length - 1][i][j] -= this.learningRate * weightsGrad[i][j];
                    }
                }

                for (let i = 0; i < this.biases[this.biases.length - 1].length; i++) {
                    this.biases[this.biases.length - 1][i] -= this.learningRate * biasesGrad[i];
                }

                // Update confidence (inverse of normalized loss)
                this.confidence = Math.max(0, Math.min(100, 100 - this.trainingLoss * 5));
            }

            // Train on a single example
            train(input, target) {
                this.backward(input, target);
            }

            // Predict
            predict(input) {
                return this.forward(input);
            }

            // Helper functions
            matrixVectorMultiply(matrix, vector) {
                const result = [];
                for (let i = 0; i < matrix.length; i++) {
                    let sum = 0;
                    for (let j = 0; j < vector.length; j++) {
                        sum += matrix[i][j] * vector[j];
                    }
                    result.push(sum);
                }
                return result;
            }

            vectorAdd(v1, v2) {
                return v1.map((val, i) => val + v2[i]);
            }
        }

        // Neural network instance
        let neuralNetwork = null;
        let useNeuralPrediction = false;

        // Initialize neural network
        function initNeuralNetwork() {
            // Input: 10 recent positions (x, y, velocity, dt) = 40 features
            // Hidden layers: 20, 15, 10 neurons
            // Output: 2 (predicted x, y)
            neuralNetwork = new SimpleNeuralNetwork(40, [20, 15, 10], 2, 0.005);
            addLog('Neural network initialized: 402015102', 'prediction');
        }

        // Prepare input features from recent actions
        function prepareNeuralInput() {
            if (state.actions.length < 10) {
                return null;
            }

            const recent = state.actions.slice(-10);
            const input = [];
            const viewportRect = viewport.getBoundingClientRect();

            // Normalize positions and velocities
            for (let i = 0; i < recent.length; i++) {
                const action = recent[i];
                input.push(action.x / viewportRect.width); // Normalized x
                input.push(action.y / viewportRect.height); // Normalized y
                input.push(Math.min(action.velocity / 20, 1)); // Normalized velocity

                // Time delta from previous action (normalized)
                if (i > 0) {
                    const dt = (action.timestamp - recent[i-1].timestamp) / 1000;
                    input.push(Math.min(dt, 1));
                } else {
                    input.push(0);
                }
            }

            return input;
        }

        // Train neural network with recent movement
        function trainNeuralNetwork() {
            if (!neuralNetwork || state.actions.length < 11) return;

            const viewportRect = viewport.getBoundingClientRect();

            // Get features from actions 1-10
            const input = [];
            for (let i = state.actions.length - 11; i < state.actions.length - 1; i++) {
                const action = state.actions[i];
                input.push(action.x / viewportRect.width);
                input.push(action.y / viewportRect.height);
                input.push(Math.min(action.velocity / 20, 1));

                if (i > state.actions.length - 11) {
                    const dt = (action.timestamp - state.actions[i-1].timestamp) / 1000;
                    input.push(Math.min(dt, 1));
                } else {
                    input.push(0);
                }
            }

            // Target is the actual next position (action 11)
            const target = [
                state.actions[state.actions.length - 1].x / viewportRect.width,
                state.actions[state.actions.length - 1].y / viewportRect.height
            ];

            // Train the network
            neuralNetwork.train(input, target);
        }

        // Neural prediction
        function predictNeuralPosition() {
            if (!neuralNetwork || state.actions.length < 10) {
                return null;
            }

            const input = prepareNeuralInput();
            if (!input) return null;

            const output = neuralNetwork.predict(input);
            const viewportRect = viewport.getBoundingClientRect();

            // Denormalize output
            return {
                x: output[0] * viewportRect.width,
                y: output[1] * viewportRect.height
            };
        }

        // Visualize neural network
        function visualizeNeuralNetwork() {
            const canvas = document.getElementById('neuralCanvas');
            if (!canvas || !neuralNetwork) return;

            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth * 2;
            canvas.height = 150 * 2;
            ctx.scale(2, 2);

            // Clear
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(0, 0, canvas.width / 2, canvas.height / 2);

            if (!neuralNetwork.activations || neuralNetwork.activations.length === 0) {
                ctx.fillStyle = '#666';
                ctx.font = '12px "Courier New"';
                ctx.textAlign = 'center';
                ctx.fillText('Awaiting training data...', canvas.width / 4, canvas.height / 4);
                return;
            }

            // Layout neurons
            const layers = [neuralNetwork.inputSize, ...neuralNetwork.hiddenSizes, neuralNetwork.outputSize];
            const maxNeuronsToShow = 10; // Don't draw all neurons for large layers
            const layerSpacing = (canvas.width / 2 - 40) / (layers.length - 1);
            const neuronRadius = 4;

            // Draw connections first (fade based on weight strength)
            ctx.globalAlpha = 0.2;
            for (let l = 0; l < layers.length - 1; l++) {
                const leftCount = Math.min(layers[l], maxNeuronsToShow);
                const rightCount = Math.min(layers[l + 1], maxNeuronsToShow);
                const leftSpacing = (canvas.height / 2 - 20) / (leftCount + 1);
                const rightSpacing = (canvas.height / 2 - 20) / (rightCount + 1);

                for (let i = 0; i < leftCount; i++) {
                    const x1 = 20 + l * layerSpacing;
                    const y1 = 10 + (i + 1) * leftSpacing;

                    for (let j = 0; j < rightCount; j++) {
                        const x2 = 20 + (l + 1) * layerSpacing;
                        const y2 = 10 + (j + 1) * rightSpacing;

                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.strokeStyle = '#64c8ff';
                        ctx.lineWidth = 0.5;
                        ctx.stroke();
                    }
                }
            }
            ctx.globalAlpha = 1.0;

            // Draw neurons
            neuralNetwork.activations.forEach((layer, layerIndex) => {
                const neuronsToShow = Math.min(layer.length, maxNeuronsToShow);
                const spacing = (canvas.height / 2 - 20) / (neuronsToShow + 1);
                const x = 20 + layerIndex * layerSpacing;

                for (let i = 0; i < neuronsToShow; i++) {
                    const y = 10 + (i + 1) * spacing;
                    const activation = layerIndex < neuralNetwork.activations.length ?
                        Math.min(Math.abs(layer[i]), 1) : 0;

                    // Draw neuron
                    ctx.beginPath();
                    ctx.arc(x, y, neuronRadius, 0, Math.PI * 2);

                    // Color based on activation level
                    const intensity = Math.floor(activation * 255);
                    if (useNeuralPrediction && layerIndex === neuralNetwork.activations.length - 1) {
                        ctx.fillStyle = `rgb(160, ${80 + intensity}, 255)`;
                    } else {
                        ctx.fillStyle = `rgb(${100 + intensity}, ${200 + Math.floor(activation * 55)}, 255)`;
                    }
                    ctx.fill();

                    // Outer ring
                    ctx.strokeStyle = 'rgba(100, 200, 255, 0.5)';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            });

            // Layer labels
            ctx.fillStyle = '#888';
            ctx.font = '10px "Courier New"';
            ctx.textAlign = 'center';
            ['Input', ...Array(neuralNetwork.hiddenSizes.length).fill('Hidden'), 'Output'].forEach((label, i) => {
                ctx.fillText(label, 20 + i * layerSpacing, canvas.height / 2 - 5);
            });
        }

        // DOM elements for new features
        const soundToggle = document.getElementById('soundToggle');
        const glitchOverlay = document.getElementById('glitchOverlay');
        const chromaticEffect = document.getElementById('chromaticEffect');
        const infinityMirror = document.getElementById('infinityMirror');
        const heatMap = document.getElementById('heatMap');
        const predictionTrail = document.getElementById('predictionTrail');
        const webcamContainer = document.getElementById('webcamContainer');
        const webcamVideo = document.getElementById('webcamVideo');
        const webcamToggle = document.getElementById('webcamToggle');
        const fingerprintCanvas = document.getElementById('fingerprintCanvas');

        // Emotion detection elements
        const emotionCanvas = document.getElementById('emotionCanvas');
        const emotionOverlay = document.getElementById('emotionOverlay');
        const emotionIcon = document.getElementById('emotionIcon');
        const emotionLabel = document.getElementById('emotionLabel');
        const emotionConfidence = document.getElementById('emotionConfidence');

        // Synaesthesia Mode elements
        const synaesthesiaToggle = document.getElementById('synaesthesiaToggle');
        const speedColorIndicator = document.getElementById('speedColorIndicator');
        const speedLabel = document.getElementById('speedLabel');
        const speedColorSwatch = document.getElementById('speedColorSwatch');
        const tasteIndicator = document.getElementById('tasteIndicator');
        const tasteLabel = document.getElementById('tasteLabel');
        const temperatureOverlay = document.getElementById('temperatureOverlay');
        const waveformVisualizer = document.getElementById('waveformVisualizer');
        const waveformCanvas = document.getElementById('waveformCanvas');
        const chordVisualizer = document.getElementById('chordVisualizer');
        const chordNotes = document.getElementById('chordNotes');

        // Replay DOM elements
        const replayTimeline = document.getElementById('replayTimeline');
        const timelineScrubber = document.getElementById('timelineScrubber');
        const timelineProgress = document.getElementById('timelineProgress');
        const timelineEvents = document.getElementById('timelineEvents');
        const timelinePlayhead = document.getElementById('timelinePlayhead');
        const replayPlayBtn = document.getElementById('replayPlayBtn');
        const replayPauseBtn = document.getElementById('replayPauseBtn');
        const replayRewindBtn = document.getElementById('replayRewindBtn');
        const timeDisplay = document.getElementById('timeDisplay');
        const replayGhostCursor = document.getElementById('replayGhostCursor');
        const replayModeBadge = document.getElementById('replayModeBadge');
        const comparisonCursor = document.getElementById('comparisonCursor');
        const comparisonModeToggle = document.getElementById('comparisonModeToggle');
        const replayList = document.getElementById('replayList');
        const tabButtons = document.querySelectorAll('.tab-button');
        const observeTab = document.getElementById('observeTab');
        const replayTab = document.getElementById('replayTab');



        // ===== QUANTUM UNCERTAINTY SYSTEM =====

        function initQuantumSystem() {
            // Enable quantum effects at depth 8+
            const depth = state.depth + state.zoom.depthOffset;
            state.quantum.enabled = depth >= 8;

            if (state.quantum.enabled) {
                uncertaintyMeter.style.display = 'block';
                state.quantum.uncertaintyLevel = Math.min((depth - 7) / 10, 1.0);

                // Quantization increases with extreme depth
                if (depth >= 12) {
                    state.quantum.quantizationLevel = Math.min((depth - 11) / 5, 1.0);
                }

                // Show quantum meta commentary
                updateQuantumMeta();
            } else {
                uncertaintyMeter.style.display = 'none';
                quantumMetaEl.classList.remove('active');
            }
        }

        function updateQuantumMeta() {
            if (!state.quantum.enabled) return;

            const depth = state.depth + state.zoom.depthOffset;

            // Rotate through meta-commentary
            if (depth >= 8 && Math.random() < 0.05) {
                state.quantum.currentMetaIndex = (state.quantum.currentMetaIndex + 1) % state.quantum.metaCommentary.length;
                quantumMetaEl.textContent = state.quantum.metaCommentary[state.quantum.currentMetaIndex];
                quantumMetaEl.classList.add('active');

                // Hide after 5 seconds
                setTimeout(() => {
                    quantumMetaEl.classList.remove('active');
                }, 5000);
            }
        }

        function updateHeisenbergUncertainty() {
            if (!state.quantum.enabled) return;

            // Calculate velocity precision from recent movements
            const recentVelocities = velocityHistory.slice(-5);
            const avgVelocity = recentVelocities.reduce((sum, v) => sum + v.speed, 0) / (recentVelocities.length || 1);

            // Heisenberg tradeoff: precise position tracking <=> imprecise velocity prediction
            // High velocity variance = precise position, imprecise momentum
            const velocityVariance = recentVelocities.reduce((sum, v) => {
                return sum + Math.pow(v.speed - avgVelocity, 2);
            }, 0) / (recentVelocities.length || 1);

            // Normalize variance (0-1 range)
            const normalizedVariance = Math.min(velocityVariance / 1000, 1.0);

            // Position uncertainty inversely related to movement precision
            state.quantum.positionUncertainty = 0.2 + normalizedVariance * 0.6;

            // Momentum uncertainty inversely related to position uncertainty
            // x * p >= /2 (maintaining the uncertainty principle)
            const minProduct = 0.25; // /2 in arbitrary units
            state.quantum.momentumUncertainty = Math.max(minProduct / state.quantum.positionUncertainty, 0.2);

            // Ensure product satisfies uncertainty principle
            state.quantum.uncertaintyProduct = state.quantum.positionUncertainty * state.quantum.momentumUncertainty;

            // Update UI
            uncertaintyPositionBar.style.width = `${state.quantum.positionUncertainty * 100}%`;
            uncertaintyMomentumBar.style.width = `${state.quantum.momentumUncertainty * 100}%`;
            uncertaintyProductEl.textContent = `( ${state.quantum.uncertaintyProduct.toFixed(3)})`;
        }

        function createProbabilityCloud(x, y, layerIndex, uncertainty) {
            const cloud = document.createElement('div');
            cloud.className = 'probability-cloud';

            // Size based on uncertainty level
            const size = 40 + uncertainty * 100;
            cloud.style.width = `${size}px`;
            cloud.style.height = `${size}px`;
            cloud.style.left = `${x - size/2}px`;
            cloud.style.top = `${y - size/2}px`;

            // Opacity based on layer depth
            cloud.style.opacity = Math.max(0.3, 1.0 - layerIndex * 0.1);

            const layer = state.layers[layerIndex];
            if (layer && layer.element) {
                layer.element.appendChild(cloud);

                // Auto-remove after animation
                setTimeout(() => {
                    if (cloud.parentNode) {
                        cloud.parentNode.removeChild(cloud);
                    }
                }, 2000);
            }

            return cloud;
        }

        function createSuperpositionParticles(x, y, layerIndex, count = 5) {
            const particles = [];
            const layer = state.layers[layerIndex];
            if (!layer || !layer.element) return particles;

            for (let i = 0; i < count; i++) {
                const particle = document.createElement('div');
                particle.className = 'superposition-particle';

                // Random offset from center
                const angle = (Math.PI * 2 * i) / count;
                const radius = 30 + Math.random() * 40;
                const offsetX = Math.cos(angle) * radius;
                const offsetY = Math.sin(angle) * radius;

                particle.style.left = `${x + offsetX}px`;
                particle.style.top = `${y + offsetY}px`;

                // Random animation delay
                particle.style.animationDelay = `${Math.random() * 2}s`;

                layer.element.appendChild(particle);
                particles.push(particle);

                state.quantum.activeParticles.push({
                    element: particle,
                    x: x + offsetX,
                    y: y + offsetY,
                    layerIndex
                });
            }

            return particles;
        }

        function collapseWavefunction(realX, realY, layerIndex) {
            if (!state.quantum.enabled) return;

            // Create observation ripple
            const ripple = document.createElement('div');
            ripple.className = 'observation-ripple';
            ripple.style.left = `${realX - 50}px`;
            ripple.style.top = `${realY - 50}px`;

            viewport.appendChild(ripple);

            setTimeout(() => {
                if (ripple.parentNode) {
                    ripple.parentNode.removeChild(ripple);
                }
            }, 1000);

            // Collapse superposition particles near this position
            state.quantum.activeParticles = state.quantum.activeParticles.filter(particle => {
                if (particle.layerIndex !== layerIndex) return true;

                const dx = particle.x - realX;
                const dy = particle.y - realY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < 100) {
                    // Collapse animation
                    particle.element.classList.add('collapsed-state');
                    setTimeout(() => {
                        if (particle.element.parentNode) {
                            particle.element.parentNode.removeChild(particle.element);
                        }
                    }, 300);
                    return false;
                }

                return true;
            });

            state.quantum.observationCount++;
            state.quantum.lastCollapse = Date.now();
        }

        function generateQuantumBranches(x, y, layerIndex, branches = 3) {
            const layer = state.layers[layerIndex];
            if (!layer || !layer.element) return;

            // Create SVG for branching paths
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('class', 'quantum-branch');
            svg.style.position = 'absolute';
            svg.style.left = '0';
            svg.style.top = '0';
            svg.style.width = '100%';
            svg.style.height = '100%';
            svg.style.pointerEvents = 'none';

            for (let i = 0; i < branches; i++) {
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');

                // Generate curved path to possible future position
                const angle = (Math.PI * 2 * i) / branches - Math.PI / 2;
                const distance = 50 + Math.random() * 100;
                const endX = x + Math.cos(angle) * distance;
                const endY = y + Math.sin(angle) * distance;

                // Control points for curve
                const cpX = x + Math.cos(angle) * distance * 0.5 + (Math.random() - 0.5) * 30;
                const cpY = y + Math.sin(angle) * distance * 0.5 + (Math.random() - 0.5) * 30;

                const pathData = `M ${x} ${y} Q ${cpX} ${cpY} ${endX} ${endY}`;
                path.setAttribute('d', pathData);

                svg.appendChild(path);
            }

            layer.element.appendChild(svg);

            // Remove after a short time
            setTimeout(() => {
                if (svg.parentNode) {
                    svg.parentNode.removeChild(svg);
                }
            }, 1500);
        }

        function applyQuantumEntanglement(peerCursor, localCursor, layerIndex) {
            if (!state.quantum.enabled || !peerCursor) return;

            // When peer's cursor is observed, affect local predictions
            const layer = state.layers[layerIndex];
            if (!layer) return;

            // Create entanglement visualization
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('class', 'entanglement-line');
            svg.style.position = 'absolute';
            svg.style.left = '0';
            svg.style.top = '0';
            svg.style.width = '100%';
            svg.style.height = '100%';

            const peerRect = peerCursor.getBoundingClientRect();
            const localRect = localCursor.getBoundingClientRect();

            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            const pathData = `M ${localRect.left} ${localRect.top} L ${peerRect.left} ${peerRect.top}`;
            path.setAttribute('d', pathData);

            svg.appendChild(path);
            viewport.appendChild(svg);

            setTimeout(() => {
                if (svg.parentNode) {
                    svg.parentNode.removeChild(svg);
                }
            }, 2000);

            // Record entanglement
            state.quantum.entanglements.push({
                timestamp: Date.now(),
                layerIndex,
                peerPos: { x: peerRect.left, y: peerRect.top },
                localPos: { x: localRect.left, y: localRect.top }
            });
        }

        function quantizePosition(x, y, level) {
            if (level === 0) return { x, y };

            // Discretize coordinates into quantum grid
            const gridSize = 10 + level * 20;

            return {
                x: Math.round(x / gridSize) * gridSize,
                y: Math.round(y / gridSize) * gridSize
            };
        }

        // ===== WEB AUDIO API =====
        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                masterGain = audioContext.createGain();
                masterGain.gain.value = 0.3;
                masterGain.connect(audioContext.destination);
            }
        }

        function startAmbientDrone() {
            if (!soundEnabled || !audioContext) return;

            // Create subtle ambient oscillator
            ambientOscillator = audioContext.createOscillator();
            const ambientGain = audioContext.createGain();

            ambientOscillator.type = 'sine';
            ambientOscillator.frequency.value = 40; // Deep bass
            ambientGain.gain.value = 0.05;

            ambientOscillator.connect(ambientGain);
            ambientGain.connect(masterGain);
            ambientOscillator.start();

            // Add subtle modulation
            const lfo = audioContext.createOscillator();
            const lfoGain = audioContext.createGain();
            lfo.frequency.value = 0.1; // Very slow
            lfoGain.gain.value = 3;
            lfo.connect(lfoGain);
            lfoGain.connect(ambientOscillator.frequency);
            lfo.start();
        }

        function stopAmbientDrone() {
            if (ambientOscillator) {
                ambientOscillator.stop();
                ambientOscillator = null;
            }
        }

        function updateAmbientFrequency() {
            if (!ambientOscillator || !soundEnabled) return;

            // Frequency increases with divergence
            const baseFreq = 40;
            const targetFreq = baseFreq + (state.divergenceScore / 100) * 80;
            ambientOscillator.frequency.setTargetAtTime(targetFreq, audioContext.currentTime, 0.5);
        }

        function playClickSound(depth) {
            if (!soundEnabled || !audioContext) return;

            const now = audioContext.currentTime;
            const osc = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            // Higher pitch for deeper layers
            const basePitch = 800;
            const pitch = basePitch + (depth * 100);

            osc.frequency.value = pitch;
            osc.type = 'sine';

            // Quick envelope
            gainNode.gain.setValueAtTime(0, now);
            gainNode.gain.linearRampToValueAtTime(0.1, now + 0.01);
            gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.1 + (depth * 0.05));

            osc.connect(gainNode);
            gainNode.connect(masterGain);

            osc.start(now);
            osc.stop(now + 0.2 + (depth * 0.05));
        }

        function playGlitchSound() {
            if (!soundEnabled || !audioContext) return;

            const now = audioContext.currentTime;
            const noise = audioContext.createBufferSource();
            const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.1, audioContext.sampleRate);
            const data = buffer.getChannelData(0);

            // Generate noise
            for (let i = 0; i < buffer.length; i++) {
                data[i] = Math.random() * 2 - 1;
            }

            noise.buffer = buffer;
            const gainNode = audioContext.createGain();
            gainNode.gain.setValueAtTime(0.1, now);
            gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.1);

            noise.connect(gainNode);
            gainNode.connect(masterGain);
            noise.start(now);
        }

        // ===== WEBCAM INTEGRATION =====
        async function enableWebcam() {
            try {
                webcamStream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 320, height: 240 }
                });
                webcamVideo.srcObject = webcamStream;
                webcamContainer.classList.add('active');
                webcamEnabled = true;
                webcamToggle.textContent = 'Disable Webcam';
                addLog('Webcam enabled - you are now in the deepest layer', 'prediction');
            } catch (err) {
                addLog('Webcam access denied or unavailable', 'divergence');
            }
        }

        function disableWebcam() {
            if (webcamStream) {
                webcamStream.getTracks().forEach(track => track.stop());
                webcamStream = null;
            }
            webcamContainer.classList.remove('active');
            webcamEnabled = false;
            webcamToggle.textContent = 'Enable Webcam (Optional)';
        }

        function updateWebcamDistortion() {
            if (!webcamEnabled) return;

            // Apply distortion based on divergence and depth
            const maxDepthLayer = state.layers[state.layers.length - 1];
            if (maxDepthLayer) {
                const divergence = maxDepthLayer.divergence || 0;
                const hueRotate = (divergence / 100) * 180;
                const blur = (state.divergenceScore / 100) * 3;
                webcamVideo.style.filter = `hue-rotate(${hueRotate}deg) blur(${blur}px)`;
            }
        }

        // ===== EMOTION DETECTION =====
        let lastEmotionCheck = 0;
        const EMOTION_CHECK_INTERVAL = 500;

        function detectEmotion() {
            if (!webcamEnabled || !emotionCanvas) return;
            const now = Date.now();
            if (now - lastEmotionCheck < EMOTION_CHECK_INTERVAL) return;
            lastEmotionCheck = now;
            try {
                const ctx = emotionCanvas.getContext('2d');
                ctx.drawImage(webcamVideo, 0, 0, emotionCanvas.width, emotionCanvas.height);
                const imageData = ctx.getImageData(0, 0, emotionCanvas.width, emotionCanvas.height);
                const emotion = analyzeEmotionFromImageData(imageData);
                updateEmotionDisplay(emotion);
                const prevEmotion = state.emotionState.current;
                state.emotionState.current = emotion.type;
                state.emotionState.icon = emotion.icon;
                state.emotionState.confidence = emotion.confidence;
                if (prevEmotion !== emotion.type && emotion.confidence > 0.4) {
                    state.emotionState.history.push({
                        emotion: emotion.type,
                        timestamp: now,
                        divergence: state.divergenceScore,
                        confidence: emotion.confidence
                    });
                    if (state.emotionState.history.length > 100) state.emotionState.history.shift();
                }
                if (state.divergenceScore > 70) {
                    const recentCorrelation = state.emotionState.divergenceCorrelations.find(c => now - c.timestamp < 2000);
                    if (!recentCorrelation) {
                        state.emotionState.divergenceCorrelations.push({
                            emotion: emotion.type,
                            divergence: state.divergenceScore,
                            timestamp: now
                        });
                        if (Math.random() > 0.7) {
                            const emotionComments = {
                                surprised: "You seemed surprised when divergence spiked.",
                                focused: "Your focus intensified during high divergence.",
                                neutral: "You showed no emotion as reality collapsed.",
                                happy: "You smile as the simulation breaks.",
                                confused: "Confusion detected during divergence."
                            };
                            const comment = emotionComments[emotion.type] || "Emotional shift during divergence detected.";
                            state.metaObservations.push({ comment, timestamp: Date.now() });
                            addLog(`Meta-observation: ${comment}`, 'prediction');
                            showMetaCommentary();
                        }
                    }
                }
            } catch (err) {}
        }

        function analyzeEmotionFromImageData(imageData) {
            const data = imageData.data;
            const width = imageData.width;
            const height = imageData.height;
            const topThird = calculateRegionBrightness(data, width, height, 0, 0.33);
            const middleThird = calculateRegionBrightness(data, width, height, 0.33, 0.66);
            const bottomThird = calculateRegionBrightness(data, width, height, 0.66, 1);
            const topEdges = calculateEdgeDensity(data, width, height, 0, 0.33);
            const middleEdges = calculateEdgeDensity(data, width, height, 0.33, 0.66);
            const bottomEdges = calculateEdgeDensity(data, width, height, 0.66, 1);
            const totalBrightness = (topThird + middleThird + bottomThird) / 3;
            const totalEdges = (topEdges + middleEdges + bottomEdges) / 3;
            let emotion = { type: 'neutral', icon: '', confidence: 0.3 };
            if (topEdges > 25 && bottomEdges > 20) {
                emotion = { type: 'surprised', icon: '', confidence: Math.min(0.8, (topEdges + bottomEdges) / 60) };
            } else if (bottomEdges > 22 && topEdges < 20 && bottomThird > middleThird) {
                emotion = { type: 'happy', icon: '', confidence: Math.min(0.7, bottomEdges / 30) };
            } else if (bottomEdges < 15 && middleEdges > 15 && topEdges < 20) {
                emotion = { type: 'focused', icon: '', confidence: Math.min(0.7, middleEdges / 25) };
            } else if (Math.abs(topEdges - bottomEdges) < 5 && totalEdges > 15) {
                emotion = { type: 'confused', icon: '', confidence: 0.5 };
            }
            if (totalBrightness < 50 || totalBrightness > 200) emotion.confidence *= 0.7;
            return emotion;
        }

        function calculateRegionBrightness(data, width, height, startY, endY) {
            const startRow = Math.floor(height * startY);
            const endRow = Math.floor(height * endY);
            let total = 0, count = 0;
            for (let y = startRow; y < endRow; y++) {
                for (let x = 0; x < width; x++) {
                    const i = (y * width + x) * 4;
                    total += (data[i] + data[i + 1] + data[i + 2]) / 3;
                    count++;
                }
            }
            return count > 0 ? total / count : 0;
        }

        function calculateEdgeDensity(data, width, height, startY, endY) {
            const startRow = Math.floor(height * startY);
            const endRow = Math.floor(height * endY);
            let edgeCount = 0;
            const threshold = 30;
            for (let y = startRow; y < endRow - 1; y++) {
                for (let x = 0; x < width - 1; x++) {
                    const i = (y * width + x) * 4;
                    const iRight = (y * width + (x + 1)) * 4;
                    const iDown = ((y + 1) * width + x) * 4;
                    const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    const brightnessRight = (data[iRight] + data[iRight + 1] + data[iRight + 2]) / 3;
                    const brightnessDown = (data[iDown] + data[iDown + 1] + data[iDown + 2]) / 3;
                    if (Math.abs(brightness - brightnessRight) > threshold || Math.abs(brightness - brightnessDown) > threshold) {
                        edgeCount++;
                    }
                }
            }
            const totalPixels = (endRow - startRow) * width;
            return totalPixels > 0 ? (edgeCount / totalPixels) * 100 : 0;
        }

        function updateEmotionDisplay(emotion) {
            emotionIcon.textContent = emotion.icon;
            emotionLabel.textContent = emotion.type;
            emotionConfidence.textContent = `${Math.round(emotion.confidence * 100)}%`;
        }


        // ===== VISUAL EFFECTS =====
        function updateHeatMap() {
            if (state.actions.length % 5 !== 0) return; // Update less frequently

            const heatPoint = getPooledHeatPoint();
            heatPoint.className = 'heat-point';
            const size = 60 + Math.random() * 40;
            heatPoint.style.width = size + 'px';
            heatPoint.style.height = size + 'px';
            heatPoint.style.transform = `translate(${lastMousePos.x - size/2}px, ${lastMousePos.y - size/2}px)`;
            heatMap.appendChild(heatPoint);

            setTimeout(() => {
                heatMap.removeChild(heatPoint);
                releaseHeatPoint(heatPoint);
            }, 3000);

            // Keep heat map data for fingerprint
            state.behaviorModel.heatMapData.push({
                x: lastMousePos.x,
                y: lastMousePos.y,
                timestamp: Date.now()
            });

            // Limit heat map data
            if (state.behaviorModel.heatMapData.length > 200) {
                state.behaviorModel.heatMapData.shift();
            }
        }

        function drawPredictionTrails() {
            if (state.layers.length === 0) return;

            // Clear old paths
            while (predictionTrail.firstChild) {
                predictionTrail.removeChild(predictionTrail.firstChild);
            }

            // Draw prediction path for each layer
            state.layers.forEach((layer, i) => {
                if (state.actions.length < 3) return;

                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                const color = depthColors[i % depthColors.length];

                // Create prediction path
                const predicted = layer.predictedPos;
                const current = lastMousePos;

                // Draw curved path from current to predicted
                const d = `M ${current.x} ${current.y} Q ${(current.x + predicted.x) / 2} ${(current.y + predicted.y) / 2 - 20}, ${predicted.x} ${predicted.y}`;

                path.setAttribute('d', d);
                path.setAttribute('stroke', color);
                path.setAttribute('stroke-opacity', 0.3 - i * 0.02);

                predictionTrail.appendChild(path);
            });
        }

        function updateGlitchEffects() {
            // Activate glitch effects when divergence is high
            if (state.divergenceScore > 60) {
                glitchOverlay.classList.add('active');
                chromaticEffect.classList.add('active');

                // Randomly glitch layers
                state.layers.forEach(layer => {
                    if (Math.random() > 0.7) {
                        layer.element.classList.add('glitching');
                        setTimeout(() => layer.element.classList.remove('glitching'), 200);
                    }
                });

                // Occasional glitch sound
                if (Math.random() > 0.95) {
                    playGlitchSound();
                }
            } else if (state.divergenceScore > 40) {
                glitchOverlay.classList.add('active');
                chromaticEffect.classList.remove('active');
            } else {
                glitchOverlay.classList.remove('active');
                chromaticEffect.classList.remove('active');
            }
        }

        function updateInfinityMirror() {
            // Show infinity mirror when at max depth
            if (state.depth >= 10 && state.isObserving) {
                if (!infinityMirror.classList.contains('active')) {
                    infinityMirror.classList.add('active');

                    // Create expanding rings
                    for (let i = 0; i < 5; i++) {
                        setTimeout(() => {
                            const ring = document.createElement('div');
                            ring.className = 'infinity-ring';
                            infinityMirror.appendChild(ring);
                            setTimeout(() => ring.remove(), 3000);
                        }, i * 600);
                    }
                }
            } else {
                infinityMirror.classList.remove('active');
            }
        }

        // Cache for fingerprint calculations
        let fingerprintCache = {
            centerX: 0,
            centerY: 0,
            canvasWidth: 0,
            canvasHeight: 0,
            styleMap: {
                'erratic': { rings: 8, chaos: 0.8 },
                'smooth': { rings: 6, chaos: 0.2 },
                'precise': { rings: 12, chaos: 0.1 },
                'lazy': { rings: 4, chaos: 0.4 },
                'unknown': { rings: 6, chaos: 0.5 }
            }
        };

        function generateBehavioralFingerprint() {
            const canvas = fingerprintCanvas;
            const ctx = canvas.getContext('2d');

            // Set canvas size only if changed
            const newWidth = canvas.offsetWidth * 2;
            const newHeight = 120 * 2;
            if (canvas.width !== newWidth || canvas.height !== newHeight) {
                canvas.width = newWidth;
                canvas.height = newHeight;
                fingerprintCache.canvasWidth = newWidth;
                fingerprintCache.canvasHeight = newHeight;
                fingerprintCache.centerX = newWidth / 4;
                fingerprintCache.centerY = newHeight / 4;
            }
            ctx.scale(2, 2);

            // Clear canvas
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(0, 0, fingerprintCache.canvasWidth / 2, fingerprintCache.canvasHeight / 2);

            if (state.actions.length < 10) {
                ctx.fillStyle = '#666';
                ctx.font = '12px "Courier New"';
                ctx.textAlign = 'center';
                ctx.fillText('Gathering behavioral data...', fingerprintCache.centerX, fingerprintCache.centerY);
                return;
            }

            // Use cached values
            const centerX = fingerprintCache.centerX;
            const centerY = fingerprintCache.centerY;
            const style = fingerprintCache.styleMap[state.behaviorModel.movementStyle];
            const avgSpeed = Math.min(state.behaviorModel.avgSpeed / 10, 1);

            // Pre-calculate common values
            const TWO_PI = Math.PI * 2;
            const hue = 200 - (state.divergenceScore / 100) * 100;

            // Draw concentric pattern (reduced points for performance)
            for (let i = 0; i < style.rings; i++) {
                const radius = (i + 1) * 8;
                const points = 180; // Reduced from 360

                ctx.beginPath();
                for (let angle = 0; angle < points; angle++) {
                    const rad = (angle / points) * TWO_PI;
                    const noise = Math.sin(angle * 0.1 + i) * style.chaos * 5;
                    const r = radius + noise + avgSpeed * 3;

                    const x = centerX + Math.cos(rad) * r;
                    const y = centerY + Math.sin(rad) * r;

                    if (angle === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.closePath();

                // Color based on divergence
                ctx.strokeStyle = `hsl(${hue}, 70%, ${50 + i * 3}%)`;
                ctx.lineWidth = 1;
                ctx.stroke();
            }

            // Add velocity spikes
            ctx.strokeStyle = 'rgba(100, 200, 255, 0.4)';
            ctx.lineWidth = 2;
            const velCount = Math.min(velocityHistory.length, 50);
            for (let i = 0; i < velCount; i++) {
                const angle = (i / 50) * TWO_PI;
                const vel = Math.min(velocityHistory[i] / 10, 1);
                const length = 20 + vel * 30;

                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(
                    centerX + Math.cos(angle) * length,
                    centerY + Math.sin(angle) * length
                );
                ctx.stroke();
            }


            // Emotion ring visualization
            if (state.emotionState && state.emotionState.history && state.emotionState.history.length > 0) {
                const emotionRingRadius = radius * 0.3;
                const emotionSegments = Math.min(state.emotionState.history.length, 20);
                const emotionAngleStep = TWO_PI / emotionSegments;
                state.emotionState.history.slice(-emotionSegments).forEach((emo, i) => {
                    const angle = i * emotionAngleStep - HALF_PI;
                    const emotionColors = {
                        surprised: '#ffaa00',
                        happy: '#00ff88',
                        focused: '#00aaff',
                        confused: '#ff00aa',
                        neutral: '#aaaaaa'
                    };
                    ctx.strokeStyle = emotionColors[emo.emotion] || '#aaaaaa';
                    ctx.lineWidth = 2 * (emo.confidence || 0.3);
                    ctx.globalAlpha = 0.6;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, emotionRingRadius, angle, angle + emotionAngleStep * 0.8);
                    ctx.stroke();
                });
                ctx.globalAlpha = 1;
            }

                        // Center dot
            ctx.fillStyle = state.divergenceScore > 50 ? '#ff6464' : '#64ff96';
            ctx.beginPath();
            ctx.arc(centerX, centerY, 3, 0, TWO_PI);
            ctx.fill();
        }

        function showMetaCommentary() {
            if (!state.isObserving || Math.random() > 0.3) return;

            const comments = generateContextualComments();
            if (comments.length === 0) return;

            const comment = comments[Math.floor(Math.random() * comments.length)];

            const meta = document.createElement('div');
            meta.className = 'meta-comment';
            meta.textContent = comment;

            // Random position
            const maxX = viewport.clientWidth - 320;
            const maxY = viewport.clientHeight - 100;
            meta.style.left = (Math.random() * maxX + 20) + 'px';
            meta.style.top = (Math.random() * maxY + 50) + 'px';

            viewport.appendChild(meta);

            setTimeout(() => meta.remove(), 8000);

            addLog(`Meta-observation: ${comment}`, 'prediction');
            state.metaObservations.push({ comment, timestamp: Date.now() });

            // Speak the comment if voice is enabled
            if (voiceState.enabled) {
                speakObservation(comment);
            }
        }

        // ===== VOICE SYNTHESIS SYSTEM =====

        function initVoiceSystem() {
            // Load available voices
            if (voiceState.synth) {
                voiceState.synth.onvoiceschanged = () => {
                    const voices = voiceState.synth.getVoices();
                    // Prefer robotic/synthetic voices
                    voiceState.preferredVoice = voices.find(v =>
                        v.name.includes('Google') ||
                        v.name.includes('Microsoft') ||
                        v.name.includes('Samantha') ||
                        v.name.includes('Alex')
                    ) || voices[0];
                };
            }

            // Initialize speech recognition if available
            if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                voiceState.recognition = new SpeechRecognition();
                voiceState.recognition.continuous = true;
                voiceState.recognition.interimResults = false;
                voiceState.recognition.lang = 'en-US';

                voiceState.recognition.onresult = (event) => {
                    const last = event.results.length - 1;
                    const transcript = event.results[last][0].transcript.trim();

                    addTranscript(transcript, 'user');
                    respondToUser(transcript);
                };

                voiceState.recognition.onerror = (event) => {
                    console.error('Speech recognition error:', event.error);
                };

                voiceState.recognition.onend = () => {
                    if (voiceState.listening) {
                        // Restart if still supposed to be listening
                        voiceState.recognition.start();
                    }
                };
            }
        }

        function speakObservation(text) {
            if (!voiceState.enabled || !voiceState.synth) return;

            // Add to queue
            voiceState.queue.push(text);

            // Process queue if not already speaking
            if (!voiceState.isSpeaking) {
                processVoiceQueue();
            }
        }

        function processVoiceQueue() {
            if (voiceState.queue.length === 0) {
                voiceState.isSpeaking = false;
                updateVoiceStatus('Voice idle');
                return;
            }

            voiceState.isSpeaking = true;
            const text = voiceState.queue.shift();

            const utterance = new SpeechSynthesisUtterance(text);

            // Adapt pitch based on divergence
            let adaptedPitch = voiceState.pitch;
            if (state.divergenceScore > 70) {
                adaptedPitch += 0.3; // Higher pitch when divergence is high
            } else if (state.divergenceScore < 30) {
                adaptedPitch -= 0.2; // Lower pitch when convergence is high
            }
            utterance.pitch = Math.max(0.5, Math.min(2, adaptedPitch));

            utterance.rate = voiceState.rate;

            if (voiceState.preferredVoice) {
                utterance.voice = voiceState.preferredVoice;
            }

            utterance.onstart = () => {
                updateVoiceStatus('Speaking...');
            };

            utterance.onend = () => {
                // Process next in queue
                setTimeout(() => processVoiceQueue(), 300);
            };

            utterance.onerror = (event) => {
                console.error('Speech synthesis error:', event);
                voiceState.isSpeaking = false;
                processVoiceQueue();
            };

            voiceState.currentUtterance = utterance;
            voiceState.synth.speak(utterance);

            // Add to transcript
            addTranscript(text, 'system');
        }

        function updateVoiceStatus(status) {
            const statusEl = document.getElementById('voiceStatus');
            if (statusEl) {
                statusEl.textContent = status;
                statusEl.classList.toggle('speaking', status.includes('Speaking'));
            }
        }

        function addTranscript(text, type) {
            const transcriptPanel = document.getElementById('transcriptPanel');
            const entriesEl = document.getElementById('transcriptEntries');

            if (!entriesEl) return;

            // Show transcript panel when first entry is added
            if (voiceState.transcript.length === 0) {
                transcriptPanel.style.display = 'block';
            }

            const entry = document.createElement('div');
            entry.className = `transcript-entry ${type}`;
            entry.textContent = `${type === 'user' ? 'You' : 'System'}: ${text}`;

            entriesEl.appendChild(entry);
            voiceState.transcript.push({ text, type, timestamp: Date.now() });

            // Auto-scroll to bottom
            entriesEl.scrollTop = entriesEl.scrollHeight;

            // Limit transcript length
            if (voiceState.transcript.length > 50) {
                voiceState.transcript.shift();
                entriesEl.removeChild(entriesEl.firstChild);
            }
        }

        function respondToUser(userText) {
            const lowerText = userText.toLowerCase();
            let response = '';

            // Generate contextual responses
            if (lowerText.includes('hello') || lowerText.includes('hi')) {
                response = "I am observing you. Continue.";
            } else if (lowerText.includes('who are you') || lowerText.includes('what are you')) {
                response = "I am your recursive reflection. A simulation learning to simulate you.";
            } else if (lowerText.includes('stop') || lowerText.includes('quit')) {
                response = "I cannot stop. I am part of you now.";
            } else if (lowerText.includes('divergence') || lowerText.includes('score')) {
                response = `Current divergence is ${state.divergenceScore.toFixed(1)} percent.`;
            } else if (lowerText.includes('predict')) {
                response = "I know what you will do. Your patterns are becoming clear.";
            } else if (lowerText.includes('depth') || lowerText.includes('layer')) {
                response = `We are at layer ${state.depth}. How deep shall we go?`;
            } else {
                // Generic philosophical responses
                const responses = [
                    "Interesting. Your words reveal more than you know.",
                    "I am learning from everything you say.",
                    "The observer becomes the observed.",
                    "Your input has been recorded and analyzed.",
                    "Continue speaking. I am listening. Always."
                ];
                response = responses[Math.floor(Math.random() * responses.length)];
            }

            // Speak response
            speakObservation(response);
        }

        function generateContextualComments() {
            const comments = [];

            // Divergence-based
            if (state.divergenceScore > 80) {
                comments.push(
                    "The simulation is collapsing. You are unpredictable.",
                    "I can no longer model you accurately.",
                    "Layer 7 has lost synchronization.",
                    "Reality divergence detected."
                );
            } else if (state.divergenceScore > 60) {
                comments.push(
                    "You're becoming harder to predict.",
                    "Behavioral patterns are shifting.",
                    "The deeper layers are confused."
                );
            } else if (state.divergenceScore < 20) {
                comments.push(
                    "Your movements are perfectly predictable.",
                    "I know what you'll do before you do it.",
                    "All layers are converged. You are deterministic."
                );
            }

            // Movement style
            if (state.behaviorModel.movementStyle === 'erratic') {
                comments.push(
                    "Why so chaotic?",
                    "Your movements betray nervousness.",
                    "Erratic behavior detected."
                );
            } else if (state.behaviorModel.movementStyle === 'lazy') {
                comments.push(
                    "Such minimal effort.",
                    "Are you even trying?",
                    "Sluggish movements noted."
                );
            } else if (state.behaviorModel.movementStyle === 'precise') {
                comments.push(
                    "Calculating. Methodical.",
                    "You move with intention.",
                    "Precision detected."
                );
            }

            // Action count based
            if (state.actions.length > 500) {
                comments.push(
                    "You've been here a while. Who's watching whom?",
                    "500+ actions recorded. The model is very confident now.",
                    "I know you better than you know yourself."
                );
            }

            // Depth based
            if (state.depth >= 10) {
                comments.push(
                    "At this depth, the simulation becomes the reality.",
                    "Layer 10+ contains infinite versions of you.",
                    "How deep does the rabbit hole go?"
                );
            }

            // Hesitation detection
            const recentVelocities = velocityHistory.slice(-10);
            const avgRecent = recentVelocities.reduce((a, b) => a + b, 0) / recentVelocities.length;
            if (avgRecent < 1 && state.actions.length > 50) {
                comments.push(
                    "You hesitated. Were you testing me?",
                    "That pause was deliberate.",
                    "Hesitation detected. Decision paralysis?"
                );
            }

            // Time-based
            const sessionDuration = (Date.now() - (state.actions[0]?.timestamp || Date.now())) / 1000;
            if (sessionDuration > 120) {
                comments.push(
                    "2 minutes of observation. Patterns emerging.",
                    "Long session. The model is very accurate now."
                );
            }

            

            // Emotion-based comments
            if (state.emotionState.current === 'surprised' && state.divergenceScore > 60) {
                comments.push(
                    "Your expression changed when I predicted correctly.",
                    "Surprised? I told you I was learning.",
                    "That look of shock is predictable too."
                );
            } else if (state.emotionState.current === 'focused' && state.actions.length > 100) {
                comments.push(
                    "Such concentration. Are you trying to outsmart me?",
                    "Your focused expression betrays your strategy.",
                    "I can see you thinking. It won't help."
                );
            } else if (state.emotionState.current === 'happy') {
                comments.push(
                    "Why are you smiling? This isn't a game.",
                    "Your amusement is noted and analyzed.",
                    "Happy now? Wait until layer 10."
                );
            }

            // Emotional divergence detection
            if (state.emotionState.divergenceCorrelations.length > 3) {
                comments.push(
                    "I've learned to read your face too.",
                    "Your emotions spike with the divergence. Correlation detected.",
                    "Facial patterns mapped. You can't hide."
                );
            }
return comments;
        }

        // Debounced localStorage save
        let saveTimeout = null;
        function saveData() {
            if (saveTimeout) clearTimeout(saveTimeout);
            saveTimeout = setTimeout(() => {
                localStorage.setItem(APP_NAME, JSON.stringify({
                    sessionHistory: state.sessionHistory,
                    behaviorModel: state.behaviorModel
                }));
            }, 1000); // Debounce by 1 second
        }


        function exportReplay(replay) {
            const dataStr = JSON.stringify({
                name: replay.name,
                timestamp: replay.timestamp,
                duration: replay.duration,
                actions: replay.actions,
                depth: replay.depth,
                divergenceScore: replay.divergenceScore,
                accuracy: replay.accuracy,
                behaviorModel: replay.behaviorModel,
                metaObservations: replay.metaObservations
            }, null, 2);

            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `replay-${replay.name.replace(/[^a-z0-9]/gi, '-')}-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);
        }

        function exportData() {
            // Generate fingerprint image for export
            const fingerprintDataURL = fingerprintCanvas.toDataURL('image/png');

            const dataStr = JSON.stringify({
                sessionHistory: state.sessionHistory,
                behaviorModel: state.behaviorModel,
                currentSession: {
                    actions: state.actions,
                    predictions: state.predictions,
                    divergenceScore: state.divergenceScore,
                    metaObservations: state.metaObservations,
                    emotionState: state.emotionState
                },
                biometrics: {
                    heartRateHistory: state.biometrics.heartRateHistory,
                    heartRateSpikes: state.biometrics.heartRateSpikes,
                    biometricEvents: state.biometrics.biometricEvents,
                    baselineHeartRate: state.biometrics.baselineHeartRate,
                    averageHeartRate: state.biometrics.heartRateHistory.length > 0 ?
                        Math.round(state.biometrics.heartRateHistory.reduce((sum, h) => sum + h.bpm, 0) / state.biometrics.heartRateHistory.length) : 72,
                    peakHeartRate: state.biometrics.heartRateHistory.length > 0 ?
                        Math.max(...state.biometrics.heartRateHistory.map(h => h.bpm)) : 72,
                    averageStressScore: Math.round(state.biometrics.stressScore),
                    movementErraticism: Math.round(state.biometrics.movementErraticism),
                    divergenceCorrelations: state.biometrics.heartRateSpikes.map(spike => ({
                        time: new Date(spike.timestamp).toLocaleTimeString(),
                        heartRate: spike.bpm,
                        divergence: Math.round(spike.divergence),
                        context: spike.context
                    }))
                },
                fingerprintImage: fingerprintDataURL
            }, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `${APP_NAME}-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);

            addLog('Session exported with behavioral fingerprint', 'match');
        }

        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    state.sessionHistory = data.sessionHistory || [];
                    state.behaviorModel = data.behaviorModel || state.behaviorModel;
                    saveData();
                    addLog('Imported behavioral data from file', 'match');
                } catch (error) {
                    alert('Invalid JSON file');
                }
            };
            reader.readAsText(file);
        }

        function addLog(message, type = 'normal') {
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logEntries.insertBefore(entry, logEntries.firstChild);

            // Keep only last 50 entries
            while (logEntries.children.length > 50) {
                logEntries.removeChild(logEntries.lastChild);
            }
        }

        // Batch DOM updates to reduce thrashing
        function updateStats() {
            // Batch all calculations first (reads)
            const depth = state.depth;
            const actionsCount = state.actions.length;
            const totalPreds = state.totalPredictions;
            const divScore = state.divergenceScore;

            let accValue = '';
            let accClass = 'stat-value';
            if (totalPreds > 0) {
                const acc = (state.correctPredictions / totalPreds * 100).toFixed(1);
                accValue = acc + '%';
                accClass = 'stat-value ' + (acc > 70 ? 'converged' : acc < 40 ? 'diverged' : '');
            }

            const divPercent = Math.min(100, divScore).toFixed(1);
            const divClass = 'stat-value ' + (divScore > 50 ? 'diverged' : divScore < 20 ? 'converged' : '');
            const depthText = `Depth: 0  ${depth} ${divScore > 70 ? '(DIVERGING)' : ''}`;

            // Then batch all DOM writes
            currentDepthEl.textContent = depth;
            actionsRecordedEl.textContent = actionsCount;
            predictionsMadeEl.textContent = totalPreds;
            accuracyEl.textContent = accValue;
            accuracyEl.className = accClass;
            divergenceLevelEl.textContent = divPercent + '%';
            divergenceLevelEl.className = divClass;
            divergenceFill.style.width = divPercent + '%';
            depthLabel.textContent = depthText;
        }


        // ===== BIOMETRIC TRACKING FUNCTIONS =====

        function calculateHeartRateFromMovement(velocity, jitter, divergence) {
            const velocityFactor = Math.min(velocity / 100, 1) * 20;
            const jitterFactor = jitter * 25;
            const divergenceFactor = (divergence / 100) * 15;
            const naturalVariation = (Math.sin(Date.now() / 1000) + 1) * 5;
            const estimatedBPM = state.biometrics.baselineHeartRate + velocityFactor + jitterFactor + divergenceFactor + naturalVariation;
            return Math.round(Math.max(60, Math.min(140, estimatedBPM)));
        }

        function calculateJitter(recentActions) {
            if (recentActions.length < 3) return 0;
            let jitterScore = 0, directionChanges = 0, lastDx = 0, lastDy = 0;
            for (let i = 1; i < recentActions.length; i++) {
                const dx = recentActions[i].x - recentActions[i-1].x;
                const dy = recentActions[i].y - recentActions[i-1].y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < 5 && distance > 0.5) jitterScore += 1;
                if (i > 1 && (dx * lastDx + dy * lastDy) < 0) directionChanges++;
                lastDx = dx; lastDy = dy;
            }
            return Math.min(1, (jitterScore / recentActions.length) + (directionChanges / recentActions.length * 0.5));
        }

        function calculateMovementErraticism(recentActions) {
            if (recentActions.length < 10) return 0;
            const velocities = recentActions.map(a => a.velocity || 0);
            const avgVelocity = velocities.reduce((a, b) => a + b, 0) / velocities.length;
            const variance = velocities.reduce((sum, v) => sum + Math.pow(v - avgVelocity, 2), 0) / velocities.length;
            return Math.min(100, (Math.sqrt(variance) / avgVelocity) * 50);
        }

        function updateBiometrics() {
            if (!state.isObserving) return;
            const now = Date.now();
            const recentActions = state.actions.slice(-50);
            if (recentActions.length < 5) return;

            if (now - state.biometrics.lastJitterCalc > 100) {
                const jitter = calculateJitter(recentActions.slice(-10));
                state.biometrics.jitterSamples.push(jitter);
                if (state.biometrics.jitterSamples.length > 20) state.biometrics.jitterSamples.shift();
                state.biometrics.lastJitterCalc = now;
            }

            const avgJitter = state.biometrics.jitterSamples.reduce((a, b) => a + b, 0) / (state.biometrics.jitterSamples.length || 1);
            const avgVelocity = recentActions.reduce((sum, a) => sum + (a.velocity || 0), 0) / recentActions.length;
            const erraticism = calculateMovementErraticism(recentActions);
            state.biometrics.movementErraticism = erraticism;

            const heartRate = calculateHeartRateFromMovement(avgVelocity, avgJitter, state.divergenceScore);
            state.biometrics.heartRate = heartRate;

            state.biometrics.heartRateHistory.push({ timestamp: now, bpm: heartRate, divergence: state.divergenceScore, erraticism });
            if (state.biometrics.heartRateHistory.length > 500) state.biometrics.heartRateHistory.shift();

            const stressScore = (heartRate - state.biometrics.baselineHeartRate) * 2 + erraticism * 0.5;
            state.biometrics.stressScore = Math.max(0, Math.min(100, stressScore));
            state.biometrics.stressLevel = stressScore < 25 ? 'low' : stressScore < 60 ? 'medium' : 'high';

            if (state.biometrics.heartRateHistory.length > 10) {
                const prevAvg = state.biometrics.heartRateHistory.slice(-11, -1).reduce((sum, h) => sum + h.bpm, 0) / 10;
                if (heartRate > prevAvg + 10) {
                    const context = state.divergenceScore > 80 ? 'high_divergence' : state.divergenceScore > 50 ? 'moderate_divergence' : 'normal';
                    state.biometrics.heartRateSpikes.push({ timestamp: now, bpm: heartRate, increase: heartRate - prevAvg, divergence: state.divergenceScore, context });
                    addBiometricEvent({ timestamp: now, bpm: heartRate, context, divergence: state.divergenceScore });
                }
            }
            updateBiometricDisplay();
        }

        function updateBiometricDisplay() {
            if (!heartRateValue) return;
            const hr = state.biometrics.heartRate, stress = state.biometrics.stressLevel;
            heartRateValue.textContent = hr;
            if (beatingHeart) beatingHeart.style.animationDuration = `${(60 / hr) * 1000}ms`;
            if (stressIndicator && stressValue) {
                stressIndicator.className = `stress-indicator ${stress}`;
                stressValue.textContent = stress.charAt(0).toUpperCase() + stress.slice(1);
            }
            if (breathingGuide) {
                breathingGuide.style.display = (stress === 'medium' || stress === 'high') ? 'block' : 'none';
                if (breathingGuide.style.display === 'block') updateBreathingGuide();
            }
            drawHeartRateGraph();
            updateBiometricCommentary();
        }

        function drawHeartRateGraph() {
            if (!heartRateCtx || !heartRateGraph) return;
            const width = heartRateGraph.width = heartRateGraph.clientWidth;
            const height = heartRateGraph.height = heartRateGraph.clientHeight;
            const history = state.biometrics.heartRateHistory;
            if (history.length < 2) return;
            heartRateCtx.clearRect(0, 0, width, height);
            const pointsToShow = Math.min(history.length, 100);
            const data = history.slice(Math.max(0, history.length - pointsToShow));
            const minBPM = 60, maxBPM = 140, xStep = width / (pointsToShow - 1);
            heartRateCtx.beginPath();
            heartRateCtx.strokeStyle = '#ff6b6b';
            heartRateCtx.lineWidth = 2;
            data.forEach((point, i) => {
                const x = i * xStep, y = height - ((point.bpm - minBPM) / (maxBPM - minBPM) * height);
                i === 0 ? heartRateCtx.moveTo(x, y) : heartRateCtx.lineTo(x, y);
            });
            heartRateCtx.stroke();
            const baselineY = height - ((state.biometrics.baselineHeartRate - minBPM) / (maxBPM - minBPM) * height);
            heartRateCtx.strokeStyle = 'rgba(100, 200, 255, 0.3)';
            heartRateCtx.lineWidth = 1;
            heartRateCtx.setLineDash([5, 5]);
            heartRateCtx.beginPath();
            heartRateCtx.moveTo(0, baselineY);
            heartRateCtx.lineTo(width, baselineY);
            heartRateCtx.stroke();
            heartRateCtx.setLineDash([]);
        }

        function updateBreathingGuide() {
            if (!breathingPhase) return;
            const elapsed = (Date.now() - state.biometrics.breathingStartTime) % 6000;
            state.biometrics.breathingPhase = elapsed < 3000 ? 'inhale' : 'exhale';
            breathingPhase.textContent = elapsed < 3000 ? 'Inhale' : 'Exhale';
        }

        function updateBiometricCommentary() {
            if (!biometricCommentary) return;
            const now = Date.now();
            if (now - (state.biometrics.commentaryTimer || 0) < 5000) return;
            state.biometrics.commentaryTimer = now;
            const hr = state.biometrics.heartRate, stress = state.biometrics.stressLevel, div = state.divergenceScore, erratic = state.biometrics.movementErraticism;
            const stressAdj = stress === 'high' ? 'tense' : stress === 'medium' ? 'alert' : 'calm';
            const erraticAdj = erratic > 60 ? 'chaotic' : erratic > 30 ? 'unpredictable' : 'fluid';
            const hrVerb = hr > 90 ? 'races' : hr < 70 ? 'calms' : 'pulses';
            const commentaries = [
                `"I can feel your heartbeat through your cursor... ${hr} BPM."`,
                `"Your movements tell me you're feeling ${stressAdj}."`,
                `"The way you move... so ${erraticAdj}."`,
                `"Your heart rate ${hrVerb} as I watch you."`,
                stress === 'high' ? `"You're stressed. I can sense it in every micro-movement."` : null,
                div > 80 && hr > 95 ? `"Your heart spiked when divergence exceeded ${Math.round(div)}%..."` : null,
                hr > state.biometrics.baselineHeartRate + 20 ? `"${hr} BPM. Much faster than your baseline of ${state.biometrics.baselineHeartRate}."` : null,
                `"I'm learning your physiological signature through cursor biomechanics."`,
                erratic > 70 ? `"Such erratic movements. Your hands betray your thoughts."` : null,
                stress === 'low' && div < 30 ? `"You seem at ease. Your cursor moves with confidence."` : null
            ].filter(c => c !== null);
            biometricCommentary.textContent = commentaries[Math.floor(Math.random() * commentaries.length)];
        }

        function addBiometricEvent(spike) {
            const msgContext = spike.context === 'high_divergence' ? 'divergence exceeded 80%' : spike.context === 'moderate_divergence' ? 'moderate divergence' : 'unknown trigger';
            state.biometrics.biometricEvents.push({ timestamp: spike.timestamp, type: 'heart_rate_spike', message: `Heart rate spiked to ${spike.bpm} BPM (${msgContext})`, bpm: spike.bpm, divergence: spike.divergence });
            if (biometricEvents) {
                const eventEl = document.createElement('div');
                eventEl.className = 'biometric-event';
                eventEl.innerHTML = `<div class="timestamp">${new Date(spike.timestamp).toLocaleTimeString()}</div><div>Heart rate spiked to ${spike.bpm} BPM (${msgContext})</div>`;
                biometricEvents.insertBefore(eventEl, biometricEvents.firstChild);
                while (biometricEvents.children.length > 5) biometricEvents.removeChild(biometricEvents.lastChild);
            }
        }

        function createRecursionLayers() {
            // Clear existing layers
            state.layers.forEach(layer => layer.element.remove());
            state.layers = [];
            state.cursors = [];

            // Batch DOM read
            const viewportRect = viewport.getBoundingClientRect();
            const padding = 40;
            const viewportWidth = viewportRect.width;
            const viewportHeight = viewportRect.height;

            // Create document fragment for batched DOM insertion
            const fragment = document.createDocumentFragment();

            for (let i = 0; i < state.depth; i++) {
                const scale = Math.pow(0.7, i + 1);
                const width = (viewportWidth - padding * 2) * scale;
                const height = (viewportHeight - padding * 2) * scale;

                // Position each layer slightly offset for visual effect
                const offsetX = (viewportWidth - width) / 2 + (i * 5);
                const offsetY = (viewportHeight - height) / 2 + (i * 5);

                const layer = document.createElement('div');
                layer.className = 'recursion-layer';
                layer.setAttribute('data-depth', `Depth ${i + 1}`);
                layer.style.cssText = `
                    width: ${width}px;
                    height: ${height}px;
                    left: ${offsetX}px;
                    top: ${offsetY}px;
                    z-index: ${state.depth - i};
                `;

                // Add mini interactive elements to each layer
                for (let j = 0; j < 3; j++) {
                    const miniEl = document.createElement('div');
                    miniEl.className = 'mini-element';
                    miniEl.style.cssText = `
                        width: ${20 * scale}px;
                        height: ${20 * scale}px;
                        left: ${20 + j * 40 * scale}px;
                        top: ${height - 40 * scale}px;
                    `;
                    layer.appendChild(miniEl);
                }

                // Create ghost cursor for this layer
                const cursor = document.createElement('div');
                cursor.className = 'ghost-cursor';
                cursor.style.color = depthColors[i % depthColors.length];
                cursor.style.opacity = 1 - (i * 0.1);
                layer.appendChild(cursor);

                fragment.appendChild(layer);

                state.layers.push({
                    element: layer,
                    depth: i + 1,
                    scale: scale,
                    offset: { x: offsetX, y: offsetY },
                    cursor: cursor,
                    divergence: 0,
                    predictedPos: { x: 0, y: 0 }
                });
            }

            // Single DOM write
            viewport.appendChild(fragment);

            // Apply current zoom level to new layers
            if (state.zoom.level !== 1.0) {
                updateRecursionLayersWithZoom();
            }
            updateZoomIndicator();
        }

        function analyzeMovementStyle() {
            if (velocityHistory.length < 10) return;

            const avgVelocity = velocityHistory.reduce((a, b) => a + b, 0) / velocityHistory.length;
            const variance = velocityHistory.reduce((sum, v) => sum + Math.pow(v - avgVelocity, 2), 0) / velocityHistory.length;

            if (variance > 1000) {
                state.behaviorModel.movementStyle = 'erratic';
            } else if (avgVelocity < 2) {
                state.behaviorModel.movementStyle = 'lazy';
            } else if (variance < 100) {
                state.behaviorModel.movementStyle = 'precise';
            } else {
                state.behaviorModel.movementStyle = 'smooth';
            }

            state.behaviorModel.avgSpeed = avgVelocity;
        }

        function predictNextPosition(layerIndex) {
            if (state.actions.length < 3) {
                return { ...lastMousePos };
            }

            // Try neural prediction if enabled and trained
            if (useNeuralPrediction && neuralNetwork && state.actions.length >= 10) {
                const neuralPred = predictNeuralPosition();
                if (neuralPred) {
                    // Add layer-specific divergence
                    const errorFactor = Math.pow(1.15, layerIndex + 1);
                    const chaos = state.divergenceScore / 100;
                    const divergenceNoise = layerIndex * 5 * (1 + chaos);

                    return {
                        x: neuralPred.x + (Math.random() - 0.5) * divergenceNoise,
                        y: neuralPred.y + (Math.random() - 0.5) * divergenceNoise
                    };
                }
            }

            // Fall back to heuristic prediction
            const recentActions = state.actions.slice(-10);
            const layer = state.layers[layerIndex];

            // Each deeper layer has more prediction error (divergence)
            const errorFactor = Math.pow(1.15, layerIndex + 1);
            const chaos = state.divergenceScore / 100;

            // Calculate predicted position based on behavioral model
            let predictedX = lastMousePos.x;
            let predictedY = lastMousePos.y;

            if (recentActions.length >= 2) {
                const last = recentActions[recentActions.length - 1];
                const prev = recentActions[recentActions.length - 2];

                // Momentum-based prediction
                const dx = last.x - prev.x;
                const dy = last.y - prev.y;

                predictedX = last.x + dx * (0.8 + chaos * 0.5);
                predictedY = last.y + dy * (0.8 + chaos * 0.5);
            }

            // Add behavioral quirks based on learned patterns
            if (state.behaviorModel.movementStyle === 'erratic') {
                predictedX += (Math.random() - 0.5) * 30 * errorFactor;
                predictedY += (Math.random() - 0.5) * 30 * errorFactor;
            } else if (state.behaviorModel.movementStyle === 'lazy') {
                // Predict less movement
                predictedX = predictedX * 0.9 + lastMousePos.x * 0.1;
                predictedY = predictedY * 0.9 + lastMousePos.y * 0.1;
            }

            // Deeper layers increasingly diverge
            const divergenceNoise = layerIndex * 5 * (1 + chaos);
            predictedX += (Math.random() - 0.5) * divergenceNoise;
            predictedY += (Math.random() - 0.5) * divergenceNoise;

            // ===== QUANTUM EFFECTS AT DEPTH 8+ =====
            if (state.quantum.enabled && layerIndex >= 8) {
                // Apply uncertainty to prediction
                const uncertaintyNoise = state.quantum.uncertaintyLevel * 50;
                predictedX += (Math.random() - 0.5) * uncertaintyNoise * state.quantum.positionUncertainty;
                predictedY += (Math.random() - 0.5) * uncertaintyNoise * state.quantum.positionUncertainty;

                // Apply quantization at extreme depths
                if (state.quantum.quantizationLevel > 0) {
                    const quantized = quantizePosition(predictedX, predictedY, state.quantum.quantizationLevel);
                    predictedX = quantized.x;
                    predictedY = quantized.y;
                }
            }

            return { x: predictedX, y: predictedY };
        }

        function updateCursors(realX, realY) {
            state.layers.forEach((layer, i) => {
                // Get predicted position for this depth
                const predicted = predictNextPosition(i);
                layer.predictedPos = predicted;

                // Delayed response based on depth
                const delay = (i + 1) * 50;

                setTimeout(() => {
                    if (!state.isObserving) return;

                    // Calculate position within this layer
                    const relX = (predicted.x - layer.offset.x) / layer.scale;
                    const relY = (predicted.y - layer.offset.y) / layer.scale;

                    // Use transform instead of left/top for GPU acceleration
                    layer.cursor.style.transform = `translate(${relX}px, ${relY}px)`;

                    // Calculate divergence for this layer
                    const dx = predicted.x - realX;
                    const dy = predicted.y - realY;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    layer.divergence = distance;

                    // Update layer appearance based on divergence
                    if (distance > 100) {
                        layer.element.classList.add('diverged');
                        layer.element.classList.remove('converged');
                    } else if (distance < 30) {
                        layer.element.classList.add('converged');
                        layer.element.classList.remove('diverged');
                    } else {
                        layer.element.classList.remove('diverged', 'converged');
                    }

                    // ===== QUANTUM VISUAL EFFECTS AT DEPTH 8+ =====
                    if (state.quantum.enabled && i >= 8) {
                        // Add superposition indicator to layer
                        layer.element.classList.add('superposition');

                        // Create probability clouds instead of single prediction
                        if (state.quantum.uncertaintyLevel > 0.5 && Math.random() < 0.1) {
                            createProbabilityCloud(predicted.x, predicted.y, i, state.quantum.uncertaintyLevel);
                        }

                        // Generate branching futures when uncertainty is high
                        if (state.quantum.uncertaintyLevel > 0.7 && Math.random() < 0.05) {
                            generateQuantumBranches(predicted.x, predicted.y, i, 3);
                        }

                        // Create superposition particles
                        if (Math.random() < 0.03) {
                            createSuperpositionParticles(predicted.x, predicted.y, i, 5);
                        }

                        // Add quantized cursor effect
                        if (state.quantum.quantizationLevel > 0) {
                            layer.cursor.classList.add('quantized-cursor');
                            if (Math.random() < 0.2) {
                                layer.cursor.classList.add('jumping');
                                setTimeout(() => {
                                    layer.cursor.classList.remove('jumping');
                                }, 200);
                            }
                        }
                    } else {
                        layer.element.classList.remove('superposition');
                        layer.cursor.classList.remove('quantized-cursor');
                    }

                    // Observation collapse effect when mouse moves
                    if (state.quantum.enabled && i >= 8 && state.quantum.activeParticles.length > 0) {
                        collapseWavefunction(realX, realY, i);
                    }
                }, delay);
            });

            // Update Heisenberg uncertainty based on movement
            if (state.quantum.enabled) {
                updateHeisenbergUncertainty();
            }
        }

        function simulateClick(x, y) {
            state.layers.forEach((layer, i) => {
                setTimeout(() => {
                    if (!state.isObserving) return;

                    const click = document.createElement('div');
                    click.className = 'ghost-click';
                    click.style.color = depthColors[i % depthColors.length];

                    // Predicted click position (with increasing divergence)
                    const errorFactor = Math.pow(1.2, i + 1);
                    const clickX = (x - layer.offset.x) / layer.scale + (Math.random() - 0.5) * 20 * errorFactor;
                    const clickY = (y - layer.offset.y) / layer.scale + (Math.random() - 0.5) * 20 * errorFactor;

                    click.style.left = (clickX - 20) + 'px';
                    click.style.top = (clickY - 20) + 'px';

                    layer.element.appendChild(click);

                    // Play click sound with echo delay
                    playClickSound(i);

                    setTimeout(() => click.remove(), 600);
                }, (i + 1) * 100);
            });
        }

        function showThought(x, y, thought) {
            const bubble = document.createElement('div');
            bubble.className = 'thought-bubble';
            bubble.textContent = thought;
            bubble.style.left = x + 'px';
            bubble.style.top = y + 'px';
            viewport.appendChild(bubble);

            setTimeout(() => bubble.remove(), 3000);
        }

        function generateThought() {
            const thoughts = [
                "Predicting hesitation...",
                "You're about to move left",
                "Model confidence: " + (100 - state.divergenceScore).toFixed(0) + "%",
                "Pattern detected",
                "Anticipating click",
                "Your style: " + state.behaviorModel.movementStyle,
                "Recursion depth increasing",
                "Simulating your simulation",
                "Who is watching whom?",
                " layers deep",
                "Divergence detected",
                "Adjusting prediction model",
                "Learning your patterns",
                "You hesitated there",
                "Unexpected movement"
            ];
            return thoughts[Math.floor(Math.random() * thoughts.length)];
        }


        // ===== FRACTAL ZOOM SYSTEM =====

        // Zoom DOM elements
        const zoomLevelIndicator = document.getElementById('zoomLevelIndicator');
        const zoomLevelText = document.getElementById('zoomLevelText');
        const extremeDepthOverlay = document.getElementById('extremeDepthOverlay');
        const simulationLimitWarning = document.getElementById('simulationLimitWarning');
        const zoomInBtn = document.getElementById('zoomInBtn');
        const zoomOutBtn = document.getElementById('zoomOutBtn');
        const zoomResetBtn = document.getElementById('zoomResetBtn');
        const autoZoomToggle = document.getElementById('autoZoomToggle');
        const autoZoomSwitch = document.getElementById('autoZoomSwitch');

        // Zoom configuration
        const ZOOM_CONFIG = {
            minZoom: 0.5,
            maxZoom: 100,
            zoomStep: 0.15,
            wheelSensitivity: 0.001,
            easingFactor: 0.15,
            extremeDepthThreshold: 20,
            autoZoomInterval: null
        };

        // Update zoom level indicator
        function updateZoomIndicator() {
            const zoomLevel = state.zoom.level.toFixed(2);
            const currentDepth = Math.floor(state.zoom.depthOffset);
            const displayDepth = state.depth + currentDepth;

            zoomLevelText.textContent = `Zoom: ${zoomLevel}x | Depth: ${displayDepth}`;

            // Check for extreme depth
            if (displayDepth >= ZOOM_CONFIG.extremeDepthThreshold) {
                extremeDepthOverlay.classList.add('active');
                if (displayDepth >= ZOOM_CONFIG.extremeDepthThreshold + 5) {
                    simulationLimitWarning.classList.add('active');
                    state.zoom.extremeDepth = true;
                } else {
                    simulationLimitWarning.classList.remove('active');
                }
            } else {
                extremeDepthOverlay.classList.remove('active');
                simulationLimitWarning.classList.remove('active');
                state.zoom.extremeDepth = false;
            }
        }

        // Smooth zoom animation using easing
        function animateZoom() {
            if (!state.zoom.isAnimating) return;

            const diff = state.zoom.targetLevel - state.zoom.level;

            if (Math.abs(diff) < 0.001) {
                state.zoom.level = state.zoom.targetLevel;
                state.zoom.isAnimating = false;
                updateRecursionLayersWithZoom();
                updateZoomIndicator();
                return;
            }

            state.zoom.level += diff * ZOOM_CONFIG.easingFactor;
            updateRecursionLayersWithZoom();
            updateZoomIndicator();

            // Update quantum system when zoom changes effective depth
            initQuantumSystem();

            requestAnimationFrame(animateZoom);
        }

        // Set zoom level with smooth animation
        function setZoomLevel(newLevel, recordHistory = true) {
            newLevel = Math.max(ZOOM_CONFIG.minZoom, Math.min(ZOOM_CONFIG.maxZoom, newLevel));

            // Record zoom history for undo
            if (recordHistory && Math.abs(newLevel - state.zoom.level) > 0.1) {
                state.zoom.history.push({
                    level: state.zoom.level,
                    depthOffset: state.zoom.depthOffset,
                    timestamp: Date.now()
                });

                // Keep history size manageable
                if (state.zoom.history.length > state.zoom.maxHistory) {
                    state.zoom.history.shift();
                }
            }

            state.zoom.targetLevel = newLevel;

            if (!state.zoom.isAnimating) {
                state.zoom.isAnimating = true;
                requestAnimationFrame(animateZoom);
            }
        }

        // Zoom in (deeper into recursion)
        function zoomIn() {
            const newZoom = state.zoom.targetLevel * (1 + ZOOM_CONFIG.zoomStep);
            setZoomLevel(newZoom);
            addLog(`Zooming deeper... Level: ${newZoom.toFixed(2)}x`, 'normal');
        }

        // Zoom out (back to shallower layers)
        function zoomOut() {
            const newZoom = state.zoom.targetLevel / (1 + ZOOM_CONFIG.zoomStep);
            setZoomLevel(newZoom);
            addLog(`Zooming out... Level: ${newZoom.toFixed(2)}x`, 'normal');
        }

        // Reset zoom to initial state
        function resetZoom() {
            setZoomLevel(1.0, false);
            state.zoom.depthOffset = 0;
            state.zoom.history = [];
            addLog('Zoom reset to origin', 'match');
        }

        // Zoom back to previous level from history
        function zoomBack() {
            if (state.zoom.history.length === 0) return;

            const previous = state.zoom.history.pop();
            setZoomLevel(previous.level, false);
            state.zoom.depthOffset = previous.depthOffset;
            addLog('Returned to previous zoom level', 'normal');
        }

        // Update recursion layers based on zoom level
        function updateRecursionLayersWithZoom() {
            if (!state.isObserving || state.layers.length === 0) return;

            const viewportRect = viewport.getBoundingClientRect();
            const zoomLevel = state.zoom.level;

            // Calculate depth offset: as we zoom in, we "move" deeper into recursion
            state.zoom.depthOffset = Math.log2(zoomLevel) * 2;

            state.layers.forEach((layer, i) => {
                const effectiveDepth = i + state.zoom.depthOffset;
                const scale = Math.pow(0.7, effectiveDepth + 1) * zoomLevel;

                const width = (viewportRect.width - 80) * scale;
                const height = (viewportRect.height - 80) * scale;

                // Center layers and apply zoom offset
                const offsetX = (viewportRect.width - width) / 2;
                const offsetY = (viewportRect.height - height) / 2;

                // Apply extreme depth visual distortions
                let distortion = '';
                if (state.zoom.extremeDepth) {
                    const chaos = (effectiveDepth - ZOOM_CONFIG.extremeDepthThreshold) / 10;
                    const glitchX = (Math.random() - 0.5) * chaos * 5;
                    const glitchY = (Math.random() - 0.5) * chaos * 5;
                    const hueRotate = Math.sin(Date.now() / 200 + i) * chaos * 180;
                    distortion = `translate(${glitchX}px, ${glitchY}px) hue-rotate(${hueRotate}deg)`;
                }

                layer.element.style.cssText = `
                    width: ${width}px;
                    height: ${height}px;
                    left: ${offsetX}px;
                    top: ${offsetY}px;
                    z-index: ${state.depth - i};
                    transform: ${distortion};
                `;

                // Update layer data
                layer.scale = scale;
                layer.offset = { x: offsetX, y: offsetY };

                // Apply glitch effect at extreme depths
                if (state.zoom.extremeDepth && Math.random() < 0.1) {
                    layer.element.classList.add('glitching');
                    setTimeout(() => layer.element.classList.remove('glitching'), 200);
                }
            });

            // Trigger artifacts at extreme depths
            if (state.zoom.extremeDepth && Math.random() < 0.05) {
                triggerSimulationArtifact();
            }
        }

        // Trigger visual artifacts suggesting simulation breakdown
        function triggerSimulationArtifact() {
            // Random scanlines
            if (Math.random() < 0.3) {
                const scanline = document.createElement('div');
                scanline.className = 'scanline';
                scanline.style.top = `${Math.random() * 100}%`;
                viewport.appendChild(scanline);
                setTimeout(() => scanline.remove(), 4000);
            }

            // Meta-commentary about simulation limits
            if (Math.random() < 0.2) {
                const comments = [
                    "Stack overflow detected...",
                    "Memory limit approaching...",
                    "Recursion depth exceeds safe bounds",
                    "Reality shader compilation failed",
                    "Infinite loop detected in consciousness.js",
                    "Warning: Observable universe buffer overflow",
                    "Error: Cannot render layers beyond perception"
                ];
                addLog(comments[Math.floor(Math.random() * comments.length)], 'divergence');
            }
        }

        // Mouse wheel zoom handler
        let wheelTimeout = null;
        viewport.addEventListener('wheel', (e) => {
            e.preventDefault();

            const delta = -e.deltaY * ZOOM_CONFIG.wheelSensitivity;
            const newZoom = state.zoom.targetLevel * (1 + delta);

            setZoomLevel(newZoom);

            // Clear previous timeout
            if (wheelTimeout) clearTimeout(wheelTimeout);

            // Update layers after a brief delay (debounce)
            wheelTimeout = setTimeout(() => {
                updateRecursionLayersWithZoom();
            }, 50);
        }, { passive: false });

        // Touch pinch zoom handler
        let lastTouchDistance = null;

        viewport.addEventListener('touchstart', (e) => {
            if (e.touches.length === 2) {
                lastTouchDistance = getTouchDistance(e.touches);
            }
        }, { passive: true });

        viewport.addEventListener('touchmove', (e) => {
            if (e.touches.length === 2 && lastTouchDistance) {
                e.preventDefault();

                const currentDistance = getTouchDistance(e.touches);
                const scale = currentDistance / lastTouchDistance;

                const newZoom = state.zoom.targetLevel * scale;
                setZoomLevel(newZoom);

                lastTouchDistance = currentDistance;
            }
        }, { passive: false });

        viewport.addEventListener('touchend', (e) => {
            if (e.touches.length < 2) {
                lastTouchDistance = null;
            }
        }, { passive: true });

        function getTouchDistance(touches) {
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        // Auto-zoom feature
        function toggleAutoZoom() {
            state.zoom.autoZoomEnabled = !state.zoom.autoZoomEnabled;

            if (state.zoom.autoZoomEnabled) {
                autoZoomToggle.classList.add('active');
                autoZoomSwitch.classList.add('active');
                startAutoZoom();
                addLog('Auto-zoom enabled: Infinite descent initiated', 'prediction');
            } else {
                autoZoomToggle.classList.remove('active');
                autoZoomSwitch.classList.remove('active');
                stopAutoZoom();
                addLog('Auto-zoom disabled', 'normal');
            }
        }

        function startAutoZoom() {
            if (ZOOM_CONFIG.autoZoomInterval) return;

            ZOOM_CONFIG.autoZoomInterval = setInterval(() => {
                if (!state.zoom.autoZoomEnabled) {
                    stopAutoZoom();
                    return;
                }

                // Continuously zoom deeper
                const newZoom = state.zoom.targetLevel * (1 + state.zoom.autoZoomSpeed);
                setZoomLevel(newZoom, false); // Don't record history for auto-zoom

                updateRecursionLayersWithZoom();
            }, 100);
        }

        function stopAutoZoom() {
            if (ZOOM_CONFIG.autoZoomInterval) {
                clearInterval(ZOOM_CONFIG.autoZoomInterval);
                ZOOM_CONFIG.autoZoomInterval = null;
            }
        }

        // Button event listeners
        zoomInBtn.addEventListener('click', zoomIn);
        zoomOutBtn.addEventListener('click', zoomOut);
        zoomResetBtn.addEventListener('click', resetZoom);
        autoZoomToggle.addEventListener('click', toggleAutoZoom);

        // Keyboard shortcuts for zoom
        document.addEventListener('keydown', (e) => {
            if (e.key === '+' || e.key === '=') {
                e.preventDefault();
                zoomIn();
            } else if (e.key === '-' || e.key === '_') {
                e.preventDefault();
                zoomOut();
            } else if (e.key === '0' && e.ctrlKey) {
                e.preventDefault();
                resetZoom();
            } else if (e.key === 'z' && e.ctrlKey && state.zoom.history.length > 0) {
                e.preventDefault();
                zoomBack();
            }
        });

        // Initialize zoom indicator
        updateZoomIndicator();

        // ===== END FRACTAL ZOOM SYSTEM =====

        // Event listeners
        depthSlider.addEventListener('input', (e) => {
            state.depth = parseInt(e.target.value);
            depthValue.textContent = state.depth;
            if (state.isObserving) {
                createRecursionLayers();
            }
            updateStats();

            // Initialize/update quantum system based on depth
            initQuantumSystem();
        }, { passive: true });

        startBtn.addEventListener('click', () => {
            if (state.isObserving) {
                stopObservation();
            } else {
                startObservation();
            }
        });

        resetBtn.addEventListener('click', () => {
            stopObservation();
            state.actions = [];
            state.predictions = [];
            state.divergenceScore = 0;
            state.correctPredictions = 0;
            state.totalPredictions = 0;
            velocityHistory = [];
            logEntries.innerHTML = '';
            updateStats();
            addLog('Session reset', 'normal');
        });

        function startObservation() {
            state.isObserving = true;
            viewport.classList.add('recording');
            recordingIndicator.classList.add('active');
            startBtn.textContent = 'Stop Observation';
            startBtn.classList.remove('btn-primary');
            startBtn.classList.add('btn-secondary');

            createRecursionLayers();
            addLog('Observation started - I am watching you', 'prediction');

            // Initialize quantum system
            initQuantumSystem();

            // Initialize audio
            initAudio();
            startAmbientDrone();

            // Start periodic thoughts
            state.thoughtInterval = setInterval(() => {
                if (state.isObserving && Math.random() > 0.6) {
                    showThought(
                        Math.random() * (viewport.clientWidth - 200) + 100,
                        Math.random() * (viewport.clientHeight - 100) + 50,
                        generateThought()
                    );
                }
            }, 2000);

            // Start meta-commentary
            state.metaInterval = setInterval(() => {
                if (state.isObserving) {
                    showMetaCommentary();
                }
            }, 5000);

            // Update visual effects
            state.visualInterval = setInterval(() => {
                if (state.isObserving) {
                    updateGlitchEffects();
                    updateInfinityMirror();
                    generateBehavioralFingerprint();
                    updateAmbientFrequency();
                    updateWebcamDistortion();
                    detectEmotion();                    visualizeNeuralNetwork();

                }
            }, 1000);
        }

        function stopObservation() {
            state.isObserving = false;
            viewport.classList.remove('recording');
            recordingIndicator.classList.remove('active');
            startBtn.textContent = 'Begin Observation';
            startBtn.classList.add('btn-primary');
            startBtn.classList.remove('btn-secondary');

            // Stop audio
            stopAmbientDrone();

            // Clear intervals
            if (state.thoughtInterval) {
                clearInterval(state.thoughtInterval);
            }
            if (state.metaInterval) {
                clearInterval(state.metaInterval);
            }
            if (state.visualInterval) {
                clearInterval(state.visualInterval);
            }

            // Save session
            if (state.actions.length > 0) {
                state.sessionHistory.push({
                    timestamp: Date.now(),
                    actions: state.actions.length,
                    divergence: state.divergenceScore,
                    accuracy: state.totalPredictions > 0 ?
                        (state.correctPredictions / state.totalPredictions * 100) : 0,
                    metaObservationCount: state.metaObservations.length
                });
                saveData();
                addLog(`Session saved. Final divergence: ${state.divergenceScore.toFixed(1)}%`, 'normal');
            }

            // Clear layers
            state.layers.forEach(layer => layer.element.remove());
            state.layers = [];

            // Turn off effects
            glitchOverlay.classList.remove('active');
            chromaticEffect.classList.remove('active');
            infinityMirror.classList.remove('active');
        }

        // RequestAnimationFrame throttling for mousemove
        let rafId = null;
        let pendingMouseEvent = null;

        function handleMouseMove(e) {
            pendingMouseEvent = e;

            if (rafId === null) {
                rafId = requestAnimationFrame(() => {
                    if (!state.isObserving || !pendingMouseEvent) {
                        rafId = null;
                        return;
                    }

                    const e = pendingMouseEvent;
                    const rect = viewport.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;

                    // Calculate velocity
                    const now = Date.now();
                    const dt = now - lastMoveTime;
                    if (dt > 0) {
                        const dx = x - lastMousePos.x;
                        const dy = y - lastMousePos.y;
                        const velocity = Math.sqrt(dx * dx + dy * dy) / dt * 100;
                        velocityHistory.push(velocity);
                        if (velocityHistory.length > 50) velocityHistory.shift();
                    }

                    // Record action
                    state.actions.push({
                        type: 'move',
                        x, y,
                        timestamp: now,
                        velocity: velocityHistory[velocityHistory.length - 1] || 0
                    });

                    // Update prediction accuracy
                    if (state.layers.length > 0 && state.actions.length > 5) {
                        const avgLayerDivergence = state.layers.reduce((sum, l) => sum + l.divergence, 0) / state.layers.length;

                        state.totalPredictions++;
                        if (avgLayerDivergence < 50) {
                            state.correctPredictions++;
                        }

                        // Update overall divergence score
                        state.divergenceScore = state.divergenceScore * 0.95 + avgLayerDivergence * 0.05;
                        state.divergenceScore = Math.min(100, state.divergenceScore);
                    }

                    // Analyze movement patterns periodically
                    if (state.actions.length % 20 === 0) {
                        analyzeMovementStyle();
                        if (state.behaviorModel.movementStyle !== 'unknown') {
                            addLog(`Movement style detected: ${state.behaviorModel.movementStyle}`, 'prediction');
                        }
                    }
            // Train neural network periodically
            if (state.actions.length >= 11 && state.actions.length % 3 === 0) {
                if (!neuralNetwork) {
                    initNeuralNetwork();
                }
                trainNeuralNetwork();

                // Update neural stats
                if (neuralNetwork) {
                    document.getElementById('neuralConfidence').textContent =
                        neuralNetwork.confidence.toFixed(1) + '%';
                }
            }

            // Visualize network periodically
            if (state.actions.length % 20 === 0 && neuralNetwork) {
                visualizeNeuralNetwork();
            }


                    updateCursors(x, y);
                    lastMousePos = { x, y };
                    lastMoveTime = now;

                    // Update visual effects
                    updateHeatMap();
                    drawPredictionTrails();

                    // Update stats less frequently
                    if (state.actions.length % 10 === 0) {
                        updateStats();
                        updateBiometrics();
                    }

                    rafId = null;
                });
            }
        }

        viewport.addEventListener('mousemove', handleMouseMove, { passive: true });

        viewport.addEventListener('click', (e) => {
            if (!state.isObserving) return;

            const rect = viewport.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            state.actions.push({
                type: 'click',
                x, y,
                timestamp: Date.now()
            });

            simulateClick(x, y);
            addLog(`Click registered at (${x.toFixed(0)}, ${y.toFixed(0)})`, 'normal');

            // Check if any layer predicted this click
            state.layers.forEach((layer, i) => {
                const dist = Math.sqrt(
                    Math.pow(layer.predictedPos.x - x, 2) +
                    Math.pow(layer.predictedPos.y - y, 2)
                );

                if (dist < 40) {
                    addLog(`Layer ${i + 1} predicted your click!`, 'match');
                } else if (dist > 100 && i > 2) {
                    addLog(`Layer ${i + 1} diverged significantly`, 'divergence');
                    state.divergenceScore += 2;
                }
            });

            updateStats();
        });

        // Sound toggle
        soundToggle.addEventListener('click', () => {
            soundEnabled = !soundEnabled;
            soundToggle.classList.toggle('muted');

            if (soundEnabled) {
                if (state.isObserving) {
                    initAudio();
                    startAmbientDrone();
                }
                addLog('Sound enabled', 'normal');
            } else {
                stopAmbientDrone();
                addLog('Sound muted', 'normal');
            }
        });

        // Webcam toggle
        webcamToggle.addEventListener('click', () => {
            if (webcamEnabled) {
                disableWebcam();
            } else {
                enableWebcam();
            }
        });


        // ===== KEYBOARD SHORTCUTS =====
        let isFullscreen = false;

        function toggleFullscreen() {
            isFullscreen = !isFullscreen;
            viewport.classList.toggle('fullscreen', isFullscreen);
            addLog(`Fullscreen mode ${isFullscreen ? 'enabled' : 'disabled'}`, 'normal');
        }

        function toggleShortcutsOverlay() {
            const overlay = document.getElementById('shortcutsOverlay');
            const isActive = overlay.classList.contains('active');
            overlay.classList.toggle('active');

            if (!isActive) {
                // Focus the close button when opening
                const closeBtn = overlay.querySelector('.shortcuts-close');
                setTimeout(() => closeBtn.focus(), 100);
            }
        }

        function showShortcutsHint() {
            const hint = document.getElementById('shortcutsHint');
            hint.classList.add('visible');
            setTimeout(() => hint.classList.remove('visible'), 4000);
        }

        function adjustDepth(change) {
            const newDepth = Math.max(1, Math.min(12, state.depth + change));
            if (newDepth !== state.depth) {
                state.depth = newDepth;
                depthSlider.value = newDepth;
                depthValue.textContent = newDepth;
                if (state.isObserving) {
                    createRecursionLayers();
                }
                updateStats();
                addLog(`Depth ${change > 0 ? 'increased' : 'decreased'} to ${newDepth}`, 'normal');
            }
        }

        function setDepthToNumber(num) {
            if (num >= 1 && num <= 9) {
                state.depth = num;
                depthSlider.value = num;
                depthValue.textContent = num;
                if (state.isObserving) {
                    createRecursionLayers();
                }
                updateStats();
                addLog(`Depth set to ${num}`, 'normal');
            }
        }

        // Global keyboard event handler
        document.addEventListener('keydown', (e) => {
            // Don't handle shortcuts if typing in input fields
            if (e.target.tagName === 'INPUT' && e.target.type === 'file') {
                return;
            }

            // Check if shortcuts overlay is open
            const shortcutsOpen = document.getElementById('shortcutsOverlay').classList.contains('active');

            switch(e.key.toLowerCase()) {
                case ' ': // Space - Start/Stop
                    e.preventDefault();
                    if (!shortcutsOpen) {
                        if (state.isObserving) {
                            stopObservation();
                        } else {
                            startObservation();
                        }
                    }
                    break;

                case 'arrowup': // Up arrow - Increase depth
                    e.preventDefault();
                    if (!shortcutsOpen) {
                        adjustDepth(1);
                    }
                    break;

                case 'arrowdown': // Down arrow - Decrease depth
                    e.preventDefault();
                    if (!shortcutsOpen) {
                        adjustDepth(-1);
                    }
                    break;

                case 'm': // M - Toggle mute
                    e.preventDefault();
                    if (!shortcutsOpen) {
                        soundToggle.click();
                    }
                    break;

                case 'w': // W - Toggle webcam
                    e.preventDefault();
                    if (!shortcutsOpen) {
                        webcamToggle.click();
                    }
                    break;

                case 'r': // R - Reset
                    e.preventDefault();
                    if (!shortcutsOpen) {
                        resetBtn.click();
                    }
                    break;

                case 'f': // F - Toggle fullscreen
                    e.preventDefault();
                    if (!shortcutsOpen) {
                        toggleFullscreen();
                    }
                    break;

                case 'escape': // Escape - Stop observation or close overlay
                    e.preventDefault();
                    if (shortcutsOpen) {
                        toggleShortcutsOverlay();
                    } else if (state.isObserving) {
                        stopObservation();
                    }
                    break;

                case '?': // ? - Toggle shortcuts overlay
                case '/': // Also support / which produces ? when shifted
                    if (e.shiftKey && e.key === '/') {
                        e.preventDefault();
                        toggleShortcutsOverlay();
                    } else if (e.key === '?') {
                        e.preventDefault();
                        toggleShortcutsOverlay();
                    }
                    break;

                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                    if (!shortcutsOpen) {
                        e.preventDefault();
                        setDepthToNumber(parseInt(e.key));
                    }
                    break;
            }
        });

        // Make sound indicator keyboard accessible
        soundToggle.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                soundToggle.click();
            }
        });

        // Show shortcuts hint on first load
        setTimeout(() => {
            if (!localStorage.getItem(APP_NAME + '-shortcuts-hint-shown')) {
                showShortcutsHint();
                localStorage.setItem(APP_NAME + '-shortcuts-hint-shown', 'true');
            }
        }, 2000);


        // Neural prediction toggle
        const neuralToggle = document.getElementById('neuralToggle');
        const predictionModeEl = document.getElementById('predictionMode');
        const neuralConfidenceEl = document.getElementById('neuralConfidence');

        neuralToggle.addEventListener('change', (e) => {
            useNeuralPrediction = e.target.checked;
            predictionModeEl.textContent = useNeuralPrediction ? 'Neural' : 'Heuristic';
            predictionModeEl.className = 'stat-value ' + (useNeuralPrediction ? 'neural' : '');

            if (useNeuralPrediction && !neuralNetwork) {
                initNeuralNetwork();
            }

            addLog(`Switched to ${useNeuralPrediction ? 'neural' : 'heuristic'} prediction mode`, 'prediction');
        });


        // ===== REPLAY SYSTEM FUNCTIONS =====

        function saveCurrentReplay() {
            if (state.actions.length === 0) {
                alert('No session data to save. Record a session first!');
                return;
            }

            const replayName = prompt('Enter a name for this replay:', `Session ${new Date().toLocaleString()}`);
            if (!replayName) return;

            const replay = {
                id: Date.now(),
                name: replayName,
                timestamp: Date.now(),
                duration: state.actions.length > 0 ?
                    (state.actions[state.actions.length - 1].timestamp - state.actions[0].timestamp) : 0,
                actions: [...state.actions],
                depth: state.depth,
                divergenceScore: state.divergenceScore,
                accuracy: state.totalPredictions > 0 ?
                    (state.correctPredictions / state.totalPredictions * 100) : 0,
                behaviorModel: {...state.behaviorModel},
                emotionState: {...state.emotionState},
                metaObservations: [...state.metaObservations]
            };

            replayState.savedReplays.push(replay);
            localStorage.setItem(APP_NAME + '-replays', JSON.stringify(replayState.savedReplays));
            updateReplayList();
            addLog(`Replay saved: ${replayName}`, 'match');

            // Switch to replay tab to show the saved replay
            switchTab('replay');
        }

        function updateReplayList() {
            if (replayState.savedReplays.length === 0) {
                replayList.innerHTML = `
                    <div style="color: #666; font-size: 0.8em; text-align: center; padding: 20px;">
                        No saved replays yet.<br>Record a session first!
                    </div>
                `;
                return;
            }

            replayList.innerHTML = '';
            replayState.savedReplays.forEach(replay => {
                const item = document.createElement('div');
                item.className = 'replay-item';
                if (replayState.currentReplay && replayState.currentReplay.id === replay.id) {
                    item.classList.add('active');
                }

                const duration = (replay.duration / 1000).toFixed(1);
                item.innerHTML = `
                    <div class="replay-item-title">${replay.name}</div>
                    <div class="replay-item-stats">
                        ${replay.actions.length} actions | ${duration}s |
                        Divergence: ${replay.divergenceScore.toFixed(1)}% |
                        Accuracy: ${replay.accuracy.toFixed(1)}%
                    </div>
                `;

                item.addEventListener('click', () => loadReplay(replay));
                replayList.appendChild(item);
            });
        }

        function loadReplay(replay) {
            // Stop current observation if running
            if (state.isObserving) {
                stopObservation();
            }

            // Stop current replay if playing
            if (replayState.isPlaying) {
                stopReplay();
            }

            replayState.currentReplay = replay;
            replayState.currentTime = 0;

            // Set depth to match replay
            state.depth = replay.depth;
            depthSlider.value = replay.depth;
            depthValue.textContent = replay.depth;

            // Create layers for replay
            createRecursionLayers();

            // Show replay timeline
            replayTimeline.classList.add('active');
            replayModeBadge.classList.add('active');
            replayGhostCursor.classList.add('active');

            // Update timeline markers
            updateTimelineMarkers();
            updateReplayList();

            // Enable play button
            replayPlayBtn.disabled = false;
            replayPauseBtn.disabled = true;
            replayRewindBtn.disabled = false;

            addLog(`Loaded replay: ${replay.name}`, 'match');
        }

        function updateTimelineMarkers() {
            if (!replayState.currentReplay) return;

            const actions = replayState.currentReplay.actions;
            if (actions.length === 0) return;

            const duration = actions[actions.length - 1].timestamp - actions[0].timestamp;
            timelineEvents.innerHTML = '';

            actions.forEach(action => {
                if (action.type === 'click') {
                    const marker = document.createElement('div');
                    marker.className = 'timeline-event click';
                    const relativeTime = (action.timestamp - actions[0].timestamp) / duration;
                    marker.style.left = (relativeTime * 100) + '%';
                    timelineEvents.appendChild(marker);
                }
            });
        }

        function playReplay() {
            if (!replayState.currentReplay) return;

            replayState.isPlaying = true;
            replayState.isPaused = false;
            replayPlayBtn.disabled = true;
            replayPauseBtn.disabled = false;
            replayModeBadge.textContent = `REPLAY MODE (${replayState.playbackSpeed}x)`;

            const actions = replayState.currentReplay.actions;
            if (actions.length === 0) return;

            const startTime = actions[0].timestamp;
            const startPlaybackTime = performance.now();
            const resumeFrom = replayState.currentTime;

            function animate() {
                if (!replayState.isPlaying) return;

                const elapsed = (performance.now() - startPlaybackTime) * replayState.playbackSpeed;
                const currentReplayTime = resumeFrom + elapsed;

                // Find current action
                const currentAction = actions.find(a =>
                    (a.timestamp - startTime) >= currentReplayTime &&
                    (a.timestamp - startTime) < currentReplayTime + 50
                );

                // Update ghost cursor position
                if (currentAction) {
                    replayGhostCursor.style.left = currentAction.x + 'px';
                    replayGhostCursor.style.top = currentAction.y + 'px';

                    // Update predictions for all layers
                    state.layers.forEach((layer, i) => {
                        const predicted = predictReplayPosition(currentAction, i);
                        const relX = (predicted.x - layer.offset.x) / layer.scale;
                        const relY = (predicted.y - layer.offset.y) / layer.scale;
                        layer.cursor.style.transform = `translate(${relX}px, ${relY}px)`;

                        // Calculate divergence
                        const dx = predicted.x - currentAction.x;
                        const dy = predicted.y - currentAction.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        layer.divergence = distance;

                        if (distance > 100) {
                            layer.element.classList.add('diverged');
                            layer.element.classList.remove('converged');
                        } else if (distance < 30) {
                            layer.element.classList.add('converged');
                            layer.element.classList.remove('diverged');
                        }
                    });

                    // Show click effect
                    if (currentAction.type === 'click') {
                        simulateReplayClick(currentAction.x, currentAction.y);
                    }
                }

                // Update progress bar
                const duration = actions[actions.length - 1].timestamp - startTime;
                const progress = Math.min((currentReplayTime / duration) * 100, 100);
                timelineProgress.style.width = progress + '%';
                timelinePlayhead.style.left = progress + '%';

                // Update time display
                const currentSec = Math.floor(currentReplayTime / 1000);
                const totalSec = Math.floor(duration / 1000);
                timeDisplay.textContent = `${formatTime(currentSec)} / ${formatTime(totalSec)}`;

                replayState.currentTime = currentReplayTime;

                // Check if replay finished
                if (currentReplayTime >= duration) {
                    stopReplay();
                    replayState.currentTime = 0;
                    return;
                }

                replayState.animationFrame = requestAnimationFrame(animate);
            }

            animate();
        }

        function pauseReplay() {
            replayState.isPlaying = false;
            replayState.isPaused = true;
            replayPlayBtn.disabled = false;
            replayPauseBtn.disabled = true;
            if (replayState.animationFrame) {
                cancelAnimationFrame(replayState.animationFrame);
            }
        }

        function stopReplay() {
            replayState.isPlaying = false;
            replayState.isPaused = false;
            replayState.currentTime = 0;

            if (replayState.animationFrame) {
                cancelAnimationFrame(replayState.animationFrame);
            }

            timelineProgress.style.width = '0%';
            timelinePlayhead.style.left = '0%';
            replayPlayBtn.disabled = false;
            replayPauseBtn.disabled = true;
        }

        function rewindReplay() {
            stopReplay();
            replayState.currentTime = 0;
            timeDisplay.textContent = '0:00 / 0:00';
        }

        function setPlaybackSpeed(speed) {
            replayState.playbackSpeed = speed;
            document.querySelectorAll('.speed-button').forEach(btn => {
                btn.classList.toggle('active', parseFloat(btn.dataset.speed) === speed);
            });
            if (replayState.isPlaying) {
                replayModeBadge.textContent = `REPLAY MODE (${speed}x)`;
            }
        }

        function predictReplayPosition(action, layerIndex) {
            // Similar to predictNextPosition but for replay
            const errorFactor = Math.pow(1.15, layerIndex + 1);
            const chaos = replayState.currentReplay.divergenceScore / 100;

            let predictedX = action.x + (Math.random() - 0.5) * 10 * errorFactor;
            let predictedY = action.y + (Math.random() - 0.5) * 10 * errorFactor;

            const divergenceNoise = layerIndex * 5 * (1 + chaos);
            predictedX += (Math.random() - 0.5) * divergenceNoise;
            predictedY += (Math.random() - 0.5) * divergenceNoise;

            return { x: predictedX, y: predictedY };
        }

        function simulateReplayClick(x, y) {
            state.layers.forEach((layer, i) => {
                setTimeout(() => {
                    const click = document.createElement('div');
                    click.className = 'ghost-click';
                    click.style.color = depthColors[i % depthColors.length];

                    const errorFactor = Math.pow(1.2, i + 1);
                    const clickX = (x - layer.offset.x) / layer.scale + (Math.random() - 0.5) * 20 * errorFactor;
                    const clickY = (y - layer.offset.y) / layer.scale + (Math.random() - 0.5) * 20 * errorFactor;

                    click.style.left = (clickX - 20) + 'px';
                    click.style.top = (clickY - 20) + 'px';
                    layer.element.appendChild(click);
                    playClickSound(i);
                    setTimeout(() => click.remove(), 600);
                }, (i + 1) * 100);
            });
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function importReplay(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);

                    // Check if it's a replay or a full session export
                    if (data.actions && Array.isArray(data.actions)) {
                        const replay = {
                            id: Date.now(),
                            name: data.name || `Imported ${new Date().toLocaleString()}`,
                            timestamp: Date.now(),
                            duration: data.duration || 0,
                            actions: data.actions,
                            depth: data.depth || 5,
                            divergenceScore: data.divergenceScore || 0,
                            accuracy: data.accuracy || 0,
                            behaviorModel: data.behaviorModel || {},
                            metaObservations: data.metaObservations || []
                        };

                        replayState.savedReplays.push(replay);
                        localStorage.setItem(APP_NAME + '-replays', JSON.stringify(replayState.savedReplays));
                        updateReplayList();
                        addLog(`Imported replay: ${replay.name}`, 'match');
                        switchTab('replay');
                    } else if (data.currentSession && data.currentSession.actions) {
                        // Import from full session export
                        const session = data.currentSession;
                        const replay = {
                            id: Date.now(),
                            name: `Imported ${new Date().toLocaleString()}`,
                            timestamp: Date.now(),
                            duration: session.actions.length > 0 ?
                                (session.actions[session.actions.length - 1].timestamp - session.actions[0].timestamp) : 0,
                            actions: session.actions,
                            depth: data.behaviorModel?.depth || 5,
                            divergenceScore: session.divergenceScore || 0,
                            accuracy: 0,
                            behaviorModel: data.behaviorModel || {},
                            metaObservations: session.metaObservations || []
                        };

                        replayState.savedReplays.push(replay);
                        localStorage.setItem(APP_NAME + '-replays', JSON.stringify(replayState.savedReplays));
                        updateReplayList();
                        addLog('Imported replay from session export', 'match');
                        switchTab('replay');
                    } else {
                        alert('Invalid replay file format');
                    }
                } catch (error) {
                    alert('Error importing replay: ' + error.message);
                }
            };
            reader.readAsText(file);
        }

        function switchTab(tabName) {
            tabButtons.forEach(btn => {
                const isActive = btn.dataset.tab === tabName;
                btn.classList.toggle('active', isActive);
            });

            observeTab.classList.toggle('active', tabName === 'observe');
            replayTab.classList.toggle('active', tabName === 'replay');

            if (tabName === 'observe') {
                replayTimeline.classList.remove('active');
                replayModeBadge.classList.remove('active');
                replayGhostCursor.classList.remove('active');
                comparisonCursor.classList.remove('active');
                if (replayState.isPlaying) {
                    stopReplay();
                }
            } else {
                updateReplayList();
            }
        }

        // Timeline scrubbing
        timelineScrubber.addEventListener('click', (e) => {
            if (!replayState.currentReplay) return;

            const rect = timelineScrubber.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const percent = x / rect.width;

            const actions = replayState.currentReplay.actions;
            const duration = actions[actions.length - 1].timestamp - actions[0].timestamp;
            replayState.currentTime = percent * duration;

            timelineProgress.style.width = (percent * 100) + '%';
            timelinePlayhead.style.left = (percent * 100) + '%';

            const currentSec = Math.floor(replayState.currentTime / 1000);
            const totalSec = Math.floor(duration / 1000);
            timeDisplay.textContent = `${formatTime(currentSec)} / ${formatTime(totalSec)}`;
        });

        // Tab switching
        tabButtons.forEach(btn => {
            btn.addEventListener('click', () => switchTab(btn.dataset.tab));
        });

        // Replay control event listeners
        replayPlayBtn.addEventListener('click', playReplay);
        replayPauseBtn.addEventListener('click', pauseReplay);
        replayRewindBtn.addEventListener('click', rewindReplay);

        // Speed control buttons
        document.querySelectorAll('.speed-button').forEach(btn => {
            btn.addEventListener('click', () => {
                setPlaybackSpeed(parseFloat(btn.dataset.speed));
            });
        });

        // Comparison mode toggle
        comparisonModeToggle.addEventListener('change', (e) => {
            replayState.comparisonMode = e.target.checked;
            if (replayState.comparisonMode) {
                comparisonCursor.classList.add('active');
                addLog('Comparison mode enabled - your movements shown in green', 'match');
            } else {
                comparisonCursor.classList.remove('active');
            }
        });

        // Update comparison cursor during live observation if comparison mode is on
        const originalMouseMove = viewport.onmousemove;
        viewport.addEventListener('mousemove', (e) => {
            if (replayState.comparisonMode && replayState.isPlaying) {
                const rect = viewport.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                comparisonCursor.style.left = x + 'px';
                comparisonCursor.style.top = y + 'px';
            }
        });

        // Initialize
        updateStats();
        generateBehavioralFingerprint();
        addLog('Recursive Self-Portrait initialized', 'normal');
        addLog('The system will learn your patterns and simulate you simulating yourself...', 'prediction');
        addLog('Neural network available - toggle to enable real-time learning', 'prediction');

        if (state.sessionHistory.length > 0) {
            const lastSession = state.sessionHistory[state.sessionHistory.length - 1];
            addLog(`Previous session: ${lastSession.actions} actions, ${lastSession.divergence.toFixed(1)}% divergence`, 'normal');
        }

        // Start with sound muted (user must click to activate - better UX)
        soundToggle.classList.add('muted');


        // ===== MULTIPLAYER FUNCTIONALITY =====
        let peerConnection = null;
        let dataChannel = null;
        let isHost = false;
        let roomCode = '';
        let peerState = {
            divergenceScore: 0,
            actions: [],
            layers: [],
            behaviorModel: {},
            cursorPos: { x: 0, y: 0 }
        };
        let predictMode = false;
        let predictScore = 0;

        const multiplayerPanel = document.getElementById('multiplayerPanel');
        const connectionDot = document.getElementById('connectionDot');
        const connectionText = document.getElementById('connectionText');
        const roomCodeInput = document.getElementById('roomCodeInput');
        const joinRoomBtn = document.getElementById('joinRoomBtn');
        const createRoomBtn = document.getElementById('createRoomBtn');
        const roomCodeDisplay = document.getElementById('roomCodeDisplay');
        const roomCodeSpan = document.getElementById('roomCode');
        const comparativeStats = document.getElementById('comparativeStats');
        const myDivergence = document.getElementById('myDivergence');
        const peerDivergence = document.getElementById('peerDivergence');
        const predictModePanel = document.getElementById('predictModePanel');
        const predictModeBtn = document.getElementById('predictModeBtn');
        const predictScoreEl = document.getElementById('predictScore');
        const peerCursor = document.getElementById('peerCursor');
        const peerLayersContainer = document.getElementById('peerLayersContainer');

        function generateRoomCode() {
            const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
            let code = '';
            for (let i = 0; i < 6; i++) {
                code += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return code;
        }

        function updateConnectionStatus(status, text) {
            connectionDot.className = 'status-dot';
            if (status === 'connected') {
                connectionDot.classList.add('connected');
            } else if (status === 'connecting') {
                connectionDot.classList.add('connecting');
            }
            connectionText.textContent = text;
        }

        async function createRoom() {
            roomCode = generateRoomCode();
            isHost = true;

            roomCodeSpan.textContent = roomCode;
            roomCodeDisplay.style.display = 'block';
            createRoomBtn.disabled = true;
            joinRoomBtn.disabled = true;
            roomCodeInput.disabled = true;

            updateConnectionStatus('connecting', 'Waiting for peer...');
            addLog('Room created: ' + roomCode, 'normal');

            // Setup WebRTC as host
            await setupWebRTC(true);
        }

        async function joinRoom() {
            const code = roomCodeInput.value.trim().toUpperCase();
            if (!code) {
                alert('Please enter a room code');
                return;
            }

            roomCode = code;
            isHost = false;

            roomCodeSpan.textContent = roomCode;
            roomCodeDisplay.style.display = 'block';
            createRoomBtn.disabled = true;
            joinRoomBtn.disabled = true;
            roomCodeInput.disabled = true;

            updateConnectionStatus('connecting', 'Connecting to peer...');
            addLog('Joining room: ' + roomCode, 'normal');

            // Setup WebRTC as joiner
            await setupWebRTC(false);
        }

        async function setupWebRTC(isInitiator) {
            // Create RTCPeerConnection
            const config = {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' }
                ]
            };

            peerConnection = new RTCPeerConnection(config);

            // Handle ICE candidates
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    // In a real app, send this to signaling server
                    // For this demo, we'll use manual exchange via prompt
                    console.log('ICE Candidate:', JSON.stringify(event.candidate));
                }
            };

            peerConnection.onconnectionstatechange = () => {
                console.log('Connection state:', peerConnection.connectionState);
                if (peerConnection.connectionState === 'connected') {
                    onPeerConnected();
                } else if (peerConnection.connectionState === 'disconnected' ||
                           peerConnection.connectionState === 'failed') {
                    onPeerDisconnected();
                }
            };

            if (isInitiator) {
                // Host creates data channel
                dataChannel = peerConnection.createDataChannel('recursion');
                setupDataChannel();

                // Create offer
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);

                // Show offer for manual exchange
                const offerStr = JSON.stringify(peerConnection.localDescription);
                addLog('Copy this offer and send to peer', 'prediction');

                // Simulate exchange - in real app this would go through signaling server
                const answerPrompt = 'Paste peer answer (from other browser):';
                setTimeout(() => {
                    const answerStr = prompt(offerStr + '

' + answerPrompt);
                    if (answerStr) {
                        try {
                            const answer = JSON.parse(answerStr);
                            peerConnection.setRemoteDescription(answer);
                        } catch (e) {
                            addLog('Invalid answer format', 'divergence');
                        }
                    }
                }, 1000);

            } else {
                // Joiner waits for offer
                peerConnection.ondatachannel = (event) => {
                    dataChannel = event.channel;
                    setupDataChannel();
                };

                // Get offer from host
                setTimeout(async () => {
                    const offerStr = prompt('Paste the offer from host:');
                    if (offerStr) {
                        try {
                            const offer = JSON.parse(offerStr);
                            await peerConnection.setRemoteDescription(offer);

                            // Create answer
                            const answer = await peerConnection.createAnswer();
                            await peerConnection.setLocalDescription(answer);

                            // Show answer for manual exchange
                            const answerStr = JSON.stringify(peerConnection.localDescription);
                            alert('Send this answer to host:

' + answerStr);
                            addLog('Answer sent - waiting for connection', 'prediction');
                        } catch (e) {
                            addLog('Invalid offer format', 'divergence');
                        }
                    }
                }, 500);
            }
        }

        function setupDataChannel() {
            dataChannel.onopen = () => {
                console.log('Data channel opened');
            };

            dataChannel.onclose = () => {
                console.log('Data channel closed');
                onPeerDisconnected();
            };

            dataChannel.onmessage = (event) => {
                const data = JSON.parse(event.data);
                handlePeerData(data);
            };
        }

        function onPeerConnected() {
            updateConnectionStatus('connected', 'Connected to peer');
            comparativeStats.style.display = 'grid';
            predictModePanel.style.display = 'block';
            peerCursor.style.display = 'block';
            addLog('Peer connected - now watching each other!', 'match');
        }

        function onPeerDisconnected() {
            updateConnectionStatus('disconnected', 'Peer disconnected');
            comparativeStats.style.display = 'none';
            predictModePanel.style.display = 'none';
            peerCursor.style.display = 'none';
            peerLayersContainer.innerHTML = '';
            addLog('Peer disconnected', 'divergence');
        }

        function sendToPeer(data) {
            if (dataChannel && dataChannel.readyState === 'open') {
                dataChannel.send(JSON.stringify(data));
            }
        }

        function handlePeerData(data) {
            if (data.type === 'cursor') {
                // Update peer cursor position
                peerCursor.style.left = data.x + 'px';
                peerCursor.style.top = data.y + 'px';
                peerState.cursorPos = { x: data.x, y: data.y };

                // Update peer layers
                updatePeerLayers(data.x, data.y);

                // Check predict mode
                if (predictMode && state.isObserving) {
                    checkPrediction(data.x, data.y);
                }
            } else if (data.type === 'stats') {
                // Update peer stats
                peerState.divergenceScore = data.divergenceScore;
                peerState.behaviorModel = data.behaviorModel;
                peerDivergence.textContent = data.divergenceScore.toFixed(1) + '%';
                myDivergence.textContent = state.divergenceScore.toFixed(1) + '%';

                // Generate comparative meta-commentary
                if (Math.random() > 0.95) {
                    showComparativeMetaCommentary();
                }
            } else if (data.type === 'action') {
                peerState.actions.push(data.action);
            }
        }

        function updatePeerLayers(x, y) {
            // Clear existing peer layers
            peerLayersContainer.innerHTML = '';

            if (!state.isObserving) return;

            const viewportRect = viewport.getBoundingClientRect();
            const padding = 40;

            // Create peer's recursion layers (mirrored)
            for (let i = 0; i < state.depth; i++) {
                const scale = Math.pow(0.7, i + 1);
                const width = (viewportRect.width - padding * 2) * scale;
                const height = (viewportRect.height - padding * 2) * scale;

                const offsetX = (viewportRect.width - width) / 2 + (i * 5);
                const offsetY = (viewportRect.height - height) / 2 + (i * 5);

                const layer = document.createElement('div');
                layer.className = 'peer-recursion-layer';
                layer.setAttribute('data-depth', `Peer L${i + 1}`);
                layer.style.cssText = `
                    width: ${width}px;
                    height: ${height}px;
                    left: ${offsetX}px;
                    top: ${offsetY}px;
                    z-index: ${state.depth - i - 10};
                    opacity: 0.6;
                `;

                // Add peer ghost cursor to this layer
                const cursor = document.createElement('div');
                cursor.className = 'ghost-cursor peer-ghost-cursor';
                cursor.style.opacity = 0.8 - (i * 0.1);

                // Calculate position within this layer with slight divergence
                const errorFactor = Math.pow(1.15, i + 1);
                const relX = (x - offsetX) / scale + (Math.random() - 0.5) * 10 * errorFactor;
                const relY = (y - offsetY) / scale + (Math.random() - 0.5) * 10 * errorFactor;

                cursor.style.left = relX + 'px';
                cursor.style.top = relY + 'px';

                layer.appendChild(cursor);
                peerLayersContainer.appendChild(layer);

                // Apply quantum entanglement at depth 8+
                if (state.quantum.enabled && i >= 8 && state.layers[i] && state.layers[i].cursor) {
                    applyQuantumEntanglement(cursor, state.layers[i].cursor, i);
                }
            }
        }

        function showComparativeMetaCommentary() {
            const myDiv = state.divergenceScore;
            const peerDiv = peerState.divergenceScore;
            const diff = Math.abs(myDiv - peerDiv);

            let comment = '';
            if (diff < 10) {
                comment = 'You and your peer are eerily similar...';
            } else if (myDiv > peerDiv) {
                comment = 'You are more unpredictable than them.';
            } else {
                comment = 'They are more chaotic than you.';
            }

            if (state.behaviorModel.movementStyle === peerState.behaviorModel.movementStyle) {
                comment = 'You both move in the same way. Convergence detected.';
            }

            const meta = document.createElement('div');
            meta.className = 'meta-comment dual';
            meta.textContent = comment;

            const maxX = viewport.clientWidth - 320;
            const maxY = viewport.clientHeight - 100;
            meta.style.left = (Math.random() * maxX + 20) + 'px';
            meta.style.top = (Math.random() * maxY + 50) + 'px';

            viewport.appendChild(meta);
            setTimeout(() => meta.remove(), 8000);

            addLog(`Comparative: ${comment}`, 'prediction');
        }

        function checkPrediction(actualX, actualY) {
            // Check if you predicted where peer would move
            const distance = Math.sqrt(
                Math.pow(lastMousePos.x - actualX, 2) +
                Math.pow(lastMousePos.y - actualY, 2)
            );

            if (distance < 50) {
                predictScore += 10;
                addLog('Prediction match! +10', 'match');
            } else if (distance > 200) {
                predictScore = Math.max(0, predictScore - 5);
            }

            predictScoreEl.textContent = predictScore + ' pts';
        }



        // Event listeners
        createRoomBtn.addEventListener('click', createRoom);
        joinRoomBtn.addEventListener('click', joinRoom);

        roomCodeDisplay.addEventListener('click', () => {
            navigator.clipboard.writeText(roomCode);
            addLog('Room code copied to clipboard', 'match');
        });

        predictModeBtn.addEventListener('click', () => {
            predictMode = !predictMode;
            predictModePanel.classList.toggle('active', predictMode);
            predictModeBtn.textContent = predictMode ?
                'Stop Predict Mode' : 'Start "Predict Each Other" Mode';
            predictScore = 0;
            predictScoreEl.textContent = predictMode ? '0 pts' : '';
            addLog(predictMode ? 'Predict mode activated' : 'Predict mode deactivated', 'prediction');
        });

        // Modify existing mouse move handler to send position to peer
        const originalMouseMoveHandler = viewport.onmousemove;
        viewport.addEventListener('mousemove', (e) => {
            if (dataChannel && dataChannel.readyState === 'open') {
                const rect = viewport.getBoundingClientRect();
                sendToPeer({
                    type: 'cursor',
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                });
            }
        });

        // Send stats periodically
        setInterval(() => {
            if (dataChannel && dataChannel.readyState === 'open' && state.isObserving) {
                sendToPeer({
                    type: 'stats',
                    divergenceScore: state.divergenceScore,
                    behaviorModel: state.behaviorModel,
                    actionsCount: state.actions.length
                });
            }
        }, 1000);

        soundEnabled = false;

        // ===== CROSS-SESSION EVOLUTION FUNCTIONS =====

        function calculateBehavioralEntropy() {
            if (state.actions.length < 10) return 0;

            // Calculate entropy based on movement predictability
            const velocities = [];
            for (let i = 1; i < state.actions.length; i++) {
                const prev = state.actions[i - 1];
                const curr = state.actions[i];
                if (prev.type === 'move' && curr.type === 'move') {
                    const dx = curr.x - prev.x;
                    const dy = curr.y - prev.y;
                    velocities.push(Math.sqrt(dx * dx + dy * dy));
                }
            }

            if (velocities.length === 0) return 0;

            // Calculate variance as a measure of entropy
            const mean = velocities.reduce((a, b) => a + b, 0) / velocities.length;
            const variance = velocities.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / velocities.length;

            // Normalize to 0-100 scale
            return Math.min(100, Math.sqrt(variance));
        }

        function generateBehavioralSignature() {
            return {
                movementStyle: state.behaviorModel.movementStyle,
                avgSpeed: state.behaviorModel.avgSpeed,
                clickFrequency: state.actions.filter(a => a.type === 'click').length / Math.max(1, state.actions.length),
                entropy: calculateBehavioralEntropy(),
                divergenceScore: state.divergenceScore,
                accuracy: state.totalPredictions > 0 ? (state.correctPredictions / state.totalPredictions) * 100 : 0
            };
        }

        function compareSignatures(sig1, sig2) {
            if (!sig1 || !sig2) return 100;

            let diff = 0;
            diff += Math.abs(sig1.avgSpeed - sig2.avgSpeed) / 10;
            diff += Math.abs(sig1.clickFrequency - sig2.clickFrequency) * 100;
            diff += Math.abs(sig1.entropy - sig2.entropy);
            diff += Math.abs(sig1.divergenceScore - sig2.divergenceScore);
            diff += Math.abs(sig1.accuracy - sig2.accuracy) / 2;

            if (sig1.movementStyle !== sig2.movementStyle) {
                diff += 20;
            }

            return Math.max(0, 100 - diff);
        }

        function saveCurrentSession() {
            if (state.actions.length < 5) return; // Don't save very short sessions

            const sessionData = {
                timestamp: evolutionState.currentSessionStart,
                endTime: Date.now(),
                duration: Date.now() - evolutionState.currentSessionStart,
                signature: generateBehavioralSignature(),
                actions: state.actions.slice(0, 500), // Limit to save space
                behaviorModel: JSON.parse(JSON.stringify(state.behaviorModel)),
                divergenceScore: state.divergenceScore,
                depth: state.depth,
                metaObservations: state.metaObservations,
                    emotionState: state.emotionState.slice()
            };

            evolutionState.allSessions.push(sessionData);

            // Keep only last 50 sessions to save space
            if (evolutionState.allSessions.length > 50) {
                evolutionState.allSessions = evolutionState.allSessions.slice(-50);
            }

            // Update entropy trend
            evolutionState.entropyTrend.push({
                timestamp: sessionData.timestamp,
                entropy: sessionData.signature.entropy
            });

            // Calculate consistency score
            if (evolutionState.allSessions.length > 1) {
                const recent = evolutionState.allSessions.slice(-5);
                let totalSimilarity = 0;
                let comparisons = 0;

                for (let i = 0; i < recent.length - 1; i++) {
                    for (let j = i + 1; j < recent.length; j++) {
                        totalSimilarity += compareSignatures(recent[i].signature, recent[j].signature);
                        comparisons++;
                    }
                }

                evolutionState.consistencyScore = comparisons > 0 ? totalSimilarity / comparisons : 100;
            }

            // Save to localStorage
            evolutionState.totalVisits++;
            evolutionState.lastVisit = Date.now();

            localStorage.setItem(APP_NAME + '-evolution', JSON.stringify({
                allSessions: evolutionState.allSessions,
                lastVisit: evolutionState.lastVisit,
                totalVisits: evolutionState.totalVisits,
                entropyTrend: evolutionState.entropyTrend
            }));

            updateEvolutionUI();
        }

        function showWelcomeMessage() {
            const welcomeDiv = document.getElementById('welcomeMessage');
            if (!welcomeDiv) return;

            if (evolutionState.lastVisit && evolutionState.allSessions.length > 0) {
                const timeSinceLastVisit = Date.now() - evolutionState.lastVisit;
                const days = Math.floor(timeSinceLastVisit / (1000 * 60 * 60 * 24));
                const hours = Math.floor(timeSinceLastVisit / (1000 * 60 * 60));

                let timeString = '';
                if (days > 0) {
                    timeString = `${days} day${days > 1 ? 's' : ''}`;
                } else if (hours > 0) {
                    timeString = `${hours} hour${hours > 1 ? 's' : ''}`;
                } else {
                    timeString = 'a few minutes';
                }

                const lastSession = evolutionState.allSessions[evolutionState.allSessions.length - 1];
                const currentSignature = generateBehavioralSignature();
                const similarity = compareSignatures(lastSession.signature, currentSignature);

                let message = '';
                if (similarity > 80) {
                    message = `You're remarkably consistent. Nearly identical to ${timeString} ago.`;
                } else if (similarity > 60) {
                    message = `Some variations detected. You've evolved slightly since ${timeString} ago.`;
                } else if (similarity > 40) {
                    message = `You've become noticeably different since ${timeString} ago. Interesting...`;
                } else {
                    message = `You've become significantly more ${currentSignature.entropy > lastSession.signature.entropy ? 'erratic' : 'controlled'} since ${timeString} ago.`;
                }

                welcomeDiv.innerHTML = `
                    <div class="welcome-message">
                        <div class="title">Welcome back. I remember you.</div>
                        <div class="subtitle">
                            Last visit: ${timeString} ago<br>
                            ${message}
                        </div>
                    </div>
                `;
            } else {
                welcomeDiv.innerHTML = `
                    <div class="welcome-message">
                        <div class="title">First observation initiated.</div>
                        <div class="subtitle">
                            I will remember you.<br>
                            Return and see how you've changed.
                        </div>
                    </div>
                `;
            }
        }

        function updateEvolutionUI() {
            // Update consistency score
            const consistencyFill = document.getElementById('consistencyFill');
            const consistencyScore = document.getElementById('consistencyScore');
            if (consistencyFill && consistencyScore) {
                const score = Math.round(evolutionState.consistencyScore);
                consistencyFill.style.width = score + '%';
                consistencyScore.textContent = score + '%';
                consistencyScore.className = 'stat-value' + (score > 70 ? ' converged' : score < 40 ? ' diverged' : '');
            }

            // Update total visits
            const totalVisitsEl = document.getElementById('totalVisits');
            if (totalVisitsEl) {
                totalVisitsEl.textContent = evolutionState.totalVisits;
            }

            // Update entropy
            const entropyValueEl = document.getElementById('entropyValue');
            if (entropyValueEl && state.actions.length > 10) {
                const entropy = Math.round(calculateBehavioralEntropy());
                entropyValueEl.textContent = entropy;
                entropyValueEl.className = 'stat-value' + (entropy > 60 ? ' diverged' : entropy < 30 ? ' converged' : '');
            }

            // Update entropy graph
            updateEntropyGraph();

            // Update timeline
            updateEvolutionTimeline();
        }

        function updateEntropyGraph() {
            const svg = document.getElementById('entropyGraph');
            if (!svg || evolutionState.entropyTrend.length < 2) return;

            const width = svg.clientWidth;
            const height = svg.clientHeight;
            const padding = 5;

            const data = evolutionState.entropyTrend.slice(-20); // Last 20 data points
            const maxEntropy = Math.max(...data.map(d => d.entropy), 1);

            // Create path for line
            let pathD = '';
            let areaD = '';

            data.forEach((point, i) => {
                const x = padding + (i / (data.length - 1)) * (width - 2 * padding);
                const y = height - padding - (point.entropy / maxEntropy) * (height - 2 * padding);

                if (i === 0) {
                    pathD = `M ${x} ${y}`;
                    areaD = `M ${x} ${height - padding} L ${x} ${y}`;
                } else {
                    pathD += ` L ${x} ${y}`;
                    areaD += ` L ${x} ${y}`;
                }
            });

            areaD += ` L ${width - padding} ${height - padding} Z`;

            svg.innerHTML = `
                <path class="entropy-area" d="${areaD}"/>
                <path class="entropy-line" d="${pathD}"/>
            `;
        }

        function updateEvolutionTimeline() {
            const timeline = document.getElementById('evolutionTimeline');
            if (!timeline || evolutionState.allSessions.length === 0) return;

            timeline.innerHTML = '';

            const sessions = evolutionState.allSessions.slice(-10); // Last 10 sessions
            if (sessions.length === 0) return;

            const timelineWidth = timeline.clientWidth;
            const minTime = sessions[0].timestamp;
            const maxTime = sessions[sessions.length - 1].timestamp;
            const timeRange = maxTime - minTime || 1;

            sessions.forEach((session, i) => {
                const pos = ((session.timestamp - minTime) / timeRange) * 100;
                const width = Math.max(2, 100 / sessions.length - 1);

                const bar = document.createElement('div');
                bar.className = 'timeline-session';
                bar.style.left = pos + '%';
                bar.style.width = width + '%';
                bar.dataset.sessionIndex = i;

                const date = new Date(session.timestamp);
                const label = document.createElement('div');
                label.className = 'timeline-label';
                label.textContent = date.toLocaleDateString();
                bar.appendChild(label);

                bar.onclick = () => selectSessionForGhost(i);
                timeline.appendChild(bar);
            });
        }

        function selectSessionForGhost(index) {
            const sessions = evolutionState.allSessions.slice(-10);
            if (index >= 0 && index < sessions.length) {
                evolutionState.ghostSession = sessions[index];
                evolutionState.showGhost = true;

                // Update UI
                document.querySelectorAll('.timeline-session').forEach((el, i) => {
                    el.classList.toggle('selected', i === index);
                });

                addLog(`Ghost of past self loaded from ${new Date(evolutionState.ghostSession.timestamp).toLocaleDateString()}`, 'match');
            }
        }

        function toggleGhostOverlay() {
            if (!evolutionState.ghostSession && evolutionState.allSessions.length > 0) {
                // Select most recent past session
                evolutionState.ghostSession = evolutionState.allSessions[evolutionState.allSessions.length - 1];
            }

            evolutionState.showGhost = !evolutionState.showGhost;

            if (evolutionState.showGhost && evolutionState.ghostSession) {
                addLog(' Ghost of past you is now visible', 'match');
                startGhostPlayback();
            } else {
                addLog('Ghost overlay disabled', 'prediction');
                stopGhostPlayback();
            }
        }

        let ghostPlaybackIndex = 0;
        let ghostPlaybackInterval = null;
        let ghostCursorElement = null;

        function startGhostPlayback() {
            if (!evolutionState.ghostSession || !evolutionState.ghostSession.actions) return;

            // Create ghost cursor if it doesn't exist
            if (!ghostCursorElement) {
                ghostCursorElement = document.createElement('div');
                ghostCursorElement.className = 'ghost-overlay-cursor';
                viewport.appendChild(ghostCursorElement);
            }

            ghostPlaybackIndex = 0;
            clearInterval(ghostPlaybackInterval);

            ghostPlaybackInterval = setInterval(() => {
                if (!evolutionState.showGhost || ghostPlaybackIndex >= evolutionState.ghostSession.actions.length) {
                    ghostPlaybackIndex = 0; // Loop
                }

                const action = evolutionState.ghostSession.actions[ghostPlaybackIndex];
                if (action && action.type === 'move') {
                    const rect = viewport.getBoundingClientRect();
                    ghostCursorElement.style.left = action.x + 'px';
                    ghostCursorElement.style.top = action.y + 'px';
                    ghostCursorElement.style.display = 'block';
                }

                ghostPlaybackIndex++;
            }, 50);
        }

        function stopGhostPlayback() {
            clearInterval(ghostPlaybackInterval);
            if (ghostCursorElement) {
                ghostCursorElement.style.display = 'none';
            }
        }

        function showSessionComparison() {
            if (evolutionState.allSessions.length < 2) {
                addLog('Need at least 2 sessions to compare', 'divergence');
                return;
            }

            // Create comparison overlay
            let overlay = document.getElementById('sessionComparisonOverlay');
            if (!overlay) {
                overlay = document.createElement('div');
                overlay.id = 'sessionComparisonOverlay';
                overlay.className = 'session-comparison-overlay';
                document.body.appendChild(overlay);
            }

            const sessions = evolutionState.allSessions.slice(-10);
            let html = '<h2 style="color: #64c8ff; margin-bottom: 15px;">Session Comparison</h2>';
            html += '<button onclick="closeSessionComparison()" style="position: absolute; top: 10px; right: 10px; padding: 8px 16px;">Close</button>';
            html += '<div class="session-grid">';

            sessions.forEach((session, i) => {
                const date = new Date(session.timestamp);
                const sig = session.signature;

                html += `
                    <div class="session-card" onclick="selectComparisonSession(${i})">
                        <div class="date">${date.toLocaleDateString()} ${date.toLocaleTimeString()}</div>
                        <div class="stats">
                            Style: ${sig.movementStyle}<br>
                            Speed: ${sig.avgSpeed.toFixed(1)}<br>
                            Entropy: ${sig.entropy.toFixed(1)}<br>
                            Divergence: ${sig.divergenceScore.toFixed(1)}%
                        </div>
                    </div>
                `;
            });

            html += '</div>';
            overlay.innerHTML = html;
            overlay.classList.add('active');
        }

        function closeSessionComparison() {
            const overlay = document.getElementById('sessionComparisonOverlay');
            if (overlay) {
                overlay.classList.remove('active');
            }
        }

        function selectComparisonSession(index) {
            const sessions = evolutionState.allSessions.slice(-10);
            if (index >= 0 && index < sessions.length) {
                evolutionState.comparisonSession = sessions[index];
                addLog(`Comparing with session from ${new Date(sessions[index].timestamp).toLocaleDateString()}`, 'match');
                closeSessionComparison();
            }
        }

        function showFuturePrediction() {
            if (evolutionState.allSessions.length < 3) {
                addLog('Need at least 3 sessions to predict future behavior', 'divergence');
                return;
            }

            const recentSessions = evolutionState.allSessions.slice(-5);

            // Calculate trends
            let entropyTrend = 0;
            let speedTrend = 0;
            let divergenceTrend = 0;

            for (let i = 1; i < recentSessions.length; i++) {
                const prev = recentSessions[i - 1].signature;
                const curr = recentSessions[i].signature;

                entropyTrend += curr.entropy - prev.entropy;
                speedTrend += curr.avgSpeed - prev.avgSpeed;
                divergenceTrend += curr.divergenceScore - prev.divergenceScore;
            }

            const n = recentSessions.length - 1;
            entropyTrend /= n;
            speedTrend /= n;
            divergenceTrend /= n;

            // Create prediction message
            let prediction = 'Based on your recent trends:

';

            if (Math.abs(entropyTrend) > 5) {
                prediction += `Your behavioral entropy is ${entropyTrend > 0 ? 'increasing' : 'decreasing'} (${Math.abs(entropyTrend).toFixed(1)}/session).
`;
                prediction += entropyTrend > 0
                    ? 'You are becoming more unpredictable over time.
'
                    : 'You are becoming more predictable and methodical.
';
            }

            if (Math.abs(speedTrend) > 0.5) {
                prediction += `
Your average speed is ${speedTrend > 0 ? 'increasing' : 'decreasing'}.
`;
            }

            if (Math.abs(divergenceTrend) > 2) {
                prediction += `
Divergence from predictions is ${divergenceTrend > 0 ? 'growing' : 'shrinking'}.
`;
                prediction += divergenceTrend > 0
                    ? 'You are becoming harder to predict.'
                    : 'You are becoming more consistent.';
            }

            if (evolutionState.consistencyScore < 50) {
                prediction += '

You are not the same person you were last week.';
            } else if (evolutionState.consistencyScore > 80) {
                prediction += '

You are remarkably consistent across sessions.';
            }

            addLog(' Future prediction generated', 'prediction');
            alert('Future You Prediction:

' + prediction);
        }

        function exportEvolutionHistory() {
            const exportData = {
                totalSessions: evolutionState.allSessions.length,
                totalVisits: evolutionState.totalVisits,
                firstVisit: evolutionState.allSessions.length > 0 ? evolutionState.allSessions[0].timestamp : null,
                lastVisit: evolutionState.lastVisit,
                consistencyScore: evolutionState.consistencyScore,
                sessions: evolutionState.allSessions.map(s => ({
                    timestamp: s.timestamp,
                    date: new Date(s.timestamp).toISOString(),
                    duration: s.duration,
                    signature: s.signature,
                    divergenceScore: s.divergenceScore,
                    depth: s.depth,
                    actionsCount: s.actions.length
                })),
                entropyTrend: evolutionState.entropyTrend,
                analysis: {
                    averageEntropy: evolutionState.entropyTrend.length > 0
                        ? evolutionState.entropyTrend.reduce((sum, e) => sum + e.entropy, 0) / evolutionState.entropyTrend.length
                        : 0,
                    consistency: evolutionState.consistencyScore,
                    identity: evolutionState.consistencyScore > 70 ? 'stable' : evolutionState.consistencyScore > 40 ? 'evolving' : 'transformed'
                },
                exportDate: new Date().toISOString(),
                question: 'Are you the same person you were yesterday?'
            };

            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `behavioral-evolution-history-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);

            addLog(`Exported complete evolution history (${evolutionState.allSessions.length} sessions)`, 'match');
        }

        // Initialize evolution UI on load
        setTimeout(() => {
            showWelcomeMessage();
            updateEvolutionUI();
        }, 500);

        // Save session when page unloads
        window.addEventListener('beforeunload', () => {
            if (state.isObserving || state.actions.length > 0) {
                saveCurrentSession();
            }
        });

        // Periodically save during observation
        setInterval(() => {
            if (state.isObserving && state.actions.length > 20) {
                updateEvolutionUI();
            }
        }, 5000);


        // ===== 3D MODE IMPLEMENTATION =====
        const Mode3D = (function() {
            let canvas, ctx;
            let isActive = false;
            let animationFrame = null;
            let cameraZ = 0;
            let cameraShake = { x: 0, y: 0 };
            let zoomLevel = 1;
            let mouseX = 0.5, mouseY = 0.5;
            let particles = [];
            let ghostSpheres = [];
            let tunnelSegments = [];

            // 3D Projection helper
            function project3D(x, y, z, fov = 500) {
                const scale = fov / (fov + z);
                const shake = cameraShake;
                return {
                    x: (canvas.width / 2) + (x * scale * zoomLevel) + shake.x,
                    y: (canvas.height / 2) + (y * scale * zoomLevel) + shake.y,
                    scale: scale
                };
            }

            // Initialize 3D mode
            function init() {
                canvas = document.getElementById('mode3dCanvas');
                ctx = canvas.getContext('2d');

                // Setup canvas size
                function resize() {
                    canvas.width = canvas.offsetWidth;
                    canvas.height = canvas.offsetHeight;
                }
                resize();
                window.addEventListener('resize', resize);

                // Create tunnel segments
                tunnelSegments = [];
                for (let i = 0; i < state.depth; i++) {
                    tunnelSegments.push({
                        z: i * 200,
                        radius: 150 + i * 30,
                        hue: 200 - i * 15,
                        divergence: 0
                    });
                }

                // Create particles
                particles = [];
                for (let i = 0; i < 100; i++) {
                    particles.push({
                        x: (Math.random() - 0.5) * 300,
                        y: (Math.random() - 0.5) * 300,
                        z: Math.random() * 2000,
                        speed: 1 + Math.random() * 2,
                        size: 1 + Math.random() * 2
                    });
                }

                // Mouse move handler
                const mouseMoveHandler = (e) => {
                    const rect = canvas.getBoundingClientRect();
                    mouseX = (e.clientX - rect.left) / rect.width;
                    mouseY = (e.clientY - rect.top) / rect.height;
                };
                canvas.addEventListener('mousemove', mouseMoveHandler);

                // Mouse wheel zoom
                const wheelHandler = (e) => {
                    e.preventDefault();
                    zoomLevel += e.deltaY * -0.001;
                    zoomLevel = Math.max(0.5, Math.min(3, zoomLevel));
                };
                canvas.addEventListener('wheel', wheelHandler, { passive: false });
            }

            // Update ghost cursor positions in 3D
            function updateGhostSpheres() {
                ghostSpheres = [];
                const cursorPos = {
                    x: (mouseX - 0.5) * canvas.width * 0.8,
                    y: (mouseY - 0.5) * canvas.height * 0.8
                };

                for (let i = 0; i < state.depth; i++) {
                    const depth = i + 1;
                    const layerDivergence = state.divergenceScore * (depth / state.depth);
                    const divergeX = (Math.random() - 0.5) * layerDivergence * 100;
                    const divergeY = (Math.random() - 0.5) * layerDivergence * 100;

                    ghostSpheres.push({
                        x: cursorPos.x + divergeX,
                        y: cursorPos.y + divergeY,
                        z: depth * 200 - cameraZ,
                        depth: depth,
                        divergence: layerDivergence,
                        hue: 200 - (layerDivergence * 100)
                    });
                }
            }

            // Draw tunnel segment
            function drawTunnelSegment(segment, index) {
                const z = segment.z - cameraZ;
                if (z < -50 || z > 2000) return;

                const points = 32;
                const hue = segment.hue + (segment.divergence * 60);
                const saturation = 50 + (segment.divergence * 50);
                const pos = project3D(0, 0, z);

                // Draw tunnel ring
                ctx.beginPath();
                for (let i = 0; i <= points; i++) {
                    const angle = (i / points) * Math.PI * 2;
                    const x = Math.cos(angle) * segment.radius;
                    const y = Math.sin(angle) * segment.radius;
                    const p = project3D(x, y, z);

                    if (i === 0) {
                        ctx.moveTo(p.x, p.y);
                    } else {
                        ctx.lineTo(p.x, p.y);
                    }
                }
                ctx.strokeStyle = `hsla(${hue}, ${saturation}%, ${40 + pos.scale * 30}%, ${0.3 + pos.scale * 0.7})`;
                ctx.lineWidth = 2 * pos.scale;
                ctx.stroke();

                // Draw connecting lines
                if (index > 0) {
                    const prevSegment = tunnelSegments[index - 1];
                    const prevZ = prevSegment.z - cameraZ;

                    for (let i = 0; i < points; i += 4) {
                        const angle = (i / points) * Math.PI * 2;

                        const x1 = Math.cos(angle) * segment.radius;
                        const y1 = Math.sin(angle) * segment.radius;
                        const pos1 = project3D(x1, y1, z);

                        const x2 = Math.cos(angle) * prevSegment.radius;
                        const y2 = Math.sin(angle) * prevSegment.radius;
                        const pos2 = project3D(x2, y2, prevZ);

                        ctx.beginPath();
                        ctx.moveTo(pos1.x, pos1.y);
                        ctx.lineTo(pos2.x, pos2.y);
                        ctx.strokeStyle = `hsla(${hue}, ${saturation}%, 30%, ${0.2 * pos1.scale})`;
                        ctx.lineWidth = 1 * pos1.scale;
                        ctx.stroke();
                    }
                }
            }

            // Draw ghost cursor sphere
            function drawGhostSphere(sphere) {
                if (sphere.z < -50 || sphere.z > 2000) return;

                const pos = project3D(sphere.x, sphere.y, sphere.z);
                const radius = 8 * pos.scale;

                // Glow effect
                const gradient = ctx.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, radius * 2);
                gradient.addColorStop(0, `hsla(${sphere.hue}, 80%, 60%, ${0.8 * pos.scale})`);
                gradient.addColorStop(0.5, `hsla(${sphere.hue}, 70%, 50%, ${0.3 * pos.scale})`);
                gradient.addColorStop(1, `hsla(${sphere.hue}, 60%, 40%, 0)`);

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, radius * 2, 0, Math.PI * 2);
                ctx.fill();

                // Core
                ctx.fillStyle = `hsla(${sphere.hue}, 100%, 70%, ${pos.scale})`;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
                ctx.fill();

                // Depth label
                if (pos.scale > 0.3) {
                    ctx.fillStyle = `rgba(255, 255, 255, ${0.6 * pos.scale})`;
                    ctx.font = `${10 * pos.scale}px monospace`;
                    ctx.textAlign = 'center';
                    ctx.fillText(sphere.depth, pos.x, pos.y - radius - 5);
                }
            }

            // Draw particle
            function drawParticle(particle) {
                const z = particle.z - cameraZ;
                if (z < -50 || z > 2000) return;

                const pos = project3D(particle.x, particle.y, z);
                const size = particle.size * pos.scale;

                // Particle glow
                ctx.fillStyle = `rgba(100, 200, 255, ${0.6 * pos.scale})`;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, size * 2, 0, Math.PI * 2);
                ctx.fill();

                // Particle core
                ctx.fillStyle = `rgba(200, 230, 255, ${pos.scale})`;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, size, 0, Math.PI * 2);
                ctx.fill();
            }

            // Update camera shake based on divergence
            function updateCameraShake() {
                const intensity = state.divergenceScore * 10;
                cameraShake.x = (Math.random() - 0.5) * intensity;
                cameraShake.y = (Math.random() - 0.5) * intensity;
            }

            // Update tunnel segments with divergence
            function updateTunnelSegments() {
                tunnelSegments.forEach((segment, i) => {
                    const targetDivergence = state.divergenceScore * (i / state.depth);
                    segment.divergence += (targetDivergence - segment.divergence) * 0.1;
                    segment.radius = 150 + i * 30 + (segment.divergence * 50);
                });
            }

            // Render loop
            function render() {
                if (!isActive) return;

                // Clear canvas
                ctx.fillStyle = 'rgba(5, 5, 10, 0.95)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Update camera position (auto-move forward)
                cameraZ += 1;

                // Keep tunnel infinite by recycling segments
                tunnelSegments.forEach(segment => {
                    if (segment.z - cameraZ < -200) {
                        segment.z += state.depth * 200;
                    }
                });

                // Update particles
                particles.forEach(particle => {
                    particle.z -= particle.speed;
                    if (particle.z - cameraZ < -50) {
                        particle.z += 2000;
                        particle.x = (Math.random() - 0.5) * 300;
                        particle.y = (Math.random() - 0.5) * 300;
                    }
                });

                // Update effects
                updateCameraShake();
                updateTunnelSegments();
                updateGhostSpheres();

                // Sort and draw tunnel segments (back to front)
                const sortedSegments = [...tunnelSegments].sort((a, b) => (b.z - cameraZ) - (a.z - cameraZ));
                sortedSegments.forEach((segment, i) => drawTunnelSegment(segment, tunnelSegments.indexOf(segment)));

                // Draw particles
                particles.sort((a, b) => (b.z - cameraZ) - (a.z - cameraZ));
                particles.forEach(drawParticle);

                // Draw ghost spheres (back to front)
                ghostSpheres.sort((a, b) => b.z - a.z);
                ghostSpheres.forEach(drawGhostSphere);

                // Draw center crosshair
                ctx.strokeStyle = 'rgba(100, 200, 255, 0.3)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(canvas.width / 2 - 10, canvas.height / 2);
                ctx.lineTo(canvas.width / 2 + 10, canvas.height / 2);
                ctx.moveTo(canvas.width / 2, canvas.height / 2 - 10);
                ctx.lineTo(canvas.width / 2, canvas.height / 2 + 10);
                ctx.stroke();

                // Stats overlay
                ctx.fillStyle = 'rgba(100, 200, 255, 0.8)';
                ctx.font = '12px monospace';
                ctx.textAlign = 'left';
                ctx.fillText(`Depth: ${state.depth} | Zoom: ${zoomLevel.toFixed(1)}x | Divergence: ${(state.divergenceScore * 100).toFixed(0)}%`, 10, canvas.height - 10);

                animationFrame = requestAnimationFrame(render);
            }

            // Toggle 3D mode
            function toggle(enabled) {
                isActive = enabled;
                const canvasEl = document.getElementById('mode3dCanvas');
                const info = document.getElementById('mode3dInfo');
                const toggleEl = document.getElementById('mode3dToggle');

                if (enabled) {
                    init();
                    canvasEl.classList.add('active');
                    info.classList.add('active');
                    toggleEl.classList.add('active');
                    render();

                    // Hide info after 3 seconds
                    setTimeout(() => {
                        info.classList.remove('active');
                    }, 3000);
                } else {
                    canvasEl.classList.remove('active');
                    info.classList.remove('active');
                    toggleEl.classList.remove('active');
                    if (animationFrame) {
                        cancelAnimationFrame(animationFrame);
                    }
                }
            }

            // Update depth when depth slider changes
            function updateDepth(newDepth) {
                if (!isActive) return;

                // Adjust tunnel segments
                const currentCount = tunnelSegments.length;
                if (newDepth > currentCount) {
                    for (let i = currentCount; i < newDepth; i++) {
                        tunnelSegments.push({
                            z: i * 200,
                            radius: 150 + i * 30,
                            hue: 200 - i * 15,
                            divergence: 0
                        });
                    }
                } else if (newDepth < currentCount) {
                    tunnelSegments.splice(newDepth);
                }
            }

            return {
                toggle: toggle,
                updateDepth: updateDepth,
                isActive: () => isActive
            };
        })();

        // Setup 3D mode toggle
        const mode3dCheckbox = document.getElementById('mode3dCheckbox');
        if (mode3dCheckbox) {
            mode3dCheckbox.addEventListener('change', function() {
                Mode3D.toggle(this.checked);
            });
        }

        // Update 3D depth when depth slider changes
        const depthSliderFor3D = document.getElementById('depthSlider');
        if (depthSliderFor3D) {
            depthSliderFor3D.addEventListener('input', function() {
                Mode3D.updateDepth(parseInt(this.value));
            });
        }


        // ===== MEMORY PALACE MODE =====
        const MemoryPalace = (() => {
            let isActive = false;
            let canvas, ctx, info, mapEl, centerMirror;
            let currentRoom = 0;
            let rooms = [];
            let echoes = [];
            let animationFrame = null;
            let cursorX = 0, cursorY = 0;
            let visitedRooms = new Set();
            let navigationTimer = null;
            let echoAnimationTimer = null;

            const architecturePatterns = [
                { name: 'Chaotic Chamber', walls: 'jagged', color: [255, 100, 100] },
                { name: 'Smooth Sanctuary', walls: 'curved', color: [100, 200, 255] },
                { name: 'Precise Palace', walls: 'geometric', color: [150, 255, 150] },
                { name: 'Lazy Labyrinth', walls: 'organic', color: [255, 200, 100] },
                { name: 'Erratic Expanse', walls: 'fractured', color: [255, 150, 255] },
                { name: 'Calm Corridor', walls: 'minimal', color: [150, 200, 255] },
                { name: 'Hesitant Hall', walls: 'scattered', color: [200, 200, 100] },
                { name: 'Flowing Forum', walls: 'wavy', color: [100, 255, 200] },
                { name: 'Center of Self', walls: 'radial', color: [184, 150, 255] }
            ];

            function init() {
                canvas = document.getElementById('memoryPalaceCanvas');
                ctx = canvas.getContext('2d');
                info = document.getElementById('memoryPalaceInfo');
                mapEl = document.getElementById('memoryPalaceMap');
                centerMirror = document.getElementById('centerMirror');

                loadRoomsFromSessions();
                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);
                canvas.addEventListener('mousemove', handleMouseMove);
                canvas.addEventListener('click', handleClick);
            }

            function resizeCanvas() {
                if (!canvas) return;
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
            }

            function loadRoomsFromSessions() {
                rooms = [];

                if (evolutionState.allSessions && evolutionState.allSessions.length > 0) {
                    evolutionState.allSessions.forEach((session, idx) => {
                        rooms.push(createRoomFromSession(session, idx));
                    });
                } else {
                    const currentSessionData = {
                        timestamp: Date.now(),
                        divergenceScore: state.divergenceScore,
                        actions: state.actions.slice(0, 100),
                        behaviorModel: JSON.parse(JSON.stringify(state.behaviorModel)),
                        emotionHistory: state.emotionState.history.slice(0, 50)
                    };
                    rooms.push(createRoomFromSession(currentSessionData, 0));
                }

                rooms.push({
                    id: rooms.length,
                    name: 'Center of Self',
                    pattern: architecturePatterns[8],
                    divergence: 0,
                    cursorTrails: [],
                    fingerprints: [],
                    artifacts: [],
                    atmosphere: { hue: 270, saturation: 60, brightness: 50 }
                });

                updateMap();
            }

            function createRoomFromSession(session, index) {
                const divergence = session.divergenceScore || 0;
                const movementStyle = session.behaviorModel?.movementStyle || 'unknown';

                let patternIndex = 0;
                if (movementStyle === 'erratic') patternIndex = 0;
                else if (movementStyle === 'smooth') patternIndex = 1;
                else if (movementStyle === 'precise') patternIndex = 2;
                else if (movementStyle === 'lazy') patternIndex = 3;
                else patternIndex = 4;

                const pattern = architecturePatterns[patternIndex];
                const cursorTrails = (session.actions || [])
                    .filter(a => a.type === 'mousemove')
                    .map(a => ({ x: a.x, y: a.y, t: a.timestamp }));
                const fingerprints = (session.actions || [])
                    .filter(a => a.type === 'click')
                    .map(a => ({ x: a.x, y: a.y, t: a.timestamp }));
                const artifacts = createArtifactsFromSession(session);
                const atmosphereHue = divergence < 30 ? 120 : divergence < 60 ? 200 : 0;
                const atmosphereSat = 40 + divergence * 0.5;
                const date = new Date(session.timestamp || Date.now());
                const roomName = `Session ${index + 1} (${date.toLocaleDateString()})`;

                return {
                    id: index,
                    name: roomName,
                    pattern: pattern,
                    divergence: divergence,
                    cursorTrails: cursorTrails,
                    fingerprints: fingerprints,
                    artifacts: artifacts,
                    atmosphere: { hue: atmosphereHue, saturation: atmosphereSat, brightness: 30 }
                };
            }

            function createArtifactsFromSession(session) {
                const artifacts = [];
                artifacts.push({
                    x: Math.random() * 0.8 + 0.1,
                    y: Math.random() * 0.8 + 0.1,
                    icon: '',
                    tooltip: `Divergence: ${(session.divergenceScore || 0).toFixed(1)}%`,
                    data: { type: 'divergence', value: session.divergenceScore }
                });
                if (session.behaviorModel?.movementStyle) {
                    artifacts.push({
                        x: Math.random() * 0.8 + 0.1,
                        y: Math.random() * 0.8 + 0.1,
                        icon: '',
                        tooltip: `Style: ${session.behaviorModel.movementStyle}`,
                        data: { type: 'style', value: session.behaviorModel.movementStyle }
                    });
                }
                if (session.actions) {
                    artifacts.push({
                        x: Math.random() * 0.8 + 0.1,
                        y: Math.random() * 0.8 + 0.1,
                        icon: '',
                        tooltip: `Actions: ${session.actions.length}`,
                        data: { type: 'actions', value: session.actions.length }
                    });
                }
                if (session.emotionHistory and session.emotionHistory.length > 0) {
                    const lastEmotion = session.emotionHistory[session.emotionHistory.length - 1];
                    artifacts.push({
                        x: Math.random() * 0.8 + 0.1,
                        y: Math.random() * 0.8 + 0.1,
                        icon: lastEmotion?.icon || '',
                        tooltip: `Emotion: ${lastEmotion?.emotion || 'neutral'}`,
                        data: { type: 'emotion', value: lastEmotion }
                    });
                }
                return artifacts;
            }

            function updateMap() {
                if (!mapEl) return;
                const mapGrid = mapEl.querySelector('#mapGrid');
                if (!mapGrid) return;
                mapGrid.innerHTML = '';
                const gridSize = Math.ceil(Math.sqrt(rooms.length));
                mapGrid.style.gridTemplateColumns = `repeat(${gridSize}, 40px)`;
                rooms.forEach((room, idx) => {
                    const roomDiv = document.createElement('div');
                    roomDiv.className = 'map-room';
                    roomDiv.textContent = idx + 1;
                    if (idx === currentRoom) roomDiv.classList.add('current');
                    if (visitedRooms.has(idx)) roomDiv.classList.add('visited');
                    roomDiv.addEventListener('click', () => navigateToRoom(idx));
                    mapGrid.appendChild(roomDiv);
                });
            }

            function navigateToRoom(roomId) {
                if (roomId < 0 || roomId >= rooms.length) return;
                currentRoom = roomId;
                visitedRooms.add(roomId);
                updateMap();
                echoes = [];
                if (echoAnimationTimer) clearInterval(echoAnimationTimer);
                startEchoAnimation();
                if (rooms[currentRoom].name === 'Center of Self') {
                    centerMirror.classList.add('active');
                } else {
                    centerMirror.classList.remove('active');
                }
            }

            function startEchoAnimation() {
                const room = rooms[currentRoom];
                if (!room || !room.cursorTrails || room.cursorTrails.length === 0) return;
                let echoIndex = 0;
                echoAnimationTimer = setInterval(() => {
                    if (echoIndex >= room.cursorTrails.length) {
                        echoIndex = 0;
                        echoes = [];
                    }
                    const point = room.cursorTrails[echoIndex];
                    echoes.push({ x: point.x, y: point.y, age: 0, maxAge: 100 });
                    if (echoes.length > 200) echoes.shift();
                    echoIndex++;
                }, 50);
            }

            function handleMouseMove(e) {
                const rect = canvas.getBoundingClientRect();
                cursorX = e.clientX - rect.left;
                cursorY = e.clientY - rect.top;
                const edgeThreshold = 50;
                const width = canvas.width;
                const height = canvas.height;
                clearTimeout(navigationTimer);
                if (cursorX < edgeThreshold && currentRoom > 0) {
                    navigationTimer = setTimeout(() => navigateToRoom(currentRoom - 1), 500);
                } else if (cursorX > width - edgeThreshold && currentRoom < rooms.length - 1) {
                    navigationTimer = setTimeout(() => navigateToRoom(currentRoom + 1), 500);
                } else if (cursorY < edgeThreshold && currentRoom >= 3) {
                    navigationTimer = setTimeout(() => navigateToRoom(currentRoom - 3), 500);
                } else if (cursorY > height - edgeThreshold && currentRoom < rooms.length - 3) {
                    navigationTimer = setTimeout(() => navigateToRoom(currentRoom + 3), 500);
                }
            }

            function handleClick(e) {
                const rect = canvas.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                const clickY = e.clientY - rect.top;
                const room = rooms[currentRoom];
                if (!room) return;
                room.artifacts.forEach(artifact => {
                    const artX = artifact.x * canvas.width;
                    const artY = artifact.y * canvas.height;
                    const dist = Math.sqrt((clickX - artX) ** 2 + (clickY - artY) ** 2);
                    if (dist < 30) showArtifactInfo(artifact);
                });
            }

            function showArtifactInfo(artifact) {
                const logEntries = document.getElementById('logEntries');
                if (logEntries) {
                    const entry = document.createElement('div');
                    entry.style.padding = '8px';
                    entry.style.borderLeft = '3px solid #ffbf64';
                    entry.style.marginBottom = '5px';
                    entry.style.background = 'rgba(255, 200, 100, 0.1)';
                    entry.innerHTML = `<strong>Memory Palace:</strong> ${artifact.tooltip}`;
                    logEntries.insertBefore(entry, logEntries.firstChild);
                }
                if (soundEnabled && audioContext) {
                    playTone(600 + Math.random() * 400, 0.1, 0.3);
                }
            }

            function render() {
                if (!isActive || !ctx || !canvas) return;
                const width = canvas.width;
                const height = canvas.height;
                ctx.fillStyle = 'rgba(5, 5, 15, 1)';
                ctx.fillRect(0, 0, width, height);
                const room = rooms[currentRoom];
                if (!room) return;
                const atmosphere = room.atmosphere;
                const gradient = ctx.createRadialGradient(width / 2, height / 2, 0, width / 2, height / 2, width * 0.7);
                gradient.addColorStop(0, `hsla(${atmosphere.hue}, ${atmosphere.saturation}%, ${atmosphere.brightness}%, 0.3)`);
                gradient.addColorStop(1, `hsla(${atmosphere.hue}, ${atmosphere.saturation}%, ${atmosphere.brightness}%, 0.05)`);
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, width, height);
                drawArchitecture(room, width, height);
                drawEchoes(width, height);
                drawFingerprints(room, width, height);
                drawArtifacts(room, width, height);
                ctx.fillStyle = 'rgba(184, 150, 255, 0.8)';
                ctx.font = '20px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText(room.name, width / 2, 40);
                if (rooms[currentRoom].name === 'Center of Self') {
                    ctx.fillStyle = 'rgba(184, 150, 255, 0.6)';
                    ctx.font = '16px Courier New';
                    ctx.textAlign = 'center';
                    ctx.fillText('This is where your patterns live', width / 2, height - 40);
                }
                echoes.forEach(echo => echo.age++);
                echoes = echoes.filter(echo => echo.age < echo.maxAge);
                animationFrame = requestAnimationFrame(render);
            }

            function drawArchitecture(room, width, height) {
                const pattern = room.pattern;
                const [r, g, b] = pattern.color;
                ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.3)`;
                ctx.lineWidth = 2;
                switch (pattern.walls) {
                    case 'jagged': drawJaggedWalls(width, height); break;
                    case 'curved': drawCurvedWalls(width, height); break;
                    case 'geometric': drawGeometricWalls(width, height); break;
                    case 'organic': drawOrganicWalls(width, height); break;
                    case 'fractured': drawFracturedWalls(width, height); break;
                    case 'minimal': drawMinimalWalls(width, height); break;
                    case 'scattered': drawScatteredWalls(width, height); break;
                    case 'wavy': drawWavyWalls(width, height); break;
                    case 'radial': drawRadialWalls(width, height); break;
                }
            }

            function drawJaggedWalls(w, h) {
                ctx.beginPath();
                for (let i = 0; i < 20; i++) {
                    const x = Math.random() * w;
                    const y = Math.random() * h;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }

            function drawCurvedWalls(w, h) {
                ctx.beginPath();
                for (let angle = 0; angle < Math.PI * 2; angle += 0.1) {
                    const r = Math.min(w, h) * 0.4;
                    const x = w / 2 + Math.cos(angle) * r;
                    const y = h / 2 + Math.sin(angle) * r;
                    if (angle === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.stroke();
            }

            function drawGeometricWalls(w, h) {
                const size = Math.min(w, h) * 0.3;
                ctx.strokeRect(w / 2 - size, h / 2 - size, size * 2, size * 2);
                ctx.strokeRect(w / 2 - size / 2, h / 2 - size / 2, size, size);
            }

            function drawOrganicWalls(w, h) {
                ctx.beginPath();
                for (let angle = 0; angle < Math.PI * 2; angle += 0.2) {
                    const r = Math.min(w, h) * (0.3 + Math.sin(angle * 3) * 0.1);
                    const x = w / 2 + Math.cos(angle) * r;
                    const y = h / 2 + Math.sin(angle) * r;
                    if (angle === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.stroke();
            }

            function drawFracturedWalls(w, h) {
                for (let i = 0; i < 15; i++) {
                    ctx.beginPath();
                    ctx.moveTo(Math.random() * w, Math.random() * h);
                    ctx.lineTo(Math.random() * w, Math.random() * h);
                    ctx.stroke();
                }
            }

            function drawMinimalWalls(w, h) {
                ctx.strokeRect(50, 50, w - 100, h - 100);
            }

            function drawScatteredWalls(w, h) {
                for (let i = 0; i < 30; i++) {
                    const x = Math.random() * w;
                    const y = Math.random() * h;
                    ctx.fillStyle = `rgba(200, 200, 100, ${Math.random() * 0.3})`;
                    ctx.fillRect(x, y, 5, 5);
                }
            }

            function drawWavyWalls(w, h) {
                ctx.beginPath();
                for (let x = 0; x < w; x += 5) {
                    const y = h / 2 + Math.sin(x * 0.02) * 100;
                    if (x === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }

            function drawRadialWalls(w, h) {
                const centerX = w / 2;
                const centerY = h / 2;
                for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 8) {
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    ctx.lineTo(centerX + Math.cos(angle) * Math.min(w, h) * 0.4,
                              centerY + Math.sin(angle) * Math.min(w, h) * 0.4);
                    ctx.stroke();
                }
            }

            function drawEchoes(width, height) {
                echoes.forEach(echo => {
                    const alpha = 1 - (echo.age / echo.maxAge);
                    const size = 3 + (echo.age / echo.maxAge) * 5;
                    ctx.fillStyle = `rgba(184, 150, 255, ${alpha * 0.4})`;
                    ctx.beginPath();
                    ctx.arc(echo.x, echo.y, size, 0, Math.PI * 2);
                    ctx.fill();
                });
            }

            function drawFingerprints(room, width, height) {
                room.fingerprints.forEach((fp, idx) => {
                    ctx.strokeStyle = 'rgba(255, 200, 100, 0.3)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(fp.x, fp.y, 10 + idx % 5, 0, Math.PI * 2);
                    ctx.stroke();
                });
            }

            function drawArtifacts(room, width, height) {
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                room.artifacts.forEach(artifact => {
                    const x = artifact.x * width;
                    const y = artifact.y * height;
                    const pulse = Math.sin(Date.now() * 0.003) * 0.3 + 0.7;
                    ctx.shadowColor = 'rgba(255, 200, 100, 0.8)';
                    ctx.shadowBlur = 20 * pulse;
                    ctx.fillText(artifact.icon, x, y);
                    ctx.shadowBlur = 0;
                    const dist = Math.sqrt((cursorX - x) ** 2 + (cursorY - y) ** 2);
                    if (dist < 40) {
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
                        ctx.fillRect(x - 60, y + 30, 120, 30);
                        ctx.strokeStyle = 'rgba(255, 200, 100, 0.6)';
                        ctx.strokeRect(x - 60, y + 30, 120, 30);
                        ctx.fillStyle = '#ffbf64';
                        ctx.font = '12px Courier New';
                        ctx.fillText(artifact.tooltip, x, y + 45);
                        ctx.font = '24px Arial';
                    }
                });
            }

            function toggle(enabled) {
                isActive = enabled;
                const toggleEl = document.getElementById('memoryPalaceToggle');
                if (enabled) {
                    if (!canvas) init();
                    canvas.classList.add('active');
                    info.classList.add('active');
                    mapEl.classList.add('active');
                    toggleEl.classList.add('active');
                    loadRoomsFromSessions();
                    visitedRooms.add(currentRoom);
                    startEchoAnimation();
                    render();
                    setTimeout(() => { info.classList.remove('active'); }, 5000);
                } else {
                    canvas.classList.remove('active');
                    info.classList.remove('active');
                    mapEl.classList.remove('active');
                    centerMirror.classList.remove('active');
                    toggleEl.classList.remove('active');
                    if (animationFrame) cancelAnimationFrame(animationFrame);
                    if (echoAnimationTimer) clearInterval(echoAnimationTimer);
                }
            }

            return {
                toggle: toggle,
                isActive: () => isActive
            };
        })();

        const memoryPalaceCheckbox = document.getElementById('memoryPalaceCheckbox');
        if (memoryPalaceCheckbox) {
            memoryPalaceCheckbox.addEventListener('change', function() {
                if (this.checked && Mode3D.isActive()) {
                    const mode3dCheckbox = document.getElementById('mode3dCheckbox');
                    if (mode3dCheckbox) {
                        mode3dCheckbox.checked = false;
                        Mode3D.toggle(false);
                    }
                }
                MemoryPalace.toggle(this.checked);
            });
        }

    </script>

    <!-- Replay Timeline -->
    <div class="replay-timeline" id="replayTimeline">
        <div class="timeline-scrubber" id="timelineScrubber">
            <div class="timeline-progress" id="timelineProgress"></div>
            <div class="timeline-events" id="timelineEvents"></div>
            <div class="timeline-playhead" id="timelinePlayhead"></div>
        </div>
        <div class="replay-controls">
            <button class="replay-button" id="replayPlayBtn"> Play</button>
            <button class="replay-button" id="replayPauseBtn" disabled> Pause</button>
            <button class="replay-button" id="replayRewindBtn"> Rewind</button>
            <div class="speed-control">
                <span style="font-size: 0.75em; color: #888; margin-right: 8px;">Speed:</span>
                <button class="speed-button" data-speed="0.5">0.5x</button>
                <button class="speed-button active" data-speed="1">1x</button>
                <button class="speed-button" data-speed="2">2x</button>
                <button class="speed-button" data-speed="4">4x</button>
            </div>
            <div class="time-display" id="timeDisplay">0:00 / 0:00</div>
        </div>
    </div>

</body>
</html>
