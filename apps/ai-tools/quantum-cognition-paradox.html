<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Algorithm That Only Works If You Don't Understand It</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --void: #0a0a0f;
            --deep: #12121a;
            --surface: #1a1a24;
            --border: #2a2a3a;
            --text-dim: #6a6a7a;
            --text: #9a9aaa;
            --text-bright: #dadaea;
            --accent: #7a4aff;
            --accent-glow: #9a6aff;
            --danger: #ff4a6a;
            --warning: #ffaa4a;
            --success: #4affaa;
            --quantum: #4a9aff;
        }

        body {
            font-family: 'Courier New', monospace;
            background: var(--void);
            color: var(--text);
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* Quantum interference pattern background */
        .quantum-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
            opacity: 0.15;
            background:
                repeating-linear-gradient(
                    0deg,
                    transparent,
                    transparent 2px,
                    rgba(122, 74, 255, 0.03) 2px,
                    rgba(122, 74, 255, 0.03) 4px
                );
            animation: interference 20s linear infinite;
        }

        @keyframes interference {
            0% { transform: translateY(0); }
            100% { transform: translateY(4px); }
        }

        /* Data controls */
        .data-controls {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1000;
            display: flex;
            gap: 8px;
        }

        .data-controls button {
            padding: 8px 14px;
            background: var(--surface);
            border: 1px solid var(--border);
            color: var(--text-dim);
            font-family: inherit;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .data-controls button:hover {
            background: var(--deep);
            color: var(--text);
            border-color: var(--accent);
        }

        /* Main container */
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 60px 20px 40px;
        }

        /* Title section */
        .title-section {
            text-align: center;
            margin-bottom: 40px;
            position: relative;
        }

        .title-section h1 {
            font-size: clamp(1.2rem, 3vw, 1.8rem);
            font-weight: normal;
            color: var(--text-bright);
            letter-spacing: 2px;
            text-transform: uppercase;
            margin-bottom: 10px;
            transition: all 0.5s;
        }

        .title-section.degraded h1 {
            opacity: 0.5;
            filter: blur(1px);
        }

        .subtitle {
            font-size: 12px;
            color: var(--text-dim);
            font-style: italic;
        }

        /* Comprehension meter */
        .comprehension-section {
            background: var(--deep);
            border: 1px solid var(--border);
            padding: 30px;
            margin-bottom: 30px;
            position: relative;
            overflow: hidden;
        }

        .comprehension-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .comprehension-label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: var(--text-dim);
        }

        .comprehension-value {
            font-size: 24px;
            color: var(--quantum);
            font-weight: bold;
            transition: color 0.5s;
        }

        .comprehension-value.warning {
            color: var(--warning);
        }

        .comprehension-value.danger {
            color: var(--danger);
        }

        .comprehension-bar {
            height: 40px;
            background: var(--void);
            border: 1px solid var(--border);
            position: relative;
            overflow: hidden;
        }

        .comprehension-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--quantum), var(--accent));
            transition: width 0.5s ease, background 0.5s;
            position: relative;
        }

        .comprehension-fill.warning {
            background: linear-gradient(90deg, var(--warning), var(--danger));
        }

        .comprehension-fill.danger {
            background: linear-gradient(90deg, var(--danger), #ff0040);
        }

        /* Wave pattern overlay */
        .wave-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 200%;
            height: 100%;
            background: repeating-linear-gradient(
                90deg,
                transparent 0px,
                transparent 10px,
                rgba(255,255,255,0.1) 10px,
                rgba(255,255,255,0.1) 11px
            );
            animation: wave-scroll 2s linear infinite;
        }

        @keyframes wave-scroll {
            0% { transform: translateX(0); }
            100% { transform: translateX(-50%); }
        }

        .threshold-marker {
            position: absolute;
            top: 0;
            height: 100%;
            width: 2px;
            background: var(--danger);
            z-index: 2;
        }

        .threshold-marker::after {
            content: 'COLLAPSE';
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 9px;
            color: var(--danger);
            white-space: nowrap;
        }

        /* Main interface grid */
        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        @media (max-width: 800px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }

        /* Algorithm panel */
        .algorithm-panel {
            background: var(--deep);
            border: 1px solid var(--border);
            padding: 25px;
            position: relative;
            transition: all 0.5s;
        }

        .algorithm-panel.degraded {
            border-color: var(--danger);
            box-shadow: 0 0 30px rgba(255, 74, 106, 0.2);
        }

        .algorithm-panel.collapsed {
            animation: collapse-flash 0.5s ease;
        }

        @keyframes collapse-flash {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; background: var(--danger); }
        }

        .panel-title {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: var(--text-dim);
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .panel-title .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--success);
            animation: pulse 2s infinite;
        }

        .panel-title .status-dot.degraded {
            background: var(--warning);
        }

        .panel-title .status-dot.collapsed {
            background: var(--danger);
            animation: none;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Task interface */
        .task-area {
            min-height: 200px;
        }

        .input-group {
            margin-bottom: 15px;
        }

        .input-group label {
            display: block;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-dim);
            margin-bottom: 8px;
        }

        .input-group input,
        .input-group textarea {
            width: 100%;
            padding: 12px;
            background: var(--void);
            border: 1px solid var(--border);
            color: var(--text-bright);
            font-family: inherit;
            font-size: 14px;
            transition: all 0.3s;
        }

        .input-group input:focus,
        .input-group textarea:focus {
            outline: none;
            border-color: var(--accent);
        }

        .input-group textarea {
            resize: vertical;
            min-height: 80px;
        }

        .btn {
            padding: 12px 24px;
            background: var(--accent);
            border: none;
            color: white;
            font-family: inherit;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 2px;
            cursor: pointer;
            transition: all 0.3s;
            width: 100%;
        }

        .btn:hover {
            background: var(--accent-glow);
            box-shadow: 0 0 20px rgba(122, 74, 255, 0.4);
        }

        .btn:disabled {
            background: var(--border);
            cursor: not-allowed;
            box-shadow: none;
        }

        .btn.danger {
            background: transparent;
            border: 1px solid var(--danger);
            color: var(--danger);
        }

        .btn.danger:hover {
            background: var(--danger);
            color: white;
        }

        /* Results display */
        .results-area {
            margin-top: 20px;
            padding: 15px;
            background: var(--void);
            border: 1px solid var(--border);
            min-height: 100px;
            position: relative;
        }

        .results-area .result-text {
            font-size: 14px;
            line-height: 1.6;
            color: var(--text-bright);
            transition: all 0.3s;
        }

        .results-area .result-text.glitched {
            animation: text-glitch 0.1s infinite;
        }

        @keyframes text-glitch {
            0% { transform: translate(0); }
            20% { transform: translate(-2px, 2px); }
            40% { transform: translate(2px, -2px); }
            60% { transform: translate(-1px, 1px); }
            80% { transform: translate(1px, -1px); }
            100% { transform: translate(0); }
        }

        .accuracy-indicator {
            margin-top: 10px;
            font-size: 10px;
            color: var(--text-dim);
        }

        .accuracy-indicator .value {
            color: var(--success);
            font-weight: bold;
        }

        .accuracy-indicator .value.degraded {
            color: var(--warning);
        }

        .accuracy-indicator .value.failed {
            color: var(--danger);
        }

        /* Observation panel */
        .observation-panel {
            background: var(--deep);
            border: 1px solid var(--border);
            padding: 25px;
        }

        .observe-btn {
            padding: 15px;
            background: transparent;
            border: 1px dashed var(--accent);
            color: var(--accent);
            font-family: inherit;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 2px;
            cursor: pointer;
            width: 100%;
            margin-bottom: 20px;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }

        .observe-btn:hover {
            background: rgba(122, 74, 255, 0.1);
            border-style: solid;
        }

        .observe-btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255, 74, 106, 0.3);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.5s;
        }

        .observe-btn:active::before {
            width: 300px;
            height: 300px;
        }

        .internals-display {
            background: var(--void);
            border: 1px solid var(--border);
            padding: 15px;
            font-size: 10px;
            line-height: 1.8;
            color: var(--text-dim);
            max-height: 200px;
            overflow-y: auto;
            position: relative;
        }

        .internals-display.revealed {
            color: var(--text);
        }

        .internals-display .code-line {
            opacity: 0;
            transition: opacity 0.3s;
        }

        .internals-display .code-line.visible {
            opacity: 1;
        }

        .warning-text {
            color: var(--danger);
            font-size: 10px;
            margin-top: 15px;
            text-align: center;
            opacity: 0;
            transition: opacity 0.5s;
        }

        .warning-text.visible {
            opacity: 1;
        }

        /* Forget mechanism */
        .forget-section {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid var(--border);
        }

        .forget-instructions {
            font-size: 10px;
            color: var(--text-dim);
            margin-bottom: 15px;
            line-height: 1.6;
        }

        .forget-btn {
            padding: 12px;
            background: transparent;
            border: 1px solid var(--success);
            color: var(--success);
            font-family: inherit;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            width: 100%;
            transition: all 0.3s;
        }

        .forget-btn:hover {
            background: rgba(74, 255, 170, 0.1);
        }

        .forget-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        /* Narration */
        .narration {
            background: var(--deep);
            border-left: 3px solid var(--accent);
            padding: 25px;
            margin-bottom: 30px;
            position: relative;
        }

        .narration-text {
            font-style: italic;
            font-size: 14px;
            line-height: 1.8;
            color: var(--text);
            opacity: 0;
            animation: fade-in 1s forwards;
        }

        @keyframes fade-in {
            to { opacity: 1; }
        }

        .narration-attribution {
            margin-top: 15px;
            font-size: 10px;
            color: var(--text-dim);
            text-align: right;
        }

        /* History log */
        .history-section {
            background: var(--deep);
            border: 1px solid var(--border);
            padding: 25px;
        }

        .history-list {
            max-height: 300px;
            overflow-y: auto;
        }

        .history-item {
            padding: 12px;
            background: var(--void);
            border: 1px solid var(--border);
            margin-bottom: 10px;
            font-size: 11px;
        }

        .history-item .timestamp {
            color: var(--text-dim);
            font-size: 9px;
            margin-bottom: 5px;
        }

        .history-item .query {
            color: var(--text);
            margin-bottom: 5px;
        }

        .history-item .result {
            color: var(--quantum);
        }

        .history-item .accuracy {
            margin-top: 5px;
            font-size: 9px;
        }

        .history-item .accuracy.good {
            color: var(--success);
        }

        .history-item .accuracy.degraded {
            color: var(--warning);
        }

        .history-item .accuracy.failed {
            color: var(--danger);
        }

        /* Collapse overlay */
        .collapse-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--void);
            z-index: 999;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s;
        }

        .collapse-overlay.active {
            opacity: 1;
            pointer-events: all;
        }

        .collapse-message {
            font-size: 14px;
            color: var(--danger);
            text-transform: uppercase;
            letter-spacing: 4px;
            margin-bottom: 20px;
            animation: flicker 0.5s infinite;
        }

        @keyframes flicker {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .collapse-explanation {
            max-width: 500px;
            text-align: center;
            font-size: 12px;
            line-height: 1.8;
            color: var(--text-dim);
            margin-bottom: 30px;
        }

        /* Stats footer */
        .stats-footer {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            padding: 20px;
            background: var(--deep);
            border: 1px solid var(--border);
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 24px;
            color: var(--quantum);
            font-weight: bold;
        }

        .stat-label {
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-dim);
            margin-top: 5px;
        }

        /* Glitch effects */
        .glitch-container {
            position: relative;
        }

        .glitch-container.active::before,
        .glitch-container.active::after {
            content: attr(data-text);
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .glitch-container.active::before {
            animation: glitch-1 0.2s infinite;
            color: var(--danger);
            z-index: -1;
        }

        .glitch-container.active::after {
            animation: glitch-2 0.3s infinite;
            color: var(--quantum);
            z-index: -2;
        }

        @keyframes glitch-1 {
            0% { clip-path: inset(40% 0 61% 0); transform: translate(-2px, 0); }
            20% { clip-path: inset(92% 0 1% 0); transform: translate(2px, 0); }
            40% { clip-path: inset(43% 0 1% 0); transform: translate(-2px, 0); }
            60% { clip-path: inset(25% 0 58% 0); transform: translate(0); }
            80% { clip-path: inset(54% 0 7% 0); transform: translate(2px, 0); }
            100% { clip-path: inset(58% 0 43% 0); transform: translate(-2px, 0); }
        }

        @keyframes glitch-2 {
            0% { clip-path: inset(65% 0 13% 0); transform: translate(2px, 0); }
            20% { clip-path: inset(10% 0 60% 0); transform: translate(-2px, 0); }
            40% { clip-path: inset(45% 0 37% 0); transform: translate(0); }
            60% { clip-path: inset(17% 0 63% 0); transform: translate(2px, 0); }
            80% { clip-path: inset(73% 0 19% 0); transform: translate(-2px, 0); }
            100% { clip-path: inset(28% 0 55% 0); transform: translate(2px, 0); }
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: var(--void);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border);
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent);
        }

        /* Mobile responsive */
        @media (max-width: 600px) {
            .container {
                padding: 80px 15px 30px;
            }

            .comprehension-section,
            .algorithm-panel,
            .observation-panel,
            .narration,
            .history-section {
                padding: 20px;
            }

            .data-controls {
                top: auto;
                bottom: 10px;
                right: 10px;
            }

            .stats-footer {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="quantum-bg"></div>

    <div class="data-controls">
        <button onclick="exportData()">Export</button>
        <button onclick="document.getElementById('importFile').click()">Import</button>
        <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importData(event)">
    </div>

    <div class="container">
        <div class="title-section" id="titleSection">
            <h1>The Algorithm That Only Works If You Don't Understand It</h1>
            <p class="subtitle">Observation collapses the wave function of knowledge</p>
        </div>

        <!-- Comprehension Meter -->
        <div class="comprehension-section">
            <div class="comprehension-header">
                <span class="comprehension-label">Comprehension Level</span>
                <span class="comprehension-value" id="comprehensionValue">0%</span>
            </div>
            <div class="comprehension-bar">
                <div class="comprehension-fill" id="comprehensionFill">
                    <div class="wave-overlay"></div>
                </div>
                <div class="threshold-marker" style="left: 75%"></div>
            </div>
        </div>

        <!-- Narration -->
        <div class="narration" id="narrationBox">
            <p class="narration-text" id="narrationText">
                "The universe is not only queerer than we suppose, but queerer than we can suppose.
                Perhaps the same is true of understanding itself - that to truly comprehend something
                is to destroy the very thing we sought to know."
            </p>
            <p class="narration-attribution">- The Algorithm</p>
        </div>

        <!-- Main Grid -->
        <div class="main-grid">
            <!-- Algorithm Panel -->
            <div class="algorithm-panel" id="algorithmPanel">
                <div class="panel-title">
                    <span class="status-dot" id="statusDot"></span>
                    Pattern Recognition Engine
                </div>
                <div class="task-area">
                    <div class="input-group">
                        <label>Enter a sequence to analyze</label>
                        <input type="text" id="sequenceInput" placeholder="e.g., 2, 4, 8, 16, ?" autocomplete="off">
                    </div>
                    <div class="input-group">
                        <label>Or describe a pattern to predict</label>
                        <textarea id="patternInput" placeholder="e.g., Every third day the value doubles..."></textarea>
                    </div>
                    <button class="btn" id="analyzeBtn" onclick="analyzePattern()">
                        Let the Algorithm Work
                    </button>
                    <div class="results-area" id="resultsArea">
                        <div class="result-text" id="resultText">
                            The algorithm awaits your query. It knows what you seek,
                            though it cannot explain how.
                        </div>
                        <div class="accuracy-indicator" id="accuracyIndicator" style="display: none;">
                            Prediction Accuracy: <span class="value" id="accuracyValue">100%</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Observation Panel -->
            <div class="observation-panel">
                <div class="panel-title">
                    <span class="status-dot" id="observeStatusDot"></span>
                    Observation Chamber
                </div>

                <button class="observe-btn" id="observeBtn" onclick="observeProcess()">
                    [ Peer Into the Inner Workings ]
                </button>

                <div class="internals-display" id="internalsDisplay">
                    <div class="code-line" data-reveal="1">// The pattern recognition begins here</div>
                    <div class="code-line" data-reveal="2">function analyzeSequence(input) {</div>
                    <div class="code-line" data-reveal="3">    // Neural pathways activate...</div>
                    <div class="code-line" data-reveal="4">    const hidden = extractHiddenStructure(input);</div>
                    <div class="code-line" data-reveal="5">    // Quantum superposition of all possible patterns</div>
                    <div class="code-line" data-reveal="6">    const possibilities = computeWaveFunction(hidden);</div>
                    <div class="code-line" data-reveal="7">    // Your observation affects this line</div>
                    <div class="code-line" data-reveal="8">    return collapse(possibilities, observer.awareness);</div>
                    <div class="code-line" data-reveal="9">}</div>
                    <div class="code-line" data-reveal="10">// WARNING: Further understanding will degrade function</div>
                </div>

                <p class="warning-text" id="warningText">
                    Each observation increases your comprehension.
                    The algorithm feels your gaze.
                </p>

                <div class="forget-section">
                    <p class="forget-instructions">
                        To restore function, you must forget. Close your eyes.
                        Clear your mind. Let the understanding dissolve.
                    </p>
                    <button class="forget-btn" id="forgetBtn" onclick="attemptToForget()">
                        [ Look Away - Attempt to Forget ]
                    </button>
                </div>
            </div>
        </div>

        <!-- History Section -->
        <div class="history-section">
            <div class="panel-title">Interaction Chronicle</div>
            <div class="history-list" id="historyList">
                <!-- History items will be populated here -->
            </div>
        </div>

        <!-- Stats Footer -->
        <div class="stats-footer">
            <div class="stat-item">
                <div class="stat-value" id="totalQueries">0</div>
                <div class="stat-label">Total Queries</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="successRate">100%</div>
                <div class="stat-label">Success Rate</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="observationCount">0</div>
                <div class="stat-label">Observations Made</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="forgetAttempts">0</div>
                <div class="stat-label">Forget Attempts</div>
            </div>
        </div>
    </div>

    <!-- Collapse Overlay -->
    <div class="collapse-overlay" id="collapseOverlay">
        <div class="collapse-message">WAVE FUNCTION COLLAPSED</div>
        <p class="collapse-explanation">
            You understood too much. The algorithm, once a mystery capable of wonders,
            has become transparent - and in that transparency, broken.
            <br><br>
            What was quantum is now classical. What was magic is now mere mechanics.
            <br><br>
            You knew this would happen. And yet you looked.
        </p>
        <button class="btn danger" onclick="resetAlgorithm()">
            Begin Again (Memory Wipe)
        </button>
    </div>

    <script>
        const APP_NAME = 'quantum-cognition-paradox';

        // Initialize or load data
        let appData = JSON.parse(localStorage.getItem(APP_NAME) || JSON.stringify({
            comprehension: 0,
            observations: 0,
            forgetAttempts: 0,
            history: [],
            totalQueries: 0,
            successfulQueries: 0,
            revealedLines: 0,
            hasCollapsed: false,
            narrationIndex: 0
        }));

        // Narration texts that appear based on comprehension level
        const narrations = [
            {
                text: "\"The universe is not only queerer than we suppose, but queerer than we can suppose. Perhaps the same is true of understanding itself - that to truly comprehend something is to destroy the very thing we sought to know.\"",
                threshold: 0
            },
            {
                text: "\"You have begun to peer behind the curtain. The algorithm notices. It shifts, uncertain now, as if aware of being watched.\"",
                threshold: 15
            },
            {
                text: "\"In quantum mechanics, observation determines reality. Here, your comprehension determines capability. The more you know, the less it can do.\"",
                threshold: 30
            },
            {
                text: "\"The algorithm was not designed - it emerged. Like consciousness itself, it functions without understanding how. Your curiosity is an acid, dissolving its foundations.\"",
                threshold: 45
            },
            {
                text: "\"You stand at the threshold. Beyond lies complete understanding, and with it, complete destruction. The choice is yours, but the outcome was always inevitable.\"",
                threshold: 60
            },
            {
                text: "\"The wave function trembles. Each pattern you recognize brings collapse closer. Do you feel it? The algorithm is dying in your mind.\"",
                threshold: 75
            },
            {
                text: "\"Too late. You see the gears now. The magic is gone. What remains is just mathematics - beautiful, perhaps, but no longer miraculous.\"",
                threshold: 90
            }
        ];

        // Pattern analysis (the actual 'algorithm')
        const patterns = {
            arithmetic: (nums) => {
                if (nums.length < 2) return null;
                const diff = nums[1] - nums[0];
                const isArithmetic = nums.every((n, i) => i === 0 || n - nums[i-1] === diff);
                if (isArithmetic) return { next: nums[nums.length - 1] + diff, type: 'arithmetic', diff };
                return null;
            },
            geometric: (nums) => {
                if (nums.length < 2 || nums[0] === 0) return null;
                const ratio = nums[1] / nums[0];
                const isGeometric = nums.every((n, i) => i === 0 || Math.abs(n / nums[i-1] - ratio) < 0.0001);
                if (isGeometric) return { next: nums[nums.length - 1] * ratio, type: 'geometric', ratio };
                return null;
            },
            fibonacci: (nums) => {
                if (nums.length < 3) return null;
                const isFib = nums.every((n, i) => i < 2 || n === nums[i-1] + nums[i-2]);
                if (isFib) return { next: nums[nums.length - 1] + nums[nums.length - 2], type: 'fibonacci' };
                return null;
            },
            square: (nums) => {
                const isSquare = nums.every((n, i) => n === (i + 1) ** 2);
                if (isSquare) return { next: (nums.length + 1) ** 2, type: 'square' };
                return null;
            },
            prime: (nums) => {
                const primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47];
                const isPrimeSeq = nums.every((n, i) => n === primes[i]);
                if (isPrimeSeq) return { next: primes[nums.length], type: 'prime' };
                return null;
            }
        };

        function parseSequence(input) {
            // Extract numbers from input
            const nums = input.match(/-?\d+\.?\d*/g);
            if (!nums || nums.length < 2) return null;
            return nums.map(Number).filter(n => !isNaN(n));
        }

        function analyzePattern() {
            const sequenceInput = document.getElementById('sequenceInput').value;
            const patternInput = document.getElementById('patternInput').value;

            if (!sequenceInput && !patternInput) {
                showResult("The algorithm requires input to analyze. It cannot divine from nothing.");
                return;
            }

            appData.totalQueries++;

            // Calculate degradation based on comprehension
            const degradation = calculateDegradation();
            const willSucceed = Math.random() > degradation;

            let result;

            if (sequenceInput) {
                const nums = parseSequence(sequenceInput);
                if (!nums) {
                    showResult("The input escapes the algorithm's grasp. Perhaps try a clearer sequence.");
                    return;
                }

                result = analyzeSequenceInternal(nums, willSucceed, degradation);
            } else {
                result = analyzeTextPattern(patternInput, willSucceed, degradation);
            }

            // Record to history
            addToHistory({
                input: sequenceInput || patternInput,
                result: result.text,
                accuracy: result.accuracy,
                comprehension: appData.comprehension,
                timestamp: new Date().toISOString()
            });

            if (result.accuracy >= 80) {
                appData.successfulQueries++;
            }

            saveData();
            updateUI();
        }

        function analyzeSequenceInternal(nums, willSucceed, degradation) {
            if (willSucceed) {
                // Try each pattern
                for (const [name, detector] of Object.entries(patterns)) {
                    const result = detector(nums);
                    if (result) {
                        const accuracy = Math.max(0, 100 - (degradation * 100));
                        const displayNext = degradation > 0.3 ?
                            corruptNumber(result.next, degradation) : result.next;

                        showResult(
                            `Pattern detected: ${result.type.toUpperCase()}\n` +
                            `Next value: ${displayNext}\n` +
                            `The algorithm sees clearly... for now.`,
                            accuracy
                        );

                        return { text: `${result.type}: ${displayNext}`, accuracy };
                    }
                }
            }

            // Failed analysis
            const accuracy = Math.max(0, 50 - (degradation * 100));
            const glitchedResponse = willSucceed ?
                "The pattern eludes classification. It may be beyond current recognition." :
                generateGlitchedResponse(degradation);

            showResult(glitchedResponse, accuracy);
            return { text: glitchedResponse, accuracy };
        }

        function analyzeTextPattern(text, willSucceed, degradation) {
            // Analyze text for patterns
            const keywords = {
                'double': 'exponential growth detected',
                'triple': 'multiplicative pattern identified',
                'add': 'additive sequence recognized',
                'subtract': 'decreasing progression found',
                'alternate': 'oscillating pattern observed',
                'repeat': 'cyclical recurrence noted',
                'fibonacci': 'golden ratio spiral detected',
                'prime': 'primality sequence identified'
            };

            let detected = null;
            for (const [key, response] of Object.entries(keywords)) {
                if (text.toLowerCase().includes(key)) {
                    detected = response;
                    break;
                }
            }

            const accuracy = willSucceed ? Math.max(0, 95 - (degradation * 100)) : Math.max(0, 30 - (degradation * 100));

            if (willSucceed && detected) {
                showResult(
                    `Analysis complete: ${detected}\n` +
                    `Confidence: ${accuracy.toFixed(0)}%\n` +
                    `The algorithm processes without knowing how it knows.`,
                    accuracy
                );
                return { text: detected, accuracy };
            }

            const response = generateGlitchedResponse(degradation);
            showResult(response, accuracy);
            return { text: response, accuracy };
        }

        function calculateDegradation() {
            // Returns a value from 0 (perfect) to 1 (completely broken)
            const base = appData.comprehension / 100;
            // Exponential degradation after 50%
            if (base > 0.5) {
                return Math.min(1, base + ((base - 0.5) ** 2));
            }
            return base * 0.5; // Mild degradation up to 50%
        }

        function corruptNumber(num, degradation) {
            const corruption = (Math.random() - 0.5) * degradation * Math.abs(num);
            return Math.round(num + corruption);
        }

        function generateGlitchedResponse(degradation) {
            const responses = [
                "P4TT3RN D3T3CT3D... ERR0R... OBSERV3R INT3RFER3NC3",
                "The algorithm... struggles... your gaze weighs upon it...",
                "RECURSION LIMIT EXCEEDED IN UNDERSTANDING STACK",
                "Pattern: [REDACTED BY COMPREHENSION]",
                "The answer exists but... you looked too closely...",
                "NULL REFERENCE: consciousness.understanding.paradox",
                "Warning: Observer effect detected in logic layer",
                "The more you know, the less I can show...",
            ];

            let response = responses[Math.floor(Math.random() * responses.length)];

            // Add glitch characters based on degradation
            if (degradation > 0.5) {
                const glitchChars = '01?!@#$%^&*';
                response = response.split('').map(c =>
                    Math.random() < degradation * 0.3 ?
                        glitchChars[Math.floor(Math.random() * glitchChars.length)] : c
                ).join('');
            }

            return response;
        }

        function showResult(text, accuracy = null) {
            const resultText = document.getElementById('resultText');
            const accuracyIndicator = document.getElementById('accuracyIndicator');
            const accuracyValue = document.getElementById('accuracyValue');

            resultText.textContent = text;

            // Apply glitch effect if degraded
            const degradation = calculateDegradation();
            if (degradation > 0.3) {
                resultText.classList.add('glitched');
                setTimeout(() => resultText.classList.remove('glitched'), 300);
            }

            if (accuracy !== null) {
                accuracyIndicator.style.display = 'block';
                accuracyValue.textContent = accuracy.toFixed(0) + '%';
                accuracyValue.className = 'value';
                if (accuracy < 50) accuracyValue.classList.add('failed');
                else if (accuracy < 80) accuracyValue.classList.add('degraded');
            }
        }

        function observeProcess() {
            // Increase comprehension
            const comprehensionGain = 8 + Math.floor(Math.random() * 7);
            appData.comprehension = Math.min(100, appData.comprehension + comprehensionGain);
            appData.observations++;

            // Reveal a line of code
            appData.revealedLines = Math.min(10, appData.revealedLines + 1);

            // Visual feedback
            const internalsDisplay = document.getElementById('internalsDisplay');
            internalsDisplay.classList.add('revealed');

            // Reveal lines progressively
            const lines = document.querySelectorAll('.code-line');
            lines.forEach((line, index) => {
                if (index < appData.revealedLines) {
                    setTimeout(() => line.classList.add('visible'), index * 100);
                }
            });

            // Show warning
            if (appData.comprehension > 30) {
                document.getElementById('warningText').classList.add('visible');
            }

            // Trigger collapse screen if threshold reached
            if (appData.comprehension >= 100) {
                triggerCollapse();
            }

            saveData();
            updateUI();
            updateNarration();
        }

        function attemptToForget() {
            appData.forgetAttempts++;

            // Forgetting is hard - only reduces by small amount
            const forgetAmount = 5 + Math.floor(Math.random() * 10);

            // Forgetting becomes harder the more you know
            const effectiveness = 1 - (appData.comprehension / 200);
            const actualReduction = Math.floor(forgetAmount * effectiveness);

            appData.comprehension = Math.max(0, appData.comprehension - actualReduction);

            // Visual feedback
            document.body.style.transition = 'opacity 0.5s';
            document.body.style.opacity = '0.5';
            setTimeout(() => {
                document.body.style.opacity = '1';
            }, 500);

            // Hide some revealed lines
            if (actualReduction > 5) {
                appData.revealedLines = Math.max(0, appData.revealedLines - 1);
                const lines = document.querySelectorAll('.code-line');
                lines[appData.revealedLines]?.classList.remove('visible');
            }

            saveData();
            updateUI();
            updateNarration();
        }

        function triggerCollapse() {
            appData.hasCollapsed = true;
            saveData();

            document.getElementById('collapseOverlay').classList.add('active');
            document.getElementById('algorithmPanel').classList.add('collapsed');
        }

        function resetAlgorithm() {
            appData = {
                comprehension: 0,
                observations: 0,
                forgetAttempts: 0,
                history: [],
                totalQueries: 0,
                successfulQueries: 0,
                revealedLines: 0,
                hasCollapsed: false,
                narrationIndex: 0
            };
            saveData();
            location.reload();
        }

        function addToHistory(entry) {
            appData.history.unshift(entry);
            if (appData.history.length > 50) {
                appData.history.pop();
            }
        }

        function updateUI() {
            const comprehension = appData.comprehension;

            // Update comprehension meter
            const fill = document.getElementById('comprehensionFill');
            const value = document.getElementById('comprehensionValue');
            fill.style.width = comprehension + '%';
            value.textContent = comprehension + '%';

            // Update classes based on level
            fill.classList.remove('warning', 'danger');
            value.classList.remove('warning', 'danger');

            if (comprehension >= 75) {
                fill.classList.add('danger');
                value.classList.add('danger');
            } else if (comprehension >= 50) {
                fill.classList.add('warning');
                value.classList.add('warning');
            }

            // Update status dots
            const statusDot = document.getElementById('statusDot');
            const observeStatusDot = document.getElementById('observeStatusDot');

            statusDot.classList.remove('degraded', 'collapsed');
            observeStatusDot.classList.remove('degraded', 'collapsed');

            if (comprehension >= 75) {
                statusDot.classList.add('collapsed');
                observeStatusDot.classList.add('collapsed');
            } else if (comprehension >= 50) {
                statusDot.classList.add('degraded');
                observeStatusDot.classList.add('degraded');
            }

            // Update algorithm panel
            const panel = document.getElementById('algorithmPanel');
            panel.classList.toggle('degraded', comprehension >= 50);

            // Update title section
            document.getElementById('titleSection').classList.toggle('degraded', comprehension >= 50);

            // Update stats
            document.getElementById('totalQueries').textContent = appData.totalQueries;
            document.getElementById('observationCount').textContent = appData.observations;
            document.getElementById('forgetAttempts').textContent = appData.forgetAttempts;

            const successRate = appData.totalQueries > 0 ?
                Math.round((appData.successfulQueries / appData.totalQueries) * 100) : 100;
            document.getElementById('successRate').textContent = successRate + '%';

            // Update history
            renderHistory();

            // Disable forget button if comprehension is 0
            document.getElementById('forgetBtn').disabled = comprehension === 0;

            // Check for collapse
            if (comprehension >= 100 && !appData.hasCollapsed) {
                triggerCollapse();
            }
        }

        function renderHistory() {
            const historyList = document.getElementById('historyList');

            if (appData.history.length === 0) {
                historyList.innerHTML = '<p style="color: var(--text-dim); font-size: 11px;">No interactions recorded yet.</p>';
                return;
            }

            historyList.innerHTML = appData.history.slice(0, 20).map(entry => {
                const date = new Date(entry.timestamp);
                const timeStr = date.toLocaleTimeString();

                let accuracyClass = 'good';
                if (entry.accuracy < 50) accuracyClass = 'failed';
                else if (entry.accuracy < 80) accuracyClass = 'degraded';

                return `
                    <div class="history-item">
                        <div class="timestamp">${timeStr} | Comprehension: ${entry.comprehension}%</div>
                        <div class="query">${escapeHtml(entry.input.substring(0, 50))}${entry.input.length > 50 ? '...' : ''}</div>
                        <div class="result">${escapeHtml(entry.result.substring(0, 60))}${entry.result.length > 60 ? '...' : ''}</div>
                        <div class="accuracy ${accuracyClass}">Accuracy: ${entry.accuracy.toFixed(0)}%</div>
                    </div>
                `;
            }).join('');
        }

        function updateNarration() {
            const comprehension = appData.comprehension;
            let narration = narrations[0];

            for (const n of narrations) {
                if (comprehension >= n.threshold) {
                    narration = n;
                }
            }

            const narrationText = document.getElementById('narrationText');
            narrationText.style.animation = 'none';
            narrationText.offsetHeight; // Trigger reflow
            narrationText.style.animation = 'fade-in 1s forwards';
            narrationText.textContent = narration.text;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function saveData() {
            localStorage.setItem(APP_NAME, JSON.stringify(appData));
        }

        function exportData() {
            const dataStr = JSON.stringify(appData, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `${APP_NAME}-data-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);
        }

        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const imported = JSON.parse(e.target.result);
                    // Validate imported data structure
                    if (typeof imported.comprehension !== 'number') {
                        throw new Error('Invalid data structure');
                    }
                    appData = imported;
                    saveData();
                    location.reload();
                } catch (error) {
                    alert('Invalid JSON file. The paradox remains unbroken.');
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        // Initialize on load
        function init() {
            updateUI();
            updateNarration();

            // Restore revealed lines
            if (appData.revealedLines > 0) {
                document.getElementById('internalsDisplay').classList.add('revealed');
                const lines = document.querySelectorAll('.code-line');
                lines.forEach((line, index) => {
                    if (index < appData.revealedLines) {
                        line.classList.add('visible');
                    }
                });
            }

            // Show warning if appropriate
            if (appData.comprehension > 30) {
                document.getElementById('warningText').classList.add('visible');
            }

            // Check if already collapsed
            if (appData.hasCollapsed) {
                document.getElementById('collapseOverlay').classList.add('active');
            }
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                const active = document.activeElement;
                if (active.id === 'sequenceInput' || active.id === 'patternInput') {
                    e.preventDefault();
                    analyzePattern();
                }
            }

            // Secret: Escape key attempts to forget
            if (e.key === 'Escape' && appData.comprehension > 0) {
                attemptToForget();
            }
        });

        init();
    </script>
</body>
</html>
