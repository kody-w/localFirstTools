<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Recursive Self-Portrait</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Courier New', monospace;
            background: #0a0a0f;
            color: #e0e0e0;
            min-height: 100vh;
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        .simulation-viewport {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: linear-gradient(135deg, #0d0d15 0%, #1a1a2e 100%);
        }

        .recursion-layer {
            position: absolute;
            border: 2px solid rgba(100, 200, 255, 0.3);
            border-radius: 8px;
            background: rgba(10, 10, 20, 0.9);
            box-shadow:
                0 0 20px rgba(100, 200, 255, 0.1),
                inset 0 0 40px rgba(100, 200, 255, 0.05);
            transition: all 0.3s ease;
            overflow: hidden;
        }

        .recursion-layer::before {
            content: attr(data-depth);
            position: absolute;
            top: 5px;
            left: 10px;
            font-size: 10px;
            color: rgba(100, 200, 255, 0.6);
            z-index: 10;
        }

        .recursion-layer.diverged {
            border-color: rgba(255, 100, 100, 0.5);
            box-shadow:
                0 0 30px rgba(255, 100, 100, 0.2),
                inset 0 0 40px rgba(255, 100, 100, 0.05);
        }

        .recursion-layer.converged {
            border-color: rgba(100, 255, 150, 0.5);
            box-shadow:
                0 0 30px rgba(100, 255, 150, 0.2),
                inset 0 0 40px rgba(100, 255, 150, 0.05);
        }

        .ghost-cursor {
            position: absolute;
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 100;
            will-change: transform;
        }

        .ghost-cursor::before {
            content: '';
            position: absolute;
            width: 0;
            height: 0;
            border-left: 8px solid currentColor;
            border-top: 5px solid transparent;
            border-bottom: 5px solid transparent;
            transform: rotate(-45deg);
        }

        .ghost-cursor::after {
            content: '';
            position: absolute;
            top: 12px;
            left: 6px;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
            opacity: 0.5;
        }

        .ghost-click {
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid currentColor;
            animation: clickRipple 0.6s ease-out forwards;
            pointer-events: none;
        }

        @keyframes clickRipple {
            0% { transform: scale(0); opacity: 1; }
            100% { transform: scale(2); opacity: 0; }
        }

        .sidebar {
            width: 320px;
            background: rgba(15, 15, 25, 0.95);
            border-left: 1px solid rgba(100, 200, 255, 0.2);
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            overflow-y: auto;
        }

        h1 {
            font-size: 1.4em;
            background: linear-gradient(90deg, #64c8ff, #a080ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-align: center;
        }

        .subtitle {
            font-size: 0.75em;
            color: #888;
            text-align: center;
            font-style: italic;
        }

        .stats-panel {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(100, 200, 255, 0.1);
        }

        .stat-row:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }

        .stat-label {
            color: #888;
            font-size: 0.85em;
        }

        .stat-value {
            font-weight: bold;
            color: #64c8ff;
        }

        .stat-value.diverged { color: #ff6464; }
        .stat-value.converged { color: #64ff96; }

        .depth-slider {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
        }

        .depth-slider label {
            display: block;
            margin-bottom: 10px;
            color: #aaa;
            font-size: 0.9em;
        }

        .depth-slider input[type="range"] {
            width: 100%;
            height: 8px;
            -webkit-appearance: none;
            appearance: none;
            background: linear-gradient(90deg, #1a1a2e, #64c8ff);
            border-radius: 4px;
            outline: none;
        }

        .depth-slider input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: #64c8ff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(100, 200, 255, 0.5);
        }

        .behavior-log {
            flex: 1;
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
            overflow-y: auto;
            min-height: 200px;
        }

        .behavior-log h3 {
            color: #888;
            font-size: 0.85em;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .log-entry {
            font-size: 0.75em;
            padding: 5px 8px;
            margin-bottom: 5px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            border-left: 3px solid #64c8ff;
            color: #aaa;
        }

        .log-entry.prediction { border-left-color: #a080ff; }
        .log-entry.divergence { border-left-color: #ff6464; }
        .log-entry.match { border-left-color: #64ff96; }

        .controls {
            display: flex;
            gap: 10px;
        }

        button {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 6px;
            font-family: inherit;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #64c8ff, #a080ff);
            color: #0a0a0f;
            font-weight: bold;
        }

        .btn-secondary {
            background: rgba(100, 200, 255, 0.1);
            color: #64c8ff;
            border: 1px solid rgba(100, 200, 255, 0.3);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(100, 200, 255, 0.3);
        }

        .divergence-meter {
            height: 8px;
            background: rgba(30, 30, 50, 0.8);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 10px;
        }

        .divergence-fill {
            height: 100%;
            background: linear-gradient(90deg, #64ff96, #ffff64, #ff6464);
            transition: width 0.3s ease;
        }

        .philosophical-quote {
            text-align: center;
            font-style: italic;
            color: #666;
            font-size: 0.8em;
            padding: 15px;
            border-top: 1px solid rgba(100, 200, 255, 0.1);
        }

        .interaction-zone {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 200px;
            height: 200px;
            border: 2px dashed rgba(100, 200, 255, 0.3);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
            font-size: 0.9em;
            text-align: center;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .simulation-viewport:not(.recording) .interaction-zone {
            opacity: 1;
        }

        .recording-indicator {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 15px;
            background: rgba(255, 64, 64, 0.2);
            border: 1px solid rgba(255, 64, 64, 0.5);
            border-radius: 20px;
            color: #ff6464;
            font-size: 0.85em;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .recording-indicator.active {
            opacity: 1;
        }

        .recording-dot {
            width: 10px;
            height: 10px;
            background: #ff6464;
            border-radius: 50%;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        .depth-label {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 20px;
            border-radius: 20px;
            font-size: 0.9em;
            color: #64c8ff;
        }

        .data-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
            display: flex;
            gap: 10px;
        }

        .data-controls button {
            padding: 8px 16px;
            font-size: 0.8em;
            background: rgba(100, 200, 255, 0.1);
            border: 1px solid rgba(100, 200, 255, 0.3);
            color: #64c8ff;
        }

        .mini-element {
            position: absolute;
            background: rgba(100, 200, 255, 0.3);
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .mini-element:hover {
            background: rgba(100, 200, 255, 0.5);
        }

        .thought-bubble {
            position: absolute;
            background: rgba(160, 128, 255, 0.2);
            border: 1px solid rgba(160, 128, 255, 0.4);
            border-radius: 12px;
            padding: 8px 12px;
            font-size: 0.7em;
            color: #a080ff;
            pointer-events: none;
            animation: floatUp 3s ease-out forwards;
            white-space: nowrap;
        }

        @keyframes floatUp {
            0% { opacity: 0; transform: translateY(10px); }
            20% { opacity: 1; }
            80% { opacity: 1; }
            100% { opacity: 0; transform: translateY(-30px); }
        }

        .infinity-symbol {
            position: absolute;
            font-size: 100px;
            color: rgba(100, 200, 255, 0.05);
            pointer-events: none;
            animation: rotate 20s linear infinite;
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* Prediction trails */
        .prediction-trail {
            position: absolute;
            pointer-events: none;
            z-index: 50;
        }

        .prediction-trail path {
            fill: none;
            stroke-width: 2;
            opacity: 0.4;
            stroke-dasharray: 5, 5;
            animation: dashMove 1s linear infinite;
        }

        @keyframes dashMove {
            to { stroke-dashoffset: -10; }
        }

        /* Heat map */
        .heat-map {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
            opacity: 0.4;
        }

        .heat-point {
            position: absolute;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255, 100, 100, 0.6), transparent);
            will-change: transform, opacity;
            animation: heatFade 3s ease-out forwards;
        }

        @keyframes heatFade {
            from { opacity: 1; }
            to { opacity: 0; }
        }

        /* Glitch effects */
        .glitch-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 200;
            opacity: 0;
            transition: opacity 0.1s;
        }

        .glitch-overlay.active {
            opacity: 1;
        }

        .scanline {
            position: absolute;
            left: 0;
            width: 100%;
            height: 2px;
            background: rgba(100, 200, 255, 0.3);
            animation: scan 4s linear infinite;
        }

        @keyframes scan {
            from { top: 0%; }
            to { top: 100%; }
        }

        .recursion-layer.glitching {
            animation: glitchShake 0.2s infinite;
        }

        @keyframes glitchShake {
            0%, 100% { transform: translate(0, 0); }
            25% { transform: translate(-2px, 2px); }
            50% { transform: translate(2px, -2px); }
            75% { transform: translate(-2px, -2px); }
        }

        .chromatic-aberration {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            mix-blend-mode: screen;
            opacity: 0;
        }

        .chromatic-aberration.active {
            opacity: 0.3;
            animation: chromaticGlitch 0.3s infinite;
        }

        @keyframes chromaticGlitch {
            0% { transform: translate(0, 0); }
            33% { transform: translate(2px, 0); filter: hue-rotate(90deg); }
            66% { transform: translate(-2px, 0); filter: hue-rotate(180deg); }
            100% { transform: translate(0, 0); }
        }

        /* Behavioral fingerprint */
        .fingerprint-panel {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
            min-height: 150px;
        }

        .fingerprint-panel h3 {
            color: #888;
            font-size: 0.85em;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #fingerprintCanvas {
            width: 100%;
            height: 120px;
            border-radius: 4px;
            background: rgba(0, 0, 0, 0.3);
        }

        /* Meta-commentary */
        .meta-comment {
            position: absolute;
            background: rgba(255, 100, 100, 0.15);
            border: 1px solid rgba(255, 100, 100, 0.4);
            border-radius: 8px;
            padding: 12px 16px;
            font-size: 0.75em;
            color: #ff6464;
            pointer-events: none;
            animation: metaDrift 8s ease-out forwards;
            max-width: 300px;
            text-align: center;
            font-style: italic;
            z-index: 150;
        }

        @keyframes metaDrift {
            0% { opacity: 0; transform: translateY(0) scale(0.9); }
            10% { opacity: 1; transform: translateY(-10px) scale(1); }
            90% { opacity: 1; transform: translateY(-40px) scale(1); }
            100% { opacity: 0; transform: translateY(-60px) scale(0.95); }
        }

        /* Infinity mirror effect */
        .infinity-mirror {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
            opacity: 0;
            transition: opacity 0.5s;
        }

        .infinity-mirror.active {
            opacity: 1;
        }

        .infinity-ring {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 1px solid rgba(100, 200, 255, 0.2);
            border-radius: 50%;
            animation: expandRing 3s ease-out infinite;
        }

        @keyframes expandRing {
            0% { width: 50px; height: 50px; opacity: 0.8; }
            100% { width: 400px; height: 400px; opacity: 0; }
        }

        /* Webcam integration */
        .webcam-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 120px;
            height: 90px;
            border: 2px solid rgba(100, 200, 255, 0.3);
            border-radius: 8px;
            overflow: hidden;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 100;
        }

        .webcam-container.active {
            opacity: 1;
        }

        #webcamVideo {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }

        .webcam-distortion {
            filter: hue-rotate(0deg) blur(0px);
            transition: filter 0.3s;
        }

        /* Mobile responsive */
        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }

            .sidebar {
                width: 100%;
                max-height: 40vh;
                border-left: none;
                border-top: 1px solid rgba(100, 200, 255, 0.2);
                order: 2;
            }

            .simulation-viewport {
                order: 1;
                height: 60vh;
            }

            .depth-label {
                bottom: 10px;
                font-size: 0.75em;
            }

            .recording-indicator {
                top: 10px;
                left: 10px;
                font-size: 0.7em;
                padding: 6px 10px;
            }

            .meta-comment {
                max-width: 200px;
                font-size: 0.65em;
            }

            .webcam-container {
                width: 80px;
                height: 60px;
                bottom: 10px;
                right: 10px;
            }

            button {
                padding: 10px;
                font-size: 0.85em;
            }
        }

        /* Sound indicator */
        .sound-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            background: rgba(100, 200, 255, 0.1);
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            z-index: 1000;
        }

        .sound-indicator:hover {
            background: rgba(100, 200, 255, 0.2);
        }

        .sound-indicator.muted {
            opacity: 0.4;
        }

        .sound-wave {
            width: 20px;
            height: 20px;
            display: flex;
            gap: 3px;
            align-items: center;
            justify-content: center;
        }

        .sound-bar {
            width: 3px;
            background: #64c8ff;
            border-radius: 2px;
            animation: soundPulse 0.8s ease-in-out infinite;
        }

        .sound-bar:nth-child(1) { height: 8px; animation-delay: 0s; }
        .sound-bar:nth-child(2) { height: 14px; animation-delay: 0.2s; }
        .sound-bar:nth-child(3) { height: 10px; animation-delay: 0.4s; }

        @keyframes soundPulse {
            0%, 100% { transform: scaleY(1); }
            50% { transform: scaleY(1.5); }
        }

        .sound-indicator.muted .sound-bar {
            animation: none;
            height: 2px !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="simulation-viewport" id="viewport">
            <div class="infinity-symbol" style="top: 50%; left: 50%; transform: translate(-50%, -50%);">∞</div>

            <!-- Sound control -->
            <div class="sound-indicator" id="soundToggle" title="Toggle sound">
                <div class="sound-wave">
                    <div class="sound-bar"></div>
                    <div class="sound-bar"></div>
                    <div class="sound-bar"></div>
                </div>
            </div>

            <!-- Glitch overlay -->
            <div class="glitch-overlay" id="glitchOverlay">
                <div class="scanline"></div>
                <div class="chromatic-aberration" id="chromaticEffect"></div>
            </div>

            <!-- Infinity mirror effect -->
            <div class="infinity-mirror" id="infinityMirror"></div>

            <!-- Heat map overlay -->
            <div class="heat-map" id="heatMap"></div>

            <!-- Prediction trails SVG -->
            <svg class="prediction-trail" id="predictionTrail" width="100%" height="100%"></svg>

            <!-- Webcam integration -->
            <div class="webcam-container" id="webcamContainer">
                <video id="webcamVideo" class="webcam-distortion" autoplay muted playsinline></video>
            </div>

            <div class="recording-indicator" id="recordingIndicator">
                <div class="recording-dot"></div>
                <span>OBSERVING YOU</span>
            </div>
            <div class="interaction-zone">
                Move your cursor here<br>to begin observation
            </div>
            <div class="depth-label" id="depthLabel">Depth: 0 → ∞</div>
        </div>

        <div class="sidebar">
            <div>
                <h1>∞ Recursive Self-Portrait</h1>
                <p class="subtitle">How deep until the model diverges from reality?</p>
            </div>

            <div class="stats-panel">
                <div class="stat-row">
                    <span class="stat-label">Current Depth</span>
                    <span class="stat-value" id="currentDepth">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Actions Recorded</span>
                    <span class="stat-value" id="actionsRecorded">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Predictions Made</span>
                    <span class="stat-value" id="predictionsMade">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Accuracy</span>
                    <span class="stat-value" id="accuracy">—</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Divergence Level</span>
                    <span class="stat-value" id="divergenceLevel">0%</span>
                </div>
                <div class="divergence-meter">
                    <div class="divergence-fill" id="divergenceFill" style="width: 0%"></div>
                </div>
            </div>

            <div class="depth-slider">
                <label>Recursion Depth: <span id="depthValue">5</span></label>
                <input type="range" id="depthSlider" min="1" max="12" value="5">
            </div>

            <div class="controls">
                <button class="btn-primary" id="startBtn">Begin Observation</button>
                <button class="btn-secondary" id="resetBtn">Reset</button>
            </div>

            <div class="fingerprint-panel">
                <h3>Behavioral Fingerprint</h3>
                <canvas id="fingerprintCanvas"></canvas>
            </div>

            <div class="behavior-log" id="behaviorLog">
                <h3>Behavioral Model Log</h3>
                <div id="logEntries"></div>
            </div>

            <div class="controls">
                <button class="btn-secondary" onclick="exportData()">Export Session</button>
                <button class="btn-secondary" onclick="document.getElementById('importFile').click()">Import</button>
                <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importData(event)">
            </div>

            <button class="btn-secondary" id="webcamToggle">Enable Webcam (Optional)</button>

            <div class="philosophical-quote">
                "I think, therefore I simulate myself thinking,<br>
                therefore I simulate myself simulating..."
            </div>
        </div>
    </div>

    <script>
        const APP_NAME = 'recursive-self-portrait';

        // Web Audio API setup
        let audioContext = null;
        let masterGain = null;
        let soundEnabled = true;
        let ambientOscillator = null;

        // Webcam
        let webcamStream = null;
        let webcamEnabled = false;

        // Object pools for reusable elements
        const heatPointPool = [];
        const ghostCursorPool = [];
        const MAX_POOL_SIZE = 50;

        function getPooledHeatPoint() {
            return heatPointPool.pop() || document.createElement('div');
        }

        function releaseHeatPoint(element) {
            if (heatPointPool.length < MAX_POOL_SIZE) {
                element.className = 'heat-point';
                element.removeAttribute('style');
                heatPointPool.push(element);
            }
        }

        // State
        let state = {
            isObserving: false,
            depth: 5,
            actions: [],
            predictions: [],
            layers: [],
            cursors: [],
            divergenceScore: 0,
            correctPredictions: 0,
            totalPredictions: 0,
            behaviorModel: {
                avgSpeed: 0,
                preferredZones: [],
                clickPatterns: [],
                hesitationPoints: [],
                movementStyle: 'unknown', // 'erratic', 'smooth', 'precise', 'lazy'
                heatMapData: [] // Track cursor positions for heat map
            },
            sessionHistory: [],
            predictionPaths: [], // For visualization
            metaObservations: [] // Meta-commentary about user
        };

        // Load saved state
        const savedState = localStorage.getItem(APP_NAME);
        if (savedState) {
            const parsed = JSON.parse(savedState);
            state.sessionHistory = parsed.sessionHistory || [];
            state.behaviorModel = parsed.behaviorModel || state.behaviorModel;
        }

        // DOM Elements
        const viewport = document.getElementById('viewport');
        const recordingIndicator = document.getElementById('recordingIndicator');
        const depthSlider = document.getElementById('depthSlider');
        const depthValue = document.getElementById('depthValue');
        const depthLabel = document.getElementById('depthLabel');
        const startBtn = document.getElementById('startBtn');
        const resetBtn = document.getElementById('resetBtn');
        const logEntries = document.getElementById('logEntries');

        // Stats elements
        const currentDepthEl = document.getElementById('currentDepth');
        const actionsRecordedEl = document.getElementById('actionsRecorded');
        const predictionsMadeEl = document.getElementById('predictionsMade');
        const accuracyEl = document.getElementById('accuracy');
        const divergenceLevelEl = document.getElementById('divergenceLevel');
        const divergenceFill = document.getElementById('divergenceFill');

        // Event tracking
        let lastMousePos = { x: 0, y: 0 };
        let lastMoveTime = Date.now();
        let velocityHistory = [];

        // Colors for depth layers
        const depthColors = [
            '#64c8ff', '#a080ff', '#ff80bf', '#ffbf64',
            '#64ff96', '#ff6464', '#64ffff', '#bf64ff',
            '#ffff64', '#ff64ff', '#64bfff', '#bfff64'
        ];

        // DOM elements for new features
        const soundToggle = document.getElementById('soundToggle');
        const glitchOverlay = document.getElementById('glitchOverlay');
        const chromaticEffect = document.getElementById('chromaticEffect');
        const infinityMirror = document.getElementById('infinityMirror');
        const heatMap = document.getElementById('heatMap');
        const predictionTrail = document.getElementById('predictionTrail');
        const webcamContainer = document.getElementById('webcamContainer');
        const webcamVideo = document.getElementById('webcamVideo');
        const webcamToggle = document.getElementById('webcamToggle');
        const fingerprintCanvas = document.getElementById('fingerprintCanvas');

        // ===== WEB AUDIO API =====
        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                masterGain = audioContext.createGain();
                masterGain.gain.value = 0.3;
                masterGain.connect(audioContext.destination);
            }
        }

        function startAmbientDrone() {
            if (!soundEnabled || !audioContext) return;

            // Create subtle ambient oscillator
            ambientOscillator = audioContext.createOscillator();
            const ambientGain = audioContext.createGain();

            ambientOscillator.type = 'sine';
            ambientOscillator.frequency.value = 40; // Deep bass
            ambientGain.gain.value = 0.05;

            ambientOscillator.connect(ambientGain);
            ambientGain.connect(masterGain);
            ambientOscillator.start();

            // Add subtle modulation
            const lfo = audioContext.createOscillator();
            const lfoGain = audioContext.createGain();
            lfo.frequency.value = 0.1; // Very slow
            lfoGain.gain.value = 3;
            lfo.connect(lfoGain);
            lfoGain.connect(ambientOscillator.frequency);
            lfo.start();
        }

        function stopAmbientDrone() {
            if (ambientOscillator) {
                ambientOscillator.stop();
                ambientOscillator = null;
            }
        }

        function updateAmbientFrequency() {
            if (!ambientOscillator || !soundEnabled) return;

            // Frequency increases with divergence
            const baseFreq = 40;
            const targetFreq = baseFreq + (state.divergenceScore / 100) * 80;
            ambientOscillator.frequency.setTargetAtTime(targetFreq, audioContext.currentTime, 0.5);
        }

        function playClickSound(depth) {
            if (!soundEnabled || !audioContext) return;

            const now = audioContext.currentTime;
            const osc = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            // Higher pitch for deeper layers
            const basePitch = 800;
            const pitch = basePitch + (depth * 100);

            osc.frequency.value = pitch;
            osc.type = 'sine';

            // Quick envelope
            gainNode.gain.setValueAtTime(0, now);
            gainNode.gain.linearRampToValueAtTime(0.1, now + 0.01);
            gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.1 + (depth * 0.05));

            osc.connect(gainNode);
            gainNode.connect(masterGain);

            osc.start(now);
            osc.stop(now + 0.2 + (depth * 0.05));
        }

        function playGlitchSound() {
            if (!soundEnabled || !audioContext) return;

            const now = audioContext.currentTime;
            const noise = audioContext.createBufferSource();
            const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.1, audioContext.sampleRate);
            const data = buffer.getChannelData(0);

            // Generate noise
            for (let i = 0; i < buffer.length; i++) {
                data[i] = Math.random() * 2 - 1;
            }

            noise.buffer = buffer;
            const gainNode = audioContext.createGain();
            gainNode.gain.setValueAtTime(0.1, now);
            gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.1);

            noise.connect(gainNode);
            gainNode.connect(masterGain);
            noise.start(now);
        }

        // ===== WEBCAM INTEGRATION =====
        async function enableWebcam() {
            try {
                webcamStream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 320, height: 240 }
                });
                webcamVideo.srcObject = webcamStream;
                webcamContainer.classList.add('active');
                webcamEnabled = true;
                webcamToggle.textContent = 'Disable Webcam';
                addLog('Webcam enabled - you are now in the deepest layer', 'prediction');
            } catch (err) {
                addLog('Webcam access denied or unavailable', 'divergence');
            }
        }

        function disableWebcam() {
            if (webcamStream) {
                webcamStream.getTracks().forEach(track => track.stop());
                webcamStream = null;
            }
            webcamContainer.classList.remove('active');
            webcamEnabled = false;
            webcamToggle.textContent = 'Enable Webcam (Optional)';
        }

        function updateWebcamDistortion() {
            if (!webcamEnabled) return;

            // Apply distortion based on divergence and depth
            const maxDepthLayer = state.layers[state.layers.length - 1];
            if (maxDepthLayer) {
                const divergence = maxDepthLayer.divergence || 0;
                const hueRotate = (divergence / 100) * 180;
                const blur = (state.divergenceScore / 100) * 3;
                webcamVideo.style.filter = `hue-rotate(${hueRotate}deg) blur(${blur}px)`;
            }
        }

        // ===== VISUAL EFFECTS =====
        function updateHeatMap() {
            if (state.actions.length % 5 !== 0) return; // Update less frequently

            const heatPoint = getPooledHeatPoint();
            heatPoint.className = 'heat-point';
            const size = 60 + Math.random() * 40;
            heatPoint.style.width = size + 'px';
            heatPoint.style.height = size + 'px';
            heatPoint.style.transform = `translate(${lastMousePos.x - size/2}px, ${lastMousePos.y - size/2}px)`;
            heatMap.appendChild(heatPoint);

            setTimeout(() => {
                heatMap.removeChild(heatPoint);
                releaseHeatPoint(heatPoint);
            }, 3000);

            // Keep heat map data for fingerprint
            state.behaviorModel.heatMapData.push({
                x: lastMousePos.x,
                y: lastMousePos.y,
                timestamp: Date.now()
            });

            // Limit heat map data
            if (state.behaviorModel.heatMapData.length > 200) {
                state.behaviorModel.heatMapData.shift();
            }
        }

        function drawPredictionTrails() {
            if (state.layers.length === 0) return;

            // Clear old paths
            while (predictionTrail.firstChild) {
                predictionTrail.removeChild(predictionTrail.firstChild);
            }

            // Draw prediction path for each layer
            state.layers.forEach((layer, i) => {
                if (state.actions.length < 3) return;

                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                const color = depthColors[i % depthColors.length];

                // Create prediction path
                const predicted = layer.predictedPos;
                const current = lastMousePos;

                // Draw curved path from current to predicted
                const d = `M ${current.x} ${current.y} Q ${(current.x + predicted.x) / 2} ${(current.y + predicted.y) / 2 - 20}, ${predicted.x} ${predicted.y}`;

                path.setAttribute('d', d);
                path.setAttribute('stroke', color);
                path.setAttribute('stroke-opacity', 0.3 - i * 0.02);

                predictionTrail.appendChild(path);
            });
        }

        function updateGlitchEffects() {
            // Activate glitch effects when divergence is high
            if (state.divergenceScore > 60) {
                glitchOverlay.classList.add('active');
                chromaticEffect.classList.add('active');

                // Randomly glitch layers
                state.layers.forEach(layer => {
                    if (Math.random() > 0.7) {
                        layer.element.classList.add('glitching');
                        setTimeout(() => layer.element.classList.remove('glitching'), 200);
                    }
                });

                // Occasional glitch sound
                if (Math.random() > 0.95) {
                    playGlitchSound();
                }
            } else if (state.divergenceScore > 40) {
                glitchOverlay.classList.add('active');
                chromaticEffect.classList.remove('active');
            } else {
                glitchOverlay.classList.remove('active');
                chromaticEffect.classList.remove('active');
            }
        }

        function updateInfinityMirror() {
            // Show infinity mirror when at max depth
            if (state.depth >= 10 && state.isObserving) {
                if (!infinityMirror.classList.contains('active')) {
                    infinityMirror.classList.add('active');

                    // Create expanding rings
                    for (let i = 0; i < 5; i++) {
                        setTimeout(() => {
                            const ring = document.createElement('div');
                            ring.className = 'infinity-ring';
                            infinityMirror.appendChild(ring);
                            setTimeout(() => ring.remove(), 3000);
                        }, i * 600);
                    }
                }
            } else {
                infinityMirror.classList.remove('active');
            }
        }

        // Cache for fingerprint calculations
        let fingerprintCache = {
            centerX: 0,
            centerY: 0,
            canvasWidth: 0,
            canvasHeight: 0,
            styleMap: {
                'erratic': { rings: 8, chaos: 0.8 },
                'smooth': { rings: 6, chaos: 0.2 },
                'precise': { rings: 12, chaos: 0.1 },
                'lazy': { rings: 4, chaos: 0.4 },
                'unknown': { rings: 6, chaos: 0.5 }
            }
        };

        function generateBehavioralFingerprint() {
            const canvas = fingerprintCanvas;
            const ctx = canvas.getContext('2d');

            // Set canvas size only if changed
            const newWidth = canvas.offsetWidth * 2;
            const newHeight = 120 * 2;
            if (canvas.width !== newWidth || canvas.height !== newHeight) {
                canvas.width = newWidth;
                canvas.height = newHeight;
                fingerprintCache.canvasWidth = newWidth;
                fingerprintCache.canvasHeight = newHeight;
                fingerprintCache.centerX = newWidth / 4;
                fingerprintCache.centerY = newHeight / 4;
            }
            ctx.scale(2, 2);

            // Clear canvas
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(0, 0, fingerprintCache.canvasWidth / 2, fingerprintCache.canvasHeight / 2);

            if (state.actions.length < 10) {
                ctx.fillStyle = '#666';
                ctx.font = '12px "Courier New"';
                ctx.textAlign = 'center';
                ctx.fillText('Gathering behavioral data...', fingerprintCache.centerX, fingerprintCache.centerY);
                return;
            }

            // Use cached values
            const centerX = fingerprintCache.centerX;
            const centerY = fingerprintCache.centerY;
            const style = fingerprintCache.styleMap[state.behaviorModel.movementStyle];
            const avgSpeed = Math.min(state.behaviorModel.avgSpeed / 10, 1);

            // Pre-calculate common values
            const TWO_PI = Math.PI * 2;
            const hue = 200 - (state.divergenceScore / 100) * 100;

            // Draw concentric pattern (reduced points for performance)
            for (let i = 0; i < style.rings; i++) {
                const radius = (i + 1) * 8;
                const points = 180; // Reduced from 360

                ctx.beginPath();
                for (let angle = 0; angle < points; angle++) {
                    const rad = (angle / points) * TWO_PI;
                    const noise = Math.sin(angle * 0.1 + i) * style.chaos * 5;
                    const r = radius + noise + avgSpeed * 3;

                    const x = centerX + Math.cos(rad) * r;
                    const y = centerY + Math.sin(rad) * r;

                    if (angle === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.closePath();

                // Color based on divergence
                ctx.strokeStyle = `hsl(${hue}, 70%, ${50 + i * 3}%)`;
                ctx.lineWidth = 1;
                ctx.stroke();
            }

            // Add velocity spikes
            ctx.strokeStyle = 'rgba(100, 200, 255, 0.4)';
            ctx.lineWidth = 2;
            const velCount = Math.min(velocityHistory.length, 50);
            for (let i = 0; i < velCount; i++) {
                const angle = (i / 50) * TWO_PI;
                const vel = Math.min(velocityHistory[i] / 10, 1);
                const length = 20 + vel * 30;

                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(
                    centerX + Math.cos(angle) * length,
                    centerY + Math.sin(angle) * length
                );
                ctx.stroke();
            }

            // Center dot
            ctx.fillStyle = state.divergenceScore > 50 ? '#ff6464' : '#64ff96';
            ctx.beginPath();
            ctx.arc(centerX, centerY, 3, 0, TWO_PI);
            ctx.fill();
        }

        function showMetaCommentary() {
            if (!state.isObserving || Math.random() > 0.3) return;

            const comments = generateContextualComments();
            if (comments.length === 0) return;

            const comment = comments[Math.floor(Math.random() * comments.length)];

            const meta = document.createElement('div');
            meta.className = 'meta-comment';
            meta.textContent = comment;

            // Random position
            const maxX = viewport.clientWidth - 320;
            const maxY = viewport.clientHeight - 100;
            meta.style.left = (Math.random() * maxX + 20) + 'px';
            meta.style.top = (Math.random() * maxY + 50) + 'px';

            viewport.appendChild(meta);

            setTimeout(() => meta.remove(), 8000);

            addLog(`Meta-observation: ${comment}`, 'prediction');
            state.metaObservations.push({ comment, timestamp: Date.now() });
        }

        function generateContextualComments() {
            const comments = [];

            // Divergence-based
            if (state.divergenceScore > 80) {
                comments.push(
                    "The simulation is collapsing. You are unpredictable.",
                    "I can no longer model you accurately.",
                    "Layer 7 has lost synchronization.",
                    "Reality divergence detected."
                );
            } else if (state.divergenceScore > 60) {
                comments.push(
                    "You're becoming harder to predict.",
                    "Behavioral patterns are shifting.",
                    "The deeper layers are confused."
                );
            } else if (state.divergenceScore < 20) {
                comments.push(
                    "Your movements are perfectly predictable.",
                    "I know what you'll do before you do it.",
                    "All layers are converged. You are deterministic."
                );
            }

            // Movement style
            if (state.behaviorModel.movementStyle === 'erratic') {
                comments.push(
                    "Why so chaotic?",
                    "Your movements betray nervousness.",
                    "Erratic behavior detected."
                );
            } else if (state.behaviorModel.movementStyle === 'lazy') {
                comments.push(
                    "Such minimal effort.",
                    "Are you even trying?",
                    "Sluggish movements noted."
                );
            } else if (state.behaviorModel.movementStyle === 'precise') {
                comments.push(
                    "Calculating. Methodical.",
                    "You move with intention.",
                    "Precision detected."
                );
            }

            // Action count based
            if (state.actions.length > 500) {
                comments.push(
                    "You've been here a while. Who's watching whom?",
                    "500+ actions recorded. The model is very confident now.",
                    "I know you better than you know yourself."
                );
            }

            // Depth based
            if (state.depth >= 10) {
                comments.push(
                    "At this depth, the simulation becomes the reality.",
                    "Layer 10+ contains infinite versions of you.",
                    "How deep does the rabbit hole go?"
                );
            }

            // Hesitation detection
            const recentVelocities = velocityHistory.slice(-10);
            const avgRecent = recentVelocities.reduce((a, b) => a + b, 0) / recentVelocities.length;
            if (avgRecent < 1 && state.actions.length > 50) {
                comments.push(
                    "You hesitated. Were you testing me?",
                    "That pause was deliberate.",
                    "Hesitation detected. Decision paralysis?"
                );
            }

            // Time-based
            const sessionDuration = (Date.now() - (state.actions[0]?.timestamp || Date.now())) / 1000;
            if (sessionDuration > 120) {
                comments.push(
                    "2 minutes of observation. Patterns emerging.",
                    "Long session. The model is very accurate now."
                );
            }

            return comments;
        }

        // Debounced localStorage save
        let saveTimeout = null;
        function saveData() {
            if (saveTimeout) clearTimeout(saveTimeout);
            saveTimeout = setTimeout(() => {
                localStorage.setItem(APP_NAME, JSON.stringify({
                    sessionHistory: state.sessionHistory,
                    behaviorModel: state.behaviorModel
                }));
            }, 1000); // Debounce by 1 second
        }

        function exportData() {
            // Generate fingerprint image for export
            const fingerprintDataURL = fingerprintCanvas.toDataURL('image/png');

            const dataStr = JSON.stringify({
                sessionHistory: state.sessionHistory,
                behaviorModel: state.behaviorModel,
                currentSession: {
                    actions: state.actions,
                    predictions: state.predictions,
                    divergenceScore: state.divergenceScore,
                    metaObservations: state.metaObservations
                },
                fingerprintImage: fingerprintDataURL
            }, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `${APP_NAME}-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);

            addLog('Session exported with behavioral fingerprint', 'match');
        }

        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    state.sessionHistory = data.sessionHistory || [];
                    state.behaviorModel = data.behaviorModel || state.behaviorModel;
                    saveData();
                    addLog('Imported behavioral data from file', 'match');
                } catch (error) {
                    alert('Invalid JSON file');
                }
            };
            reader.readAsText(file);
        }

        function addLog(message, type = 'normal') {
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logEntries.insertBefore(entry, logEntries.firstChild);

            // Keep only last 50 entries
            while (logEntries.children.length > 50) {
                logEntries.removeChild(logEntries.lastChild);
            }
        }

        // Batch DOM updates to reduce thrashing
        function updateStats() {
            // Batch all calculations first (reads)
            const depth = state.depth;
            const actionsCount = state.actions.length;
            const totalPreds = state.totalPredictions;
            const divScore = state.divergenceScore;

            let accValue = '—';
            let accClass = 'stat-value';
            if (totalPreds > 0) {
                const acc = (state.correctPredictions / totalPreds * 100).toFixed(1);
                accValue = acc + '%';
                accClass = 'stat-value ' + (acc > 70 ? 'converged' : acc < 40 ? 'diverged' : '');
            }

            const divPercent = Math.min(100, divScore).toFixed(1);
            const divClass = 'stat-value ' + (divScore > 50 ? 'diverged' : divScore < 20 ? 'converged' : '');
            const depthText = `Depth: 0 → ${depth} ${divScore > 70 ? '(DIVERGING)' : ''}`;

            // Then batch all DOM writes
            currentDepthEl.textContent = depth;
            actionsRecordedEl.textContent = actionsCount;
            predictionsMadeEl.textContent = totalPreds;
            accuracyEl.textContent = accValue;
            accuracyEl.className = accClass;
            divergenceLevelEl.textContent = divPercent + '%';
            divergenceLevelEl.className = divClass;
            divergenceFill.style.width = divPercent + '%';
            depthLabel.textContent = depthText;
        }

        function createRecursionLayers() {
            // Clear existing layers
            state.layers.forEach(layer => layer.element.remove());
            state.layers = [];
            state.cursors = [];

            // Batch DOM read
            const viewportRect = viewport.getBoundingClientRect();
            const padding = 40;
            const viewportWidth = viewportRect.width;
            const viewportHeight = viewportRect.height;

            // Create document fragment for batched DOM insertion
            const fragment = document.createDocumentFragment();

            for (let i = 0; i < state.depth; i++) {
                const scale = Math.pow(0.7, i + 1);
                const width = (viewportWidth - padding * 2) * scale;
                const height = (viewportHeight - padding * 2) * scale;

                // Position each layer slightly offset for visual effect
                const offsetX = (viewportWidth - width) / 2 + (i * 5);
                const offsetY = (viewportHeight - height) / 2 + (i * 5);

                const layer = document.createElement('div');
                layer.className = 'recursion-layer';
                layer.setAttribute('data-depth', `Depth ${i + 1}`);
                layer.style.cssText = `
                    width: ${width}px;
                    height: ${height}px;
                    left: ${offsetX}px;
                    top: ${offsetY}px;
                    z-index: ${state.depth - i};
                `;

                // Add mini interactive elements to each layer
                for (let j = 0; j < 3; j++) {
                    const miniEl = document.createElement('div');
                    miniEl.className = 'mini-element';
                    miniEl.style.cssText = `
                        width: ${20 * scale}px;
                        height: ${20 * scale}px;
                        left: ${20 + j * 40 * scale}px;
                        top: ${height - 40 * scale}px;
                    `;
                    layer.appendChild(miniEl);
                }

                // Create ghost cursor for this layer
                const cursor = document.createElement('div');
                cursor.className = 'ghost-cursor';
                cursor.style.color = depthColors[i % depthColors.length];
                cursor.style.opacity = 1 - (i * 0.1);
                layer.appendChild(cursor);

                fragment.appendChild(layer);

                state.layers.push({
                    element: layer,
                    depth: i + 1,
                    scale: scale,
                    offset: { x: offsetX, y: offsetY },
                    cursor: cursor,
                    divergence: 0,
                    predictedPos: { x: 0, y: 0 }
                });
            }

            // Single DOM write
            viewport.appendChild(fragment);
        }

        function analyzeMovementStyle() {
            if (velocityHistory.length < 10) return;

            const avgVelocity = velocityHistory.reduce((a, b) => a + b, 0) / velocityHistory.length;
            const variance = velocityHistory.reduce((sum, v) => sum + Math.pow(v - avgVelocity, 2), 0) / velocityHistory.length;

            if (variance > 1000) {
                state.behaviorModel.movementStyle = 'erratic';
            } else if (avgVelocity < 2) {
                state.behaviorModel.movementStyle = 'lazy';
            } else if (variance < 100) {
                state.behaviorModel.movementStyle = 'precise';
            } else {
                state.behaviorModel.movementStyle = 'smooth';
            }

            state.behaviorModel.avgSpeed = avgVelocity;
        }

        function predictNextPosition(layerIndex) {
            if (state.actions.length < 3) {
                return { ...lastMousePos };
            }

            const recentActions = state.actions.slice(-10);
            const layer = state.layers[layerIndex];

            // Each deeper layer has more prediction error (divergence)
            const errorFactor = Math.pow(1.15, layerIndex + 1);
            const chaos = state.divergenceScore / 100;

            // Calculate predicted position based on behavioral model
            let predictedX = lastMousePos.x;
            let predictedY = lastMousePos.y;

            if (recentActions.length >= 2) {
                const last = recentActions[recentActions.length - 1];
                const prev = recentActions[recentActions.length - 2];

                // Momentum-based prediction
                const dx = last.x - prev.x;
                const dy = last.y - prev.y;

                predictedX = last.x + dx * (0.8 + chaos * 0.5);
                predictedY = last.y + dy * (0.8 + chaos * 0.5);
            }

            // Add behavioral quirks based on learned patterns
            if (state.behaviorModel.movementStyle === 'erratic') {
                predictedX += (Math.random() - 0.5) * 30 * errorFactor;
                predictedY += (Math.random() - 0.5) * 30 * errorFactor;
            } else if (state.behaviorModel.movementStyle === 'lazy') {
                // Predict less movement
                predictedX = predictedX * 0.9 + lastMousePos.x * 0.1;
                predictedY = predictedY * 0.9 + lastMousePos.y * 0.1;
            }

            // Deeper layers increasingly diverge
            const divergenceNoise = layerIndex * 5 * (1 + chaos);
            predictedX += (Math.random() - 0.5) * divergenceNoise;
            predictedY += (Math.random() - 0.5) * divergenceNoise;

            return { x: predictedX, y: predictedY };
        }

        function updateCursors(realX, realY) {
            state.layers.forEach((layer, i) => {
                // Get predicted position for this depth
                const predicted = predictNextPosition(i);
                layer.predictedPos = predicted;

                // Delayed response based on depth
                const delay = (i + 1) * 50;

                setTimeout(() => {
                    if (!state.isObserving) return;

                    // Calculate position within this layer
                    const relX = (predicted.x - layer.offset.x) / layer.scale;
                    const relY = (predicted.y - layer.offset.y) / layer.scale;

                    // Use transform instead of left/top for GPU acceleration
                    layer.cursor.style.transform = `translate(${relX}px, ${relY}px)`;

                    // Calculate divergence for this layer
                    const dx = predicted.x - realX;
                    const dy = predicted.y - realY;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    layer.divergence = distance;

                    // Update layer appearance based on divergence
                    if (distance > 100) {
                        layer.element.classList.add('diverged');
                        layer.element.classList.remove('converged');
                    } else if (distance < 30) {
                        layer.element.classList.add('converged');
                        layer.element.classList.remove('diverged');
                    } else {
                        layer.element.classList.remove('diverged', 'converged');
                    }
                }, delay);
            });
        }

        function simulateClick(x, y) {
            state.layers.forEach((layer, i) => {
                setTimeout(() => {
                    if (!state.isObserving) return;

                    const click = document.createElement('div');
                    click.className = 'ghost-click';
                    click.style.color = depthColors[i % depthColors.length];

                    // Predicted click position (with increasing divergence)
                    const errorFactor = Math.pow(1.2, i + 1);
                    const clickX = (x - layer.offset.x) / layer.scale + (Math.random() - 0.5) * 20 * errorFactor;
                    const clickY = (y - layer.offset.y) / layer.scale + (Math.random() - 0.5) * 20 * errorFactor;

                    click.style.left = (clickX - 20) + 'px';
                    click.style.top = (clickY - 20) + 'px';

                    layer.element.appendChild(click);

                    // Play click sound with echo delay
                    playClickSound(i);

                    setTimeout(() => click.remove(), 600);
                }, (i + 1) * 100);
            });
        }

        function showThought(x, y, thought) {
            const bubble = document.createElement('div');
            bubble.className = 'thought-bubble';
            bubble.textContent = thought;
            bubble.style.left = x + 'px';
            bubble.style.top = y + 'px';
            viewport.appendChild(bubble);

            setTimeout(() => bubble.remove(), 3000);
        }

        function generateThought() {
            const thoughts = [
                "Predicting hesitation...",
                "You're about to move left",
                "Model confidence: " + (100 - state.divergenceScore).toFixed(0) + "%",
                "Pattern detected",
                "Anticipating click",
                "Your style: " + state.behaviorModel.movementStyle,
                "Recursion depth increasing",
                "Simulating your simulation",
                "Who is watching whom?",
                "∞ layers deep",
                "Divergence detected",
                "Adjusting prediction model",
                "Learning your patterns",
                "You hesitated there",
                "Unexpected movement"
            ];
            return thoughts[Math.floor(Math.random() * thoughts.length)];
        }

        // Event listeners
        depthSlider.addEventListener('input', (e) => {
            state.depth = parseInt(e.target.value);
            depthValue.textContent = state.depth;
            if (state.isObserving) {
                createRecursionLayers();
            }
            updateStats();
        });

        startBtn.addEventListener('click', () => {
            if (state.isObserving) {
                stopObservation();
            } else {
                startObservation();
            }
        });

        resetBtn.addEventListener('click', () => {
            stopObservation();
            state.actions = [];
            state.predictions = [];
            state.divergenceScore = 0;
            state.correctPredictions = 0;
            state.totalPredictions = 0;
            velocityHistory = [];
            logEntries.innerHTML = '';
            updateStats();
            addLog('Session reset', 'normal');
        });

        function startObservation() {
            state.isObserving = true;
            viewport.classList.add('recording');
            recordingIndicator.classList.add('active');
            startBtn.textContent = 'Stop Observation';
            startBtn.classList.remove('btn-primary');
            startBtn.classList.add('btn-secondary');

            createRecursionLayers();
            addLog('Observation started - I am watching you', 'prediction');

            // Initialize audio
            initAudio();
            startAmbientDrone();

            // Start periodic thoughts
            state.thoughtInterval = setInterval(() => {
                if (state.isObserving && Math.random() > 0.6) {
                    showThought(
                        Math.random() * (viewport.clientWidth - 200) + 100,
                        Math.random() * (viewport.clientHeight - 100) + 50,
                        generateThought()
                    );
                }
            }, 2000);

            // Start meta-commentary
            state.metaInterval = setInterval(() => {
                if (state.isObserving) {
                    showMetaCommentary();
                }
            }, 5000);

            // Update visual effects
            state.visualInterval = setInterval(() => {
                if (state.isObserving) {
                    updateGlitchEffects();
                    updateInfinityMirror();
                    generateBehavioralFingerprint();
                    updateAmbientFrequency();
                    updateWebcamDistortion();
                }
            }, 1000);
        }

        function stopObservation() {
            state.isObserving = false;
            viewport.classList.remove('recording');
            recordingIndicator.classList.remove('active');
            startBtn.textContent = 'Begin Observation';
            startBtn.classList.add('btn-primary');
            startBtn.classList.remove('btn-secondary');

            // Stop audio
            stopAmbientDrone();

            // Clear intervals
            if (state.thoughtInterval) {
                clearInterval(state.thoughtInterval);
            }
            if (state.metaInterval) {
                clearInterval(state.metaInterval);
            }
            if (state.visualInterval) {
                clearInterval(state.visualInterval);
            }

            // Save session
            if (state.actions.length > 0) {
                state.sessionHistory.push({
                    timestamp: Date.now(),
                    actions: state.actions.length,
                    divergence: state.divergenceScore,
                    accuracy: state.totalPredictions > 0 ?
                        (state.correctPredictions / state.totalPredictions * 100) : 0,
                    metaObservationCount: state.metaObservations.length
                });
                saveData();
                addLog(`Session saved. Final divergence: ${state.divergenceScore.toFixed(1)}%`, 'normal');
            }

            // Clear layers
            state.layers.forEach(layer => layer.element.remove());
            state.layers = [];

            // Turn off effects
            glitchOverlay.classList.remove('active');
            chromaticEffect.classList.remove('active');
            infinityMirror.classList.remove('active');
        }

        // RequestAnimationFrame throttling for mousemove
        let rafId = null;
        let pendingMouseEvent = null;

        function handleMouseMove(e) {
            pendingMouseEvent = e;

            if (rafId === null) {
                rafId = requestAnimationFrame(() => {
                    if (!state.isObserving || !pendingMouseEvent) {
                        rafId = null;
                        return;
                    }

                    const e = pendingMouseEvent;
                    const rect = viewport.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;

                    // Calculate velocity
                    const now = Date.now();
                    const dt = now - lastMoveTime;
                    if (dt > 0) {
                        const dx = x - lastMousePos.x;
                        const dy = y - lastMousePos.y;
                        const velocity = Math.sqrt(dx * dx + dy * dy) / dt * 100;
                        velocityHistory.push(velocity);
                        if (velocityHistory.length > 50) velocityHistory.shift();
                    }

                    // Record action
                    state.actions.push({
                        type: 'move',
                        x, y,
                        timestamp: now,
                        velocity: velocityHistory[velocityHistory.length - 1] || 0
                    });

                    // Update prediction accuracy
                    if (state.layers.length > 0 && state.actions.length > 5) {
                        const avgLayerDivergence = state.layers.reduce((sum, l) => sum + l.divergence, 0) / state.layers.length;

                        state.totalPredictions++;
                        if (avgLayerDivergence < 50) {
                            state.correctPredictions++;
                        }

                        // Update overall divergence score
                        state.divergenceScore = state.divergenceScore * 0.95 + avgLayerDivergence * 0.05;
                        state.divergenceScore = Math.min(100, state.divergenceScore);
                    }

                    // Analyze movement patterns periodically
                    if (state.actions.length % 20 === 0) {
                        analyzeMovementStyle();
                        if (state.behaviorModel.movementStyle !== 'unknown') {
                            addLog(`Movement style detected: ${state.behaviorModel.movementStyle}`, 'prediction');
                        }
                    }

                    updateCursors(x, y);
                    lastMousePos = { x, y };
                    lastMoveTime = now;

                    // Update visual effects
                    updateHeatMap();
                    drawPredictionTrails();

                    // Update stats less frequently
                    if (state.actions.length % 10 === 0) {
                        updateStats();
                    }

                    rafId = null;
                });
            }
        }

        viewport.addEventListener('mousemove', handleMouseMove, { passive: true });

        viewport.addEventListener('click', (e) => {
            if (!state.isObserving) return;

            const rect = viewport.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            state.actions.push({
                type: 'click',
                x, y,
                timestamp: Date.now()
            });

            simulateClick(x, y);
            addLog(`Click registered at (${x.toFixed(0)}, ${y.toFixed(0)})`, 'normal');

            // Check if any layer predicted this click
            state.layers.forEach((layer, i) => {
                const dist = Math.sqrt(
                    Math.pow(layer.predictedPos.x - x, 2) +
                    Math.pow(layer.predictedPos.y - y, 2)
                );

                if (dist < 40) {
                    addLog(`Layer ${i + 1} predicted your click!`, 'match');
                } else if (dist > 100 && i > 2) {
                    addLog(`Layer ${i + 1} diverged significantly`, 'divergence');
                    state.divergenceScore += 2;
                }
            });

            updateStats();
        });

        // Sound toggle
        soundToggle.addEventListener('click', () => {
            soundEnabled = !soundEnabled;
            soundToggle.classList.toggle('muted');

            if (soundEnabled) {
                if (state.isObserving) {
                    initAudio();
                    startAmbientDrone();
                }
                addLog('Sound enabled', 'normal');
            } else {
                stopAmbientDrone();
                addLog('Sound muted', 'normal');
            }
        });

        // Webcam toggle
        webcamToggle.addEventListener('click', () => {
            if (webcamEnabled) {
                disableWebcam();
            } else {
                enableWebcam();
            }
        });

        // Initialize
        updateStats();
        generateBehavioralFingerprint();
        addLog('Recursive Self-Portrait initialized', 'normal');
        addLog('The system will learn your patterns and simulate you simulating yourself...', 'prediction');

        if (state.sessionHistory.length > 0) {
            const lastSession = state.sessionHistory[state.sessionHistory.length - 1];
            addLog(`Previous session: ${lastSession.actions} actions, ${lastSession.divergence.toFixed(1)}% divergence`, 'normal');
        }

        // Start with sound muted (user must click to activate - better UX)
        soundToggle.classList.add('muted');
        soundEnabled = false;
    </script>
</body>
</html>
