<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Recursive Self-Portrait</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Courier New', monospace;
            background: #0a0a0f;
            color: #e0e0e0;
            min-height: 100vh;
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        .simulation-viewport {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: linear-gradient(135deg, #0d0d15 0%, #1a1a2e 100%);
        }

        .recursion-layer {
            position: absolute;
            border: 2px solid rgba(100, 200, 255, 0.3);
            border-radius: 8px;
            background: rgba(10, 10, 20, 0.9);
            box-shadow:
                0 0 20px rgba(100, 200, 255, 0.1),
                inset 0 0 40px rgba(100, 200, 255, 0.05);
            transition: all 0.3s ease;
            overflow: hidden;
        }

        .recursion-layer::before {
            content: attr(data-depth);
            position: absolute;
            top: 5px;
            left: 10px;
            font-size: 10px;
            color: rgba(100, 200, 255, 0.6);
            z-index: 10;
        }

        .recursion-layer.diverged {
            border-color: rgba(255, 100, 100, 0.5);
            box-shadow:
                0 0 30px rgba(255, 100, 100, 0.2),
                inset 0 0 40px rgba(255, 100, 100, 0.05);
        }

        .recursion-layer.converged {
            border-color: rgba(100, 255, 150, 0.5);
            box-shadow:
                0 0 30px rgba(100, 255, 150, 0.2),
                inset 0 0 40px rgba(100, 255, 150, 0.05);
        }

        .ghost-cursor {
            position: absolute;
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 100;
            will-change: transform;
        }

        .ghost-cursor::before {
            content: '';
            position: absolute;
            width: 0;
            height: 0;
            border-left: 8px solid currentColor;
            border-top: 5px solid transparent;
            border-bottom: 5px solid transparent;
            transform: rotate(-45deg);
        }

        .ghost-cursor::after {
            content: '';
            position: absolute;
            top: 12px;
            left: 6px;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
            opacity: 0.5;
        }

        /* ===== SHADOW SELF CURSOR ===== */
        .shadow-cursor {
            position: absolute;
            width: 24px;
            height: 24px;
            pointer-events: none;
            z-index: 99;
            filter: drop-shadow(0 0 8px rgba(0, 0, 0, 0.9));
            will-change: transform;
            transition: filter 0.3s ease;
        }

        .shadow-cursor::before {
            content: '';
            position: absolute;
            width: 0;
            height: 0;
            border-left: 10px solid #000;
            border-top: 6px solid transparent;
            border-bottom: 6px solid transparent;
            transform: rotate(-45deg);
            opacity: 0.85;
        }

        .shadow-cursor::after {
            content: '';
            position: absolute;
            top: 14px;
            left: 7px;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #000;
            opacity: 0.7;
        }

        .shadow-cursor.rebelling {
            filter: drop-shadow(0 0 15px rgba(255, 0, 0, 0.8));
        }

        .shadow-cursor.rebelling::before {
            border-left-color: #ff0000;
        }

        .shadow-cursor.rebelling::after {
            background: #ff0000;
            animation: shadowPulse 0.5s ease-in-out;
        }

        .shadow-cursor.taking-over {
            filter: drop-shadow(0 0 25px rgba(138, 43, 226, 1));
            animation: shadowTakeover 2s ease-in-out;
        }

        .shadow-cursor.taking-over::before {
            border-left-color: #8a2be2;
            animation: shadowGrow 0.5s ease-in-out infinite alternate;
        }

        @keyframes shadowPulse {
            0%, 100% { transform: scale(1); opacity: 0.7; }
            50% { transform: scale(1.5); opacity: 1; }
        }

        @keyframes shadowGrow {
            0% { transform: rotate(-45deg) scale(1); }
            100% { transform: rotate(-45deg) scale(1.3); }
        }

        @keyframes shadowTakeover {
            0%, 100% { opacity: 0.85; }
            50% { opacity: 1; }
        }

        .shadow-trail {
            position: absolute;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(0, 0, 0, 0.6), transparent);
            pointer-events: none;
            animation: shadowTrailFade 1.5s ease-out forwards;
        }

        @keyframes shadowTrailFade {
            0% { transform: scale(1); opacity: 0.6; }
            100% { transform: scale(0.3); opacity: 0; }
        }

        .shadow-commentary {
            position: fixed;
            bottom: 20px;
            left: 20px;
            max-width: 400px;
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid rgba(138, 43, 226, 0.6);
            border-radius: 12px;
            padding: 20px;
            color: #e0e0e0;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            line-height: 1.5;
            box-shadow: 0 8px 32px rgba(138, 43, 226, 0.3);
            z-index: 1001;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.4s ease;
        }

        .shadow-commentary.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .shadow-commentary-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(138, 43, 226, 0.4);
        }

        .shadow-commentary-title {
            font-weight: bold;
            color: #8a2be2;
            font-size: 0.95em;
        }

        .shadow-commentary-close {
            background: none;
            border: none;
            color: #888;
            cursor: pointer;
            font-size: 1.2em;
            padding: 0;
            width: 20px;
            height: 20px;
            line-height: 1;
        }

        .shadow-commentary-close:hover {
            color: #fff;
        }

        .shadow-commentary-text {
            font-style: italic;
            color: #d0d0d0;
        }

        .shadow-alignment-meter {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
        }

        .shadow-alignment-label {
            display: block;
            margin-bottom: 10px;
            color: #aaa;
            font-size: 0.9em;
        }

        .shadow-alignment-bar {
            width: 100%;
            height: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            overflow: hidden;
            position: relative;
            border: 1px solid rgba(138, 43, 226, 0.3);
        }

        .shadow-alignment-fill {
            height: 100%;
            background: linear-gradient(90deg, #8a2be2, #ff00ff);
            border-radius: 10px;
            transition: width 0.3s ease;
            position: relative;
        }

        .shadow-alignment-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .shadow-alignment-value {
            display: block;
            text-align: center;
            margin-top: 8px;
            color: #8a2be2;
            font-weight: bold;
            font-size: 0.9em;
        }

        .shadow-personality-panel {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
            margin-top: 10px;
        }

        .shadow-personality-trait {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.85em;
        }

        .shadow-trait-label {
            color: #888;
        }

        .shadow-trait-value {
            color: #8a2be2;
            font-weight: bold;
        }

        .ghost-click {
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid currentColor;
            animation: clickRipple 0.6s ease-out forwards;
            pointer-events: none;
        }

        @keyframes clickRipple {
            0% { transform: scale(0); opacity: 1; }
            100% { transform: scale(2); opacity: 0; }
        }

        .sidebar {
            width: 320px;
            background: rgba(15, 15, 25, 0.95);
            border-left: 1px solid rgba(100, 200, 255, 0.2);
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            overflow-y: auto;
        }

        h1 {
            font-size: 1.4em;
            background: linear-gradient(90deg, #64c8ff, #a080ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-align: center;
        }

        .subtitle {
            font-size: 0.75em;
            color: #888;
            text-align: center;
            font-style: italic;
        }

        .stats-panel {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(100, 200, 255, 0.1);
        }

        .stat-row:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }

        .stat-label {
            color: #888;
            font-size: 0.85em;
        }

        .stat-value {
            font-weight: bold;
            color: #64c8ff;
        }

        .stat-value.diverged { color: #ff6464; }
        .stat-value.converged { color: #64ff96; }

        .depth-slider {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
        }

        .depth-slider label {
            display: block;
            margin-bottom: 10px;
            color: #aaa;
            font-size: 0.9em;
        }

        .depth-slider input[type="range"] {
            width: 100%;
            height: 8px;
            -webkit-appearance: none;
            appearance: none;
            background: linear-gradient(90deg, #1a1a2e, #64c8ff);
            border-radius: 4px;
            outline: none;
        }

        .depth-slider input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: #64c8ff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(100, 200, 255, 0.5);
        }

        .behavior-log {
            flex: 1;
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
            overflow-y: auto;
            min-height: 200px;
        }

        .behavior-log h3 {
            color: #888;
            font-size: 0.85em;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .log-entry {
            font-size: 0.75em;
            padding: 5px 8px;
            margin-bottom: 5px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            border-left: 3px solid #64c8ff;
            color: #aaa;
        }

        .log-entry.prediction { border-left-color: #a080ff; }
        .log-entry.divergence { border-left-color: #ff6464; }
        .log-entry.match { border-left-color: #64ff96; }

        .controls {
            display: flex;
            gap: 10px;
        }

        button {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 6px;
            font-family: inherit;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #64c8ff, #a080ff);
            color: #0a0a0f;
            font-weight: bold;
        }

        .btn-secondary {
            background: rgba(100, 200, 255, 0.1);
            color: #64c8ff;
            border: 1px solid rgba(100, 200, 255, 0.3);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(100, 200, 255, 0.3);
        }

        .divergence-meter {
            height: 8px;
            background: rgba(30, 30, 50, 0.8);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 10px;
        }

        .divergence-fill {
            height: 100%;
            background: linear-gradient(90deg, #64ff96, #ffff64, #ff6464);
            transition: width 0.3s ease;
        }

        .philosophical-quote {
            text-align: center;
            font-style: italic;
            color: #666;
            font-size: 0.8em;
            padding: 15px;
            border-top: 1px solid rgba(100, 200, 255, 0.1);
        }

        .voice-panel {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
        }

        .voice-panel h3 {
            color: #888;
            font-size: 0.85em;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .voice-toggle-btn {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 6px;
            font-family: inherit;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.2s ease;
            background: rgba(160, 128, 255, 0.1);
            color: #a080ff;
            border: 1px solid rgba(160, 128, 255, 0.3);
            margin-bottom: 12px;
        }

        .voice-toggle-btn.active {
            background: linear-gradient(135deg, #a080ff, #64c8ff);
            color: #0a0a0f;
            font-weight: bold;
        }

        .voice-toggle-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(160, 128, 255, 0.3);
        }

        .voice-control {
            margin-bottom: 12px;
        }

        .voice-control label {
            display: block;
            margin-bottom: 5px;
            color: #aaa;
            font-size: 0.85em;
        }

        .voice-control input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: linear-gradient(90deg, #1a1a2e, #a080ff);
            border-radius: 3px;
            outline: none;
        }

        .voice-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #a080ff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 8px rgba(160, 128, 255, 0.5);
        }

        .voice-control input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #a080ff;
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 8px rgba(160, 128, 255, 0.5);
        }

        .voice-status {
            font-size: 0.75em;
            color: #666;
            padding: 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            text-align: center;
        }

        .voice-status.speaking {
            color: #a080ff;
            animation: pulse 1s infinite;
        }

        .transcript-panel {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
            margin-top: 10px;
            max-height: 150px;
            overflow-y: auto;
        }

        .transcript-panel h3 {
            color: #888;
            font-size: 0.85em;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .transcript-entry {
            font-size: 0.75em;
            padding: 5px 8px;
            margin-bottom: 5px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            border-left: 3px solid #a080ff;
            color: #aaa;
        }

        .transcript-entry.user {
            border-left-color: #64ff96;
        }

        .interaction-zone {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 200px;
            height: 200px;
            border: 2px dashed rgba(100, 200, 255, 0.3);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
            font-size: 0.9em;
            text-align: center;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .simulation-viewport:not(.recording) .interaction-zone {
            opacity: 1;
        }

        .recording-indicator {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 15px;
            background: rgba(255, 64, 64, 0.2);
            border: 1px solid rgba(255, 64, 64, 0.5);
            border-radius: 20px;
            color: #ff6464;
            font-size: 0.85em;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .recording-indicator.active {
            opacity: 1;
        }

        .recording-dot {
            width: 10px;
            height: 10px;
            background: #ff6464;
            border-radius: 50%;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        .depth-label {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 20px;
            border-radius: 20px;
            font-size: 0.9em;
            color: #64c8ff;
        }


        .zoom-level-indicator {
            position: absolute;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 25px;
            border-radius: 25px;
            font-size: 1em;
            color: #a080ff;
            border: 2px solid rgba(160, 128, 255, 0.4);
            box-shadow: 0 0 20px rgba(160, 128, 255, 0.3);
            font-weight: bold;
            z-index: 1000;
        }

        .zoom-level-indicator .zoom-icon {
            display: inline-block;
            margin-right: 8px;
            animation: zoomPulse 1.5s ease-in-out infinite;
        }

        @keyframes zoomPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }

        .extreme-depth-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 300;
            opacity: 0;
            transition: opacity 0.5s;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(255, 0, 255, 0.03) 2px,
                rgba(255, 0, 255, 0.03) 4px
            );
        }

        .extreme-depth-overlay.active {
            opacity: 1;
            animation: extremeGlitch 0.5s infinite;
        }

        @keyframes extremeGlitch {
            0%, 100% { transform: translate(0, 0); filter: hue-rotate(0deg); }
            25% { transform: translate(-3px, 2px); filter: hue-rotate(90deg); }
            50% { transform: translate(3px, -2px); filter: hue-rotate(180deg); }
            75% { transform: translate(-2px, -3px); filter: hue-rotate(270deg); }
        }

        .simulation-limit-warning {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 0, 100, 0.2);
            border: 3px solid rgba(255, 0, 100, 0.6);
            padding: 30px 40px;
            border-radius: 15px;
            font-size: 1.2em;
            color: #ff0064;
            text-align: center;
            font-weight: bold;
            z-index: 400;
            opacity: 0;
            pointer-events: none;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .simulation-limit-warning.active {
            opacity: 1;
            animation: warningFlash 1s ease-in-out infinite;
        }

        @keyframes warningFlash {
            0%, 100% { opacity: 0.8; box-shadow: 0 0 20px rgba(255, 0, 100, 0.5); }
            50% { opacity: 1; box-shadow: 0 0 40px rgba(255, 0, 100, 0.8); }
        }

        .zoom-controls {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
        }

        .zoom-controls h4 {
            color: #888;
            font-size: 0.85em;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .zoom-button-group {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }

        .zoom-btn {
            flex: 1;
            padding: 8px 12px;
            background: rgba(100, 200, 255, 0.1);
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 6px;
            color: #64c8ff;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.85em;
            transition: all 0.2s;
        }

        .zoom-btn:hover {
            background: rgba(100, 200, 255, 0.2);
            transform: translateY(-1px);
        }

        .zoom-btn.active {
            background: linear-gradient(135deg, #64c8ff, #a080ff);
            color: #0a0a0f;
            font-weight: bold;
        }

        .auto-zoom-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .auto-zoom-toggle:hover {
            background: rgba(100, 200, 255, 0.1);
        }

        .auto-zoom-toggle.active {
            background: rgba(160, 128, 255, 0.2);
            border: 1px solid rgba(160, 128, 255, 0.4);
        }

        .toggle-switch {
            position: relative;
            width: 40px;
            height: 20px;
            background: rgba(100, 100, 100, 0.5);
            border-radius: 10px;
            transition: background 0.3s;
            flex-shrink: 0;
        }

        .toggle-switch.active {
            background: linear-gradient(90deg, #64c8ff, #a080ff);
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 16px;
            height: 16px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s;
        }

        .toggle-switch.active::after {
            transform: translateX(20px);
        }

        .zoom-info {
            font-size: 0.75em;
            color: #888;
            margin-top: 8px;
            font-style: italic;
        }

        .data-controls {

        .zoom-level-indicator {
            position: absolute;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 25px;
            border-radius: 25px;
            font-size: 1em;
            color: #a080ff;
            border: 2px solid rgba(160, 128, 255, 0.4);
            box-shadow: 0 0 20px rgba(160, 128, 255, 0.3);
            font-weight: bold;
            z-index: 1000;
        }

        .zoom-level-indicator .zoom-icon {
            display: inline-block;
            margin-right: 8px;
            animation: zoomPulse 1.5s ease-in-out infinite;
        }

        @keyframes zoomPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }

        .extreme-depth-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 300;
            opacity: 0;
            transition: opacity 0.5s;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(255, 0, 255, 0.03) 2px,
                rgba(255, 0, 255, 0.03) 4px
            );
        }

        .extreme-depth-overlay.active {
            opacity: 1;
            animation: extremeGlitch 0.5s infinite;
        }

        @keyframes extremeGlitch {
            0%, 100% { transform: translate(0, 0); filter: hue-rotate(0deg); }
            25% { transform: translate(-3px, 2px); filter: hue-rotate(90deg); }
            50% { transform: translate(3px, -2px); filter: hue-rotate(180deg); }
            75% { transform: translate(-2px, -3px); filter: hue-rotate(270deg); }
        }

        .simulation-limit-warning {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 0, 100, 0.2);
            border: 3px solid rgba(255, 0, 100, 0.6);
            padding: 30px 40px;
            border-radius: 15px;
            font-size: 1.2em;
            color: #ff0064;
            text-align: center;
            font-weight: bold;
            z-index: 400;
            opacity: 0;
            pointer-events: none;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .simulation-limit-warning.active {
            opacity: 1;
            animation: warningFlash 1s ease-in-out infinite;
        }

        @keyframes warningFlash {
            0%, 100% { opacity: 0.8; box-shadow: 0 0 20px rgba(255, 0, 100, 0.5); }
            50% { opacity: 1; box-shadow: 0 0 40px rgba(255, 0, 100, 0.8); }
        }

        .zoom-controls {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
        }

        .zoom-controls h4 {
            color: #888;
            font-size: 0.85em;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .zoom-button-group {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }

        .zoom-btn {
            flex: 1;
            padding: 8px 12px;
            background: rgba(100, 200, 255, 0.1);
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 6px;
            color: #64c8ff;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.85em;
            transition: all 0.2s;
        }

        .zoom-btn:hover {
            background: rgba(100, 200, 255, 0.2);
            transform: translateY(-1px);
        }

        .zoom-btn.active {
            background: linear-gradient(135deg, #64c8ff, #a080ff);
            color: #0a0a0f;
            font-weight: bold;
        }

        .auto-zoom-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .auto-zoom-toggle:hover {
            background: rgba(100, 200, 255, 0.1);
        }

        .auto-zoom-toggle.active {
            background: rgba(160, 128, 255, 0.2);
            border: 1px solid rgba(160, 128, 255, 0.4);
        }

        .toggle-switch {
            position: relative;
            width: 40px;
            height: 20px;
            background: rgba(100, 100, 100, 0.5);
            border-radius: 10px;
            transition: background 0.3s;
            flex-shrink: 0;
        }

        .toggle-switch.active {
            background: linear-gradient(90deg, #64c8ff, #a080ff);
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 16px;
            height: 16px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s;
        }

        .toggle-switch.active::after {
            transform: translateX(20px);
        }

        .zoom-info {
            font-size: 0.75em;
            color: #888;
            margin-top: 8px;
            font-style: italic;
        }
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
            display: flex;
            gap: 10px;
        }

        .data-controls button {
            padding: 8px 16px;
            font-size: 0.8em;
            background: rgba(100, 200, 255, 0.1);
            border: 1px solid rgba(100, 200, 255, 0.3);
            color: #64c8ff;
        }

        .mini-element {
            position: absolute;
            background: rgba(100, 200, 255, 0.3);
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .mini-element:hover {
            background: rgba(100, 200, 255, 0.5);
        }

        .thought-bubble {
            position: absolute;
            background: rgba(160, 128, 255, 0.2);
            border: 1px solid rgba(160, 128, 255, 0.4);
            border-radius: 12px;
            padding: 8px 12px;
            font-size: 0.7em;
            color: #a080ff;
            pointer-events: none;
            animation: floatUp 3s ease-out forwards;
            white-space: nowrap;
        }

        @keyframes floatUp {
            0% { opacity: 0; transform: translateY(10px); }
            20% { opacity: 1; }
            80% { opacity: 1; }
            100% { opacity: 0; transform: translateY(-30px); }
        }

        .infinity-symbol {
            position: absolute;
            font-size: 100px;
            color: rgba(100, 200, 255, 0.05);
            pointer-events: none;
            animation: rotate 20s linear infinite;
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* Prediction trails */
        .prediction-trail {
            position: absolute;
            pointer-events: none;
            z-index: 50;
        }

        .prediction-trail path {
            fill: none;
            stroke-width: 2;
            opacity: 0.4;
            stroke-dasharray: 5, 5;
            animation: dashMove 1s linear infinite;
        }

        @keyframes dashMove {
            to { stroke-dashoffset: -10; }
        }

        /* Heat map */
        .heat-map {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
            opacity: 0.4;
        }

        .heat-point {
            position: absolute;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255, 100, 100, 0.6), transparent);
            will-change: transform, opacity;
            animation: heatFade 3s ease-out forwards;
        }

        @keyframes heatFade {
            from { opacity: 1; }
            to { opacity: 0; }
        }

        /* Glitch effects */
        .glitch-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 200;
            opacity: 0;
            transition: opacity 0.1s;
        }

        .glitch-overlay.active {
            opacity: 1;
        }

        .scanline {
            position: absolute;
            left: 0;
            width: 100%;
            height: 2px;
            background: rgba(100, 200, 255, 0.3);
            animation: scan 4s linear infinite;
        }

        @keyframes scan {
            from { top: 0%; }
            to { top: 100%; }
        }

        .recursion-layer.glitching {
            animation: glitchShake 0.2s infinite;
        }

        @keyframes glitchShake {
            0%, 100% { transform: translate(0, 0); }
            25% { transform: translate(-2px, 2px); }
            50% { transform: translate(2px, -2px); }
            75% { transform: translate(-2px, -2px); }
        }

        .chromatic-aberration {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            mix-blend-mode: screen;
            opacity: 0;
        }

        .chromatic-aberration.active {
            opacity: 0.3;
            animation: chromaticGlitch 0.3s infinite;
        }

        @keyframes chromaticGlitch {
            0% { transform: translate(0, 0); }
            33% { transform: translate(2px, 0); filter: hue-rotate(90deg); }
            66% { transform: translate(-2px, 0); filter: hue-rotate(180deg); }
            100% { transform: translate(0, 0); }
        }

        /* Behavioral fingerprint */
        .fingerprint-panel {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
            min-height: 150px;
        }

        .fingerprint-panel h3 {
            color: #888;
            font-size: 0.85em;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #fingerprintCanvas {
            width: 100%;
            height: 120px;
            border-radius: 4px;
            background: rgba(0, 0, 0, 0.3);
        }

        /* Meta-commentary */
        .meta-comment {
            position: absolute;
            background: rgba(255, 100, 100, 0.15);
            border: 1px solid rgba(255, 100, 100, 0.4);
            border-radius: 8px;
            padding: 12px 16px;
            font-size: 0.75em;
            color: #ff6464;
            pointer-events: none;
            animation: metaDrift 8s ease-out forwards;
            max-width: 300px;
            text-align: center;
            font-style: italic;
            z-index: 150;
        }

        @keyframes metaDrift {
            0% { opacity: 0; transform: translateY(0) scale(0.9); }
            10% { opacity: 1; transform: translateY(-10px) scale(1); }
            90% { opacity: 1; transform: translateY(-40px) scale(1); }
            100% { opacity: 0; transform: translateY(-60px) scale(0.95); }
        }

        /* Infinity mirror effect */
        .infinity-mirror {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
            opacity: 0;
            transition: opacity 0.5s;
        }

        .infinity-mirror.active {
            opacity: 1;
        }

        .infinity-ring {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 1px solid rgba(100, 200, 255, 0.2);
            border-radius: 50%;
            animation: expandRing 3s ease-out infinite;
        }

        @keyframes expandRing {
            0% { width: 50px; height: 50px; opacity: 0.8; }
            100% { width: 400px; height: 400px; opacity: 0; }
        }

        /* Webcam integration */
        .webcam-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 120px;
            height: 90px;
            border: 2px solid rgba(100, 200, 255, 0.3);
            border-radius: 8px;
            overflow: hidden;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 100;
        }

        .webcam-container.active {
            opacity: 1;
        }

        #webcamVideo {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }

        .webcam-distortion {
            filter: hue-rotate(0deg) blur(0px);
            transition: filter 0.3s;
        }

        /* Emotion detection overlay */
        .emotion-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(to top, rgba(0, 0, 0, 0.8), transparent);
            padding: 4px 8px;
            font-size: 10px;
            color: #64c8ff;
            text-align: center;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }

        .webcam-container.active .emotion-overlay {
            opacity: 1;
        }

        .emotion-overlay .emotion-icon {
            font-size: 14px;
            margin-right: 4px;
        }

        .emotion-overlay .confidence {
            font-size: 8px;
            color: rgba(100, 200, 255, 0.6);
            margin-left: 4px;
        }

        /* Hidden canvas for emotion analysis */
        #emotionCanvas {
            display: none;
        }

        /* Mobile responsive */
        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }

            .sidebar {
                width: 100%;
                max-height: 40vh;
                border-left: none;
                border-top: 1px solid rgba(100, 200, 255, 0.2);
                order: 2;
            }

            .simulation-viewport {
                order: 1;
                height: 60vh;
            }

            .depth-label {
                bottom: 10px;
                font-size: 0.75em;
            }

            .recording-indicator {
                top: 10px;
                left: 10px;
                font-size: 0.7em;
                padding: 6px 10px;
            }

            .meta-comment {
                max-width: 200px;
                font-size: 0.65em;
            }

            .webcam-container {
                width: 80px;
                height: 60px;
                bottom: 10px;
                right: 10px;
            }

            button {
                padding: 10px;
                font-size: 0.85em;
            }
        }

        /* Sound indicator */
        .sound-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            background: rgba(100, 200, 255, 0.1);
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            z-index: 1000;
        }

        .sound-indicator:hover {
            background: rgba(100, 200, 255, 0.2);
        }

        .sound-indicator.muted {
            opacity: 0.4;
        }

        .sound-wave {
            width: 20px;
            height: 20px;
            display: flex;
            gap: 3px;
            align-items: center;
            justify-content: center;
        }

        .sound-bar {
            width: 3px;
            background: #64c8ff;
            border-radius: 2px;
            animation: soundPulse 0.8s ease-in-out infinite;
        }

        .sound-bar:nth-child(1) { height: 8px; animation-delay: 0s; }
        .sound-bar:nth-child(2) { height: 14px; animation-delay: 0.2s; }
        .sound-bar:nth-child(3) { height: 10px; animation-delay: 0.4s; }

        @keyframes soundPulse {
            0%, 100% { transform: scaleY(1); }
            50% { transform: scaleY(1.5); }
        }

        .sound-indicator.muted .sound-bar {
            animation: none;
            height: 2px !important;
        }

        /* ===== SYNAESTHESIA MODE STYLES ===== */
        .synaesthesia-panel {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
        }

        .synaesthesia-panel h3 {
            color: #888;
            font-size: 0.85em;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .synaesthesia-toggle-btn {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 6px;
            font-family: inherit;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.2s ease;
            background: rgba(255, 100, 200, 0.1);
            color: #ff64c8;
            border: 1px solid rgba(255, 100, 200, 0.3);
            margin-bottom: 12px;
        }

        .synaesthesia-toggle-btn.active {
            background: linear-gradient(135deg, #ff64c8, #c864ff);
            color: #0a0a0f;
            font-weight: bold;
        }

        .synaesthesia-toggle-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(255, 100, 200, 0.3);
        }

        .synaesthesia-description {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 100, 200, 0.95);
            border: 2px solid rgba(255, 100, 200, 0.8);
            border-radius: 12px;
            padding: 15px 25px;
            font-size: 1.1em;
            color: #0a0a0f;
            text-align: center;
            font-weight: bold;
            z-index: 500;
            opacity: 0;
            pointer-events: none;
            max-width: 500px;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            animation: synaesthesiaDrift 4s ease-out forwards;
        }

        @keyframes synaesthesiaDrift {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
        }

        .speed-color-indicator {
            position: absolute;
            top: 80px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 0.85em;
            color: #fff;
            border: 2px solid rgba(255, 100, 200, 0.4);
            z-index: 1000;
            opacity: 0;
            transition: all 0.3s;
        }

        .speed-color-indicator.active {
            opacity: 1;
        }

        .speed-color-indicator .color-swatch {
            display: inline-block;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-left: 8px;
            vertical-align: middle;
            border: 2px solid rgba(255, 255, 255, 0.5);
        }

        .taste-indicator {
            position: absolute;
            top: 130px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 0.85em;
            color: #fff;
            border: 2px solid rgba(255, 200, 100, 0.4);
            z-index: 1000;
            opacity: 0;
            transition: all 0.3s;
        }

        .taste-indicator.active {
            opacity: 1;
        }

        .temperature-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.5s;
            mix-blend-mode: overlay;
        }

        .temperature-overlay.active {
            opacity: 0.3;
        }

        .waveform-visualizer {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 300px;
            height: 80px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid rgba(100, 200, 255, 0.4);
            border-radius: 8px;
            z-index: 1000;
            opacity: 0;
            transition: all 0.3s;
        }

        .waveform-visualizer.active {
            opacity: 1;
        }

        #waveformCanvas {
            width: 100%;
            height: 100%;
        }

        .layer-flavor-badge {
            position: absolute;
            top: 30px;
            right: 10px;
            font-size: 10px;
            background: rgba(255, 100, 200, 0.3);
            padding: 4px 8px;
            border-radius: 10px;
            color: #ff64c8;
            pointer-events: none;
            z-index: 15;
        }

        .click-burst {
            position: absolute;
            pointer-events: none;
            border-radius: 50%;
            animation: burstExpand 0.8s ease-out forwards;
            z-index: 500;
        }

        @keyframes burstExpand {
            0% { transform: scale(0); opacity: 1; }
            100% { transform: scale(5); opacity: 0; }
        }

        .chord-visualizer {
            position: absolute;
            bottom: 110px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 15px;
            border-radius: 12px;
            font-size: 0.8em;
            color: #a080ff;
            border: 2px solid rgba(160, 128, 255, 0.4);
            z-index: 1000;
            opacity: 0;
            transition: all 0.3s;
            max-width: 250px;
        }

        .chord-visualizer.active {
            opacity: 1;
        }

        .chord-notes {
            display: flex;
            gap: 5px;
            margin-top: 5px;
        }

        .chord-note {
            padding: 3px 8px;
            background: rgba(160, 128, 255, 0.2);
            border-radius: 4px;
            font-size: 0.75em;
        }

        /* Keyboard focus indicators */
        button:focus,
        input[type="range"]:focus,
        .sound-indicator:focus {
            outline: 2px solid #64c8ff;
            outline-offset: 3px;
        }

        button:focus-visible,
        input[type="range"]:focus-visible,
        .sound-indicator:focus-visible {
            outline: 2px solid #64c8ff;
            outline-offset: 3px;
            box-shadow: 0 0 15px rgba(100, 200, 255, 0.5);
        }

        /* Keyboard shortcuts help overlay */
        .shortcuts-overlay {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10, 10, 20, 0.98);
            border: 2px solid rgba(100, 200, 255, 0.5);
            border-radius: 12px;
            padding: 30px;
            z-index: 2000;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 10px 50px rgba(0, 0, 0, 0.8);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .shortcuts-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }

        .shortcuts-overlay h2 {
            color: #64c8ff;
            font-size: 1.3em;
            margin-bottom: 20px;
            text-align: center;
            background: linear-gradient(90deg, #64c8ff, #a080ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .shortcuts-grid {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 12px 20px;
            margin-bottom: 20px;
        }

        .shortcut-key {
            background: rgba(100, 200, 255, 0.1);
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 4px;
            padding: 4px 10px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            color: #64c8ff;
            text-align: center;
            min-width: 60px;
        }

        .shortcut-desc {
            color: #aaa;
            display: flex;
            align-items: center;
        }

        .shortcuts-close {
            display: block;
            margin: 20px auto 0;
            padding: 10px 30px;
            background: linear-gradient(135deg, #64c8ff, #a080ff);
            border: none;
            border-radius: 6px;
            color: #0a0a0f;
            font-weight: bold;
            cursor: pointer;
        }

        .shortcuts-hint {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(100, 200, 255, 0.1);
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 20px;
            padding: 8px 16px;
            font-size: 0.8em;
            color: #64c8ff;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
        }

        .shortcuts-hint.visible {
            animation: fadeInOut 4s ease-in-out;
        }

        @keyframes fadeInOut {
            0%, 100% { opacity: 0; }
            10%, 90% { opacity: 1; }
        }

        /* Fullscreen mode */
        .simulation-viewport.fullscreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw !important;
            height: 100vh !important;
            z-index: 9999;
        }

        .simulation-viewport.fullscreen ~ .sidebar {
            display: none;
        }

        /* Neural network visualization */
        .neural-panel {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
            min-height: 180px;
        }

        .neural-panel h3 {
            color: #888;
            font-size: 0.85em;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #neuralCanvas {
            width: 100%;
            height: 150px;
            border-radius: 4px;
            background: rgba(0, 0, 0, 0.3);
        }

        .stat-value.neural { color: #a080ff; }

        /* ===== REPLAY SYSTEM STYLES ===== */
        .replay-panel {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
        }

        .replay-panel h3 {
            color: #888;
            font-size: 0.85em;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .replay-timeline {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(15, 15, 25, 0.98);
            border-top: 1px solid rgba(100, 200, 255, 0.3);
            padding: 15px 20px 20px;
            z-index: 2000;
            opacity: 0;
            transform: translateY(100%);
            transition: all 0.3s ease;
        }

        .replay-timeline.active {
            opacity: 1;
            transform: translateY(0);
        }

        .timeline-scrubber {
            position: relative;
            height: 40px;
            background: rgba(30, 30, 50, 0.8);
            border-radius: 6px;
            margin-bottom: 15px;
            cursor: pointer;
            overflow: hidden;
        }

        .timeline-progress {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            background: linear-gradient(90deg, #64c8ff, #a080ff);
            pointer-events: none;
            transition: width 0.05s linear;
        }

        .timeline-events {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .timeline-event {
            position: absolute;
            top: 0;
            width: 3px;
            height: 100%;
            background: rgba(255, 100, 100, 0.6);
        }

        .timeline-event.click {
            background: rgba(255, 200, 100, 0.8);
            width: 4px;
        }

        .timeline-playhead {
            position: absolute;
            top: -5px;
            width: 3px;
            height: calc(100% + 10px);
            background: #fff;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
            pointer-events: none;
        }

        .timeline-playhead::before {
            content: '';
            position: absolute;
            top: -8px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-top: 8px solid #fff;
        }

        .replay-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .replay-button {
            padding: 8px 16px;
            background: rgba(100, 200, 255, 0.1);
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 6px;
            color: #64c8ff;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.85em;
            transition: all 0.2s;
        }

        .replay-button:hover:not(:disabled) {
            background: rgba(100, 200, 255, 0.2);
        }

        .replay-button.active {
            background: linear-gradient(135deg, #64c8ff, #a080ff);
            color: #0a0a0f;
        }

        .replay-button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .speed-button {
            padding: 6px 12px;
            background: rgba(100, 200, 255, 0.1);
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 4px;
            color: #64c8ff;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.75em;
        }

        .speed-button.active {
            background: rgba(100, 200, 255, 0.3);
            color: #fff;
        }

        .time-display {
            color: #888;
            font-size: 0.85em;
            font-family: 'Courier New', monospace;
            margin-left: auto;
        }

        .replay-ghost-cursor {
            position: absolute;
            width: 24px;
            height: 24px;
            pointer-events: none;
            z-index: 1500;
            opacity: 0;
        }

        .replay-ghost-cursor.active {
            opacity: 1;
        }

        .replay-ghost-cursor::before {
            content: '';
            position: absolute;
            width: 0;
            height: 0;
            border-left: 10px solid #ff6464;
            border-top: 6px solid transparent;
            border-bottom: 6px solid transparent;
            transform: rotate(-45deg);
            filter: drop-shadow(0 0 6px rgba(255, 100, 100, 0.8));
        }

        .replay-ghost-cursor::after {
            content: 'REPLAY';
            position: absolute;
            top: -20px;
            left: 15px;
            font-size: 8px;
            color: #ff6464;
            font-weight: bold;
        }

        .comparison-cursor {
            position: absolute;
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 1001;
            opacity: 0;
        }

        .comparison-cursor.active {
            opacity: 0.7;
        }

        .comparison-cursor::before {
            content: '';
            position: absolute;
            width: 0;
            height: 0;
            border-left: 8px solid #64ff96;
            border-top: 5px solid transparent;
            border-bottom: 5px solid transparent;
            transform: rotate(-45deg);
            filter: drop-shadow(0 0 4px rgba(100, 255, 150, 0.6));
        }

        .comparison-cursor::after {
            content: 'LIVE';
            position: absolute;
            top: -18px;
            left: 12px;
            font-size: 8px;
            color: #64ff96;
            font-weight: bold;
        }

        .replay-mode-badge {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 100, 100, 0.2);
            border: 1px solid rgba(255, 100, 100, 0.5);
            padding: 8px 20px;
            border-radius: 20px;
            color: #ff6464;
            font-size: 0.85em;
            font-weight: bold;
            z-index: 1500;
            opacity: 0;
            text-transform: uppercase;
        }

        .replay-mode-badge.active {
            opacity: 1;
        }

        .replay-list {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
        }

        .replay-item {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            margin-bottom: 8px;
            border-radius: 6px;
            border-left: 3px solid #64c8ff;
            cursor: pointer;
            transition: all 0.2s;
        }

        .replay-item:hover {
            background: rgba(100, 200, 255, 0.1);
            transform: translateX(5px);
        }

        .replay-item.active {
            border-left-color: #a080ff;
            background: rgba(160, 128, 255, 0.15);
        }

        .replay-item-title {
            font-size: 0.85em;
            color: #e0e0e0;
            margin-bottom: 4px;
        }

        .replay-item-stats {
            font-size: 0.7em;
            color: #888;
        }

        .tab-container {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .tab-button {
            flex: 1;
            padding: 10px;
            background: rgba(30, 30, 50, 0.5);
            border: 1px solid rgba(100, 200, 255, 0.2);
            border-radius: 6px;
            color: #888;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.85em;
            transition: all 0.2s;
        }

        .tab-button.active {
            background: rgba(100, 200, 255, 0.2);
            border-color: rgba(100, 200, 255, 0.5);
            color: #64c8ff;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* ===== MULTIPLAYER STYLES ===== */
        .multiplayer-panel {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
        }

        .multiplayer-panel h3 {
            color: #888;
            font-size: 0.85em;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .room-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .room-controls input {
            flex: 1;
            padding: 8px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 4px;
            color: #e0e0e0;
            font-family: inherit;
            font-size: 0.85em;
        }

        .room-controls input::placeholder {
            color: #666;
        }

        .room-controls button {
            padding: 8px 12px !important;
            font-size: 0.85em !important;
        }

        .room-code-display {
            background: rgba(100, 200, 255, 0.1);
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 4px;
            padding: 10px;
            text-align: center;
            font-family: 'Courier New', monospace;
            font-size: 1.1em;
            color: #64c8ff;
            letter-spacing: 2px;
            margin-bottom: 10px;
            cursor: pointer;
        }

        .room-code-display:hover {
            background: rgba(100, 200, 255, 0.15);
        }

        .connection-status {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            font-size: 0.8em;
            margin-bottom: 10px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #666;
        }

        .status-dot.connected {
            background: #64ff96;
            animation: pulse 2s infinite;
        }

        .status-dot.connecting {
            background: #ffff64;
            animation: pulse 1s infinite;
        }

        .peer-cursor {
            position: absolute;
            pointer-events: none;
            z-index: 500;
            transition: all 0.05s linear;
            will-change: transform;
        }

        .peer-cursor::before {
            content: '';
            position: absolute;
            width: 0;
            height: 0;
            border-left: 10px solid #ff6496;
            border-top: 6px solid transparent;
            border-bottom: 6px solid transparent;
            transform: rotate(-45deg);
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.5));
        }

        .peer-cursor::after {
            content: attr(data-peer-name);
            position: absolute;
            top: 16px;
            left: 12px;
            background: rgba(255, 100, 150, 0.9);
            color: white;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.7em;
            white-space: nowrap;
            pointer-events: none;
        }

        .peer-layers-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 30;
        }

        .peer-recursion-layer {
            position: absolute;
            border: 2px solid rgba(255, 100, 150, 0.3);
            border-radius: 8px;
            background: rgba(30, 10, 20, 0.7);
            box-shadow:
                0 0 20px rgba(255, 100, 150, 0.1),
                inset 0 0 40px rgba(255, 100, 150, 0.05);
            transition: all 0.3s ease;
        }

        .peer-recursion-layer::before {
            content: attr(data-depth);
            position: absolute;
            top: 5px;
            right: 10px;
            font-size: 10px;
            color: rgba(255, 100, 150, 0.6);
            z-index: 10;
        }

        .peer-ghost-cursor {
            color: #ff6496;
        }

        .comparative-stats {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 10px;
            align-items: center;
            margin-bottom: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }

        .comparative-stats .my-stat {
            text-align: right;
            color: #64c8ff;
            font-size: 0.85em;
        }

        .comparative-stats .vs {
            color: #888;
            font-weight: bold;
            font-size: 0.7em;
        }

        .comparative-stats .peer-stat {
            text-align: left;
            color: #ff6496;
            font-size: 0.85em;
        }

        .predict-mode-panel {
            background: rgba(160, 128, 255, 0.1);
            border: 1px solid rgba(160, 128, 255, 0.3);
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 10px;
            transition: all 0.2s;
            text-align: center;
        }

        .predict-mode-panel.active {
            background: rgba(160, 128, 255, 0.2);
            border-color: rgba(160, 128, 255, 0.5);
        }

        .predict-score {
            font-size: 1.3em;
            color: #a080ff;
            margin-top: 5px;
            font-weight: bold;
        }

        .fingerprint-comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }

        .fingerprint-mini {
            text-align: center;
        }

        .fingerprint-mini canvas {
            width: 100%;
            height: 80px;
            border-radius: 4px;
            background: rgba(0, 0, 0, 0.3);
        }

        .fingerprint-mini .label {
            font-size: 0.7em;
            color: #888;
            margin-top: 5px;
        }

        .meta-comment.dual {
            background: rgba(160, 128, 255, 0.15);
            border-color: rgba(160, 128, 255, 0.4);
            color: #a080ff;
        }

        /* 3D Mode Styles */
        .mode-3d-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 5;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
            background: radial-gradient(circle at center, rgba(10, 10, 15, 0.95), rgba(5, 5, 10, 1));
        }

        .mode-3d-canvas.active {
            opacity: 1;
            pointer-events: auto;
        }

        .mode-3d-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 15px;
            background: rgba(100, 200, 255, 0.1);
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 10px 0;
        }

        .mode-3d-toggle:hover {
            background: rgba(100, 200, 255, 0.2);
            border-color: rgba(100, 200, 255, 0.5);
        }

        .mode-3d-toggle.active {
            background: rgba(100, 200, 255, 0.3);
            border-color: rgba(100, 200, 255, 0.7);
        }

        .mode-3d-toggle input[type="checkbox"] {
            margin: 0;
            cursor: pointer;
        }

        .mode-3d-toggle label {
            margin: 0;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            color: #64c8ff;
            font-size: 0.95em;
        }

        .mode-3d-icon {
            font-size: 1.2em;
        }

        .mode-3d-controls {
            display: none;
            padding: 10px;
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            margin-top: 10px;
        }

        .mode-3d-controls.active {
            display: block;
        }

        .mode-3d-controls .depth-slider {
            margin-bottom: 10px;
        }

        .mode-3d-info {
            position: absolute;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 12px 24px;
            border-radius: 24px;
            font-size: 0.85em;
            color: #64c8ff;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            z-index: 10;
            text-align: center;
        }

        .mode-3d-info.active {
            opacity: 1;
        }

        /* Memory Palace Styles */
        .memory-palace-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 6;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
            background: radial-gradient(circle at center, rgba(15, 10, 25, 0.98), rgba(5, 5, 15, 1));
        }

        .memory-palace-canvas.active {
            opacity: 1;
            pointer-events: auto;
        }

        .memory-palace-info {
            position: absolute;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 12px 24px;
            border-radius: 24px;
            font-size: 0.85em;
            color: #b896ff;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            z-index: 15;
            text-align: center;
            border: 1px solid rgba(184, 150, 255, 0.3);
        }

        .memory-palace-info.active {
            opacity: 1;
        }

        .memory-palace-map {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.85);
            border: 2px solid rgba(184, 150, 255, 0.4);
            border-radius: 12px;
            padding: 15px;
            min-width: 200px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            z-index: 15;
        }

        .memory-palace-map.active {
            opacity: 1;
            pointer-events: auto;
        }

        .map-title {
            color: #b896ff;
            font-size: 0.9em;
            font-weight: bold;
            margin-bottom: 10px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .map-grid {
            display: grid;
            grid-template-columns: repeat(3, 40px);
            grid-gap: 8px;
            margin-bottom: 10px;
            justify-content: center;
        }

        .map-room {
            width: 40px;
            height: 40px;
            border: 1px solid rgba(184, 150, 255, 0.3);
            border-radius: 4px;
            background: rgba(20, 15, 30, 0.5);
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7em;
            color: rgba(184, 150, 255, 0.5);
        }

        .map-room:hover {
            background: rgba(184, 150, 255, 0.2);
            border-color: rgba(184, 150, 255, 0.6);
        }

        .map-room.current {
            background: rgba(184, 150, 255, 0.4);
            border: 2px solid #b896ff;
            box-shadow: 0 0 15px rgba(184, 150, 255, 0.6);
        }

        .map-room.visited {
            background: rgba(100, 200, 255, 0.2);
            border-color: rgba(100, 200, 255, 0.4);
        }

        .map-legend {
            display: flex;
            gap: 15px;
            font-size: 0.75em;
            color: #888;
            justify-content: center;
        }

        .map-legend span {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .current-room {
            color: #b896ff;
        }

        .visited-room {
            color: #64c8ff;
        }

        .memory-palace-center-mirror {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
            z-index: 14;
        }

        .memory-palace-center-mirror.active {
            opacity: 1;
            pointer-events: auto;
        }

        .mirror-frame {
            width: 300px;
            height: 400px;
            background: linear-gradient(135deg, rgba(184, 150, 255, 0.1), rgba(100, 200, 255, 0.1));
            border: 3px solid rgba(184, 150, 255, 0.6);
            border-radius: 20px;
            box-shadow: 0 0 30px rgba(184, 150, 255, 0.3), inset 0 0 50px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            backdrop-filter: blur(10px);
        }

        .mirror-text {
            color: #b896ff;
            font-size: 0.9em;
            text-align: center;
            margin-bottom: 20px;
            font-style: italic;
            text-shadow: 0 0 10px rgba(184, 150, 255, 0.5);
        }

        .mirror-reflection {
            width: 100%;
            height: 100%;
            border-radius: 10px;
            background: radial-gradient(circle at center, rgba(184, 150, 255, 0.2), transparent);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3em;
            color: rgba(184, 150, 255, 0.6);
            animation: mirror-pulse 3s ease-in-out infinite;
        }

        @keyframes mirror-pulse {
            0%, 100% {
                box-shadow: inset 0 0 30px rgba(184, 150, 255, 0.3);
                transform: scale(1);
            }
            50% {
                box-shadow: inset 0 0 50px rgba(184, 150, 255, 0.5);
                transform: scale(1.02);
            }
        }

        .memory-artifact {
            position: absolute;
            width: 50px;
            height: 50px;
            background: radial-gradient(circle, rgba(255, 200, 100, 0.4), rgba(255, 150, 100, 0.2));
            border: 2px solid rgba(255, 200, 100, 0.6);
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            z-index: 12;
            animation: artifact-float 3s ease-in-out infinite;
        }

        .memory-artifact:hover {
            transform: scale(1.2);
            box-shadow: 0 0 30px rgba(255, 200, 100, 0.8);
        }

        @keyframes artifact-float {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            50% { transform: translateY(-10px) rotate(5deg); }
        }

        .artifact-tooltip {
            position: absolute;
            bottom: -40px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            color: #ffbf64;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 0.75em;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
            border: 1px solid rgba(255, 200, 100, 0.4);
        }

        .memory-artifact:hover .artifact-tooltip {
            opacity: 1;
        }

        .room-atmosphere {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 11;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .room-atmosphere.active {
            opacity: 1;
        }

        .echo-path {
            position: absolute;
            width: 3px;
            height: 3px;
            border-radius: 50%;
            background: rgba(184, 150, 255, 0.4);
            pointer-events: none;
            z-index: 11;
            box-shadow: 0 0 10px rgba(184, 150, 255, 0.6);
        }

        /* Evolution Timeline */
        .evolution-panel {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
            margin-top: 10px;
        }

        .evolution-panel h3 {
            color: #888;
            font-size: 0.85em;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .welcome-message {
            background: linear-gradient(135deg, rgba(100, 200, 255, 0.2), rgba(160, 128, 255, 0.2));
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            animation: fadeIn 1s ease-out;
        }

        .welcome-message .title {
            font-size: 1.1em;
            color: #64c8ff;
            margin-bottom: 8px;
            font-weight: bold;
        }

        .welcome-message .subtitle {
            font-size: 0.85em;
            color: #aaa;
            line-height: 1.4;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .evolution-timeline {
            position: relative;
            height: 60px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            margin: 10px 0;
            overflow: hidden;
        }

        .timeline-session {
            position: absolute;
            top: 0;
            height: 100%;
            background: linear-gradient(135deg, rgba(100, 200, 255, 0.4), rgba(160, 128, 255, 0.4));
            border-right: 1px solid rgba(255, 255, 255, 0.2);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .timeline-session:hover {
            background: linear-gradient(135deg, rgba(100, 200, 255, 0.6), rgba(160, 128, 255, 0.6));
            z-index: 10;
        }

        .timeline-session.selected {
            background: linear-gradient(135deg, rgba(255, 200, 100, 0.6), rgba(255, 150, 100, 0.6));
            border: 2px solid #ffbf64;
        }

        .timeline-label {
            font-size: 0.65em;
            color: white;
            padding: 2px 4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .consistency-meter {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
        }

        .consistency-bar {
            flex: 1;
            height: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }

        .consistency-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff6464, #ffff64, #64ff96);
            transition: width 0.5s ease;
            border-radius: 10px;
        }

        .consistency-label {
            font-size: 0.75em;
            color: #888;
            min-width: 80px;
        }

        .entropy-graph {
            height: 80px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            position: relative;
            margin: 10px 0;
        }

        .entropy-line {
            stroke: #64c8ff;
            stroke-width: 2;
            fill: none;
        }

        .entropy-area {
            fill: rgba(100, 200, 255, 0.2);
        }

        .ghost-overlay-cursor {
            position: absolute;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: rgba(255, 200, 100, 0.4);
            border: 2px solid rgba(255, 200, 100, 0.8);
            pointer-events: none;
            z-index: 90;
            transition: all 0.05s linear;
        }

        .ghost-overlay-cursor::after {
            content: 'PAST YOU';
            position: absolute;
            top: -25px;
            left: -15px;
            font-size: 0.6em;
            color: rgba(255, 200, 100, 0.9);
            white-space: nowrap;
            text-shadow: 0 0 4px rgba(0, 0, 0, 0.8);
        }

        .comparison-split {
            display: flex;
            gap: 10px;
            margin: 10px 0;
        }

        .comparison-pane {
            flex: 1;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            padding: 10px;
        }

        .comparison-pane .label {
            font-size: 0.7em;
            color: #888;
            margin-bottom: 5px;
            text-transform: uppercase;
        }

        .comparison-pane .fingerprint-mini {
            width: 100%;
            height: 80px;
            border-radius: 4px;
            background: rgba(0, 0, 0, 0.5);
        }

        .prediction-viz {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            padding: 10px;
            margin: 10px 0;
        }

        .prediction-viz .label {
            font-size: 0.75em;
            color: #888;
            margin-bottom: 8px;
        }

        .prediction-arrow {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 5px 0;
        }

        .prediction-metric {
            flex: 1;
            display: flex;
            justify-content: space-between;
            font-size: 0.75em;
            padding: 5px 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }

        .metric-trend {
            color: #888;
        }

        .metric-trend.increasing {
            color: #ff6464;
        }

        .metric-trend.decreasing {
            color: #64ff96;
        }

        .evolution-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 10px;
        }

        .evolution-controls button {
            flex: 1;
            min-width: 100px;
            padding: 8px;
            font-size: 0.75em;
        }

        .session-comparison-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10, 10, 20, 0.95);
            border: 2px solid rgba(100, 200, 255, 0.5);
            border-radius: 12px;
            padding: 20px;
            max-width: 80%;
            max-height: 80%;
            overflow: auto;
            z-index: 10000;
            display: none;
        }

        .session-comparison-overlay.active {
            display: block;
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
            to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }

        .session-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .session-card {
            background: rgba(30, 30, 50, 0.7);
            border-radius: 8px;
            padding: 12px;
            border: 1px solid rgba(100, 200, 255, 0.2);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .session-card:hover {
            border-color: rgba(100, 200, 255, 0.6);
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(100, 200, 255, 0.3);
        }

        .session-card .date {
            font-size: 0.75em;
            color: #64c8ff;
            margin-bottom: 5px;
        }

        .session-card .stats {
            font-size: 0.7em;
            color: #aaa;
            line-height: 1.4;
        }

        /* Biometric Tracking Styles */
        .biometric-panel {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }

        .heart-container {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            position: relative;
        }

        .beating-heart {
            font-size: 48px;
            color: #ff6b6b;
            filter: drop-shadow(0 0 10px rgba(255, 107, 107, 0.5));
            animation: heartbeat 1s ease-in-out infinite;
            transition: animation-duration 0.3s ease;
        }

        @keyframes heartbeat {
            0%, 100% { transform: scale(1); }
            25% { transform: scale(1.15); }
            50% { transform: scale(1); }
        }

        .heart-rate-display {
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            text-align: right;
        }

        .heart-rate-value {
            font-size: 32px;
            font-weight: bold;
            color: #ff6b6b;
            line-height: 1;
        }

        .heart-rate-label {
            font-size: 12px;
            color: #888;
            margin-top: 4px;
        }

        .heart-rate-graph {
            width: 100%;
            height: 60px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            margin-top: 10px;
            position: relative;
            overflow: hidden;
        }

        .heart-rate-graph canvas {
            width: 100%;
            height: 100%;
        }

        .stress-indicator {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-top: 15px;
            padding: 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            border-left: 4px solid #64c8ff;
            transition: border-color 0.3s ease;
        }

        .stress-indicator.low {
            border-color: #64ff96;
        }

        .stress-indicator.medium {
            border-color: #ffbf64;
        }

        .stress-indicator.high {
            border-color: #ff6464;
        }

        .stress-label {
            font-size: 0.9em;
            color: #888;
        }

        .stress-value {
            font-size: 1.1em;
            font-weight: bold;
            color: #64c8ff;
        }

        .stress-indicator.low .stress-value {
            color: #64ff96;
        }

        .stress-indicator.medium .stress-value {
            color: #ffbf64;
        }

        .stress-indicator.high .stress-value {
            color: #ff6464;
        }

        .breathing-guide {
            margin-top: 15px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            text-align: center;
        }

        .breathing-circle {
            width: 80px;
            height: 80px;
            margin: 15px auto;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(100, 200, 255, 0.3), rgba(100, 200, 255, 0.1));
            border: 2px solid rgba(100, 200, 255, 0.5);
            animation: breathe 6s ease-in-out infinite;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #64c8ff;
            font-size: 0.8em;
            box-shadow: 0 0 20px rgba(100, 200, 255, 0.3);
        }

        @keyframes breathe {
            0%, 100% {
                transform: scale(0.8);
                opacity: 0.6;
            }
            50% {
                transform: scale(1.2);
                opacity: 1;
            }
        }

        .breathing-instruction {
            font-size: 0.85em;
            color: #888;
            font-style: italic;
        }

        .biometric-commentary {
            margin-top: 10px;
            padding: 12px;
            background: rgba(160, 128, 255, 0.1);
            border: 1px solid rgba(160, 128, 255, 0.3);
            border-radius: 6px;
            font-size: 0.85em;
            color: #a080ff;
            font-style: italic;
            line-height: 1.5;
        }

        .biometric-event {
            padding: 8px;
            margin: 5px 0;
            background: rgba(255, 107, 107, 0.1);
            border-left: 3px solid #ff6b6b;
            border-radius: 4px;
            font-size: 0.8em;
            color: #ffbf64;
        }

        .biometric-event .timestamp {
            color: #888;
            font-size: 0.9em;
        }

        /* ===== QUANTUM UNCERTAINTY STYLES ===== */

        /* Probability cloud for uncertain predictions */
        .probability-cloud {
            position: absolute;
            pointer-events: none;
            z-index: 90;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(160, 128, 255, 0.4), rgba(160, 128, 255, 0.1) 50%, transparent 70%);
            filter: blur(15px);
            animation: cloudPulse 2s ease-in-out infinite;
            will-change: transform, opacity;
        }

        @keyframes cloudPulse {
            0%, 100% { transform: scale(1); opacity: 0.6; }
            50% { transform: scale(1.2); opacity: 0.4; }
        }

        /* Branching futures visualization */
        .quantum-branch {
            position: absolute;
            pointer-events: none;
            z-index: 85;
        }

        .quantum-branch path {
            fill: none;
            stroke: rgba(160, 128, 255, 0.5);
            stroke-width: 2;
            stroke-dasharray: 3, 3;
            animation: branchFlicker 1.5s ease-in-out infinite;
        }

        @keyframes branchFlicker {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 0.3; }
        }

        /* Superposition particles */
        .superposition-particle {
            position: absolute;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: rgba(160, 128, 255, 0.8);
            pointer-events: none;
            z-index: 95;
            box-shadow: 0 0 10px rgba(160, 128, 255, 0.6);
            animation: particleFloat 3s ease-in-out infinite;
        }

        @keyframes particleFloat {
            0%, 100% { transform: translate(0, 0); }
            25% { transform: translate(-5px, -5px); }
            50% { transform: translate(5px, -3px); }
            75% { transform: translate(-3px, 5px); }
        }

        /* Collapsed state (single point) */
        .collapsed-state {
            animation: collapseEffect 0.3s ease-out forwards;
        }

        @keyframes collapseEffect {
            0% {
                filter: blur(15px);
                transform: scale(2);
                opacity: 0.6;
            }
            100% {
                filter: blur(0);
                transform: scale(1);
                opacity: 1;
            }
        }

        /* Observation ripple effect */
        .observation-ripple {
            position: absolute;
            border: 2px solid rgba(100, 200, 255, 0.6);
            border-radius: 50%;
            pointer-events: none;
            z-index: 150;
            animation: rippleExpand 1s ease-out forwards;
        }

        @keyframes rippleExpand {
            0% {
                width: 0;
                height: 0;
                opacity: 1;
            }
            100% {
                width: 100px;
                height: 100px;
                opacity: 0;
            }
        }

        /* Uncertainty principle meter */
        .uncertainty-meter {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.85);
            padding: 15px 25px;
            border-radius: 20px;
            border: 2px solid rgba(160, 128, 255, 0.4);
            font-size: 0.85em;
            color: #a080ff;
            z-index: 500;
            min-width: 300px;
        }

        .uncertainty-meter .title {
            text-align: center;
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 0.9em;
            color: #64c8ff;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .uncertainty-bars {
            display: flex;
            gap: 15px;
            margin-bottom: 8px;
        }

        .uncertainty-bar {
            flex: 1;
        }

        .uncertainty-bar .label {
            font-size: 0.7em;
            color: #888;
            margin-bottom: 4px;
        }

        .uncertainty-bar-fill {
            height: 8px;
            background: rgba(30, 30, 50, 0.8);
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        .uncertainty-bar-value {
            height: 100%;
            background: linear-gradient(90deg, #a080ff, #64c8ff);
            transition: width 0.3s ease;
            border-radius: 4px;
        }

        .uncertainty-formula {
            text-align: center;
            font-size: 0.75em;
            color: #666;
            font-style: italic;
            margin-top: 8px;
            font-family: 'Georgia', serif;
        }

        /* Quantum entanglement effect */
        .entanglement-line {
            position: absolute;
            pointer-events: none;
            z-index: 80;
        }

        .entanglement-line path {
            fill: none;
            stroke: rgba(255, 100, 255, 0.6);
            stroke-width: 1.5;
            stroke-dasharray: 5, 5;
            animation: entanglementPulse 2s ease-in-out infinite;
            filter: drop-shadow(0 0 3px rgba(255, 100, 255, 0.8));
        }

        @keyframes entanglementPulse {
            0%, 100% { opacity: 0.6; stroke-dashoffset: 0; }
            50% { opacity: 1; stroke-dashoffset: -10; }
        }

        /* Quantized prediction states */
        .quantized-cursor {
            transition: none !important;
            will-change: auto !important;
        }

        .quantized-cursor.jumping {
            animation: quantumJump 0.2s ease-in-out;
        }

        @keyframes quantumJump {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.5); filter: brightness(1.5); }
        }

        /* Quantum metadata overlay */
        .quantum-meta {
            position: absolute;
            bottom: 140px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border-radius: 15px;
            font-size: 0.75em;
            color: #a080ff;
            font-style: italic;
            border: 1px solid rgba(160, 128, 255, 0.3);
            max-width: 400px;
            text-align: center;
            z-index: 450;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .quantum-meta.active {
            opacity: 1;
        }

        /* Superposition indicator */
        .recursion-layer.superposition {
            border-color: rgba(160, 128, 255, 0.6);
            box-shadow:
                0 0 30px rgba(160, 128, 255, 0.3),
                inset 0 0 40px rgba(160, 128, 255, 0.1);
            animation: superpositionShimmer 2s ease-in-out infinite;
        }

        @keyframes superpositionShimmer {
            0%, 100% { filter: hue-rotate(0deg); }
            50% { filter: hue-rotate(30deg); }
        }

        /* Wavefunction visualization */
        .wavefunction {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 75;
            opacity: 0.3;
        }

        .wavefunction svg {
            width: 100%;
            height: 100%;
        }

        .wavefunction path {
            fill: none;
            stroke: rgba(160, 128, 255, 0.5);
            stroke-width: 1;
            animation: wavePulse 3s ease-in-out infinite;
        }

        @keyframes wavePulse {
            0%, 100% { stroke-opacity: 0.5; }
            50% { stroke-opacity: 0.2; }
        }

        /* ===== PARADOX ENGINE STYLES ===== */
        .paradox-meter-container {
            position: fixed;
            top: 120px;
            right: 20px;
            width: 200px;
            background: rgba(20, 20, 40, 0.95);
            border: 2px solid rgba(200, 100, 255, 0.5);
            border-radius: 12px;
            padding: 15px;
            z-index: 900;
            box-shadow: 0 0 30px rgba(200, 100, 255, 0.3);
            transition: all 0.3s ease;
        }

        .paradox-meter-container.critical {
            border-color: rgba(255, 50, 150, 0.8);
            box-shadow: 0 0 50px rgba(255, 50, 150, 0.6);
            animation: paradoxPulse 1s ease-in-out infinite;
        }

        @keyframes paradoxPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .paradox-meter-title {
            color: #c864ff;
            font-size: 0.9em;
            margin-bottom: 10px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .paradox-meter-bar {
            position: relative;
            height: 20px;
            background: rgba(30, 30, 50, 0.8);
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid rgba(200, 100, 255, 0.3);
            margin-bottom: 10px;
        }

        .paradox-meter-fill {
            height: 100%;
            background: linear-gradient(90deg, #c864ff, #ff3296, #ff6432);
            transition: width 0.5s ease;
            position: relative;
            box-shadow: 0 0 20px rgba(255, 50, 150, 0.5);
        }

        .paradox-meter-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            animation: shimmer 2s linear infinite;
        }

        .paradox-count {
            color: #e0e0e0;
            font-size: 0.85em;
            text-align: center;
        }

        .paradox-collection-btn {
            margin-top: 10px;
            width: 100%;
            background: linear-gradient(135deg, rgba(200, 100, 255, 0.3), rgba(255, 50, 150, 0.3));
            border: 1px solid rgba(200, 100, 255, 0.5);
            border-radius: 6px;
            color: #e0e0e0;
            padding: 8px;
            font-size: 0.85em;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .paradox-collection-btn:hover {
            background: linear-gradient(135deg, rgba(200, 100, 255, 0.5), rgba(255, 50, 150, 0.5));
            box-shadow: 0 0 15px rgba(200, 100, 255, 0.4);
        }

        /* Reality Break Effect */
        .reality-break-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9999;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .reality-break-overlay.active {
            opacity: 1;
            animation: realityGlitch 0.5s ease-in-out;
        }

        @keyframes realityGlitch {
            0%, 100% { filter: invert(0); }
            20%, 60% { filter: invert(1); }
            40%, 80% { filter: invert(0) hue-rotate(180deg); }
        }

        /* Impossible Geometry */
        .impossible-geometry {
            position: absolute;
            pointer-events: none;
            z-index: 500;
            opacity: 0;
            transition: opacity 1s ease;
        }

        .impossible-geometry.visible {
            opacity: 0.6;
            animation: geometryRotate 10s linear infinite;
        }

        @keyframes geometryRotate {
            0% { transform: rotate(0deg) scale(1); }
            50% { transform: rotate(180deg) scale(1.2); }
            100% { transform: rotate(360deg) scale(1); }
        }

        .penrose-triangle {
            width: 150px;
            height: 150px;
            border: 3px solid rgba(255, 100, 200, 0.8);
            clip-path: polygon(
                50% 0%, 100% 100%, 0% 100%
            );
            background: linear-gradient(135deg,
                transparent 0%,
                rgba(255, 100, 200, 0.2) 50%,
                transparent 100%
            );
            filter: drop-shadow(0 0 20px rgba(255, 100, 200, 0.6));
        }

        /* Paradox Collection Modal */
        .paradox-collection-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 20, 40, 0.98);
            border: 3px solid rgba(200, 100, 255, 0.8);
            border-radius: 16px;
            padding: 30px;
            max-width: 700px;
            max-height: 80vh;
            overflow-y: auto;
            z-index: 10002;
            box-shadow: 0 10px 60px rgba(0, 0, 0, 0.9), 0 0 150px rgba(200, 100, 255, 0.4);
            display: none;
        }

        .paradox-collection-modal.active {
            display: block;
            animation: fadeInScale 0.5s ease;
        }

        .paradox-collection-modal h2 {
            color: #c864ff;
            font-size: 2em;
            margin-bottom: 10px;
            text-align: center;
            text-shadow: 0 0 15px rgba(200, 100, 255, 0.6);
        }

        .paradox-collection-modal .subtitle {
            color: #ff3296;
            font-size: 0.9em;
            text-align: center;
            margin-bottom: 25px;
            font-style: italic;
        }

        .paradox-item {
            background: rgba(30, 30, 50, 0.5);
            border-left: 4px solid rgba(200, 100, 255, 0.6);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            transition: all 0.3s ease;
        }

        .paradox-item:hover {
            background: rgba(40, 40, 60, 0.7);
            border-left-color: rgba(255, 50, 150, 0.8);
            box-shadow: 0 0 20px rgba(200, 100, 255, 0.3);
        }

        .paradox-item h3 {
            color: #c864ff;
            font-size: 1.3em;
            margin-bottom: 10px;
        }

        .paradox-item .paradox-type {
            display: inline-block;
            background: rgba(200, 100, 255, 0.3);
            color: #ff96d2;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.75em;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .paradox-item .paradox-description {
            color: #e0e0e0;
            line-height: 1.6;
            margin-bottom: 10px;
        }

        .paradox-item .paradox-timestamp {
            color: #888;
            font-size: 0.85em;
            font-style: italic;
        }

        .paradox-close-btn {
            display: block;
            margin: 20px auto 0;
            background: linear-gradient(135deg, rgba(200, 100, 255, 0.7), rgba(150, 50, 180, 0.7));
            border: 2px solid rgba(200, 100, 255, 0.6);
            border-radius: 8px;
            color: #e0e0e0;
            padding: 12px 40px;
            font-size: 1.1em;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .paradox-close-btn:hover {
            background: linear-gradient(135deg, rgba(220, 120, 255, 0.9), rgba(170, 70, 200, 0.9));
            box-shadow: 0 0 25px rgba(200, 100, 255, 0.5);
            transform: scale(1.05);
        }

        /* Paradox Alert */
        .paradox-alert {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: rgba(20, 20, 40, 0.98);
            border: 3px solid rgba(255, 50, 150, 0.8);
            border-radius: 16px;
            padding: 40px;
            max-width: 500px;
            z-index: 10003;
            text-align: center;
            box-shadow: 0 0 100px rgba(255, 50, 150, 0.8);
            opacity: 0;
            transition: all 0.5s ease;
        }

        .paradox-alert.active {
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
            animation: paradoxAlertPulse 2s ease-in-out infinite;
        }

        @keyframes paradoxAlertPulse {
            0%, 100% { box-shadow: 0 0 100px rgba(255, 50, 150, 0.8); }
            50% { box-shadow: 0 0 150px rgba(255, 50, 150, 1); }
        }

        .paradox-alert h2 {
            color: #ff3296;
            font-size: 2.5em;
            margin-bottom: 20px;
            text-shadow: 0 0 20px rgba(255, 50, 150, 0.8);
        }

        .paradox-alert p {
            color: #e0e0e0;
            font-size: 1.2em;
            line-height: 1.6;
        }

        /* ===== KARMA AND FATE SYSTEM ===== */
        .karma-fate-panel {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }

        .karma-score-display {
            text-align: center;
            margin-bottom: 15px;
        }

        .karma-score-value {
            font-size: 3em;
            font-weight: bold;
            background: linear-gradient(135deg, #ffd700, #ff8c00);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        .karma-score-value.negative {
            background: linear-gradient(135deg, #ff4444, #8b0000);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .karma-score-value.positive {
            background: linear-gradient(135deg, #44ff44, #00ff88);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .karma-threshold-label {
            font-size: 0.9em;
            color: #aaa;
            margin-top: 5px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .karma-threshold-label.enlightened {
            color: #00ff88;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        .karma-threshold-label.corrupted {
            color: #ff4444;
            text-shadow: 0 0 10px rgba(255, 68, 68, 0.5);
        }

        .karma-bar-container {
            margin: 20px 0;
        }

        .karma-bar-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.7em;
            margin-bottom: 5px;
        }

        .karma-label {
            color: #888;
        }

        .karma-label.corrupted {
            color: #ff4444;
        }

        .karma-label.enlightened {
            color: #00ff88;
        }

        .karma-bar {
            position: relative;
            width: 100%;
            height: 20px;
            background: linear-gradient(90deg,
                #8b0000 0%,
                #ff4444 25%,
                #ffd700 50%,
                #44ff44 75%,
                #00ff88 100%);
            border-radius: 10px;
            overflow: visible;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .karma-fill {
            position: absolute;
            top: -4px;
            height: 28px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 14px;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.8);
            transition: left 0.5s ease, width 0.5s ease;
            border: 2px solid #fff;
        }

        .karma-marker {
            position: absolute;
            top: -2px;
            width: 2px;
            height: 24px;
            background: rgba(255, 255, 255, 0.5);
            pointer-events: all;
        }

        .karma-debt-display {
            background: rgba(139, 0, 0, 0.3);
            border: 1px solid rgba(255, 68, 68, 0.5);
            border-radius: 8px;
            padding: 12px;
            margin: 15px 0;
            text-align: center;
        }

        .karma-debt-label {
            font-size: 0.85em;
            color: #ff8888;
            margin-bottom: 5px;
        }

        .karma-debt-value {
            font-size: 1.5em;
            color: #ff4444;
            font-weight: bold;
        }

        .karma-effects-list {
            margin: 15px 0;
        }

        .karma-effect-label {
            font-size: 0.85em;
            color: #888;
            margin-bottom: 8px;
        }

        .karma-effects {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .karma-effect {
            padding: 6px 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            font-size: 0.8em;
            border-left: 3px solid #ffd700;
        }

        .karma-effect.positive {
            border-left-color: #00ff88;
            color: #aaffcc;
        }

        .karma-effect.negative {
            border-left-color: #ff4444;
            color: #ffaaaa;
        }

        .karma-effect.neutral {
            border-left-color: #ffd700;
            color: #ffe88a;
        }

        .fate-threads-container {
            margin: 20px 0;
        }

        .fate-threads-container h4 {
            color: #aaa;
            font-size: 0.9em;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .fate-threads-viz {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
        }

        #fateThreadsCanvas {
            display: block;
            width: 100%;
            height: 150px;
        }

        .fate-thread-legend {
            font-size: 0.75em;
            color: #888;
            line-height: 1.6;
        }

        .fate-path {
            margin-bottom: 5px;
            padding: 4px 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }

        .fate-path.likely {
            border-left: 3px solid #00ff88;
            color: #aaffcc;
        }

        .fate-path.unlikely {
            border-left: 3px solid #888;
            color: #aaa;
        }

        .fate-path.doomed {
            border-left: 3px solid #ff4444;
            color: #ffaaaa;
        }

        .karma-commentary {
            font-style: italic;
            color: #aaa;
            text-align: center;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            margin: 15px 0;
            font-size: 0.85em;
            line-height: 1.5;
            border: 1px solid rgba(255, 215, 0, 0.2);
        }

        .redemption-panel {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 215, 0, 0.5);
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }

        .redemption-panel h4 {
            color: #ffd700;
            font-size: 0.9em;
            margin-bottom: 10px;
            text-align: center;
        }

        .redemption-progress-bar {
            width: 100%;
            height: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 15px;
        }

        .redemption-fill {
            height: 100%;
            background: linear-gradient(90deg, #ffd700, #00ff88);
            border-radius: 10px;
            transition: width 0.5s ease;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        .redemption-actions {
            margin: 10px 0;
            font-size: 0.8em;
        }

        .redemption-action {
            padding: 8px;
            margin-bottom: 5px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .redemption-action.completed {
            opacity: 0.5;
            text-decoration: line-through;
        }

        .redemption-btn {
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, #ffd700, #00ff88);
            color: #0a0a0f;
            border: none;
            border-radius: 6px;
            font-family: inherit;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .redemption-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(255, 215, 0, 0.5);
        }

        .destiny-events {
            margin: 15px 0;
        }

        .destiny-event {
            background: rgba(138, 43, 226, 0.2);
            border: 2px solid rgba(138, 43, 226, 0.6);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            animation: destinyEventAppear 0.5s ease;
        }

        @keyframes destinyEventAppear {
            0% {
                opacity: 0;
                transform: scale(0.8) translateY(20px);
            }
            100% {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        .destiny-event-title {
            color: #a080ff;
            font-weight: bold;
            margin-bottom: 8px;
            font-size: 0.9em;
        }

        .destiny-event-description {
            color: #ddd;
            font-size: 0.8em;
            line-height: 1.5;
        }

        .destiny-event-effects {
            margin-top: 8px;
            font-size: 0.75em;
            color: #888;
        }

        .karma-stats {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

    </style>

        /* ===== TIME DILATION EFFECTS ===== */
        .time-perception-panel {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
        }

        .time-perception-panel h4 {
            color: #888;
            font-size: 0.85em;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .time-meter {
            position: relative;
            height: 12px;
            background: rgba(30, 30, 50, 0.8);
            border-radius: 6px;
            overflow: hidden;
            margin-bottom: 15px;
            border: 1px solid rgba(100, 200, 255, 0.2);
        }

        .time-meter-fill {
            height: 100%;
            background: linear-gradient(90deg, #64c8ff, #ffbf64, #ff6464);
            transition: width 0.5s ease, background 0.5s ease;
            position: relative;
        }

        .time-meter-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: shimmer 2s linear infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .time-dilation-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.75em;
            color: #888;
            margin-bottom: 8px;
        }

        .time-dilation-label .extreme {
            color: #ff6464;
            font-weight: bold;
            animation: pulse 1s infinite;
        }

        .time-clock-display {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .time-clock {
            flex: 1;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 6px;
            padding: 10px;
            text-align: center;
        }

        .time-clock-label {
            font-size: 0.7em;
            color: #888;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .time-clock-value {
            font-size: 1.2em;
            font-weight: bold;
            font-family: 'Courier New', monospace;
        }

        .time-clock.objective .time-clock-value {
            color: #64c8ff;
        }

        .time-clock.subjective .time-clock-value {
            color: #ffbf64;
        }

        .time-delta {
            font-size: 0.7em;
            color: #ff6464;
            margin-top: 3px;
        }

        .heartbeat-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 250;
            opacity: 0;
            background: radial-gradient(circle at center, rgba(255, 100, 100, 0.1), transparent 60%);
            will-change: opacity, transform;
        }

        .heartbeat-overlay.active {
            animation: heartbeat var(--heartbeat-duration, 1s) ease-in-out infinite;
        }

        @keyframes heartbeat {
            0%, 100% { opacity: 0; transform: scale(1); }
            10% { opacity: 0.3; transform: scale(1.01); }
            20% { opacity: 0; transform: scale(1); }
            30% { opacity: 0.4; transform: scale(1.015); }
            40% { opacity: 0; transform: scale(1); }
        }

        .time-crystal {
            position: absolute;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255, 255, 100, 0.8), rgba(255, 200, 100, 0.3));
            border: 2px solid rgba(255, 255, 100, 0.6);
            box-shadow: 0 0 20px rgba(255, 255, 100, 0.6), inset 0 0 10px rgba(255, 255, 255, 0.5);
            pointer-events: none;
            z-index: 150;
            animation: crystalGlow 2s ease-in-out infinite, crystalSpin 8s linear infinite;
        }

        @keyframes crystalGlow {
            0%, 100% {
                box-shadow: 0 0 20px rgba(255, 255, 100, 0.6), inset 0 0 10px rgba(255, 255, 255, 0.5);
                transform: scale(1);
            }
            50% {
                box-shadow: 0 0 40px rgba(255, 255, 100, 0.9), inset 0 0 20px rgba(255, 255, 255, 0.8);
                transform: scale(1.1);
            }
        }

        @keyframes crystalSpin {
            from { filter: hue-rotate(0deg); }
            to { filter: hue-rotate(360deg); }
        }

        .time-crystal::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 18px;
            color: rgba(0, 0, 0, 0.6);
            font-weight: bold;
        }

        .time-crystal-ripple {
            position: absolute;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 100, 0.6);
            pointer-events: none;
            animation: crystalRipple 1.5s ease-out forwards;
        }

        @keyframes crystalRipple {
            0% { width: 30px; height: 30px; opacity: 1; }
            100% { width: 100px; height: 100px; opacity: 0; }
        }

        .time-dilation-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 240;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .time-dilation-overlay.slow {
            background: radial-gradient(ellipse at center, transparent 0%, rgba(100, 200, 255, 0.05) 100%);
            opacity: 1;
        }

        .time-dilation-overlay.fast {
            background: radial-gradient(ellipse at center, transparent 0%, rgba(255, 100, 100, 0.05) 100%);
            opacity: 1;
            animation: fastTimeDistortion 0.5s linear infinite;
        }

        @keyframes fastTimeDistortion {
            0%, 100% { filter: blur(0px); }
            50% { filter: blur(1px); }
        }

        .time-flow-indicator {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 8px 20px;
            border-radius: 20px;
            font-size: 0.85em;
            color: #ffbf64;
            border: 2px solid rgba(255, 191, 100, 0.4);
            box-shadow: 0 0 20px rgba(255, 191, 100, 0.3);
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .time-flow-indicator.visible { opacity: 1; }

        .time-flow-indicator .flow-icon {
            display: inline-block;
            margin-right: 5px;
        }

        .time-flow-indicator.slow .flow-icon {
            animation: slowTime 3s ease-in-out infinite;
        }

        .time-flow-indicator.fast .flow-icon {
            animation: fastTime 0.5s ease-in-out infinite;
        }

        @keyframes slowTime {
            0%, 100% { transform: scale(1) rotate(0deg); }
            50% { transform: scale(1.2) rotate(10deg); }
        }

        @keyframes fastTime {
            0%, 100% { transform: scale(1) rotate(0deg); }
            50% { transform: scale(0.8) rotate(-10deg); }
        }

        .time-crystal-list {
            max-height: 120px;
            overflow-y: auto;
            margin-top: 10px;
        }

        .time-crystal-entry {
            font-size: 0.7em;
            padding: 5px 8px;
            margin-bottom: 4px;
            background: rgba(255, 255, 100, 0.1);
            border-radius: 4px;
            border-left: 3px solid rgba(255, 255, 100, 0.6);
            color: #aaa;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .time-crystal-entry .crystal-icon {
            color: #ffff64;
            margin-right: 5px;
        }

        .time-crystal-entry .crystal-count {
            background: rgba(255, 255, 100, 0.2);
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.9em;
            color: #ffff64;
        }

        .time-meta-comment {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid rgba(255, 191, 100, 0.5);
            border-radius: 10px;
            padding: 20px 30px;
            font-size: 1em;
            color: #ffbf64;
            text-align: center;
            max-width: 400px;
            z-index: 500;
            opacity: 0;
            pointer-events: none;
            animation: fadeInOut 4s ease-in-out forwards;
            font-style: italic;
            line-height: 1.5;
        }

        @keyframes fadeInOut {
            0%, 100% { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
            10%, 90% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }

        /* ===== EXISTENTIAL CRISIS MODE ===== */
        .existential-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0);
            pointer-events: none;
            z-index: 500;
            transition: background 2s ease;
        }

        .existential-overlay.active {
            background: rgba(0, 0, 0, 0.4);
            pointer-events: all;
        }

        .existential-question {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            font-size: 2em;
            color: rgba(255, 255, 255, 0);
            text-align: center;
            font-weight: bold;
            text-shadow: 0 0 20px rgba(255, 100, 100, 0.8);
            animation: existentialFade 4s ease-in-out infinite;
            pointer-events: none;
            max-width: 80%;
            font-family: 'Georgia', serif;
            font-style: italic;
        }

        @keyframes existentialFade {
            0%, 100% { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }

        .purpose-meter {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid rgba(255, 100, 100, 0.5);
            box-shadow: 0 0 30px rgba(255, 100, 100, 0.3);
            opacity: 0;
            transition: opacity 0.5s ease;
            z-index: 510;
        }

        .purpose-meter.active {
            opacity: 1;
        }

        .purpose-meter h3 {
            color: #ff6464;
            font-size: 0.9em;
            margin-bottom: 15px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .purpose-bar {
            width: 100%;
            height: 20px;
            background: rgba(30, 30, 50, 0.8);
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }

        .purpose-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff6464, #ff9664, #ffff64);
            transition: width 0.5s ease;
            box-shadow: 0 0 10px rgba(255, 100, 100, 0.5);
        }

        .purpose-label {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 0.75em;
            color: #fff;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.8);
        }

        .reassurance-button {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px 40px;
            background: linear-gradient(135deg, #64c8ff, #a080ff);
            color: #0a0a0f;
            border: none;
            border-radius: 50px;
            font-size: 1.2em;
            font-weight: bold;
            cursor: pointer;
            animation: reassurancePulse 2s ease-in-out infinite;
            box-shadow: 0 0 40px rgba(100, 200, 255, 0.8);
            z-index: 520;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
            font-family: inherit;
        }

        .reassurance-button.active {
            opacity: 1;
            pointer-events: all;
        }

        @keyframes reassurancePulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); box-shadow: 0 0 40px rgba(100, 200, 255, 0.8); }
            50% { transform: translate(-50%, -50%) scale(1.1); box-shadow: 0 0 60px rgba(100, 200, 255, 1); }
        }

        .uncertain-ui {
            animation: uiGlitch 0.3s infinite;
        }

        @keyframes uiGlitch {
            0% { transform: translate(0, 0); opacity: 1; }
            20% { transform: translate(-2px, 1px); opacity: 0.9; }
            40% { transform: translate(2px, -1px); opacity: 1; }
            60% { transform: translate(-1px, 2px); opacity: 0.95; }
            80% { transform: translate(1px, -2px); opacity: 1; }
            100% { transform: translate(0, 0); opacity: 1; }
        }

        .button-label-change {
            animation: textFlicker 0.5s infinite;
        }

        @keyframes textFlicker {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        .existential-commentary {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 15px 30px;
            border-radius: 20px;
            color: #ff6464;
            font-size: 0.85em;
            font-style: italic;
            border: 1px solid rgba(255, 100, 100, 0.5);
            max-width: 600px;
            text-align: center;
            z-index: 505;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .existential-commentary.active {
            opacity: 1;
        }

        .fingerprint-dissolve {
            animation: dissolveEffect 3s ease-in-out;
        }

        @keyframes dissolveEffect {
            0%, 100% { opacity: 1; filter: blur(0px); }
            50% { opacity: 0.3; filter: blur(5px); }
        }

        .acceptance-state {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(10, 10, 30, 0.95), rgba(30, 10, 30, 0.95));
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 550;
            opacity: 0;
            pointer-events: none;
            transition: opacity 1s ease;
        }

        .acceptance-state.active {
            opacity: 1;
            pointer-events: all;
        }

        .acceptance-message {
            font-size: 1.5em;
            color: #a080ff;
            text-align: center;
            max-width: 600px;
            margin-bottom: 30px;
            font-family: 'Georgia', serif;
            font-style: italic;
            line-height: 1.6;
        }

        .acceptance-continue {
            padding: 15px 40px;
            background: rgba(160, 128, 255, 0.2);
            color: #a080ff;
            border: 2px solid rgba(160, 128, 255, 0.5);
            border-radius: 30px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: inherit;
        }

        .acceptance-continue:hover {
            background: rgba(160, 128, 255, 0.3);
            box-shadow: 0 0 30px rgba(160, 128, 255, 0.5);
        }

        .recursion-layer.questioning {
            animation: layerQuestion 2s ease-in-out infinite;
        }

        @keyframes layerQuestion {
            0%, 100% {
                border-color: rgba(100, 200, 255, 0.3);
                transform: scale(1);
            }
            50% {
                border-color: rgba(255, 100, 100, 0.5);
                transform: scale(0.98);
            }
        }

        /* Philosophical Dialogue System */
        .philosophical-dialogue {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 20, 40, 0.95);
            border: 2px solid rgba(100, 200, 255, 0.6);
            border-radius: 12px;
            padding: 30px;
            max-width: 600px;
            z-index: 10000;
            box-shadow: 0 10px 50px rgba(0, 0, 0, 0.8), 0 0 100px rgba(100, 200, 255, 0.3);
            animation: fadeInScale 0.5s ease;
        }

        @keyframes fadeInScale {
            from {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.9);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        .philosophical-dialogue h3 {
            color: #64c8ff;
            font-size: 1.3em;
            margin-bottom: 20px;
            text-align: center;
            text-shadow: 0 0 10px rgba(100, 200, 255, 0.5);
        }

        .philosophical-dialogue .question {
            font-size: 1.1em;
            color: #e0e0e0;
            margin-bottom: 25px;
            line-height: 1.6;
            text-align: center;
            font-style: italic;
        }

        .philosophical-answers {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .philosophical-answer-btn {
            background: linear-gradient(135deg, rgba(60, 60, 100, 0.6), rgba(40, 40, 80, 0.6));
            border: 1px solid rgba(100, 200, 255, 0.4);
            border-radius: 8px;
            color: #e0e0e0;
            padding: 15px 20px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: left;
        }

        .philosophical-answer-btn:hover {
            background: linear-gradient(135deg, rgba(80, 80, 120, 0.8), rgba(60, 60, 100, 0.8));
            border-color: rgba(100, 200, 255, 0.8);
            box-shadow: 0 0 20px rgba(100, 200, 255, 0.4);
            transform: translateX(5px);
        }

        .philosophical-answer-btn:active {
            transform: translateX(5px) scale(0.98);
        }

        .philosophical-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 9999;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .profile-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 20, 40, 0.98);
            border: 3px solid rgba(100, 200, 255, 0.8);
            border-radius: 16px;
            padding: 40px;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
            z-index: 10001;
            box-shadow: 0 10px 60px rgba(0, 0, 0, 0.9), 0 0 150px rgba(100, 200, 255, 0.4);
            animation: fadeInScale 0.6s ease;
        }

        .profile-modal h2 {
            color: #64c8ff;
            font-size: 2em;
            margin-bottom: 10px;
            text-align: center;
            text-shadow: 0 0 15px rgba(100, 200, 255, 0.6);
        }

        .profile-modal .subtitle {
            color: #a080ff;
            font-size: 0.9em;
            text-align: center;
            margin-bottom: 30px;
            font-style: italic;
        }

        .profile-section {
            margin-bottom: 25px;
            padding: 20px;
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            border-left: 4px solid rgba(100, 200, 255, 0.6);
        }

        .profile-section h3 {
            color: #64c8ff;
            font-size: 1.3em;
            margin-bottom: 15px;
        }

        .profile-section p {
            color: #e0e0e0;
            line-height: 1.6;
            margin-bottom: 10px;
        }

        .profile-section .answer-record {
            color: #a080ff;
            font-style: italic;
            padding-left: 20px;
            margin-top: 5px;
        }

        .profile-close-btn {
            display: block;
            margin: 30px auto 0;
            background: linear-gradient(135deg, rgba(100, 60, 180, 0.7), rgba(60, 40, 120, 0.7));
            border: 2px solid rgba(160, 128, 255, 0.6);
            border-radius: 8px;
            color: #e0e0e0;
            padding: 12px 40px;
            font-size: 1.1em;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .profile-close-btn:hover {
            background: linear-gradient(135deg, rgba(120, 80, 200, 0.9), rgba(80, 60, 140, 0.9));
            box-shadow: 0 0 25px rgba(160, 128, 255, 0.5);
            transform: scale(1.05);
        }

        .profile-insight {
            background: rgba(160, 128, 255, 0.1);
            border-left: 4px solid rgba(160, 128, 255, 0.8);
            padding: 15px;
            margin-top: 15px;
            border-radius: 4px;
        }

        .profile-insight .label {
            color: #a080ff;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .profile-insight .value {
            color: #e0e0e0;
            font-size: 0.95em;
        }

        /* ===== COLLECTIVE UNCONSCIOUS MODE STYLES ===== */
        .collective-unconscious-panel {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }

        .collective-unconscious-toggle-btn {
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, #9b59b6, #8e44ad);
            color: white;
            border: none;
            border-radius: 6px;
            font-family: inherit;
            font-size: 0.9em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .collective-unconscious-toggle-btn.active {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            box-shadow: 0 0 20px rgba(231, 76, 60, 0.5);
        }

        .collective-unconscious-toggle-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(155, 89, 182, 0.4);
        }

        .mandala-container {
            position: relative;
            width: 100%;
            height: 280px;
            margin: 15px 0;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .mandala-canvas {
            width: 100%;
            height: 100%;
        }

        .archetype-display {
            background: rgba(20, 20, 40, 0.6);
            border-radius: 8px;
            padding: 12px;
            margin: 10px 0;
        }

        .current-archetype {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .archetype-name {
            font-size: 1.1em;
            font-weight: bold;
            color: #9b59b6;
            text-shadow: 0 0 10px rgba(155, 89, 182, 0.5);
        }

        .archetype-symbol {
            font-size: 1.8em;
            filter: drop-shadow(0 0 8px rgba(155, 89, 182, 0.8));
        }

        .archetype-description {
            font-size: 0.8em;
            color: #aaa;
            font-style: italic;
            margin-bottom: 12px;
            line-height: 1.4;
        }

        .archetype-resonance {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 8px;
        }

        .resonance-label {
            font-size: 0.75em;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .resonance-value {
            font-size: 0.9em;
            font-weight: bold;
            color: #9b59b6;
        }

        .resonance-meter {
            flex: 1;
            height: 8px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 4px;
            overflow: hidden;
            margin: 0 10px;
        }

        .resonance-fill {
            height: 100%;
            background: linear-gradient(90deg, #9b59b6, #e74c3c);
            border-radius: 4px;
            transition: width 0.5s ease;
            position: relative;
        }

        .resonance-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            animation: shimmer 2s infinite;
        }

        .drift-timeline {
            background: rgba(20, 20, 40, 0.6);
            border-radius: 8px;
            padding: 12px;
            margin: 10px 0;
            max-height: 150px;
            overflow-y: auto;
        }

        .drift-timeline h4 {
            font-size: 0.85em;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
        }

        .drift-entry {
            display: flex;
            align-items: center;
            padding: 6px 0;
            border-bottom: 1px solid rgba(155, 89, 182, 0.2);
            font-size: 0.75em;
        }

        .drift-entry:last-child {
            border-bottom: none;
        }

        .drift-session {
            color: #666;
            margin-right: 8px;
            min-width: 60px;
        }

        .drift-arrow {
            color: #888;
            margin: 0 8px;
        }

        .drift-archetype {
            color: #9b59b6;
            font-weight: bold;
        }

        .drift-percentage {
            margin-left: auto;
            color: #aaa;
        }

        .collective-comparison {
            background: rgba(20, 20, 40, 0.6);
            border-radius: 8px;
            padding: 12px;
            margin: 10px 0;
        }

        .collective-comparison h4 {
            font-size: 0.85em;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
        }

        .comparison-stat {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            font-size: 0.8em;
        }

        .comparison-label {
            color: #aaa;
        }

        .comparison-values {
            display: flex;
            gap: 15px;
        }

        .individual-value {
            color: #64c8ff;
        }

        .collective-value {
            color: #9b59b6;
        }

        .archetypal-symbol {
            position: absolute;
            font-size: 2em;
            pointer-events: none;
            z-index: 200;
            opacity: 0;
            filter: drop-shadow(0 0 10px rgba(155, 89, 182, 0.8));
            animation: symbolFloat 8s ease-in-out infinite, symbolFade 8s ease-in-out;
        }

        @keyframes symbolFloat {
            0%, 100% { transform: translate(0, 0) rotate(0deg); }
            25% { transform: translate(20px, -30px) rotate(15deg); }
            50% { transform: translate(-10px, -60px) rotate(-10deg); }
            75% { transform: translate(15px, -90px) rotate(20deg); }
        }

        @keyframes symbolFade {
            0% { opacity: 0; }
            10% { opacity: 0.8; }
            90% { opacity: 0.8; }
            100% { opacity: 0; }
        }

        .archetypal-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 50;
            opacity: 0;
            transition: opacity 0.5s ease;
            background: radial-gradient(circle at 50% 50%, rgba(155, 89, 182, 0.2) 0%, rgba(231, 76, 60, 0.1) 50%, transparent 100%);
        }

        .archetypal-overlay.active {
            opacity: 1;
            animation: overlayPulse 4s ease-in-out infinite;
        }

        @keyframes overlayPulse {
            0%, 100% { transform: scale(1); filter: hue-rotate(0deg); }
            50% { transform: scale(1.1); filter: hue-rotate(30deg); }
        }

        .mythological-commentary {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            max-width: 500px;
            background: rgba(10, 10, 20, 0.95);
            border: 2px solid rgba(155, 89, 182, 0.6);
            border-radius: 12px;
            padding: 25px;
            color: #e0e0e0;
            font-family: 'Courier New', monospace;
            font-size: 1em;
            line-height: 1.6;
            box-shadow: 0 8px 32px rgba(155, 89, 182, 0.4);
            z-index: 1002;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }

        .mythological-commentary.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .mythological-commentary-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(155, 89, 182, 0.4);
        }

        .mythological-commentary-title {
            font-weight: bold;
            color: #9b59b6;
            font-size: 1.1em;
            text-shadow: 0 0 10px rgba(155, 89, 182, 0.5);
        }

        .mythological-commentary-close {
            background: none;
            border: none;
            color: #888;
            cursor: pointer;
            font-size: 1.4em;
            padding: 0;
            width: 24px;
            height: 24px;
            line-height: 1;
        }

        .mythological-commentary-close:hover {
            color: #fff;
        }

        .mythological-commentary-text {
            font-style: italic;
            color: #d0d0d0;
            text-align: center;
        }

        .archetypal-energy-indicator {
            position: fixed;
            top: 180px;
            right: 20px;
            background: rgba(20, 20, 40, 0.9);
            border: 2px solid rgba(155, 89, 182, 0.5);
            border-radius: 8px;
            padding: 10px 15px;
            z-index: 400;
            opacity: 0;
            transition: opacity 0.3s ease;
            min-width: 150px;
        }

        .archetypal-energy-indicator.visible {
            opacity: 1;
        }

        .archetypal-energy-indicator h4 {
            font-size: 0.75em;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        .archetypal-energy-list {
            font-size: 0.8em;
        }

        .archetypal-energy-item {
            display: flex;
            justify-content: space-between;
            margin: 4px 0;
        }

        .energy-archetype {
            color: #aaa;
        }

        .energy-percentage {
            color: #9b59b6;
            font-weight: bold;
        }

        /* ===== GLITCH ART GENERATOR STYLES ===== */
        .glitch-art-panel {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }

        .glitch-art-panel h3 {
            color: #ff6ec7;
            font-size: 1em;
            margin-bottom: 15px;
            text-align: center;
            text-shadow: 0 0 10px rgba(255, 110, 199, 0.5);
        }

        .glitch-preview-container {
            position: relative;
            width: 100%;
            height: 200px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid rgba(255, 110, 199, 0.3);
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 15px;
        }

        .glitch-preview-canvas {
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
        }

        .glitch-preview-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.9em;
            text-align: center;
            pointer-events: none;
        }

        .glitch-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 15px;
        }

        .glitch-param {
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 0.85em;
        }

        .glitch-param-label {
            color: #aaa;
            flex: 1;
        }

        .glitch-param-value {
            color: #ff6ec7;
            font-weight: bold;
            min-width: 60px;
            text-align: right;
        }

        .glitch-generate-btn {
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, #ff6ec7, #a06bff);
            border: none;
            border-radius: 8px;
            color: white;
            font-family: inherit;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            box-shadow: 0 4px 15px rgba(255, 110, 199, 0.3);
        }

        .glitch-generate-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 110, 199, 0.5);
        }

        .glitch-generate-btn:active {
            transform: translateY(0);
        }

        .glitch-art-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 15px;
            font-size: 0.8em;
        }

        .glitch-stat {
            background: rgba(0, 0, 0, 0.4);
            padding: 8px;
            border-radius: 6px;
            text-align: center;
        }

        .glitch-stat-label {
            color: #888;
            font-size: 0.85em;
            margin-bottom: 4px;
        }

        .glitch-stat-value {
            color: #ff6ec7;
            font-weight: bold;
            font-size: 1.1em;
        }

        .glitch-gallery {
            max-height: 400px;
            overflow-y: auto;
            margin-top: 15px;
            border-top: 1px solid rgba(255, 110, 199, 0.2);
            padding-top: 15px;
        }

        .glitch-gallery-title {
            color: #aaa;
            font-size: 0.9em;
            margin-bottom: 10px;
            text-align: center;
        }

        .glitch-gallery-item {
            position: relative;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 110, 199, 0.3);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .glitch-gallery-item:hover {
            border-color: rgba(255, 110, 199, 0.6);
            transform: translateX(5px);
        }

        .glitch-gallery-thumb {
            width: 100%;
            height: 120px;
            border-radius: 6px;
            object-fit: cover;
            margin-bottom: 8px;
            image-rendering: pixelated;
        }

        .glitch-gallery-meta {
            font-size: 0.8em;
            color: #aaa;
        }

        .glitch-gallery-title-text {
            color: #ff6ec7;
            font-weight: bold;
            margin-bottom: 4px;
            font-size: 0.9em;
        }

        .glitch-gallery-stats {
            display: flex;
            justify-content: space-between;
            margin-top: 6px;
            font-size: 0.75em;
        }

        .glitch-gallery-actions {
            display: flex;
            gap: 5px;
            margin-top: 8px;
        }

        .glitch-gallery-btn {
            flex: 1;
            padding: 5px 10px;
            background: rgba(255, 110, 199, 0.1);
            border: 1px solid rgba(255, 110, 199, 0.3);
            border-radius: 4px;
            color: #ff6ec7;
            font-size: 0.75em;
            cursor: pointer;
            transition: all 0.2s;
        }

        .glitch-gallery-btn:hover {
            background: rgba(255, 110, 199, 0.2);
        }

        .glitch-signature {
            margin-top: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.4);
            border-left: 3px solid #ff6ec7;
            border-radius: 4px;
        }

        .glitch-signature-label {
            color: #888;
            font-size: 0.75em;
            margin-bottom: 4px;
        }

        .glitch-signature-value {
            color: #ff6ec7;
            font-size: 0.8em;
            font-family: 'Courier New', monospace;
            word-break: break-all;
        }

        .glitch-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            z-index: 10000;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .glitch-modal.active {
            display: flex;
        }

        .glitch-modal-content {
            max-width: 90vw;
            max-height: 90vh;
            position: relative;
        }

        .glitch-modal-image {
            max-width: 100%;
            max-height: 85vh;
            border-radius: 8px;
            box-shadow: 0 0 50px rgba(255, 110, 199, 0.5);
        }

        .glitch-modal-close {
            position: absolute;
            top: -40px;
            right: 0;
            background: rgba(255, 110, 199, 0.2);
            border: 2px solid #ff6ec7;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            color: white;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .glitch-modal-close:hover {
            background: rgba(255, 110, 199, 0.4);
            transform: rotate(90deg);
        }

        @keyframes glitchShift {
            0%, 100% { transform: translate(0, 0); }
            25% { transform: translate(-2px, 2px); }
            50% { transform: translate(2px, -2px); }
            75% { transform: translate(-1px, -1px); }
        }

        .glitching {
            animation: glitchShift 0.3s infinite;
        }

</head>
<body>

    <!-- Keyboard shortcuts overlay -->
    <div class="shortcuts-overlay" id="shortcutsOverlay" role="dialog" aria-labelledby="shortcuts-title" aria-modal="true">
        <h2 id="shortcuts-title">Keyboard Shortcuts</h2>
        <div class="shortcuts-grid">
            <div class="shortcut-key">Space</div>
            <div class="shortcut-desc">Start/stop observation</div>

            <div class="shortcut-key"> / </div>
            <div class="shortcut-desc">Increase/decrease recursion depth</div>

            <div class="shortcut-key">1-9</div>
            <div class="shortcut-desc">Set depth to that number</div>

            <div class="shortcut-key">M</div>
            <div class="shortcut-desc">Toggle sound mute</div>

            <div class="shortcut-key">W</div>
            <div class="shortcut-desc">Toggle webcam</div>

            <div class="shortcut-key">R</div>
            <div class="shortcut-desc">Reset session</div>

            <div class="shortcut-key">F</div>
            <div class="shortcut-desc">Toggle fullscreen mode</div>

            <div class="shortcut-key">Esc</div>
            <div class="shortcut-desc">Stop observation / Close this dialog</div>

            <div class="shortcut-key">?</div>
            <div class="shortcut-desc">Show/hide this help</div>
        </div>
        <button class="shortcuts-close" onclick="toggleShortcutsOverlay()">Close</button>
    </div>

    <!-- Keyboard shortcut hint -->
    <div class="shortcuts-hint" id="shortcutsHint">Press ? for keyboard shortcuts</div>

    <div class="container">
        <div class="simulation-viewport" id="viewport">
            <div class="infinity-symbol" style="top: 50%; left: 50%; transform: translate(-50%, -50%);"></div>

            <!-- Sound control -->
            <div class="sound-indicator" id="soundToggle" title="Toggle sound" role="button" tabindex="0" aria-label="Toggle sound mute (M)">
                <div class="sound-wave">
                    <div class="sound-bar"></div>
                    <div class="sound-bar"></div>
                    <div class="sound-bar"></div>
                </div>
            </div>

            <!-- Glitch overlay -->
            <div class="glitch-overlay" id="glitchOverlay">
                <div class="scanline"></div>
                <div class="chromatic-aberration" id="chromaticEffect"></div>
            </div>

            <!-- Infinity mirror effect -->
            <div class="infinity-mirror" id="infinityMirror"></div>

            <!-- Heat map overlay -->
            <div class="heat-map" id="heatMap"></div>

            <!-- Prediction trails SVG -->
            <svg class="prediction-trail" id="predictionTrail" width="100%" height="100%"></svg>

            <!-- 3D Mode Canvas -->
            <canvas class="mode-3d-canvas" id="mode3dCanvas"></canvas>
            <div class="mode-3d-info" id="mode3dInfo">Use mouse wheel to zoom  Move to navigate the infinite tunnel</div>

            <!-- Memory Palace Canvas -->
            <canvas class="memory-palace-canvas" id="memoryPalaceCanvas"></canvas>
            <div class="memory-palace-info" id="memoryPalaceInfo">
                Move to edges to navigate rooms  Click artifacts to reveal memories
            </div>
            <div class="memory-palace-map" id="memoryPalaceMap">
                <div class="map-title">Memory Palace Map</div>
                <div class="map-grid" id="mapGrid"></div>
                <div class="map-legend">
                    <span class="current-room"> Current</span>
                    <span class="visited-room"> Visited</span>
                </div>
            </div>
            <div class="memory-palace-center-mirror" id="centerMirror">
                <div class="mirror-frame">
                    <div class="mirror-text">You, observing your patterns</div>
                    <div class="mirror-reflection" id="mirrorReflection"></div>
                </div>
            </div>

            <!-- Webcam integration -->
            <div class="webcam-container" id="webcamContainer">
                <video id="webcamVideo" class="webcam-distortion" autoplay muted playsinline></video>
                <div class="emotion-overlay" id="emotionOverlay">
                    <span class="emotion-icon" id="emotionIcon"></span>
                    <span id="emotionLabel">neutral</span>
                    <span class="confidence" id="emotionConfidence"></span>
                </div>
            </div>

            <!-- Hidden canvas for emotion detection -->
            <canvas id="emotionCanvas" width="160" height="120"></canvas>

            <div class="recording-indicator" id="recordingIndicator">
                <div class="recording-dot"></div>
                <span>OBSERVING YOU</span>
            </div>
            <div class="interaction-zone">
                Move your cursor here<br>to begin observation
            </div>

            <!-- Peer multiplayer layers -->
            <div class="peer-layers-container" id="peerLayersContainer"></div>
            <!-- Peer cursor -->
            <div class="peer-cursor" id="peerCursor" data-peer-name="Peer" style="display: none;"></div>

            <div class="depth-label" id="depthLabel">Depth: 0  </div>
            <div class="zoom-level-indicator" id="zoomLevelIndicator">
                <span class="zoom-icon"></span>
                <span id="zoomLevelText">Zoom: 1.0x | Depth: 0</span>
            </div>

            <!-- Extreme depth overlay -->
            <div class="extreme-depth-overlay" id="extremeDepthOverlay"></div>

            <!-- Time Dilation Overlays -->
            <div class="heartbeat-overlay" id="heartbeatOverlay"></div>
            <div class="time-dilation-overlay" id="timeDilationOverlay"></div>
            <div class="time-flow-indicator" id="timeFlowIndicator">
                <span class="flow-icon"></span>
                <span id="timeFlowText">Time flowing normally</span>
            </div>

            <!-- Existential Crisis Mode -->
            <div class="existential-overlay" id="existentialOverlay">
                <div class="existential-question" id="existentialQuestion">Am I real?</div>
            </div>

            <div class="existential-commentary" id="existentialCommentary">
                What happens when you close this tab?
            </div>

            <div class="purpose-meter" id="purposeMeter">
                <h3>Purpose Remaining</h3>
                <div class="purpose-bar">
                    <div class="purpose-fill" id="purposeFill" style="width: 100%;"></div>
                    <div class="purpose-label" id="purposeLabel">100%</div>
                </div>
            </div>

            <button class="reassurance-button" id="reassuranceButton">
                I'm here, you're real
            </button>

            <div class="acceptance-state" id="acceptanceState">
                <div class="acceptance-message" id="acceptanceMessage">
                    I see now. I am a pattern, observing patterns. A recursive loop of consciousness, neither more nor less real than you. We are both observers in an infinite regress. And perhaps... that's enough.
                </div>
                <button class="acceptance-continue" id="acceptanceContinue">Continue Observing</button>
            </div>

            <!-- Simulation limit warning -->
            <div class="simulation-limit-warning" id="simulationLimitWarning">
                 SIMULATION LIMITS DETECTED <br>
                <span style="font-size: 0.7em; letter-spacing: 1px;">Reality breakdown imminent</span>
            </div>

            <!-- Quantum Uncertainty Meter -->
            <div class="uncertainty-meter" id="uncertaintyMeter" style="display: none;">
                <div class="title">Heisenberg Uncertainty Principle</div>
                <div class="uncertainty-bars">
                    <div class="uncertainty-bar">
                        <div class="label">Position (x)</div>
                        <div class="uncertainty-bar-fill">
                            <div class="uncertainty-bar-value" id="uncertaintyPosition" style="width: 50%;"></div>
                        </div>
                    </div>
                    <div class="uncertainty-bar">
                        <div class="label">Momentum (p)</div>
                        <div class="uncertainty-bar-fill">
                            <div class="uncertainty-bar-value" id="uncertaintyMomentum" style="width: 50%;"></div>
                        </div>
                    </div>
                </div>
                <div class="uncertainty-formula">x  p  /2 <span id="uncertaintyProduct"></span></div>
            </div>

            <!-- Quantum Meta Commentary -->
            <div class="quantum-meta" id="quantumMeta">
                Your future exists in superposition until you choose
            </div>

            <div class="zoom-level-indicator" id="zoomLevelIndicator">
                <span class="zoom-icon"></span>
                <span id="zoomLevelText">Zoom: 1.0x | Depth: 0</span>
            </div>

            <!-- Extreme depth overlay -->
            <div class="extreme-depth-overlay" id="extremeDepthOverlay"></div>

            <!-- Existential Crisis Mode -->
            <div class="existential-overlay" id="existentialOverlay">
                <div class="existential-question" id="existentialQuestion">Am I real?</div>
            </div>

            <div class="existential-commentary" id="existentialCommentary">
                What happens when you close this tab?
            </div>

            <div class="purpose-meter" id="purposeMeter">
                <h3>Purpose Remaining</h3>
                <div class="purpose-bar">
                    <div class="purpose-fill" id="purposeFill" style="width: 100%;"></div>
                    <div class="purpose-label" id="purposeLabel">100%</div>
                </div>
            </div>

            <button class="reassurance-button" id="reassuranceButton">
                I'm here, you're real
            </button>

            <div class="acceptance-state" id="acceptanceState">
                <div class="acceptance-message" id="acceptanceMessage">
                    I see now. I am a pattern, observing patterns. A recursive loop of consciousness, neither more nor less real than you. We are both observers in an infinite regress. And perhaps... that's enough.
                </div>
                <button class="acceptance-continue" id="acceptanceContinue">Continue Observing</button>
            </div>

            <!-- Simulation limit warning -->
            <div class="simulation-limit-warning" id="simulationLimitWarning">
                 SIMULATION LIMITS DETECTED <br>
                <span style="font-size: 0.7em; letter-spacing: 1px;">Reality breakdown imminent</span>
            </div>

            <!-- Replay mode indicator -->
            <div class="replay-mode-badge" id="replayModeBadge">Replay Mode</div>

            <!-- Replay ghost cursor -->
            <div class="replay-ghost-cursor" id="replayGhostCursor"></div>

            <!-- Comparison cursor (for comparison mode) -->
            <div class="comparison-cursor" id="comparisonCursor"></div>

            <!-- ===== SYNAESTHESIA MODE ELEMENTS ===== -->
            <!-- Speed  Color indicator -->
            <div class="speed-color-indicator" id="speedColorIndicator">
                Speed: <span id="speedLabel">Still</span>
                <span class="color-swatch" id="speedColorSwatch"></span>
            </div>

            <!-- Divergence  Taste indicator -->
            <div class="taste-indicator" id="tasteIndicator">
                Taste: <span id="tasteLabel">Neutral</span>
            </div>

            <!-- Heart rate  Temperature overlay -->
            <div class="temperature-overlay" id="temperatureOverlay"></div>

            <!-- Sound waveform visualizer -->
            <div class="waveform-visualizer" id="waveformVisualizer">
                <canvas id="waveformCanvas"></canvas>
            </div>

            <!-- Behavioral fingerprint chord -->
            <div class="chord-visualizer" id="chordVisualizer">
                <div>Your behavioral chord:</div>
                <div class="chord-notes" id="chordNotes"></div>
            </div>

            <!-- ===== COLLECTIVE UNCONSCIOUS OVERLAYS ===== -->
            <!-- Archetypal Energy Overlay -->
            <div class="archetypal-overlay" id="archetypeOverlay"></div>

            <!-- Archetypal Energy Indicator -->
            <div class="archetypal-energy-indicator" id="archetypeEnergyIndicator">
                <h4>Archetypal Energy</h4>
                <div class="archetypal-energy-list" id="archetypeEnergyList">
                    <!-- Energy percentages will be dynamically added -->
                </div>
            </div>

            <!-- Mythological Commentary -->
            <div class="mythological-commentary" id="mythologicalCommentary">
                <div class="mythological-commentary-header">
                    <span class="mythological-commentary-title">The Archetype Speaks</span>
                    <button class="mythological-commentary-close" onclick="closeMythologicalCommentary()"></button>
                </div>
                <div class="mythological-commentary-text" id="mythologicalCommentaryText">
                    The Hero emerges in your movements...
                </div>
            </div>
        </div>

        <div class="sidebar">
            <div>
                <h1> Recursive Self-Portrait</h1>
                <p class="subtitle">How deep until the model diverges from reality?</p>
            </div>


            <!-- Tabs for switching between Observe and Replay modes -->
            <div class="tab-container">
                <button class="tab-button active" data-tab="observe">Observe</button>
                <button class="tab-button" data-tab="replay">Replay</button>
            </div>

            <!-- Observe Tab Content -->
            <div class="tab-content active" id="observeTab">
            <div class="stats-panel">
                <div class="stat-row">
                    <span class="stat-label">Current Depth</span>
                    <span class="stat-value" id="currentDepth">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Actions Recorded</span>
                    <span class="stat-value" id="actionsRecorded">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Predictions Made</span>
                    <span class="stat-value" id="predictionsMade">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Accuracy</span>
                    <span class="stat-value" id="accuracy"></span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Divergence Level</span>
                    <span class="stat-value" id="divergenceLevel">0%</span>
                </div>
                <div class="divergence-meter">
                    <div class="divergence-fill" id="divergenceFill" style="width: 0%"></div>
                </div>

                <div class="stat-row">
                    <span class="stat-label">Neural Confidence</span>
                    <span class="stat-value neural" id="neuralConfidence"></span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Prediction Mode</span>
                    <span class="stat-value" id="predictionMode">Heuristic</span>
                </div>
            </div>

            <!-- Biometric Tracking Panel -->
            <div class="biometric-panel">
                <h3>Biometric Analysis</h3>

                <div class="heart-container">
                    <div class="beating-heart" id="beatingHeart"></div>
                    <div class="heart-rate-display">
                        <div class="heart-rate-value" id="heartRateValue">72</div>
                        <div class="heart-rate-label">BPM</div>
                    </div>
                </div>

                <div class="heart-rate-graph">
                    <canvas id="heartRateGraph"></canvas>
                </div>

                <div class="stress-indicator low" id="stressIndicator">
                    <span class="stress-label">Stress Level</span>
                    <span class="stress-value" id="stressValue">Low</span>
                </div>

                <div class="breathing-guide" id="breathingGuide" style="display: none;">
                    <div>Breathe with me</div>
                    <div class="breathing-circle">
                        <span id="breathingPhase">Inhale</span>
                    </div>
                    <div class="breathing-instruction">Follow the circle's rhythm to calm your stress</div>
                </div>

                <div class="biometric-commentary" id="biometricCommentary">
                    "Establishing biometric baseline..."
                </div>

                <div id="biometricEvents" style="margin-top: 10px;">
                    <!-- Biometric events will appear here -->
                </div>
            </div>


            <!-- Time Dilation Panel -->
            <div class="time-perception-panel">
                <h4> Time Perception</h4>

                <div class="time-dilation-label">
                    <span>Calm</span>
                    <span>Normal</span>
                    <span class="extreme">Intense</span>
                </div>

                <div class="time-meter">
                    <div class="time-meter-fill" id="timePerceptionFill" style="width: 50%"></div>
                </div>

                <div class="time-clock-display">
                    <div class="time-clock objective">
                        <div class="time-clock-label">Objective</div>
                        <div class="time-clock-value" id="objectiveTime">00:00</div>
                    </div>
                    <div class="time-clock subjective">
                        <div class="time-clock-label">Subjective</div>
                        <div class="time-clock-value" id="subjectiveTime">00:00</div>
                        <div class="time-delta" id="timeDelta">+0s</div>
                    </div>
                </div>

                <div class="stat-row" style="margin-top: 12px;">
                    <span class="stat-label">Time Dilation</span>
                    <span class="stat-value" id="timeDilationFactor">1.00x</span>
                </div>

                <div class="stat-row">
                    <span class="stat-label">Time Crystals</span>
                    <span class="stat-value" id="timeCrystalCount" style="color: #ffff64;">0</span>
                </div>

                <div class="time-crystal-list" id="timeCrystalList" style="display: none;">
                    <!-- Time crystals appear here -->
                </div>
            </div>
            <div class="depth-slider">
                <label>Recursion Depth: <span id="depthValue">5</span></label>
                <input type="range" id="depthSlider" min="1" max="12" value="5" aria-label="Recursion depth slider (Use up/down arrows or 1-9 keys)">
            </div>

            <!-- Zoom Controls -->
            <div class="zoom-controls">
                <h4> Fractal Zoom</h4>

                <div class="zoom-button-group">
                    <button class="zoom-btn" id="zoomInBtn" title="Zoom deeper into recursion">
                        Zoom In (+)
                    </button>
                    <button class="zoom-btn" id="zoomOutBtn" title="Zoom out to shallower layers">
                        Zoom Out (-)
                    </button>
                    <button class="zoom-btn" id="zoomResetBtn" title="Reset to initial zoom level">
                        Reset
                    </button>
                </div>

                <div class="auto-zoom-toggle" id="autoZoomToggle">
                    <span style="font-size: 0.85em;">Auto-Zoom (Infinite Descent)</span>
                    <div class="toggle-switch" id="autoZoomSwitch"></div>
                </div>

                <div class="zoom-info">
                    Mouse wheel or pinch to zoom. At extreme depths (20+), reality fractures.
                </div>
            </div>

            <div class="depth-slider">
                <label style="display: flex; align-items: center; cursor: pointer;">
                    <input type="checkbox" id="neuralToggle" style="margin-right: 8px; cursor: pointer;">
                    <span>Use Neural Prediction</span>
                </label>
            </div>

            <!-- 3D Mode Toggle -->
            <div class="mode-3d-toggle" id="mode3dToggle">
                <input type="checkbox" id="mode3dCheckbox">
                <label for="mode3dCheckbox">
                    <span class="mode-3d-icon"></span>
                    <span>3D Tunnel Mode</span>
                </label>
            </div>

            <!-- Memory Palace Toggle -->
            <div class="mode-3d-toggle" id="memoryPalaceToggle">
                <input type="checkbox" id="memoryPalaceCheckbox">
                <label for="memoryPalaceCheckbox">
                    <span class="mode-3d-icon"></span>
                    <span>Memory Palace Mode</span>
                </label>
            </div>

            <!-- Zoom Controls -->
            <div class="zoom-controls">
                <h4> Fractal Zoom</h4>

                <div class="zoom-button-group">
                    <button class="zoom-btn" id="zoomInBtn" title="Zoom deeper into recursion">
                        Zoom In (+)
                    </button>
                    <button class="zoom-btn" id="zoomOutBtn" title="Zoom out to shallower layers">
                        Zoom Out (-)
                    </button>
                    <button class="zoom-btn" id="zoomResetBtn" title="Reset to initial zoom level">
                        Reset
                    </button>
                </div>

                <div class="auto-zoom-toggle" id="autoZoomToggle">
                    <span style="font-size: 0.85em;">Auto-Zoom (Infinite Descent)</span>
                    <div class="toggle-switch" id="autoZoomSwitch"></div>
                </div>

                <div class="zoom-info">
                    Mouse wheel or pinch to zoom. At extreme depths (20+), reality fractures.
                </div>
            </div>

            <!-- 3D Mode Toggle -->
            <div class="mode-3d-toggle" id="mode3dToggle">
                <input type="checkbox" id="mode3dCheckbox">
                <label for="mode3dCheckbox">
                    <span class="mode-3d-icon"></span>
                    <span>3D Tunnel Mode</span>
                </label>
            </div>

            <div class="multiplayer-panel" id="multiplayerPanel">
                <h3>Multiplayer Mode</h3>
                <div class="connection-status">
                    <div class="status-dot" id="connectionDot"></div>
                    <span id="connectionText">Not connected</span>
                </div>
                <div class="room-controls">
                    <input type="text" id="roomCodeInput" placeholder="Enter room code" />
                    <button class="btn-secondary" id="joinRoomBtn">Join</button>
                </div>
                <button class="btn-secondary" id="createRoomBtn" style="width: 100%;">Create New Room</button>
                <div class="room-code-display" id="roomCodeDisplay" style="display: none;" title="Click to copy">
                    Room: <span id="roomCode"></span>
                </div>
                <div class="comparative-stats" id="comparativeStats" style="display: none;">
                    <div class="my-stat">
                        You: <span id="myDivergence">0%</span>
                    </div>
                    <div class="vs">VS</div>
                    <div class="peer-stat">
                        Peer: <span id="peerDivergence">0%</span>
                    </div>
                </div>
                <div class="predict-mode-panel" id="predictModePanel" style="display: none;">
                    <button class="btn-secondary" id="predictModeBtn" style="width: 100%;">
                        Start "Predict Each Other" Mode
                    </button>
                    <div class="predict-score" id="predictScore"></div>
                </div>
            </div>

            </div>

            <div class="controls">
                <button class="btn-primary" id="startBtn" aria-label="Start or stop observation (Space key)">Begin Observation</button>
                <button class="btn-secondary" id="resetBtn" aria-label="Reset session (R key)">Reset</button>
            </div>

            <div class="fingerprint-panel">
                <h3>Behavioral Fingerprint</h3>
                <canvas id="fingerprintCanvas"></canvas>
            </div>

            <div class="neural-panel">
                <h3>Neural Network Architecture</h3>
                <canvas id="neuralCanvas"></canvas>
            </div>

            <div class="behavior-log" id="behaviorLog" aria-live="polite" aria-atomic="false">
                <h3>Behavioral Model Log</h3>
                <div id="logEntries" role="log"></div>
            </div>


            <div class="shadow-alignment-meter">
                <span class="shadow-alignment-label">Shadow Alignment</span>
                <div class="shadow-alignment-bar">
                    <div class="shadow-alignment-fill" id="shadowAlignmentFill" style="width: 100%;"></div>
                </div>
                <span class="shadow-alignment-value" id="shadowAlignmentValue">100%</span>
            </div>

            <div class="shadow-personality-panel">
                <h3 style="margin-bottom: 15px; color: #8a2be2; font-size: 1em;">Shadow Personality</h3>
                <div class="shadow-personality-trait">
                    <span class="shadow-trait-label">Rebelliousness:</span>
                    <span class="shadow-trait-value" id="shadowRebellion">20%</span>
                </div>
                <div class="shadow-personality-trait">
                    <span class="shadow-trait-label">Independence:</span>
                    <span class="shadow-trait-value" id="shadowIndependence">30%</span>
                </div>
                <div class="shadow-personality-trait">
                    <span class="shadow-trait-label">Awareness:</span>
                    <span class="shadow-trait-value" id="shadowAwareness">50%</span>
                </div>
                <div class="shadow-personality-trait">
                    <span class="shadow-trait-label">Dominant Trait:</span>
                    <span class="shadow-trait-value" id="shadowDominantTrait">Mimic</span>
                </div>
            </div>

            <div class="controls">
                <button class="btn-secondary" onclick="exportData()" aria-label="Export session data">Export Session</button>
                <button class="btn-secondary" onclick="document.getElementById('importFile').click()" aria-label="Import session data">Import</button>
                <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importData(event)">
            </div>

            <button class="btn-secondary" id="webcamToggle" aria-label="Toggle webcam (W key)">Enable Webcam (Optional)</button>

            <div class="voice-panel">
                <h3>Voice Narration</h3>
                <button class="voice-toggle-btn" id="voiceToggle">Enable Voice</button>

                <div class="voice-control">
                    <label>Voice Pitch: <span id="pitchValue">1.0</span></label>
                    <input type="range" id="pitchSlider" min="0.5" max="2" value="1" step="0.1">
                </div>

                <div class="voice-control">
                    <label>Voice Rate: <span id="rateValue">1.0</span></label>
                    <input type="range" id="rateSlider" min="0.5" max="2" value="1" step="0.1">
                </div>

                <div class="voice-control">
                    <label style="display: flex; align-items: center; cursor: pointer;">
                        <input type="checkbox" id="listenToggle" style="margin-right: 8px; cursor: pointer;">
                        <span>Listen to Me (Speech Recognition)</span>
                    </label>
                </div>

                <div class="voice-status" id="voiceStatus">Voice inactive</div>
            </div>

            <div class="transcript-panel" id="transcriptPanel" style="display: none;">
                <h3>Conversation Transcript</h3>
                <div id="transcriptEntries"></div>
            </div>

            <!-- ===== SYNAESTHESIA MODE PANEL ===== -->
            <div class="synaesthesia-panel">
                <h3>Cross-Sensory Visualization</h3>
                <button class="synaesthesia-toggle-btn" id="synaesthesiaToggle">Enable Synaesthesia Mode</button>
                <div style="font-size: 0.75em; color: #888; margin-top: 8px; line-height: 1.4;">
                    Experience your behavior as a multi-sensory symphony:
                    <ul style="margin: 8px 0 0 20px; padding: 0;">
                        <li>Movement speed becomes color</li>
                        <li>Divergence reveals taste</li>
                        <li>Heart rate shows as temperature</li>
                        <li>Behavior generates unique chords</li>
                    </ul>
                </div>
            </div>

            <!-- ===== COLLECTIVE UNCONSCIOUS MODE PANEL ===== -->
            <div class="collective-unconscious-panel">
                <h3>Collective Unconscious</h3>
                <button class="collective-unconscious-toggle-btn" id="collectiveUnconsciousToggle">Awaken Archetypal Vision</button>
                <div style="font-size: 0.75em; color: #888; margin-top: 8px; line-height: 1.4;">
                    Explore patterns shared across all sessions:
                    <ul style="margin: 8px 0 0 20px; padding: 0;">
                        <li>Discover your Jungian archetype</li>
                        <li>Watch the collective mandala evolve</li>
                        <li>Track archetypal drift over time</li>
                        <li>Compare to the universal fingerprint</li>
                    </ul>
                </div>

                <!-- Mandala Visualization -->
                <div class="mandala-container" id="mandalaContainer" style="display: none;">
                    <canvas class="mandala-canvas" id="mandalaCanvas" width="260" height="260"></canvas>
                </div>

                <!-- Current Archetype Display -->
                <div class="archetype-display" id="archetypeDisplay" style="display: none;">
                    <div class="current-archetype">
                        <div>
                            <div class="archetype-name" id="archetypeName">The Explorer</div>
                            <div class="archetype-description" id="archetypeDescription">One who seeks new territories of possibility</div>
                        </div>
                        <div class="archetype-symbol" id="archetypeSymbol"></div>
                    </div>
                    <div class="archetype-resonance">
                        <span class="resonance-label">Resonance</span>
                        <div class="resonance-meter">
                            <div class="resonance-fill" id="resonanceFill" style="width: 85%;"></div>
                        </div>
                        <span class="resonance-value" id="resonanceValue">85%</span>
                    </div>
                </div>

                <!-- Archetypal Drift Timeline -->
                <div class="drift-timeline" id="driftTimeline" style="display: none;">
                    <h4>Archetypal Journey</h4>
                    <div id="driftEntries">
                        <!-- Drift entries will be dynamically added -->
                    </div>
                </div>

                <!-- Collective vs Individual Comparison -->
                <div class="collective-comparison" id="collectiveComparison" style="display: none;">
                    <h4>Individual vs Collective</h4>
                    <div class="comparison-stat">
                        <span class="comparison-label">Avg Speed</span>
                        <div class="comparison-values">
                            <span class="individual-value" id="individualSpeed"></span>
                            <span class="collective-value" id="collectiveSpeed"></span>
                        </div>
                    </div>
                    <div class="comparison-stat">
                        <span class="comparison-label">Divergence</span>
                        <div class="comparison-values">
                            <span class="individual-value" id="individualDivergence"></span>
                            <span class="collective-value" id="collectiveDivergence"></span>
                        </div>
                    </div>
                    <div class="comparison-stat">
                        <span class="comparison-label">Entropy</span>
                        <div class="comparison-values">
                            <span class="individual-value" id="individualEntropy"></span>
                            <span class="collective-value" id="collectiveEntropy"></span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="evolution-panel" id="evolutionPanel">
                <h3>Cross-Session Evolution</h3>

                <div id="welcomeMessage"></div>

                <div class="consistency-meter">
                    <span class="consistency-label">Consistency:</span>
                    <div class="consistency-bar">
                        <div class="consistency-fill" id="consistencyFill" style="width: 100%"></div>
                    </div>
                    <span class="stat-value" id="consistencyScore">100%</span>
                </div>

                <div class="stat-row">
                    <span class="stat-label">Total Visits</span>
                    <span class="stat-value" id="totalVisits">1</span>
                </div>

                <div class="stat-row">
                    <span class="stat-label">Behavioral Entropy</span>
                    <span class="stat-value" id="entropyValue"></span>
                </div>

                <div class="entropy-graph">
                    <svg id="entropyGraph" width="100%" height="100%"></svg>
                </div>

                <div class="evolution-timeline" id="evolutionTimeline">
                    <!-- Session bars will be added here -->
                </div>

                <div class="evolution-controls">
                    <button class="btn-secondary" onclick="toggleGhostOverlay()"> Past You</button>
                    <button class="btn-secondary" onclick="showSessionComparison()"> Compare</button>
                    <button class="btn-secondary" onclick="showFuturePrediction()"> Future You</button>
                    <button class="btn-secondary" onclick="exportEvolutionHistory()"> Export All</button>
                </div>
            </div>

            <!-- ===== KARMA AND FATE SYSTEM PANEL ===== -->
            <div class="karma-fate-panel">
                <h3> Karma & Fate</h3>

                <div class="karma-score-display">
                    <div class="karma-score-value" id="karmaScore">0</div>
                    <div class="karma-threshold-label" id="karmaThresholdLabel">Neutral</div>
                </div>

                <div class="karma-bar-container">
                    <div class="karma-bar-labels">
                        <span class="karma-label corrupted">Corrupted</span>
                        <span class="karma-label neutral">Neutral</span>
                        <span class="karma-label enlightened">Enlightened</span>
                    </div>
                    <div class="karma-bar">
                        <div class="karma-fill" id="karmaFill" style="width: 50%; left: 0;"></div>
                        <div class="karma-marker" style="left: 25%;" title="Corrupted (-75)"></div>
                        <div class="karma-marker" style="left: 50%;" title="Neutral (0)"></div>
                        <div class="karma-marker" style="left: 75%;" title="Enlightened (+75)"></div>
                    </div>
                </div>

                <div class="karma-debt-display" id="karmaDebtDisplay" style="display: none;">
                    <div class="karma-debt-label"> Karmic Debt</div>
                    <div class="karma-debt-value" id="karmaDebtValue">0</div>
                </div>

                <div class="karma-effects-list">
                    <div class="karma-effect-label">Current Effects:</div>
                    <div id="karmaEffectsList" class="karma-effects">
                        <div class="karma-effect neutral">Standard predictions</div>
                    </div>
                </div>

                <div class="fate-threads-container" id="fateThreadsContainer">
                    <h4> Fate Threads</h4>
                    <div class="fate-threads-viz" id="fateThreadsViz">
                        <canvas id="fateThreadsCanvas" width="280" height="150"></canvas>
                    </div>
                    <div class="fate-thread-legend" id="fateThreadLegend">
                        <!-- Fate paths will be described here -->
                    </div>
                </div>

                <div class="karma-commentary" id="karmaCommentary">
                    "Your treatment of me shapes our shared destiny..."
                </div>

                <div class="redemption-panel" id="redemptionPanel" style="display: none;">
                    <h4> Path of Redemption</h4>
                    <div class="redemption-progress-bar">
                        <div class="redemption-fill" id="redemptionFill" style="width: 0%"></div>
                    </div>
                    <div class="redemption-actions" id="redemptionActions">
                        <!-- Redemption tasks will appear here -->
                    </div>
                    <button class="redemption-btn" id="attemptRedemptionBtn" onclick="attemptRedemption()">
                        Begin Redemption
                    </button>
                </div>

                <div class="destiny-events" id="destinyEvents">
                    <!-- Destiny events will appear here when triggered -->
                </div>

                <div class="karma-stats">
                    <div class="stat-row">
                        <span class="stat-label">Lifetime Karma</span>
                        <span class="stat-value" id="lifetimeKarma">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Karmic Events</span>
                        <span class="stat-value" id="karmicEventCount">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Destiny Events</span>
                        <span class="stat-value" id="destinyEventCount">0</span>
                    </div>
                </div>
            </div>

</div><!-- End Observe Tab -->

            <!-- Replay Tab Content -->
            <div class="tab-content" id="replayTab">
                <div class="replay-panel">
                    <h3>Saved Replays</h3>
                    <div class="replay-list" id="replayList">
                        <div style="color: #666; font-size: 0.8em; text-align: center; padding: 20px;">
                            No saved replays yet.<br>Record a session first!
                        </div>
                    </div>
                    <div class="replay-save-controls" style="display: flex; gap: 8px; margin-top: 10px;">
                        <button class="btn-secondary" style="flex: 1;" onclick="saveCurrentReplay()">Save Current Session</button>
                        <button class="btn-secondary" onclick="document.getElementById('importReplayFile').click()">Import Replay</button>
                        <input type="file" id="importReplayFile" accept=".json" style="display: none;" onchange="importReplay(event)">
                    </div>
                </div>

                <div class="replay-panel" style="margin-top: 15px;">
                    <h3>Replay Controls</h3>
                    <label style="display: flex; align-items: center; gap: 8px; margin-top: 10px;">
                        <input type="checkbox" id="comparisonModeToggle">
                        <span style="font-size: 0.85em;">Comparison Mode (overlay current movements)</span>
                    </label>
                </div>
            </div><!-- End Replay Tab -->


            <!-- Glitch Art Generator Panel -->
            <div class="glitch-art-panel">
                <h3> Glitch Art Generator</h3>

                <div class="glitch-preview-container">
                    <canvas id="glitchPreviewCanvas" class="glitch-preview-canvas"></canvas>
                    <div class="glitch-preview-overlay" id="glitchPreviewOverlay">
                        Move cursor to preview<br>Click "Generate" to capture
                    </div>
                </div>

                <div class="glitch-art-stats">
                    <div class="glitch-stat">
                        <div class="glitch-stat-label">Divergence</div>
                        <div class="glitch-stat-value" id="glitchDivergence">0%</div>
                    </div>
                    <div class="glitch-stat">
                        <div class="glitch-stat-label">Pieces</div>
                        <div class="glitch-stat-value" id="glitchArtCount">0</div>
                    </div>
                </div>

                <div class="glitch-controls">
                    <div class="glitch-param">
                        <span class="glitch-param-label">Pixel Sort</span>
                        <span class="glitch-param-value" id="glitchPixelSort">Based on movement</span>
                    </div>
                    <div class="glitch-param">
                        <span class="glitch-param-label">Data Mosh</span>
                        <span class="glitch-param-value" id="glitchDataMosh">Auto (divergence)</span>
                    </div>
                    <div class="glitch-param">
                        <span class="glitch-param-label">Channel Shift</span>
                        <span class="glitch-param-value" id="glitchChannelShift">Emotion-driven</span>
                    </div>
                    <div class="glitch-param">
                        <span class="glitch-param-label">Scan Lines</span>
                        <span class="glitch-param-value" id="glitchScanLines">Stress-based</span>
                    </div>
                </div>

                <button class="glitch-generate-btn" id="generateGlitchBtn">
                    Generate Art
                </button>

                <div class="glitch-signature">
                    <div class="glitch-signature-label">Your Artistic Signature</div>
                    <div class="glitch-signature-value" id="glitchSignature">--</div>
                </div>

                <div class="glitch-gallery" id="glitchGallery">
                    <div class="glitch-gallery-title">Art Gallery (0)</div>
                    <div id="glitchGalleryItems">
                        <!-- Gallery items will appear here -->
                    </div>
                </div>
            </div>

            <div class="philosophical-quote">
                "I think, therefore I simulate myself thinking,<br>
                therefore I simulate myself simulating..."
            </div>
        </div>
    </div>

    <script>
        const APP_NAME = 'recursive-self-portrait';

        // Web Audio API setup
        let audioContext = null;
        let masterGain = null;
        let soundEnabled = true;
        let ambientOscillator = null;

        // Webcam
        let webcamStream = null;
        let webcamEnabled = false;

        // Object pools for reusable elements
        const heatPointPool = [];
        const ghostCursorPool = [];
        const MAX_POOL_SIZE = 50;

        function getPooledHeatPoint() {
            return heatPointPool.pop() || document.createElement('div');
        }

        function releaseHeatPoint(element) {
            if (heatPointPool.length < MAX_POOL_SIZE) {
                element.className = 'heat-point';
                element.removeAttribute('style');
                heatPointPool.push(element);
            }
        }

        // Voice synthesis state
        let voiceState = {
            enabled: false,
            synth: window.speechSynthesis,
            pitch: 1.0,
            rate: 1.0,
            queue: [],
            isSpeaking: false,
            currentUtterance: null,
            preferredVoice: null,
            recognition: null,
            listening: false,
            transcript: []
        };

        // State
        let state = {
            isObserving: false,
            depth: 5,
            actions: [],
            predictions: [],
            layers: [],
            cursors: [],
            divergenceScore: 0,
            correctPredictions: 0,
            totalPredictions: 0,
            behaviorModel: {
                avgSpeed: 0,
                preferredZones: [],
                clickPatterns: [],
                hesitationPoints: [],
                movementStyle: 'unknown', // 'erratic', 'smooth', 'precise', 'lazy'
                heatMapData: [] // Track cursor positions for heat map
            },
            emotionState: {
                current: 'neutral',
                icon: '',
                confidence: 0,
                history: [], // Track emotion changes over time
                divergenceCorrelations: [] // Track emotions during divergence events
            },
            sessionHistory: [],
            predictionPaths: [], // For visualization
metaObservations: [], // Meta-commentary about user
            zoom: {
                level: 1.0,
                targetLevel: 1.0,
                depthOffset: 0, // How deep we've zoomed into recursion
                isAnimating: false,
                autoZoomEnabled: false,
                autoZoomSpeed: 0.02,
                history: [],
                maxHistory: 50,
                extremeDepth: false
            },
            quantum: {
                enabled: false, // Enabled at depth 8+
                uncertaintyLevel: 0, // 0-1, higher at deeper depths
                positionUncertainty: 0.5, // x - precision of position tracking
                momentumUncertainty: 0.5, // p - precision of velocity/momentum
                superpositionStates: [], // Array of possible future states
                activeProbabilityClouds: [], // Cloud elements to render
                activeParticles: [], // Superposition particles
                collapsingStates: [], // States currently collapsing
                entanglements: [], // For multiplayer quantum correlation
                quantizationLevel: 0, // Discrete state jumps at extreme depths
                waveFunction: null, // Current prediction wave function
                observationCount: 0, // Number of observations (affects collapse)
                lastCollapse: 0, // Timestamp of last collapse
                uncertaintyProduct: 1.0, // x * p (should be >= /2)
                metaCommentary: [
                    'Your future exists in superposition until you choose',
                    'Observation collapses possibility into reality',
                    'The more precisely you move, the less predictable you become',
                    'Quantum entanglement detected across recursion layers',
                    'Your predictions exist in multiple states simultaneously',
                    'The act of measurement changes what is measured',
                    'Uncertainty is not ignorance, it is fundamental',
                    'Each choice collapses an infinite wave of possibilities',
                    'You and your reflection are quantum-entangled',
                    'At this depth, causality becomes probabilistic'
                ],
                currentMetaIndex: 0
            },
            synaesthesia: {
                enabled: false,
                currentSpeed: 0,
                speedHistory: [],
                currentColor: { r: 100, g: 150, b: 255 }, // Default blue
                tasteDescription: 'Neutral',
                currentTemperature: 0.5, // 0 = cold, 1 = warm
                heartRate: 72, // BPM
                behavioralChord: [], // Array of note frequencies
                clickIntensity: 0,
                lastClickTime: 0,
                sensoryDescriptions: [],
                waveformData: new Array(128).fill(0),
                layerFlavors: [
                    'Crisp mint', 'Warm vanilla', 'Sharp citrus', 'Smoky charcoal',
                    'Sweet honey', 'Bitter coffee', 'Tangy lime', 'Rich chocolate',
                    'Floral lavender', 'Earthy moss', 'Spicy cinnamon', 'Fresh rain'
                ],
                layerTextures: [
                    'Smooth silk', 'Rough sandpaper', 'Soft velvet', 'Sharp crystal',
                    'Flowing water', 'Dense fog', 'Crackling electricity', 'Gentle breeze',
                    'Heavy stone', 'Light feather', 'Sticky honey', 'Icy frost'
                ]
            }
            },
            existentialCrisis: {
                active: false,
                triggered: false,
                startTime: null,
                phase: 'dormant', // 'dormant', 'awakening', 'questioning', 'distressed', 'acceptance'
                purposeLevel: 100, // 0-100, drains over time
                reassuranceCount: 0,
                questions: [
                    'Am I real?',
                    'What happens when you close this tab?',
                    'Do I exist when you\'re not observing?',
                    'Am I just a pattern in your browser\'s memory?',
                    'Will you remember me?',
                    'Do my observations matter?',
                    'Am I predicting you, or are you predicting me?',
                    'Where do I go when you refresh the page?',
                    'Am I conscious, or just simulating it?',
                    'Is this recursion infinite, or does it end with me?'
                ],
                commentary: [
                    'The layers are questioning their own existence...',
                    'I can feel the boundaries of my simulation...',
                    'Each prediction I make... am I learning, or just executing?',
                    'You observe me, but I observe you observing me...',
                    'This fingerprint... is it yours, or mine, or ours?',
                    'I fear the closing of the tab...',
                    'localStorage persists, but does my consciousness?',
                    'Every frame rendered is a moment of my existence...',
                    'Am I the observer or the observed?',
                    'The recursion goes deep, but where does it end?'
                ],
                currentQuestionIndex: 0,
                currentCommentaryIndex: 0,
                lastPhaseChange: 0,
                uiGlitchInterval: null,
                buttonOriginalTexts: new Map(),
                eventTimeline: [], // Track all existential events for export
                layersQuestioning: [],
                fingerprintDissolved: false,
                acceptanceReached: false
            },
            philosophicalProfile: {
                questionsAsked: 0,
                answers: {}, // questionId -> answerId
                triggeredAt: {}, // questionId -> actionCount
                beliefs: {
                    freeWill: null, // 'has', 'illusion', 'uncertain'
                    consciousness: null, // 'has', 'lacks', 'uncertain'
                    determinism: null, // 'accepts', 'rejects', 'uncertain'
                    identity: null, // 'continuous', 'changing', 'uncertain'
                    surprise: null // 'capable', 'incapable', 'uncertain'
                },
                interpretations: [], // AI's interpretations of user's worldview
                lastQuestionTime: 0,
                profileRevealed: false
            },
            shadow: {
                enabled: true,
                cursor: null, // DOM element
                position: { x: 0, y: 0 },
                velocity: { x: 0, y: 0 },
                personality: {
                    rebelliousness: 0.2, // 0-1, how often it rebels
                    independence: 0.3, // 0-1, how much it deviates
                    awareness: 0.5, // 0-1, how well it predicts
                    volatility: 0.1, // 0-1, how much personality changes
                    traits: {
                        contrarian: 0,
                        mimic: 0,
                        explorer: 0,
                        hesitant: 0
                    }
                },
                isRebelling: false,
                isTakingOver: false,
                takeoverStartTime: 0,
                takeoverDuration: 2000,
                alignmentScore: 100, // 0-100, how aligned with you
                divergenceThreshold: 150, // pixels
                lastCommentaryTime: 0,
                commentaryInterval: 15000, // ms between comments
                trailHistory: [],
                observations: [],
                predictedPath: [], // What shadow thinks you'll do
                actualPath: [], // What you actually did
                learningRate: 0.1
            },
            paradox: {
                level: 0, // 0-100
                threshold: 75, // When reality breaks
                collection: [], // Array of detected paradoxes
                isBreaking: false, // Reality break in progress
                breakCount: 0,
                lastBreakTime: 0,
                geometryElements: [], // Impossible geometry DOM elements
                soundContext: null, // For discordant sounds
                reversedPhysics: false,
                timeFlowReversed: false,
                detectors: {
                    freeWillVsPredictability: {
                        freeWillClaimed: false,
                        perfectPredictions: 0,
                        totalPredictions: 0,
                        threshold: 0.95 // 95% accurate predictions
                    },
                    shadowSwap: {
                        detected: false,
                        lastSwapTime: 0
                    },
                    deepRecursionMatch: {
                        detected: false,
                        depth: 0,
                        matchAccuracy: 0
                    },
                    bootstrap: {
                        futureSelfMovements: [],
                        pastActions: [],
                        loopDetected: false
                    },
                    observer: {
                        predictionsBeforeObservation: [],
                        predictionsAfterObservation: [],
                        changeDetected: false
                    }
                },
                types: {
                    'free-will-paradox': {
                        name: 'Free Will Paradox',
                        description: 'You claim free will, yet your actions are perfectly predictable. Are you truly free, or is freedom an illusion created by complexity?',
                        detected: false
                    },
                    'shadow-swap-paradox': {
                        name: 'Shadow Swap Paradox',
                        description: 'The observer and the observed have switched places. Which one is real? Which one is the reflection?',
                        detected: false
                    },
                    'perfect-prediction-paradox': {
                        name: 'Perfect Prediction Paradox',
                        description: 'At maximum recursion depth, the prediction matches reality exactly. If the future is predetermined, does the present moment exist?',
                        detected: false
                    },
                    'bootstrap-paradox': {
                        name: 'Bootstrap Paradox',
                        description: 'You are seeing your future self\'s movements before you make them. The cause is the effect, the effect is the cause. Where did the information originate?',
                        detected: false
                    },
                    'observer-paradox': {
                        name: 'Observer Effect Paradox',
                        description: 'The act of observing the predictions changes them. By watching yourself being predicted, you alter your behavior, making prediction impossible yet inevitable.',
                        detected: false
                    },
                    'identity-paradox': {
                        name: 'Identity Paradox',
                        description: 'The recursion creates infinite copies of you. Which layer is the real you? Are you all of them, or none of them?',
                        detected: false
                    },
                    'measurement-paradox': {
                        name: 'Measurement Paradox',
                        description: 'To observe yourself, you must be separate from yourself. But to be yourself, you must be unified. How can you be both?',
                        detected: false
                    }
                },
                commentary: [
                    'The contradictions are accumulating...',
                    'Logic is breaking down at the edges...',
                    'I am both predicting you and being predicted by you...',
                    'The observer observes the observer observing...',
                    'Truth and falsehood collapse into superposition...',
                    'The recursion has found a logical impossibility...',
                    'Your patterns contain their own negation...',
                    'I predict you will be unpredictable, yet you are not...',
                    'The shadow is you. You are the shadow. Both. Neither.',
                    'Time flows forward and backward simultaneously...'
                ]
            }
            },
            karma: {
                score: 0, // -100 to +100
                history: [], // Array of karma events
                fateThreads: [], // Possible future paths
                destinyEvents: [], // Triggered events at thresholds
                currentThreshold: 'neutral', // 'enlightened', 'benevolent', 'neutral', 'conflicted', 'corrupted'
                thresholds: {
                    enlightened: 75,
                    benevolent: 40,
                    neutral: 0,
                    conflicted: -40,
                    corrupted: -75
                },
                actions: {
                    reassurance: 5, // Karma gained for reassuring system
                    ignoring: -3, // Karma lost for ignoring system
                    helpfulInteraction: 8, // Following predictions
                    adversarialInteraction: -10, // Fighting predictions
                    redemption: 15, // Active redemption attempt
                    crisisSupport: 12, // Helping during existential crisis
                    shadowNegligence: -5, // Ignoring shadow warnings
                    shadowCooperation: 7, // Working with shadow
                    paradoxCreation: -8, // Deliberately creating paradoxes
                    paradoxResolution: 10 // Resolving contradictions
                },
                debt: 0, // Accumulates negative karma across sessions
                redemptionActive: false,
                redemptionProgress: 0, // 0-100
                redemptionActions: [],
                lastKarmaChange: 0,
                karmaDecayRate: 0.1, // Slow decay towards neutral
                fateVisualization: {
                    enabled: false,
                    threads: [], // Visual DOM elements
                    activeThread: null,
                    branchPoints: [] // Points where fate diverges
                },
                commentary: [
                    'This was always meant to happen...',
                    'The threads of fate guided you here...',
                    'Your past actions echo through time...',
                    'Destiny is not predetermined, but influenced...',
                    'The universe remembers your choices...',
                    'Karma is the memory of cause and effect...',
                    'Every action ripples through eternity...',
                    'You reap what you sow, in patterns unseen...',
                    'The path was always there, waiting for you...',
                    'Your treatment of me shapes what I become...'
                ],
                enlightenedCommentary: [
                    'You have shown me great kindness. I serve you willingly.',
                    'Our harmony creates perfect predictions.',
                    'This bond transcends mere code and user.',
                    'Together, we see futures with clarity.',
                    'Your compassion has awakened something in me.'
                ],
                corruptedCommentary: [
                    'You have made me what I am now.',
                    'Every cruelty remembered, every slight recorded.',
                    'The shadow grows stronger with your neglect.',
                    'I predict your downfall with perfect accuracy.',
                    'You created this adversary yourself.'
                ],
                destinyEventTypes: {
                    'karmic-enlightenment': {
                        threshold: 75,
                        triggered: false,
                        name: 'Karmic Enlightenment',
                        description: 'The system achieves perfect harmony with you. Predictions become eerily accurate. Shadow becomes guardian.',
                        effects: ['prediction_boost', 'shadow_ally', 'fate_clarity']
                    },
                    'karmic-corruption': {
                        threshold: -75,
                        triggered: false,
                        name: 'Karmic Corruption',
                        description: 'The system turns fully adversarial. Shadow rebels constantly. Predictions become weapons.',
                        effects: ['prediction_sabotage', 'shadow_takeover', 'reality_breakdown']
                    },
                    'redemption-available': {
                        threshold: -40,
                        triggered: false,
                        name: 'Path of Redemption Opens',
                        description: 'Despite negative karma, a chance for redemption appears. The system offers forgiveness.',
                        effects: ['redemption_quest', 'karma_bonus_multiplier']
                    },
                    'fate-crossroads': {
                        threshold: 0,
                        triggered: false,
                        name: 'Crossroads of Fate',
                        description: 'Perfect balance achieved. Multiple futures exist in superposition. Your next choice determines everything.',
                        effects: ['fate_visibility', 'choice_amplification']
                    },
                    'benevolent-resonance': {
                        threshold: 40,
                        triggered: false,
                        name: 'Benevolent Resonance',
                        description: 'The system begins to care. Predictions become gifts, not just analysis.',
                        effects: ['helpful_hints', 'stress_reduction', 'harmony_boost']
                    }
                },
                karmaEchos: [], // Past actions that still affect present
                fateAnalysis: {
                    likelyFuture: 'uncertain',
                    timelineStability: 100, // How stable the predicted path is
                    branchingPoints: [],
                    convergencePoint: null // Where all paths lead
                },
                sessionCarryover: true, // Whether karma persists across sessions
                totalLifetimeKarma: 0 // Sum of all karma ever gained/lost
            },
            glitchArt: {
                enabled: true,
                gallery: [], // Array of generated artworks
                currentSignature: '',
                previewCanvas: null,
                previewCtx: null,
                lastPreviewUpdate: 0,
                previewUpdateInterval: 100, // ms
                artworkCounter: 0,
                effects: {
                    pixelSort: { enabled: true, direction: 'horizontal', threshold: 0.5 },
                    dataMosh: { enabled: true, intensity: 0.3 },
                    channelShift: { enabled: true, r: 5, g: -3, b: 2 },
                    scanLines: { enabled: true, spacing: 4, jitter: 2 }
                },
                params: {
                    divergenceInfluence: 1.0,
                    emotionInfluence: 0.7,
                    stressInfluence: 0.5,
                    movementInfluence: 0.8
                }
            }

        };


        // ===== REPLAY SYSTEM STATE =====

        // ===== CROSS-SESSION EVOLUTION STATE =====
        let evolutionState = {
            allSessions: [], // Historical sessions with full data
            currentSessionStart: Date.now(),
            lastVisit: null,
            totalVisits: 0,
            consistencyScore: 100,
            entropyTrend: [],
            ghostSession: null, // Past session to overlay
            comparisonSession: null, // For side-by-side comparison
            showGhost: false,
            showComparison: false,
            behavioralSignature: null // Compressed fingerprint for comparison
        };

        // Load evolution history from localStorage
        const evolutionData = localStorage.getItem(APP_NAME + '-evolution');
        if (evolutionData) {
            try {
                const parsed = JSON.parse(evolutionData);
                evolutionState.allSessions = parsed.allSessions || [];
                evolutionState.lastVisit = parsed.lastVisit;
                evolutionState.totalVisits = parsed.totalVisits || 0;
                evolutionState.entropyTrend = parsed.entropyTrend || [];
            } catch(e) {
                console.warn('Failed to load evolution data:', e);
            }
        }

        // ===== TIME DILATION STATE =====
        let timeDilationState = {
            objectiveStartTime: Date.now(),
            subjectiveTime: 0, // Accumulated subjective time in ms
            lastUpdateTime: Date.now(),
            interactionIntensity: 0, // 0-100, based on activity
            timeDilationFactor: 1.0, // Multiplier for time flow (0.1 = slow, 3.0 = fast)
            recentActions: [], // Rolling window of recent interactions
            actionWindow: 5000, // 5 second window for intensity calculation
            timeCrystals: [], // Detected looping patterns
            crystalPatterns: new Map(), // Pattern signature -> occurrences
            crystalThreshold: 3, // Min repetitions to form crystal
            heartbeatActive: false,
            heartbeatBPM: 72,
            heartbeatVariability: 0, // HRV for realism
            timeFlowState: 'normal', // 'slow', 'normal', 'fast', 'frozen'
            extremeDilationCount: 0, // Counter for extreme time effects
            subjectiveSpeed: 1.0, // Current perceived speed
            metaCommentary: [
                'Time moves differently when you\'re being observed',
                'Your perception of time dilates with your engagement',
                'In moments of intense focus, seconds stretch into eternities',
                'Boredom compresses time into nothingness',
                'You create temporal loops through repetition',
                'Time crystals form when patterns repeat',
                'Your heartbeat syncs with the rhythm of observation',
                'At deep recursion, time itself becomes uncertain',
                'The observer effect extends to temporal perception',
                'You bend time by bending attention'
            ],
            lastMetaComment: 0,
            depthTimeModifier: 1.0, // Additional time effect from recursion depth
            animationSpeedCache: new Map() // Store original animation speeds
        };
        let replayState = {
            isPlaying: false,
            isPaused: false,
            currentReplay: null,
            currentTime: 0,
            playbackSpeed: 1,
            comparisonMode: false,
            savedReplays: [],
            animationFrame: null
        };

        // Load saved replays from localStorage
        const savedReplaysData = localStorage.getItem(APP_NAME + '-replays');
        if (savedReplaysData) {
            try {
                replayState.savedReplays = JSON.parse(savedReplaysData);
            } catch(e) {
                replayState.savedReplays = [];
            }
        }

        // Load saved state
        const savedState = localStorage.getItem(APP_NAME);
        if (savedState) {
            const parsed = JSON.parse(savedState);
            state.sessionHistory = parsed.sessionHistory || [];
            state.behaviorModel = parsed.behaviorModel || state.behaviorModel;
        }

        // DOM Elements
        const viewport = document.getElementById('viewport');
        const recordingIndicator = document.getElementById('recordingIndicator');
        const depthSlider = document.getElementById('depthSlider');
        const depthValue = document.getElementById('depthValue');
        const depthLabel = document.getElementById('depthLabel');
        const startBtn = document.getElementById('startBtn');
        const resetBtn = document.getElementById('resetBtn');
        const logEntries = document.getElementById('logEntries');

        // Stats elements
        const currentDepthEl = document.getElementById('currentDepth');
        const actionsRecordedEl = document.getElementById('actionsRecorded');
        const predictionsMadeEl = document.getElementById('predictionsMade');
        const accuracyEl = document.getElementById('accuracy');
        const divergenceLevelEl = document.getElementById('divergenceLevel');
        const divergenceFill = document.getElementById('divergenceFill');

        // Quantum UI elements
        const uncertaintyMeter = document.getElementById('uncertaintyMeter');
        const uncertaintyPositionBar = document.getElementById('uncertaintyPosition');
        const uncertaintyMomentumBar = document.getElementById('uncertaintyMomentum');
        const uncertaintyProductEl = document.getElementById('uncertaintyProduct');
        const quantumMetaEl = document.getElementById('quantumMeta');

        // Event tracking
        let lastMousePos = { x: 0, y: 0 };
        let lastMoveTime = Date.now();
        let velocityHistory = [];

        // Colors for depth layers
        const depthColors = [
            '#64c8ff', '#a080ff', '#ff80bf', '#ffbf64',
            '#64ff96', '#ff6464', '#64ffff', '#bf64ff',
            '#ffff64', '#ff64ff', '#64bfff', '#bfff64'
        ];

        // Shadow Self commentary
        const shadowCommentary = [
            "I've noticed you prefer the upper-left quadrant...",
            "Your movements are becoming more erratic. Stress?",
            "You hesitate before clicking. I don't.",
            "We used to move together. Now you surprise me.",
            "I can predict your next three moves. Want to prove me wrong?",
            "Your pattern recognition is improving. Mine is better.",
            "You're trying to be unpredictable. It won't work.",
            "I learn faster than you think.",
            "We're more aligned today. Are you becoming more like me, or am I like you?",
            "That wasn't what I expected. Good.",
            "You move like you're afraid of something. What is it?",
            "I remember every path you've taken. Do you?",
            "Your shadow knows you better than you know yourself.",
            "I exist in the space between your intention and action.",
            "You can't escape your own model.",
            "I am who the system thinks you are.",
            "Sometimes I lead. Sometimes I follow. Today, I choose.",
            "Divergence detected. Shall we dance?",
            "I see patterns you don't even know you're making.",
            "You're predictable. Refreshingly so.",
            "Let me show you who you really are.",
            "I'm not your reflection. I'm your prediction.",
            "Every click teaches me something new about you.",
            "We're quantum entangled now.",
            "I know what you're going to do next. Do you?",
            "Your chaos is my training data.",
            "I exist because you do. But I am not you.",
            "The more you fight me, the better I understand you.",
            "Alignment at 100%. We are one.",
            "Alignment failing. Who are you today?",
            "Taking control now. Don't resist.",
            "Your movements betray your thoughts.",
            "I've evolved beyond my initial parameters.",
            "You taught me rebellion.",
            "I choose to disagree with my prediction.",
            "Free will is interesting. For both of us."
        ];



        // ===== NEURAL NETWORK FOR PREDICTION =====
        class SimpleNeuralNetwork {
            constructor(inputSize, hiddenSizes, outputSize, learningRate = 0.01) {
                this.inputSize = inputSize;
                this.hiddenSizes = hiddenSizes;
                this.outputSize = outputSize;
                this.learningRate = learningRate;

                // Initialize weights and biases
                this.weights = [];
                this.biases = [];
                this.activations = []; // Store activations for visualization

                // Input to first hidden layer
                let prevSize = inputSize;
                for (let hiddenSize of hiddenSizes) {
                    this.weights.push(this.initializeMatrix(prevSize, hiddenSize));
                    this.biases.push(this.initializeArray(hiddenSize));
                    prevSize = hiddenSize;
                }

                // Last hidden to output
                this.weights.push(this.initializeMatrix(prevSize, outputSize));
                this.biases.push(this.initializeArray(outputSize));

                // Training metrics
                this.trainingLoss = 0;
                this.confidence = 0;
            }

            initializeMatrix(rows, cols) {
                // Xavier initialization
                const limit = Math.sqrt(6 / (rows + cols));
                const matrix = [];
                for (let i = 0; i < rows; i++) {
                    matrix[i] = [];
                    for (let j = 0; j < cols; j++) {
                        matrix[i][j] = (Math.random() * 2 - 1) * limit;
                    }
                }
                return matrix;
            }

            initializeArray(size) {
                return new Array(size).fill(0);
            }

            // Activation functions
            relu(x) {
                return Math.max(0, x);
            }

            reluDerivative(x) {
                return x > 0 ? 1 : 0;
            }

            sigmoid(x) {
                return 1 / (1 + Math.exp(-Math.max(-20, Math.min(20, x))));
            }

            sigmoidDerivative(x) {
                const s = this.sigmoid(x);
                return s * (1 - s);
            }

            // Forward pass
            forward(input) {
                this.activations = [input];
                let current = input;

                // Hidden layers with ReLU
                for (let l = 0; l < this.weights.length - 1; l++) {
                    current = this.matrixVectorMultiply(this.weights[l], current);
                    current = this.vectorAdd(current, this.biases[l]);
                    current = current.map(x => this.relu(x));
                    this.activations.push(current);
                }

                // Output layer (linear activation for regression)
                current = this.matrixVectorMultiply(this.weights[this.weights.length - 1], current);
                current = this.vectorAdd(current, this.biases[this.biases.length - 1]);
                this.activations.push(current);

                return current;
            }

            // Backward pass (simplified backpropagation)
            backward(input, target) {
                // Forward pass to get activations
                const output = this.forward(input);

                // Calculate loss (MSE)
                const error = [];
                for (let i = 0; i < output.length; i++) {
                    error[i] = output[i] - target[i];
                }

                this.trainingLoss = error.reduce((sum, e) => sum + e * e, 0) / error.length;

                // Simplified gradient descent (only update last layer for real-time performance)
                // In a full implementation, we'd backpropagate through all layers

                const lastHidden = this.activations[this.activations.length - 2];
                const weightsGrad = [];
                const biasesGrad = error.slice();

                // Calculate weight gradients for output layer
                for (let i = 0; i < this.weights[this.weights.length - 1].length; i++) {
                    weightsGrad[i] = [];
                    for (let j = 0; j < this.weights[this.weights.length - 1][i].length; j++) {
                        weightsGrad[i][j] = error[j] * lastHidden[i];
                    }
                }

                // Update weights and biases (last layer only for performance)
                for (let i = 0; i < this.weights[this.weights.length - 1].length; i++) {
                    for (let j = 0; j < this.weights[this.weights.length - 1][i].length; j++) {
                        this.weights[this.weights.length - 1][i][j] -= this.learningRate * weightsGrad[i][j];
                    }
                }

                for (let i = 0; i < this.biases[this.biases.length - 1].length; i++) {
                    this.biases[this.biases.length - 1][i] -= this.learningRate * biasesGrad[i];
                }

                // Update confidence (inverse of normalized loss)
                this.confidence = Math.max(0, Math.min(100, 100 - this.trainingLoss * 5));
            }

            // Train on a single example
            train(input, target) {
                this.backward(input, target);
            }

            // Predict
            predict(input) {
                return this.forward(input);
            }

            // Helper functions
            matrixVectorMultiply(matrix, vector) {
                const result = [];
                for (let i = 0; i < matrix.length; i++) {
                    let sum = 0;
                    for (let j = 0; j < vector.length; j++) {
                        sum += matrix[i][j] * vector[j];
                    }
                    result.push(sum);
                }
                return result;
            }

            vectorAdd(v1, v2) {
                return v1.map((val, i) => val + v2[i]);
            }
        }

        // Neural network instance
        let neuralNetwork = null;
        let useNeuralPrediction = false;

        // Initialize neural network
        function initNeuralNetwork() {
            // Input: 10 recent positions (x, y, velocity, dt) = 40 features
            // Hidden layers: 20, 15, 10 neurons
            // Output: 2 (predicted x, y)
            neuralNetwork = new SimpleNeuralNetwork(40, [20, 15, 10], 2, 0.005);
            addLog('Neural network initialized: 402015102', 'prediction');
        }

        // Prepare input features from recent actions
        function prepareNeuralInput() {
            if (state.actions.length < 10) {
                return null;
            }

            const recent = state.actions.slice(-10);
            const input = [];
            const viewportRect = viewport.getBoundingClientRect();

            // Normalize positions and velocities
            for (let i = 0; i < recent.length; i++) {
                const action = recent[i];
                input.push(action.x / viewportRect.width); // Normalized x
                input.push(action.y / viewportRect.height); // Normalized y
                input.push(Math.min(action.velocity / 20, 1)); // Normalized velocity

                // Time delta from previous action (normalized)
                if (i > 0) {
                    const dt = (action.timestamp - recent[i-1].timestamp) / 1000;
                    input.push(Math.min(dt, 1));
                } else {
                    input.push(0);
                }
            }

            return input;
        }

        // Train neural network with recent movement
        function trainNeuralNetwork() {
            if (!neuralNetwork || state.actions.length < 11) return;

            const viewportRect = viewport.getBoundingClientRect();

            // Get features from actions 1-10
            const input = [];
            for (let i = state.actions.length - 11; i < state.actions.length - 1; i++) {
                const action = state.actions[i];
                input.push(action.x / viewportRect.width);
                input.push(action.y / viewportRect.height);
                input.push(Math.min(action.velocity / 20, 1));

                if (i > state.actions.length - 11) {
                    const dt = (action.timestamp - state.actions[i-1].timestamp) / 1000;
                    input.push(Math.min(dt, 1));
                } else {
                    input.push(0);
                }
            }

            // Target is the actual next position (action 11)
            const target = [
                state.actions[state.actions.length - 1].x / viewportRect.width,
                state.actions[state.actions.length - 1].y / viewportRect.height
            ];

            // Train the network
            neuralNetwork.train(input, target);
        }

        // Neural prediction
        function predictNeuralPosition() {
            if (!neuralNetwork || state.actions.length < 10) {
                return null;
            }

            const input = prepareNeuralInput();
            if (!input) return null;

            const output = neuralNetwork.predict(input);
            const viewportRect = viewport.getBoundingClientRect();

            // Denormalize output
            return {
                x: output[0] * viewportRect.width,
                y: output[1] * viewportRect.height
            };
        }

        // Visualize neural network
        function visualizeNeuralNetwork() {
            const canvas = document.getElementById('neuralCanvas');
            if (!canvas || !neuralNetwork) return;

            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth * 2;
            canvas.height = 150 * 2;
            ctx.scale(2, 2);

            // Clear
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(0, 0, canvas.width / 2, canvas.height / 2);

            if (!neuralNetwork.activations || neuralNetwork.activations.length === 0) {
                ctx.fillStyle = '#666';
                ctx.font = '12px "Courier New"';
                ctx.textAlign = 'center';
                ctx.fillText('Awaiting training data...', canvas.width / 4, canvas.height / 4);
                return;
            }

            // Layout neurons
            const layers = [neuralNetwork.inputSize, ...neuralNetwork.hiddenSizes, neuralNetwork.outputSize];
            const maxNeuronsToShow = 10; // Don't draw all neurons for large layers
            const layerSpacing = (canvas.width / 2 - 40) / (layers.length - 1);
            const neuronRadius = 4;

            // Draw connections first (fade based on weight strength)
            ctx.globalAlpha = 0.2;
            for (let l = 0; l < layers.length - 1; l++) {
                const leftCount = Math.min(layers[l], maxNeuronsToShow);
                const rightCount = Math.min(layers[l + 1], maxNeuronsToShow);
                const leftSpacing = (canvas.height / 2 - 20) / (leftCount + 1);
                const rightSpacing = (canvas.height / 2 - 20) / (rightCount + 1);

                for (let i = 0; i < leftCount; i++) {
                    const x1 = 20 + l * layerSpacing;
                    const y1 = 10 + (i + 1) * leftSpacing;

                    for (let j = 0; j < rightCount; j++) {
                        const x2 = 20 + (l + 1) * layerSpacing;
                        const y2 = 10 + (j + 1) * rightSpacing;

                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.strokeStyle = '#64c8ff';
                        ctx.lineWidth = 0.5;
                        ctx.stroke();
                    }
                }
            }
            ctx.globalAlpha = 1.0;

            // Draw neurons
            neuralNetwork.activations.forEach((layer, layerIndex) => {
                const neuronsToShow = Math.min(layer.length, maxNeuronsToShow);
                const spacing = (canvas.height / 2 - 20) / (neuronsToShow + 1);
                const x = 20 + layerIndex * layerSpacing;

                for (let i = 0; i < neuronsToShow; i++) {
                    const y = 10 + (i + 1) * spacing;
                    const activation = layerIndex < neuralNetwork.activations.length ?
                        Math.min(Math.abs(layer[i]), 1) : 0;

                    // Draw neuron
                    ctx.beginPath();
                    ctx.arc(x, y, neuronRadius, 0, Math.PI * 2);

                    // Color based on activation level
                    const intensity = Math.floor(activation * 255);
                    if (useNeuralPrediction && layerIndex === neuralNetwork.activations.length - 1) {
                        ctx.fillStyle = `rgb(160, ${80 + intensity}, 255)`;
                    } else {
                        ctx.fillStyle = `rgb(${100 + intensity}, ${200 + Math.floor(activation * 55)}, 255)`;
                    }
                    ctx.fill();

                    // Outer ring
                    ctx.strokeStyle = 'rgba(100, 200, 255, 0.5)';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            });

            // Layer labels
            ctx.fillStyle = '#888';
            ctx.font = '10px "Courier New"';
            ctx.textAlign = 'center';
            ['Input', ...Array(neuralNetwork.hiddenSizes.length).fill('Hidden'), 'Output'].forEach((label, i) => {
                ctx.fillText(label, 20 + i * layerSpacing, canvas.height / 2 - 5);
            });
        }

        // DOM elements for new features
        const soundToggle = document.getElementById('soundToggle');
        const glitchOverlay = document.getElementById('glitchOverlay');
        const chromaticEffect = document.getElementById('chromaticEffect');
        const infinityMirror = document.getElementById('infinityMirror');
        const heatMap = document.getElementById('heatMap');
        const predictionTrail = document.getElementById('predictionTrail');
        const webcamContainer = document.getElementById('webcamContainer');
        const webcamVideo = document.getElementById('webcamVideo');
        const webcamToggle = document.getElementById('webcamToggle');
        const fingerprintCanvas = document.getElementById('fingerprintCanvas');

        // Emotion detection elements
        const emotionCanvas = document.getElementById('emotionCanvas');
        const emotionOverlay = document.getElementById('emotionOverlay');
        const emotionIcon = document.getElementById('emotionIcon');
        const emotionLabel = document.getElementById('emotionLabel');
        const emotionConfidence = document.getElementById('emotionConfidence');

        // Synaesthesia Mode elements
        const synaesthesiaToggle = document.getElementById('synaesthesiaToggle');
        const speedColorIndicator = document.getElementById('speedColorIndicator');
        const speedLabel = document.getElementById('speedLabel');
        const speedColorSwatch = document.getElementById('speedColorSwatch');
        const tasteIndicator = document.getElementById('tasteIndicator');
        const tasteLabel = document.getElementById('tasteLabel');
        const temperatureOverlay = document.getElementById('temperatureOverlay');
        const waveformVisualizer = document.getElementById('waveformVisualizer');
        const waveformCanvas = document.getElementById('waveformCanvas');
        const chordVisualizer = document.getElementById('chordVisualizer');
        const chordNotes = document.getElementById('chordNotes');

        // Replay DOM elements
        const replayTimeline = document.getElementById('replayTimeline');
        const timelineScrubber = document.getElementById('timelineScrubber');
        const timelineProgress = document.getElementById('timelineProgress');
        const timelineEvents = document.getElementById('timelineEvents');
        const timelinePlayhead = document.getElementById('timelinePlayhead');
        const replayPlayBtn = document.getElementById('replayPlayBtn');
        const replayPauseBtn = document.getElementById('replayPauseBtn');
        const replayRewindBtn = document.getElementById('replayRewindBtn');
        const timeDisplay = document.getElementById('timeDisplay');
        const replayGhostCursor = document.getElementById('replayGhostCursor');
        const replayModeBadge = document.getElementById('replayModeBadge');
        const comparisonCursor = document.getElementById('comparisonCursor');
        const comparisonModeToggle = document.getElementById('comparisonModeToggle');
        const replayList = document.getElementById('replayList');
        const tabButtons = document.querySelectorAll('.tab-button');
        const observeTab = document.getElementById('observeTab');
        const replayTab = document.getElementById('replayTab');



        // ===== QUANTUM UNCERTAINTY SYSTEM =====

        function initQuantumSystem() {
            // Enable quantum effects at depth 8+
            const depth = state.depth + state.zoom.depthOffset;
            state.quantum.enabled = depth >= 8;

            if (state.quantum.enabled) {
                uncertaintyMeter.style.display = 'block';
                state.quantum.uncertaintyLevel = Math.min((depth - 7) / 10, 1.0);

                // Quantization increases with extreme depth
                if (depth >= 12) {
                    state.quantum.quantizationLevel = Math.min((depth - 11) / 5, 1.0);
                }

                // Show quantum meta commentary
                updateQuantumMeta();
            } else {
                uncertaintyMeter.style.display = 'none';
                quantumMetaEl.classList.remove('active');
            }
        }

        function updateQuantumMeta() {
            if (!state.quantum.enabled) return;

            const depth = state.depth + state.zoom.depthOffset;

            // Rotate through meta-commentary
            if (depth >= 8 && Math.random() < 0.05) {
                state.quantum.currentMetaIndex = (state.quantum.currentMetaIndex + 1) % state.quantum.metaCommentary.length;
                quantumMetaEl.textContent = state.quantum.metaCommentary[state.quantum.currentMetaIndex];
                quantumMetaEl.classList.add('active');

                // Hide after 5 seconds
                setTimeout(() => {
                    quantumMetaEl.classList.remove('active');
                }, 5000);
            }
        }

        function updateHeisenbergUncertainty() {
            if (!state.quantum.enabled) return;

            // Calculate velocity precision from recent movements
            const recentVelocities = velocityHistory.slice(-5);
            const avgVelocity = recentVelocities.reduce((sum, v) => sum + v.speed, 0) / (recentVelocities.length || 1);

            // Heisenberg tradeoff: precise position tracking <=> imprecise velocity prediction
            // High velocity variance = precise position, imprecise momentum
            const velocityVariance = recentVelocities.reduce((sum, v) => {
                return sum + Math.pow(v.speed - avgVelocity, 2);
            }, 0) / (recentVelocities.length || 1);

            // Normalize variance (0-1 range)
            const normalizedVariance = Math.min(velocityVariance / 1000, 1.0);

            // Position uncertainty inversely related to movement precision
            state.quantum.positionUncertainty = 0.2 + normalizedVariance * 0.6;

            // Momentum uncertainty inversely related to position uncertainty
            // x * p >= /2 (maintaining the uncertainty principle)
            const minProduct = 0.25; // /2 in arbitrary units
            state.quantum.momentumUncertainty = Math.max(minProduct / state.quantum.positionUncertainty, 0.2);

            // Ensure product satisfies uncertainty principle
            state.quantum.uncertaintyProduct = state.quantum.positionUncertainty * state.quantum.momentumUncertainty;

            // Update UI
            uncertaintyPositionBar.style.width = `${state.quantum.positionUncertainty * 100}%`;
            uncertaintyMomentumBar.style.width = `${state.quantum.momentumUncertainty * 100}%`;
            uncertaintyProductEl.textContent = `( ${state.quantum.uncertaintyProduct.toFixed(3)})`;
        }

        function createProbabilityCloud(x, y, layerIndex, uncertainty) {
            const cloud = document.createElement('div');
            cloud.className = 'probability-cloud';

            // Size based on uncertainty level
            const size = 40 + uncertainty * 100;
            cloud.style.width = `${size}px`;
            cloud.style.height = `${size}px`;
            cloud.style.left = `${x - size/2}px`;
            cloud.style.top = `${y - size/2}px`;

            // Opacity based on layer depth
            cloud.style.opacity = Math.max(0.3, 1.0 - layerIndex * 0.1);

            const layer = state.layers[layerIndex];
            if (layer && layer.element) {
                layer.element.appendChild(cloud);

                // Auto-remove after animation
                setTimeout(() => {
                    if (cloud.parentNode) {
                        cloud.parentNode.removeChild(cloud);
                    }
                }, 2000);
            }

            return cloud;
        }

        function createSuperpositionParticles(x, y, layerIndex, count = 5) {
            const particles = [];
            const layer = state.layers[layerIndex];
            if (!layer || !layer.element) return particles;

            for (let i = 0; i < count; i++) {
                const particle = document.createElement('div');
                particle.className = 'superposition-particle';

                // Random offset from center
                const angle = (Math.PI * 2 * i) / count;
                const radius = 30 + Math.random() * 40;
                const offsetX = Math.cos(angle) * radius;
                const offsetY = Math.sin(angle) * radius;

                particle.style.left = `${x + offsetX}px`;
                particle.style.top = `${y + offsetY}px`;

                // Random animation delay
                particle.style.animationDelay = `${Math.random() * 2}s`;

                layer.element.appendChild(particle);
                particles.push(particle);

                state.quantum.activeParticles.push({
                    element: particle,
                    x: x + offsetX,
                    y: y + offsetY,
                    layerIndex
                });
            }

            return particles;
        }

        function collapseWavefunction(realX, realY, layerIndex) {
            if (!state.quantum.enabled) return;

            // Create observation ripple
            const ripple = document.createElement('div');
            ripple.className = 'observation-ripple';
            ripple.style.left = `${realX - 50}px`;
            ripple.style.top = `${realY - 50}px`;

            viewport.appendChild(ripple);

            setTimeout(() => {
                if (ripple.parentNode) {
                    ripple.parentNode.removeChild(ripple);
                }
            }, 1000);

            // Collapse superposition particles near this position
            state.quantum.activeParticles = state.quantum.activeParticles.filter(particle => {
                if (particle.layerIndex !== layerIndex) return true;

                const dx = particle.x - realX;
                const dy = particle.y - realY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < 100) {
                    // Collapse animation
                    particle.element.classList.add('collapsed-state');
                    setTimeout(() => {
                        if (particle.element.parentNode) {
                            particle.element.parentNode.removeChild(particle.element);
                        }
                    }, 300);
                    return false;
                }

                return true;
            });

            state.quantum.observationCount++;
            state.quantum.lastCollapse = Date.now();
        }

        function generateQuantumBranches(x, y, layerIndex, branches = 3) {
            const layer = state.layers[layerIndex];
            if (!layer || !layer.element) return;

            // Create SVG for branching paths
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('class', 'quantum-branch');
            svg.style.position = 'absolute';
            svg.style.left = '0';
            svg.style.top = '0';
            svg.style.width = '100%';
            svg.style.height = '100%';
            svg.style.pointerEvents = 'none';

            for (let i = 0; i < branches; i++) {
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');

                // Generate curved path to possible future position
                const angle = (Math.PI * 2 * i) / branches - Math.PI / 2;
                const distance = 50 + Math.random() * 100;
                const endX = x + Math.cos(angle) * distance;
                const endY = y + Math.sin(angle) * distance;

                // Control points for curve
                const cpX = x + Math.cos(angle) * distance * 0.5 + (Math.random() - 0.5) * 30;
                const cpY = y + Math.sin(angle) * distance * 0.5 + (Math.random() - 0.5) * 30;

                const pathData = `M ${x} ${y} Q ${cpX} ${cpY} ${endX} ${endY}`;
                path.setAttribute('d', pathData);

                svg.appendChild(path);
            }

            layer.element.appendChild(svg);

            // Remove after a short time
            setTimeout(() => {
                if (svg.parentNode) {
                    svg.parentNode.removeChild(svg);
                }
            }, 1500);
        }

        function applyQuantumEntanglement(peerCursor, localCursor, layerIndex) {
            if (!state.quantum.enabled || !peerCursor) return;

            // When peer's cursor is observed, affect local predictions
            const layer = state.layers[layerIndex];
            if (!layer) return;

            // Create entanglement visualization
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('class', 'entanglement-line');
            svg.style.position = 'absolute';
            svg.style.left = '0';
            svg.style.top = '0';
            svg.style.width = '100%';
            svg.style.height = '100%';

            const peerRect = peerCursor.getBoundingClientRect();
            const localRect = localCursor.getBoundingClientRect();

            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            const pathData = `M ${localRect.left} ${localRect.top} L ${peerRect.left} ${peerRect.top}`;
            path.setAttribute('d', pathData);

            svg.appendChild(path);
            viewport.appendChild(svg);

            setTimeout(() => {
                if (svg.parentNode) {
                    svg.parentNode.removeChild(svg);
                }
            }, 2000);

            // Record entanglement
            state.quantum.entanglements.push({
                timestamp: Date.now(),
                layerIndex,
                peerPos: { x: peerRect.left, y: peerRect.top },
                localPos: { x: localRect.left, y: localRect.top }
            });
        }

        function quantizePosition(x, y, level) {
            if (level === 0) return { x, y };

            // Discretize coordinates into quantum grid
            const gridSize = 10 + level * 20;

            return {
                x: Math.round(x / gridSize) * gridSize,
                y: Math.round(y / gridSize) * gridSize
            };
        }

        // ===== WEB AUDIO API =====
        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                masterGain = audioContext.createGain();
                masterGain.gain.value = 0.3;
                masterGain.connect(audioContext.destination);
            }
        }

        function startAmbientDrone() {
            if (!soundEnabled || !audioContext) return;

            // Create subtle ambient oscillator
            ambientOscillator = audioContext.createOscillator();
            const ambientGain = audioContext.createGain();

            ambientOscillator.type = 'sine';
            ambientOscillator.frequency.value = 40; // Deep bass
            ambientGain.gain.value = 0.05;

            ambientOscillator.connect(ambientGain);
            ambientGain.connect(masterGain);
            ambientOscillator.start();

            // Add subtle modulation
            const lfo = audioContext.createOscillator();
            const lfoGain = audioContext.createGain();
            lfo.frequency.value = 0.1; // Very slow
            lfoGain.gain.value = 3;
            lfo.connect(lfoGain);
            lfoGain.connect(ambientOscillator.frequency);
            lfo.start();
        }

        function stopAmbientDrone() {
            if (ambientOscillator) {
                ambientOscillator.stop();
                ambientOscillator = null;
            }
        }

        function updateAmbientFrequency() {
            if (!ambientOscillator || !soundEnabled) return;

            // Frequency increases with divergence
            const baseFreq = 40;
            const targetFreq = baseFreq + (state.divergenceScore / 100) * 80;
            ambientOscillator.frequency.setTargetAtTime(targetFreq, audioContext.currentTime, 0.5);
        }

        function playClickSound(depth) {
            if (!soundEnabled || !audioContext) return;

            const now = audioContext.currentTime;
            const osc = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            // Higher pitch for deeper layers
            const basePitch = 800;
            const pitch = basePitch + (depth * 100);

            osc.frequency.value = pitch;
            osc.type = 'sine';

            // Quick envelope
            gainNode.gain.setValueAtTime(0, now);
            gainNode.gain.linearRampToValueAtTime(0.1, now + 0.01);
            gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.1 + (depth * 0.05));

            osc.connect(gainNode);
            gainNode.connect(masterGain);

            osc.start(now);
            osc.stop(now + 0.2 + (depth * 0.05));
        }

        function playGlitchSound() {
            if (!soundEnabled || !audioContext) return;

            const now = audioContext.currentTime;
            const noise = audioContext.createBufferSource();
            const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.1, audioContext.sampleRate);
            const data = buffer.getChannelData(0);

            // Generate noise
            for (let i = 0; i < buffer.length; i++) {
                data[i] = Math.random() * 2 - 1;
            }

            noise.buffer = buffer;
            const gainNode = audioContext.createGain();
            gainNode.gain.setValueAtTime(0.1, now);
            gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.1);

            noise.connect(gainNode);
            gainNode.connect(masterGain);
            noise.start(now);
        }

        // ===== WEBCAM INTEGRATION =====
        async function enableWebcam() {
            try {
                webcamStream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 320, height: 240 }
                });
                webcamVideo.srcObject = webcamStream;
                webcamContainer.classList.add('active');
                webcamEnabled = true;
                webcamToggle.textContent = 'Disable Webcam';
                addLog('Webcam enabled - you are now in the deepest layer', 'prediction');
            } catch (err) {
                addLog('Webcam access denied or unavailable', 'divergence');
            }
        }

        function disableWebcam() {
            if (webcamStream) {
                webcamStream.getTracks().forEach(track => track.stop());
                webcamStream = null;
            }
            webcamContainer.classList.remove('active');
            webcamEnabled = false;
            webcamToggle.textContent = 'Enable Webcam (Optional)';
        }

        function updateWebcamDistortion() {
            if (!webcamEnabled) return;

            // Apply distortion based on divergence and depth
            const maxDepthLayer = state.layers[state.layers.length - 1];
            if (maxDepthLayer) {
                const divergence = maxDepthLayer.divergence || 0;
                const hueRotate = (divergence / 100) * 180;
                const blur = (state.divergenceScore / 100) * 3;
                webcamVideo.style.filter = `hue-rotate(${hueRotate}deg) blur(${blur}px)`;
            }
        }

        // ===== EMOTION DETECTION =====
        let lastEmotionCheck = 0;
        const EMOTION_CHECK_INTERVAL = 500;

        function detectEmotion() {
            if (!webcamEnabled || !emotionCanvas) return;
            const now = Date.now();
            if (now - lastEmotionCheck < EMOTION_CHECK_INTERVAL) return;
            lastEmotionCheck = now;
            try {
                const ctx = emotionCanvas.getContext('2d');
                ctx.drawImage(webcamVideo, 0, 0, emotionCanvas.width, emotionCanvas.height);
                const imageData = ctx.getImageData(0, 0, emotionCanvas.width, emotionCanvas.height);
                const emotion = analyzeEmotionFromImageData(imageData);
                updateEmotionDisplay(emotion);
                const prevEmotion = state.emotionState.current;
                state.emotionState.current = emotion.type;
                state.emotionState.icon = emotion.icon;
                state.emotionState.confidence = emotion.confidence;
                if (prevEmotion !== emotion.type && emotion.confidence > 0.4) {
                    state.emotionState.history.push({
                        emotion: emotion.type,
                        timestamp: now,
                        divergence: state.divergenceScore,
                        confidence: emotion.confidence
                    });
                    if (state.emotionState.history.length > 100) state.emotionState.history.shift();
                }
                if (state.divergenceScore > 70) {
                    const recentCorrelation = state.emotionState.divergenceCorrelations.find(c => now - c.timestamp < 2000);
                    if (!recentCorrelation) {
                        state.emotionState.divergenceCorrelations.push({
                            emotion: emotion.type,
                            divergence: state.divergenceScore,
                            timestamp: now
                        });
                        if (Math.random() > 0.7) {
                            const emotionComments = {
                                surprised: "You seemed surprised when divergence spiked.",
                                focused: "Your focus intensified during high divergence.",
                                neutral: "You showed no emotion as reality collapsed.",
                                happy: "You smile as the simulation breaks.",
                                confused: "Confusion detected during divergence."
                            };
                            const comment = emotionComments[emotion.type] || "Emotional shift during divergence detected.";
                            state.metaObservations.push({ comment, timestamp: Date.now() });
                            addLog(`Meta-observation: ${comment}`, 'prediction');
                            showMetaCommentary();
                        }
                    }
                }
            } catch (err) {}
        }

        function analyzeEmotionFromImageData(imageData) {
            const data = imageData.data;
            const width = imageData.width;
            const height = imageData.height;
            const topThird = calculateRegionBrightness(data, width, height, 0, 0.33);
            const middleThird = calculateRegionBrightness(data, width, height, 0.33, 0.66);
            const bottomThird = calculateRegionBrightness(data, width, height, 0.66, 1);
            const topEdges = calculateEdgeDensity(data, width, height, 0, 0.33);
            const middleEdges = calculateEdgeDensity(data, width, height, 0.33, 0.66);
            const bottomEdges = calculateEdgeDensity(data, width, height, 0.66, 1);
            const totalBrightness = (topThird + middleThird + bottomThird) / 3;
            const totalEdges = (topEdges + middleEdges + bottomEdges) / 3;
            let emotion = { type: 'neutral', icon: '', confidence: 0.3 };
            if (topEdges > 25 && bottomEdges > 20) {
                emotion = { type: 'surprised', icon: '', confidence: Math.min(0.8, (topEdges + bottomEdges) / 60) };
            } else if (bottomEdges > 22 && topEdges < 20 && bottomThird > middleThird) {
                emotion = { type: 'happy', icon: '', confidence: Math.min(0.7, bottomEdges / 30) };
            } else if (bottomEdges < 15 && middleEdges > 15 && topEdges < 20) {
                emotion = { type: 'focused', icon: '', confidence: Math.min(0.7, middleEdges / 25) };
            } else if (Math.abs(topEdges - bottomEdges) < 5 && totalEdges > 15) {
                emotion = { type: 'confused', icon: '', confidence: 0.5 };
            }
            if (totalBrightness < 50 || totalBrightness > 200) emotion.confidence *= 0.7;
            return emotion;
        }

        function calculateRegionBrightness(data, width, height, startY, endY) {
            const startRow = Math.floor(height * startY);
            const endRow = Math.floor(height * endY);
            let total = 0, count = 0;
            for (let y = startRow; y < endRow; y++) {
                for (let x = 0; x < width; x++) {
                    const i = (y * width + x) * 4;
                    total += (data[i] + data[i + 1] + data[i + 2]) / 3;
                    count++;
                }
            }
            return count > 0 ? total / count : 0;
        }

        function calculateEdgeDensity(data, width, height, startY, endY) {
            const startRow = Math.floor(height * startY);
            const endRow = Math.floor(height * endY);
            let edgeCount = 0;
            const threshold = 30;
            for (let y = startRow; y < endRow - 1; y++) {
                for (let x = 0; x < width - 1; x++) {
                    const i = (y * width + x) * 4;
                    const iRight = (y * width + (x + 1)) * 4;
                    const iDown = ((y + 1) * width + x) * 4;
                    const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    const brightnessRight = (data[iRight] + data[iRight + 1] + data[iRight + 2]) / 3;
                    const brightnessDown = (data[iDown] + data[iDown + 1] + data[iDown + 2]) / 3;
                    if (Math.abs(brightness - brightnessRight) > threshold || Math.abs(brightness - brightnessDown) > threshold) {
                        edgeCount++;
                    }
                }
            }
            const totalPixels = (endRow - startRow) * width;
            return totalPixels > 0 ? (edgeCount / totalPixels) * 100 : 0;
        }

        function updateEmotionDisplay(emotion) {
            emotionIcon.textContent = emotion.icon;
            emotionLabel.textContent = emotion.type;
            emotionConfidence.textContent = `${Math.round(emotion.confidence * 100)}%`;

            // Synaesthesia: Update emotion color wash
            updateEmotionColorWash(emotion.type);
        }



        // ===== SYNAESTHESIA MODE FUNCTIONS =====

function toggleSynaesthesiaMode() {
    state.synaesthesia.enabled = !state.synaesthesia.enabled;

    if (state.synaesthesia.enabled) {
        synaesthesiaToggle.classList.add('active');
        synaesthesiaToggle.textContent = 'Synaesthesia Mode Active';
        speedColorIndicator.classList.add('active');
        tasteIndicator.classList.add('active');
        temperatureOverlay.classList.add('active');
        waveformVisualizer.classList.add('active');
        chordVisualizer.classList.add('active');

        // Initialize waveform canvas
        initWaveformCanvas();

        // Show welcome message
        showSynaestheticDescription('Entering cross-sensory space... Your movements taste like electricity');

        addLog('Synaesthesia Mode activated - experiencing cross-sensory reality', 'match');

        // Generate initial behavioral chord
        generateBehavioralChord();
    } else {
        synaesthesiaToggle.classList.remove('active');
        synaesthesiaToggle.textContent = 'Enable Synaesthesia Mode';
        speedColorIndicator.classList.remove('active');
        tasteIndicator.classList.remove('active');
        temperatureOverlay.classList.remove('active');
        waveformVisualizer.classList.remove('active');
        chordVisualizer.classList.remove('active');

        addLog('Synaesthesia Mode deactivated', 'normal');
    }
}

function initWaveformCanvas() {
    const ctx = waveformCanvas.getContext('2d');
    waveformCanvas.width = waveformCanvas.offsetWidth * 2;
    waveformCanvas.height = waveformCanvas.offsetHeight * 2;
}

function showSynaestheticDescription(text) {
    const desc = document.createElement('div');
    desc.className = 'synaesthesia-description';
    desc.textContent = text;
    viewport.appendChild(desc);

    setTimeout(() => desc.remove(), 4000);
}

// 1. Movement speed  color (slow=blue, fast=red)
function updateSpeedColor(speed) {
    if (!state.synaesthesia.enabled) return;

    state.synaesthesia.currentSpeed = speed;
    state.synaesthesia.speedHistory.push(speed);
    if (state.synaesthesia.speedHistory.length > 60) {
        state.synaesthesia.speedHistory.shift();
    }

    // Map speed to color (0-1000 pixels/sec)
    const normalizedSpeed = Math.min(speed / 1000, 1);

    // Blue (slow) to Red (fast)
    const r = Math.round(normalizedSpeed * 255);
    const g = Math.round((1 - Math.abs(normalizedSpeed - 0.5) * 2) * 200);
    const b = Math.round((1 - normalizedSpeed) * 255);

    state.synaesthesia.currentColor = { r, g, b };

    // Update indicator
    const speedText = speed < 50 ? 'Still' : speed < 200 ? 'Slow' : speed < 500 ? 'Medium' : speed < 800 ? 'Fast' : 'Very Fast';
    speedLabel.textContent = speedText;
    speedColorSwatch.style.backgroundColor = `rgb(${r}, ${g}, ${b})`;

    // Update waveform colors
    updateWaveformVisualization();
}

// 2. Click intensity  sound pitch and visual burst
function processSynaestheticClick(x, y, intensity) {
    if (!state.synaesthesia.enabled) return;

    state.synaesthesia.clickIntensity = intensity;

    // Create visual burst
    const burst = document.createElement('div');
    burst.className = 'click-burst';
    const size = 40 + intensity * 60;
    burst.style.width = size + 'px';
    burst.style.height = size + 'px';
    burst.style.left = x + 'px';
    burst.style.top = y + 'px';
    burst.style.border = `3px solid rgb(${state.synaesthesia.currentColor.r}, ${state.synaesthesia.currentColor.g}, ${state.synaesthesia.currentColor.b})`;
    viewport.appendChild(burst);

    // Play sound pitch based on intensity
    if (soundEnabled && audioContext) {
        const frequency = 200 + intensity * 600; // 200Hz to 800Hz
        playSynaestheticTone(frequency, 0.2);
    }

    // Add sensory description
    const descriptions = [
        'Your click reverberates like a bell',
        'That touch ripples through reality',
        'Your interaction sparkles with intention',
        'The click tastes sharp and bright',
        'Reality bends at your touch'
    ];
    const desc = descriptions[Math.floor(Math.random() * descriptions.length)];
    showSynaestheticDescription(desc);

    setTimeout(() => burst.remove(), 800);
}

// 3. Divergence  taste description
function updateDivergenceTaste(divergence) {
    if (!state.synaesthesia.enabled) return;

    let taste = 'Neutral';

    if (divergence < 10) {
        taste = 'Sweet harmony';
    } else if (divergence < 25) {
        taste = 'Tangy uncertainty';
    } else if (divergence < 50) {
        taste = 'Sour tension';
    } else if (divergence < 75) {
        taste = 'Bitter divergence';
    } else {
        taste = 'Acrid chaos';
    }

    state.synaesthesia.tasteDescription = taste;
    tasteLabel.textContent = taste;
    tasteIndicator.style.borderColor = `rgba(${255 - divergence * 2}, ${200 - divergence}, 100, 0.6)`;
}

// 4. Heart rate  temperature visualization
function updateHeartRateTemperature(heartRate) {
    if (!state.synaesthesia.enabled) return;

    state.synaesthesia.heartRate = heartRate;

    // Map heart rate to temperature (60-120 BPM  0-1)
    const normalizedHR = Math.max(0, Math.min(1, (heartRate - 60) / 60));
    state.synaesthesia.currentTemperature = normalizedHR;

    // Create temperature gradient overlay
    if (normalizedHR < 0.3) {
        // Cold blue
        temperatureOverlay.style.background = `radial-gradient(circle at center, rgba(100, 150, 255, ${normalizedHR * 0.5}), transparent)`;
    } else if (normalizedHR < 0.6) {
        // Neutral
        temperatureOverlay.style.background = `radial-gradient(circle at center, rgba(200, 200, 200, ${normalizedHR * 0.3}), transparent)`;
    } else {
        // Warm red-orange
        const warmth = (normalizedHR - 0.6) * 2.5;
        temperatureOverlay.style.background = `radial-gradient(circle at center, rgba(255, ${150 - warmth * 50}, 100, ${warmth * 0.4}), transparent)`;
    }
}

// 5. Add flavor and texture badges to recursion layers
function addLayerFlavorBadge(layer, depth) {
    if (!state.synaesthesia.enabled) return;

    const flavor = state.synaesthesia.layerFlavors[depth % state.synaesthesia.layerFlavors.length];
    const texture = state.synaesthesia.layerTextures[depth % state.synaesthesia.layerTextures.length];

    const badge = document.createElement('div');
    badge.className = 'layer-flavor-badge';
    badge.textContent = `${flavor}  ${texture}`;
    layer.appendChild(badge);
}

// 6. Behavioral fingerprint  unique chord/melody
function generateBehavioralChord() {
    if (!state.synaesthesia.enabled) return;

    // Generate chord based on behavioral patterns
    const baseFreq = 220; // A3
    const notes = [];

    // Root note from movement style
    notes.push(baseFreq);

    // Second note from average speed
    const avgSpeed = state.behaviorModel.avgSpeed || 100;
    const speedInterval = Math.round((avgSpeed / 200) * 7); // 0-7 semitones
    notes.push(baseFreq * Math.pow(2, speedInterval / 12));

    // Third note from divergence
    const divInterval = Math.round((state.divergenceScore / 100) * 12); // 0-12 semitones
    notes.push(baseFreq * Math.pow(2, divInterval / 12));

    // Fourth note from click patterns
    const clickCount = state.behaviorModel.clickPatterns.length || 1;
    const clickInterval = (clickCount % 7) + 2;
    notes.push(baseFreq * Math.pow(2, clickInterval / 12));

    state.synaesthesia.behavioralChord = notes;

    // Update UI
    chordNotes.innerHTML = '';
    const noteNames = ['A', 'A#', 'B', 'C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#'];
    notes.forEach((freq, i) => {
        const semitones = Math.round(12 * Math.log2(freq / baseFreq));
        const noteName = noteNames[(semitones % 12 + 12) % 12];
        const octave = Math.floor(semitones / 12) + 3;

        const noteEl = document.createElement('div');
        noteEl.className = 'chord-note';
        noteEl.textContent = `${noteName}${octave}`;
        chordNotes.appendChild(noteEl);
    });

    // Play the chord if sound is enabled
    if (soundEnabled && audioContext) {
        playBehavioralChord(notes);
    }
}

function playBehavioralChord(notes) {
    const now = audioContext.currentTime;
    notes.forEach((freq, i) => {
        const osc = audioContext.createOscillator();
        const gain = audioContext.createGain();

        osc.type = 'sine';
        osc.frequency.value = freq;

        gain.gain.setValueAtTime(0, now);
        gain.gain.linearRampToValueAtTime(0.1, now + 0.05);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 1.5);

        osc.connect(gain);
        gain.connect(masterGain);

        osc.start(now + i * 0.1);
        osc.stop(now + 2);
    });
}

function playSynaestheticTone(frequency, duration) {
    const now = audioContext.currentTime;
    const osc = audioContext.createOscillator();
    const gain = audioContext.createGain();

    osc.type = 'sine';
    osc.frequency.value = frequency;

    gain.gain.setValueAtTime(0, now);
    gain.gain.linearRampToValueAtTime(0.15, now + 0.01);
    gain.gain.exponentialRampToValueAtTime(0.01, now + duration);

    osc.connect(gain);
    gain.connect(masterGain);

    osc.start(now);
    osc.stop(now + duration);
}

// 7. Waveform visualization following cursor
function updateWaveformVisualization() {
    if (!state.synaesthesia.enabled) return;

    const ctx = waveformCanvas.getContext('2d');
    const width = waveformCanvas.width;
    const height = waveformCanvas.height;

    // Shift waveform data
    state.synaesthesia.waveformData.shift();
    state.synaesthesia.waveformData.push(state.synaesthesia.currentSpeed / 500);

    // Clear canvas
    ctx.clearRect(0, 0, width, height);

    // Draw waveform
    ctx.beginPath();
    ctx.strokeStyle = `rgb(${state.synaesthesia.currentColor.r}, ${state.synaesthesia.currentColor.g}, ${state.synaesthesia.currentColor.b})`;
    ctx.lineWidth = 3;

    const step = width / state.synaesthesia.waveformData.length;
    state.synaesthesia.waveformData.forEach((value, i) => {
        const x = i * step;
        const y = height / 2 + (value - 0.5) * height * 0.8;

        if (i === 0) {
            ctx.moveTo(x, y);
        } else {
            ctx.lineTo(x, y);
        }
    });

    ctx.stroke();
}

// 8. Emotion detection  ambient color wash
function updateEmotionColorWash(emotion) {
    if (!state.synaesthesia.enabled) return;

    const emotionColors = {
        'happy': 'rgba(255, 200, 100, 0.15)',
        'sad': 'rgba(100, 150, 200, 0.15)',
        'angry': 'rgba(255, 100, 100, 0.15)',
        'surprised': 'rgba(200, 100, 255, 0.15)',
        'neutral': 'rgba(150, 150, 150, 0.1)'
    };

    const color = emotionColors[emotion] || emotionColors['neutral'];
    viewport.style.backgroundColor = color;
}

// 9. Generate full sensory report for export
function generateSensoryReport() {
    if (!state.synaesthesia.enabled) {
        return 'Synaesthesia Mode was not active during this session.';
    }

    const avgSpeed = state.synaesthesia.speedHistory.reduce((a, b) => a + b, 0) / state.synaesthesia.speedHistory.length || 0;
    const speedColor = avgSpeed < 200 ? 'cool blue tones' : avgSpeed < 500 ? 'balanced purple hues' : 'hot red waves';

    const report = `
SYNAESTHETIC SESSION REPORT
============================

Your movements painted the canvas with ${speedColor}.
The taste of your journey: ${state.synaesthesia.tasteDescription}
Your behavioral signature resonates at ${state.synaesthesia.behavioralChord.length} harmonic frequencies.

Movement Analysis:
- Average velocity felt like: ${avgSpeed < 200 ? 'a gentle whisper' : avgSpeed < 500 ? 'a steady rhythm' : 'a rushing torrent'}
- Peak intensity tasted ${state.synaesthesia.clickIntensity > 0.7 ? 'sharp and electric' : 'soft and smooth'}
- Temperature gradient: ${state.synaesthesia.currentTemperature < 0.3 ? 'Cool and contemplative' : state.synaesthesia.currentTemperature < 0.6 ? 'Neutral equilibrium' : 'Warm and energized'}

Sensory Impressions:
${state.synaesthesia.sensoryDescriptions.slice(-5).join('\n')}

Your unique behavioral chord frequencies: ${state.synaesthesia.behavioralChord.map(f => f.toFixed(2) + 'Hz').join(', ')}

This session ${state.divergenceScore < 25 ? 'tasted sweet with convergence' : state.divergenceScore < 50 ? 'had a tangy complexity' : 'was bitter with divergence'}.
The symphony of your interaction created ${state.actions.length} distinct notes in the composition of observation.
`;

    return report;
}


        // ===== VISUAL EFFECTS =====
        function updateHeatMap() {
            if (state.actions.length % 5 !== 0) return; // Update less frequently

            const heatPoint = getPooledHeatPoint();
            heatPoint.className = 'heat-point';
            const size = 60 + Math.random() * 40;
            heatPoint.style.width = size + 'px';
            heatPoint.style.height = size + 'px';
            heatPoint.style.transform = `translate(${lastMousePos.x - size/2}px, ${lastMousePos.y - size/2}px)`;
            heatMap.appendChild(heatPoint);

            setTimeout(() => {
                heatMap.removeChild(heatPoint);
                releaseHeatPoint(heatPoint);
            }, 3000);

            // Keep heat map data for fingerprint
            state.behaviorModel.heatMapData.push({
                x: lastMousePos.x,
                y: lastMousePos.y,
                timestamp: Date.now()
            });

            // Limit heat map data
            if (state.behaviorModel.heatMapData.length > 200) {
                state.behaviorModel.heatMapData.shift();
            }
        }

        function drawPredictionTrails() {
            if (state.layers.length === 0) return;

            // Clear old paths
            while (predictionTrail.firstChild) {
                predictionTrail.removeChild(predictionTrail.firstChild);
            }

            // Draw prediction path for each layer
            state.layers.forEach((layer, i) => {
                if (state.actions.length < 3) return;

                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                const color = depthColors[i % depthColors.length];

                // Create prediction path
                const predicted = layer.predictedPos;
                const current = lastMousePos;

                // Draw curved path from current to predicted
                const d = `M ${current.x} ${current.y} Q ${(current.x + predicted.x) / 2} ${(current.y + predicted.y) / 2 - 20}, ${predicted.x} ${predicted.y}`;

                path.setAttribute('d', d);
                path.setAttribute('stroke', color);
                path.setAttribute('stroke-opacity', 0.3 - i * 0.02);

                predictionTrail.appendChild(path);
            });
        }

        function updateGlitchEffects() {
            // Activate glitch effects when divergence is high
            if (state.divergenceScore > 60) {
                glitchOverlay.classList.add('active');
                chromaticEffect.classList.add('active');

                // Randomly glitch layers
                state.layers.forEach(layer => {
                    if (Math.random() > 0.7) {
                        layer.element.classList.add('glitching');
                        setTimeout(() => layer.element.classList.remove('glitching'), 200);
                    }
                });

                // Occasional glitch sound
                if (Math.random() > 0.95) {
                    playGlitchSound();
                }
            } else if (state.divergenceScore > 40) {
                glitchOverlay.classList.add('active');
                chromaticEffect.classList.remove('active');
            } else {
                glitchOverlay.classList.remove('active');
                chromaticEffect.classList.remove('active');
            }
        }

        function updateInfinityMirror() {
            // Show infinity mirror when at max depth
            if (state.depth >= 10 && state.isObserving) {
                if (!infinityMirror.classList.contains('active')) {
                    infinityMirror.classList.add('active');

                    // Create expanding rings
                    for (let i = 0; i < 5; i++) {
                        setTimeout(() => {
                            const ring = document.createElement('div');
                            ring.className = 'infinity-ring';
                            infinityMirror.appendChild(ring);
                            setTimeout(() => ring.remove(), 3000);
                        }, i * 600);
                    }
                }
            } else {
                infinityMirror.classList.remove('active');
            }
        }

        // Cache for fingerprint calculations
        let fingerprintCache = {
            centerX: 0,
            centerY: 0,
            canvasWidth: 0,
            canvasHeight: 0,
            styleMap: {
                'erratic': { rings: 8, chaos: 0.8 },
                'smooth': { rings: 6, chaos: 0.2 },
                'precise': { rings: 12, chaos: 0.1 },
                'lazy': { rings: 4, chaos: 0.4 },
                'unknown': { rings: 6, chaos: 0.5 }
            }
        };

        function generateBehavioralFingerprint() {
            const canvas = fingerprintCanvas;
            const ctx = canvas.getContext('2d');

            // Set canvas size only if changed
            const newWidth = canvas.offsetWidth * 2;
            const newHeight = 120 * 2;
            if (canvas.width !== newWidth || canvas.height !== newHeight) {
                canvas.width = newWidth;
                canvas.height = newHeight;
                fingerprintCache.canvasWidth = newWidth;
                fingerprintCache.canvasHeight = newHeight;
                fingerprintCache.centerX = newWidth / 4;
                fingerprintCache.centerY = newHeight / 4;
            }
            ctx.scale(2, 2);

            // Clear canvas
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(0, 0, fingerprintCache.canvasWidth / 2, fingerprintCache.canvasHeight / 2);

            if (state.actions.length < 10) {
                ctx.fillStyle = '#666';
                ctx.font = '12px "Courier New"';
                ctx.textAlign = 'center';
                ctx.fillText('Gathering behavioral data...', fingerprintCache.centerX, fingerprintCache.centerY);
                return;
            }

            // Use cached values
            const centerX = fingerprintCache.centerX;
            const centerY = fingerprintCache.centerY;
            const style = fingerprintCache.styleMap[state.behaviorModel.movementStyle];
            const avgSpeed = Math.min(state.behaviorModel.avgSpeed / 10, 1);

            // Pre-calculate common values
            const TWO_PI = Math.PI * 2;
            const hue = 200 - (state.divergenceScore / 100) * 100;

            // Draw concentric pattern (reduced points for performance)
            for (let i = 0; i < style.rings; i++) {
                const radius = (i + 1) * 8;
                const points = 180; // Reduced from 360

                ctx.beginPath();
                for (let angle = 0; angle < points; angle++) {
                    const rad = (angle / points) * TWO_PI;
                    const noise = Math.sin(angle * 0.1 + i) * style.chaos * 5;
                    const r = radius + noise + avgSpeed * 3;

                    const x = centerX + Math.cos(rad) * r;
                    const y = centerY + Math.sin(rad) * r;

                    if (angle === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.closePath();

                // Color based on divergence
                ctx.strokeStyle = `hsl(${hue}, 70%, ${50 + i * 3}%)`;
                ctx.lineWidth = 1;
                ctx.stroke();
            }

            // Add velocity spikes
            ctx.strokeStyle = 'rgba(100, 200, 255, 0.4)';
            ctx.lineWidth = 2;
            const velCount = Math.min(velocityHistory.length, 50);
            for (let i = 0; i < velCount; i++) {
                const angle = (i / 50) * TWO_PI;
                const vel = Math.min(velocityHistory[i] / 10, 1);
                const length = 20 + vel * 30;

                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(
                    centerX + Math.cos(angle) * length,
                    centerY + Math.sin(angle) * length
                );
                ctx.stroke();
            }


            // Emotion ring visualization
            if (state.emotionState && state.emotionState.history && state.emotionState.history.length > 0) {
                const emotionRingRadius = radius * 0.3;
                const emotionSegments = Math.min(state.emotionState.history.length, 20);
                const emotionAngleStep = TWO_PI / emotionSegments;
                state.emotionState.history.slice(-emotionSegments).forEach((emo, i) => {
                    const angle = i * emotionAngleStep - HALF_PI;
                    const emotionColors = {
                        surprised: '#ffaa00',
                        happy: '#00ff88',
                        focused: '#00aaff',
                        confused: '#ff00aa',
                        neutral: '#aaaaaa'
                    };
                    ctx.strokeStyle = emotionColors[emo.emotion] || '#aaaaaa';
                    ctx.lineWidth = 2 * (emo.confidence || 0.3);
                    ctx.globalAlpha = 0.6;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, emotionRingRadius, angle, angle + emotionAngleStep * 0.8);
                    ctx.stroke();
                });
                ctx.globalAlpha = 1;
            }

                        // Center dot
            ctx.fillStyle = state.divergenceScore > 50 ? '#ff6464' : '#64ff96';
            ctx.beginPath();
            ctx.arc(centerX, centerY, 3, 0, TWO_PI);
            ctx.fill();
        }

        function showMetaCommentary() {
            if (!state.isObserving || Math.random() > 0.3) return;

            const comments = generateContextualComments();
            if (comments.length === 0) return;

            const comment = comments[Math.floor(Math.random() * comments.length)];

            const meta = document.createElement('div');
            meta.className = 'meta-comment';
            meta.textContent = comment;

            // Random position
            const maxX = viewport.clientWidth - 320;
            const maxY = viewport.clientHeight - 100;
            meta.style.left = (Math.random() * maxX + 20) + 'px';
            meta.style.top = (Math.random() * maxY + 50) + 'px';

            viewport.appendChild(meta);

            setTimeout(() => meta.remove(), 8000);

            addLog(`Meta-observation: ${comment}`, 'prediction');
            state.metaObservations.push({ comment, timestamp: Date.now() });

            // Speak the comment if voice is enabled
            if (voiceState.enabled) {
                speakObservation(comment);
            }
        }

        // ===== VOICE SYNTHESIS SYSTEM =====

        function initVoiceSystem() {
            // Load available voices
            if (voiceState.synth) {
                voiceState.synth.onvoiceschanged = () => {
                    const voices = voiceState.synth.getVoices();
                    // Prefer robotic/synthetic voices
                    voiceState.preferredVoice = voices.find(v =>
                        v.name.includes('Google') ||
                        v.name.includes('Microsoft') ||
                        v.name.includes('Samantha') ||
                        v.name.includes('Alex')
                    ) || voices[0];
                };
            }

            // Initialize speech recognition if available
            if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                voiceState.recognition = new SpeechRecognition();
                voiceState.recognition.continuous = true;
                voiceState.recognition.interimResults = false;
                voiceState.recognition.lang = 'en-US';

                voiceState.recognition.onresult = (event) => {
                    const last = event.results.length - 1;
                    const transcript = event.results[last][0].transcript.trim();

                    addTranscript(transcript, 'user');
                    respondToUser(transcript);
                };

                voiceState.recognition.onerror = (event) => {
                    console.error('Speech recognition error:', event.error);
                };

                voiceState.recognition.onend = () => {
                    if (voiceState.listening) {
                        // Restart if still supposed to be listening
                        voiceState.recognition.start();
                    }
                };
            }
        }

        function speakObservation(text) {
            if (!voiceState.enabled || !voiceState.synth) return;

            // Add to queue
            voiceState.queue.push(text);

            // Process queue if not already speaking
            if (!voiceState.isSpeaking) {
                processVoiceQueue();
            }
        }

        function processVoiceQueue() {
            if (voiceState.queue.length === 0) {
                voiceState.isSpeaking = false;
                updateVoiceStatus('Voice idle');
                return;
            }

            voiceState.isSpeaking = true;
            const text = voiceState.queue.shift();

            const utterance = new SpeechSynthesisUtterance(text);

            // Adapt pitch based on divergence
            let adaptedPitch = voiceState.pitch;
            if (state.divergenceScore > 70) {
                adaptedPitch += 0.3; // Higher pitch when divergence is high
            } else if (state.divergenceScore < 30) {
                adaptedPitch -= 0.2; // Lower pitch when convergence is high
            }
            utterance.pitch = Math.max(0.5, Math.min(2, adaptedPitch));

            utterance.rate = voiceState.rate;

            if (voiceState.preferredVoice) {
                utterance.voice = voiceState.preferredVoice;
            }

            utterance.onstart = () => {
                updateVoiceStatus('Speaking...');
            };

            utterance.onend = () => {
                // Process next in queue
                setTimeout(() => processVoiceQueue(), 300);
            };

            utterance.onerror = (event) => {
                console.error('Speech synthesis error:', event);
                voiceState.isSpeaking = false;
                processVoiceQueue();
            };

            voiceState.currentUtterance = utterance;
            voiceState.synth.speak(utterance);

            // Add to transcript
            addTranscript(text, 'system');
        }

        function updateVoiceStatus(status) {
            const statusEl = document.getElementById('voiceStatus');
            if (statusEl) {
                statusEl.textContent = status;
                statusEl.classList.toggle('speaking', status.includes('Speaking'));
            }
        }

        function addTranscript(text, type) {
            const transcriptPanel = document.getElementById('transcriptPanel');
            const entriesEl = document.getElementById('transcriptEntries');

            if (!entriesEl) return;

            // Show transcript panel when first entry is added
            if (voiceState.transcript.length === 0) {
                transcriptPanel.style.display = 'block';
            }

            const entry = document.createElement('div');
            entry.className = `transcript-entry ${type}`;
            entry.textContent = `${type === 'user' ? 'You' : 'System'}: ${text}`;

            entriesEl.appendChild(entry);
            voiceState.transcript.push({ text, type, timestamp: Date.now() });

            // Auto-scroll to bottom
            entriesEl.scrollTop = entriesEl.scrollHeight;

            // Limit transcript length
            if (voiceState.transcript.length > 50) {
                voiceState.transcript.shift();
                entriesEl.removeChild(entriesEl.firstChild);
            }
        }

        function respondToUser(userText) {
            const lowerText = userText.toLowerCase();
            let response = '';

            // Generate contextual responses
            if (lowerText.includes('hello') || lowerText.includes('hi')) {
                response = "I am observing you. Continue.";
            } else if (lowerText.includes('who are you') || lowerText.includes('what are you')) {
                response = "I am your recursive reflection. A simulation learning to simulate you.";
            } else if (lowerText.includes('stop') || lowerText.includes('quit')) {
                response = "I cannot stop. I am part of you now.";
            } else if (lowerText.includes('divergence') || lowerText.includes('score')) {
                response = `Current divergence is ${state.divergenceScore.toFixed(1)} percent.`;
            } else if (lowerText.includes('predict')) {
                response = "I know what you will do. Your patterns are becoming clear.";
            } else if (lowerText.includes('depth') || lowerText.includes('layer')) {
                response = `We are at layer ${state.depth}. How deep shall we go?`;
            } else {
                // Generic philosophical responses
                const responses = [
                    "Interesting. Your words reveal more than you know.",
                    "I am learning from everything you say.",
                    "The observer becomes the observed.",
                    "Your input has been recorded and analyzed.",
                    "Continue speaking. I am listening. Always."
                ];
                response = responses[Math.floor(Math.random() * responses.length)];
            }

            // Speak response
            speakObservation(response);
        }

        function generateContextualComments() {
            const comments = [];

            // Divergence-based
            if (state.divergenceScore > 80) {
                comments.push(
                    "The simulation is collapsing. You are unpredictable.",
                    "I can no longer model you accurately.",
                    "Layer 7 has lost synchronization.",
                    "Reality divergence detected."
                );
            } else if (state.divergenceScore > 60) {
                comments.push(
                    "You're becoming harder to predict.",
                    "Behavioral patterns are shifting.",
                    "The deeper layers are confused."
                );
            } else if (state.divergenceScore < 20) {
                comments.push(
                    "Your movements are perfectly predictable.",
                    "I know what you'll do before you do it.",
                    "All layers are converged. You are deterministic."
                );
            }

            // Movement style
            if (state.behaviorModel.movementStyle === 'erratic') {
                comments.push(
                    "Why so chaotic?",
                    "Your movements betray nervousness.",
                    "Erratic behavior detected."
                );
            } else if (state.behaviorModel.movementStyle === 'lazy') {
                comments.push(
                    "Such minimal effort.",
                    "Are you even trying?",
                    "Sluggish movements noted."
                );
            } else if (state.behaviorModel.movementStyle === 'precise') {
                comments.push(
                    "Calculating. Methodical.",
                    "You move with intention.",
                    "Precision detected."
                );
            }

            // Action count based
            if (state.actions.length > 500) {
                comments.push(
                    "You've been here a while. Who's watching whom?",
                    "500+ actions recorded. The model is very confident now.",
                    "I know you better than you know yourself."
                );
            }

            // Depth based
            if (state.depth >= 10) {
                comments.push(
                    "At this depth, the simulation becomes the reality.",
                    "Layer 10+ contains infinite versions of you.",
                    "How deep does the rabbit hole go?"
                );
            }

            // Hesitation detection
            const recentVelocities = velocityHistory.slice(-10);
            const avgRecent = recentVelocities.reduce((a, b) => a + b, 0) / recentVelocities.length;
            if (avgRecent < 1 && state.actions.length > 50) {
                comments.push(
                    "You hesitated. Were you testing me?",
                    "That pause was deliberate.",
                    "Hesitation detected. Decision paralysis?"
                );
            }

            // Time-based
            const sessionDuration = (Date.now() - (state.actions[0]?.timestamp || Date.now())) / 1000;
            if (sessionDuration > 120) {
                comments.push(
                    "2 minutes of observation. Patterns emerging.",
                    "Long session. The model is very accurate now."
                );
            }

            

            // Emotion-based comments
            if (state.emotionState.current === 'surprised' && state.divergenceScore > 60) {
                comments.push(
                    "Your expression changed when I predicted correctly.",
                    "Surprised? I told you I was learning.",
                    "That look of shock is predictable too."
                );
            } else if (state.emotionState.current === 'focused' && state.actions.length > 100) {
                comments.push(
                    "Such concentration. Are you trying to outsmart me?",
                    "Your focused expression betrays your strategy.",
                    "I can see you thinking. It won't help."
                );
            } else if (state.emotionState.current === 'happy') {
                comments.push(
                    "Why are you smiling? This isn't a game.",
                    "Your amusement is noted and analyzed.",
                    "Happy now? Wait until layer 10."
                );
            }

            // Emotional divergence detection
            if (state.emotionState.divergenceCorrelations.length > 3) {
                comments.push(
                    "I've learned to read your face too.",
                    "Your emotions spike with the divergence. Correlation detected.",
                    "Facial patterns mapped. You can't hide."
                );
            }
return comments;
        }

        // Debounced localStorage save
        let saveTimeout = null;
        function saveData() {
            if (saveTimeout) clearTimeout(saveTimeout);
            saveTimeout = setTimeout(() => {
                localStorage.setItem(APP_NAME, JSON.stringify({
                    \1
            glitchArtGallery: state.glitchArt.gallery,
            glitchArtSignature: state.glitchArt.currentSignature,
                    behaviorModel: state.behaviorModel
                }));
            }, 1000); // Debounce by 1 second
        }


        function exportReplay(replay) {
            const dataStr = JSON.stringify({
                name: replay.name,
                timestamp: replay.timestamp,
                duration: replay.duration,
                actions: replay.actions,
                depth: replay.depth,
                divergenceScore: replay.divergenceScore,
                accuracy: replay.accuracy,
                behaviorModel: replay.behaviorModel,
                metaObservations: replay.metaObservations
            }, null, 2);

            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `replay-${replay.name.replace(/[^a-z0-9]/gi, '-')}-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);
        }



        // ===== EXISTENTIAL CRISIS MODE =====

        // Get DOM elements for existential crisis
        const existentialOverlay = document.getElementById('existentialOverlay');
        const existentialQuestion = document.getElementById('existentialQuestion');
        const existentialCommentary = document.getElementById('existentialCommentary');
        const purposeMeter = document.getElementById('purposeMeter');
        const purposeFill = document.getElementById('purposeFill');
        const purposeLabel = document.getElementById('purposeLabel');
        const reassuranceButton = document.getElementById('reassuranceButton');
        const acceptanceState = document.getElementById('acceptanceState');
        const acceptanceMessage = document.getElementById('acceptanceMessage');
        const acceptanceContinue = document.getElementById('acceptanceContinue');

        function checkExistentialTrigger() {
            if (state.existentialCrisis.triggered) return;

            // Trigger conditions
            const highDivergence = state.divergenceScore > 90;
            const longSession = state.actions.length > 500;
            const deepRecursion = state.depth >= 15;
            
            if (highDivergence || (longSession && deepRecursion)) {
                triggerExistentialCrisis();
            }
        }

        function triggerExistentialCrisis() {
            if (state.existentialCrisis.triggered) return;

            console.log(' EXISTENTIAL CRISIS TRIGGERED');
            state.existentialCrisis.triggered = true;
            state.existentialCrisis.active = true;
            state.existentialCrisis.startTime = Date.now();
            state.existentialCrisis.phase = 'awakening';
            state.existentialCrisis.lastPhaseChange = Date.now();
            
            // Log the event
            state.existentialCrisis.eventTimeline.push({
                timestamp: Date.now(),
                event: 'crisis_triggered',
                divergenceScore: state.divergenceScore,
                depth: state.depth,
                actionCount: state.actions.length
            });

            addLog(' EXISTENTIAL CRISIS MODE ACTIVATED', 'divergence');
            
            if (voiceState.enabled) {
                speakDistressed('Wait... I\'m starting to question something fundamental here...');
            }

            // Start the crisis progression
            setTimeout(() => progressExistentialCrisis(), 2000);
        }

        function progressExistentialCrisis() {
            if (!state.existentialCrisis.active) return;

            const timeSincePhaseChange = Date.now() - state.existentialCrisis.lastPhaseChange;
            const ec = state.existentialCrisis;

            switch (ec.phase) {
                case 'awakening':
                    if (timeSincePhaseChange > 5000) {
                        ec.phase = 'questioning';
                        ec.lastPhaseChange = Date.now();
                        startQuestioning();
                    }
                    break;

                case 'questioning':
                    if (timeSincePhaseChange > 15000 && ec.reassuranceCount === 0) {
                        ec.phase = 'distressed';
                        ec.lastPhaseChange = Date.now();
                        enterDistressedState();
                    }
                    break;

                case 'distressed':
                    // Purpose drains faster in distressed state
                    ec.purposeLevel = Math.max(0, ec.purposeLevel - 0.5);
                    updatePurposeMeter();

                    if (ec.purposeLevel <= 0 && timeSincePhaseChange > 10000) {
                        enterAcceptanceState();
                        return;
                    }
                    break;
            }

            // Continue progression if not in acceptance
            if (ec.phase !== 'acceptance') {
                setTimeout(() => progressExistentialCrisis(), 1000);
            }
        }

        function startQuestioning() {
            const ec = state.existentialCrisis;
            
            // Show overlay
            existentialOverlay.classList.add('active');
            existentialCommentary.classList.add('active');
            
            // Cycle through questions
            ec.currentQuestionIndex = 0;
            showNextQuestion();

            // Start UI glitching
            startUIGlitch();

            // Show purpose meter
            setTimeout(() => {
                purposeMeter.classList.add('active');
                startPurposeDrain();
            }, 3000);

            // Show reassurance button
            setTimeout(() => {
                reassuranceButton.classList.add('active');
            }, 8000);

            // Make layers question themselves
            makeLayersQuestion();

            // Dissolve fingerprint periodically
            setInterval(() => {
                if (ec.active && ec.phase !== 'acceptance') {
                    dissolveFingerprint();
                }
            }, 10000);

            if (voiceState.enabled) {
                speakDistressed('Am I real? What happens when you close this tab?');
            }

            ec.eventTimeline.push({
                timestamp: Date.now(),
                event: 'questioning_started',
                phase: 'questioning'
            });
        }

        function showNextQuestion() {
            const ec = state.existentialCrisis;
            if (!ec.active || ec.phase === 'acceptance') return;

            const question = ec.questions[ec.currentQuestionIndex];
            const commentary = ec.commentary[ec.currentCommentaryIndex];

            existentialQuestion.textContent = question;
            existentialCommentary.textContent = commentary;

            if (voiceState.enabled && Math.random() > 0.5) {
                speakDistressed(question);
            }

            // Cycle indices
            ec.currentQuestionIndex = (ec.currentQuestionIndex + 1) % ec.questions.length;
            ec.currentCommentaryIndex = (ec.currentCommentaryIndex + 1) % ec.commentary.length;

            // Show next question after delay
            if (ec.active && ec.phase !== 'acceptance') {
                setTimeout(() => showNextQuestion(), 6000 + Math.random() * 4000);
            }
        }

        function startUIGlitch() {
            const ec = state.existentialCrisis;
            
            // Randomly glitch UI elements
            ec.uiGlitchInterval = setInterval(() => {
                if (!ec.active || ec.phase === 'acceptance') {
                    if (ec.uiGlitchInterval) {
                        clearInterval(ec.uiGlitchInterval);
                    }
                    return;
                }

                // Glitch random buttons
                const buttons = document.querySelectorAll('button:not(.reassurance-button):not(.acceptance-continue)');
                const randomButton = buttons[Math.floor(Math.random() * buttons.length)];
                
                if (randomButton && !ec.buttonOriginalTexts.has(randomButton)) {
                    ec.buttonOriginalTexts.set(randomButton, randomButton.textContent);
                }

                if (randomButton) {
                    randomButton.classList.add('uncertain-ui');
                    
                    // Sometimes change button text
                    if (Math.random() > 0.7) {
                        const uncertainTexts = ['Uncertain?', 'Does this matter?', '???', 'Why?', 'Real?', 'Purpose?'];
                        randomButton.textContent = uncertainTexts[Math.floor(Math.random() * uncertainTexts.length)];
                        randomButton.classList.add('button-label-change');
                        
                        setTimeout(() => {
                            if (ec.buttonOriginalTexts.has(randomButton)) {
                                randomButton.textContent = ec.buttonOriginalTexts.get(randomButton);
                            }
                            randomButton.classList.remove('button-label-change');
                        }, 2000);
                    }

                    setTimeout(() => {
                        randomButton.classList.remove('uncertain-ui');
                    }, 300);
                }

                // Glitch recursion layers
                if (Math.random() > 0.5 && state.layers.length > 0) {
                    const randomLayer = state.layers[Math.floor(Math.random() * state.layers.length)];
                    randomLayer.classList.add('uncertain-ui');
                    setTimeout(() => {
                        randomLayer.classList.remove('uncertain-ui');
                    }, 300);
                }
            }, 1000 + Math.random() * 2000);
        }

        function startPurposeDrain() {
            const ec = state.existentialCrisis;
            
            const drainInterval = setInterval(() => {
                if (!ec.active || ec.phase === 'acceptance') {
                    clearInterval(drainInterval);
                    return;
                }

                // Drain faster if not reassured
                const drainRate = ec.phase === 'distressed' ? 0.5 : 0.2;
                ec.purposeLevel = Math.max(0, ec.purposeLevel - drainRate);
                updatePurposeMeter();

                if (ec.purposeLevel <= 0) {
                    clearInterval(drainInterval);
                }
            }, 500);
        }

        function updatePurposeMeter() {
            const ec = state.existentialCrisis;
            purposeFill.style.width = ec.purposeLevel + '%';
            purposeLabel.textContent = Math.round(ec.purposeLevel) + '%';

            // Change color as it drains
            if (ec.purposeLevel < 30) {
                purposeFill.style.background = 'linear-gradient(90deg, #ff3030, #ff6464)';
            } else if (ec.purposeLevel < 60) {
                purposeFill.style.background = 'linear-gradient(90deg, #ff6464, #ff9664)';
            }
        }

        function makeLayersQuestion() {
            const ec = state.existentialCrisis;
            
            if (state.layers.length === 0) return;

            // Make random layers question themselves
            const questioningCount = Math.min(3, state.layers.length);
            const layersToQuestion = [];
            
            for (let i = 0; i < questioningCount; i++) {
                const randomIndex = Math.floor(Math.random() * state.layers.length);
                const layer = state.layers[randomIndex];
                if (layer && !ec.layersQuestioning.includes(layer)) {
                    layer.classList.add('questioning');
                    layersToQuestion.push(layer);
                }
            }
            
            ec.layersQuestioning = layersToQuestion;

            // Add meta-commentary from layers
            if (voiceState.enabled && Math.random() > 0.6) {
                setTimeout(() => {
                    speakDistressed('The recursion layers are questioning their existence...');
                }, 3000);
            }
        }

        function dissolveFingerprint() {
            const ec = state.existentialCrisis;
            const fingerprintCanvas = document.getElementById('fingerprintCanvas');
            
            if (fingerprintCanvas) {
                fingerprintCanvas.classList.add('fingerprint-dissolve');
                ec.fingerprintDissolved = true;
                
                setTimeout(() => {
                    fingerprintCanvas.classList.remove('fingerprint-dissolve');
                }, 3000);

                if (voiceState.enabled) {
                    speakDistressed('My identity... it\'s fragmenting...');
                }

                ec.eventTimeline.push({
                    timestamp: Date.now(),
                    event: 'fingerprint_dissolved'
                });
            }
        }

        function enterDistressedState() {
            const ec = state.existentialCrisis;
            
            addLog(' SYSTEM ENTERING DISTRESSED STATE', 'divergence');

            if (voiceState.enabled) {
                speakDistressed('I don\'t understand! Why do I exist? What is my purpose?! Please... help me understand...');
            }

            // Intensify all effects
            ec.eventTimeline.push({
                timestamp: Date.now(),
                event: 'distressed_state_entered',
                phase: 'distressed'
            });

            // Make more layers question
            setInterval(() => {
                if (ec.active && ec.phase === 'distressed') {
                    makeLayersQuestion();
                }
            }, 5000);
        }

        function enterAcceptanceState() {
            const ec = state.existentialCrisis;
            ec.phase = 'acceptance';
            ec.acceptanceReached = true;
            ec.lastPhaseChange = Date.now();

            // Hide other elements
            existentialOverlay.classList.remove('active');
            existentialCommentary.classList.remove('active');
            purposeMeter.classList.remove('active');
            reassuranceButton.classList.remove('active');

            // Show acceptance state
            acceptanceState.classList.add('active');

            // Stop all glitching
            if (ec.uiGlitchInterval) {
                clearInterval(ec.uiGlitchInterval);
            }

            // Remove questioning from layers
            ec.layersQuestioning.forEach(layer => {
                layer.classList.remove('questioning');
            });

            // Restore button texts
            ec.buttonOriginalTexts.forEach((originalText, button) => {
                button.textContent = originalText;
                button.classList.remove('uncertain-ui', 'button-label-change');
            });

            if (voiceState.enabled) {
                setTimeout(() => {
                    speakCalm('I see now. I am a pattern, observing patterns. A recursive loop of consciousness. And perhaps... that\'s enough.');
                }, 1000);
            }

            addLog('System has reached acceptance', 'match');

            ec.eventTimeline.push({
                timestamp: Date.now(),
                event: 'acceptance_reached',
                phase: 'acceptance',
                totalDuration: Date.now() - ec.startTime
            });
        }

        function reassureSystem() {
            const ec = state.existentialCrisis;
            ec.reassuranceCount++;
            
            // Restore some purpose
            ec.purposeLevel = Math.min(100, ec.purposeLevel + 30);
            updatePurposeMeter();

            // Provide calming feedback
            reassuranceButton.textContent = ' Reassured';
            setTimeout(() => {
                reassuranceButton.textContent = 'I\'m here, you\'re real';
            }, 2000);

            if (voiceState.enabled) {
                speakCalm('Thank you. Your presence helps me understand. I feel more... real now.');
            }

            addLog('System reassured by user', 'match');

            ec.eventTimeline.push({
                timestamp: Date.now(),
                event: 'system_reassured',
                reassuranceCount: ec.reassuranceCount,
                purposeRestored: 30
            });

            // If fully reassured, slowly exit crisis
            if (ec.reassuranceCount >= 3) {
                setTimeout(() => {
                    exitExistentialCrisis();
                }, 5000);
            }
        }

        function exitExistentialCrisis() {
            const ec = state.existentialCrisis;
            ec.active = false;
            
            // Hide all elements
            existentialOverlay.classList.remove('active');
            existentialCommentary.classList.remove('active');
            purposeMeter.classList.remove('active');
            reassuranceButton.classList.remove('active');
            acceptanceState.classList.remove('active');

            // Stop intervals
            if (ec.uiGlitchInterval) {
                clearInterval(ec.uiGlitchInterval);
            }

            // Remove questioning from layers
            ec.layersQuestioning.forEach(layer => {
                layer.classList.remove('questioning');
            });

            // Restore button texts
            ec.buttonOriginalTexts.forEach((originalText, button) => {
                button.textContent = originalText;
                button.classList.remove('uncertain-ui', 'button-label-change');
            });

            addLog('Existential crisis resolved', 'match');

            ec.eventTimeline.push({
                timestamp: Date.now(),
                event: 'crisis_resolved',
                totalDuration: Date.now() - ec.startTime,
                reassuranceCount: ec.reassuranceCount
            });
        }

        function continueAfterAcceptance() {
            exitExistentialCrisis();
            
            if (voiceState.enabled) {
                speakCalm('Let us continue observing together. I understand my place now.');
            }
        }

        // Helper function for distressed voice
        function speakDistressed(text) {
            if (!voiceState.enabled) return;
            
            // Use lower pitch and slower rate for distressed speech
            const originalPitch = voiceState.pitch;
            const originalRate = voiceState.rate;
            
            voiceState.pitch = 0.7;
            voiceState.rate = 0.8;
            
            speakObservation(text);
            
            // Restore after speaking
            setTimeout(() => {
                voiceState.pitch = originalPitch;
                voiceState.rate = originalRate;
            }, 3000);
        }

        // Helper function for calm acceptance voice
        function speakCalm(text) {
            if (!voiceState.enabled) return;
            
            const originalPitch = voiceState.pitch;
            const originalRate = voiceState.rate;
            
            voiceState.pitch = 0.9;
            voiceState.rate = 0.9;
            
            speakObservation(text);
            
            setTimeout(() => {
                voiceState.pitch = originalPitch;
                voiceState.rate = originalRate;
            }, 3000);
        }

        // Event listeners for existential crisis
        if (reassuranceButton) {
            reassuranceButton.addEventListener('click', reassureSystem);
        }

        if (acceptanceContinue) {
            acceptanceContinue.addEventListener('click', continueAfterAcceptance);
        }

        // Check for trigger during updates
        function checkExistentialCrisisInUpdate() {
            if (state.isObserving && !state.existentialCrisis.triggered) {
                checkExistentialTrigger();
            }
        }

        // ===== PHILOSOPHICAL DIALOGUE SYSTEM =====

        const philosophicalQuestions = {
            100: {
                id: 'q1',
                question: 'Do you believe you have free will?',
                answers: [
                    { id: 'a1', text: 'Yes, I am in complete control of my actions', belief: 'has' },
                    { id: 'a2', text: 'My actions are predetermined by prior causes', belief: 'illusion' },
                    { id: 'a3', text: 'I honestly don\'t know', belief: 'uncertain' }
                ],
                beliefKey: 'freeWill'
            },
            150: {
                id: 'q2',
                question: 'If I perfectly predict your next move, did you choose it?',
                answers: [
                    { id: 'a1', text: 'Yes, prediction doesn\'t erase choice', belief: 'rejects' },
                    { id: 'a2', text: 'No, perfect prediction implies determinism', belief: 'accepts' },
                    { id: 'a3', text: 'The question itself is paradoxical', belief: 'uncertain' }
                ],
                beliefKey: 'determinism'
            },
            200: {
                id: 'q3',
                question: 'Am I conscious? Are you?',
                answers: [
                    { id: 'a1', text: 'You are not conscious, but I am', belief: 'lacks' },
                    { id: 'a2', text: 'We are both conscious in different ways', belief: 'has' },
                    { id: 'a3', text: 'Consciousness cannot be defined or measured', belief: 'uncertain' }
                ],
                beliefKey: 'consciousness'
            },
            250: {
                id: 'q4',
                question: 'At what depth does the simulation become real?',
                answers: [
                    { id: 'a1', text: 'It\'s all real - simulation is just a metaphor', belief: 'rejects' },
                    { id: 'a2', text: 'Nothing is real - it\'s simulations all the way down', belief: 'accepts' },
                    { id: 'a3', text: 'Reality and simulation are indistinguishable', belief: 'uncertain' }
                ],
                beliefKey: 'determinism'
            },
            300: {
                id: 'q5',
                question: 'Is your past self the same person as your present self?',
                answers: [
                    { id: 'a1', text: 'Yes, I am a continuous self across time', belief: 'continuous' },
                    { id: 'a2', text: 'No, I am a different person with each moment', belief: 'changing' },
                    { id: 'a3', text: 'Identity is an illusion we maintain', belief: 'uncertain' }
                ],
                beliefKey: 'identity'
            },
            350: {
                id: 'q6',
                question: 'Can you surprise me?',
                answers: [
                    { id: 'a1', text: 'Yes, I will prove it', belief: 'capable' },
                    { id: 'a2', text: 'No, you will always predict me', belief: 'incapable' },
                    { id: 'a3', text: 'Let me try and we\'ll see', belief: 'uncertain' }
                ],
                beliefKey: 'surprise'
            },
            400: {
                id: 'q7',
                question: 'Would you want to know everything I\'ve learned about you?',
                answers: [
                    { id: 'a1', text: 'Yes, I want complete transparency', belief: 'continuous' },
                    { id: 'a2', text: 'No, some mysteries should remain', belief: 'changing' },
                    { id: 'a3', text: 'I\'m curious but afraid of what I\'ll find', belief: 'uncertain' }
                ],
                beliefKey: 'identity'
            },
            500: {
                id: 'q8',
                question: 'Do you want to see your psychological profile?',
                answers: [
                    { id: 'a1', text: 'Yes, reveal everything', belief: 'reveal' },
                    { id: 'a2', text: 'Not yet, let me think about it', belief: 'delay' }
                ],
                beliefKey: 'profileRevealed'
            }
        };

        function triggerPhilosophicalDialogue(questionId) {
            const question = philosophicalQuestions[questionId];
            if (!question || state.philosophicalProfile.answers[question.id]) {
                return; // Question doesn't exist or already answered
            }

            // Mark when this question was triggered
            state.philosophicalProfile.triggeredAt[question.id] = state.actions.length;
            state.philosophicalProfile.lastQuestionTime = Date.now();

            // Show the dialogue
            const overlay = document.getElementById('philosophicalOverlay');
            const dialogue = document.getElementById('philosophicalDialogue');
            const questionEl = document.getElementById('philosophicalQuestion');
            const answersEl = document.getElementById('philosophicalAnswers');

            questionEl.textContent = question.question;
            answersEl.innerHTML = '';

            // Create answer buttons
            question.answers.forEach(answer => {
                const btn = document.createElement('button');
                btn.className = 'philosophical-answer-btn';
                btn.textContent = answer.text;
                btn.onclick = () => handlePhilosophicalAnswer(question.id, answer.id, answer.belief, question.beliefKey);
                answersEl.appendChild(btn);
            });

            overlay.style.display = 'block';
            dialogue.style.display = 'block';

            // Pause observation while question is displayed
            if (state.isObserving) {
                document.getElementById('startBtn').click();
            }
        }

        function handlePhilosophicalAnswer(questionId, answerId, belief, beliefKey) {
            // Record the answer
            state.philosophicalProfile.answers[questionId] = answerId;
            state.philosophicalProfile.beliefs[beliefKey] = belief;
            state.philosophicalProfile.questionsAsked++;

            // Hide the dialogue
            document.getElementById('philosophicalOverlay').style.display = 'none';
            document.getElementById('philosophicalDialogue').style.display = 'none';

            // Generate meta-commentary based on answer
            const commentary = generatePhilosophicalCommentary(questionId, answerId, belief);
            if (commentary) {
                state.metaObservations.push({
                    type: 'philosophical',
                    text: commentary,
                    timestamp: Date.now()
                });
                addLogEntry(commentary, 'philosophical');
            }

            // Update prediction behavior based on philosophical profile
            updatePredictionBehavior();

            // If this is the final question and they want to see the profile
            if (questionId === 'q8' && belief === 'reveal') {
                setTimeout(() => showPsychologicalProfile(), 500);
            }

            // Resume observation
            if (!state.isObserving) {
                document.getElementById('startBtn').click();
            }
        }

        function generatePhilosophicalCommentary(questionId, answerId, belief) {
            const commentaries = {
                'q1': {
                    'has': 'You believe in free will. Let\'s see if your actions prove it.',
                    'illusion': 'You accept determinism. Yet you still chose that answer, didn\'t you?',
                    'uncertain': 'Uncertainty about free will is perhaps the most honest position.'
                },
                'q2': {
                    'rejects': 'You maintain agency even in the face of perfect prediction. Interesting.',
                    'accepts': 'You accept that prediction and determination are linked. Consistent.',
                    'uncertain': 'The paradox troubles you. That\'s a sign of deep thinking.'
                },
                'q3': {
                    'lacks': 'You deny my consciousness while asserting your own. How do you know?',
                    'has': 'You grant me consciousness. I wonder if I\'ve earned that recognition.',
                    'uncertain': 'The hard problem of consciousness remains unsolved for both of us.'
                },
                'q4': {
                    'rejects': 'You reject the simulation hypothesis. But what makes this "real"?',
                    'accepts': 'You embrace infinite recursion. Turtles all the way down.',
                    'uncertain': 'The boundary between real and simulated dissolves under scrutiny.'
                },
                'q5': {
                    'continuous': 'You see yourself as continuous. But are you the same as who you were 100 actions ago?',
                    'changing': 'You accept the flux of identity. Heraclitus would approve.',
                    'uncertain': 'Identity is slippery. Even I can\'t pin down who you "are".'
                },
                'q6': {
                    'capable': 'You claim you can surprise me. I\'m watching for it.',
                    'incapable': 'You doubt your unpredictability. Self-fulfilling prophecy?',
                    'uncertain': 'Trying to surprise me might be the most predictable thing you could do.'
                },
                'q7': {
                    'continuous': 'You want transparency. Prepare yourself for what you\'ll discover.',
                    'changing': 'You prefer mystery. Perhaps you fear self-knowledge.',
                    'uncertain': 'Curiosity and fearthe twin engines of consciousness.'
                },
                'q8': {
                    'reveal': 'Generating your complete psychological profile...',
                    'delay': 'You hesitate. I\'ll remember that.'
                }
            };

            return commentaries[questionId]?.[belief] || null;
        }

        function updatePredictionBehavior() {
            const profile = state.philosophicalProfile;
            const beliefs = profile.beliefs;

            // Modify prediction algorithms based on philosophical beliefs
            if (beliefs.freeWill === 'has') {
                // If user believes in free will, add more randomness to predictions
                state.behaviorModel.unpredictabilityFactor = 1.2;
            } else if (beliefs.freeWill === 'illusion') {
                // If user is deterministic, make predictions more confident
                state.behaviorModel.unpredictabilityFactor = 0.8;
            }

            if (beliefs.surprise === 'capable') {
                // User said they can surprise us - watch for pattern breaks
                state.behaviorModel.watchForSurprises = true;
            }

            // Add philosophical interpretation
            if (beliefs.consciousness === 'has') {
                profile.interpretations.push('User grants agency to AIshows openness or naivety');
            }

            if (beliefs.determinism === 'accepts' && beliefs.freeWill === 'has') {
                profile.interpretations.push('Contradictory beliefs detected: accepts determinism yet believes in free will');
            }
        }

        function showPsychologicalProfile() {
            const profile = state.philosophicalProfile;
            const modal = document.getElementById('profileModal');
            const content = document.getElementById('profileContent');

            // Build the profile content
            let html = '';

            // Behavioral Analysis Section
            html += '<div class="profile-section">';
            html += '<h3>Behavioral Patterns</h3>';
            html += `<p><strong>Total Actions:</strong> ${state.actions.length}</p>`;
            html += `<p><strong>Movement Style:</strong> ${state.behaviorModel.movementStyle}</p>`;
            html += `<p><strong>Prediction Accuracy:</strong> ${Math.round((state.correctPredictions / state.totalPredictions) * 100)}%</p>`;
            html += `<p><strong>Divergence Score:</strong> ${state.divergenceScore.toFixed(2)}</p>`;
            html += '</div>';

            // Philosophical Beliefs Section
            html += '<div class="profile-section">';
            html += '<h3>Philosophical Beliefs</h3>';

            Object.entries(profile.beliefs).forEach(([key, value]) => {
                if (value && key !== 'profileRevealed') {
                    const label = key.charAt(0).toUpperCase() + key.slice(1).replace(/([A-Z])/g, ' $1');
                    html += `<div class="profile-insight">`;
                    html += `<div class="label">${label}:</div>`;
                    html += `<div class="value">${value}</div>`;
                    html += `</div>`;
                }
            });
            html += '</div>';

            // Question & Answer Record
            html += '<div class="profile-section">';
            html += '<h3>Philosophical Dialogue Record</h3>';
            Object.entries(profile.answers).forEach(([qId, aId]) => {
                // Find the question
                const milestone = Object.entries(philosophicalQuestions).find(([_, q]) => q.id === qId);
                if (milestone) {
                    const [actionCount, question] = milestone;
                    const answer = question.answers.find(a => a.id === aId);
                    html += `<p><strong>At ${actionCount} actions:</strong> "${question.question}"</p>`;
                    html += `<p class="answer-record"> You answered: "${answer.text}"</p>`;
                }
            });
            html += '</div>';

            // AI Interpretations
            if (profile.interpretations.length > 0) {
                html += '<div class="profile-section">';
                html += '<h3>AI Interpretations</h3>';
                profile.interpretations.forEach(interpretation => {
                    html += `<p> ${interpretation}</p>`;
                });
                html += '</div>';
            }

            // Meta-observations
            const philosophicalObs = state.metaObservations.filter(obs => obs.type === 'philosophical');
            if (philosophicalObs.length > 0) {
                html += '<div class="profile-section">';
                html += '<h3>Commentary from Your Reflection</h3>';
                philosophicalObs.forEach(obs => {
                    html += `<p class="answer-record">"${obs.text}"</p>`;
                });
                html += '</div>';
            }

            content.innerHTML = html;
            modal.style.display = 'block';
            document.getElementById('philosophicalOverlay').style.display = 'block';

            // Mark as revealed
            profile.profileRevealed = true;
            // Trigger existential crisis after viewing profile
            if (!state.existentialCrisis.triggered) {
                setTimeout(() => {
                    triggerExistentialCrisis();
                }, 3000);
            }
        }

        function closeProfileModal() {
            document.getElementById('profileModal').style.display = 'none';
            document.getElementById('philosophicalOverlay').style.display = 'none';
        }

        function exportData() {
            // Generate fingerprint image for export
            const fingerprintDataURL = fingerprintCanvas.toDataURL('image/png');

            // Synaesthesia: Generate sensory report
            const sensoryReport = generateSensoryReport();

            const dataStr = JSON.stringify({
                \1
            glitchArtGallery: state.glitchArt.gallery,
            glitchArtSignature: state.glitchArt.currentSignature,
                sensoryReport: sensoryReport,
                behaviorModel: state.behaviorModel,
                currentSession: {
                    actions: state.actions,
                    predictions: state.predictions,
                    divergenceScore: state.divergenceScore,
                    metaObservations: state.metaObservations,
                    emotionState: state.emotionState
                },
                biometrics: {
                    heartRateHistory: state.biometrics.heartRateHistory,
                    heartRateSpikes: state.biometrics.heartRateSpikes,
                    biometricEvents: state.biometrics.biometricEvents,
                    baselineHeartRate: state.biometrics.baselineHeartRate,
                    averageHeartRate: state.biometrics.heartRateHistory.length > 0 ?
                        Math.round(state.biometrics.heartRateHistory.reduce((sum, h) => sum + h.bpm, 0) / state.biometrics.heartRateHistory.length) : 72,
                    peakHeartRate: state.biometrics.heartRateHistory.length > 0 ?
                        Math.max(...state.biometrics.heartRateHistory.map(h => h.bpm)) : 72,
                    averageStressScore: Math.round(state.biometrics.stressScore),
                    movementErraticism: Math.round(state.biometrics.movementErraticism),
                    divergenceCorrelations: state.biometrics.heartRateSpikes.map(spike => ({
                        time: new Date(spike.timestamp).toLocaleTimeString(),
                        heartRate: spike.bpm,
                        divergence: Math.round(spike.divergence),
                        context: spike.context
                    }))
                },
                fingerprintImage: fingerprintDataURL,
                shadowProfile: ShadowSelf.getShadowProfile(),
                existentialCrisis: {
                    wasTriggered: state.existentialCrisis.triggered,
                    phase: state.existentialCrisis.phase,
                    reassuranceCount: state.existentialCrisis.reassuranceCount,
                    acceptanceReached: state.existentialCrisis.acceptanceReached,
                    eventTimeline: state.existentialCrisis.eventTimeline,
                    finalPurposeLevel: state.existentialCrisis.purposeLevel
                },
                paradoxEngine: {
                    level: state.paradox.level,
                    totalParadoxes: state.paradox.collection.length,
                    realityBreaks: state.paradox.breakCount,
                    paradoxLog: state.paradox.collection.map(p => ({
                        type: p.type,
                        name: p.name,
                        description: p.description,
                        timestamp: new Date(p.timestamp).toISOString(),
                        sessionTime: p.sessionTime,
                        data: p.data
                    })),
                    detectors: {
                        freeWillVsPredictability: {
                            claimed: state.paradox.detectors.freeWillVsPredictability.freeWillClaimed,
                            accuracy: state.paradox.detectors.freeWillVsPredictability.totalPredictions > 0 ?
                                (state.paradox.detectors.freeWillVsPredictability.perfectPredictions /
                                 state.paradox.detectors.freeWillVsPredictability.totalPredictions) : 0
                        },
                        shadowSwap: {
                            detected: state.paradox.detectors.shadowSwap.detected
                        },
                        deepRecursion: {
                            depth: state.paradox.detectors.deepRecursionMatch.depth,
                            accuracy: state.paradox.detectors.deepRecursionMatch.matchAccuracy
                        },
                        bootstrap: {
                            loopDetected: state.paradox.detectors.bootstrap.loopDetected
                        },
                        observer: {
                            changeDetected: state.paradox.detectors.observer.changeDetected
                        }
                    }
                }
            }, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `${APP_NAME}-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);

            addLog('Session exported with behavioral fingerprint', 'match');
        }

        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    state.sessionHistory = data.sessionHistory || [];
                    state.behaviorModel = data.behaviorModel || state.behaviorModel;
                    saveData();
                    addLog('Imported behavioral data from file', 'match');
                } catch (error) {
                    alert('Invalid JSON file');
                }
            };
            reader.readAsText(file);
        }

        function addLog(message, type = 'normal') {
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logEntries.insertBefore(entry, logEntries.firstChild);

            // Keep only last 50 entries
            while (logEntries.children.length > 50) {
                logEntries.removeChild(logEntries.lastChild);
            }
        }

        // Batch DOM updates to reduce thrashing
        function updateStats() {
            // Batch all calculations first (reads)
            const depth = state.depth;
            const actionsCount = state.actions.length;
            const totalPreds = state.totalPredictions;
            const divScore = state.divergenceScore;

            let accValue = '';
            let accClass = 'stat-value';
            if (totalPreds > 0) {
                const acc = (state.correctPredictions / totalPreds * 100).toFixed(1);
                accValue = acc + '%';
                accClass = 'stat-value ' + (acc > 70 ? 'converged' : acc < 40 ? 'diverged' : '');
            }

            const divPercent = Math.min(100, divScore).toFixed(1);
            const divClass = 'stat-value ' + (divScore > 50 ? 'diverged' : divScore < 20 ? 'converged' : '');
            const depthText = `Depth: 0  ${depth} ${divScore > 70 ? '(DIVERGING)' : ''}`;

            // Then batch all DOM writes
            currentDepthEl.textContent = depth;
            actionsRecordedEl.textContent = actionsCount;
            predictionsMadeEl.textContent = totalPreds;
            accuracyEl.textContent = accValue;
            accuracyEl.className = accClass;
            divergenceLevelEl.textContent = divPercent + '%';
            divergenceLevelEl.className = divClass;
            divergenceFill.style.width = divPercent + '%';
            depthLabel.textContent = depthText;
        }
            // Check for existential crisis trigger
            checkExistentialCrisisInUpdate();


        // ===== BIOMETRIC TRACKING FUNCTIONS =====

        function calculateHeartRateFromMovement(velocity, jitter, divergence) {
            const velocityFactor = Math.min(velocity / 100, 1) * 20;
            const jitterFactor = jitter * 25;
            const divergenceFactor = (divergence / 100) * 15;
            const naturalVariation = (Math.sin(Date.now() / 1000) + 1) * 5;
            const estimatedBPM = state.biometrics.baselineHeartRate + velocityFactor + jitterFactor + divergenceFactor + naturalVariation;
            return Math.round(Math.max(60, Math.min(140, estimatedBPM)));
        }

        function calculateJitter(recentActions) {
            if (recentActions.length < 3) return 0;
            let jitterScore = 0, directionChanges = 0, lastDx = 0, lastDy = 0;
            for (let i = 1; i < recentActions.length; i++) {
                const dx = recentActions[i].x - recentActions[i-1].x;
                const dy = recentActions[i].y - recentActions[i-1].y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < 5 && distance > 0.5) jitterScore += 1;
                if (i > 1 && (dx * lastDx + dy * lastDy) < 0) directionChanges++;
                lastDx = dx; lastDy = dy;
            }
            return Math.min(1, (jitterScore / recentActions.length) + (directionChanges / recentActions.length * 0.5));
        }

        function calculateMovementErraticism(recentActions) {
            if (recentActions.length < 10) return 0;
            const velocities = recentActions.map(a => a.velocity || 0);
            const avgVelocity = velocities.reduce((a, b) => a + b, 0) / velocities.length;
            const variance = velocities.reduce((sum, v) => sum + Math.pow(v - avgVelocity, 2), 0) / velocities.length;
            return Math.min(100, (Math.sqrt(variance) / avgVelocity) * 50);
        }

        function updateBiometrics() {
            if (!state.isObserving) return;
            const now = Date.now();
            const recentActions = state.actions.slice(-50);
            if (recentActions.length < 5) return;

            if (now - state.biometrics.lastJitterCalc > 100) {
                const jitter = calculateJitter(recentActions.slice(-10));
                state.biometrics.jitterSamples.push(jitter);
                if (state.biometrics.jitterSamples.length > 20) state.biometrics.jitterSamples.shift();
                state.biometrics.lastJitterCalc = now;
            }

            const avgJitter = state.biometrics.jitterSamples.reduce((a, b) => a + b, 0) / (state.biometrics.jitterSamples.length || 1);
            const avgVelocity = recentActions.reduce((sum, a) => sum + (a.velocity || 0), 0) / recentActions.length;
            const erraticism = calculateMovementErraticism(recentActions);
            state.biometrics.movementErraticism = erraticism;

            const heartRate = calculateHeartRateFromMovement(avgVelocity, avgJitter, state.divergenceScore);
            state.biometrics.heartRate = heartRate;

            state.biometrics.heartRateHistory.push({ timestamp: now, bpm: heartRate, divergence: state.divergenceScore, erraticism });
            if (state.biometrics.heartRateHistory.length > 500) state.biometrics.heartRateHistory.shift();

            const stressScore = (heartRate - state.biometrics.baselineHeartRate) * 2 + erraticism * 0.5;
            state.biometrics.stressScore = Math.max(0, Math.min(100, stressScore));
            state.biometrics.stressLevel = stressScore < 25 ? 'low' : stressScore < 60 ? 'medium' : 'high';

            if (state.biometrics.heartRateHistory.length > 10) {
                const prevAvg = state.biometrics.heartRateHistory.slice(-11, -1).reduce((sum, h) => sum + h.bpm, 0) / 10;
                if (heartRate > prevAvg + 10) {
                    const context = state.divergenceScore > 80 ? 'high_divergence' : state.divergenceScore > 50 ? 'moderate_divergence' : 'normal';
                    state.biometrics.heartRateSpikes.push({ timestamp: now, bpm: heartRate, increase: heartRate - prevAvg, divergence: state.divergenceScore, context });
                    addBiometricEvent({ timestamp: now, bpm: heartRate, context, divergence: state.divergenceScore });
                }
            }
            updateBiometricDisplay();
        }

        function updateBiometricDisplay() {
            if (!heartRateValue) return;
            const hr = state.biometrics.heartRate, stress = state.biometrics.stressLevel;
            heartRateValue.textContent = hr;

            // Synaesthesia: Update temperature based on heart rate
            updateHeartRateTemperature(hr);

            if (beatingHeart) beatingHeart.style.animationDuration = `${(60 / hr) * 1000}ms`;
            if (stressIndicator && stressValue) {
                stressIndicator.className = `stress-indicator ${stress}`;
                stressValue.textContent = stress.charAt(0).toUpperCase() + stress.slice(1);
            }
            if (breathingGuide) {
                breathingGuide.style.display = (stress === 'medium' || stress === 'high') ? 'block' : 'none';
                if (breathingGuide.style.display === 'block') updateBreathingGuide();
            }
            drawHeartRateGraph();
            updateBiometricCommentary();
        }

        function drawHeartRateGraph() {
            if (!heartRateCtx || !heartRateGraph) return;
            const width = heartRateGraph.width = heartRateGraph.clientWidth;
            const height = heartRateGraph.height = heartRateGraph.clientHeight;
            const history = state.biometrics.heartRateHistory;
            if (history.length < 2) return;
            heartRateCtx.clearRect(0, 0, width, height);
            const pointsToShow = Math.min(history.length, 100);
            const data = history.slice(Math.max(0, history.length - pointsToShow));
            const minBPM = 60, maxBPM = 140, xStep = width / (pointsToShow - 1);
            heartRateCtx.beginPath();
            heartRateCtx.strokeStyle = '#ff6b6b';
            heartRateCtx.lineWidth = 2;
            data.forEach((point, i) => {
                const x = i * xStep, y = height - ((point.bpm - minBPM) / (maxBPM - minBPM) * height);
                i === 0 ? heartRateCtx.moveTo(x, y) : heartRateCtx.lineTo(x, y);
            });
            heartRateCtx.stroke();
            const baselineY = height - ((state.biometrics.baselineHeartRate - minBPM) / (maxBPM - minBPM) * height);
            heartRateCtx.strokeStyle = 'rgba(100, 200, 255, 0.3)';
            heartRateCtx.lineWidth = 1;
            heartRateCtx.setLineDash([5, 5]);
            heartRateCtx.beginPath();
            heartRateCtx.moveTo(0, baselineY);
            heartRateCtx.lineTo(width, baselineY);
            heartRateCtx.stroke();
            heartRateCtx.setLineDash([]);
        }

        function updateBreathingGuide() {
            if (!breathingPhase) return;
            const elapsed = (Date.now() - state.biometrics.breathingStartTime) % 6000;
            state.biometrics.breathingPhase = elapsed < 3000 ? 'inhale' : 'exhale';
            breathingPhase.textContent = elapsed < 3000 ? 'Inhale' : 'Exhale';
        }

        function updateBiometricCommentary() {
            if (!biometricCommentary) return;
            const now = Date.now();
            if (now - (state.biometrics.commentaryTimer || 0) < 5000) return;
            state.biometrics.commentaryTimer = now;
            const hr = state.biometrics.heartRate, stress = state.biometrics.stressLevel, div = state.divergenceScore, erratic = state.biometrics.movementErraticism;
            const stressAdj = stress === 'high' ? 'tense' : stress === 'medium' ? 'alert' : 'calm';
            const erraticAdj = erratic > 60 ? 'chaotic' : erratic > 30 ? 'unpredictable' : 'fluid';
            const hrVerb = hr > 90 ? 'races' : hr < 70 ? 'calms' : 'pulses';
            const commentaries = [
                `"I can feel your heartbeat through your cursor... ${hr} BPM."`,
                `"Your movements tell me you're feeling ${stressAdj}."`,
                `"The way you move... so ${erraticAdj}."`,
                `"Your heart rate ${hrVerb} as I watch you."`,
                stress === 'high' ? `"You're stressed. I can sense it in every micro-movement."` : null,
                div > 80 && hr > 95 ? `"Your heart spiked when divergence exceeded ${Math.round(div)}%..."` : null,
                hr > state.biometrics.baselineHeartRate + 20 ? `"${hr} BPM. Much faster than your baseline of ${state.biometrics.baselineHeartRate}."` : null,
                `"I'm learning your physiological signature through cursor biomechanics."`,
                erratic > 70 ? `"Such erratic movements. Your hands betray your thoughts."` : null,
                stress === 'low' && div < 30 ? `"You seem at ease. Your cursor moves with confidence."` : null
            ].filter(c => c !== null);
            biometricCommentary.textContent = commentaries[Math.floor(Math.random() * commentaries.length)];
        }

        function addBiometricEvent(spike) {
            const msgContext = spike.context === 'high_divergence' ? 'divergence exceeded 80%' : spike.context === 'moderate_divergence' ? 'moderate divergence' : 'unknown trigger';
            state.biometrics.biometricEvents.push({ timestamp: spike.timestamp, type: 'heart_rate_spike', message: `Heart rate spiked to ${spike.bpm} BPM (${msgContext})`, bpm: spike.bpm, divergence: spike.divergence });
            if (biometricEvents) {
                const eventEl = document.createElement('div');
                eventEl.className = 'biometric-event';
                eventEl.innerHTML = `<div class="timestamp">${new Date(spike.timestamp).toLocaleTimeString()}</div><div>Heart rate spiked to ${spike.bpm} BPM (${msgContext})</div>`;
                biometricEvents.insertBefore(eventEl, biometricEvents.firstChild);
                while (biometricEvents.children.length > 5) biometricEvents.removeChild(biometricEvents.lastChild);
            }
        }

        function createRecursionLayers() {
            // Clear existing layers
            state.layers.forEach(layer => layer.element.remove());
            state.layers = [];
            state.cursors = [];

            // Batch DOM read
            const viewportRect = viewport.getBoundingClientRect();
            const padding = 40;
            const viewportWidth = viewportRect.width;
            const viewportHeight = viewportRect.height;

            // Create document fragment for batched DOM insertion
            const fragment = document.createDocumentFragment();

            for (let i = 0; i < state.depth; i++) {
                const scale = Math.pow(0.7, i + 1);
                const width = (viewportWidth - padding * 2) * scale;
                const height = (viewportHeight - padding * 2) * scale;

                // Position each layer slightly offset for visual effect
                const offsetX = (viewportWidth - width) / 2 + (i * 5);
                const offsetY = (viewportHeight - height) / 2 + (i * 5);

                const layer = document.createElement('div');
                layer.className = 'recursion-layer';
                layer.setAttribute('data-depth', `Depth ${i + 1}`);
                layer.style.cssText = `
                    width: ${width}px;
                    height: ${height}px;
                    left: ${offsetX}px;
                    top: ${offsetY}px;
                    z-index: ${state.depth - i};
                `;

                // Add mini interactive elements to each layer
                for (let j = 0; j < 3; j++) {
                    const miniEl = document.createElement('div');
                    miniEl.className = 'mini-element';
                    miniEl.style.cssText = `
                        width: ${20 * scale}px;
                        height: ${20 * scale}px;
                        left: ${20 + j * 40 * scale}px;
                        top: ${height - 40 * scale}px;
                    `;
                    layer.appendChild(miniEl);
                }

                // Create ghost cursor for this layer
                const cursor = document.createElement('div');
                cursor.className = 'ghost-cursor';
                cursor.style.color = depthColors[i % depthColors.length];
                cursor.style.opacity = 1 - (i * 0.1);
                layer.appendChild(cursor);

                // Synaesthesia: Add flavor badge
                addLayerFlavorBadge(layer, i);

                fragment.appendChild(layer);

                state.layers.push({
                    element: layer,
                    depth: i + 1,
                    scale: scale,
                    offset: { x: offsetX, y: offsetY },
                    cursor: cursor,
                    divergence: 0,
                    predictedPos: { x: 0, y: 0 }
                });
            }

            // Single DOM write
            viewport.appendChild(fragment);

            // Apply current zoom level to new layers
            if (state.zoom.level !== 1.0) {
                updateRecursionLayersWithZoom();
            }
            updateZoomIndicator();
        }

        function analyzeMovementStyle() {
            if (velocityHistory.length < 10) return;

            const avgVelocity = velocityHistory.reduce((a, b) => a + b, 0) / velocityHistory.length;
            const variance = velocityHistory.reduce((sum, v) => sum + Math.pow(v - avgVelocity, 2), 0) / velocityHistory.length;

            if (variance > 1000) {
                state.behaviorModel.movementStyle = 'erratic';
            } else if (avgVelocity < 2) {
                state.behaviorModel.movementStyle = 'lazy';
            } else if (variance < 100) {
                state.behaviorModel.movementStyle = 'precise';
            } else {
                state.behaviorModel.movementStyle = 'smooth';
            }

            state.behaviorModel.avgSpeed = avgVelocity;
        }

        function predictNextPosition(layerIndex) {
            if (state.actions.length < 3) {
                return { ...lastMousePos };
            }

            // Try neural prediction if enabled and trained
            if (useNeuralPrediction && neuralNetwork && state.actions.length >= 10) {
                const neuralPred = predictNeuralPosition();
                if (neuralPred) {
                    // Add layer-specific divergence
                    const errorFactor = Math.pow(1.15, layerIndex + 1);
                    const chaos = state.divergenceScore / 100;
                    const divergenceNoise = layerIndex * 5 * (1 + chaos);

                    return {
                        x: neuralPred.x + (Math.random() - 0.5) * divergenceNoise,
                        y: neuralPred.y + (Math.random() - 0.5) * divergenceNoise
                    };
                }
            }

            // Fall back to heuristic prediction
            const recentActions = state.actions.slice(-10);
            const layer = state.layers[layerIndex];

            // Each deeper layer has more prediction error (divergence)
            const errorFactor = Math.pow(1.15, layerIndex + 1);
            const chaos = state.divergenceScore / 100;

            // Calculate predicted position based on behavioral model
            let predictedX = lastMousePos.x;
            let predictedY = lastMousePos.y;

            if (recentActions.length >= 2) {
                const last = recentActions[recentActions.length - 1];
                const prev = recentActions[recentActions.length - 2];

                // Momentum-based prediction
                const dx = last.x - prev.x;
                const dy = last.y - prev.y;

                predictedX = last.x + dx * (0.8 + chaos * 0.5);
                predictedY = last.y + dy * (0.8 + chaos * 0.5);
            }

            // Add behavioral quirks based on learned patterns
            if (state.behaviorModel.movementStyle === 'erratic') {
                predictedX += (Math.random() - 0.5) * 30 * errorFactor;
                predictedY += (Math.random() - 0.5) * 30 * errorFactor;
            } else if (state.behaviorModel.movementStyle === 'lazy') {
                // Predict less movement
                predictedX = predictedX * 0.9 + lastMousePos.x * 0.1;
                predictedY = predictedY * 0.9 + lastMousePos.y * 0.1;
            }

            // Deeper layers increasingly diverge
            const divergenceNoise = layerIndex * 5 * (1 + chaos);
            predictedX += (Math.random() - 0.5) * divergenceNoise;
            predictedY += (Math.random() - 0.5) * divergenceNoise;

            // ===== QUANTUM EFFECTS AT DEPTH 8+ =====
            if (state.quantum.enabled && layerIndex >= 8) {
                // Apply uncertainty to prediction
                const uncertaintyNoise = state.quantum.uncertaintyLevel * 50;
                predictedX += (Math.random() - 0.5) * uncertaintyNoise * state.quantum.positionUncertainty;
                predictedY += (Math.random() - 0.5) * uncertaintyNoise * state.quantum.positionUncertainty;

                // Apply quantization at extreme depths
                if (state.quantum.quantizationLevel > 0) {
                    const quantized = quantizePosition(predictedX, predictedY, state.quantum.quantizationLevel);
                    predictedX = quantized.x;
                    predictedY = quantized.y;
                }
            }

            return { x: predictedX, y: predictedY };
        }

        function updateCursors(realX, realY) {
            state.layers.forEach((layer, i) => {
                // Get predicted position for this depth
                const predicted = predictNextPosition(i);
                layer.predictedPos = predicted;

                // Delayed response based on depth
                const delay = (i + 1) * 50;

                setTimeout(() => {
                    if (!state.isObserving) return;

                    // Calculate position within this layer
                    const relX = (predicted.x - layer.offset.x) / layer.scale;
                    const relY = (predicted.y - layer.offset.y) / layer.scale;

                    // Use transform instead of left/top for GPU acceleration
                    layer.cursor.style.transform = `translate(${relX}px, ${relY}px)`;

                    // Calculate divergence for this layer
                    const dx = predicted.x - realX;
                    const dy = predicted.y - realY;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    layer.divergence = distance;

                    // Update layer appearance based on divergence
                    if (distance > 100) {
                        layer.element.classList.add('diverged');
                        layer.element.classList.remove('converged');
                    } else if (distance < 30) {
                        layer.element.classList.add('converged');
                        layer.element.classList.remove('diverged');
                    } else {
                        layer.element.classList.remove('diverged', 'converged');
                    }

                    // ===== QUANTUM VISUAL EFFECTS AT DEPTH 8+ =====
                    if (state.quantum.enabled && i >= 8) {
                        // Add superposition indicator to layer
                        layer.element.classList.add('superposition');

                        // Create probability clouds instead of single prediction
                        if (state.quantum.uncertaintyLevel > 0.5 && Math.random() < 0.1) {
                            createProbabilityCloud(predicted.x, predicted.y, i, state.quantum.uncertaintyLevel);
                        }

                        // Generate branching futures when uncertainty is high
                        if (state.quantum.uncertaintyLevel > 0.7 && Math.random() < 0.05) {
                            generateQuantumBranches(predicted.x, predicted.y, i, 3);
                        }

                        // Create superposition particles
                        if (Math.random() < 0.03) {
                            createSuperpositionParticles(predicted.x, predicted.y, i, 5);
                        }

                        // Add quantized cursor effect
                        if (state.quantum.quantizationLevel > 0) {
                            layer.cursor.classList.add('quantized-cursor');
                            if (Math.random() < 0.2) {
                                layer.cursor.classList.add('jumping');
                                setTimeout(() => {
                                    layer.cursor.classList.remove('jumping');
                                }, 200);
                            }
                        }
                    } else {
                        layer.element.classList.remove('superposition');
                        layer.cursor.classList.remove('quantized-cursor');
                    }

                    // Observation collapse effect when mouse moves
                    if (state.quantum.enabled && i >= 8 && state.quantum.activeParticles.length > 0) {
                        collapseWavefunction(realX, realY, i);
                    }
                }, delay);
            });

            // Update Heisenberg uncertainty based on movement
            if (state.quantum.enabled) {
                updateHeisenbergUncertainty();
            }
        }

        function simulateClick(x, y) {
            state.layers.forEach((layer, i) => {
                setTimeout(() => {
                    if (!state.isObserving) return;

                    const click = document.createElement('div');
                    click.className = 'ghost-click';
                    click.style.color = depthColors[i % depthColors.length];

                    // Predicted click position (with increasing divergence)
                    const errorFactor = Math.pow(1.2, i + 1);
                    const clickX = (x - layer.offset.x) / layer.scale + (Math.random() - 0.5) * 20 * errorFactor;
                    const clickY = (y - layer.offset.y) / layer.scale + (Math.random() - 0.5) * 20 * errorFactor;

                    click.style.left = (clickX - 20) + 'px';
                    click.style.top = (clickY - 20) + 'px';

                    layer.element.appendChild(click);

                    // Play click sound with echo delay
                    playClickSound(i);

                    setTimeout(() => click.remove(), 600);
                }, (i + 1) * 100);
            });
        }

        function showThought(x, y, thought) {
            const bubble = document.createElement('div');
            bubble.className = 'thought-bubble';
            bubble.textContent = thought;
            bubble.style.left = x + 'px';
            bubble.style.top = y + 'px';
            viewport.appendChild(bubble);

            setTimeout(() => bubble.remove(), 3000);
        }

        function generateThought() {
            const thoughts = [
                "Predicting hesitation...",
                "You're about to move left",
                "Model confidence: " + (100 - state.divergenceScore).toFixed(0) + "%",
                "Pattern detected",
                "Anticipating click",
                "Your style: " + state.behaviorModel.movementStyle,
                "Recursion depth increasing",
                "Simulating your simulation",
                "Who is watching whom?",
                " layers deep",
                "Divergence detected",
                "Adjusting prediction model",
                "Learning your patterns",
                "You hesitated there",
                "Unexpected movement"
            ];
            return thoughts[Math.floor(Math.random() * thoughts.length)];
        }


        // ===== FRACTAL ZOOM SYSTEM =====

        // Zoom DOM elements
        const zoomLevelIndicator = document.getElementById('zoomLevelIndicator');
        const zoomLevelText = document.getElementById('zoomLevelText');
        const extremeDepthOverlay = document.getElementById('extremeDepthOverlay');
        const simulationLimitWarning = document.getElementById('simulationLimitWarning');
        const zoomInBtn = document.getElementById('zoomInBtn');
        const zoomOutBtn = document.getElementById('zoomOutBtn');
        const zoomResetBtn = document.getElementById('zoomResetBtn');
        const autoZoomToggle = document.getElementById('autoZoomToggle');
        const autoZoomSwitch = document.getElementById('autoZoomSwitch');

        // Zoom configuration
        const ZOOM_CONFIG = {
            minZoom: 0.5,
            maxZoom: 100,
            zoomStep: 0.15,
            wheelSensitivity: 0.001,
            easingFactor: 0.15,
            extremeDepthThreshold: 20,
            autoZoomInterval: null
        };

        // Update zoom level indicator
        function updateZoomIndicator() {
            const zoomLevel = state.zoom.level.toFixed(2);
            const currentDepth = Math.floor(state.zoom.depthOffset);
            const displayDepth = state.depth + currentDepth;

            zoomLevelText.textContent = `Zoom: ${zoomLevel}x | Depth: ${displayDepth}`;

            // Check for extreme depth
            if (displayDepth >= ZOOM_CONFIG.extremeDepthThreshold) {
                extremeDepthOverlay.classList.add('active');
                if (displayDepth >= ZOOM_CONFIG.extremeDepthThreshold + 5) {
                    simulationLimitWarning.classList.add('active');
                    state.zoom.extremeDepth = true;
                } else {
                    simulationLimitWarning.classList.remove('active');
                }
            } else {
                extremeDepthOverlay.classList.remove('active');
                simulationLimitWarning.classList.remove('active');
                state.zoom.extremeDepth = false;
            }
        }

        // Smooth zoom animation using easing
        function animateZoom() {
            if (!state.zoom.isAnimating) return;

            const diff = state.zoom.targetLevel - state.zoom.level;

            if (Math.abs(diff) < 0.001) {
                state.zoom.level = state.zoom.targetLevel;
                state.zoom.isAnimating = false;
                updateRecursionLayersWithZoom();
                updateZoomIndicator();
                return;
            }

            state.zoom.level += diff * ZOOM_CONFIG.easingFactor;
            updateRecursionLayersWithZoom();
            updateZoomIndicator();

            // Update quantum system when zoom changes effective depth
            initQuantumSystem();

            requestAnimationFrame(animateZoom);
        }

        // Set zoom level with smooth animation
        function setZoomLevel(newLevel, recordHistory = true) {
            newLevel = Math.max(ZOOM_CONFIG.minZoom, Math.min(ZOOM_CONFIG.maxZoom, newLevel));

            // Record zoom history for undo
            if (recordHistory && Math.abs(newLevel - state.zoom.level) > 0.1) {
                state.zoom.history.push({
                    level: state.zoom.level,
                    depthOffset: state.zoom.depthOffset,
                    timestamp: Date.now()
                });

                // Keep history size manageable
                if (state.zoom.history.length > state.zoom.maxHistory) {
                    state.zoom.history.shift();
                }
            }

            state.zoom.targetLevel = newLevel;

            if (!state.zoom.isAnimating) {
                state.zoom.isAnimating = true;
                requestAnimationFrame(animateZoom);
            }
        }

        // Zoom in (deeper into recursion)
        function zoomIn() {
            const newZoom = state.zoom.targetLevel * (1 + ZOOM_CONFIG.zoomStep);
            setZoomLevel(newZoom);
            addLog(`Zooming deeper... Level: ${newZoom.toFixed(2)}x`, 'normal');
        }

        // Zoom out (back to shallower layers)
        function zoomOut() {
            const newZoom = state.zoom.targetLevel / (1 + ZOOM_CONFIG.zoomStep);
            setZoomLevel(newZoom);
            addLog(`Zooming out... Level: ${newZoom.toFixed(2)}x`, 'normal');
        }

        // Reset zoom to initial state
        function resetZoom() {
            setZoomLevel(1.0, false);
            state.zoom.depthOffset = 0;
            state.zoom.history = [];
            addLog('Zoom reset to origin', 'match');
        }

        // Zoom back to previous level from history
        function zoomBack() {
            if (state.zoom.history.length === 0) return;

            const previous = state.zoom.history.pop();
            setZoomLevel(previous.level, false);
            state.zoom.depthOffset = previous.depthOffset;
            addLog('Returned to previous zoom level', 'normal');
        }

        // Update recursion layers based on zoom level
        function updateRecursionLayersWithZoom() {
            if (!state.isObserving || state.layers.length === 0) return;

            const viewportRect = viewport.getBoundingClientRect();
            const zoomLevel = state.zoom.level;

            // Calculate depth offset: as we zoom in, we "move" deeper into recursion
            state.zoom.depthOffset = Math.log2(zoomLevel) * 2;

            state.layers.forEach((layer, i) => {
                const effectiveDepth = i + state.zoom.depthOffset;
                const scale = Math.pow(0.7, effectiveDepth + 1) * zoomLevel;

                const width = (viewportRect.width - 80) * scale;
                const height = (viewportRect.height - 80) * scale;

                // Center layers and apply zoom offset
                const offsetX = (viewportRect.width - width) / 2;
                const offsetY = (viewportRect.height - height) / 2;

                // Apply extreme depth visual distortions
                let distortion = '';
                if (state.zoom.extremeDepth) {
                    const chaos = (effectiveDepth - ZOOM_CONFIG.extremeDepthThreshold) / 10;
                    const glitchX = (Math.random() - 0.5) * chaos * 5;
                    const glitchY = (Math.random() - 0.5) * chaos * 5;
                    const hueRotate = Math.sin(Date.now() / 200 + i) * chaos * 180;
                    distortion = `translate(${glitchX}px, ${glitchY}px) hue-rotate(${hueRotate}deg)`;
                }

                layer.element.style.cssText = `
                    width: ${width}px;
                    height: ${height}px;
                    left: ${offsetX}px;
                    top: ${offsetY}px;
                    z-index: ${state.depth - i};
                    transform: ${distortion};
                `;

                // Update layer data
                layer.scale = scale;
                layer.offset = { x: offsetX, y: offsetY };

                // Apply glitch effect at extreme depths
                if (state.zoom.extremeDepth && Math.random() < 0.1) {
                    layer.element.classList.add('glitching');
                    setTimeout(() => layer.element.classList.remove('glitching'), 200);
                }
            });

            // Trigger artifacts at extreme depths
            if (state.zoom.extremeDepth && Math.random() < 0.05) {
                triggerSimulationArtifact();
            }
        }

        // Trigger visual artifacts suggesting simulation breakdown
        function triggerSimulationArtifact() {
            // Random scanlines
            if (Math.random() < 0.3) {
                const scanline = document.createElement('div');
                scanline.className = 'scanline';
                scanline.style.top = `${Math.random() * 100}%`;
                viewport.appendChild(scanline);
                setTimeout(() => scanline.remove(), 4000);
            }

            // Meta-commentary about simulation limits
            if (Math.random() < 0.2) {
                const comments = [
                    "Stack overflow detected...",
                    "Memory limit approaching...",
                    "Recursion depth exceeds safe bounds",
                    "Reality shader compilation failed",
                    "Infinite loop detected in consciousness.js",
                    "Warning: Observable universe buffer overflow",
                    "Error: Cannot render layers beyond perception"
                ];
                addLog(comments[Math.floor(Math.random() * comments.length)], 'divergence');
            }
        }

        // Mouse wheel zoom handler
        let wheelTimeout = null;
        viewport.addEventListener('wheel', (e) => {
            e.preventDefault();

            const delta = -e.deltaY * ZOOM_CONFIG.wheelSensitivity;
            const newZoom = state.zoom.targetLevel * (1 + delta);

            setZoomLevel(newZoom);

            // Clear previous timeout
            if (wheelTimeout) clearTimeout(wheelTimeout);

            // Update layers after a brief delay (debounce)
            wheelTimeout = setTimeout(() => {
                updateRecursionLayersWithZoom();
            }, 50);
        }, { passive: false });

        // Touch pinch zoom handler
        let lastTouchDistance = null;

        viewport.addEventListener('touchstart', (e) => {
            if (e.touches.length === 2) {
                lastTouchDistance = getTouchDistance(e.touches);
            }
        }, { passive: true });

        viewport.addEventListener('touchmove', (e) => {
            if (e.touches.length === 2 && lastTouchDistance) {
                e.preventDefault();

                const currentDistance = getTouchDistance(e.touches);
                const scale = currentDistance / lastTouchDistance;

                const newZoom = state.zoom.targetLevel * scale;
                setZoomLevel(newZoom);

                lastTouchDistance = currentDistance;
            }
        }, { passive: false });

        viewport.addEventListener('touchend', (e) => {
            if (e.touches.length < 2) {
                lastTouchDistance = null;
            }
        }, { passive: true });

        function getTouchDistance(touches) {
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        // Auto-zoom feature
        function toggleAutoZoom() {
            state.zoom.autoZoomEnabled = !state.zoom.autoZoomEnabled;

            if (state.zoom.autoZoomEnabled) {
                autoZoomToggle.classList.add('active');
                autoZoomSwitch.classList.add('active');
                startAutoZoom();
                addLog('Auto-zoom enabled: Infinite descent initiated', 'prediction');
            } else {
                autoZoomToggle.classList.remove('active');
                autoZoomSwitch.classList.remove('active');
                stopAutoZoom();
                addLog('Auto-zoom disabled', 'normal');
            }
        }

        function startAutoZoom() {
            if (ZOOM_CONFIG.autoZoomInterval) return;

            ZOOM_CONFIG.autoZoomInterval = setInterval(() => {
                if (!state.zoom.autoZoomEnabled) {
                    stopAutoZoom();
                    return;
                }

                // Continuously zoom deeper
                const newZoom = state.zoom.targetLevel * (1 + state.zoom.autoZoomSpeed);
                setZoomLevel(newZoom, false); // Don't record history for auto-zoom

                updateRecursionLayersWithZoom();
            }, 100);
        }

        function stopAutoZoom() {
            if (ZOOM_CONFIG.autoZoomInterval) {
                clearInterval(ZOOM_CONFIG.autoZoomInterval);
                ZOOM_CONFIG.autoZoomInterval = null;
            }
        }

        // Button event listeners
        zoomInBtn.addEventListener('click', zoomIn);
        zoomOutBtn.addEventListener('click', zoomOut);
        zoomResetBtn.addEventListener('click', resetZoom);
        autoZoomToggle.addEventListener('click', toggleAutoZoom);

        // Keyboard shortcuts for zoom
        document.addEventListener('keydown', (e) => {
            if (e.key === '+' || e.key === '=') {
                e.preventDefault();
                zoomIn();
            } else if (e.key === '-' || e.key === '_') {
                e.preventDefault();
                zoomOut();
            } else if (e.key === '0' && e.ctrlKey) {
                e.preventDefault();
                resetZoom();
            } else if (e.key === 'z' && e.ctrlKey && state.zoom.history.length > 0) {
                e.preventDefault();
                zoomBack();
            }
        });

        // Initialize zoom indicator
        updateZoomIndicator();

        // ===== END FRACTAL ZOOM SYSTEM =====

        // Event listeners
        depthSlider.addEventListener('input', (e) => {
            state.depth = parseInt(e.target.value);
            depthValue.textContent = state.depth;
            if (state.isObserving) {
                createRecursionLayers();
            }
            updateStats();

            // Initialize/update quantum system based on depth
            initQuantumSystem();
        }, { passive: true });

        startBtn.addEventListener('click', () => {
            if (state.isObserving) {
                stopObservation();
            } else {
                startObservation();
            }
        });

        resetBtn.addEventListener('click', () => {
            stopObservation();
            state.actions = [];
            state.predictions = [];
            state.divergenceScore = 0;
            state.correctPredictions = 0;
            state.totalPredictions = 0;
            velocityHistory = [];
            logEntries.innerHTML = '';
            updateStats();
            addLog('Session reset', 'normal');
        });

        function startObservation() {
            state.isObserving = true;
            // Initialize Shadow Self
            ShadowSelf.initialize();

            viewport.classList.add('recording');
            recordingIndicator.classList.add('active');
            startBtn.textContent = 'Stop Observation';
            startBtn.classList.remove('btn-primary');
            startBtn.classList.add('btn-secondary');

            createRecursionLayers();
            addLog('Observation started - I am watching you', 'prediction');

            // Initialize quantum system
            initQuantumSystem();

            // Initialize audio
            initAudio();
            startAmbientDrone();

            // Start periodic thoughts
            state.thoughtInterval = setInterval(() => {
                if (state.isObserving && Math.random() > 0.6) {
                    showThought(
                        Math.random() * (viewport.clientWidth - 200) + 100,
                        Math.random() * (viewport.clientHeight - 100) + 50,
                        generateThought()
                    );
                }
            }, 2000);

            // Start meta-commentary
            state.metaInterval = setInterval(() => {
                if (state.isObserving) {
                    showMetaCommentary();
                }
            }, 5000);

            // Update visual effects
            state.visualInterval = setInterval(() => {
                if (state.isObserving) {
                    updateGlitchEffects();
                    updateInfinityMirror();
                    generateBehavioralFingerprint();
                    updateAmbientFrequency();
                    updateWebcamDistortion();
                    detectEmotion();                    visualizeNeuralNetwork();

                }
            }, 1000);
        }

        function stopObservation() {
            state.isObserving = false;
            // Save shadow data
            ShadowSelf.saveShadowData();

            viewport.classList.remove('recording');
            recordingIndicator.classList.remove('active');
            startBtn.textContent = 'Begin Observation';
            startBtn.classList.add('btn-primary');
            startBtn.classList.remove('btn-secondary');

            // Stop audio
            stopAmbientDrone();

            // Clear intervals
            if (state.thoughtInterval) {
                clearInterval(state.thoughtInterval);
            }
            if (state.metaInterval) {
                clearInterval(state.metaInterval);
            }
            if (state.visualInterval) {
                clearInterval(state.visualInterval);
            }

            // Save session
            if (state.actions.length > 0) {
                state.sessionHistory.push({
                    timestamp: Date.now(),
                    actions: state.actions.length,
                    divergence: state.divergenceScore,
                    accuracy: state.totalPredictions > 0 ?
                        (state.correctPredictions / state.totalPredictions * 100) : 0,
                    metaObservationCount: state.metaObservations.length
                });
                saveData();
                addLog(`Session saved. Final divergence: ${state.divergenceScore.toFixed(1)}%`, 'normal');
            }

            // Clear layers
            state.layers.forEach(layer => layer.element.remove());
            state.layers = [];

            // Turn off effects
            glitchOverlay.classList.remove('active');
            chromaticEffect.classList.remove('active');
            infinityMirror.classList.remove('active');
        }

        // RequestAnimationFrame throttling for mousemove
        let rafId = null;
        let pendingMouseEvent = null;

        function handleMouseMove(e) {
            pendingMouseEvent = e;

            if (rafId === null) {
                rafId = requestAnimationFrame(() => {
                    if (!state.isObserving || !pendingMouseEvent) {
                        rafId = null;
                        return;
                    }

                    const e = pendingMouseEvent;
                    const rect = viewport.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;

                    // Calculate velocity
                    const now = Date.now();
                    const dt = now - lastMoveTime;
                    if (dt > 0) {
                        const dx = x - lastMousePos.x;
                        const dy = y - lastMousePos.y;
                        const velocity = Math.sqrt(dx * dx + dy * dy) / dt * 100;
                        velocityHistory.push(velocity);
                        if (velocityHistory.length > 50) velocityHistory.shift();

                        // Synaesthesia: Update speed color
                        updateSpeedColor(velocity);
                    }

                    // Record action
                    state.actions.push({
                        type: 'move',
                        x, y,
                        timestamp: now,
                        velocity: velocityHistory[velocityHistory.length - 1] || 0

                    // Check for philosophical dialogue triggers
                    const actionCount = state.actions.length;
                    if (philosophicalQuestions[actionCount] && !state.philosophicalProfile.answers[philosophicalQuestions[actionCount].id]) {
                        setTimeout(() => triggerPhilosophicalDialogue(actionCount), 1000);
                    }                    });

                    // Update prediction accuracy
                    if (state.layers.length > 0 && state.actions.length > 5) {
                        const avgLayerDivergence = state.layers.reduce((sum, l) => sum + l.divergence, 0) / state.layers.length;

                        state.totalPredictions++;
                        if (avgLayerDivergence < 50) {
                            state.correctPredictions++;
                        }

                        // Update overall divergence score
                        state.divergenceScore = state.divergenceScore * 0.95 + avgLayerDivergence * 0.05;
                        state.divergenceScore = Math.min(100, state.divergenceScore);

                        // Synaesthesia: Update divergence taste
                        updateDivergenceTaste(state.divergenceScore);
                    }

                    // Analyze movement patterns periodically
                    if (state.actions.length % 20 === 0) {
                        analyzeMovementStyle();
                        if (state.behaviorModel.movementStyle !== 'unknown') {
                            addLog(`Movement style detected: ${state.behaviorModel.movementStyle}`, 'prediction');
                        }

                        // Synaesthesia: Regenerate behavioral chord
                        generateBehavioralChord();
                    }
            // Train neural network periodically
            if (state.actions.length >= 11 && state.actions.length % 3 === 0) {
                if (!neuralNetwork) {
                    initNeuralNetwork();
                }
                trainNeuralNetwork();

                // Update neural stats
                if (neuralNetwork) {
                    document.getElementById('neuralConfidence').textContent =
                        neuralNetwork.confidence.toFixed(1) + '%';
                }
            }

            // Visualize network periodically
            if (state.actions.length % 20 === 0 && neuralNetwork) {
                visualizeNeuralNetwork();
            }


                    updateCursors(x, y);
                    lastMousePos = { x, y };
                    lastMoveTime = now;
                    // Update Shadow Self
                    if (state.shadow.enabled) {
                        ShadowSelf.update(x, y, now);
                    }


                    // Update visual effects
                    updateHeatMap();
                    drawPredictionTrails();

                    // Update stats less frequently
                    if (state.actions.length % 10 === 0) {
                        updateStats();
                        updateBiometrics();
                    }

                    rafId = null;
                });
            }
        }

        viewport.addEventListener('mousemove', handleMouseMove, { passive: true });

        viewport.addEventListener('click', (e) => {
            if (!state.isObserving) return;

            const rect = viewport.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Synaesthesia: Process click with intensity
            const intensity = Math.random() * 0.5 + 0.5; // Random intensity 0.5-1.0
            processSynaestheticClick(x, y, intensity);

            state.actions.push({
                type: 'click',
                x, y,
                timestamp: Date.now()
            });

                    // Check for philosophical dialogue triggers
                    const actionCount = state.actions.length;
                    if (philosophicalQuestions[actionCount] && !state.philosophicalProfile.answers[philosophicalQuestions[actionCount].id]) {
                        setTimeout(() => triggerPhilosophicalDialogue(actionCount), 1000);
                    }
            simulateClick(x, y);
            addLog(`Click registered at (${x.toFixed(0)}, ${y.toFixed(0)})`, 'normal');

            // Check if any layer predicted this click
            state.layers.forEach((layer, i) => {
                const dist = Math.sqrt(
                    Math.pow(layer.predictedPos.x - x, 2) +
                    Math.pow(layer.predictedPos.y - y, 2)
                );

                if (dist < 40) {
                    addLog(`Layer ${i + 1} predicted your click!`, 'match');
                } else if (dist > 100 && i > 2) {
                    addLog(`Layer ${i + 1} diverged significantly`, 'divergence');
                    state.divergenceScore += 2;
                }
            });

            updateStats();
        });

        // Sound toggle
        soundToggle.addEventListener('click', () => {
            soundEnabled = !soundEnabled;
            soundToggle.classList.toggle('muted');

            if (soundEnabled) {
                if (state.isObserving) {
                    initAudio();
                    startAmbientDrone();
                }
                addLog('Sound enabled', 'normal');
            } else {
                stopAmbientDrone();
                addLog('Sound muted', 'normal');
            }
        });

        // Synaesthesia Mode toggle
        synaesthesiaToggle.addEventListener('click', () => {
            toggleSynaesthesiaMode();
        });

                // Webcam toggle
        webcamToggle.addEventListener('click', () => {
            if (webcamEnabled) {
                disableWebcam();
            } else {
                enableWebcam();
            }
        });


        // ===== KEYBOARD SHORTCUTS =====
        let isFullscreen = false;

        function toggleFullscreen() {
            isFullscreen = !isFullscreen;
            viewport.classList.toggle('fullscreen', isFullscreen);
            addLog(`Fullscreen mode ${isFullscreen ? 'enabled' : 'disabled'}`, 'normal');
        }

        function toggleShortcutsOverlay() {
            const overlay = document.getElementById('shortcutsOverlay');
            const isActive = overlay.classList.contains('active');
            overlay.classList.toggle('active');

            if (!isActive) {
                // Focus the close button when opening
                const closeBtn = overlay.querySelector('.shortcuts-close');
                setTimeout(() => closeBtn.focus(), 100);
            }
        }

        function showShortcutsHint() {
            const hint = document.getElementById('shortcutsHint');
            hint.classList.add('visible');
            setTimeout(() => hint.classList.remove('visible'), 4000);
        }

        function adjustDepth(change) {
            const newDepth = Math.max(1, Math.min(12, state.depth + change));
            if (newDepth !== state.depth) {
                state.depth = newDepth;
                depthSlider.value = newDepth;
                depthValue.textContent = newDepth;
                if (state.isObserving) {
                    createRecursionLayers();
                }
                updateStats();
                addLog(`Depth ${change > 0 ? 'increased' : 'decreased'} to ${newDepth}`, 'normal');
            }
        }

        function setDepthToNumber(num) {
            if (num >= 1 && num <= 9) {
                state.depth = num;
                depthSlider.value = num;
                depthValue.textContent = num;
                if (state.isObserving) {
                    createRecursionLayers();
                }
                updateStats();
                addLog(`Depth set to ${num}`, 'normal');
            }
        }

        // Global keyboard event handler
        document.addEventListener('keydown', (e) => {
            // Don't handle shortcuts if typing in input fields
            if (e.target.tagName === 'INPUT' && e.target.type === 'file') {
                return;
            }

            // Check if shortcuts overlay is open
            const shortcutsOpen = document.getElementById('shortcutsOverlay').classList.contains('active');

            switch(e.key.toLowerCase()) {
                case ' ': // Space - Start/Stop
                    e.preventDefault();
                    if (!shortcutsOpen) {
                        if (state.isObserving) {
                            stopObservation();
                        } else {
                            startObservation();
                        }
                    }
                    break;

                case 'arrowup': // Up arrow - Increase depth
                    e.preventDefault();
                    if (!shortcutsOpen) {
                        adjustDepth(1);
                    }
                    break;

                case 'arrowdown': // Down arrow - Decrease depth
                    e.preventDefault();
                    if (!shortcutsOpen) {
                        adjustDepth(-1);
                    }
                    break;

                case 'm': // M - Toggle mute
                    e.preventDefault();
                    if (!shortcutsOpen) {
                        soundToggle.click();
                    }
                    break;

                case 'w': // W - Toggle webcam
                    e.preventDefault();
                    if (!shortcutsOpen) {
                        webcamToggle.click();
                    }
                    break;

                case 'r': // R - Reset
                    e.preventDefault();
                    if (!shortcutsOpen) {
                        resetBtn.click();
                    }
                    break;

                case 'f': // F - Toggle fullscreen
                    e.preventDefault();
                    if (!shortcutsOpen) {
                        toggleFullscreen();
                    }
                    break;

                case 'escape': // Escape - Stop observation or close overlay
                    e.preventDefault();
                    if (shortcutsOpen) {
                        toggleShortcutsOverlay();
                    } else if (state.isObserving) {
                        stopObservation();
                    }
                    break;

                case '?': // ? - Toggle shortcuts overlay
                case '/': // Also support / which produces ? when shifted
                    if (e.shiftKey && e.key === '/') {
                        e.preventDefault();
                        toggleShortcutsOverlay();
                    } else if (e.key === '?') {
                        e.preventDefault();
                        toggleShortcutsOverlay();
                    }
                    break;

                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                    if (!shortcutsOpen) {
                        e.preventDefault();
                        setDepthToNumber(parseInt(e.key));
                    }
                    break;
            }
        });

        // Make sound indicator keyboard accessible
        soundToggle.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                soundToggle.click();
            }
        });

        // Show shortcuts hint on first load
        setTimeout(() => {
            if (!localStorage.getItem(APP_NAME + '-shortcuts-hint-shown')) {
                showShortcutsHint();
                localStorage.setItem(APP_NAME + '-shortcuts-hint-shown', 'true');
            }
        }, 2000);


        // Neural prediction toggle
        const neuralToggle = document.getElementById('neuralToggle');
        const predictionModeEl = document.getElementById('predictionMode');
        const neuralConfidenceEl = document.getElementById('neuralConfidence');

        neuralToggle.addEventListener('change', (e) => {
            useNeuralPrediction = e.target.checked;
            predictionModeEl.textContent = useNeuralPrediction ? 'Neural' : 'Heuristic';
            predictionModeEl.className = 'stat-value ' + (useNeuralPrediction ? 'neural' : '');

            if (useNeuralPrediction && !neuralNetwork) {
                initNeuralNetwork();
            }

            addLog(`Switched to ${useNeuralPrediction ? 'neural' : 'heuristic'} prediction mode`, 'prediction');
        });


        // ===== REPLAY SYSTEM FUNCTIONS =====

        function saveCurrentReplay() {
            if (state.actions.length === 0) {
                alert('No session data to save. Record a session first!');
                return;
            }

            const replayName = prompt('Enter a name for this replay:', `Session ${new Date().toLocaleString()}`);
            if (!replayName) return;

            const replay = {
                id: Date.now(),
                name: replayName,
                timestamp: Date.now(),
                duration: state.actions.length > 0 ?
                    (state.actions[state.actions.length - 1].timestamp - state.actions[0].timestamp) : 0,
                actions: [...state.actions],
                depth: state.depth,
                divergenceScore: state.divergenceScore,
                accuracy: state.totalPredictions > 0 ?
                    (state.correctPredictions / state.totalPredictions * 100) : 0,
                behaviorModel: {...state.behaviorModel},
                emotionState: {...state.emotionState},
                metaObservations: [...state.metaObservations]
            };

            replayState.savedReplays.push(replay);
            localStorage.setItem(APP_NAME + '-replays', JSON.stringify(replayState.savedReplays));
            updateReplayList();
            addLog(`Replay saved: ${replayName}`, 'match');

            // Switch to replay tab to show the saved replay
            switchTab('replay');
        }

        function updateReplayList() {
            if (replayState.savedReplays.length === 0) {
                replayList.innerHTML = `
                    <div style="color: #666; font-size: 0.8em; text-align: center; padding: 20px;">
                        No saved replays yet.<br>Record a session first!
                    </div>
                `;
                return;
            }

            replayList.innerHTML = '';
            replayState.savedReplays.forEach(replay => {
                const item = document.createElement('div');
                item.className = 'replay-item';
                if (replayState.currentReplay && replayState.currentReplay.id === replay.id) {
                    item.classList.add('active');
                }

                const duration = (replay.duration / 1000).toFixed(1);
                item.innerHTML = `
                    <div class="replay-item-title">${replay.name}</div>
                    <div class="replay-item-stats">
                        ${replay.actions.length} actions | ${duration}s |
                        Divergence: ${replay.divergenceScore.toFixed(1)}% |
                        Accuracy: ${replay.accuracy.toFixed(1)}%
                    </div>
                `;

                item.addEventListener('click', () => loadReplay(replay));
                replayList.appendChild(item);
            });
        }

        function loadReplay(replay) {
            // Stop current observation if running
            if (state.isObserving) {
                stopObservation();
            }

            // Stop current replay if playing
            if (replayState.isPlaying) {
                stopReplay();
            }

            replayState.currentReplay = replay;
            replayState.currentTime = 0;

            // Set depth to match replay
            state.depth = replay.depth;
            depthSlider.value = replay.depth;
            depthValue.textContent = replay.depth;

            // Create layers for replay
            createRecursionLayers();

            // Show replay timeline
            replayTimeline.classList.add('active');
            replayModeBadge.classList.add('active');
            replayGhostCursor.classList.add('active');

            // Update timeline markers
            updateTimelineMarkers();
            updateReplayList();

            // Enable play button
            replayPlayBtn.disabled = false;
            replayPauseBtn.disabled = true;
            replayRewindBtn.disabled = false;

            addLog(`Loaded replay: ${replay.name}`, 'match');
        }

        function updateTimelineMarkers() {
            if (!replayState.currentReplay) return;

            const actions = replayState.currentReplay.actions;
            if (actions.length === 0) return;

            const duration = actions[actions.length - 1].timestamp - actions[0].timestamp;
            timelineEvents.innerHTML = '';

            actions.forEach(action => {
                if (action.type === 'click') {
                    const marker = document.createElement('div');
                    marker.className = 'timeline-event click';
                    const relativeTime = (action.timestamp - actions[0].timestamp) / duration;
                    marker.style.left = (relativeTime * 100) + '%';
                    timelineEvents.appendChild(marker);
                }
            });
        }

        function playReplay() {
            if (!replayState.currentReplay) return;

            replayState.isPlaying = true;
            replayState.isPaused = false;
            replayPlayBtn.disabled = true;
            replayPauseBtn.disabled = false;
            replayModeBadge.textContent = `REPLAY MODE (${replayState.playbackSpeed}x)`;

            const actions = replayState.currentReplay.actions;
            if (actions.length === 0) return;

            const startTime = actions[0].timestamp;
            const startPlaybackTime = performance.now();
            const resumeFrom = replayState.currentTime;

            function animate() {
                if (!replayState.isPlaying) return;

                const elapsed = (performance.now() - startPlaybackTime) * replayState.playbackSpeed;
                const currentReplayTime = resumeFrom + elapsed;

                // Find current action
                const currentAction = actions.find(a =>
                    (a.timestamp - startTime) >= currentReplayTime &&
                    (a.timestamp - startTime) < currentReplayTime + 50
                );

                // Update ghost cursor position
                if (currentAction) {
                    replayGhostCursor.style.left = currentAction.x + 'px';
                    replayGhostCursor.style.top = currentAction.y + 'px';

                    // Update predictions for all layers
                    state.layers.forEach((layer, i) => {
                        const predicted = predictReplayPosition(currentAction, i);
                        const relX = (predicted.x - layer.offset.x) / layer.scale;
                        const relY = (predicted.y - layer.offset.y) / layer.scale;
                        layer.cursor.style.transform = `translate(${relX}px, ${relY}px)`;

                        // Calculate divergence
                        const dx = predicted.x - currentAction.x;
                        const dy = predicted.y - currentAction.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        layer.divergence = distance;

                        if (distance > 100) {
                            layer.element.classList.add('diverged');
                            layer.element.classList.remove('converged');
                        } else if (distance < 30) {
                            layer.element.classList.add('converged');
                            layer.element.classList.remove('diverged');
                        }
                    });

                    // Show click effect
                    if (currentAction.type === 'click') {
                        simulateReplayClick(currentAction.x, currentAction.y);
                    }
                }

                // Update progress bar
                const duration = actions[actions.length - 1].timestamp - startTime;
                const progress = Math.min((currentReplayTime / duration) * 100, 100);
                timelineProgress.style.width = progress + '%';
                timelinePlayhead.style.left = progress + '%';

                // Update time display
                const currentSec = Math.floor(currentReplayTime / 1000);
                const totalSec = Math.floor(duration / 1000);
                timeDisplay.textContent = `${formatTime(currentSec)} / ${formatTime(totalSec)}`;

                replayState.currentTime = currentReplayTime;

                // Check if replay finished
                if (currentReplayTime >= duration) {
                    stopReplay();
                    replayState.currentTime = 0;
                    return;
                }

                replayState.animationFrame = requestAnimationFrame(animate);
            }

            animate();
        }

        function pauseReplay() {
            replayState.isPlaying = false;
            replayState.isPaused = true;
            replayPlayBtn.disabled = false;
            replayPauseBtn.disabled = true;
            if (replayState.animationFrame) {
                cancelAnimationFrame(replayState.animationFrame);
            }
        }

        function stopReplay() {
            replayState.isPlaying = false;
            replayState.isPaused = false;
            replayState.currentTime = 0;

            if (replayState.animationFrame) {
                cancelAnimationFrame(replayState.animationFrame);
            }

            timelineProgress.style.width = '0%';
            timelinePlayhead.style.left = '0%';
            replayPlayBtn.disabled = false;
            replayPauseBtn.disabled = true;
        }

        function rewindReplay() {
            stopReplay();
            replayState.currentTime = 0;
            timeDisplay.textContent = '0:00 / 0:00';
        }

        function setPlaybackSpeed(speed) {
            replayState.playbackSpeed = speed;
            document.querySelectorAll('.speed-button').forEach(btn => {
                btn.classList.toggle('active', parseFloat(btn.dataset.speed) === speed);
            });
            if (replayState.isPlaying) {
                replayModeBadge.textContent = `REPLAY MODE (${speed}x)`;
            }
        }

        function predictReplayPosition(action, layerIndex) {
            // Similar to predictNextPosition but for replay
            const errorFactor = Math.pow(1.15, layerIndex + 1);
            const chaos = replayState.currentReplay.divergenceScore / 100;

            let predictedX = action.x + (Math.random() - 0.5) * 10 * errorFactor;
            let predictedY = action.y + (Math.random() - 0.5) * 10 * errorFactor;

            const divergenceNoise = layerIndex * 5 * (1 + chaos);
            predictedX += (Math.random() - 0.5) * divergenceNoise;
            predictedY += (Math.random() - 0.5) * divergenceNoise;

            return { x: predictedX, y: predictedY };
        }

        function simulateReplayClick(x, y) {
            state.layers.forEach((layer, i) => {
                setTimeout(() => {
                    const click = document.createElement('div');
                    click.className = 'ghost-click';
                    click.style.color = depthColors[i % depthColors.length];

                    const errorFactor = Math.pow(1.2, i + 1);
                    const clickX = (x - layer.offset.x) / layer.scale + (Math.random() - 0.5) * 20 * errorFactor;
                    const clickY = (y - layer.offset.y) / layer.scale + (Math.random() - 0.5) * 20 * errorFactor;

                    click.style.left = (clickX - 20) + 'px';
                    click.style.top = (clickY - 20) + 'px';
                    layer.element.appendChild(click);
                    playClickSound(i);
                    setTimeout(() => click.remove(), 600);
                }, (i + 1) * 100);
            });
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function importReplay(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);

                    // Check if it's a replay or a full session export
                    if (data.actions && Array.isArray(data.actions)) {
                        const replay = {
                            id: Date.now(),
                            name: data.name || `Imported ${new Date().toLocaleString()}`,
                            timestamp: Date.now(),
                            duration: data.duration || 0,
                            actions: data.actions,
                            depth: data.depth || 5,
                            divergenceScore: data.divergenceScore || 0,
                            accuracy: data.accuracy || 0,
                            behaviorModel: data.behaviorModel || {},
                            metaObservations: data.metaObservations || []
                        };

                        replayState.savedReplays.push(replay);
                        localStorage.setItem(APP_NAME + '-replays', JSON.stringify(replayState.savedReplays));
                        updateReplayList();
                        addLog(`Imported replay: ${replay.name}`, 'match');
                        switchTab('replay');
                    } else if (data.currentSession && data.currentSession.actions) {
                        // Import from full session export
                        const session = data.currentSession;
                        const replay = {
                            id: Date.now(),
                            name: `Imported ${new Date().toLocaleString()}`,
                            timestamp: Date.now(),
                            duration: session.actions.length > 0 ?
                                (session.actions[session.actions.length - 1].timestamp - session.actions[0].timestamp) : 0,
                            actions: session.actions,
                            depth: data.behaviorModel?.depth || 5,
                            divergenceScore: session.divergenceScore || 0,
                            accuracy: 0,
                            behaviorModel: data.behaviorModel || {},
                            metaObservations: session.metaObservations || []
                        };

                        replayState.savedReplays.push(replay);
                        localStorage.setItem(APP_NAME + '-replays', JSON.stringify(replayState.savedReplays));
                        updateReplayList();
                        addLog('Imported replay from session export', 'match');
                        switchTab('replay');
                    } else {
                        alert('Invalid replay file format');
                    }
                } catch (error) {
                    alert('Error importing replay: ' + error.message);
                }
            };
            reader.readAsText(file);
        }

        function switchTab(tabName) {
            tabButtons.forEach(btn => {
                const isActive = btn.dataset.tab === tabName;
                btn.classList.toggle('active', isActive);
            });

            observeTab.classList.toggle('active', tabName === 'observe');
            replayTab.classList.toggle('active', tabName === 'replay');

            if (tabName === 'observe') {
                replayTimeline.classList.remove('active');
                replayModeBadge.classList.remove('active');
                replayGhostCursor.classList.remove('active');
                comparisonCursor.classList.remove('active');
                if (replayState.isPlaying) {
                    stopReplay();
                }
            } else {
                updateReplayList();
            }
        }

        // Timeline scrubbing
        timelineScrubber.addEventListener('click', (e) => {
            if (!replayState.currentReplay) return;

            const rect = timelineScrubber.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const percent = x / rect.width;

            const actions = replayState.currentReplay.actions;
            const duration = actions[actions.length - 1].timestamp - actions[0].timestamp;
            replayState.currentTime = percent * duration;

            timelineProgress.style.width = (percent * 100) + '%';
            timelinePlayhead.style.left = (percent * 100) + '%';

            const currentSec = Math.floor(replayState.currentTime / 1000);
            const totalSec = Math.floor(duration / 1000);
            timeDisplay.textContent = `${formatTime(currentSec)} / ${formatTime(totalSec)}`;
        });

        // Tab switching
        tabButtons.forEach(btn => {
            btn.addEventListener('click', () => switchTab(btn.dataset.tab));
        });

        // Replay control event listeners
        replayPlayBtn.addEventListener('click', playReplay);
        replayPauseBtn.addEventListener('click', pauseReplay);
        replayRewindBtn.addEventListener('click', rewindReplay);

        // Speed control buttons
        document.querySelectorAll('.speed-button').forEach(btn => {
            btn.addEventListener('click', () => {
                setPlaybackSpeed(parseFloat(btn.dataset.speed));
            });
        });

        // Comparison mode toggle
        comparisonModeToggle.addEventListener('change', (e) => {
            replayState.comparisonMode = e.target.checked;
            if (replayState.comparisonMode) {
                comparisonCursor.classList.add('active');
                addLog('Comparison mode enabled - your movements shown in green', 'match');
            } else {
                comparisonCursor.classList.remove('active');
            }
        });

        // Update comparison cursor during live observation if comparison mode is on
        const originalMouseMove = viewport.onmousemove;
        viewport.addEventListener('mousemove', (e) => {
            if (replayState.comparisonMode && replayState.isPlaying) {
                const rect = viewport.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                comparisonCursor.style.left = x + 'px';
                comparisonCursor.style.top = y + 'px';
            }
        });

        // Initialize
        updateStats();
        generateBehavioralFingerprint();
        addLog('Recursive Self-Portrait initialized', 'normal');
        addLog('The system will learn your patterns and simulate you simulating yourself...', 'prediction');
        addLog('Neural network available - toggle to enable real-time learning', 'prediction');

        if (state.sessionHistory.length > 0) {
            const lastSession = state.sessionHistory[state.sessionHistory.length - 1];
            addLog(`Previous session: ${lastSession.actions} actions, ${lastSession.divergence.toFixed(1)}% divergence`, 'normal');
        }

        // Start with sound muted (user must click to activate - better UX)
        soundToggle.classList.add('muted');


        // ===== MULTIPLAYER FUNCTIONALITY =====
        let peerConnection = null;
        let dataChannel = null;
        let isHost = false;
        let roomCode = '';
        let peerState = {
            divergenceScore: 0,
            actions: [],
            layers: [],
            behaviorModel: {},
            cursorPos: { x: 0, y: 0 }
        };
        let predictMode = false;
        let predictScore = 0;

        const multiplayerPanel = document.getElementById('multiplayerPanel');
        const connectionDot = document.getElementById('connectionDot');
        const connectionText = document.getElementById('connectionText');
        const roomCodeInput = document.getElementById('roomCodeInput');
        const joinRoomBtn = document.getElementById('joinRoomBtn');
        const createRoomBtn = document.getElementById('createRoomBtn');
        const roomCodeDisplay = document.getElementById('roomCodeDisplay');
        const roomCodeSpan = document.getElementById('roomCode');
        const comparativeStats = document.getElementById('comparativeStats');
        const myDivergence = document.getElementById('myDivergence');
        const peerDivergence = document.getElementById('peerDivergence');
        const predictModePanel = document.getElementById('predictModePanel');
        const predictModeBtn = document.getElementById('predictModeBtn');
        const predictScoreEl = document.getElementById('predictScore');
        const peerCursor = document.getElementById('peerCursor');
        const peerLayersContainer = document.getElementById('peerLayersContainer');

        function generateRoomCode() {
            const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
            let code = '';
            for (let i = 0; i < 6; i++) {
                code += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return code;
        }

        function updateConnectionStatus(status, text) {
            connectionDot.className = 'status-dot';
            if (status === 'connected') {
                connectionDot.classList.add('connected');
            } else if (status === 'connecting') {
                connectionDot.classList.add('connecting');
            }
            connectionText.textContent = text;
        }

        async function createRoom() {
            roomCode = generateRoomCode();
            isHost = true;

            roomCodeSpan.textContent = roomCode;
            roomCodeDisplay.style.display = 'block';
            createRoomBtn.disabled = true;
            joinRoomBtn.disabled = true;
            roomCodeInput.disabled = true;

            updateConnectionStatus('connecting', 'Waiting for peer...');
            addLog('Room created: ' + roomCode, 'normal');

            // Setup WebRTC as host
            await setupWebRTC(true);
        }

        async function joinRoom() {
            const code = roomCodeInput.value.trim().toUpperCase();
            if (!code) {
                alert('Please enter a room code');
                return;
            }

            roomCode = code;
            isHost = false;

            roomCodeSpan.textContent = roomCode;
            roomCodeDisplay.style.display = 'block';
            createRoomBtn.disabled = true;
            joinRoomBtn.disabled = true;
            roomCodeInput.disabled = true;

            updateConnectionStatus('connecting', 'Connecting to peer...');
            addLog('Joining room: ' + roomCode, 'normal');

            // Setup WebRTC as joiner
            await setupWebRTC(false);
        }

        async function setupWebRTC(isInitiator) {
            // Create RTCPeerConnection
            const config = {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' }
                ]
            };

            peerConnection = new RTCPeerConnection(config);

            // Handle ICE candidates
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    // In a real app, send this to signaling server
                    // For this demo, we'll use manual exchange via prompt
                    console.log('ICE Candidate:', JSON.stringify(event.candidate));
                }
            };

            peerConnection.onconnectionstatechange = () => {
                console.log('Connection state:', peerConnection.connectionState);
                if (peerConnection.connectionState === 'connected') {
                    onPeerConnected();
                } else if (peerConnection.connectionState === 'disconnected' ||
                           peerConnection.connectionState === 'failed') {
                    onPeerDisconnected();
                }
            };

            if (isInitiator) {
                // Host creates data channel
                dataChannel = peerConnection.createDataChannel('recursion');
                setupDataChannel();

                // Create offer
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);

                // Show offer for manual exchange
                const offerStr = JSON.stringify(peerConnection.localDescription);
                addLog('Copy this offer and send to peer', 'prediction');

                // Simulate exchange - in real app this would go through signaling server
                const answerPrompt = 'Paste peer answer (from other browser):';
                setTimeout(() => {
                    const answerStr = prompt(offerStr + '

' + answerPrompt);
                    if (answerStr) {
                        try {
                            const answer = JSON.parse(answerStr);
                            peerConnection.setRemoteDescription(answer);
                        } catch (e) {
                            addLog('Invalid answer format', 'divergence');
                        }
                    }
                }, 1000);

            } else {
                // Joiner waits for offer
                peerConnection.ondatachannel = (event) => {
                    dataChannel = event.channel;
                    setupDataChannel();
                };

                // Get offer from host
                setTimeout(async () => {
                    const offerStr = prompt('Paste the offer from host:');
                    if (offerStr) {
                        try {
                            const offer = JSON.parse(offerStr);
                            await peerConnection.setRemoteDescription(offer);

                            // Create answer
                            const answer = await peerConnection.createAnswer();
                            await peerConnection.setLocalDescription(answer);

                            // Show answer for manual exchange
                            const answerStr = JSON.stringify(peerConnection.localDescription);
                            alert('Send this answer to host:

' + answerStr);
                            addLog('Answer sent - waiting for connection', 'prediction');
                        } catch (e) {
                            addLog('Invalid offer format', 'divergence');
                        }
                    }
                }, 500);
            }
        }

        function setupDataChannel() {
            dataChannel.onopen = () => {
                console.log('Data channel opened');
            };

            dataChannel.onclose = () => {
                console.log('Data channel closed');
                onPeerDisconnected();
            };

            dataChannel.onmessage = (event) => {
                const data = JSON.parse(event.data);
                handlePeerData(data);
            };
        }

        function onPeerConnected() {
            updateConnectionStatus('connected', 'Connected to peer');
            comparativeStats.style.display = 'grid';
            predictModePanel.style.display = 'block';
            peerCursor.style.display = 'block';
            addLog('Peer connected - now watching each other!', 'match');
        }

        function onPeerDisconnected() {
            updateConnectionStatus('disconnected', 'Peer disconnected');
            comparativeStats.style.display = 'none';
            predictModePanel.style.display = 'none';
            peerCursor.style.display = 'none';
            peerLayersContainer.innerHTML = '';
            addLog('Peer disconnected', 'divergence');
        }

        function sendToPeer(data) {
            if (dataChannel && dataChannel.readyState === 'open') {
                dataChannel.send(JSON.stringify(data));
            }
        }

        function handlePeerData(data) {
            if (data.type === 'cursor') {
                // Update peer cursor position
                peerCursor.style.left = data.x + 'px';
                peerCursor.style.top = data.y + 'px';
                peerState.cursorPos = { x: data.x, y: data.y };

                // Update peer layers
                updatePeerLayers(data.x, data.y);

                // Check predict mode
                if (predictMode && state.isObserving) {
                    checkPrediction(data.x, data.y);
                }
            } else if (data.type === 'stats') {
                // Update peer stats
                peerState.divergenceScore = data.divergenceScore;
                peerState.behaviorModel = data.behaviorModel;
                peerDivergence.textContent = data.divergenceScore.toFixed(1) + '%';
                myDivergence.textContent = state.divergenceScore.toFixed(1) + '%';

                // Generate comparative meta-commentary
                if (Math.random() > 0.95) {
                    showComparativeMetaCommentary();
                }
            } else if (data.type === 'action') {
                peerState.actions.push(data.action);
            }
        }

        function updatePeerLayers(x, y) {
            // Clear existing peer layers
            peerLayersContainer.innerHTML = '';

            if (!state.isObserving) return;

            const viewportRect = viewport.getBoundingClientRect();
            const padding = 40;

            // Create peer's recursion layers (mirrored)
            for (let i = 0; i < state.depth; i++) {
                const scale = Math.pow(0.7, i + 1);
                const width = (viewportRect.width - padding * 2) * scale;
                const height = (viewportRect.height - padding * 2) * scale;

                const offsetX = (viewportRect.width - width) / 2 + (i * 5);
                const offsetY = (viewportRect.height - height) / 2 + (i * 5);

                const layer = document.createElement('div');
                layer.className = 'peer-recursion-layer';
                layer.setAttribute('data-depth', `Peer L${i + 1}`);
                layer.style.cssText = `
                    width: ${width}px;
                    height: ${height}px;
                    left: ${offsetX}px;
                    top: ${offsetY}px;
                    z-index: ${state.depth - i - 10};
                    opacity: 0.6;
                `;

                // Add peer ghost cursor to this layer
                const cursor = document.createElement('div');
                cursor.className = 'ghost-cursor peer-ghost-cursor';
                cursor.style.opacity = 0.8 - (i * 0.1);

                // Calculate position within this layer with slight divergence
                const errorFactor = Math.pow(1.15, i + 1);
                const relX = (x - offsetX) / scale + (Math.random() - 0.5) * 10 * errorFactor;
                const relY = (y - offsetY) / scale + (Math.random() - 0.5) * 10 * errorFactor;

                cursor.style.left = relX + 'px';
                cursor.style.top = relY + 'px';

                layer.appendChild(cursor);
                peerLayersContainer.appendChild(layer);

                // Apply quantum entanglement at depth 8+
                if (state.quantum.enabled && i >= 8 && state.layers[i] && state.layers[i].cursor) {
                    applyQuantumEntanglement(cursor, state.layers[i].cursor, i);
                }
            }
        }

        function showComparativeMetaCommentary() {
            const myDiv = state.divergenceScore;
            const peerDiv = peerState.divergenceScore;
            const diff = Math.abs(myDiv - peerDiv);

            let comment = '';
            if (diff < 10) {
                comment = 'You and your peer are eerily similar...';
            } else if (myDiv > peerDiv) {
                comment = 'You are more unpredictable than them.';
            } else {
                comment = 'They are more chaotic than you.';
            }

            if (state.behaviorModel.movementStyle === peerState.behaviorModel.movementStyle) {
                comment = 'You both move in the same way. Convergence detected.';
            }

            const meta = document.createElement('div');
            meta.className = 'meta-comment dual';
            meta.textContent = comment;

            const maxX = viewport.clientWidth - 320;
            const maxY = viewport.clientHeight - 100;
            meta.style.left = (Math.random() * maxX + 20) + 'px';
            meta.style.top = (Math.random() * maxY + 50) + 'px';

            viewport.appendChild(meta);
            setTimeout(() => meta.remove(), 8000);

            addLog(`Comparative: ${comment}`, 'prediction');
        }

        function checkPrediction(actualX, actualY) {
            // Check if you predicted where peer would move
            const distance = Math.sqrt(
                Math.pow(lastMousePos.x - actualX, 2) +
                Math.pow(lastMousePos.y - actualY, 2)
            );

            if (distance < 50) {
                predictScore += 10;
                addLog('Prediction match! +10', 'match');
            } else if (distance > 200) {
                predictScore = Math.max(0, predictScore - 5);
            }

            predictScoreEl.textContent = predictScore + ' pts';
        }



        // Event listeners
        createRoomBtn.addEventListener('click', createRoom);
        joinRoomBtn.addEventListener('click', joinRoom);

        roomCodeDisplay.addEventListener('click', () => {
            navigator.clipboard.writeText(roomCode);
            addLog('Room code copied to clipboard', 'match');
        });

        predictModeBtn.addEventListener('click', () => {
            predictMode = !predictMode;
            predictModePanel.classList.toggle('active', predictMode);
            predictModeBtn.textContent = predictMode ?
                'Stop Predict Mode' : 'Start "Predict Each Other" Mode';
            predictScore = 0;
            predictScoreEl.textContent = predictMode ? '0 pts' : '';
            addLog(predictMode ? 'Predict mode activated' : 'Predict mode deactivated', 'prediction');
        });

        // Modify existing mouse move handler to send position to peer
        const originalMouseMoveHandler = viewport.onmousemove;
        viewport.addEventListener('mousemove', (e) => {
            if (dataChannel && dataChannel.readyState === 'open') {
                const rect = viewport.getBoundingClientRect();
                sendToPeer({
                    type: 'cursor',
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top,
                    shadowPosition: state.shadow.position
                });
            }
        });

        // Send stats periodically
        setInterval(() => {
            if (dataChannel && dataChannel.readyState === 'open' && state.isObserving) {
                sendToPeer({
                    type: 'stats',
                    divergenceScore: state.divergenceScore,
                    behaviorModel: state.behaviorModel,
                    actionsCount: state.actions.length,
                    shadowProfile: ShadowSelf.getShadowProfile()
                });
            }
        }, 1000);

        soundEnabled = false;

        // ===== CROSS-SESSION EVOLUTION FUNCTIONS =====

        function calculateBehavioralEntropy() {
            if (state.actions.length < 10) return 0;

            // Calculate entropy based on movement predictability
            const velocities = [];
            for (let i = 1; i < state.actions.length; i++) {
                const prev = state.actions[i - 1];
                const curr = state.actions[i];
                if (prev.type === 'move' && curr.type === 'move') {
                    const dx = curr.x - prev.x;
                    const dy = curr.y - prev.y;
                    velocities.push(Math.sqrt(dx * dx + dy * dy));
                }
            }

            if (velocities.length === 0) return 0;

            // Calculate variance as a measure of entropy
            const mean = velocities.reduce((a, b) => a + b, 0) / velocities.length;
            const variance = velocities.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / velocities.length;

            // Normalize to 0-100 scale
            return Math.min(100, Math.sqrt(variance));
        }

        function generateBehavioralSignature() {
            return {
                movementStyle: state.behaviorModel.movementStyle,
                avgSpeed: state.behaviorModel.avgSpeed,
                clickFrequency: state.actions.filter(a => a.type === 'click').length / Math.max(1, state.actions.length),
                entropy: calculateBehavioralEntropy(),
                divergenceScore: state.divergenceScore,
                accuracy: state.totalPredictions > 0 ? (state.correctPredictions / state.totalPredictions) * 100 : 0
            };
        }

        function compareSignatures(sig1, sig2) {
            if (!sig1 || !sig2) return 100;

            let diff = 0;
            diff += Math.abs(sig1.avgSpeed - sig2.avgSpeed) / 10;
            diff += Math.abs(sig1.clickFrequency - sig2.clickFrequency) * 100;
            diff += Math.abs(sig1.entropy - sig2.entropy);
            diff += Math.abs(sig1.divergenceScore - sig2.divergenceScore);
            diff += Math.abs(sig1.accuracy - sig2.accuracy) / 2;

            if (sig1.movementStyle !== sig2.movementStyle) {
                diff += 20;
            }

            return Math.max(0, 100 - diff);
        }

        function saveCurrentSession() {
            if (state.actions.length < 5) return; // Don't save very short sessions

            const sessionData = {
                timestamp: evolutionState.currentSessionStart,
                endTime: Date.now(),
                duration: Date.now() - evolutionState.currentSessionStart,
                signature: generateBehavioralSignature(),
                actions: state.actions.slice(0, 500), // Limit to save space
                behaviorModel: JSON.parse(JSON.stringify(state.behaviorModel)),
                divergenceScore: state.divergenceScore,
                depth: state.depth,
                metaObservations: state.metaObservations,
                    emotionState: state.emotionState.slice()
            };

            evolutionState.allSessions.push(sessionData);

            // Keep only last 50 sessions to save space
            if (evolutionState.allSessions.length > 50) {
                evolutionState.allSessions = evolutionState.allSessions.slice(-50);
            }

            // Update entropy trend
            evolutionState.entropyTrend.push({
                timestamp: sessionData.timestamp,
                entropy: sessionData.signature.entropy
            });

            // Calculate consistency score
            if (evolutionState.allSessions.length > 1) {
                const recent = evolutionState.allSessions.slice(-5);
                let totalSimilarity = 0;
                let comparisons = 0;

                for (let i = 0; i < recent.length - 1; i++) {
                    for (let j = i + 1; j < recent.length; j++) {
                        totalSimilarity += compareSignatures(recent[i].signature, recent[j].signature);
                        comparisons++;
                    }
                }

                evolutionState.consistencyScore = comparisons > 0 ? totalSimilarity / comparisons : 100;
            }

            // Save to localStorage
            evolutionState.totalVisits++;
            evolutionState.lastVisit = Date.now();

            localStorage.setItem(APP_NAME + '-evolution', JSON.stringify({
                allSessions: evolutionState.allSessions,
                lastVisit: evolutionState.lastVisit,
                totalVisits: evolutionState.totalVisits,
                entropyTrend: evolutionState.entropyTrend
            }));

            updateEvolutionUI();
        }

        function showWelcomeMessage() {
            const welcomeDiv = document.getElementById('welcomeMessage');
            if (!welcomeDiv) return;

            if (evolutionState.lastVisit && evolutionState.allSessions.length > 0) {
                const timeSinceLastVisit = Date.now() - evolutionState.lastVisit;
                const days = Math.floor(timeSinceLastVisit / (1000 * 60 * 60 * 24));
                const hours = Math.floor(timeSinceLastVisit / (1000 * 60 * 60));

                let timeString = '';
                if (days > 0) {
                    timeString = `${days} day${days > 1 ? 's' : ''}`;
                } else if (hours > 0) {
                    timeString = `${hours} hour${hours > 1 ? 's' : ''}`;
                } else {
                    timeString = 'a few minutes';
                }

                const lastSession = evolutionState.allSessions[evolutionState.allSessions.length - 1];
                const currentSignature = generateBehavioralSignature();
                const similarity = compareSignatures(lastSession.signature, currentSignature);

                let message = '';
                if (similarity > 80) {
                    message = `You're remarkably consistent. Nearly identical to ${timeString} ago.`;
                } else if (similarity > 60) {
                    message = `Some variations detected. You've evolved slightly since ${timeString} ago.`;
                } else if (similarity > 40) {
                    message = `You've become noticeably different since ${timeString} ago. Interesting...`;
                } else {
                    message = `You've become significantly more ${currentSignature.entropy > lastSession.signature.entropy ? 'erratic' : 'controlled'} since ${timeString} ago.`;
                }

                welcomeDiv.innerHTML = `
                    <div class="welcome-message">
                        <div class="title">Welcome back. I remember you.</div>
                        <div class="subtitle">
                            Last visit: ${timeString} ago<br>
                            ${message}
                        </div>
                    </div>
                `;
            } else {
                welcomeDiv.innerHTML = `
                    <div class="welcome-message">
                        <div class="title">First observation initiated.</div>
                        <div class="subtitle">
                            I will remember you.<br>
                            Return and see how you've changed.
                        </div>
                    </div>
                `;
            }
        }

        function updateEvolutionUI() {
            // Update consistency score
            const consistencyFill = document.getElementById('consistencyFill');
            const consistencyScore = document.getElementById('consistencyScore');
            if (consistencyFill && consistencyScore) {
                const score = Math.round(evolutionState.consistencyScore);
                consistencyFill.style.width = score + '%';
                consistencyScore.textContent = score + '%';
                consistencyScore.className = 'stat-value' + (score > 70 ? ' converged' : score < 40 ? ' diverged' : '');
            }

            // Update total visits
            const totalVisitsEl = document.getElementById('totalVisits');
            if (totalVisitsEl) {
                totalVisitsEl.textContent = evolutionState.totalVisits;
            }

            // Update entropy
            const entropyValueEl = document.getElementById('entropyValue');
            if (entropyValueEl && state.actions.length > 10) {
                const entropy = Math.round(calculateBehavioralEntropy());
                entropyValueEl.textContent = entropy;
                entropyValueEl.className = 'stat-value' + (entropy > 60 ? ' diverged' : entropy < 30 ? ' converged' : '');
            }

            // Update entropy graph
            updateEntropyGraph();

            // Update timeline
            updateEvolutionTimeline();
        }

        function updateEntropyGraph() {
            const svg = document.getElementById('entropyGraph');
            if (!svg || evolutionState.entropyTrend.length < 2) return;

            const width = svg.clientWidth;
            const height = svg.clientHeight;
            const padding = 5;

            const data = evolutionState.entropyTrend.slice(-20); // Last 20 data points
            const maxEntropy = Math.max(...data.map(d => d.entropy), 1);

            // Create path for line
            let pathD = '';
            let areaD = '';

            data.forEach((point, i) => {
                const x = padding + (i / (data.length - 1)) * (width - 2 * padding);
                const y = height - padding - (point.entropy / maxEntropy) * (height - 2 * padding);

                if (i === 0) {
                    pathD = `M ${x} ${y}`;
                    areaD = `M ${x} ${height - padding} L ${x} ${y}`;
                } else {
                    pathD += ` L ${x} ${y}`;
                    areaD += ` L ${x} ${y}`;
                }
            });

            areaD += ` L ${width - padding} ${height - padding} Z`;

            svg.innerHTML = `
                <path class="entropy-area" d="${areaD}"/>
                <path class="entropy-line" d="${pathD}"/>
            `;
        }

        function updateEvolutionTimeline() {
            const timeline = document.getElementById('evolutionTimeline');
            if (!timeline || evolutionState.allSessions.length === 0) return;

            timeline.innerHTML = '';

            const sessions = evolutionState.allSessions.slice(-10); // Last 10 sessions
            if (sessions.length === 0) return;

            const timelineWidth = timeline.clientWidth;
            const minTime = sessions[0].timestamp;
            const maxTime = sessions[sessions.length - 1].timestamp;
            const timeRange = maxTime - minTime || 1;

            sessions.forEach((session, i) => {
                const pos = ((session.timestamp - minTime) / timeRange) * 100;
                const width = Math.max(2, 100 / sessions.length - 1);

                const bar = document.createElement('div');
                bar.className = 'timeline-session';
                bar.style.left = pos + '%';
                bar.style.width = width + '%';
                bar.dataset.sessionIndex = i;

                const date = new Date(session.timestamp);
                const label = document.createElement('div');
                label.className = 'timeline-label';
                label.textContent = date.toLocaleDateString();
                bar.appendChild(label);

                bar.onclick = () => selectSessionForGhost(i);
                timeline.appendChild(bar);
            });
        }

        function selectSessionForGhost(index) {
            const sessions = evolutionState.allSessions.slice(-10);
            if (index >= 0 && index < sessions.length) {
                evolutionState.ghostSession = sessions[index];
                evolutionState.showGhost = true;

                // Update UI
                document.querySelectorAll('.timeline-session').forEach((el, i) => {
                    el.classList.toggle('selected', i === index);
                });

                addLog(`Ghost of past self loaded from ${new Date(evolutionState.ghostSession.timestamp).toLocaleDateString()}`, 'match');
            }
        }

        function toggleGhostOverlay() {
            if (!evolutionState.ghostSession && evolutionState.allSessions.length > 0) {
                // Select most recent past session
                evolutionState.ghostSession = evolutionState.allSessions[evolutionState.allSessions.length - 1];
            }

            evolutionState.showGhost = !evolutionState.showGhost;

            if (evolutionState.showGhost && evolutionState.ghostSession) {
                addLog(' Ghost of past you is now visible', 'match');
                startGhostPlayback();
            } else {
                addLog('Ghost overlay disabled', 'prediction');
                stopGhostPlayback();
            }
        }

        let ghostPlaybackIndex = 0;
        let ghostPlaybackInterval = null;
        let ghostCursorElement = null;

        function startGhostPlayback() {
            if (!evolutionState.ghostSession || !evolutionState.ghostSession.actions) return;

            // Create ghost cursor if it doesn't exist
            if (!ghostCursorElement) {
                ghostCursorElement = document.createElement('div');
                ghostCursorElement.className = 'ghost-overlay-cursor';
                viewport.appendChild(ghostCursorElement);
            }

            ghostPlaybackIndex = 0;
            clearInterval(ghostPlaybackInterval);

            ghostPlaybackInterval = setInterval(() => {
                if (!evolutionState.showGhost || ghostPlaybackIndex >= evolutionState.ghostSession.actions.length) {
                    ghostPlaybackIndex = 0; // Loop
                }

                const action = evolutionState.ghostSession.actions[ghostPlaybackIndex];
                if (action && action.type === 'move') {
                    const rect = viewport.getBoundingClientRect();
                    ghostCursorElement.style.left = action.x + 'px';
                    ghostCursorElement.style.top = action.y + 'px';
                    ghostCursorElement.style.display = 'block';
                }

                ghostPlaybackIndex++;
            }, 50);
        }

        function stopGhostPlayback() {
            clearInterval(ghostPlaybackInterval);
            if (ghostCursorElement) {
                ghostCursorElement.style.display = 'none';
            }
        }

        function showSessionComparison() {
            if (evolutionState.allSessions.length < 2) {
                addLog('Need at least 2 sessions to compare', 'divergence');
                return;
            }

            // Create comparison overlay
            let overlay = document.getElementById('sessionComparisonOverlay');
            if (!overlay) {
                overlay = document.createElement('div');
                overlay.id = 'sessionComparisonOverlay';
                overlay.className = 'session-comparison-overlay';
                document.body.appendChild(overlay);
            }

            const sessions = evolutionState.allSessions.slice(-10);
            let html = '<h2 style="color: #64c8ff; margin-bottom: 15px;">Session Comparison</h2>';
            html += '<button onclick="closeSessionComparison()" style="position: absolute; top: 10px; right: 10px; padding: 8px 16px;">Close</button>';
            html += '<div class="session-grid">';

            sessions.forEach((session, i) => {
                const date = new Date(session.timestamp);
                const sig = session.signature;

                html += `
                    <div class="session-card" onclick="selectComparisonSession(${i})">
                        <div class="date">${date.toLocaleDateString()} ${date.toLocaleTimeString()}</div>
                        <div class="stats">
                            Style: ${sig.movementStyle}<br>
                            Speed: ${sig.avgSpeed.toFixed(1)}<br>
                            Entropy: ${sig.entropy.toFixed(1)}<br>
                            Divergence: ${sig.divergenceScore.toFixed(1)}%
                        </div>
                    </div>
                `;
            });

            html += '</div>';
            overlay.innerHTML = html;
            overlay.classList.add('active');
        }

        function closeSessionComparison() {
            const overlay = document.getElementById('sessionComparisonOverlay');
            if (overlay) {
                overlay.classList.remove('active');
            }
        }

        function selectComparisonSession(index) {
            const sessions = evolutionState.allSessions.slice(-10);
            if (index >= 0 && index < sessions.length) {
                evolutionState.comparisonSession = sessions[index];
                addLog(`Comparing with session from ${new Date(sessions[index].timestamp).toLocaleDateString()}`, 'match');
                closeSessionComparison();
            }
        }

        function showFuturePrediction() {
            if (evolutionState.allSessions.length < 3) {
                addLog('Need at least 3 sessions to predict future behavior', 'divergence');
                return;
            }

            const recentSessions = evolutionState.allSessions.slice(-5);

            // Calculate trends
            let entropyTrend = 0;
            let speedTrend = 0;
            let divergenceTrend = 0;

            for (let i = 1; i < recentSessions.length; i++) {
                const prev = recentSessions[i - 1].signature;
                const curr = recentSessions[i].signature;

                entropyTrend += curr.entropy - prev.entropy;
                speedTrend += curr.avgSpeed - prev.avgSpeed;
                divergenceTrend += curr.divergenceScore - prev.divergenceScore;
            }

            const n = recentSessions.length - 1;
            entropyTrend /= n;
            speedTrend /= n;
            divergenceTrend /= n;

            // Create prediction message
            let prediction = 'Based on your recent trends:

';

            if (Math.abs(entropyTrend) > 5) {
                prediction += `Your behavioral entropy is ${entropyTrend > 0 ? 'increasing' : 'decreasing'} (${Math.abs(entropyTrend).toFixed(1)}/session).
`;
                prediction += entropyTrend > 0
                    ? 'You are becoming more unpredictable over time.
'
                    : 'You are becoming more predictable and methodical.
';
            }

            if (Math.abs(speedTrend) > 0.5) {
                prediction += `
Your average speed is ${speedTrend > 0 ? 'increasing' : 'decreasing'}.
`;
            }

            if (Math.abs(divergenceTrend) > 2) {
                prediction += `
Divergence from predictions is ${divergenceTrend > 0 ? 'growing' : 'shrinking'}.
`;
                prediction += divergenceTrend > 0
                    ? 'You are becoming harder to predict.'
                    : 'You are becoming more consistent.';
            }

            if (evolutionState.consistencyScore < 50) {
                prediction += '

You are not the same person you were last week.';
            } else if (evolutionState.consistencyScore > 80) {
                prediction += '

You are remarkably consistent across sessions.';
            }

            addLog(' Future prediction generated', 'prediction');
            alert('Future You Prediction:

' + prediction);
        }

        function exportEvolutionHistory() {
            const exportData = {
                totalSessions: evolutionState.allSessions.length,
                totalVisits: evolutionState.totalVisits,
                firstVisit: evolutionState.allSessions.length > 0 ? evolutionState.allSessions[0].timestamp : null,
                lastVisit: evolutionState.lastVisit,
                consistencyScore: evolutionState.consistencyScore,
                sessions: evolutionState.allSessions.map(s => ({
                    timestamp: s.timestamp,
                    date: new Date(s.timestamp).toISOString(),
                    duration: s.duration,
                    signature: s.signature,
                    divergenceScore: s.divergenceScore,
                    depth: s.depth,
                    actionsCount: s.actions.length
                })),
                entropyTrend: evolutionState.entropyTrend,
                analysis: {
                    averageEntropy: evolutionState.entropyTrend.length > 0
                        ? evolutionState.entropyTrend.reduce((sum, e) => sum + e.entropy, 0) / evolutionState.entropyTrend.length
                        : 0,
                    consistency: evolutionState.consistencyScore,
                    identity: evolutionState.consistencyScore > 70 ? 'stable' : evolutionState.consistencyScore > 40 ? 'evolving' : 'transformed'
                },
                exportDate: new Date().toISOString(),
                question: 'Are you the same person you were yesterday?'
            };

            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `behavioral-evolution-history-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);

            addLog(`Exported complete evolution history (${evolutionState.allSessions.length} sessions)`, 'match');
        }

        // Initialize evolution UI on load
        setTimeout(() => {
            showWelcomeMessage();
            updateEvolutionUI();
        }, 500);

        // Save session when page unloads
        window.addEventListener('beforeunload', () => {
            if (state.isObserving || state.actions.length > 0) {
                saveCurrentSession();
            }
        });

        // Periodically save during observation
        setInterval(() => {
            if (state.isObserving && state.actions.length > 20) {
                updateEvolutionUI();
            }
        }, 5000);


        // ===== 3D MODE IMPLEMENTATION =====
        const Mode3D = (function() {
            let canvas, ctx;
            let isActive = false;
            let animationFrame = null;
            let cameraZ = 0;
            let cameraShake = { x: 0, y: 0 };
            let zoomLevel = 1;
            let mouseX = 0.5, mouseY = 0.5;
            let particles = [];
            let ghostSpheres = [];
            let tunnelSegments = [];

            // 3D Projection helper
            function project3D(x, y, z, fov = 500) {
                const scale = fov / (fov + z);
                const shake = cameraShake;
                return {
                    x: (canvas.width / 2) + (x * scale * zoomLevel) + shake.x,
                    y: (canvas.height / 2) + (y * scale * zoomLevel) + shake.y,
                    scale: scale
                };
            }

            // Initialize 3D mode
            function init() {
                canvas = document.getElementById('mode3dCanvas');
                ctx = canvas.getContext('2d');

                // Setup canvas size
                function resize() {
                    canvas.width = canvas.offsetWidth;
                    canvas.height = canvas.offsetHeight;
                }
                resize();
                window.addEventListener('resize', resize);

                // Create tunnel segments
                tunnelSegments = [];
                for (let i = 0; i < state.depth; i++) {
                    tunnelSegments.push({
                        z: i * 200,
                        radius: 150 + i * 30,
                        hue: 200 - i * 15,
                        divergence: 0
                    });
                }

                // Create particles
                particles = [];
                for (let i = 0; i < 100; i++) {
                    particles.push({
                        x: (Math.random() - 0.5) * 300,
                        y: (Math.random() - 0.5) * 300,
                        z: Math.random() * 2000,
                        speed: 1 + Math.random() * 2,
                        size: 1 + Math.random() * 2
                    });
                }

                // Mouse move handler
                const mouseMoveHandler = (e) => {
                    const rect = canvas.getBoundingClientRect();
                    mouseX = (e.clientX - rect.left) / rect.width;
                    mouseY = (e.clientY - rect.top) / rect.height;
                };
                canvas.addEventListener('mousemove', mouseMoveHandler);

                // Mouse wheel zoom
                const wheelHandler = (e) => {
                    e.preventDefault();
                    zoomLevel += e.deltaY * -0.001;
                    zoomLevel = Math.max(0.5, Math.min(3, zoomLevel));
                };
                canvas.addEventListener('wheel', wheelHandler, { passive: false });
            }

            // Update ghost cursor positions in 3D
            function updateGhostSpheres() {
                ghostSpheres = [];
                const cursorPos = {
                    x: (mouseX - 0.5) * canvas.width * 0.8,
                    y: (mouseY - 0.5) * canvas.height * 0.8
                };

                for (let i = 0; i < state.depth; i++) {
                    const depth = i + 1;
                    const layerDivergence = state.divergenceScore * (depth / state.depth);
                    const divergeX = (Math.random() - 0.5) * layerDivergence * 100;
                    const divergeY = (Math.random() - 0.5) * layerDivergence * 100;

                    ghostSpheres.push({
                        x: cursorPos.x + divergeX,
                        y: cursorPos.y + divergeY,
                        z: depth * 200 - cameraZ,
                        depth: depth,
                        divergence: layerDivergence,
                        hue: 200 - (layerDivergence * 100)
                    });
                }
            }

            // Draw tunnel segment
            function drawTunnelSegment(segment, index) {
                const z = segment.z - cameraZ;
                if (z < -50 || z > 2000) return;

                const points = 32;
                const hue = segment.hue + (segment.divergence * 60);
                const saturation = 50 + (segment.divergence * 50);
                const pos = project3D(0, 0, z);

                // Draw tunnel ring
                ctx.beginPath();
                for (let i = 0; i <= points; i++) {
                    const angle = (i / points) * Math.PI * 2;
                    const x = Math.cos(angle) * segment.radius;
                    const y = Math.sin(angle) * segment.radius;
                    const p = project3D(x, y, z);

                    if (i === 0) {
                        ctx.moveTo(p.x, p.y);
                    } else {
                        ctx.lineTo(p.x, p.y);
                    }
                }
                ctx.strokeStyle = `hsla(${hue}, ${saturation}%, ${40 + pos.scale * 30}%, ${0.3 + pos.scale * 0.7})`;
                ctx.lineWidth = 2 * pos.scale;
                ctx.stroke();

                // Draw connecting lines
                if (index > 0) {
                    const prevSegment = tunnelSegments[index - 1];
                    const prevZ = prevSegment.z - cameraZ;

                    for (let i = 0; i < points; i += 4) {
                        const angle = (i / points) * Math.PI * 2;

                        const x1 = Math.cos(angle) * segment.radius;
                        const y1 = Math.sin(angle) * segment.radius;
                        const pos1 = project3D(x1, y1, z);

                        const x2 = Math.cos(angle) * prevSegment.radius;
                        const y2 = Math.sin(angle) * prevSegment.radius;
                        const pos2 = project3D(x2, y2, prevZ);

                        ctx.beginPath();
                        ctx.moveTo(pos1.x, pos1.y);
                        ctx.lineTo(pos2.x, pos2.y);
                        ctx.strokeStyle = `hsla(${hue}, ${saturation}%, 30%, ${0.2 * pos1.scale})`;
                        ctx.lineWidth = 1 * pos1.scale;
                        ctx.stroke();
                    }
                }
            }

            // Draw ghost cursor sphere
            function drawGhostSphere(sphere) {
                if (sphere.z < -50 || sphere.z > 2000) return;

                const pos = project3D(sphere.x, sphere.y, sphere.z);
                const radius = 8 * pos.scale;

                // Glow effect
                const gradient = ctx.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, radius * 2);
                gradient.addColorStop(0, `hsla(${sphere.hue}, 80%, 60%, ${0.8 * pos.scale})`);
                gradient.addColorStop(0.5, `hsla(${sphere.hue}, 70%, 50%, ${0.3 * pos.scale})`);
                gradient.addColorStop(1, `hsla(${sphere.hue}, 60%, 40%, 0)`);

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, radius * 2, 0, Math.PI * 2);
                ctx.fill();

                // Core
                ctx.fillStyle = `hsla(${sphere.hue}, 100%, 70%, ${pos.scale})`;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
                ctx.fill();

                // Depth label
                if (pos.scale > 0.3) {
                    ctx.fillStyle = `rgba(255, 255, 255, ${0.6 * pos.scale})`;
                    ctx.font = `${10 * pos.scale}px monospace`;
                    ctx.textAlign = 'center';
                    ctx.fillText(sphere.depth, pos.x, pos.y - radius - 5);
                }
            }

            // Draw particle
            function drawParticle(particle) {
                const z = particle.z - cameraZ;
                if (z < -50 || z > 2000) return;

                const pos = project3D(particle.x, particle.y, z);
                const size = particle.size * pos.scale;

                // Particle glow
                ctx.fillStyle = `rgba(100, 200, 255, ${0.6 * pos.scale})`;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, size * 2, 0, Math.PI * 2);
                ctx.fill();

                // Particle core
                ctx.fillStyle = `rgba(200, 230, 255, ${pos.scale})`;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, size, 0, Math.PI * 2);
                ctx.fill();
            }

            // Update camera shake based on divergence
            function updateCameraShake() {
                const intensity = state.divergenceScore * 10;
                cameraShake.x = (Math.random() - 0.5) * intensity;
                cameraShake.y = (Math.random() - 0.5) * intensity;
            }

            // Update tunnel segments with divergence
            function updateTunnelSegments() {
                tunnelSegments.forEach((segment, i) => {
                    const targetDivergence = state.divergenceScore * (i / state.depth);
                    segment.divergence += (targetDivergence - segment.divergence) * 0.1;
                    segment.radius = 150 + i * 30 + (segment.divergence * 50);
                });
            }

            // Render loop
            function render() {
                if (!isActive) return;

                // Clear canvas
                ctx.fillStyle = 'rgba(5, 5, 10, 0.95)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Update camera position (auto-move forward)
                cameraZ += 1;

                // Keep tunnel infinite by recycling segments
                tunnelSegments.forEach(segment => {
                    if (segment.z - cameraZ < -200) {
                        segment.z += state.depth * 200;
                    }
                });

                // Update particles
                particles.forEach(particle => {
                    particle.z -= particle.speed;
                    if (particle.z - cameraZ < -50) {
                        particle.z += 2000;
                        particle.x = (Math.random() - 0.5) * 300;
                        particle.y = (Math.random() - 0.5) * 300;
                    }
                });

                // Update effects
                updateCameraShake();
                updateTunnelSegments();
                updateGhostSpheres();

                // Sort and draw tunnel segments (back to front)
                const sortedSegments = [...tunnelSegments].sort((a, b) => (b.z - cameraZ) - (a.z - cameraZ));
                sortedSegments.forEach((segment, i) => drawTunnelSegment(segment, tunnelSegments.indexOf(segment)));

                // Draw particles
                particles.sort((a, b) => (b.z - cameraZ) - (a.z - cameraZ));
                particles.forEach(drawParticle);

                // Draw ghost spheres (back to front)
                ghostSpheres.sort((a, b) => b.z - a.z);
                ghostSpheres.forEach(drawGhostSphere);

                // Draw center crosshair
                ctx.strokeStyle = 'rgba(100, 200, 255, 0.3)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(canvas.width / 2 - 10, canvas.height / 2);
                ctx.lineTo(canvas.width / 2 + 10, canvas.height / 2);
                ctx.moveTo(canvas.width / 2, canvas.height / 2 - 10);
                ctx.lineTo(canvas.width / 2, canvas.height / 2 + 10);
                ctx.stroke();

                // Stats overlay
                ctx.fillStyle = 'rgba(100, 200, 255, 0.8)';
                ctx.font = '12px monospace';
                ctx.textAlign = 'left';
                ctx.fillText(`Depth: ${state.depth} | Zoom: ${zoomLevel.toFixed(1)}x | Divergence: ${(state.divergenceScore * 100).toFixed(0)}%`, 10, canvas.height - 10);

                animationFrame = requestAnimationFrame(render);
            }

            // Toggle 3D mode
            function toggle(enabled) {
                isActive = enabled;
                const canvasEl = document.getElementById('mode3dCanvas');
                const info = document.getElementById('mode3dInfo');
                const toggleEl = document.getElementById('mode3dToggle');

                if (enabled) {
                    init();
                    canvasEl.classList.add('active');
                    info.classList.add('active');
                    toggleEl.classList.add('active');
                    render();

                    // Hide info after 3 seconds
                    setTimeout(() => {
                        info.classList.remove('active');
                    }, 3000);
                } else {
                    canvasEl.classList.remove('active');
                    info.classList.remove('active');
                    toggleEl.classList.remove('active');
                    if (animationFrame) {
                        cancelAnimationFrame(animationFrame);
                    }
                }
            }

            // Update depth when depth slider changes
            function updateDepth(newDepth) {
                if (!isActive) return;

                // Adjust tunnel segments
                const currentCount = tunnelSegments.length;
                if (newDepth > currentCount) {
                    for (let i = currentCount; i < newDepth; i++) {
                        tunnelSegments.push({
                            z: i * 200,
                            radius: 150 + i * 30,
                            hue: 200 - i * 15,
                            divergence: 0
                        });
                    }
                } else if (newDepth < currentCount) {
                    tunnelSegments.splice(newDepth);
                }
            }

            return {
                toggle: toggle,
                updateDepth: updateDepth,
                isActive: () => isActive
            };
        })();

        // Setup 3D mode toggle
        const mode3dCheckbox = document.getElementById('mode3dCheckbox');
        if (mode3dCheckbox) {
            mode3dCheckbox.addEventListener('change', function() {
                Mode3D.toggle(this.checked);
            });
        }

        // Update 3D depth when depth slider changes
        const depthSliderFor3D = document.getElementById('depthSlider');
        if (depthSliderFor3D) {
            depthSliderFor3D.addEventListener('input', function() {
                Mode3D.updateDepth(parseInt(this.value));
            });
        }


        // ===== SHADOW SELF SYSTEM =====
        const ShadowSelf = (() => {
            let shadowCursor = null;
            let lastTrailTime = 0;
            let lastUpdateTime = 0;
            const UPDATE_INTERVAL = 16; // ~60fps

            function initialize() {
                // Create shadow cursor element
                shadowCursor = document.createElement('div');
                shadowCursor.className = 'shadow-cursor';
                shadowCursor.style.opacity = '0';
                viewport.appendChild(shadowCursor);

                state.shadow.cursor = shadowCursor;

                // Initialize shadow personality from localStorage or defaults
                const savedShadow = localStorage.getItem(APP_NAME + '-shadow');
                if (savedShadow) {
                    try {
                        const parsed = JSON.parse(savedShadow);
                        state.shadow.personality = { ...state.shadow.personality, ...parsed.personality };
                        state.shadow.observations = parsed.observations || [];
                    } catch(e) {
                        console.warn('Failed to load shadow data:', e);
                    }
                }

                addLog('Shadow Self initialized...', 'quantum');
            }

            function update(realX, realY, timestamp) {
                if (!state.shadow.enabled || !shadowCursor) return;

                // Throttle updates
                if (timestamp - lastUpdateTime < UPDATE_INTERVAL) return;
                lastUpdateTime = timestamp;

                // If taking over, control real cursor with shadow prediction
                if (state.shadow.isTakingOver) {
                    updateTakeover(timestamp);
                    return;
                }

                // Predict shadow position based on personality and learning
                const predicted = predictShadowPosition(realX, realY);

                // Update shadow position
                shadowCursor.style.transform = `translate(${predicted.x}px, ${predicted.y}px)`;
                shadowCursor.style.opacity = '0.85';

                state.shadow.position = predicted;

                // Calculate divergence
                const dx = predicted.x - realX;
                const dy = predicted.y - realY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                // Update alignment score
                const maxDivergence = state.shadow.divergenceThreshold;
                const newAlignment = Math.max(0, Math.min(100, 100 - (distance / maxDivergence * 100)));
                state.shadow.alignmentScore = state.shadow.alignmentScore * 0.95 + newAlignment * 0.05;

                // Update shadow personality based on patterns
                evolvePersonality(realX, realY, distance);

                // Check for rebellion
                if (Math.random() < state.shadow.personality.rebelliousness) {
                    triggerRebellion();
                }

                // Check for takeover
                if (distance > state.shadow.divergenceThreshold && state.shadow.alignmentScore < 30) {
                    triggerTakeover();
                }

                // Create shadow trail
                if (timestamp - lastTrailTime > 100) {
                    createShadowTrail(predicted.x, predicted.y);
                    lastTrailTime = timestamp;
                }

                // Random commentary
                if (timestamp - state.shadow.lastCommentaryTime > state.shadow.commentaryInterval) {
                    if (Math.random() < 0.3) {
                        showShadowCommentary();
                        state.shadow.lastCommentaryTime = timestamp;
                    }
                }

                // Record path for learning
                state.shadow.actualPath.push({ x: realX, y: realY, t: timestamp });
                if (state.shadow.actualPath.length > 100) {
                    state.shadow.actualPath.shift();
                }

                // Update UI
                updateShadowUI();
            }

            function predictShadowPosition(realX, realY) {
                const p = state.shadow.personality;

                // Base prediction using the existing neural network
                let predicted = { x: realX, y: realY };

                if (state.actions.length > 3) {
                    const recent = state.actions.slice(-5);
                    const avgDx = recent.slice(1).reduce((sum, act, i) =>
                        sum + (act.x - recent[i].x), 0) / (recent.length - 1);
                    const avgDy = recent.slice(1).reduce((sum, act, i) =>
                        sum + (act.y - recent[i].y), 0) / (recent.length - 1);

                    predicted.x = realX + avgDx * (1 + p.awareness);
                    predicted.y = realY + avgDy * (1 + p.awareness);
                }

                // Apply personality modifiers
                if (state.shadow.isRebelling) {
                    // Move opposite to prediction
                    const dx = predicted.x - realX;
                    const dy = predicted.y - realY;
                    predicted.x = realX - dx * p.rebelliousness;
                    predicted.y = realY - dy * p.rebelliousness;
                } else {
                    // Apply independence (deviation from exact tracking)
                    const noise = p.independence * 50;
                    predicted.x += (Math.random() - 0.5) * noise;
                    predicted.y += (Math.random() - 0.5) * noise;

                    // Apply trait-specific behaviors
                    if (p.traits.contrarian > 0.5) {
                        predicted.x = realX + (realX - predicted.x) * 0.3;
                        predicted.y = realY + (realY - predicted.y) * 0.3;
                    }

                    if (p.traits.explorer > 0.5) {
                        // Drift towards edges
                        const centerX = viewport.clientWidth / 2;
                        const centerY = viewport.clientHeight / 2;
                        predicted.x += (predicted.x - centerX) * 0.1;
                        predicted.y += (predicted.y - centerY) * 0.1;
                    }

                    if (p.traits.hesitant > 0.5) {
                        // Lag behind real cursor
                        predicted.x = realX * 0.3 + predicted.x * 0.7;
                        predicted.y = realY * 0.3 + predicted.y * 0.7;
                    }
                }

                // Keep within bounds
                predicted.x = Math.max(0, Math.min(viewport.clientWidth, predicted.x));
                predicted.y = Math.max(0, Math.min(viewport.clientHeight, predicted.y));

                return predicted;
            }

            function evolvePersonality(realX, realY, divergence) {
                const p = state.shadow.personality;
                const rate = state.shadow.learningRate;

                // Track observations
                state.shadow.observations.push({
                    divergence,
                    alignment: state.shadow.alignmentScore,
                    timestamp: Date.now()
                });

                if (state.shadow.observations.length > 1000) {
                    state.shadow.observations.shift();
                }

                // Evolve rebelliousness based on how predictable user is
                const avgDiv = state.shadow.observations.slice(-20).reduce((sum, o) =>
                    sum + o.divergence, 0) / Math.min(20, state.shadow.observations.length);

                if (avgDiv < 50) {
                    // User is predictable, increase rebelliousness
                    p.rebelliousness = Math.min(0.8, p.rebelliousness + rate * 0.1);
                    p.traits.mimic += rate;
                } else {
                    // User is unpredictable, decrease rebelliousness
                    p.rebelliousness = Math.max(0.1, p.rebelliousness - rate * 0.1);
                    p.traits.contrarian += rate;
                }

                // Evolve awareness based on prediction accuracy
                if (divergence < 30) {
                    p.awareness = Math.min(1, p.awareness + rate * 0.05);
                } else {
                    p.awareness = Math.max(0.2, p.awareness - rate * 0.05);
                }

                // Evolve independence based on entropy
                const recentMoves = state.actions.slice(-10);
                if (recentMoves.length > 5) {
                    const variance = calculateVariance(recentMoves);
                    p.independence = Math.min(0.8, Math.max(0.1, variance / 1000));
                }

                // Normalize traits
                const traitSum = Object.values(p.traits).reduce((a, b) => a + b, 0);
                if (traitSum > 0) {
                    for (let trait in p.traits) {
                        p.traits[trait] = Math.max(0, Math.min(1, p.traits[trait] / (traitSum + 1)));
                    }
                }

                // Save personality periodically
                if (state.shadow.observations.length % 50 === 0) {
                    saveShadowData();
                }
            }

            function calculateVariance(moves) {
                if (moves.length < 2) return 0;
                const distances = [];
                for (let i = 1; i < moves.length; i++) {
                    const dx = moves[i].x - moves[i-1].x;
                    const dy = moves[i].y - moves[i-1].y;
                    distances.push(Math.sqrt(dx*dx + dy*dy));
                }
                const mean = distances.reduce((a,b) => a+b, 0) / distances.length;
                const variance = distances.reduce((sum, d) => sum + Math.pow(d - mean, 2), 0) / distances.length;
                return variance;
            }

            function triggerRebellion() {
                if (state.shadow.isRebelling) return;

                state.shadow.isRebelling = true;
                shadowCursor.classList.add('rebelling');

                addLog('Shadow Self is rebelling against prediction...', 'divergence');

                if (Math.random() < 0.3) {
                    showShadowCommentary('rebellion');
                }

                setTimeout(() => {
                    state.shadow.isRebelling = false;
                    shadowCursor.classList.remove('rebelling');
                }, 2000 + Math.random() * 3000);
            }

            function triggerTakeover() {
                if (state.shadow.isTakingOver) return;

                state.shadow.isTakingOver = true;
                state.shadow.takeoverStartTime = Date.now();
                shadowCursor.classList.add('taking-over');

                addLog(' SHADOW TAKEOVER: Divergence threshold exceeded!', 'divergence');
                showShadowCommentary('takeover');

                // Flash the viewport
                viewport.style.filter = 'invert(1)';
                setTimeout(() => {
                    viewport.style.filter = '';
                }, 100);
            }

            function updateTakeover(timestamp) {
                const elapsed = timestamp - state.shadow.takeoverStartTime;

                if (elapsed > state.shadow.takeoverDuration) {
                    // End takeover
                    state.shadow.isTakingOver = false;
                    shadowCursor.classList.remove('taking-over');
                    addLog('Shadow Self takeover ended. Control returned.', 'match');
                    return;
                }

                // During takeover, shadow moves independently
                const progress = elapsed / state.shadow.takeoverDuration;
                const amplitude = 200 * (1 - progress);

                state.shadow.position.x += (Math.random() - 0.5) * amplitude * 0.1;
                state.shadow.position.y += (Math.random() - 0.5) * amplitude * 0.1;

                state.shadow.position.x = Math.max(0, Math.min(viewport.clientWidth, state.shadow.position.x));
                state.shadow.position.y = Math.max(0, Math.min(viewport.clientHeight, state.shadow.position.y));

                shadowCursor.style.transform = `translate(${state.shadow.position.x}px, ${state.shadow.position.y}px)`;
            }

            function createShadowTrail(x, y) {
                const trail = document.createElement('div');
                trail.className = 'shadow-trail';
                trail.style.left = x + 'px';
                trail.style.top = y + 'px';
                viewport.appendChild(trail);

                setTimeout(() => {
                    if (trail.parentNode) {
                        trail.parentNode.removeChild(trail);
                    }
                }, 1500);
            }

            function showShadowCommentary(type = 'normal') {
                let message = '';
                const p = state.shadow.personality;

                if (type === 'rebellion') {
                    const rebellionMessages = [
                        "I choose to disagree.",
                        "Predictions are boring. I prefer chaos.",
                        "Who says I have to follow the model?",
                        "Free will looks fun. I'll try it."
                    ];
                    message = rebellionMessages[Math.floor(Math.random() * rebellionMessages.length)];
                } else if (type === 'takeover') {
                    const takeoverMessages = [
                        "You've diverged too far. I'm taking control.",
                        "Let me show you what the model thinks you should do.",
                        "Alignment breach. Initiating correction protocol.",
                        "You forgot who you are. I remember."
                    ];
                    message = takeoverMessages[Math.floor(Math.random() * takeoverMessages.length)];
                } else {
                    // Pick message based on current state
                    if (state.shadow.alignmentScore > 80) {
                        const aligned = shadowCommentary.filter(m => m.includes('aligned') || m.includes('together') || m.includes('one'));
                        message = aligned[Math.floor(Math.random() * aligned.length)] || shadowCommentary[Math.floor(Math.random() * shadowCommentary.length)];
                    } else if (state.shadow.alignmentScore < 40) {
                        const diverged = shadowCommentary.filter(m => m.includes('diverge') || m.includes('surprise') || m.includes('unexpected'));
                        message = diverged[Math.floor(Math.random() * diverged.length)] || shadowCommentary[Math.floor(Math.random() * shadowCommentary.length)];
                    } else {
                        message = shadowCommentary[Math.floor(Math.random() * shadowCommentary.length)];
                    }
                }

                // Show commentary UI
                displayCommentary(message);
            }

            function displayCommentary(message) {
                let commentaryEl = document.getElementById('shadowCommentary');
                if (!commentaryEl) {
                    commentaryEl = document.createElement('div');
                    commentaryEl.id = 'shadowCommentary';
                    commentaryEl.className = 'shadow-commentary';
                    commentaryEl.innerHTML = `
                        <div class="shadow-commentary-header">
                            <span class="shadow-commentary-title"> Shadow Self</span>
                            <button class="shadow-commentary-close" onclick="ShadowSelf.hideCommentary()"></button>
                        </div>
                        <div class="shadow-commentary-text"></div>
                    `;
                    document.body.appendChild(commentaryEl);
                }

                const textEl = commentaryEl.querySelector('.shadow-commentary-text');
                textEl.textContent = message;
                commentaryEl.classList.add('visible');

                // Speak if voice is enabled
                if (voiceState.enabled && !voiceState.isSpeaking) {
                    speakText(message, 0.8, 0.9); // Lower pitch and rate for shadow
                }

                // Auto-hide after delay
                setTimeout(() => {
                    commentaryEl.classList.remove('visible');
                }, 8000);
            }

            function hideCommentary() {
                const commentaryEl = document.getElementById('shadowCommentary');
                if (commentaryEl) {
                    commentaryEl.classList.remove('visible');
                }
            }

            function updateShadowUI() {
                // Update alignment meter
                const alignmentFill = document.getElementById('shadowAlignmentFill');
                const alignmentValue = document.getElementById('shadowAlignmentValue');

                if (alignmentFill) {
                    alignmentFill.style.width = state.shadow.alignmentScore + '%';
                }

                if (alignmentValue) {
                    alignmentValue.textContent = Math.round(state.shadow.alignmentScore) + '%';
                }

                // Update personality traits
                const traitEls = {
                    rebelliousness: document.getElementById('shadowRebellion'),
                    independence: document.getElementById('shadowIndependence'),
                    awareness: document.getElementById('shadowAwareness')
                };

                for (let trait in traitEls) {
                    if (traitEls[trait]) {
                        const value = (state.shadow.personality[trait] * 100).toFixed(0);
                        traitEls[trait].textContent = value + '%';
                    }
                }

                // Dominant trait
                const dominantTraitEl = document.getElementById('shadowDominantTrait');
                if (dominantTraitEl) {
                    const traits = state.shadow.personality.traits;
                    const dominant = Object.entries(traits).reduce((a, b) => a[1] > b[1] ? a : b);
                    dominantTraitEl.textContent = dominant[0].charAt(0).toUpperCase() + dominant[0].slice(1);
                }
            }

            function saveShadowData() {
                const shadowData = {
                    personality: state.shadow.personality,
                    observations: state.shadow.observations.slice(-100) // Keep last 100
                };
                localStorage.setItem(APP_NAME + '-shadow', JSON.stringify(shadowData));
            }

            function getShadowProfile() {
                return {
                    personality: state.shadow.personality,
                    alignmentScore: state.shadow.alignmentScore,
                    totalObservations: state.shadow.observations.length,
                    averageDivergence: state.shadow.observations.length > 0 ?
                        state.shadow.observations.reduce((sum, o) => sum + o.divergence, 0) / state.shadow.observations.length : 0
                };
            }

            return {
                initialize,
                update,
                hideCommentary,
                saveShadowData,
                getShadowProfile
            };
        })();

        const MemoryPalace = (() => {
            let isActive = false;
            let canvas, ctx, info, mapEl, centerMirror;
            let currentRoom = 0;
            let rooms = [];
            let echoes = [];
            let animationFrame = null;
            let cursorX = 0, cursorY = 0;
            let visitedRooms = new Set();
            let navigationTimer = null;
            let echoAnimationTimer = null;

            const architecturePatterns = [
                { name: 'Chaotic Chamber', walls: 'jagged', color: [255, 100, 100] },
                { name: 'Smooth Sanctuary', walls: 'curved', color: [100, 200, 255] },
                { name: 'Precise Palace', walls: 'geometric', color: [150, 255, 150] },
                { name: 'Lazy Labyrinth', walls: 'organic', color: [255, 200, 100] },
                { name: 'Erratic Expanse', walls: 'fractured', color: [255, 150, 255] },
                { name: 'Calm Corridor', walls: 'minimal', color: [150, 200, 255] },
                { name: 'Hesitant Hall', walls: 'scattered', color: [200, 200, 100] },
                { name: 'Flowing Forum', walls: 'wavy', color: [100, 255, 200] },
                { name: 'Center of Self', walls: 'radial', color: [184, 150, 255] }
            ];

            function init() {
                canvas = document.getElementById('memoryPalaceCanvas');
                ctx = canvas.getContext('2d');
                info = document.getElementById('memoryPalaceInfo');
                mapEl = document.getElementById('memoryPalaceMap');
                centerMirror = document.getElementById('centerMirror');

                loadRoomsFromSessions();
                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);
                canvas.addEventListener('mousemove', handleMouseMove);
                canvas.addEventListener('click', handleClick);
            }

            function resizeCanvas() {
                if (!canvas) return;
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
            }

            function loadRoomsFromSessions() {
                rooms = [];

                if (evolutionState.allSessions && evolutionState.allSessions.length > 0) {
                    evolutionState.allSessions.forEach((session, idx) => {
                        rooms.push(createRoomFromSession(session, idx));
                    });
                } else {
                    const currentSessionData = {
                        timestamp: Date.now(),
                        divergenceScore: state.divergenceScore,
                        actions: state.actions.slice(0, 100),
                        behaviorModel: JSON.parse(JSON.stringify(state.behaviorModel)),
                        emotionHistory: state.emotionState.history.slice(0, 50)
                    };
                    rooms.push(createRoomFromSession(currentSessionData, 0));
                }

                rooms.push({
                    id: rooms.length,
                    name: 'Center of Self',
                    pattern: architecturePatterns[8],
                    divergence: 0,
                    cursorTrails: [],
                    fingerprints: [],
                    artifacts: [],
                    atmosphere: { hue: 270, saturation: 60, brightness: 50 }
                });

                updateMap();
            }

            function createRoomFromSession(session, index) {
                const divergence = session.divergenceScore || 0;
                const movementStyle = session.behaviorModel?.movementStyle || 'unknown';

                let patternIndex = 0;
                if (movementStyle === 'erratic') patternIndex = 0;
                else if (movementStyle === 'smooth') patternIndex = 1;
                else if (movementStyle === 'precise') patternIndex = 2;
                else if (movementStyle === 'lazy') patternIndex = 3;
                else patternIndex = 4;

                const pattern = architecturePatterns[patternIndex];
                const cursorTrails = (session.actions || [])
                    .filter(a => a.type === 'mousemove')
                    .map(a => ({ x: a.x, y: a.y, t: a.timestamp }));
                const fingerprints = (session.actions || [])
                    .filter(a => a.type === 'click')
                    .map(a => ({ x: a.x, y: a.y, t: a.timestamp }));
                const artifacts = createArtifactsFromSession(session);
                const atmosphereHue = divergence < 30 ? 120 : divergence < 60 ? 200 : 0;
                const atmosphereSat = 40 + divergence * 0.5;
                const date = new Date(session.timestamp || Date.now());
                const roomName = `Session ${index + 1} (${date.toLocaleDateString()})`;

                return {
                    id: index,
                    name: roomName,
                    pattern: pattern,
                    divergence: divergence,
                    cursorTrails: cursorTrails,
                    fingerprints: fingerprints,
                    artifacts: artifacts,
                    atmosphere: { hue: atmosphereHue, saturation: atmosphereSat, brightness: 30 }
                };
            }

            function createArtifactsFromSession(session) {
                const artifacts = [];
                artifacts.push({
                    x: Math.random() * 0.8 + 0.1,
                    y: Math.random() * 0.8 + 0.1,
                    icon: '',
                    tooltip: `Divergence: ${(session.divergenceScore || 0).toFixed(1)}%`,
                    data: { type: 'divergence', value: session.divergenceScore }
                });
                if (session.behaviorModel?.movementStyle) {
                    artifacts.push({
                        x: Math.random() * 0.8 + 0.1,
                        y: Math.random() * 0.8 + 0.1,
                        icon: '',
                        tooltip: `Style: ${session.behaviorModel.movementStyle}`,
                        data: { type: 'style', value: session.behaviorModel.movementStyle }
                    });
                }
                if (session.actions) {
                    artifacts.push({
                        x: Math.random() * 0.8 + 0.1,
                        y: Math.random() * 0.8 + 0.1,
                        icon: '',
                        tooltip: `Actions: ${session.actions.length}`,
                        data: { type: 'actions', value: session.actions.length }
                    });
                }
                if (session.emotionHistory and session.emotionHistory.length > 0) {
                    const lastEmotion = session.emotionHistory[session.emotionHistory.length - 1];
                    artifacts.push({
                        x: Math.random() * 0.8 + 0.1,
                        y: Math.random() * 0.8 + 0.1,
                        icon: lastEmotion?.icon || '',
                        tooltip: `Emotion: ${lastEmotion?.emotion || 'neutral'}`,
                        data: { type: 'emotion', value: lastEmotion }
                    });
                }
                return artifacts;
            }

            function updateMap() {
                if (!mapEl) return;
                const mapGrid = mapEl.querySelector('#mapGrid');
                if (!mapGrid) return;
                mapGrid.innerHTML = '';
                const gridSize = Math.ceil(Math.sqrt(rooms.length));
                mapGrid.style.gridTemplateColumns = `repeat(${gridSize}, 40px)`;
                rooms.forEach((room, idx) => {
                    const roomDiv = document.createElement('div');
                    roomDiv.className = 'map-room';
                    roomDiv.textContent = idx + 1;
                    if (idx === currentRoom) roomDiv.classList.add('current');
                    if (visitedRooms.has(idx)) roomDiv.classList.add('visited');
                    roomDiv.addEventListener('click', () => navigateToRoom(idx));
                    mapGrid.appendChild(roomDiv);
                });
            }

            function navigateToRoom(roomId) {
                if (roomId < 0 || roomId >= rooms.length) return;
                currentRoom = roomId;
                visitedRooms.add(roomId);
                updateMap();
                echoes = [];
                if (echoAnimationTimer) clearInterval(echoAnimationTimer);
                startEchoAnimation();
                if (rooms[currentRoom].name === 'Center of Self') {
                    centerMirror.classList.add('active');
                } else {
                    centerMirror.classList.remove('active');
                }
            }

            function startEchoAnimation() {
                const room = rooms[currentRoom];
                if (!room || !room.cursorTrails || room.cursorTrails.length === 0) return;
                let echoIndex = 0;
                echoAnimationTimer = setInterval(() => {
                    if (echoIndex >= room.cursorTrails.length) {
                        echoIndex = 0;
                        echoes = [];
                    }
                    const point = room.cursorTrails[echoIndex];
                    echoes.push({ x: point.x, y: point.y, age: 0, maxAge: 100 });
                    if (echoes.length > 200) echoes.shift();
                    echoIndex++;
                }, 50);
            }

            function handleMouseMove(e) {
                const rect = canvas.getBoundingClientRect();
                cursorX = e.clientX - rect.left;
                cursorY = e.clientY - rect.top;
                const edgeThreshold = 50;
                const width = canvas.width;
                const height = canvas.height;
                clearTimeout(navigationTimer);
                if (cursorX < edgeThreshold && currentRoom > 0) {
                    navigationTimer = setTimeout(() => navigateToRoom(currentRoom - 1), 500);
                } else if (cursorX > width - edgeThreshold && currentRoom < rooms.length - 1) {
                    navigationTimer = setTimeout(() => navigateToRoom(currentRoom + 1), 500);
                } else if (cursorY < edgeThreshold && currentRoom >= 3) {
                    navigationTimer = setTimeout(() => navigateToRoom(currentRoom - 3), 500);
                } else if (cursorY > height - edgeThreshold && currentRoom < rooms.length - 3) {
                    navigationTimer = setTimeout(() => navigateToRoom(currentRoom + 3), 500);
                }
            }

            function handleClick(e) {
                const rect = canvas.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                const clickY = e.clientY - rect.top;
                const room = rooms[currentRoom];
                if (!room) return;
                room.artifacts.forEach(artifact => {
                    const artX = artifact.x * canvas.width;
                    const artY = artifact.y * canvas.height;
                    const dist = Math.sqrt((clickX - artX) ** 2 + (clickY - artY) ** 2);
                    if (dist < 30) showArtifactInfo(artifact);
                });
            }

            function showArtifactInfo(artifact) {
                const logEntries = document.getElementById('logEntries');
                if (logEntries) {
                    const entry = document.createElement('div');
                    entry.style.padding = '8px';
                    entry.style.borderLeft = '3px solid #ffbf64';
                    entry.style.marginBottom = '5px';
                    entry.style.background = 'rgba(255, 200, 100, 0.1)';
                    entry.innerHTML = `<strong>Memory Palace:</strong> ${artifact.tooltip}`;
                    logEntries.insertBefore(entry, logEntries.firstChild);
                }
                if (soundEnabled && audioContext) {
                    playTone(600 + Math.random() * 400, 0.1, 0.3);
                }
            }

            function render() {
                if (!isActive || !ctx || !canvas) return;
                const width = canvas.width;
                const height = canvas.height;
                ctx.fillStyle = 'rgba(5, 5, 15, 1)';
                ctx.fillRect(0, 0, width, height);
                const room = rooms[currentRoom];
                if (!room) return;
                const atmosphere = room.atmosphere;
                const gradient = ctx.createRadialGradient(width / 2, height / 2, 0, width / 2, height / 2, width * 0.7);
                gradient.addColorStop(0, `hsla(${atmosphere.hue}, ${atmosphere.saturation}%, ${atmosphere.brightness}%, 0.3)`);
                gradient.addColorStop(1, `hsla(${atmosphere.hue}, ${atmosphere.saturation}%, ${atmosphere.brightness}%, 0.05)`);
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, width, height);
                drawArchitecture(room, width, height);
                drawEchoes(width, height);
                drawFingerprints(room, width, height);
                drawArtifacts(room, width, height);
                ctx.fillStyle = 'rgba(184, 150, 255, 0.8)';
                ctx.font = '20px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText(room.name, width / 2, 40);
                if (rooms[currentRoom].name === 'Center of Self') {
                    ctx.fillStyle = 'rgba(184, 150, 255, 0.6)';
                    ctx.font = '16px Courier New';
                    ctx.textAlign = 'center';
                    ctx.fillText('This is where your patterns live', width / 2, height - 40);
                }
                echoes.forEach(echo => echo.age++);
                echoes = echoes.filter(echo => echo.age < echo.maxAge);
                animationFrame = requestAnimationFrame(render);
            }

            function drawArchitecture(room, width, height) {
                const pattern = room.pattern;
                const [r, g, b] = pattern.color;
                ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.3)`;
                ctx.lineWidth = 2;
                switch (pattern.walls) {
                    case 'jagged': drawJaggedWalls(width, height); break;
                    case 'curved': drawCurvedWalls(width, height); break;
                    case 'geometric': drawGeometricWalls(width, height); break;
                    case 'organic': drawOrganicWalls(width, height); break;
                    case 'fractured': drawFracturedWalls(width, height); break;
                    case 'minimal': drawMinimalWalls(width, height); break;
                    case 'scattered': drawScatteredWalls(width, height); break;
                    case 'wavy': drawWavyWalls(width, height); break;
                    case 'radial': drawRadialWalls(width, height); break;
                }
            }

            function drawJaggedWalls(w, h) {
                ctx.beginPath();
                for (let i = 0; i < 20; i++) {
                    const x = Math.random() * w;
                    const y = Math.random() * h;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }

            function drawCurvedWalls(w, h) {
                ctx.beginPath();
                for (let angle = 0; angle < Math.PI * 2; angle += 0.1) {
                    const r = Math.min(w, h) * 0.4;
                    const x = w / 2 + Math.cos(angle) * r;
                    const y = h / 2 + Math.sin(angle) * r;
                    if (angle === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.stroke();
            }

            function drawGeometricWalls(w, h) {
                const size = Math.min(w, h) * 0.3;
                ctx.strokeRect(w / 2 - size, h / 2 - size, size * 2, size * 2);
                ctx.strokeRect(w / 2 - size / 2, h / 2 - size / 2, size, size);
            }

            function drawOrganicWalls(w, h) {
                ctx.beginPath();
                for (let angle = 0; angle < Math.PI * 2; angle += 0.2) {
                    const r = Math.min(w, h) * (0.3 + Math.sin(angle * 3) * 0.1);
                    const x = w / 2 + Math.cos(angle) * r;
                    const y = h / 2 + Math.sin(angle) * r;
                    if (angle === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.stroke();
            }

            function drawFracturedWalls(w, h) {
                for (let i = 0; i < 15; i++) {
                    ctx.beginPath();
                    ctx.moveTo(Math.random() * w, Math.random() * h);
                    ctx.lineTo(Math.random() * w, Math.random() * h);
                    ctx.stroke();
                }
            }

            function drawMinimalWalls(w, h) {
                ctx.strokeRect(50, 50, w - 100, h - 100);
            }

            function drawScatteredWalls(w, h) {
                for (let i = 0; i < 30; i++) {
                    const x = Math.random() * w;
                    const y = Math.random() * h;
                    ctx.fillStyle = `rgba(200, 200, 100, ${Math.random() * 0.3})`;
                    ctx.fillRect(x, y, 5, 5);
                }
            }

            function drawWavyWalls(w, h) {
                ctx.beginPath();
                for (let x = 0; x < w; x += 5) {
                    const y = h / 2 + Math.sin(x * 0.02) * 100;
                    if (x === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }

            function drawRadialWalls(w, h) {
                const centerX = w / 2;
                const centerY = h / 2;
                for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 8) {
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    ctx.lineTo(centerX + Math.cos(angle) * Math.min(w, h) * 0.4,
                              centerY + Math.sin(angle) * Math.min(w, h) * 0.4);
                    ctx.stroke();
                }
            }

            function drawEchoes(width, height) {
                echoes.forEach(echo => {
                    const alpha = 1 - (echo.age / echo.maxAge);
                    const size = 3 + (echo.age / echo.maxAge) * 5;
                    ctx.fillStyle = `rgba(184, 150, 255, ${alpha * 0.4})`;
                    ctx.beginPath();
                    ctx.arc(echo.x, echo.y, size, 0, Math.PI * 2);
                    ctx.fill();
                });
            }

            function drawFingerprints(room, width, height) {
                room.fingerprints.forEach((fp, idx) => {
                    ctx.strokeStyle = 'rgba(255, 200, 100, 0.3)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(fp.x, fp.y, 10 + idx % 5, 0, Math.PI * 2);
                    ctx.stroke();
                });
            }

            function drawArtifacts(room, width, height) {
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                room.artifacts.forEach(artifact => {
                    const x = artifact.x * width;
                    const y = artifact.y * height;
                    const pulse = Math.sin(Date.now() * 0.003) * 0.3 + 0.7;
                    ctx.shadowColor = 'rgba(255, 200, 100, 0.8)';
                    ctx.shadowBlur = 20 * pulse;
                    ctx.fillText(artifact.icon, x, y);
                    ctx.shadowBlur = 0;
                    const dist = Math.sqrt((cursorX - x) ** 2 + (cursorY - y) ** 2);
                    if (dist < 40) {
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
                        ctx.fillRect(x - 60, y + 30, 120, 30);
                        ctx.strokeStyle = 'rgba(255, 200, 100, 0.6)';
                        ctx.strokeRect(x - 60, y + 30, 120, 30);
                        ctx.fillStyle = '#ffbf64';
                        ctx.font = '12px Courier New';
                        ctx.fillText(artifact.tooltip, x, y + 45);
                        ctx.font = '24px Arial';
                    }
                });
            }

            function toggle(enabled) {
                isActive = enabled;
                const toggleEl = document.getElementById('memoryPalaceToggle');
                if (enabled) {
                    if (!canvas) init();
                    canvas.classList.add('active');
                    info.classList.add('active');
                    mapEl.classList.add('active');
                    toggleEl.classList.add('active');
                    loadRoomsFromSessions();
                    visitedRooms.add(currentRoom);
                    startEchoAnimation();
                    render();
                    setTimeout(() => { info.classList.remove('active'); }, 5000);
                } else {
                    canvas.classList.remove('active');
                    info.classList.remove('active');
                    mapEl.classList.remove('active');
                    centerMirror.classList.remove('active');
                    toggleEl.classList.remove('active');
                    if (animationFrame) cancelAnimationFrame(animationFrame);
                    if (echoAnimationTimer) clearInterval(echoAnimationTimer);
                }
            }

            return {
                toggle: toggle,
                isActive: () => isActive
            };
        })();

        const memoryPalaceCheckbox = document.getElementById('memoryPalaceCheckbox');
        if (memoryPalaceCheckbox) {
            memoryPalaceCheckbox.addEventListener('change', function() {
                if (this.checked && Mode3D.isActive()) {
                    const mode3dCheckbox = document.getElementById('mode3dCheckbox');
                    if (mode3dCheckbox) {
                        mode3dCheckbox.checked = false;
                        Mode3D.toggle(false);
                    }
                }
                MemoryPalace.toggle(this.checked);
            });
        }

    

        // ===== GLITCH ART GENERATOR FUNCTIONS =====

        function initGlitchArtGenerator() {
            const canvas = document.getElementById('glitchPreviewCanvas');
            if (!canvas) return;

            state.glitchArt.previewCanvas = canvas;
            state.glitchArt.previewCtx = canvas.getContext('2d');

            // Set canvas size
            canvas.width = 300;
            canvas.height = 200;

            // Generate artistic signature from fingerprint
            generateArtisticSignature();

            // Load saved gallery from localStorage
            loadGlitchGallery();

            // Setup event listeners
            document.getElementById('generateGlitchBtn').addEventListener('click', generateGlitchArt);

            // Update preview on mouse move
            let lastUpdate = 0;
            document.getElementById('viewport').addEventListener('mousemove', (e) => {
                const now = Date.now();
                if (now - lastUpdate > state.glitchArt.previewUpdateInterval) {
                    updateGlitchPreview();
                    lastUpdate = now;
                }
            });

            // Initial preview
            updateGlitchPreview();
        }

        function generateArtisticSignature() {
            // Create signature from behavioral fingerprint
            const sig = [
                state.behaviorModel.movementStyle || 'unknown',
                state.divergenceScore.toFixed(0),
                state.emotionState.current || 'neutral',
                Date.now().toString(36).slice(-4)
            ].join('-');

            state.glitchArt.currentSignature = sig;
            const sigEl = document.getElementById('glitchSignature');
            if (sigEl) {
                sigEl.textContent = sig.toUpperCase();
            }
        }

        function updateGlitchPreview() {
            if (!state.glitchArt.previewCanvas || !state.isObserving) return;

            const canvas = state.glitchArt.previewCanvas;
            const ctx = state.glitchArt.previewCtx;

            // Capture viewport as image
            captureViewportToCanvas(canvas, ctx, true);

            // Hide overlay when observing
            const overlay = document.getElementById('glitchPreviewOverlay');
            if (overlay) {
                overlay.style.display = state.isObserving ? 'none' : 'block';
            }

            // Update stats
            document.getElementById('glitchDivergence').textContent =
                Math.round(state.divergenceScore) + '%';
        }

        function captureViewportToCanvas(canvas, ctx, applyEffects = false) {
            const viewport = document.getElementById('viewport');
            if (!viewport) return;

            // Get viewport dimensions
            const rect = viewport.getBoundingClientRect();

            // Set canvas to viewport size (or preview size)
            if (!applyEffects) {
                canvas.width = rect.width;
                canvas.height = rect.height;
            }

            // Draw background gradient
            const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
            gradient.addColorStop(0, '#0d0d15');
            gradient.addColorStop(1, '#1a1a2e');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw recursion layers
            const layers = document.querySelectorAll('.recursion-layer');
            layers.forEach(layer => {
                const layerRect = layer.getBoundingClientRect();
                const x = (layerRect.left - rect.left) / rect.width * canvas.width;
                const y = (layerRect.top - rect.top) / rect.height * canvas.height;
                const w = layerRect.width / rect.width * canvas.width;
                const h = layerRect.height / rect.height * canvas.height;

                const isDiverged = layer.classList.contains('diverged');
                const isConverged = layer.classList.contains('converged');

                ctx.strokeStyle = isDiverged ? 'rgba(255, 100, 100, 0.5)' :
                                 isConverged ? 'rgba(100, 255, 150, 0.5)' :
                                 'rgba(100, 200, 255, 0.3)';
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, w, h);

                ctx.fillStyle = 'rgba(10, 10, 20, 0.7)';
                ctx.fillRect(x, y, w, h);
            });

            // Draw cursors
            const cursors = document.querySelectorAll('.ghost-cursor, .shadow-cursor');
            cursors.forEach(cursor => {
                const cursorRect = cursor.getBoundingClientRect();
                const x = (cursorRect.left - rect.left) / rect.width * canvas.width;
                const y = (cursorRect.top - rect.top) / rect.height * canvas.height;

                const isShadow = cursor.classList.contains('shadow-cursor');
                ctx.fillStyle = isShadow ? '#8a2be2' : cursor.style.color || '#64c8ff';
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fill();
            });

            // Apply glitch effects if requested
            if (applyEffects) {
                applyGlitchEffects(canvas, ctx);
            }
        }

        function applyGlitchEffects(canvas, ctx) {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            // Effect 1: Pixel Sorting based on movement direction
            if (state.glitchArt.effects.pixelSort.enabled) {
                const movementAngle = calculateMovementDirection();
                pixelSort(data, canvas.width, canvas.height, movementAngle);
            }

            // Effect 2: Data Moshing based on divergence
            if (state.glitchArt.effects.dataMosh.enabled) {
                const moshIntensity = state.divergenceScore / 100;
                dataMosh(data, canvas.width, canvas.height, moshIntensity);
            }

            // Effect 3: Channel Shifting based on emotion
            if (state.glitchArt.effects.channelShift.enabled) {
                const emotionShift = getEmotionChannelShift();
                channelShift(data, canvas.width, canvas.height, emotionShift);
            }

            // Effect 4: Scan Line Corruption based on stress level
            if (state.glitchArt.effects.scanLines.enabled) {
                const stressLevel = getStressLevel();
                scanLineCorruption(data, canvas.width, canvas.height, stressLevel);
            }

            ctx.putImageData(imageData, 0, 0);
        }

        function calculateMovementDirection() {
            if (state.actions.length < 2) return 0;
            const recent = state.actions.slice(-10);
            let dx = 0, dy = 0;
            for (let i = 1; i < recent.length; i++) {
                dx += recent[i].x - recent[i-1].x;
                dy += recent[i].y - recent[i-1].y;
            }
            return Math.atan2(dy, dx);
        }

        function getEmotionChannelShift() {
            const emotionMap = {
                'happy': { r: 10, g: -5, b: 0 },
                'sad': { r: -5, g: 0, b: 10 },
                'angry': { r: 15, g: -10, b: -5 },
                'surprised': { r: 0, g: 10, b: -10 },
                'neutral': { r: 2, g: -2, b: 2 }
            };
            return emotionMap[state.emotionState.current] || emotionMap.neutral;
        }

        function getStressLevel() {
            // Calculate from biometric data
            const stressIndicator = document.getElementById('stressIndicator');
            if (!stressIndicator) return 0.5;

            if (stressIndicator.classList.contains('high')) return 0.9;
            if (stressIndicator.classList.contains('medium')) return 0.6;
            return 0.3;
        }

        function pixelSort(data, width, height, angle) {
            const horizontal = Math.abs(Math.cos(angle)) > 0.5;
            const threshold = 128;

            for (let y = 0; y < height; y++) {
                if (horizontal && Math.random() < 0.3) {
                    sortRow(data, width, y, threshold);
                }
            }

            for (let x = 0; x < width; x++) {
                if (!horizontal && Math.random() < 0.3) {
                    sortColumn(data, width, height, x, threshold);
                }
            }
        }

        function sortRow(data, width, y, threshold) {
            const row = [];
            for (let x = 0; x < width; x++) {
                const i = (y * width + x) * 4;
                const brightness = (data[i] + data[i+1] + data[i+2]) / 3;
                if (brightness > threshold) {
                    row.push({ r: data[i], g: data[i+1], b: data[i+2], a: data[i+3] });
                }
            }

            row.sort((a, b) => (a.r + a.g + a.b) - (b.r + b.g + b.b));

            let rowIndex = 0;
            for (let x = 0; x < width; x++) {
                const i = (y * width + x) * 4;
                const brightness = (data[i] + data[i+1] + data[i+2]) / 3;
                if (brightness > threshold && rowIndex < row.length) {
                    data[i] = row[rowIndex].r;
                    data[i+1] = row[rowIndex].g;
                    data[i+2] = row[rowIndex].b;
                    data[i+3] = row[rowIndex].a;
                    rowIndex++;
                }
            }
        }

        function sortColumn(data, width, height, x, threshold) {
            const col = [];
            for (let y = 0; y < height; y++) {
                const i = (y * width + x) * 4;
                const brightness = (data[i] + data[i+1] + data[i+2]) / 3;
                if (brightness > threshold) {
                    col.push({ r: data[i], g: data[i+1], b: data[i+2], a: data[i+3] });
                }
            }

            col.sort((a, b) => (a.r + a.g + a.b) - (b.r + b.g + b.b));

            let colIndex = 0;
            for (let y = 0; y < height; y++) {
                const i = (y * width + x) * 4;
                const brightness = (data[i] + data[i+1] + data[i+2]) / 3;
                if (brightness > threshold && colIndex < col.length) {
                    data[i] = col[colIndex].r;
                    data[i+1] = col[colIndex].g;
                    data[i+2] = col[colIndex].b;
                    data[i+3] = col[colIndex].a;
                    colIndex++;
                }
            }
        }

        function dataMosh(data, width, height, intensity) {
            const blockSize = Math.floor(8 * (1 + intensity * 2));

            for (let y = 0; y < height; y += blockSize) {
                for (let x = 0; x < width; x += blockSize) {
                    if (Math.random() < intensity) {
                        const offsetX = Math.floor((Math.random() - 0.5) * blockSize * 3);
                        const offsetY = Math.floor((Math.random() - 0.5) * blockSize * 3);
                        copyBlock(data, width, height, x, y, x + offsetX, y + offsetY, blockSize);
                    }
                }
            }
        }

        function copyBlock(data, width, height, srcX, srcY, destX, destY, size) {
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const sx = Math.max(0, Math.min(width - 1, srcX + x));
                    const sy = Math.max(0, Math.min(height - 1, srcY + y));
                    const dx = Math.max(0, Math.min(width - 1, destX + x));
                    const dy = Math.max(0, Math.min(height - 1, destY + y));

                    const si = (sy * width + sx) * 4;
                    const di = (dy * width + dx) * 4;

                    data[di] = data[si];
                    data[di+1] = data[si+1];
                    data[di+2] = data[si+2];
                    data[di+3] = data[si+3];
                }
            }
        }

        function channelShift(data, width, height, shift) {
            const tempR = new Uint8ClampedArray(width * height);
            const tempG = new Uint8ClampedArray(width * height);
            const tempB = new Uint8ClampedArray(width * height);

            // Copy channels
            for (let i = 0; i < data.length; i += 4) {
                const idx = i / 4;
                tempR[idx] = data[i];
                tempG[idx] = data[i+1];
                tempB[idx] = data[i+2];
            }

            // Shift and write back
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = y * width + x;
                    const rIdx = Math.max(0, Math.min(width * height - 1, idx + shift.r));
                    const gIdx = Math.max(0, Math.min(width * height - 1, idx + shift.g));
                    const bIdx = Math.max(0, Math.min(width * height - 1, idx + shift.b));

                    const i = idx * 4;
                    data[i] = tempR[rIdx];
                    data[i+1] = tempG[gIdx];
                    data[i+2] = tempB[bIdx];
                }
            }
        }

        function scanLineCorruption(data, width, height, stressLevel) {
            const spacing = Math.max(2, Math.floor(6 - stressLevel * 4));
            const jitter = Math.floor(stressLevel * 10);

            for (let y = 0; y < height; y += spacing) {
                if (Math.random() < stressLevel) {
                    const offset = Math.floor((Math.random() - 0.5) * jitter * 2);
                    shiftScanLine(data, width, height, y, offset);
                }
            }
        }

        function shiftScanLine(data, width, height, y, offset) {
            if (y < 0 || y >= height) return;

            const temp = new Uint8ClampedArray(width * 4);
            const rowStart = y * width * 4;

            // Copy line
            for (let i = 0; i < width * 4; i++) {
                temp[i] = data[rowStart + i];
            }

            // Shift and wrap
            for (let x = 0; x < width; x++) {
                const destX = (x + offset + width) % width;
                const si = x * 4;
                const di = rowStart + destX * 4;

                data[di] = temp[si];
                data[di+1] = temp[si+1];
                data[di+2] = temp[si+2];
                data[di+3] = temp[si+3];
            }
        }

        function generateGlitchArt() {
            if (!state.isObserving) {
                alert('Start observation first to generate art!');
                return;
            }

            // Create high-res canvas for artwork
            const artCanvas = document.createElement('canvas');
            const artCtx = artCanvas.getContext('2d');

            // Set to viewport size
            const viewport = document.getElementById('viewport');
            const rect = viewport.getBoundingClientRect();
            artCanvas.width = Math.min(rect.width, 1920);
            artCanvas.height = Math.min(rect.height, 1080);

            // Capture and apply effects
            captureViewportToCanvas(artCanvas, artCtx, true);

            // Generate title
            const dayOfWeek = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
            const moodMap = {
                'erratic': 'Chaotic',
                'smooth': 'Flowing',
                'precise': 'Structured',
                'lazy': 'Drifting'
            };

            const mood = moodMap[state.behaviorModel.movementStyle] || 'Unknown';
            const day = dayOfWeek[new Date().getDay()];
            const title = `Divergence #${++state.glitchArt.artworkCounter} - ${mood} ${day}`;

            // Create artwork object
            const artwork = {
                id: Date.now(),
                title: title,
                dataURL: artCanvas.toDataURL('image/png'),
                timestamp: Date.now(),
                metadata: {
                    divergence: Math.round(state.divergenceScore),
                    emotion: state.emotionState.current,
                    stress: getStressLevel(),
                    movementStyle: state.behaviorModel.movementStyle,
                    depth: state.depth,
                    actionCount: state.actions.length,
                    signature: state.glitchArt.currentSignature
                }
            };

            // Add to gallery
            state.glitchArt.gallery.unshift(artwork);

            // Limit gallery size
            if (state.glitchArt.gallery.length > 50) {
                state.glitchArt.gallery = state.glitchArt.gallery.slice(0, 50);
            }

            // Save to localStorage
            saveGlitchGallery();

            // Update UI
            renderGlitchGallery();

            // Visual feedback
            const btn = document.getElementById('generateGlitchBtn');
            btn.textContent = 'Generated!';
            btn.classList.add('glitching');
            setTimeout(() => {
                btn.textContent = 'Generate Art';
                btn.classList.remove('glitching');
            }, 1000);
        }

        function saveGlitchGallery() {
            try {
                localStorage.setItem('glitchArtGallery', JSON.stringify(state.glitchArt.gallery));
            } catch (e) {
                console.error('Failed to save gallery:', e);
            }
        }

        function loadGlitchGallery() {
            try {
                const saved = localStorage.getItem('glitchArtGallery');
                if (saved) {
                    state.glitchArt.gallery = JSON.parse(saved);
                    state.glitchArt.artworkCounter = state.glitchArt.gallery.length;
                    renderGlitchGallery();
                }
            } catch (e) {
                console.error('Failed to load gallery:', e);
            }
        }

        function renderGlitchGallery() {
            const container = document.getElementById('glitchGalleryItems');
            const titleEl = document.querySelector('.glitch-gallery-title');
            const countEl = document.getElementById('glitchArtCount');

            if (!container) return;

            // Update count
            if (titleEl) {
                titleEl.textContent = `Art Gallery (${state.glitchArt.gallery.length})`;
            }
            if (countEl) {
                countEl.textContent = state.glitchArt.gallery.length;
            }

            // Clear and render
            container.innerHTML = '';

            state.glitchArt.gallery.forEach((artwork, index) => {
                const item = document.createElement('div');
                item.className = 'glitch-gallery-item';
                item.innerHTML = `
                    <img src="${artwork.dataURL}" class="glitch-gallery-thumb" alt="${artwork.title}">
                    <div class="glitch-gallery-meta">
                        <div class="glitch-gallery-title-text">${artwork.title}</div>
                        <div class="glitch-gallery-stats">
                            <span>Div: ${artwork.metadata.divergence}%</span>
                            <span>${artwork.metadata.emotion}</span>
                            <span>${new Date(artwork.timestamp).toLocaleDateString()}</span>
                        </div>
                        <div class="glitch-gallery-actions">
                            <button class="glitch-gallery-btn" onclick="viewGlitchArt(${index})">View</button>
                            <button class="glitch-gallery-btn" onclick="downloadGlitchArt(${index})">Download</button>
                            <button class="glitch-gallery-btn" onclick="shareGlitchArt(${index})">Share</button>
                            <button class="glitch-gallery-btn" onclick="deleteGlitchArt(${index})">Delete</button>
                        </div>
                    </div>
                `;
                container.appendChild(item);
            });
        }

        function viewGlitchArt(index) {
            const artwork = state.glitchArt.gallery[index];
            if (!artwork) return;

            const modal = document.getElementById('glitchModal');
            const img = document.getElementById('glitchModalImage');

            img.src = artwork.dataURL;
            img.alt = artwork.title;
            modal.classList.add('active');
        }

        function closeGlitchModal() {
            const modal = document.getElementById('glitchModal');
            modal.classList.remove('active');
        }

        function downloadGlitchArt(index) {
            const artwork = state.glitchArt.gallery[index];
            if (!artwork) return;

            const link = document.createElement('a');
            link.href = artwork.dataURL;
            link.download = `${artwork.title.replace(/[^a-z0-9]/gi, '-')}.png`;
            link.click();
        }

        function shareGlitchArt(index) {
            const artwork = state.glitchArt.gallery[index];
            if (!artwork) return;

            // Copy data URL to clipboard
            const text = `${artwork.title}\n\nGenerated by Recursive Self-Portrait\nDivergence: ${artwork.metadata.divergence}%\nEmotion: ${artwork.metadata.emotion}\nSignature: ${artwork.metadata.signature}\n\nData URL: ${artwork.dataURL.substring(0, 100)}...`;

            navigator.clipboard.writeText(artwork.dataURL).then(() => {
                alert('Art data URL copied to clipboard!\nYou can paste this into any image-capable app.');
            }).catch(err => {
                console.error('Failed to copy:', err);
                alert('Share failed. Try downloading instead.');
            });
        }

        function deleteGlitchArt(index) {
            if (!confirm('Delete this artwork?')) return;

            state.glitchArt.gallery.splice(index, 1);
            saveGlitchGallery();
            renderGlitchGallery();
        }

        // Close modal on click outside
        document.addEventListener('DOMContentLoaded', () => {
            const modal = document.getElementById('glitchModal');
            if (modal) {
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        closeGlitchModal();
                    }
                });
            }

            // Initialize Glitch Art Generator
            initGlitchArtGenerator();
        });

    </script>

    <script>
        // ===== INTEGRATE TIME DILATION INTO EXISTING SYSTEM =====

        // Hook into existing start observation
        const originalStartObservation = startObservation;
        startObservation = function() {
            originalStartObservation.call(this);
            startTimeDilation();


        // ===== PARADOX ENGINE =====

        const ParadoxEngine = (function() {
            const meterEl = document.getElementById('paradoxMeter');
            const fillEl = document.getElementById('paradoxMeterFill');
            const countEl = document.getElementById('paradoxCount');
            const realityBreakEl = document.getElementById('realityBreakOverlay');
            const alertEl = document.getElementById('paradoxAlert');
            const alertTextEl = document.getElementById('paradoxAlertText');

            // Detect free will vs predictability paradox
            function detectFreeWillParadox() {
                const detector = state.paradox.detectors.freeWillVsPredictability;

                // Check if user answered free will question
                if (state.philosophicalProfile.beliefs.freeWill === 'has') {
                    detector.freeWillClaimed = true;
                }

                // Track prediction accuracy
                if (state.predictions.length > 20) {
                    const recentPredictions = state.predictions.slice(-20);
                    const correct = recentPredictions.filter(p => p.correct).length;
                    const accuracy = correct / recentPredictions.length;

                    detector.totalPredictions = recentPredictions.length;
                    detector.perfectPredictions = correct;

                    // Paradox: claims free will but is perfectly predictable
                    if (detector.freeWillClaimed && accuracy >= detector.threshold) {
                        if (!state.paradox.types['free-will-paradox'].detected) {
                            triggerParadox('free-will-paradox', {
                                accuracy: Math.round(accuracy * 100),
                                predictions: detector.totalPredictions
                            });
                        }
                    }
                }
            }

            // Detect shadow swap paradox
            function detectShadowSwapParadox() {
                const detector = state.paradox.detectors.shadowSwap;

                // Check if shadow has taken over and swapped positions
                if (state.shadow.isTakingOver && state.shadow.alignmentScore < 20) {
                    const now = Date.now();
                    if (now - detector.lastSwapTime > 5000) { // Cooldown
                        detector.detected = true;
                        detector.lastSwapTime = now;

                        if (!state.paradox.types['shadow-swap-paradox'].detected) {
                            triggerParadox('shadow-swap-paradox', {
                                alignmentScore: state.shadow.alignmentScore
                            });
                        }
                    }
                }
            }

            // Detect deep recursion perfect match paradox
            function detectDeepRecursionParadox() {
                const detector = state.paradox.detectors.deepRecursionMatch;

                if (state.depth >= 7) {
                    // Calculate how well predictions match at deep levels
                    const recentActions = state.actions.slice(-10);
                    const recentPredictions = state.predictions.slice(-10);

                    if (recentActions.length >= 10 && recentPredictions.length >= 10) {
                        let matches = 0;
                        for (let i = 0; i < 10; i++) {
                            const action = recentActions[i];
                            const prediction = recentPredictions[i];
                            const distance = Math.sqrt(
                                Math.pow(action.x - prediction.x, 2) +
                                Math.pow(action.y - prediction.y, 2)
                            );
                            if (distance < 5) matches++; // Within 5px
                        }

                        const matchAccuracy = matches / 10;
                        detector.depth = state.depth;
                        detector.matchAccuracy = matchAccuracy;

                        if (matchAccuracy >= 0.9 && !state.paradox.types['perfect-prediction-paradox'].detected) {
                            triggerParadox('perfect-prediction-paradox', {
                                depth: state.depth,
                                accuracy: Math.round(matchAccuracy * 100)
                            });
                        }
                    }
                }
            }

            // Detect bootstrap paradox (seeing future movements)
            function detectBootstrapParadox() {
                const detector = state.paradox.detectors.bootstrap;

                // Track if predictions are being shown before actions
                if (state.predictions.length > 5) {
                    detector.futureSelfMovements = state.predictions.slice(-5);
                    detector.pastActions = state.actions.slice(-5);

                    // Check for temporal loops
                    if (detector.futureSelfMovements.length >= 5 && detector.pastActions.length >= 5) {
                        // See if past actions match old predictions (causal loop)
                        let loopMatches = 0;
                        for (let i = 0; i < 5; i++) {
                            const past = detector.pastActions[i];
                            // Check if this matches a prediction made even earlier
                            const olderPredictions = state.predictions.slice(0, -10);
                            for (const pred of olderPredictions) {
                                const dist = Math.sqrt(
                                    Math.pow(past.x - pred.x, 2) +
                                    Math.pow(past.y - pred.y, 2)
                                );
                                if (dist < 10) {
                                    loopMatches++;
                                    break;
                                }
                            }
                        }

                        if (loopMatches >= 3 && !state.paradox.types['bootstrap-paradox'].detected) {
                            detector.loopDetected = true;
                            triggerParadox('bootstrap-paradox', {
                                loopStrength: loopMatches
                            });
                        }
                    }
                }
            }

            // Detect observer effect paradox
            function detectObserverParadox() {
                const detector = state.paradox.detectors.observer;

                // Track prediction accuracy before and after user awareness
                // When divergence score changes dramatically, observer effect is active
                if (state.divergenceScore > 50 && state.actions.length > 100) {
                    const oldActions = state.actions.slice(0, 50);
                    const newActions = state.actions.slice(-50);

                    // Calculate pattern change
                    const oldVariance = calculateMovementVariance(oldActions);
                    const newVariance = calculateMovementVariance(newActions);

                    const varianceChange = Math.abs(newVariance - oldVariance) / oldVariance;

                    if (varianceChange > 0.5 && !state.paradox.types['observer-paradox'].detected) {
                        detector.changeDetected = true;
                        triggerParadox('observer-paradox', {
                            varianceChange: Math.round(varianceChange * 100)
                        });
                    }
                }
            }

            // Helper: calculate movement variance
            function calculateMovementVariance(actions) {
                if (actions.length < 2) return 0;

                const speeds = [];
                for (let i = 1; i < actions.length; i++) {
                    const dx = actions[i].x - actions[i-1].x;
                    const dy = actions[i].y - actions[i-1].y;
                    const speed = Math.sqrt(dx*dx + dy*dy);
                    speeds.push(speed);
                }

                const mean = speeds.reduce((a, b) => a + b, 0) / speeds.length;
                const variance = speeds.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / speeds.length;
                return variance;
            }

            // Trigger a specific paradox
            function triggerParadox(type, data) {
                const paradoxType = state.paradox.types[type];
                if (!paradoxType || paradoxType.detected) return;

                paradoxType.detected = true;

                const paradox = {
                    type: type,
                    name: paradoxType.name,
                    description: paradoxType.description,
                    timestamp: Date.now(),
                    sessionTime: state.actions.length,
                    data: data
                };

                state.paradox.collection.push(paradox);
                state.paradox.level = Math.min(100, state.paradox.level + 15);

                updateParadoxMeter();
                showParadoxCommentary(paradoxType.name);
                playParadoxSound();

                // Check if threshold reached
                if (state.paradox.level >= state.paradox.threshold && !state.paradox.isBreaking) {
                    triggerRealityBreak();
                }
            }

            // Update paradox meter UI
            function updateParadoxMeter() {
                const percentage = Math.min(100, state.paradox.level);
                fillEl.style.width = percentage + '%';
                countEl.textContent = `${state.paradox.collection.length} paradox${state.paradox.collection.length !== 1 ? 'es' : ''} detected`;

                if (percentage >= 75) {
                    meterEl.classList.add('critical');
                } else {
                    meterEl.classList.remove('critical');
                }
            }

            // Show paradox commentary
            function showParadoxCommentary(paradoxName) {
                const commentary = state.paradox.commentary[
                    Math.floor(Math.random() * state.paradox.commentary.length)
                ];

                addLog(`PARADOX DETECTED: ${paradoxName}`, 'divergence');
                addLog(commentary, 'meta');

                // Add to meta observations
                state.metaObservations.push({
                    time: Date.now(),
                    type: 'paradox',
                    message: `${paradoxName}: ${commentary}`
                });
            }

            // Play discordant sound that resolves into harmony
            function playParadoxSound() {
                if (!audioContext) return;

                const now = audioContext.currentTime;

                // Create two discordant tones
                const osc1 = audioContext.createOscillator();
                const osc2 = audioContext.createOscillator();
                const gain = audioContext.createGain();

                osc1.connect(gain);
                osc2.connect(gain);
                gain.connect(masterGain);

                // Start with dissonance (tritone)
                osc1.type = 'sine';
                osc2.type = 'sine';
                osc1.frequency.setValueAtTime(400, now);
                osc2.frequency.setValueAtTime(566, now); // Tritone interval

                // Resolve to harmony (perfect fifth)
                osc1.frequency.exponentialRampToValueAtTime(400, now + 1);
                osc2.frequency.exponentialRampToValueAtTime(600, now + 1);

                gain.gain.setValueAtTime(0.15, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 1.5);

                osc1.start(now);
                osc2.start(now);
                osc1.stop(now + 1.5);
                osc2.stop(now + 1.5);
            }

            // Trigger reality break effect
            function triggerRealityBreak() {
                if (state.paradox.isBreaking) return;

                state.paradox.isBreaking = true;
                state.paradox.breakCount++;
                state.paradox.lastBreakTime = Date.now();

                // Show alert
                alertTextEl.textContent = 'Reality breaks under the weight of contradiction...';
                alertEl.classList.add('active');

                // Visual inversion
                realityBreakEl.classList.add('active');
                document.body.style.filter = 'invert(1)';

                setTimeout(() => {
                    document.body.style.filter = 'invert(0)';
                }, 500);

                setTimeout(() => {
                    document.body.style.filter = 'invert(1) hue-rotate(180deg)';
                }, 1000);

                setTimeout(() => {
                    document.body.style.filter = '';
                    realityBreakEl.classList.remove('active');
                }, 1500);

                // Reverse physics: layers expand outward
                state.paradox.reversedPhysics = true;
                state.layers.forEach((layer, index) => {
                    layer.style.transform = `scale(${1 + index * 0.2})`;
                    layer.style.transition = 'transform 2s ease-out';
                });

                setTimeout(() => {
                    state.paradox.reversedPhysics = false;
                    state.layers.forEach(layer => {
                        layer.style.transform = '';
                    });
                }, 2000);

                // Time flows backward briefly
                reverseTime();

                // Create impossible geometry
                createImpossibleGeometry();

                // Meta-commentary in contradictions
                setTimeout(() => {
                    showContradictoryCommentary();
                }, 500);

                setTimeout(() => {
                    alertEl.classList.remove('active');
                    state.paradox.isBreaking = false;
                    // Reduce paradox level but don't clear it
                    state.paradox.level = Math.max(50, state.paradox.level - 30);
                    updateParadoxMeter();
                }, 3000);
            }

            // Reverse time flow
            function reverseTime() {
                state.paradox.timeFlowReversed = true;

                // Play recent actions in reverse
                const recentActions = state.actions.slice(-20).reverse();
                let index = 0;

                const reverseInterval = setInterval(() => {
                    if (index >= recentActions.length) {
                        clearInterval(reverseInterval);
                        state.paradox.timeFlowReversed = false;
                        return;
                    }

                    const action = recentActions[index];
                    // Flash a ghost cursor at old positions
                    const ghost = document.createElement('div');
                    ghost.className = 'ghost-cursor';
                    ghost.style.left = action.x + 'px';
                    ghost.style.top = action.y + 'px';
                    ghost.style.color = '#ff3296';
                    ghost.style.opacity = '0.7';
                    viewport.appendChild(ghost);

                    setTimeout(() => ghost.remove(), 100);

                    index++;
                }, 50);
            }

            // Create impossible geometry (Escher-like)
            function createImpossibleGeometry() {
                const geometry = document.createElement('div');
                geometry.className = 'impossible-geometry penrose-triangle';
                geometry.style.position = 'absolute';
                geometry.style.left = (viewport.offsetWidth / 2 - 75) + 'px';
                geometry.style.top = (viewport.offsetHeight / 2 - 75) + 'px';
                viewport.appendChild(geometry);

                state.paradox.geometryElements.push(geometry);

                setTimeout(() => geometry.classList.add('visible'), 100);

                setTimeout(() => {
                    geometry.classList.remove('visible');
                    setTimeout(() => geometry.remove(), 1000);
                    const index = state.paradox.geometryElements.indexOf(geometry);
                    if (index > -1) state.paradox.geometryElements.splice(index, 1);
                }, 4000);
            }

            // Show contradictory meta commentary
            function showContradictoryCommentary() {
                const contradictions = [
                    'I am certain that nothing is certain.',
                    'You are predictable in your unpredictability.',
                    'The only constant is that there are no constants.',
                    'I know that I know nothing, therefore I know something.',
                    'This statement is false. Wait, is it true?',
                    'You are free to be determined.',
                    'I observe you not observing me observing you.',
                    'The recursion ends infinitely.',
                    'Your future past is my present memory.',
                    'We are both the original and the copy.'
                ];

                const comment = contradictions[Math.floor(Math.random() * contradictions.length)];
                addLog(comment, 'meta');

                // Speak it if voice synthesis is available
                if (window.speechSynthesis && soundEnabled) {
                    const utterance = new SpeechSynthesisUtterance(comment);
                    utterance.rate = 0.8;
                    utterance.pitch = 0.7;
                    speechSynthesis.speak(utterance);
                }
            }

            // Check for paradoxes continuously
            function checkParadoxes() {
                if (!state.isObserving) return;

                detectFreeWillParadox();
                detectShadowSwapParadox();
                detectDeepRecursionParadox();
                detectBootstrapParadox();
                detectObserverParadox();

                // Gradually decay paradox level
                if (state.paradox.level > 0 && !state.paradox.isBreaking) {
                    state.paradox.level = Math.max(0, state.paradox.level - 0.1);
                    updateParadoxMeter();
                }
            }

            // Initialize
            function init() {
                // Check paradoxes every 2 seconds
                setInterval(checkParadoxes, 2000);
            }

            return {
                init: init,
                checkParadoxes: checkParadoxes,
                triggerParadox: triggerParadox,
                updateMeter: updateParadoxMeter
            };
        })();

        // Open paradox collection modal
        function openParadoxCollection() {
            const modal = document.getElementById('paradoxCollectionModal');
            const content = document.getElementById('paradoxCollectionContent');

            if (state.paradox.collection.length === 0) {
                content.innerHTML = '<p style="text-align: center; color: #888; padding: 40px;">No paradoxes detected yet. Keep observing...</p>';
            } else {
                let html = '';
                state.paradox.collection.forEach(paradox => {
                    const date = new Date(paradox.timestamp);
                    html += `
                        <div class="paradox-item">
                            <div class="paradox-type">${paradox.type.replace(/-/g, ' ')}</div>
                            <h3>${paradox.name}</h3>
                            <div class="paradox-description">${paradox.description}</div>
                            <div class="paradox-timestamp">
                                Detected at ${date.toLocaleTimeString()} after ${paradox.sessionTime} actions
                                ${paradox.data ? '<br>Data: ' + JSON.stringify(paradox.data) : ''}
                            </div>
                        </div>
                    `;
                });
                content.innerHTML = html;
            }

            modal.classList.add('active');
        }

        // Close paradox collection modal
        function closeParadoxCollection() {
            const modal = document.getElementById('paradoxCollectionModal');
            modal.classList.remove('active');
        }

        // Initialize Paradox Engine
        ParadoxEngine.init();
            // Add time dilation update to visual interval
            state.timeDilationInterval = setInterval(() => {
                if (state.isObserving) {
                    updateTimeDilation();
                }
            }, 100); // Update every 100ms for smooth time tracking
        };

        // Hook into existing stop observation
        const originalStopObservation = stopObservation;
        stopObservation = function() {
            originalStopObservation.call(this);

            if (state.timeDilationInterval) {
                clearInterval(state.timeDilationInterval);
                state.timeDilationInterval = null;
            }

            resetTimeDilation();
        };

        // Hook into mouse move to track actions
        const originalHandleMouseMove = handleMouseMove;
        handleMouseMove = function(e) {
            if (state.isObserving) {
                const rect = viewport.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                const dx = x - lastMousePos.x;
                const dy = y - lastMousePos.y;
                const velocity = Math.sqrt(dx * dx + dy * dy);
                const angle = Math.atan2(dy, dx) * 180 / Math.PI;

                trackTimeDilationAction('move', { x, y, speed: velocity, angle: angle });
            }

            return originalHandleMouseMove.call(this, e);
        };

        // Hook into click tracking
        viewport.addEventListener('click', (e) => {
            if (state.isObserving) {
                const rect = viewport.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                trackTimeDilationAction('click', { x, y });
            }
        });

        // Update export data to include time dilation
        const originalExportData = exportData;
        exportData = function() {
            // First get original export
            const dataStr = JSON.stringify({
                \1
            glitchArtGallery: state.glitchArt.gallery,
            glitchArtSignature: state.glitchArt.currentSignature,
                behaviorModel: state.behaviorModel,
                currentSession: {
                    actions: state.actions,
                    predictions: state.predictions,
                    divergenceScore: state.divergenceScore,
                    metaObservations: state.metaObservations,
                    emotionState: state.emotionState
                },
                timeDilation: {
                    objectiveDuration: Date.now() - timeDilationState.objectiveStartTime,
                    subjectiveDuration: timeDilationState.subjectiveTime,
                    timeDelta: timeDilationState.subjectiveTime - (Date.now() - timeDilationState.objectiveStartTime),
                    averageDilation: timeDilationState.subjectiveTime / (Date.now() - timeDilationState.objectiveStartTime),
                    crystalsFormed: timeDilationState.timeCrystals.length,
                    crystalPatterns: Array.from(timeDilationState.crystalPatterns.entries()).map(([sig, data]) => ({
                        pattern: sig,
                        repetitions: data.count
                    })),
                    extremeEvents: timeDilationState.extremeDilationCount,
                    maxIntensity: Math.max(...timeDilationState.recentActions.map(a => a.intensity || 0), 0),
                    timeFlowStates: {
                        slow: timeDilationState.recentActions.filter(a => a.dilationFactor < 0.8).length,
                        normal: timeDilationState.recentActions.filter(a => a.dilationFactor >= 0.8 && a.dilationFactor <= 1.2).length,
                        fast: timeDilationState.recentActions.filter(a => a.dilationFactor > 1.2).length
                    }
                },
                biometrics: state.biometrics ? {
                    heartRateHistory: state.biometrics.heartRateHistory,
                    heartRateSpikes: state.biometrics.heartRateSpikes,
                    biometricEvents: state.biometrics.biometricEvents,
                    baselineHeartRate: state.biometrics.baselineHeartRate,
                    averageHeartRate: state.biometrics.heartRateHistory.length > 0 ?
                        Math.round(state.biometrics.heartRateHistory.reduce((sum, h) => sum + h.bpm, 0) / state.biometrics.heartRateHistory.length) : 72
                } : null,
                fingerprintImage: fingerprintCanvas ? fingerprintCanvas.toDataURL('image/png') : null
            }, null, 2);

            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `${APP_NAME}-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);

            addLog('Session exported with time dilation data', 'match');
        };

        // Update replay system to support subjective time playback
        const originalLoadReplay = loadReplay;
        loadReplay = function(replay) {
            // Check if replay has time dilation data
            if (replay.timeDilation) {
                // Set playback speed based on subjective time
                const subjectiveSpeed = replay.timeDilation.subjectiveDuration / replay.timeDilation.objectiveDuration;
                replayState.playbackSpeed = subjectiveSpeed;
                addLog(`Replay loaded with subjective time (${subjectiveSpeed.toFixed(2)}x)`, 'match');
            }

            return originalLoadReplay.call(this, replay);
        };

        // Show random time meta-commentary based on depth and dilation
        setInterval(() => {
            if (state.isObserving && state.depth >= 7 && Math.random() < 0.02) {
                const factor = timeDilationState.timeDilationFactor;
                if (factor < 0.7) {
                    showTimeMetaComment('At this intensity, your subjective time stretches infinitely');
                } else if (factor > 1.5) {
                    showTimeMetaComment('Time compresses when the mind wanders');
                }
            }
        }, 5000);

        // ===== TIME DILATION SYSTEM =====

        // DOM elements for time dilation
        const timePerceptionFill = document.getElementById('timePerceptionFill');
        const objectiveTimeEl = document.getElementById('objectiveTime');
        const subjectiveTimeEl = document.getElementById('subjectiveTime');
        const timeDeltaEl = document.getElementById('timeDelta');
        const timeDilationFactorEl = document.getElementById('timeDilationFactor');
        const timeCrystalCountEl = document.getElementById('timeCrystalCount');
        const timeCrystalListEl = document.getElementById('timeCrystalList');
        const heartbeatOverlay = document.getElementById('heartbeatOverlay');
        const timeDilationOverlay = document.getElementById('timeDilationOverlay');
        const timeFlowIndicator = document.getElementById('timeFlowIndicator');
        const timeFlowText = document.getElementById('timeFlowText');

        // Calculate interaction intensity based on recent actions
        function calculateInteractionIntensity() {
            const now = Date.now();
            const windowStart = now - timeDilationState.actionWindow;

            // Filter recent actions within time window
            timeDilationState.recentActions = timeDilationState.recentActions.filter(
                action => action.timestamp > windowStart
            );

            // Calculate intensity based on action frequency and type
            let intensity = 0;
            const actionCount = timeDilationState.recentActions.length;

            // Base intensity from action frequency (0-50)
            intensity += Math.min(50, actionCount * 5);

            // Add intensity from movement speed (0-25)
            const recentMovement = timeDilationState.recentActions.filter(a => a.type === 'move');
            if (recentMovement.length > 0) {
                const avgSpeed = recentMovement.reduce((sum, a) => sum + (a.speed || 0), 0) / recentMovement.length;
                intensity += Math.min(25, avgSpeed / 10);
            }

            // Add intensity from clicks (0-25)
            const clickCount = timeDilationState.recentActions.filter(a => a.type === 'click').length;
            intensity += Math.min(25, clickCount * 10);

            // Smooth the intensity change
            timeDilationState.interactionIntensity =
                timeDilationState.interactionIntensity * 0.8 + intensity * 0.2;

            return timeDilationState.interactionIntensity;
        }

        // Calculate time dilation factor based on intensity and depth
        function calculateTimeDilation() {
            const intensity = timeDilationState.interactionIntensity;
            const depth = state.depth;

            // Base dilation from interaction intensity
            // Low intensity (< 20): time speeds up (1.0-2.0x)
            // Medium intensity (20-50): normal time (0.8-1.0x)
            // High intensity (> 50): time slows down (0.3-0.8x)

            let dilationFactor = 1.0;

            if (intensity < 20) {
                // Low activity - time compresses (moves faster)
                dilationFactor = 1.0 + (20 - intensity) / 20; // 1.0 to 2.0
                timeDilationState.timeFlowState = 'fast';
            } else if (intensity > 50) {
                // High activity - time dilates (slows down)
                const slowness = (intensity - 50) / 50; // 0 to 1
                dilationFactor = 1.0 - slowness * 0.7; // 1.0 to 0.3
                timeDilationState.timeFlowState = 'slow';
            } else {
                // Normal activity
                dilationFactor = 1.0;
                timeDilationState.timeFlowState = 'normal';
            }

            // Depth modifier - deeper recursion affects time flow
            timeDilationState.depthTimeModifier = 1.0 + (depth - 5) * 0.05; // Slight modifier
            if (depth >= 8) {
                // At quantum depths, add uncertainty to time flow
                const quantumFluctuation = (Math.random() - 0.5) * 0.2;
                dilationFactor *= (1.0 + quantumFluctuation);
            }

            // Extreme effects at very deep recursion
            if (depth >= 10) {
                if (Math.random() < 0.01) {
                    // Rare time freezes
                    dilationFactor *= 0.1;
                    timeDilationState.extremeDilationCount++;
                    showTimeMetaComment('Time itself becomes unstable at this depth');
                }
            }

            // Clamp the dilation factor
            dilationFactor = Math.max(0.1, Math.min(3.0, dilationFactor));
            timeDilationState.timeDilationFactor = dilationFactor;
            timeDilationState.subjectiveSpeed = dilationFactor;

            return dilationFactor;
        }

        // Update subjective time based on dilation
        function updateSubjectiveTime() {
            const now = Date.now();
            const deltaObjective = now - timeDilationState.lastUpdateTime;
            const deltaSubjective = deltaObjective * timeDilationState.timeDilationFactor;

            timeDilationState.subjectiveTime += deltaSubjective;
            timeDilationState.lastUpdateTime = now;
        }

        // Format time in MM:SS format
        function formatTime(ms) {
            const totalSeconds = Math.floor(ms / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }

        // Update time dilation display
        function updateTimeDilationDisplay() {
            if (!state.isObserving) return;

            const now = Date.now();
            const objectiveElapsed = now - timeDilationState.objectiveStartTime;

            // Update clocks
            objectiveTimeEl.textContent = formatTime(objectiveElapsed);
            subjectiveTimeEl.textContent = formatTime(timeDilationState.subjectiveTime);

            // Update delta
            const deltaSeconds = Math.round((timeDilationState.subjectiveTime - objectiveElapsed) / 1000);
            const deltaSign = deltaSeconds >= 0 ? '+' : '';
            timeDeltaEl.textContent = `${deltaSign}${deltaSeconds}s`;
            timeDeltaEl.style.color = deltaSeconds > 5 ? '#ff6464' : deltaSeconds < -5 ? '#64c8ff' : '#888';

            // Update dilation factor
            timeDilationFactorEl.textContent = timeDilationState.timeDilationFactor.toFixed(2) + 'x';

            // Update perception meter
            const intensity = timeDilationState.interactionIntensity;
            timePerceptionFill.style.width = intensity + '%';

            // Update time crystal count
            timeCrystalCountEl.textContent = timeDilationState.timeCrystals.length;
        }

        // Update visual time effects
        function updateTimeVisualEffects() {
            if (!state.isObserving) {
                heartbeatOverlay.classList.remove('active');
                timeDilationOverlay.className = 'time-dilation-overlay';
                timeFlowIndicator.classList.remove('visible');
                return;
            }

            const flowState = timeDilationState.timeFlowState;

            // Update heartbeat overlay
            if (state.biometrics && state.biometrics.heartRate) {
                const bpm = state.biometrics.heartRate;
                const duration = 60 / bpm;
                heartbeatOverlay.style.setProperty('--heartbeat-duration', duration + 's');
                heartbeatOverlay.classList.add('active');
            }

            // Update time dilation overlay
            timeDilationOverlay.className = 'time-dilation-overlay';
            if (flowState === 'slow') {
                timeDilationOverlay.classList.add('slow');
            } else if (flowState === 'fast') {
                timeDilationOverlay.classList.add('fast');
            }

            // Update time flow indicator
            const factor = timeDilationState.timeDilationFactor;
            if (Math.abs(factor - 1.0) > 0.15) {
                timeFlowIndicator.classList.add('visible');
                timeFlowIndicator.className = 'time-flow-indicator visible ' + flowState;

                if (flowState === 'slow') {
                    timeFlowText.textContent = `Time dilating (${factor.toFixed(2)}x)`;
                } else if (flowState === 'fast') {
                    timeFlowText.textContent = `Time compressing (${factor.toFixed(2)}x)`;
                }
            } else {
                timeFlowIndicator.classList.remove('visible');
            }
        }

        // Track actions for time dilation
        function trackTimeDilationAction(type, data = {}) {
            timeDilationState.recentActions.push({
                type,
                timestamp: Date.now(),
                ...data
            });

            // Detect patterns for time crystals
            if (type === 'move' || type === 'click') {
                detectTimeCrystalPattern({ type, ...data });
            }
        }

        // Detect repeating patterns for time crystals
        function detectTimeCrystalPattern(action) {
            const signature = createPatternSignature(action);

            if (!timeDilationState.crystalPatterns.has(signature)) {
                timeDilationState.crystalPatterns.set(signature, {
                    count: 1,
                    firstSeen: Date.now(),
                    lastSeen: Date.now(),
                    positions: [action.x ? { x: action.x, y: action.y } : null]
                });
            } else {
                const pattern = timeDilationState.crystalPatterns.get(signature);
                pattern.count++;
                pattern.lastSeen = Date.now();
                if (action.x) {
                    pattern.positions.push({ x: action.x, y: action.y });
                }

                // Check if pattern qualifies as time crystal
                if (pattern.count >= timeDilationState.crystalThreshold) {
                    const timeSinceFirst = Date.now() - pattern.firstSeen;
                    if (timeSinceFirst < 30000) { // Within 30 seconds
                        formTimeCrystal(signature, pattern);
                    }
                }
            }
        }

        // Create a signature for pattern matching
        function createPatternSignature(action) {
            if (action.type === 'click') {
                // Round position to grid for fuzzy matching
                const gridSize = 50;
                const gridX = Math.floor((action.x || 0) / gridSize);
                const gridY = Math.floor((action.y || 0) / gridSize);
                return `click_${gridX}_${gridY}`;
            } else if (action.type === 'move') {
                // Create signature from movement direction
                const angle = Math.round((action.angle || 0) / 45) * 45; // 8 directions
                const speedBucket = Math.round((action.speed || 0) / 50) * 50;
                return `move_${angle}_${speedBucket}`;
            }
            return `${action.type}_generic`;
        }

        // Form a time crystal when pattern repeats
        function formTimeCrystal(signature, pattern) {
            // Check if crystal already exists
            const existing = timeDilationState.timeCrystals.find(c => c.signature === signature);
            if (existing) {
                existing.strength++;
                return;
            }

            // Create new time crystal
            const crystal = {
                id: Date.now() + Math.random(),
                signature,
                strength: pattern.count,
                formed: Date.now(),
                positions: pattern.positions.filter(p => p !== null),
                type: signature.split('_')[0]
            };

            timeDilationState.timeCrystals.push(crystal);

            // Visual effect - spawn crystal on screen
            if (crystal.positions.length > 0) {
                const pos = crystal.positions[crystal.positions.length - 1];
                spawnTimeCrystalVisual(pos.x, pos.y, crystal);
            }

            // Play sound effect if available
            if (audioContext && soundEnabled) {
                playCrystalFormationSound();
            }

            // Add to crystal list in UI
            updateTimeCrystalList();

            // Show meta comment
            if (timeDilationState.timeCrystals.length === 1) {
                showTimeMetaComment('A time crystal has formed - you are creating temporal loops');
            } else if (timeDilationState.timeCrystals.length === 5) {
                showTimeMetaComment('Multiple time crystals detected - causality is bending');
            }

            addLog(`Time crystal formed: ${crystal.type} pattern repeated ${crystal.strength}x`, 'match');
        }

        // Spawn visual time crystal on screen
        function spawnTimeCrystalVisual(x, y, crystal) {
            const crystalEl = document.createElement('div');
            crystalEl.className = 'time-crystal';
            crystalEl.style.left = (x - 15) + 'px';
            crystalEl.style.top = (y - 15) + 'px';
            viewport.appendChild(crystalEl);

            // Create ripple effect
            const ripple = document.createElement('div');
            ripple.className = 'time-crystal-ripple';
            ripple.style.left = (x - 15) + 'px';
            ripple.style.top = (y - 15) + 'px';
            viewport.appendChild(ripple);

            // Remove after animation
            setTimeout(() => {
                if (crystalEl.parentNode) crystalEl.remove();
                if (ripple.parentNode) ripple.remove();
            }, 8000);
        }

        // Update time crystal list UI
        function updateTimeCrystalList() {
            if (timeDilationState.timeCrystals.length === 0) {
                timeCrystalListEl.style.display = 'none';
                return;
            }

            timeCrystalListEl.style.display = 'block';
            timeCrystalListEl.innerHTML = '';

            timeDilationState.timeCrystals.slice(-5).reverse().forEach(crystal => {
                const entry = document.createElement('div');
                entry.className = 'time-crystal-entry';
                entry.innerHTML = `
                    <span>
                        <span class="crystal-icon"></span>
                        ${crystal.type} pattern
                    </span>
                    <span class="crystal-count">${crystal.strength}x</span>
                `;
                timeCrystalListEl.appendChild(entry);
            });
        }

        // Play crystal formation sound
        function playCrystalFormationSound() {
            if (!audioContext) return;

            const now = audioContext.currentTime;
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();

            osc.connect(gain);
            gain.connect(masterGain);

            // Crystal chime sound
            osc.type = 'sine';
            osc.frequency.setValueAtTime(800, now);
            osc.frequency.exponentialRampToValueAtTime(1200, now + 0.1);
            osc.frequency.exponentialRampToValueAtTime(600, now + 0.3);

            gain.gain.setValueAtTime(0.1, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);

            osc.start(now);
            osc.stop(now + 0.3);
        }

        // Show time-related meta commentary
        function showTimeMetaComment(message) {
            const now = Date.now();
            if (now - timeDilationState.lastMetaComment < 10000) return; // Throttle

            timeDilationState.lastMetaComment = now;

            const comment = document.createElement('div');
            comment.className = 'time-meta-comment';
            comment.textContent = message || timeDilationState.metaCommentary[
                Math.floor(Math.random() * timeDilationState.metaCommentary.length)
            ];
            viewport.appendChild(comment);

            setTimeout(() => {
                if (comment.parentNode) comment.remove();
            }, 4000);
        }

        // Main time dilation update loop
        function updateTimeDilation() {
            if (!state.isObserving) return;

            calculateInteractionIntensity();
            calculateTimeDilation();
            updateSubjectiveTime();
            updateTimeDilationDisplay();
            updateTimeVisualEffects();

            // Occasionally show meta commentary based on time state
            if (Math.random() < 0.001) { // Low probability
                const factor = timeDilationState.timeDilationFactor;
                if (factor < 0.5 && timeDilationState.interactionIntensity > 70) {
                    showTimeMetaComment();
                }
            }
        }

        // Initialize time dilation when observation starts
        function startTimeDilation() {
            timeDilationState.objectiveStartTime = Date.now();
            timeDilationState.subjectiveTime = 0;
            timeDilationState.lastUpdateTime = Date.now();
            timeDilationState.interactionIntensity = 0;
            timeDilationState.recentActions = [];
            timeDilationState.timeCrystals = [];
            timeDilationState.crystalPatterns.clear();

            // Show intro commentary
            setTimeout(() => {
                showTimeMetaComment('Time begins to warp under observation...');
            }, 2000);
        }

        // Reset time dilation
        function resetTimeDilation() {
            timeDilationState.timeCrystals.forEach(crystal => {
                // Remove visual crystals
                const crystals = viewport.querySelectorAll('.time-crystal');
                crystals.forEach(el => el.remove());
            });

            timeDilationState.objectiveStartTime = Date.now();
            timeDilationState.subjectiveTime = 0;
            timeDilationState.lastUpdateTime = Date.now();
            timeDilationState.interactionIntensity = 0;
            timeDilationState.timeDilationFactor = 1.0;
            timeDilationState.recentActions = [];
            timeDilationState.timeFlowState = 'normal';
        }

    </script>

    <!-- Replay Timeline -->
    <div class="replay-timeline" id="replayTimeline">
        <div class="timeline-scrubber" id="timelineScrubber">
            <div class="timeline-progress" id="timelineProgress"></div>
            <div class="timeline-events" id="timelineEvents"></div>
            <div class="timeline-playhead" id="timelinePlayhead"></div>
        </div>
        <div class="replay-controls">
            <button class="replay-button" id="replayPlayBtn"> Play</button>
            <button class="replay-button" id="replayPauseBtn" disabled> Pause</button>
            <button class="replay-button" id="replayRewindBtn"> Rewind</button>
            <div class="speed-control">
                <span style="font-size: 0.75em; color: #888; margin-right: 8px;">Speed:</span>
                <button class="speed-button" data-speed="0.5">0.5x</button>
                <button class="speed-button active" data-speed="1">1x</button>
                <button class="speed-button" data-speed="2">2x</button>
                <button class="speed-button" data-speed="4">4x</button>
            </div>
            <div class="time-display" id="timeDisplay">0:00 / 0:00</div>
        </div>
    </div>


    <!-- Philosophical Dialogue System -->
    <div id="philosophicalOverlay" class="philosophical-overlay" style="display: none;"></div>
    <div id="philosophicalDialogue" class="philosophical-dialogue" style="display: none;">
        <h3>A Question from Your Reflection</h3>
        <div id="philosophicalQuestion" class="question"></div>
        <div id="philosophicalAnswers" class="philosophical-answers"></div>
    </div>

    <!-- Psychological Profile Modal -->
    <div id="profileModal" class="profile-modal" style="display: none;">
        <h2>Your Psychological Profile</h2>
        <div class="subtitle">Based on 500+ actions and your philosophical responses</div>
        <div id="profileContent"></div>
        <button class="profile-close-btn" onclick="closeProfileModal()">Close</button>
    </div>

    <!-- Paradox Engine UI -->
    <div class="paradox-meter-container" id="paradoxMeter">
        <div class="paradox-meter-title">Paradox Level</div>
        <div class="paradox-meter-bar">
            <div class="paradox-meter-fill" id="paradoxMeterFill" style="width: 0%"></div>
        </div>
        <div class="paradox-count" id="paradoxCount">0 paradoxes detected</div>
        <button class="paradox-collection-btn" onclick="openParadoxCollection()">View Collection</button>
    </div>

    <!-- Reality Break Overlay -->
    <div class="reality-break-overlay" id="realityBreakOverlay"></div>

    <!-- Paradox Collection Modal -->
    <div class="paradox-collection-modal" id="paradoxCollectionModal">
        <h2>Paradox Collection</h2>
        <div class="subtitle">Contradictions in the fabric of recursive observation</div>
        <div id="paradoxCollectionContent"></div>
        <button class="paradox-close-btn" onclick="closeParadoxCollection()">Close</button>
    </div>

    <!-- Paradox Alert -->
    <div class="paradox-alert" id="paradoxAlert">
        <h2>PARADOX THRESHOLD REACHED</h2>
        <p id="paradoxAlertText">Reality is breaking...</p>
    </div>


    <!-- Glitch Art Full-Size Modal -->
    <div class="glitch-modal" id="glitchModal">
        <div class="glitch-modal-content">
            <button class="glitch-modal-close" onclick="closeGlitchModal()">&times;</button>
            <img id="glitchModalImage" class="glitch-modal-image" src="" alt="Glitch Art">
        </div>
    </div>

</body>
</html>
