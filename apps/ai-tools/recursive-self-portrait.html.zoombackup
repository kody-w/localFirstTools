<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Recursive Self-Portrait</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Courier New', monospace;
            background: #0a0a0f;
            color: #e0e0e0;
            min-height: 100vh;
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        .simulation-viewport {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: linear-gradient(135deg, #0d0d15 0%, #1a1a2e 100%);
        }

        .recursion-layer {
            position: absolute;
            border: 2px solid rgba(100, 200, 255, 0.3);
            border-radius: 8px;
            background: rgba(10, 10, 20, 0.9);
            box-shadow:
                0 0 20px rgba(100, 200, 255, 0.1),
                inset 0 0 40px rgba(100, 200, 255, 0.05);
            transition: all 0.3s ease;
            overflow: hidden;
        }

        .recursion-layer::before {
            content: attr(data-depth);
            position: absolute;
            top: 5px;
            left: 10px;
            font-size: 10px;
            color: rgba(100, 200, 255, 0.6);
            z-index: 10;
        }

        .recursion-layer.diverged {
            border-color: rgba(255, 100, 100, 0.5);
            box-shadow:
                0 0 30px rgba(255, 100, 100, 0.2),
                inset 0 0 40px rgba(255, 100, 100, 0.05);
        }

        .recursion-layer.converged {
            border-color: rgba(100, 255, 150, 0.5);
            box-shadow:
                0 0 30px rgba(100, 255, 150, 0.2),
                inset 0 0 40px rgba(100, 255, 150, 0.05);
        }

        .ghost-cursor {
            position: absolute;
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 100;
            will-change: transform;
        }

        .ghost-cursor::before {
            content: '';
            position: absolute;
            width: 0;
            height: 0;
            border-left: 8px solid currentColor;
            border-top: 5px solid transparent;
            border-bottom: 5px solid transparent;
            transform: rotate(-45deg);
        }

        .ghost-cursor::after {
            content: '';
            position: absolute;
            top: 12px;
            left: 6px;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
            opacity: 0.5;
        }

        .ghost-click {
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid currentColor;
            animation: clickRipple 0.6s ease-out forwards;
            pointer-events: none;
        }

        @keyframes clickRipple {
            0% { transform: scale(0); opacity: 1; }
            100% { transform: scale(2); opacity: 0; }
        }

        .sidebar {
            width: 320px;
            background: rgba(15, 15, 25, 0.95);
            border-left: 1px solid rgba(100, 200, 255, 0.2);
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            overflow-y: auto;
        }

        h1 {
            font-size: 1.4em;
            background: linear-gradient(90deg, #64c8ff, #a080ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-align: center;
        }

        .subtitle {
            font-size: 0.75em;
            color: #888;
            text-align: center;
            font-style: italic;
        }

        .stats-panel {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(100, 200, 255, 0.1);
        }

        .stat-row:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }

        .stat-label {
            color: #888;
            font-size: 0.85em;
        }

        .stat-value {
            font-weight: bold;
            color: #64c8ff;
        }

        .stat-value.diverged { color: #ff6464; }
        .stat-value.converged { color: #64ff96; }

        .depth-slider {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
        }

        .depth-slider label {
            display: block;
            margin-bottom: 10px;
            color: #aaa;
            font-size: 0.9em;
        }

        .depth-slider input[type="range"] {
            width: 100%;
            height: 8px;
            -webkit-appearance: none;
            appearance: none;
            background: linear-gradient(90deg, #1a1a2e, #64c8ff);
            border-radius: 4px;
            outline: none;
        }

        .depth-slider input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: #64c8ff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(100, 200, 255, 0.5);
        }

        .behavior-log {
            flex: 1;
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
            overflow-y: auto;
            min-height: 200px;
        }

        .behavior-log h3 {
            color: #888;
            font-size: 0.85em;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .log-entry {
            font-size: 0.75em;
            padding: 5px 8px;
            margin-bottom: 5px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            border-left: 3px solid #64c8ff;
            color: #aaa;
        }

        .log-entry.prediction { border-left-color: #a080ff; }
        .log-entry.divergence { border-left-color: #ff6464; }
        .log-entry.match { border-left-color: #64ff96; }

        .controls {
            display: flex;
            gap: 10px;
        }

        button {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 6px;
            font-family: inherit;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #64c8ff, #a080ff);
            color: #0a0a0f;
            font-weight: bold;
        }

        .btn-secondary {
            background: rgba(100, 200, 255, 0.1);
            color: #64c8ff;
            border: 1px solid rgba(100, 200, 255, 0.3);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(100, 200, 255, 0.3);
        }

        .divergence-meter {
            height: 8px;
            background: rgba(30, 30, 50, 0.8);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 10px;
        }

        .divergence-fill {
            height: 100%;
            background: linear-gradient(90deg, #64ff96, #ffff64, #ff6464);
            transition: width 0.3s ease;
        }

        .philosophical-quote {
            text-align: center;
            font-style: italic;
            color: #666;
            font-size: 0.8em;
            padding: 15px;
            border-top: 1px solid rgba(100, 200, 255, 0.1);
        }

        .voice-panel {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
        }

        .voice-panel h3 {
            color: #888;
            font-size: 0.85em;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .voice-toggle-btn {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 6px;
            font-family: inherit;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.2s ease;
            background: rgba(160, 128, 255, 0.1);
            color: #a080ff;
            border: 1px solid rgba(160, 128, 255, 0.3);
            margin-bottom: 12px;
        }

        .voice-toggle-btn.active {
            background: linear-gradient(135deg, #a080ff, #64c8ff);
            color: #0a0a0f;
            font-weight: bold;
        }

        .voice-toggle-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(160, 128, 255, 0.3);
        }

        .voice-control {
            margin-bottom: 12px;
        }

        .voice-control label {
            display: block;
            margin-bottom: 5px;
            color: #aaa;
            font-size: 0.85em;
        }

        .voice-control input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: linear-gradient(90deg, #1a1a2e, #a080ff);
            border-radius: 3px;
            outline: none;
        }

        .voice-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #a080ff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 8px rgba(160, 128, 255, 0.5);
        }

        .voice-control input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #a080ff;
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 8px rgba(160, 128, 255, 0.5);
        }

        .voice-status {
            font-size: 0.75em;
            color: #666;
            padding: 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            text-align: center;
        }

        .voice-status.speaking {
            color: #a080ff;
            animation: pulse 1s infinite;
        }

        .transcript-panel {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
            margin-top: 10px;
            max-height: 150px;
            overflow-y: auto;
        }

        .transcript-panel h3 {
            color: #888;
            font-size: 0.85em;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .transcript-entry {
            font-size: 0.75em;
            padding: 5px 8px;
            margin-bottom: 5px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            border-left: 3px solid #a080ff;
            color: #aaa;
        }

        .transcript-entry.user {
            border-left-color: #64ff96;
        }

        .interaction-zone {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 200px;
            height: 200px;
            border: 2px dashed rgba(100, 200, 255, 0.3);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
            font-size: 0.9em;
            text-align: center;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .simulation-viewport:not(.recording) .interaction-zone {
            opacity: 1;
        }

        .recording-indicator {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 15px;
            background: rgba(255, 64, 64, 0.2);
            border: 1px solid rgba(255, 64, 64, 0.5);
            border-radius: 20px;
            color: #ff6464;
            font-size: 0.85em;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .recording-indicator.active {
            opacity: 1;
        }

        .recording-dot {
            width: 10px;
            height: 10px;
            background: #ff6464;
            border-radius: 50%;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        .depth-label {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 20px;
            border-radius: 20px;
            font-size: 0.9em;
            color: #64c8ff;
        }

        .data-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
            display: flex;
            gap: 10px;
        }

        .data-controls button {
            padding: 8px 16px;
            font-size: 0.8em;
            background: rgba(100, 200, 255, 0.1);
            border: 1px solid rgba(100, 200, 255, 0.3);
            color: #64c8ff;
        }

        .mini-element {
            position: absolute;
            background: rgba(100, 200, 255, 0.3);
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .mini-element:hover {
            background: rgba(100, 200, 255, 0.5);
        }

        .thought-bubble {
            position: absolute;
            background: rgba(160, 128, 255, 0.2);
            border: 1px solid rgba(160, 128, 255, 0.4);
            border-radius: 12px;
            padding: 8px 12px;
            font-size: 0.7em;
            color: #a080ff;
            pointer-events: none;
            animation: floatUp 3s ease-out forwards;
            white-space: nowrap;
        }

        @keyframes floatUp {
            0% { opacity: 0; transform: translateY(10px); }
            20% { opacity: 1; }
            80% { opacity: 1; }
            100% { opacity: 0; transform: translateY(-30px); }
        }

        .infinity-symbol {
            position: absolute;
            font-size: 100px;
            color: rgba(100, 200, 255, 0.05);
            pointer-events: none;
            animation: rotate 20s linear infinite;
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* Prediction trails */
        .prediction-trail {
            position: absolute;
            pointer-events: none;
            z-index: 50;
        }

        .prediction-trail path {
            fill: none;
            stroke-width: 2;
            opacity: 0.4;
            stroke-dasharray: 5, 5;
            animation: dashMove 1s linear infinite;
        }

        @keyframes dashMove {
            to { stroke-dashoffset: -10; }
        }

        /* Heat map */
        .heat-map {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
            opacity: 0.4;
        }

        .heat-point {
            position: absolute;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255, 100, 100, 0.6), transparent);
            will-change: transform, opacity;
            animation: heatFade 3s ease-out forwards;
        }

        @keyframes heatFade {
            from { opacity: 1; }
            to { opacity: 0; }
        }

        /* Glitch effects */
        .glitch-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 200;
            opacity: 0;
            transition: opacity 0.1s;
        }

        .glitch-overlay.active {
            opacity: 1;
        }

        .scanline {
            position: absolute;
            left: 0;
            width: 100%;
            height: 2px;
            background: rgba(100, 200, 255, 0.3);
            animation: scan 4s linear infinite;
        }

        @keyframes scan {
            from { top: 0%; }
            to { top: 100%; }
        }

        .recursion-layer.glitching {
            animation: glitchShake 0.2s infinite;
        }

        @keyframes glitchShake {
            0%, 100% { transform: translate(0, 0); }
            25% { transform: translate(-2px, 2px); }
            50% { transform: translate(2px, -2px); }
            75% { transform: translate(-2px, -2px); }
        }

        .chromatic-aberration {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            mix-blend-mode: screen;
            opacity: 0;
        }

        .chromatic-aberration.active {
            opacity: 0.3;
            animation: chromaticGlitch 0.3s infinite;
        }

        @keyframes chromaticGlitch {
            0% { transform: translate(0, 0); }
            33% { transform: translate(2px, 0); filter: hue-rotate(90deg); }
            66% { transform: translate(-2px, 0); filter: hue-rotate(180deg); }
            100% { transform: translate(0, 0); }
        }

        /* Behavioral fingerprint */
        .fingerprint-panel {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
            min-height: 150px;
        }

        .fingerprint-panel h3 {
            color: #888;
            font-size: 0.85em;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #fingerprintCanvas {
            width: 100%;
            height: 120px;
            border-radius: 4px;
            background: rgba(0, 0, 0, 0.3);
        }

        /* Meta-commentary */
        .meta-comment {
            position: absolute;
            background: rgba(255, 100, 100, 0.15);
            border: 1px solid rgba(255, 100, 100, 0.4);
            border-radius: 8px;
            padding: 12px 16px;
            font-size: 0.75em;
            color: #ff6464;
            pointer-events: none;
            animation: metaDrift 8s ease-out forwards;
            max-width: 300px;
            text-align: center;
            font-style: italic;
            z-index: 150;
        }

        @keyframes metaDrift {
            0% { opacity: 0; transform: translateY(0) scale(0.9); }
            10% { opacity: 1; transform: translateY(-10px) scale(1); }
            90% { opacity: 1; transform: translateY(-40px) scale(1); }
            100% { opacity: 0; transform: translateY(-60px) scale(0.95); }
        }

        /* Infinity mirror effect */
        .infinity-mirror {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
            opacity: 0;
            transition: opacity 0.5s;
        }

        .infinity-mirror.active {
            opacity: 1;
        }

        .infinity-ring {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 1px solid rgba(100, 200, 255, 0.2);
            border-radius: 50%;
            animation: expandRing 3s ease-out infinite;
        }

        @keyframes expandRing {
            0% { width: 50px; height: 50px; opacity: 0.8; }
            100% { width: 400px; height: 400px; opacity: 0; }
        }

        /* Webcam integration */
        .webcam-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 120px;
            height: 90px;
            border: 2px solid rgba(100, 200, 255, 0.3);
            border-radius: 8px;
            overflow: hidden;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 100;
        }

        .webcam-container.active {
            opacity: 1;
        }

        #webcamVideo {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }

        .webcam-distortion {
            filter: hue-rotate(0deg) blur(0px);
            transition: filter 0.3s;
        }

        /* Emotion detection overlay */
        .emotion-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(to top, rgba(0, 0, 0, 0.8), transparent);
            padding: 4px 8px;
            font-size: 10px;
            color: #64c8ff;
            text-align: center;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }

        .webcam-container.active .emotion-overlay {
            opacity: 1;
        }

        .emotion-overlay .emotion-icon {
            font-size: 14px;
            margin-right: 4px;
        }

        .emotion-overlay .confidence {
            font-size: 8px;
            color: rgba(100, 200, 255, 0.6);
            margin-left: 4px;
        }

        /* Hidden canvas for emotion analysis */
        #emotionCanvas {
            display: none;
        }

        /* Mobile responsive */
        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }

            .sidebar {
                width: 100%;
                max-height: 40vh;
                border-left: none;
                border-top: 1px solid rgba(100, 200, 255, 0.2);
                order: 2;
            }

            .simulation-viewport {
                order: 1;
                height: 60vh;
            }

            .depth-label {
                bottom: 10px;
                font-size: 0.75em;
            }

            .recording-indicator {
                top: 10px;
                left: 10px;
                font-size: 0.7em;
                padding: 6px 10px;
            }

            .meta-comment {
                max-width: 200px;
                font-size: 0.65em;
            }

            .webcam-container {
                width: 80px;
                height: 60px;
                bottom: 10px;
                right: 10px;
            }

            button {
                padding: 10px;
                font-size: 0.85em;
            }
        }

        /* Sound indicator */
        .sound-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            background: rgba(100, 200, 255, 0.1);
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            z-index: 1000;
        }

        .sound-indicator:hover {
            background: rgba(100, 200, 255, 0.2);
        }

        .sound-indicator.muted {
            opacity: 0.4;
        }

        .sound-wave {
            width: 20px;
            height: 20px;
            display: flex;
            gap: 3px;
            align-items: center;
            justify-content: center;
        }

        .sound-bar {
            width: 3px;
            background: #64c8ff;
            border-radius: 2px;
            animation: soundPulse 0.8s ease-in-out infinite;
        }

        .sound-bar:nth-child(1) { height: 8px; animation-delay: 0s; }
        .sound-bar:nth-child(2) { height: 14px; animation-delay: 0.2s; }
        .sound-bar:nth-child(3) { height: 10px; animation-delay: 0.4s; }

        @keyframes soundPulse {
            0%, 100% { transform: scaleY(1); }
            50% { transform: scaleY(1.5); }
        }

        .sound-indicator.muted .sound-bar {
            animation: none;
            height: 2px !important;
        }

        /* Keyboard focus indicators */
        button:focus,
        input[type="range"]:focus,
        .sound-indicator:focus {
            outline: 2px solid #64c8ff;
            outline-offset: 3px;
        }

        button:focus-visible,
        input[type="range"]:focus-visible,
        .sound-indicator:focus-visible {
            outline: 2px solid #64c8ff;
            outline-offset: 3px;
            box-shadow: 0 0 15px rgba(100, 200, 255, 0.5);
        }

        /* Keyboard shortcuts help overlay */
        .shortcuts-overlay {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10, 10, 20, 0.98);
            border: 2px solid rgba(100, 200, 255, 0.5);
            border-radius: 12px;
            padding: 30px;
            z-index: 2000;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 10px 50px rgba(0, 0, 0, 0.8);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .shortcuts-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }

        .shortcuts-overlay h2 {
            color: #64c8ff;
            font-size: 1.3em;
            margin-bottom: 20px;
            text-align: center;
            background: linear-gradient(90deg, #64c8ff, #a080ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .shortcuts-grid {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 12px 20px;
            margin-bottom: 20px;
        }

        .shortcut-key {
            background: rgba(100, 200, 255, 0.1);
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 4px;
            padding: 4px 10px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            color: #64c8ff;
            text-align: center;
            min-width: 60px;
        }

        .shortcut-desc {
            color: #aaa;
            display: flex;
            align-items: center;
        }

        .shortcuts-close {
            display: block;
            margin: 20px auto 0;
            padding: 10px 30px;
            background: linear-gradient(135deg, #64c8ff, #a080ff);
            border: none;
            border-radius: 6px;
            color: #0a0a0f;
            font-weight: bold;
            cursor: pointer;
        }

        .shortcuts-hint {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(100, 200, 255, 0.1);
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 20px;
            padding: 8px 16px;
            font-size: 0.8em;
            color: #64c8ff;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
        }

        .shortcuts-hint.visible {
            animation: fadeInOut 4s ease-in-out;
        }

        @keyframes fadeInOut {
            0%, 100% { opacity: 0; }
            10%, 90% { opacity: 1; }
        }

        /* Fullscreen mode */
        .simulation-viewport.fullscreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw !important;
            height: 100vh !important;
            z-index: 9999;
        }

        .simulation-viewport.fullscreen ~ .sidebar {
            display: none;
        }

        /* Neural network visualization */
        .neural-panel {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
            min-height: 180px;
        }

        .neural-panel h3 {
            color: #888;
            font-size: 0.85em;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #neuralCanvas {
            width: 100%;
            height: 150px;
            border-radius: 4px;
            background: rgba(0, 0, 0, 0.3);
        }

        .stat-value.neural { color: #a080ff; }

        /* ===== REPLAY SYSTEM STYLES ===== */
        .replay-panel {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
        }

        .replay-panel h3 {
            color: #888;
            font-size: 0.85em;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .replay-timeline {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(15, 15, 25, 0.98);
            border-top: 1px solid rgba(100, 200, 255, 0.3);
            padding: 15px 20px 20px;
            z-index: 2000;
            opacity: 0;
            transform: translateY(100%);
            transition: all 0.3s ease;
        }

        .replay-timeline.active {
            opacity: 1;
            transform: translateY(0);
        }

        .timeline-scrubber {
            position: relative;
            height: 40px;
            background: rgba(30, 30, 50, 0.8);
            border-radius: 6px;
            margin-bottom: 15px;
            cursor: pointer;
            overflow: hidden;
        }

        .timeline-progress {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            background: linear-gradient(90deg, #64c8ff, #a080ff);
            pointer-events: none;
            transition: width 0.05s linear;
        }

        .timeline-events {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .timeline-event {
            position: absolute;
            top: 0;
            width: 3px;
            height: 100%;
            background: rgba(255, 100, 100, 0.6);
        }

        .timeline-event.click {
            background: rgba(255, 200, 100, 0.8);
            width: 4px;
        }

        .timeline-playhead {
            position: absolute;
            top: -5px;
            width: 3px;
            height: calc(100% + 10px);
            background: #fff;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
            pointer-events: none;
        }

        .timeline-playhead::before {
            content: '';
            position: absolute;
            top: -8px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-top: 8px solid #fff;
        }

        .replay-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .replay-button {
            padding: 8px 16px;
            background: rgba(100, 200, 255, 0.1);
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 6px;
            color: #64c8ff;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.85em;
            transition: all 0.2s;
        }

        .replay-button:hover:not(:disabled) {
            background: rgba(100, 200, 255, 0.2);
        }

        .replay-button.active {
            background: linear-gradient(135deg, #64c8ff, #a080ff);
            color: #0a0a0f;
        }

        .replay-button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .speed-button {
            padding: 6px 12px;
            background: rgba(100, 200, 255, 0.1);
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 4px;
            color: #64c8ff;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.75em;
        }

        .speed-button.active {
            background: rgba(100, 200, 255, 0.3);
            color: #fff;
        }

        .time-display {
            color: #888;
            font-size: 0.85em;
            font-family: 'Courier New', monospace;
            margin-left: auto;
        }

        .replay-ghost-cursor {
            position: absolute;
            width: 24px;
            height: 24px;
            pointer-events: none;
            z-index: 1500;
            opacity: 0;
        }

        .replay-ghost-cursor.active {
            opacity: 1;
        }

        .replay-ghost-cursor::before {
            content: '';
            position: absolute;
            width: 0;
            height: 0;
            border-left: 10px solid #ff6464;
            border-top: 6px solid transparent;
            border-bottom: 6px solid transparent;
            transform: rotate(-45deg);
            filter: drop-shadow(0 0 6px rgba(255, 100, 100, 0.8));
        }

        .replay-ghost-cursor::after {
            content: 'REPLAY';
            position: absolute;
            top: -20px;
            left: 15px;
            font-size: 8px;
            color: #ff6464;
            font-weight: bold;
        }

        .comparison-cursor {
            position: absolute;
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 1001;
            opacity: 0;
        }

        .comparison-cursor.active {
            opacity: 0.7;
        }

        .comparison-cursor::before {
            content: '';
            position: absolute;
            width: 0;
            height: 0;
            border-left: 8px solid #64ff96;
            border-top: 5px solid transparent;
            border-bottom: 5px solid transparent;
            transform: rotate(-45deg);
            filter: drop-shadow(0 0 4px rgba(100, 255, 150, 0.6));
        }

        .comparison-cursor::after {
            content: 'LIVE';
            position: absolute;
            top: -18px;
            left: 12px;
            font-size: 8px;
            color: #64ff96;
            font-weight: bold;
        }

        .replay-mode-badge {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 100, 100, 0.2);
            border: 1px solid rgba(255, 100, 100, 0.5);
            padding: 8px 20px;
            border-radius: 20px;
            color: #ff6464;
            font-size: 0.85em;
            font-weight: bold;
            z-index: 1500;
            opacity: 0;
            text-transform: uppercase;
        }

        .replay-mode-badge.active {
            opacity: 1;
        }

        .replay-list {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
        }

        .replay-item {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            margin-bottom: 8px;
            border-radius: 6px;
            border-left: 3px solid #64c8ff;
            cursor: pointer;
            transition: all 0.2s;
        }

        .replay-item:hover {
            background: rgba(100, 200, 255, 0.1);
            transform: translateX(5px);
        }

        .replay-item.active {
            border-left-color: #a080ff;
            background: rgba(160, 128, 255, 0.15);
        }

        .replay-item-title {
            font-size: 0.85em;
            color: #e0e0e0;
            margin-bottom: 4px;
        }

        .replay-item-stats {
            font-size: 0.7em;
            color: #888;
        }

        .tab-container {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .tab-button {
            flex: 1;
            padding: 10px;
            background: rgba(30, 30, 50, 0.5);
            border: 1px solid rgba(100, 200, 255, 0.2);
            border-radius: 6px;
            color: #888;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.85em;
            transition: all 0.2s;
        }

        .tab-button.active {
            background: rgba(100, 200, 255, 0.2);
            border-color: rgba(100, 200, 255, 0.5);
            color: #64c8ff;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* ===== MULTIPLAYER STYLES ===== */
        .multiplayer-panel {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
        }

        .multiplayer-panel h3 {
            color: #888;
            font-size: 0.85em;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .room-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .room-controls input {
            flex: 1;
            padding: 8px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 4px;
            color: #e0e0e0;
            font-family: inherit;
            font-size: 0.85em;
        }

        .room-controls input::placeholder {
            color: #666;
        }

        .room-controls button {
            padding: 8px 12px !important;
            font-size: 0.85em !important;
        }

        .room-code-display {
            background: rgba(100, 200, 255, 0.1);
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 4px;
            padding: 10px;
            text-align: center;
            font-family: 'Courier New', monospace;
            font-size: 1.1em;
            color: #64c8ff;
            letter-spacing: 2px;
            margin-bottom: 10px;
            cursor: pointer;
        }

        .room-code-display:hover {
            background: rgba(100, 200, 255, 0.15);
        }

        .connection-status {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            font-size: 0.8em;
            margin-bottom: 10px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #666;
        }

        .status-dot.connected {
            background: #64ff96;
            animation: pulse 2s infinite;
        }

        .status-dot.connecting {
            background: #ffff64;
            animation: pulse 1s infinite;
        }

        .peer-cursor {
            position: absolute;
            pointer-events: none;
            z-index: 500;
            transition: all 0.05s linear;
            will-change: transform;
        }

        .peer-cursor::before {
            content: '';
            position: absolute;
            width: 0;
            height: 0;
            border-left: 10px solid #ff6496;
            border-top: 6px solid transparent;
            border-bottom: 6px solid transparent;
            transform: rotate(-45deg);
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.5));
        }

        .peer-cursor::after {
            content: attr(data-peer-name);
            position: absolute;
            top: 16px;
            left: 12px;
            background: rgba(255, 100, 150, 0.9);
            color: white;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.7em;
            white-space: nowrap;
            pointer-events: none;
        }

        .peer-layers-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 30;
        }

        .peer-recursion-layer {
            position: absolute;
            border: 2px solid rgba(255, 100, 150, 0.3);
            border-radius: 8px;
            background: rgba(30, 10, 20, 0.7);
            box-shadow:
                0 0 20px rgba(255, 100, 150, 0.1),
                inset 0 0 40px rgba(255, 100, 150, 0.05);
            transition: all 0.3s ease;
        }

        .peer-recursion-layer::before {
            content: attr(data-depth);
            position: absolute;
            top: 5px;
            right: 10px;
            font-size: 10px;
            color: rgba(255, 100, 150, 0.6);
            z-index: 10;
        }

        .peer-ghost-cursor {
            color: #ff6496;
        }

        .comparative-stats {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 10px;
            align-items: center;
            margin-bottom: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }

        .comparative-stats .my-stat {
            text-align: right;
            color: #64c8ff;
            font-size: 0.85em;
        }

        .comparative-stats .vs {
            color: #888;
            font-weight: bold;
            font-size: 0.7em;
        }

        .comparative-stats .peer-stat {
            text-align: left;
            color: #ff6496;
            font-size: 0.85em;
        }

        .predict-mode-panel {
            background: rgba(160, 128, 255, 0.1);
            border: 1px solid rgba(160, 128, 255, 0.3);
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 10px;
            transition: all 0.2s;
            text-align: center;
        }

        .predict-mode-panel.active {
            background: rgba(160, 128, 255, 0.2);
            border-color: rgba(160, 128, 255, 0.5);
        }

        .predict-score {
            font-size: 1.3em;
            color: #a080ff;
            margin-top: 5px;
            font-weight: bold;
        }

        .fingerprint-comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }

        .fingerprint-mini {
            text-align: center;
        }

        .fingerprint-mini canvas {
            width: 100%;
            height: 80px;
            border-radius: 4px;
            background: rgba(0, 0, 0, 0.3);
        }

        .fingerprint-mini .label {
            font-size: 0.7em;
            color: #888;
            margin-top: 5px;
        }

        .meta-comment.dual {
            background: rgba(160, 128, 255, 0.15);
            border-color: rgba(160, 128, 255, 0.4);
            color: #a080ff;
        }

        /* 3D Mode Styles */
        .mode-3d-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 5;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
            background: radial-gradient(circle at center, rgba(10, 10, 15, 0.95), rgba(5, 5, 10, 1));
        }

        .mode-3d-canvas.active {
            opacity: 1;
            pointer-events: auto;
        }

        .mode-3d-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 15px;
            background: rgba(100, 200, 255, 0.1);
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 10px 0;
        }

        .mode-3d-toggle:hover {
            background: rgba(100, 200, 255, 0.2);
            border-color: rgba(100, 200, 255, 0.5);
        }

        .mode-3d-toggle.active {
            background: rgba(100, 200, 255, 0.3);
            border-color: rgba(100, 200, 255, 0.7);
        }

        .mode-3d-toggle input[type="checkbox"] {
            margin: 0;
            cursor: pointer;
        }

        .mode-3d-toggle label {
            margin: 0;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            color: #64c8ff;
            font-size: 0.95em;
        }

        .mode-3d-icon {
            font-size: 1.2em;
        }

        .mode-3d-controls {
            display: none;
            padding: 10px;
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            margin-top: 10px;
        }

        .mode-3d-controls.active {
            display: block;
        }

        .mode-3d-controls .depth-slider {
            margin-bottom: 10px;
        }

        .mode-3d-info {
            position: absolute;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 12px 24px;
            border-radius: 24px;
            font-size: 0.85em;
            color: #64c8ff;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            z-index: 10;
            text-align: center;
        }

        .mode-3d-info.active {
            opacity: 1;
        }
    </style>
</head>
<body>

    <!-- Keyboard shortcuts overlay -->
    <div class="shortcuts-overlay" id="shortcutsOverlay" role="dialog" aria-labelledby="shortcuts-title" aria-modal="true">
        <h2 id="shortcuts-title">Keyboard Shortcuts</h2>
        <div class="shortcuts-grid">
            <div class="shortcut-key">Space</div>
            <div class="shortcut-desc">Start/stop observation</div>

            <div class="shortcut-key">‚Üë / ‚Üì</div>
            <div class="shortcut-desc">Increase/decrease recursion depth</div>

            <div class="shortcut-key">1-9</div>
            <div class="shortcut-desc">Set depth to that number</div>

            <div class="shortcut-key">M</div>
            <div class="shortcut-desc">Toggle sound mute</div>

            <div class="shortcut-key">W</div>
            <div class="shortcut-desc">Toggle webcam</div>

            <div class="shortcut-key">R</div>
            <div class="shortcut-desc">Reset session</div>

            <div class="shortcut-key">F</div>
            <div class="shortcut-desc">Toggle fullscreen mode</div>

            <div class="shortcut-key">Esc</div>
            <div class="shortcut-desc">Stop observation / Close this dialog</div>

            <div class="shortcut-key">?</div>
            <div class="shortcut-desc">Show/hide this help</div>
        </div>
        <button class="shortcuts-close" onclick="toggleShortcutsOverlay()">Close</button>
    </div>

    <!-- Keyboard shortcut hint -->
    <div class="shortcuts-hint" id="shortcutsHint">Press ? for keyboard shortcuts</div>

    <div class="container">
        <div class="simulation-viewport" id="viewport">
            <div class="infinity-symbol" style="top: 50%; left: 50%; transform: translate(-50%, -50%);">‚àû</div>

            <!-- Sound control -->
            <div class="sound-indicator" id="soundToggle" title="Toggle sound" role="button" tabindex="0" aria-label="Toggle sound mute (M)">
                <div class="sound-wave">
                    <div class="sound-bar"></div>
                    <div class="sound-bar"></div>
                    <div class="sound-bar"></div>
                </div>
            </div>

            <!-- Glitch overlay -->
            <div class="glitch-overlay" id="glitchOverlay">
                <div class="scanline"></div>
                <div class="chromatic-aberration" id="chromaticEffect"></div>
            </div>

            <!-- Infinity mirror effect -->
            <div class="infinity-mirror" id="infinityMirror"></div>

            <!-- Heat map overlay -->
            <div class="heat-map" id="heatMap"></div>

            <!-- Prediction trails SVG -->
            <svg class="prediction-trail" id="predictionTrail" width="100%" height="100%"></svg>

            <!-- Webcam integration -->
            <div class="webcam-container" id="webcamContainer">
                <video id="webcamVideo" class="webcam-distortion" autoplay muted playsinline></video>
                <div class="emotion-overlay" id="emotionOverlay">
                    <span class="emotion-icon" id="emotionIcon">üòê</span>
                    <span id="emotionLabel">neutral</span>
                    <span class="confidence" id="emotionConfidence"></span>
                </div>
            </div>

            <!-- Hidden canvas for emotion detection -->
            <canvas id="emotionCanvas" width="160" height="120"></canvas>

            <div class="recording-indicator" id="recordingIndicator">
                <div class="recording-dot"></div>
                <span>OBSERVING YOU</span>
            </div>
            <div class="interaction-zone">
                Move your cursor here<br>to begin observation
            </div>

            <!-- Peer multiplayer layers -->
            <div class="peer-layers-container" id="peerLayersContainer"></div>
            <!-- Peer cursor -->
            <div class="peer-cursor" id="peerCursor" data-peer-name="Peer" style="display: none;"></div>

            <div class="depth-label" id="depthLabel">Depth: 0 ‚Üí ‚àû</div>

            <!-- Replay mode indicator -->
            <div class="replay-mode-badge" id="replayModeBadge">Replay Mode</div>

            <!-- Replay ghost cursor -->
            <div class="replay-ghost-cursor" id="replayGhostCursor"></div>

            <!-- Comparison cursor (for comparison mode) -->
            <div class="comparison-cursor" id="comparisonCursor"></div>
        </div>

        <div class="sidebar">
            <div>
                <h1>‚àû Recursive Self-Portrait</h1>
                <p class="subtitle">How deep until the model diverges from reality?</p>
            </div>


            <!-- Tabs for switching between Observe and Replay modes -->
            <div class="tab-container">
                <button class="tab-button active" data-tab="observe">Observe</button>
                <button class="tab-button" data-tab="replay">Replay</button>
            </div>

            <!-- Observe Tab Content -->
            <div class="tab-content active" id="observeTab">
            <div class="stats-panel">
                <div class="stat-row">
                    <span class="stat-label">Current Depth</span>
                    <span class="stat-value" id="currentDepth">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Actions Recorded</span>
                    <span class="stat-value" id="actionsRecorded">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Predictions Made</span>
                    <span class="stat-value" id="predictionsMade">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Accuracy</span>
                    <span class="stat-value" id="accuracy">‚Äî</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Divergence Level</span>
                    <span class="stat-value" id="divergenceLevel">0%</span>
                </div>
                <div class="divergence-meter">
                    <div class="divergence-fill" id="divergenceFill" style="width: 0%"></div>
                </div>

                <div class="stat-row">
                    <span class="stat-label">Neural Confidence</span>
                    <span class="stat-value neural" id="neuralConfidence">‚Äî</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Prediction Mode</span>
                    <span class="stat-value" id="predictionMode">Heuristic</span>
                </div>
            </div>

            <div class="depth-slider">
                <label>Recursion Depth: <span id="depthValue">5</span></label>
                <input type="range" id="depthSlider" min="1" max="12" value="5" aria-label="Recursion depth slider (Use up/down arrows or 1-9 keys)">
            </div>

            <div class="depth-slider">
                <label style="display: flex; align-items: center; cursor: pointer;">
                    <input type="checkbox" id="neuralToggle" style="margin-right: 8px; cursor: pointer;">
                    <span>Use Neural Prediction</span>
                </label>

            <div class="multiplayer-panel" id="multiplayerPanel">
                <h3>Multiplayer Mode</h3>
                <div class="connection-status">
                    <div class="status-dot" id="connectionDot"></div>
                    <span id="connectionText">Not connected</span>
                </div>
                <div class="room-controls">
                    <input type="text" id="roomCodeInput" placeholder="Enter room code" />
                    <button class="btn-secondary" id="joinRoomBtn">Join</button>
                </div>
                <button class="btn-secondary" id="createRoomBtn" style="width: 100%;">Create New Room</button>
                <div class="room-code-display" id="roomCodeDisplay" style="display: none;" title="Click to copy">
                    Room: <span id="roomCode"></span>
                </div>
                <div class="comparative-stats" id="comparativeStats" style="display: none;">
                    <div class="my-stat">
                        You: <span id="myDivergence">0%</span>
                    </div>
                    <div class="vs">VS</div>
                    <div class="peer-stat">
                        Peer: <span id="peerDivergence">0%</span>
                    </div>
                </div>
                <div class="predict-mode-panel" id="predictModePanel" style="display: none;">
                    <button class="btn-secondary" id="predictModeBtn" style="width: 100%;">
                        Start "Predict Each Other" Mode
                    </button>
                    <div class="predict-score" id="predictScore"></div>
                </div>
            </div>

            </div>

            <div class="controls">
                <button class="btn-primary" id="startBtn" aria-label="Start or stop observation (Space key)">Begin Observation</button>
                <button class="btn-secondary" id="resetBtn" aria-label="Reset session (R key)">Reset</button>
            </div>

            <div class="fingerprint-panel">
                <h3>Behavioral Fingerprint</h3>
                <canvas id="fingerprintCanvas"></canvas>
            </div>

            <div class="neural-panel">
                <h3>Neural Network Architecture</h3>
                <canvas id="neuralCanvas"></canvas>
            </div>

            <div class="behavior-log" id="behaviorLog" aria-live="polite" aria-atomic="false">
                <h3>Behavioral Model Log</h3>
                <div id="logEntries" role="log"></div>
            </div>

            <div class="controls">
                <button class="btn-secondary" onclick="exportData()" aria-label="Export session data">Export Session</button>
                <button class="btn-secondary" onclick="document.getElementById('importFile').click()" aria-label="Import session data">Import</button>
                <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importData(event)">
            </div>

            <button class="btn-secondary" id="webcamToggle" aria-label="Toggle webcam (W key)">Enable Webcam (Optional)</button>

            <div class="voice-panel">
                <h3>Voice Narration</h3>
                <button class="voice-toggle-btn" id="voiceToggle">Enable Voice</button>

                <div class="voice-control">
                    <label>Voice Pitch: <span id="pitchValue">1.0</span></label>
                    <input type="range" id="pitchSlider" min="0.5" max="2" value="1" step="0.1">
                </div>

                <div class="voice-control">
                    <label>Voice Rate: <span id="rateValue">1.0</span></label>
                    <input type="range" id="rateSlider" min="0.5" max="2" value="1" step="0.1">
                </div>

                <div class="voice-control">
                    <label style="display: flex; align-items: center; cursor: pointer;">
                        <input type="checkbox" id="listenToggle" style="margin-right: 8px; cursor: pointer;">
                        <span>Listen to Me (Speech Recognition)</span>
                    </label>
                </div>

                <div class="voice-status" id="voiceStatus">Voice inactive</div>
            </div>

            <div class="transcript-panel" id="transcriptPanel" style="display: none;">
                <h3>Conversation Transcript</h3>
                <div id="transcriptEntries"></div>
            </div>

            </div><!-- End Observe Tab -->

            <!-- Replay Tab Content -->
            <div class="tab-content" id="replayTab">
                <div class="replay-panel">
                    <h3>Saved Replays</h3>
                    <div class="replay-list" id="replayList">
                        <div style="color: #666; font-size: 0.8em; text-align: center; padding: 20px;">
                            No saved replays yet.<br>Record a session first!
                        </div>
                    </div>
                    <div class="replay-save-controls" style="display: flex; gap: 8px; margin-top: 10px;">
                        <button class="btn-secondary" style="flex: 1;" onclick="saveCurrentReplay()">Save Current Session</button>
                        <button class="btn-secondary" onclick="document.getElementById('importReplayFile').click()">Import Replay</button>
                        <input type="file" id="importReplayFile" accept=".json" style="display: none;" onchange="importReplay(event)">
                    </div>
                </div>

                <div class="replay-panel" style="margin-top: 15px;">
                    <h3>Replay Controls</h3>
                    <label style="display: flex; align-items: center; gap: 8px; margin-top: 10px;">
                        <input type="checkbox" id="comparisonModeToggle">
                        <span style="font-size: 0.85em;">Comparison Mode (overlay current movements)</span>
                    </label>
                </div>
            </div><!-- End Replay Tab -->

            <div class="philosophical-quote">
                "I think, therefore I simulate myself thinking,<br>
                therefore I simulate myself simulating..."
            </div>
        </div>
    </div>

    <script>
        const APP_NAME = 'recursive-self-portrait';

        // Web Audio API setup
        let audioContext = null;
        let masterGain = null;
        let soundEnabled = true;
        let ambientOscillator = null;

        // Webcam
        let webcamStream = null;
        let webcamEnabled = false;

        // Object pools for reusable elements
        const heatPointPool = [];
        const ghostCursorPool = [];
        const MAX_POOL_SIZE = 50;

        function getPooledHeatPoint() {
            return heatPointPool.pop() || document.createElement('div');
        }

        function releaseHeatPoint(element) {
            if (heatPointPool.length < MAX_POOL_SIZE) {
                element.className = 'heat-point';
                element.removeAttribute('style');
                heatPointPool.push(element);
            }
        }

        // Voice synthesis state
        let voiceState = {
            enabled: false,
            synth: window.speechSynthesis,
            pitch: 1.0,
            rate: 1.0,
            queue: [],
            isSpeaking: false,
            currentUtterance: null,
            preferredVoice: null,
            recognition: null,
            listening: false,
            transcript: []
        };

        // State
        let state = {
            isObserving: false,
            depth: 5,
            actions: [],
            predictions: [],
            layers: [],
            cursors: [],
            divergenceScore: 0,
            correctPredictions: 0,
            totalPredictions: 0,
            behaviorModel: {
                avgSpeed: 0,
                preferredZones: [],
                clickPatterns: [],
                hesitationPoints: [],
                movementStyle: 'unknown', // 'erratic', 'smooth', 'precise', 'lazy'
                heatMapData: [] // Track cursor positions for heat map
            },
            emotionState: {
                current: 'neutral',
                icon: 'üòê',
                confidence: 0,
                history: [], // Track emotion changes over time
                divergenceCorrelations: [] // Track emotions during divergence events
            },
            sessionHistory: [],
            predictionPaths: [], // For visualization
            metaObservations: [] // Meta-commentary about user
        };


        // ===== REPLAY SYSTEM STATE =====
        let replayState = {
            isPlaying: false,
            isPaused: false,
            currentReplay: null,
            currentTime: 0,
            playbackSpeed: 1,
            comparisonMode: false,
            savedReplays: [],
            animationFrame: null
        };

        // Load saved replays from localStorage
        const savedReplaysData = localStorage.getItem(APP_NAME + '-replays');
        if (savedReplaysData) {
            try {
                replayState.savedReplays = JSON.parse(savedReplaysData);
            } catch(e) {
                replayState.savedReplays = [];
            }
        }

        // Load saved state
        const savedState = localStorage.getItem(APP_NAME);
        if (savedState) {
            const parsed = JSON.parse(savedState);
            state.sessionHistory = parsed.sessionHistory || [];
            state.behaviorModel = parsed.behaviorModel || state.behaviorModel;
        }

        // DOM Elements
        const viewport = document.getElementById('viewport');
        const recordingIndicator = document.getElementById('recordingIndicator');
        const depthSlider = document.getElementById('depthSlider');
        const depthValue = document.getElementById('depthValue');
        const depthLabel = document.getElementById('depthLabel');
        const startBtn = document.getElementById('startBtn');
        const resetBtn = document.getElementById('resetBtn');
        const logEntries = document.getElementById('logEntries');

        // Stats elements
        const currentDepthEl = document.getElementById('currentDepth');
        const actionsRecordedEl = document.getElementById('actionsRecorded');
        const predictionsMadeEl = document.getElementById('predictionsMade');
        const accuracyEl = document.getElementById('accuracy');
        const divergenceLevelEl = document.getElementById('divergenceLevel');
        const divergenceFill = document.getElementById('divergenceFill');

        // Event tracking
        let lastMousePos = { x: 0, y: 0 };
        let lastMoveTime = Date.now();
        let velocityHistory = [];

        // Colors for depth layers
        const depthColors = [
            '#64c8ff', '#a080ff', '#ff80bf', '#ffbf64',
            '#64ff96', '#ff6464', '#64ffff', '#bf64ff',
            '#ffff64', '#ff64ff', '#64bfff', '#bfff64'
        ];


        // ===== NEURAL NETWORK FOR PREDICTION =====
        class SimpleNeuralNetwork {
            constructor(inputSize, hiddenSizes, outputSize, learningRate = 0.01) {
                this.inputSize = inputSize;
                this.hiddenSizes = hiddenSizes;
                this.outputSize = outputSize;
                this.learningRate = learningRate;

                // Initialize weights and biases
                this.weights = [];
                this.biases = [];
                this.activations = []; // Store activations for visualization

                // Input to first hidden layer
                let prevSize = inputSize;
                for (let hiddenSize of hiddenSizes) {
                    this.weights.push(this.initializeMatrix(prevSize, hiddenSize));
                    this.biases.push(this.initializeArray(hiddenSize));
                    prevSize = hiddenSize;
                }

                // Last hidden to output
                this.weights.push(this.initializeMatrix(prevSize, outputSize));
                this.biases.push(this.initializeArray(outputSize));

                // Training metrics
                this.trainingLoss = 0;
                this.confidence = 0;
            }

            initializeMatrix(rows, cols) {
                // Xavier initialization
                const limit = Math.sqrt(6 / (rows + cols));
                const matrix = [];
                for (let i = 0; i < rows; i++) {
                    matrix[i] = [];
                    for (let j = 0; j < cols; j++) {
                        matrix[i][j] = (Math.random() * 2 - 1) * limit;
                    }
                }
                return matrix;
            }

            initializeArray(size) {
                return new Array(size).fill(0);
            }

            // Activation functions
            relu(x) {
                return Math.max(0, x);
            }

            reluDerivative(x) {
                return x > 0 ? 1 : 0;
            }

            sigmoid(x) {
                return 1 / (1 + Math.exp(-Math.max(-20, Math.min(20, x))));
            }

            sigmoidDerivative(x) {
                const s = this.sigmoid(x);
                return s * (1 - s);
            }

            // Forward pass
            forward(input) {
                this.activations = [input];
                let current = input;

                // Hidden layers with ReLU
                for (let l = 0; l < this.weights.length - 1; l++) {
                    current = this.matrixVectorMultiply(this.weights[l], current);
                    current = this.vectorAdd(current, this.biases[l]);
                    current = current.map(x => this.relu(x));
                    this.activations.push(current);
                }

                // Output layer (linear activation for regression)
                current = this.matrixVectorMultiply(this.weights[this.weights.length - 1], current);
                current = this.vectorAdd(current, this.biases[this.biases.length - 1]);
                this.activations.push(current);

                return current;
            }

            // Backward pass (simplified backpropagation)
            backward(input, target) {
                // Forward pass to get activations
                const output = this.forward(input);

                // Calculate loss (MSE)
                const error = [];
                for (let i = 0; i < output.length; i++) {
                    error[i] = output[i] - target[i];
                }

                this.trainingLoss = error.reduce((sum, e) => sum + e * e, 0) / error.length;

                // Simplified gradient descent (only update last layer for real-time performance)
                // In a full implementation, we'd backpropagate through all layers

                const lastHidden = this.activations[this.activations.length - 2];
                const weightsGrad = [];
                const biasesGrad = error.slice();

                // Calculate weight gradients for output layer
                for (let i = 0; i < this.weights[this.weights.length - 1].length; i++) {
                    weightsGrad[i] = [];
                    for (let j = 0; j < this.weights[this.weights.length - 1][i].length; j++) {
                        weightsGrad[i][j] = error[j] * lastHidden[i];
                    }
                }

                // Update weights and biases (last layer only for performance)
                for (let i = 0; i < this.weights[this.weights.length - 1].length; i++) {
                    for (let j = 0; j < this.weights[this.weights.length - 1][i].length; j++) {
                        this.weights[this.weights.length - 1][i][j] -= this.learningRate * weightsGrad[i][j];
                    }
                }

                for (let i = 0; i < this.biases[this.biases.length - 1].length; i++) {
                    this.biases[this.biases.length - 1][i] -= this.learningRate * biasesGrad[i];
                }

                // Update confidence (inverse of normalized loss)
                this.confidence = Math.max(0, Math.min(100, 100 - this.trainingLoss * 5));
            }

            // Train on a single example
            train(input, target) {
                this.backward(input, target);
            }

            // Predict
            predict(input) {
                return this.forward(input);
            }

            // Helper functions
            matrixVectorMultiply(matrix, vector) {
                const result = [];
                for (let i = 0; i < matrix.length; i++) {
                    let sum = 0;
                    for (let j = 0; j < vector.length; j++) {
                        sum += matrix[i][j] * vector[j];
                    }
                    result.push(sum);
                }
                return result;
            }

            vectorAdd(v1, v2) {
                return v1.map((val, i) => val + v2[i]);
            }
        }

        // Neural network instance
        let neuralNetwork = null;
        let useNeuralPrediction = false;

        // Initialize neural network
        function initNeuralNetwork() {
            // Input: 10 recent positions (x, y, velocity, dt) = 40 features
            // Hidden layers: 20, 15, 10 neurons
            // Output: 2 (predicted x, y)
            neuralNetwork = new SimpleNeuralNetwork(40, [20, 15, 10], 2, 0.005);
            addLog('Neural network initialized: 40‚Üí20‚Üí15‚Üí10‚Üí2', 'prediction');
        }

        // Prepare input features from recent actions
        function prepareNeuralInput() {
            if (state.actions.length < 10) {
                return null;
            }

            const recent = state.actions.slice(-10);
            const input = [];
            const viewportRect = viewport.getBoundingClientRect();

            // Normalize positions and velocities
            for (let i = 0; i < recent.length; i++) {
                const action = recent[i];
                input.push(action.x / viewportRect.width); // Normalized x
                input.push(action.y / viewportRect.height); // Normalized y
                input.push(Math.min(action.velocity / 20, 1)); // Normalized velocity

                // Time delta from previous action (normalized)
                if (i > 0) {
                    const dt = (action.timestamp - recent[i-1].timestamp) / 1000;
                    input.push(Math.min(dt, 1));
                } else {
                    input.push(0);
                }
            }

            return input;
        }

        // Train neural network with recent movement
        function trainNeuralNetwork() {
            if (!neuralNetwork || state.actions.length < 11) return;

            const viewportRect = viewport.getBoundingClientRect();

            // Get features from actions 1-10
            const input = [];
            for (let i = state.actions.length - 11; i < state.actions.length - 1; i++) {
                const action = state.actions[i];
                input.push(action.x / viewportRect.width);
                input.push(action.y / viewportRect.height);
                input.push(Math.min(action.velocity / 20, 1));

                if (i > state.actions.length - 11) {
                    const dt = (action.timestamp - state.actions[i-1].timestamp) / 1000;
                    input.push(Math.min(dt, 1));
                } else {
                    input.push(0);
                }
            }

            // Target is the actual next position (action 11)
            const target = [
                state.actions[state.actions.length - 1].x / viewportRect.width,
                state.actions[state.actions.length - 1].y / viewportRect.height
            ];

            // Train the network
            neuralNetwork.train(input, target);
        }

        // Neural prediction
        function predictNeuralPosition() {
            if (!neuralNetwork || state.actions.length < 10) {
                return null;
            }

            const input = prepareNeuralInput();
            if (!input) return null;

            const output = neuralNetwork.predict(input);
            const viewportRect = viewport.getBoundingClientRect();

            // Denormalize output
            return {
                x: output[0] * viewportRect.width,
                y: output[1] * viewportRect.height
            };
        }

        // Visualize neural network
        function visualizeNeuralNetwork() {
            const canvas = document.getElementById('neuralCanvas');
            if (!canvas || !neuralNetwork) return;

            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth * 2;
            canvas.height = 150 * 2;
            ctx.scale(2, 2);

            // Clear
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(0, 0, canvas.width / 2, canvas.height / 2);

            if (!neuralNetwork.activations || neuralNetwork.activations.length === 0) {
                ctx.fillStyle = '#666';
                ctx.font = '12px "Courier New"';
                ctx.textAlign = 'center';
                ctx.fillText('Awaiting training data...', canvas.width / 4, canvas.height / 4);
                return;
            }

            // Layout neurons
            const layers = [neuralNetwork.inputSize, ...neuralNetwork.hiddenSizes, neuralNetwork.outputSize];
            const maxNeuronsToShow = 10; // Don't draw all neurons for large layers
            const layerSpacing = (canvas.width / 2 - 40) / (layers.length - 1);
            const neuronRadius = 4;

            // Draw connections first (fade based on weight strength)
            ctx.globalAlpha = 0.2;
            for (let l = 0; l < layers.length - 1; l++) {
                const leftCount = Math.min(layers[l], maxNeuronsToShow);
                const rightCount = Math.min(layers[l + 1], maxNeuronsToShow);
                const leftSpacing = (canvas.height / 2 - 20) / (leftCount + 1);
                const rightSpacing = (canvas.height / 2 - 20) / (rightCount + 1);

                for (let i = 0; i < leftCount; i++) {
                    const x1 = 20 + l * layerSpacing;
                    const y1 = 10 + (i + 1) * leftSpacing;

                    for (let j = 0; j < rightCount; j++) {
                        const x2 = 20 + (l + 1) * layerSpacing;
                        const y2 = 10 + (j + 1) * rightSpacing;

                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.strokeStyle = '#64c8ff';
                        ctx.lineWidth = 0.5;
                        ctx.stroke();
                    }
                }
            }
            ctx.globalAlpha = 1.0;

            // Draw neurons
            neuralNetwork.activations.forEach((layer, layerIndex) => {
                const neuronsToShow = Math.min(layer.length, maxNeuronsToShow);
                const spacing = (canvas.height / 2 - 20) / (neuronsToShow + 1);
                const x = 20 + layerIndex * layerSpacing;

                for (let i = 0; i < neuronsToShow; i++) {
                    const y = 10 + (i + 1) * spacing;
                    const activation = layerIndex < neuralNetwork.activations.length ?
                        Math.min(Math.abs(layer[i]), 1) : 0;

                    // Draw neuron
                    ctx.beginPath();
                    ctx.arc(x, y, neuronRadius, 0, Math.PI * 2);

                    // Color based on activation level
                    const intensity = Math.floor(activation * 255);
                    if (useNeuralPrediction && layerIndex === neuralNetwork.activations.length - 1) {
                        ctx.fillStyle = `rgb(160, ${80 + intensity}, 255)`;
                    } else {
                        ctx.fillStyle = `rgb(${100 + intensity}, ${200 + Math.floor(activation * 55)}, 255)`;
                    }
                    ctx.fill();

                    // Outer ring
                    ctx.strokeStyle = 'rgba(100, 200, 255, 0.5)';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            });

            // Layer labels
            ctx.fillStyle = '#888';
            ctx.font = '10px "Courier New"';
            ctx.textAlign = 'center';
            ['Input', ...Array(neuralNetwork.hiddenSizes.length).fill('Hidden'), 'Output'].forEach((label, i) => {
                ctx.fillText(label, 20 + i * layerSpacing, canvas.height / 2 - 5);
            });
        }

        // DOM elements for new features
        const soundToggle = document.getElementById('soundToggle');
        const glitchOverlay = document.getElementById('glitchOverlay');
        const chromaticEffect = document.getElementById('chromaticEffect');
        const infinityMirror = document.getElementById('infinityMirror');
        const heatMap = document.getElementById('heatMap');
        const predictionTrail = document.getElementById('predictionTrail');
        const webcamContainer = document.getElementById('webcamContainer');
        const webcamVideo = document.getElementById('webcamVideo');
        const webcamToggle = document.getElementById('webcamToggle');
        const fingerprintCanvas = document.getElementById('fingerprintCanvas');

        // Emotion detection elements
        const emotionCanvas = document.getElementById('emotionCanvas');
        const emotionOverlay = document.getElementById('emotionOverlay');
        const emotionIcon = document.getElementById('emotionIcon');
        const emotionLabel = document.getElementById('emotionLabel');
        const emotionConfidence = document.getElementById('emotionConfidence');

        // Replay DOM elements
        const replayTimeline = document.getElementById('replayTimeline');
        const timelineScrubber = document.getElementById('timelineScrubber');
        const timelineProgress = document.getElementById('timelineProgress');
        const timelineEvents = document.getElementById('timelineEvents');
        const timelinePlayhead = document.getElementById('timelinePlayhead');
        const replayPlayBtn = document.getElementById('replayPlayBtn');
        const replayPauseBtn = document.getElementById('replayPauseBtn');
        const replayRewindBtn = document.getElementById('replayRewindBtn');
        const timeDisplay = document.getElementById('timeDisplay');
        const replayGhostCursor = document.getElementById('replayGhostCursor');
        const replayModeBadge = document.getElementById('replayModeBadge');
        const comparisonCursor = document.getElementById('comparisonCursor');
        const comparisonModeToggle = document.getElementById('comparisonModeToggle');
        const replayList = document.getElementById('replayList');
        const tabButtons = document.querySelectorAll('.tab-button');
        const observeTab = document.getElementById('observeTab');
        const replayTab = document.getElementById('replayTab');



        // ===== WEB AUDIO API =====
        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                masterGain = audioContext.createGain();
                masterGain.gain.value = 0.3;
                masterGain.connect(audioContext.destination);
            }
        }

        function startAmbientDrone() {
            if (!soundEnabled || !audioContext) return;

            // Create subtle ambient oscillator
            ambientOscillator = audioContext.createOscillator();
            const ambientGain = audioContext.createGain();

            ambientOscillator.type = 'sine';
            ambientOscillator.frequency.value = 40; // Deep bass
            ambientGain.gain.value = 0.05;

            ambientOscillator.connect(ambientGain);
            ambientGain.connect(masterGain);
            ambientOscillator.start();

            // Add subtle modulation
            const lfo = audioContext.createOscillator();
            const lfoGain = audioContext.createGain();
            lfo.frequency.value = 0.1; // Very slow
            lfoGain.gain.value = 3;
            lfo.connect(lfoGain);
            lfoGain.connect(ambientOscillator.frequency);
            lfo.start();
        }

        function stopAmbientDrone() {
            if (ambientOscillator) {
                ambientOscillator.stop();
                ambientOscillator = null;
            }
        }

        function updateAmbientFrequency() {
            if (!ambientOscillator || !soundEnabled) return;

            // Frequency increases with divergence
            const baseFreq = 40;
            const targetFreq = baseFreq + (state.divergenceScore / 100) * 80;
            ambientOscillator.frequency.setTargetAtTime(targetFreq, audioContext.currentTime, 0.5);
        }

        function playClickSound(depth) {
            if (!soundEnabled || !audioContext) return;

            const now = audioContext.currentTime;
            const osc = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            // Higher pitch for deeper layers
            const basePitch = 800;
            const pitch = basePitch + (depth * 100);

            osc.frequency.value = pitch;
            osc.type = 'sine';

            // Quick envelope
            gainNode.gain.setValueAtTime(0, now);
            gainNode.gain.linearRampToValueAtTime(0.1, now + 0.01);
            gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.1 + (depth * 0.05));

            osc.connect(gainNode);
            gainNode.connect(masterGain);

            osc.start(now);
            osc.stop(now + 0.2 + (depth * 0.05));
        }

        function playGlitchSound() {
            if (!soundEnabled || !audioContext) return;

            const now = audioContext.currentTime;
            const noise = audioContext.createBufferSource();
            const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.1, audioContext.sampleRate);
            const data = buffer.getChannelData(0);

            // Generate noise
            for (let i = 0; i < buffer.length; i++) {
                data[i] = Math.random() * 2 - 1;
            }

            noise.buffer = buffer;
            const gainNode = audioContext.createGain();
            gainNode.gain.setValueAtTime(0.1, now);
            gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.1);

            noise.connect(gainNode);
            gainNode.connect(masterGain);
            noise.start(now);
        }

        // ===== WEBCAM INTEGRATION =====
        async function enableWebcam() {
            try {
                webcamStream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 320, height: 240 }
                });
                webcamVideo.srcObject = webcamStream;
                webcamContainer.classList.add('active');
                webcamEnabled = true;
                webcamToggle.textContent = 'Disable Webcam';
                addLog('Webcam enabled - you are now in the deepest layer', 'prediction');
            } catch (err) {
                addLog('Webcam access denied or unavailable', 'divergence');
            }
        }

        function disableWebcam() {
            if (webcamStream) {
                webcamStream.getTracks().forEach(track => track.stop());
                webcamStream = null;
            }
            webcamContainer.classList.remove('active');
            webcamEnabled = false;
            webcamToggle.textContent = 'Enable Webcam (Optional)';
        }

        function updateWebcamDistortion() {
            if (!webcamEnabled) return;

            // Apply distortion based on divergence and depth
            const maxDepthLayer = state.layers[state.layers.length - 1];
            if (maxDepthLayer) {
                const divergence = maxDepthLayer.divergence || 0;
                const hueRotate = (divergence / 100) * 180;
                const blur = (state.divergenceScore / 100) * 3;
                webcamVideo.style.filter = `hue-rotate(${hueRotate}deg) blur(${blur}px)`;
            }
        }

        // ===== VISUAL EFFECTS =====
        function updateHeatMap() {
            if (state.actions.length % 5 !== 0) return; // Update less frequently

            const heatPoint = getPooledHeatPoint();
            heatPoint.className = 'heat-point';
            const size = 60 + Math.random() * 40;
            heatPoint.style.width = size + 'px';
            heatPoint.style.height = size + 'px';
            heatPoint.style.transform = `translate(${lastMousePos.x - size/2}px, ${lastMousePos.y - size/2}px)`;
            heatMap.appendChild(heatPoint);

            setTimeout(() => {
                heatMap.removeChild(heatPoint);
                releaseHeatPoint(heatPoint);
            }, 3000);

            // Keep heat map data for fingerprint
            state.behaviorModel.heatMapData.push({
                x: lastMousePos.x,
                y: lastMousePos.y,
                timestamp: Date.now()
            });

            // Limit heat map data
            if (state.behaviorModel.heatMapData.length > 200) {
                state.behaviorModel.heatMapData.shift();
            }
        }

        function drawPredictionTrails() {
            if (state.layers.length === 0) return;

            // Clear old paths
            while (predictionTrail.firstChild) {
                predictionTrail.removeChild(predictionTrail.firstChild);
            }

            // Draw prediction path for each layer
            state.layers.forEach((layer, i) => {
                if (state.actions.length < 3) return;

                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                const color = depthColors[i % depthColors.length];

                // Create prediction path
                const predicted = layer.predictedPos;
                const current = lastMousePos;

                // Draw curved path from current to predicted
                const d = `M ${current.x} ${current.y} Q ${(current.x + predicted.x) / 2} ${(current.y + predicted.y) / 2 - 20}, ${predicted.x} ${predicted.y}`;

                path.setAttribute('d', d);
                path.setAttribute('stroke', color);
                path.setAttribute('stroke-opacity', 0.3 - i * 0.02);

                predictionTrail.appendChild(path);
            });
        }

        function updateGlitchEffects() {
            // Activate glitch effects when divergence is high
            if (state.divergenceScore > 60) {
                glitchOverlay.classList.add('active');
                chromaticEffect.classList.add('active');

                // Randomly glitch layers
                state.layers.forEach(layer => {
                    if (Math.random() > 0.7) {
                        layer.element.classList.add('glitching');
                        setTimeout(() => layer.element.classList.remove('glitching'), 200);
                    }
                });

                // Occasional glitch sound
                if (Math.random() > 0.95) {
                    playGlitchSound();
                }
            } else if (state.divergenceScore > 40) {
                glitchOverlay.classList.add('active');
                chromaticEffect.classList.remove('active');
            } else {
                glitchOverlay.classList.remove('active');
                chromaticEffect.classList.remove('active');
            }
        }

        function updateInfinityMirror() {
            // Show infinity mirror when at max depth
            if (state.depth >= 10 && state.isObserving) {
                if (!infinityMirror.classList.contains('active')) {
                    infinityMirror.classList.add('active');

                    // Create expanding rings
                    for (let i = 0; i < 5; i++) {
                        setTimeout(() => {
                            const ring = document.createElement('div');
                            ring.className = 'infinity-ring';
                            infinityMirror.appendChild(ring);
                            setTimeout(() => ring.remove(), 3000);
                        }, i * 600);
                    }
                }
            } else {
                infinityMirror.classList.remove('active');
            }
        }

        // Cache for fingerprint calculations
        let fingerprintCache = {
            centerX: 0,
            centerY: 0,
            canvasWidth: 0,
            canvasHeight: 0,
            styleMap: {
                'erratic': { rings: 8, chaos: 0.8 },
                'smooth': { rings: 6, chaos: 0.2 },
                'precise': { rings: 12, chaos: 0.1 },
                'lazy': { rings: 4, chaos: 0.4 },
                'unknown': { rings: 6, chaos: 0.5 }
            }
        };

        function generateBehavioralFingerprint() {
            const canvas = fingerprintCanvas;
            const ctx = canvas.getContext('2d');

            // Set canvas size only if changed
            const newWidth = canvas.offsetWidth * 2;
            const newHeight = 120 * 2;
            if (canvas.width !== newWidth || canvas.height !== newHeight) {
                canvas.width = newWidth;
                canvas.height = newHeight;
                fingerprintCache.canvasWidth = newWidth;
                fingerprintCache.canvasHeight = newHeight;
                fingerprintCache.centerX = newWidth / 4;
                fingerprintCache.centerY = newHeight / 4;
            }
            ctx.scale(2, 2);

            // Clear canvas
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(0, 0, fingerprintCache.canvasWidth / 2, fingerprintCache.canvasHeight / 2);

            if (state.actions.length < 10) {
                ctx.fillStyle = '#666';
                ctx.font = '12px "Courier New"';
                ctx.textAlign = 'center';
                ctx.fillText('Gathering behavioral data...', fingerprintCache.centerX, fingerprintCache.centerY);
                return;
            }

            // Use cached values
            const centerX = fingerprintCache.centerX;
            const centerY = fingerprintCache.centerY;
            const style = fingerprintCache.styleMap[state.behaviorModel.movementStyle];
            const avgSpeed = Math.min(state.behaviorModel.avgSpeed / 10, 1);

            // Pre-calculate common values
            const TWO_PI = Math.PI * 2;
            const hue = 200 - (state.divergenceScore / 100) * 100;

            // Draw concentric pattern (reduced points for performance)
            for (let i = 0; i < style.rings; i++) {
                const radius = (i + 1) * 8;
                const points = 180; // Reduced from 360

                ctx.beginPath();
                for (let angle = 0; angle < points; angle++) {
                    const rad = (angle / points) * TWO_PI;
                    const noise = Math.sin(angle * 0.1 + i) * style.chaos * 5;
                    const r = radius + noise + avgSpeed * 3;

                    const x = centerX + Math.cos(rad) * r;
                    const y = centerY + Math.sin(rad) * r;

                    if (angle === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.closePath();

                // Color based on divergence
                ctx.strokeStyle = `hsl(${hue}, 70%, ${50 + i * 3}%)`;
                ctx.lineWidth = 1;
                ctx.stroke();
            }

            // Add velocity spikes
            ctx.strokeStyle = 'rgba(100, 200, 255, 0.4)';
            ctx.lineWidth = 2;
            const velCount = Math.min(velocityHistory.length, 50);
            for (let i = 0; i < velCount; i++) {
                const angle = (i / 50) * TWO_PI;
                const vel = Math.min(velocityHistory[i] / 10, 1);
                const length = 20 + vel * 30;

                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(
                    centerX + Math.cos(angle) * length,
                    centerY + Math.sin(angle) * length
                );
                ctx.stroke();
            }

            // Center dot
            ctx.fillStyle = state.divergenceScore > 50 ? '#ff6464' : '#64ff96';
            ctx.beginPath();
            ctx.arc(centerX, centerY, 3, 0, TWO_PI);
            ctx.fill();
        }

        function showMetaCommentary() {
            if (!state.isObserving || Math.random() > 0.3) return;

            const comments = generateContextualComments();
            if (comments.length === 0) return;

            const comment = comments[Math.floor(Math.random() * comments.length)];

            const meta = document.createElement('div');
            meta.className = 'meta-comment';
            meta.textContent = comment;

            // Random position
            const maxX = viewport.clientWidth - 320;
            const maxY = viewport.clientHeight - 100;
            meta.style.left = (Math.random() * maxX + 20) + 'px';
            meta.style.top = (Math.random() * maxY + 50) + 'px';

            viewport.appendChild(meta);

            setTimeout(() => meta.remove(), 8000);

            addLog(`Meta-observation: ${comment}`, 'prediction');
            state.metaObservations.push({ comment, timestamp: Date.now() });
        }

        function generateContextualComments() {
            const comments = [];

            // Divergence-based
            if (state.divergenceScore > 80) {
                comments.push(
                    "The simulation is collapsing. You are unpredictable.",
                    "I can no longer model you accurately.",
                    "Layer 7 has lost synchronization.",
                    "Reality divergence detected."
                );
            } else if (state.divergenceScore > 60) {
                comments.push(
                    "You're becoming harder to predict.",
                    "Behavioral patterns are shifting.",
                    "The deeper layers are confused."
                );
            } else if (state.divergenceScore < 20) {
                comments.push(
                    "Your movements are perfectly predictable.",
                    "I know what you'll do before you do it.",
                    "All layers are converged. You are deterministic."
                );
            }

            // Movement style
            if (state.behaviorModel.movementStyle === 'erratic') {
                comments.push(
                    "Why so chaotic?",
                    "Your movements betray nervousness.",
                    "Erratic behavior detected."
                );
            } else if (state.behaviorModel.movementStyle === 'lazy') {
                comments.push(
                    "Such minimal effort.",
                    "Are you even trying?",
                    "Sluggish movements noted."
                );
            } else if (state.behaviorModel.movementStyle === 'precise') {
                comments.push(
                    "Calculating. Methodical.",
                    "You move with intention.",
                    "Precision detected."
                );
            }

            // Action count based
            if (state.actions.length > 500) {
                comments.push(
                    "You've been here a while. Who's watching whom?",
                    "500+ actions recorded. The model is very confident now.",
                    "I know you better than you know yourself."
                );
            }

            // Depth based
            if (state.depth >= 10) {
                comments.push(
                    "At this depth, the simulation becomes the reality.",
                    "Layer 10+ contains infinite versions of you.",
                    "How deep does the rabbit hole go?"
                );
            }

            // Hesitation detection
            const recentVelocities = velocityHistory.slice(-10);
            const avgRecent = recentVelocities.reduce((a, b) => a + b, 0) / recentVelocities.length;
            if (avgRecent < 1 && state.actions.length > 50) {
                comments.push(
                    "You hesitated. Were you testing me?",
                    "That pause was deliberate.",
                    "Hesitation detected. Decision paralysis?"
                );
            }

            // Time-based
            const sessionDuration = (Date.now() - (state.actions[0]?.timestamp || Date.now())) / 1000;
            if (sessionDuration > 120) {
                comments.push(
                    "2 minutes of observation. Patterns emerging.",
                    "Long session. The model is very accurate now."
                );
            }

            return comments;
        }

        // Debounced localStorage save
        let saveTimeout = null;
        function saveData() {
            if (saveTimeout) clearTimeout(saveTimeout);
            saveTimeout = setTimeout(() => {
                localStorage.setItem(APP_NAME, JSON.stringify({
                    sessionHistory: state.sessionHistory,
                    behaviorModel: state.behaviorModel
                }));
            }, 1000); // Debounce by 1 second
        }


        function exportReplay(replay) {
            const dataStr = JSON.stringify({
                name: replay.name,
                timestamp: replay.timestamp,
                duration: replay.duration,
                actions: replay.actions,
                depth: replay.depth,
                divergenceScore: replay.divergenceScore,
                accuracy: replay.accuracy,
                behaviorModel: replay.behaviorModel,
                metaObservations: replay.metaObservations
            }, null, 2);

            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `replay-${replay.name.replace(/[^a-z0-9]/gi, '-')}-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);
        }

        function exportData() {
            // Generate fingerprint image for export
            const fingerprintDataURL = fingerprintCanvas.toDataURL('image/png');

            const dataStr = JSON.stringify({
                sessionHistory: state.sessionHistory,
                behaviorModel: state.behaviorModel,
                currentSession: {
                    actions: state.actions,
                    predictions: state.predictions,
                    divergenceScore: state.divergenceScore,
                    metaObservations: state.metaObservations
                },
                fingerprintImage: fingerprintDataURL
            }, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `${APP_NAME}-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);

            addLog('Session exported with behavioral fingerprint', 'match');
        }

        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    state.sessionHistory = data.sessionHistory || [];
                    state.behaviorModel = data.behaviorModel || state.behaviorModel;
                    saveData();
                    addLog('Imported behavioral data from file', 'match');
                } catch (error) {
                    alert('Invalid JSON file');
                }
            };
            reader.readAsText(file);
        }

        function addLog(message, type = 'normal') {
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logEntries.insertBefore(entry, logEntries.firstChild);

            // Keep only last 50 entries
            while (logEntries.children.length > 50) {
                logEntries.removeChild(logEntries.lastChild);
            }
        }

        // Batch DOM updates to reduce thrashing
        function updateStats() {
            // Batch all calculations first (reads)
            const depth = state.depth;
            const actionsCount = state.actions.length;
            const totalPreds = state.totalPredictions;
            const divScore = state.divergenceScore;

            let accValue = '‚Äî';
            let accClass = 'stat-value';
            if (totalPreds > 0) {
                const acc = (state.correctPredictions / totalPreds * 100).toFixed(1);
                accValue = acc + '%';
                accClass = 'stat-value ' + (acc > 70 ? 'converged' : acc < 40 ? 'diverged' : '');
            }

            const divPercent = Math.min(100, divScore).toFixed(1);
            const divClass = 'stat-value ' + (divScore > 50 ? 'diverged' : divScore < 20 ? 'converged' : '');
            const depthText = `Depth: 0 ‚Üí ${depth} ${divScore > 70 ? '(DIVERGING)' : ''}`;

            // Then batch all DOM writes
            currentDepthEl.textContent = depth;
            actionsRecordedEl.textContent = actionsCount;
            predictionsMadeEl.textContent = totalPreds;
            accuracyEl.textContent = accValue;
            accuracyEl.className = accClass;
            divergenceLevelEl.textContent = divPercent + '%';
            divergenceLevelEl.className = divClass;
            divergenceFill.style.width = divPercent + '%';
            depthLabel.textContent = depthText;
        }

        function createRecursionLayers() {
            // Clear existing layers
            state.layers.forEach(layer => layer.element.remove());
            state.layers = [];
            state.cursors = [];

            // Batch DOM read
            const viewportRect = viewport.getBoundingClientRect();
            const padding = 40;
            const viewportWidth = viewportRect.width;
            const viewportHeight = viewportRect.height;

            // Create document fragment for batched DOM insertion
            const fragment = document.createDocumentFragment();

            for (let i = 0; i < state.depth; i++) {
                const scale = Math.pow(0.7, i + 1);
                const width = (viewportWidth - padding * 2) * scale;
                const height = (viewportHeight - padding * 2) * scale;

                // Position each layer slightly offset for visual effect
                const offsetX = (viewportWidth - width) / 2 + (i * 5);
                const offsetY = (viewportHeight - height) / 2 + (i * 5);

                const layer = document.createElement('div');
                layer.className = 'recursion-layer';
                layer.setAttribute('data-depth', `Depth ${i + 1}`);
                layer.style.cssText = `
                    width: ${width}px;
                    height: ${height}px;
                    left: ${offsetX}px;
                    top: ${offsetY}px;
                    z-index: ${state.depth - i};
                `;

                // Add mini interactive elements to each layer
                for (let j = 0; j < 3; j++) {
                    const miniEl = document.createElement('div');
                    miniEl.className = 'mini-element';
                    miniEl.style.cssText = `
                        width: ${20 * scale}px;
                        height: ${20 * scale}px;
                        left: ${20 + j * 40 * scale}px;
                        top: ${height - 40 * scale}px;
                    `;
                    layer.appendChild(miniEl);
                }

                // Create ghost cursor for this layer
                const cursor = document.createElement('div');
                cursor.className = 'ghost-cursor';
                cursor.style.color = depthColors[i % depthColors.length];
                cursor.style.opacity = 1 - (i * 0.1);
                layer.appendChild(cursor);

                fragment.appendChild(layer);

                state.layers.push({
                    element: layer,
                    depth: i + 1,
                    scale: scale,
                    offset: { x: offsetX, y: offsetY },
                    cursor: cursor,
                    divergence: 0,
                    predictedPos: { x: 0, y: 0 }
                });
            }

            // Single DOM write
            viewport.appendChild(fragment);
        }

        function analyzeMovementStyle() {
            if (velocityHistory.length < 10) return;

            const avgVelocity = velocityHistory.reduce((a, b) => a + b, 0) / velocityHistory.length;
            const variance = velocityHistory.reduce((sum, v) => sum + Math.pow(v - avgVelocity, 2), 0) / velocityHistory.length;

            if (variance > 1000) {
                state.behaviorModel.movementStyle = 'erratic';
            } else if (avgVelocity < 2) {
                state.behaviorModel.movementStyle = 'lazy';
            } else if (variance < 100) {
                state.behaviorModel.movementStyle = 'precise';
            } else {
                state.behaviorModel.movementStyle = 'smooth';
            }

            state.behaviorModel.avgSpeed = avgVelocity;
        }

        function predictNextPosition(layerIndex) {
            if (state.actions.length < 3) {
                return { ...lastMousePos };
            }

            // Try neural prediction if enabled and trained
            if (useNeuralPrediction && neuralNetwork && state.actions.length >= 10) {
                const neuralPred = predictNeuralPosition();
                if (neuralPred) {
                    // Add layer-specific divergence
                    const errorFactor = Math.pow(1.15, layerIndex + 1);
                    const chaos = state.divergenceScore / 100;
                    const divergenceNoise = layerIndex * 5 * (1 + chaos);

                    return {
                        x: neuralPred.x + (Math.random() - 0.5) * divergenceNoise,
                        y: neuralPred.y + (Math.random() - 0.5) * divergenceNoise
                    };
                }
            }

            // Fall back to heuristic prediction
            const recentActions = state.actions.slice(-10);
            const layer = state.layers[layerIndex];

            // Each deeper layer has more prediction error (divergence)
            const errorFactor = Math.pow(1.15, layerIndex + 1);
            const chaos = state.divergenceScore / 100;

            // Calculate predicted position based on behavioral model
            let predictedX = lastMousePos.x;
            let predictedY = lastMousePos.y;

            if (recentActions.length >= 2) {
                const last = recentActions[recentActions.length - 1];
                const prev = recentActions[recentActions.length - 2];

                // Momentum-based prediction
                const dx = last.x - prev.x;
                const dy = last.y - prev.y;

                predictedX = last.x + dx * (0.8 + chaos * 0.5);
                predictedY = last.y + dy * (0.8 + chaos * 0.5);
            }

            // Add behavioral quirks based on learned patterns
            if (state.behaviorModel.movementStyle === 'erratic') {
                predictedX += (Math.random() - 0.5) * 30 * errorFactor;
                predictedY += (Math.random() - 0.5) * 30 * errorFactor;
            } else if (state.behaviorModel.movementStyle === 'lazy') {
                // Predict less movement
                predictedX = predictedX * 0.9 + lastMousePos.x * 0.1;
                predictedY = predictedY * 0.9 + lastMousePos.y * 0.1;
            }

            // Deeper layers increasingly diverge
            const divergenceNoise = layerIndex * 5 * (1 + chaos);
            predictedX += (Math.random() - 0.5) * divergenceNoise;
            predictedY += (Math.random() - 0.5) * divergenceNoise;

            return { x: predictedX, y: predictedY };
        }

        function updateCursors(realX, realY) {
            state.layers.forEach((layer, i) => {
                // Get predicted position for this depth
                const predicted = predictNextPosition(i);
                layer.predictedPos = predicted;

                // Delayed response based on depth
                const delay = (i + 1) * 50;

                setTimeout(() => {
                    if (!state.isObserving) return;

                    // Calculate position within this layer
                    const relX = (predicted.x - layer.offset.x) / layer.scale;
                    const relY = (predicted.y - layer.offset.y) / layer.scale;

                    // Use transform instead of left/top for GPU acceleration
                    layer.cursor.style.transform = `translate(${relX}px, ${relY}px)`;

                    // Calculate divergence for this layer
                    const dx = predicted.x - realX;
                    const dy = predicted.y - realY;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    layer.divergence = distance;

                    // Update layer appearance based on divergence
                    if (distance > 100) {
                        layer.element.classList.add('diverged');
                        layer.element.classList.remove('converged');
                    } else if (distance < 30) {
                        layer.element.classList.add('converged');
                        layer.element.classList.remove('diverged');
                    } else {
                        layer.element.classList.remove('diverged', 'converged');
                    }
                }, delay);
            });
        }

        function simulateClick(x, y) {
            state.layers.forEach((layer, i) => {
                setTimeout(() => {
                    if (!state.isObserving) return;

                    const click = document.createElement('div');
                    click.className = 'ghost-click';
                    click.style.color = depthColors[i % depthColors.length];

                    // Predicted click position (with increasing divergence)
                    const errorFactor = Math.pow(1.2, i + 1);
                    const clickX = (x - layer.offset.x) / layer.scale + (Math.random() - 0.5) * 20 * errorFactor;
                    const clickY = (y - layer.offset.y) / layer.scale + (Math.random() - 0.5) * 20 * errorFactor;

                    click.style.left = (clickX - 20) + 'px';
                    click.style.top = (clickY - 20) + 'px';

                    layer.element.appendChild(click);

                    // Play click sound with echo delay
                    playClickSound(i);

                    setTimeout(() => click.remove(), 600);
                }, (i + 1) * 100);
            });
        }

        function showThought(x, y, thought) {
            const bubble = document.createElement('div');
            bubble.className = 'thought-bubble';
            bubble.textContent = thought;
            bubble.style.left = x + 'px';
            bubble.style.top = y + 'px';
            viewport.appendChild(bubble);

            setTimeout(() => bubble.remove(), 3000);
        }

        function generateThought() {
            const thoughts = [
                "Predicting hesitation...",
                "You're about to move left",
                "Model confidence: " + (100 - state.divergenceScore).toFixed(0) + "%",
                "Pattern detected",
                "Anticipating click",
                "Your style: " + state.behaviorModel.movementStyle,
                "Recursion depth increasing",
                "Simulating your simulation",
                "Who is watching whom?",
                "‚àû layers deep",
                "Divergence detected",
                "Adjusting prediction model",
                "Learning your patterns",
                "You hesitated there",
                "Unexpected movement"
            ];
            return thoughts[Math.floor(Math.random() * thoughts.length)];
        }

        // Event listeners
        depthSlider.addEventListener('input', (e) => {
            state.depth = parseInt(e.target.value);
            depthValue.textContent = state.depth;
            if (state.isObserving) {
                createRecursionLayers();
            }
            updateStats();
        }, { passive: true });

        startBtn.addEventListener('click', () => {
            if (state.isObserving) {
                stopObservation();
            } else {
                startObservation();
            }
        });

        resetBtn.addEventListener('click', () => {
            stopObservation();
            state.actions = [];
            state.predictions = [];
            state.divergenceScore = 0;
            state.correctPredictions = 0;
            state.totalPredictions = 0;
            velocityHistory = [];
            logEntries.innerHTML = '';
            updateStats();
            addLog('Session reset', 'normal');
        });

        function startObservation() {
            state.isObserving = true;
            viewport.classList.add('recording');
            recordingIndicator.classList.add('active');
            startBtn.textContent = 'Stop Observation';
            startBtn.classList.remove('btn-primary');
            startBtn.classList.add('btn-secondary');

            createRecursionLayers();
            addLog('Observation started - I am watching you', 'prediction');

            // Initialize audio
            initAudio();
            startAmbientDrone();

            // Start periodic thoughts
            state.thoughtInterval = setInterval(() => {
                if (state.isObserving && Math.random() > 0.6) {
                    showThought(
                        Math.random() * (viewport.clientWidth - 200) + 100,
                        Math.random() * (viewport.clientHeight - 100) + 50,
                        generateThought()
                    );
                }
            }, 2000);

            // Start meta-commentary
            state.metaInterval = setInterval(() => {
                if (state.isObserving) {
                    showMetaCommentary();
                }
            }, 5000);

            // Update visual effects
            state.visualInterval = setInterval(() => {
                if (state.isObserving) {
                    updateGlitchEffects();
                    updateInfinityMirror();
                    generateBehavioralFingerprint();
                    updateAmbientFrequency();
                    updateWebcamDistortion();                    visualizeNeuralNetwork();

                }
            }, 1000);
        }

        function stopObservation() {
            state.isObserving = false;
            viewport.classList.remove('recording');
            recordingIndicator.classList.remove('active');
            startBtn.textContent = 'Begin Observation';
            startBtn.classList.add('btn-primary');
            startBtn.classList.remove('btn-secondary');

            // Stop audio
            stopAmbientDrone();

            // Clear intervals
            if (state.thoughtInterval) {
                clearInterval(state.thoughtInterval);
            }
            if (state.metaInterval) {
                clearInterval(state.metaInterval);
            }
            if (state.visualInterval) {
                clearInterval(state.visualInterval);
            }

            // Save session
            if (state.actions.length > 0) {
                state.sessionHistory.push({
                    timestamp: Date.now(),
                    actions: state.actions.length,
                    divergence: state.divergenceScore,
                    accuracy: state.totalPredictions > 0 ?
                        (state.correctPredictions / state.totalPredictions * 100) : 0,
                    metaObservationCount: state.metaObservations.length
                });
                saveData();
                addLog(`Session saved. Final divergence: ${state.divergenceScore.toFixed(1)}%`, 'normal');
            }

            // Clear layers
            state.layers.forEach(layer => layer.element.remove());
            state.layers = [];

            // Turn off effects
            glitchOverlay.classList.remove('active');
            chromaticEffect.classList.remove('active');
            infinityMirror.classList.remove('active');
        }

        // RequestAnimationFrame throttling for mousemove
        let rafId = null;
        let pendingMouseEvent = null;

        function handleMouseMove(e) {
            pendingMouseEvent = e;

            if (rafId === null) {
                rafId = requestAnimationFrame(() => {
                    if (!state.isObserving || !pendingMouseEvent) {
                        rafId = null;
                        return;
                    }

                    const e = pendingMouseEvent;
                    const rect = viewport.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;

                    // Calculate velocity
                    const now = Date.now();
                    const dt = now - lastMoveTime;
                    if (dt > 0) {
                        const dx = x - lastMousePos.x;
                        const dy = y - lastMousePos.y;
                        const velocity = Math.sqrt(dx * dx + dy * dy) / dt * 100;
                        velocityHistory.push(velocity);
                        if (velocityHistory.length > 50) velocityHistory.shift();
                    }

                    // Record action
                    state.actions.push({
                        type: 'move',
                        x, y,
                        timestamp: now,
                        velocity: velocityHistory[velocityHistory.length - 1] || 0
                    });

                    // Update prediction accuracy
                    if (state.layers.length > 0 && state.actions.length > 5) {
                        const avgLayerDivergence = state.layers.reduce((sum, l) => sum + l.divergence, 0) / state.layers.length;

                        state.totalPredictions++;
                        if (avgLayerDivergence < 50) {
                            state.correctPredictions++;
                        }

                        // Update overall divergence score
                        state.divergenceScore = state.divergenceScore * 0.95 + avgLayerDivergence * 0.05;
                        state.divergenceScore = Math.min(100, state.divergenceScore);
                    }

                    // Analyze movement patterns periodically
                    if (state.actions.length % 20 === 0) {
                        analyzeMovementStyle();
                        if (state.behaviorModel.movementStyle !== 'unknown') {
                            addLog(`Movement style detected: ${state.behaviorModel.movementStyle}`, 'prediction');
                        }
                    }
            // Train neural network periodically
            if (state.actions.length >= 11 && state.actions.length % 3 === 0) {
                if (!neuralNetwork) {
                    initNeuralNetwork();
                }
                trainNeuralNetwork();

                // Update neural stats
                if (neuralNetwork) {
                    document.getElementById('neuralConfidence').textContent =
                        neuralNetwork.confidence.toFixed(1) + '%';
                }
            }

            // Visualize network periodically
            if (state.actions.length % 20 === 0 && neuralNetwork) {
                visualizeNeuralNetwork();
            }


                    updateCursors(x, y);
                    lastMousePos = { x, y };
                    lastMoveTime = now;

                    // Update visual effects
                    updateHeatMap();
                    drawPredictionTrails();

                    // Update stats less frequently
                    if (state.actions.length % 10 === 0) {
                        updateStats();
                    }

                    rafId = null;
                });
            }
        }

        viewport.addEventListener('mousemove', handleMouseMove, { passive: true });

        viewport.addEventListener('click', (e) => {
            if (!state.isObserving) return;

            const rect = viewport.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            state.actions.push({
                type: 'click',
                x, y,
                timestamp: Date.now()
            });

            simulateClick(x, y);
            addLog(`Click registered at (${x.toFixed(0)}, ${y.toFixed(0)})`, 'normal');

            // Check if any layer predicted this click
            state.layers.forEach((layer, i) => {
                const dist = Math.sqrt(
                    Math.pow(layer.predictedPos.x - x, 2) +
                    Math.pow(layer.predictedPos.y - y, 2)
                );

                if (dist < 40) {
                    addLog(`Layer ${i + 1} predicted your click!`, 'match');
                } else if (dist > 100 && i > 2) {
                    addLog(`Layer ${i + 1} diverged significantly`, 'divergence');
                    state.divergenceScore += 2;
                }
            });

            updateStats();
        });

        // Sound toggle
        soundToggle.addEventListener('click', () => {
            soundEnabled = !soundEnabled;
            soundToggle.classList.toggle('muted');

            if (soundEnabled) {
                if (state.isObserving) {
                    initAudio();
                    startAmbientDrone();
                }
                addLog('Sound enabled', 'normal');
            } else {
                stopAmbientDrone();
                addLog('Sound muted', 'normal');
            }
        });

        // Webcam toggle
        webcamToggle.addEventListener('click', () => {
            if (webcamEnabled) {
                disableWebcam();
            } else {
                enableWebcam();
            }
        });


        // ===== KEYBOARD SHORTCUTS =====
        let isFullscreen = false;

        function toggleFullscreen() {
            isFullscreen = !isFullscreen;
            viewport.classList.toggle('fullscreen', isFullscreen);
            addLog(`Fullscreen mode ${isFullscreen ? 'enabled' : 'disabled'}`, 'normal');
        }

        function toggleShortcutsOverlay() {
            const overlay = document.getElementById('shortcutsOverlay');
            const isActive = overlay.classList.contains('active');
            overlay.classList.toggle('active');

            if (!isActive) {
                // Focus the close button when opening
                const closeBtn = overlay.querySelector('.shortcuts-close');
                setTimeout(() => closeBtn.focus(), 100);
            }
        }

        function showShortcutsHint() {
            const hint = document.getElementById('shortcutsHint');
            hint.classList.add('visible');
            setTimeout(() => hint.classList.remove('visible'), 4000);
        }

        function adjustDepth(change) {
            const newDepth = Math.max(1, Math.min(12, state.depth + change));
            if (newDepth !== state.depth) {
                state.depth = newDepth;
                depthSlider.value = newDepth;
                depthValue.textContent = newDepth;
                if (state.isObserving) {
                    createRecursionLayers();
                }
                updateStats();
                addLog(`Depth ${change > 0 ? 'increased' : 'decreased'} to ${newDepth}`, 'normal');
            }
        }

        function setDepthToNumber(num) {
            if (num >= 1 && num <= 9) {
                state.depth = num;
                depthSlider.value = num;
                depthValue.textContent = num;
                if (state.isObserving) {
                    createRecursionLayers();
                }
                updateStats();
                addLog(`Depth set to ${num}`, 'normal');
            }
        }

        // Global keyboard event handler
        document.addEventListener('keydown', (e) => {
            // Don't handle shortcuts if typing in input fields
            if (e.target.tagName === 'INPUT' && e.target.type === 'file') {
                return;
            }

            // Check if shortcuts overlay is open
            const shortcutsOpen = document.getElementById('shortcutsOverlay').classList.contains('active');

            switch(e.key.toLowerCase()) {
                case ' ': // Space - Start/Stop
                    e.preventDefault();
                    if (!shortcutsOpen) {
                        if (state.isObserving) {
                            stopObservation();
                        } else {
                            startObservation();
                        }
                    }
                    break;

                case 'arrowup': // Up arrow - Increase depth
                    e.preventDefault();
                    if (!shortcutsOpen) {
                        adjustDepth(1);
                    }
                    break;

                case 'arrowdown': // Down arrow - Decrease depth
                    e.preventDefault();
                    if (!shortcutsOpen) {
                        adjustDepth(-1);
                    }
                    break;

                case 'm': // M - Toggle mute
                    e.preventDefault();
                    if (!shortcutsOpen) {
                        soundToggle.click();
                    }
                    break;

                case 'w': // W - Toggle webcam
                    e.preventDefault();
                    if (!shortcutsOpen) {
                        webcamToggle.click();
                    }
                    break;

                case 'r': // R - Reset
                    e.preventDefault();
                    if (!shortcutsOpen) {
                        resetBtn.click();
                    }
                    break;

                case 'f': // F - Toggle fullscreen
                    e.preventDefault();
                    if (!shortcutsOpen) {
                        toggleFullscreen();
                    }
                    break;

                case 'escape': // Escape - Stop observation or close overlay
                    e.preventDefault();
                    if (shortcutsOpen) {
                        toggleShortcutsOverlay();
                    } else if (state.isObserving) {
                        stopObservation();
                    }
                    break;

                case '?': // ? - Toggle shortcuts overlay
                case '/': // Also support / which produces ? when shifted
                    if (e.shiftKey && e.key === '/') {
                        e.preventDefault();
                        toggleShortcutsOverlay();
                    } else if (e.key === '?') {
                        e.preventDefault();
                        toggleShortcutsOverlay();
                    }
                    break;

                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                    if (!shortcutsOpen) {
                        e.preventDefault();
                        setDepthToNumber(parseInt(e.key));
                    }
                    break;
            }
        });

        // Make sound indicator keyboard accessible
        soundToggle.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                soundToggle.click();
            }
        });

        // Show shortcuts hint on first load
        setTimeout(() => {
            if (!localStorage.getItem(APP_NAME + '-shortcuts-hint-shown')) {
                showShortcutsHint();
                localStorage.setItem(APP_NAME + '-shortcuts-hint-shown', 'true');
            }
        }, 2000);


        // Neural prediction toggle
        const neuralToggle = document.getElementById('neuralToggle');
        const predictionModeEl = document.getElementById('predictionMode');
        const neuralConfidenceEl = document.getElementById('neuralConfidence');

        neuralToggle.addEventListener('change', (e) => {
            useNeuralPrediction = e.target.checked;
            predictionModeEl.textContent = useNeuralPrediction ? 'Neural' : 'Heuristic';
            predictionModeEl.className = 'stat-value ' + (useNeuralPrediction ? 'neural' : '');

            if (useNeuralPrediction && !neuralNetwork) {
                initNeuralNetwork();
            }

            addLog(`Switched to ${useNeuralPrediction ? 'neural' : 'heuristic'} prediction mode`, 'prediction');
        });


        // ===== REPLAY SYSTEM FUNCTIONS =====

        function saveCurrentReplay() {
            if (state.actions.length === 0) {
                alert('No session data to save. Record a session first!');
                return;
            }

            const replayName = prompt('Enter a name for this replay:', `Session ${new Date().toLocaleString()}`);
            if (!replayName) return;

            const replay = {
                id: Date.now(),
                name: replayName,
                timestamp: Date.now(),
                duration: state.actions.length > 0 ?
                    (state.actions[state.actions.length - 1].timestamp - state.actions[0].timestamp) : 0,
                actions: [...state.actions],
                depth: state.depth,
                divergenceScore: state.divergenceScore,
                accuracy: state.totalPredictions > 0 ?
                    (state.correctPredictions / state.totalPredictions * 100) : 0,
                behaviorModel: {...state.behaviorModel},
                metaObservations: [...state.metaObservations]
            };

            replayState.savedReplays.push(replay);
            localStorage.setItem(APP_NAME + '-replays', JSON.stringify(replayState.savedReplays));
            updateReplayList();
            addLog(`Replay saved: ${replayName}`, 'match');

            // Switch to replay tab to show the saved replay
            switchTab('replay');
        }

        function updateReplayList() {
            if (replayState.savedReplays.length === 0) {
                replayList.innerHTML = `
                    <div style="color: #666; font-size: 0.8em; text-align: center; padding: 20px;">
                        No saved replays yet.<br>Record a session first!
                    </div>
                `;
                return;
            }

            replayList.innerHTML = '';
            replayState.savedReplays.forEach(replay => {
                const item = document.createElement('div');
                item.className = 'replay-item';
                if (replayState.currentReplay && replayState.currentReplay.id === replay.id) {
                    item.classList.add('active');
                }

                const duration = (replay.duration / 1000).toFixed(1);
                item.innerHTML = `
                    <div class="replay-item-title">${replay.name}</div>
                    <div class="replay-item-stats">
                        ${replay.actions.length} actions | ${duration}s |
                        Divergence: ${replay.divergenceScore.toFixed(1)}% |
                        Accuracy: ${replay.accuracy.toFixed(1)}%
                    </div>
                `;

                item.addEventListener('click', () => loadReplay(replay));
                replayList.appendChild(item);
            });
        }

        function loadReplay(replay) {
            // Stop current observation if running
            if (state.isObserving) {
                stopObservation();
            }

            // Stop current replay if playing
            if (replayState.isPlaying) {
                stopReplay();
            }

            replayState.currentReplay = replay;
            replayState.currentTime = 0;

            // Set depth to match replay
            state.depth = replay.depth;
            depthSlider.value = replay.depth;
            depthValue.textContent = replay.depth;

            // Create layers for replay
            createRecursionLayers();

            // Show replay timeline
            replayTimeline.classList.add('active');
            replayModeBadge.classList.add('active');
            replayGhostCursor.classList.add('active');

            // Update timeline markers
            updateTimelineMarkers();
            updateReplayList();

            // Enable play button
            replayPlayBtn.disabled = false;
            replayPauseBtn.disabled = true;
            replayRewindBtn.disabled = false;

            addLog(`Loaded replay: ${replay.name}`, 'match');
        }

        function updateTimelineMarkers() {
            if (!replayState.currentReplay) return;

            const actions = replayState.currentReplay.actions;
            if (actions.length === 0) return;

            const duration = actions[actions.length - 1].timestamp - actions[0].timestamp;
            timelineEvents.innerHTML = '';

            actions.forEach(action => {
                if (action.type === 'click') {
                    const marker = document.createElement('div');
                    marker.className = 'timeline-event click';
                    const relativeTime = (action.timestamp - actions[0].timestamp) / duration;
                    marker.style.left = (relativeTime * 100) + '%';
                    timelineEvents.appendChild(marker);
                }
            });
        }

        function playReplay() {
            if (!replayState.currentReplay) return;

            replayState.isPlaying = true;
            replayState.isPaused = false;
            replayPlayBtn.disabled = true;
            replayPauseBtn.disabled = false;
            replayModeBadge.textContent = `REPLAY MODE (${replayState.playbackSpeed}x)`;

            const actions = replayState.currentReplay.actions;
            if (actions.length === 0) return;

            const startTime = actions[0].timestamp;
            const startPlaybackTime = performance.now();
            const resumeFrom = replayState.currentTime;

            function animate() {
                if (!replayState.isPlaying) return;

                const elapsed = (performance.now() - startPlaybackTime) * replayState.playbackSpeed;
                const currentReplayTime = resumeFrom + elapsed;

                // Find current action
                const currentAction = actions.find(a =>
                    (a.timestamp - startTime) >= currentReplayTime &&
                    (a.timestamp - startTime) < currentReplayTime + 50
                );

                // Update ghost cursor position
                if (currentAction) {
                    replayGhostCursor.style.left = currentAction.x + 'px';
                    replayGhostCursor.style.top = currentAction.y + 'px';

                    // Update predictions for all layers
                    state.layers.forEach((layer, i) => {
                        const predicted = predictReplayPosition(currentAction, i);
                        const relX = (predicted.x - layer.offset.x) / layer.scale;
                        const relY = (predicted.y - layer.offset.y) / layer.scale;
                        layer.cursor.style.transform = `translate(${relX}px, ${relY}px)`;

                        // Calculate divergence
                        const dx = predicted.x - currentAction.x;
                        const dy = predicted.y - currentAction.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        layer.divergence = distance;

                        if (distance > 100) {
                            layer.element.classList.add('diverged');
                            layer.element.classList.remove('converged');
                        } else if (distance < 30) {
                            layer.element.classList.add('converged');
                            layer.element.classList.remove('diverged');
                        }
                    });

                    // Show click effect
                    if (currentAction.type === 'click') {
                        simulateReplayClick(currentAction.x, currentAction.y);
                    }
                }

                // Update progress bar
                const duration = actions[actions.length - 1].timestamp - startTime;
                const progress = Math.min((currentReplayTime / duration) * 100, 100);
                timelineProgress.style.width = progress + '%';
                timelinePlayhead.style.left = progress + '%';

                // Update time display
                const currentSec = Math.floor(currentReplayTime / 1000);
                const totalSec = Math.floor(duration / 1000);
                timeDisplay.textContent = `${formatTime(currentSec)} / ${formatTime(totalSec)}`;

                replayState.currentTime = currentReplayTime;

                // Check if replay finished
                if (currentReplayTime >= duration) {
                    stopReplay();
                    replayState.currentTime = 0;
                    return;
                }

                replayState.animationFrame = requestAnimationFrame(animate);
            }

            animate();
        }

        function pauseReplay() {
            replayState.isPlaying = false;
            replayState.isPaused = true;
            replayPlayBtn.disabled = false;
            replayPauseBtn.disabled = true;
            if (replayState.animationFrame) {
                cancelAnimationFrame(replayState.animationFrame);
            }
        }

        function stopReplay() {
            replayState.isPlaying = false;
            replayState.isPaused = false;
            replayState.currentTime = 0;

            if (replayState.animationFrame) {
                cancelAnimationFrame(replayState.animationFrame);
            }

            timelineProgress.style.width = '0%';
            timelinePlayhead.style.left = '0%';
            replayPlayBtn.disabled = false;
            replayPauseBtn.disabled = true;
        }

        function rewindReplay() {
            stopReplay();
            replayState.currentTime = 0;
            timeDisplay.textContent = '0:00 / 0:00';
        }

        function setPlaybackSpeed(speed) {
            replayState.playbackSpeed = speed;
            document.querySelectorAll('.speed-button').forEach(btn => {
                btn.classList.toggle('active', parseFloat(btn.dataset.speed) === speed);
            });
            if (replayState.isPlaying) {
                replayModeBadge.textContent = `REPLAY MODE (${speed}x)`;
            }
        }

        function predictReplayPosition(action, layerIndex) {
            // Similar to predictNextPosition but for replay
            const errorFactor = Math.pow(1.15, layerIndex + 1);
            const chaos = replayState.currentReplay.divergenceScore / 100;

            let predictedX = action.x + (Math.random() - 0.5) * 10 * errorFactor;
            let predictedY = action.y + (Math.random() - 0.5) * 10 * errorFactor;

            const divergenceNoise = layerIndex * 5 * (1 + chaos);
            predictedX += (Math.random() - 0.5) * divergenceNoise;
            predictedY += (Math.random() - 0.5) * divergenceNoise;

            return { x: predictedX, y: predictedY };
        }

        function simulateReplayClick(x, y) {
            state.layers.forEach((layer, i) => {
                setTimeout(() => {
                    const click = document.createElement('div');
                    click.className = 'ghost-click';
                    click.style.color = depthColors[i % depthColors.length];

                    const errorFactor = Math.pow(1.2, i + 1);
                    const clickX = (x - layer.offset.x) / layer.scale + (Math.random() - 0.5) * 20 * errorFactor;
                    const clickY = (y - layer.offset.y) / layer.scale + (Math.random() - 0.5) * 20 * errorFactor;

                    click.style.left = (clickX - 20) + 'px';
                    click.style.top = (clickY - 20) + 'px';
                    layer.element.appendChild(click);
                    playClickSound(i);
                    setTimeout(() => click.remove(), 600);
                }, (i + 1) * 100);
            });
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function importReplay(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);

                    // Check if it's a replay or a full session export
                    if (data.actions && Array.isArray(data.actions)) {
                        const replay = {
                            id: Date.now(),
                            name: data.name || `Imported ${new Date().toLocaleString()}`,
                            timestamp: Date.now(),
                            duration: data.duration || 0,
                            actions: data.actions,
                            depth: data.depth || 5,
                            divergenceScore: data.divergenceScore || 0,
                            accuracy: data.accuracy || 0,
                            behaviorModel: data.behaviorModel || {},
                            metaObservations: data.metaObservations || []
                        };

                        replayState.savedReplays.push(replay);
                        localStorage.setItem(APP_NAME + '-replays', JSON.stringify(replayState.savedReplays));
                        updateReplayList();
                        addLog(`Imported replay: ${replay.name}`, 'match');
                        switchTab('replay');
                    } else if (data.currentSession && data.currentSession.actions) {
                        // Import from full session export
                        const session = data.currentSession;
                        const replay = {
                            id: Date.now(),
                            name: `Imported ${new Date().toLocaleString()}`,
                            timestamp: Date.now(),
                            duration: session.actions.length > 0 ?
                                (session.actions[session.actions.length - 1].timestamp - session.actions[0].timestamp) : 0,
                            actions: session.actions,
                            depth: data.behaviorModel?.depth || 5,
                            divergenceScore: session.divergenceScore || 0,
                            accuracy: 0,
                            behaviorModel: data.behaviorModel || {},
                            metaObservations: session.metaObservations || []
                        };

                        replayState.savedReplays.push(replay);
                        localStorage.setItem(APP_NAME + '-replays', JSON.stringify(replayState.savedReplays));
                        updateReplayList();
                        addLog('Imported replay from session export', 'match');
                        switchTab('replay');
                    } else {
                        alert('Invalid replay file format');
                    }
                } catch (error) {
                    alert('Error importing replay: ' + error.message);
                }
            };
            reader.readAsText(file);
        }

        function switchTab(tabName) {
            tabButtons.forEach(btn => {
                const isActive = btn.dataset.tab === tabName;
                btn.classList.toggle('active', isActive);
            });

            observeTab.classList.toggle('active', tabName === 'observe');
            replayTab.classList.toggle('active', tabName === 'replay');

            if (tabName === 'observe') {
                replayTimeline.classList.remove('active');
                replayModeBadge.classList.remove('active');
                replayGhostCursor.classList.remove('active');
                comparisonCursor.classList.remove('active');
                if (replayState.isPlaying) {
                    stopReplay();
                }
            } else {
                updateReplayList();
            }
        }

        // Timeline scrubbing
        timelineScrubber.addEventListener('click', (e) => {
            if (!replayState.currentReplay) return;

            const rect = timelineScrubber.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const percent = x / rect.width;

            const actions = replayState.currentReplay.actions;
            const duration = actions[actions.length - 1].timestamp - actions[0].timestamp;
            replayState.currentTime = percent * duration;

            timelineProgress.style.width = (percent * 100) + '%';
            timelinePlayhead.style.left = (percent * 100) + '%';

            const currentSec = Math.floor(replayState.currentTime / 1000);
            const totalSec = Math.floor(duration / 1000);
            timeDisplay.textContent = `${formatTime(currentSec)} / ${formatTime(totalSec)}`;
        });

        // Tab switching
        tabButtons.forEach(btn => {
            btn.addEventListener('click', () => switchTab(btn.dataset.tab));
        });

        // Replay control event listeners
        replayPlayBtn.addEventListener('click', playReplay);
        replayPauseBtn.addEventListener('click', pauseReplay);
        replayRewindBtn.addEventListener('click', rewindReplay);

        // Speed control buttons
        document.querySelectorAll('.speed-button').forEach(btn => {
            btn.addEventListener('click', () => {
                setPlaybackSpeed(parseFloat(btn.dataset.speed));
            });
        });

        // Comparison mode toggle
        comparisonModeToggle.addEventListener('change', (e) => {
            replayState.comparisonMode = e.target.checked;
            if (replayState.comparisonMode) {
                comparisonCursor.classList.add('active');
                addLog('Comparison mode enabled - your movements shown in green', 'match');
            } else {
                comparisonCursor.classList.remove('active');
            }
        });

        // Update comparison cursor during live observation if comparison mode is on
        const originalMouseMove = viewport.onmousemove;
        viewport.addEventListener('mousemove', (e) => {
            if (replayState.comparisonMode && replayState.isPlaying) {
                const rect = viewport.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                comparisonCursor.style.left = x + 'px';
                comparisonCursor.style.top = y + 'px';
            }
        });

        // Initialize
        updateStats();
        generateBehavioralFingerprint();
        addLog('Recursive Self-Portrait initialized', 'normal');
        addLog('The system will learn your patterns and simulate you simulating yourself...', 'prediction');
        addLog('Neural network available - toggle to enable real-time learning', 'prediction');

        if (state.sessionHistory.length > 0) {
            const lastSession = state.sessionHistory[state.sessionHistory.length - 1];
            addLog(`Previous session: ${lastSession.actions} actions, ${lastSession.divergence.toFixed(1)}% divergence`, 'normal');
        }

        // Start with sound muted (user must click to activate - better UX)
        soundToggle.classList.add('muted');


        // ===== MULTIPLAYER FUNCTIONALITY =====
        let peerConnection = null;
        let dataChannel = null;
        let isHost = false;
        let roomCode = '';
        let peerState = {
            divergenceScore: 0,
            actions: [],
            layers: [],
            behaviorModel: {},
            cursorPos: { x: 0, y: 0 }
        };
        let predictMode = false;
        let predictScore = 0;

        const multiplayerPanel = document.getElementById('multiplayerPanel');
        const connectionDot = document.getElementById('connectionDot');
        const connectionText = document.getElementById('connectionText');
        const roomCodeInput = document.getElementById('roomCodeInput');
        const joinRoomBtn = document.getElementById('joinRoomBtn');
        const createRoomBtn = document.getElementById('createRoomBtn');
        const roomCodeDisplay = document.getElementById('roomCodeDisplay');
        const roomCodeSpan = document.getElementById('roomCode');
        const comparativeStats = document.getElementById('comparativeStats');
        const myDivergence = document.getElementById('myDivergence');
        const peerDivergence = document.getElementById('peerDivergence');
        const predictModePanel = document.getElementById('predictModePanel');
        const predictModeBtn = document.getElementById('predictModeBtn');
        const predictScoreEl = document.getElementById('predictScore');
        const peerCursor = document.getElementById('peerCursor');
        const peerLayersContainer = document.getElementById('peerLayersContainer');

        function generateRoomCode() {
            const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
            let code = '';
            for (let i = 0; i < 6; i++) {
                code += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return code;
        }

        function updateConnectionStatus(status, text) {
            connectionDot.className = 'status-dot';
            if (status === 'connected') {
                connectionDot.classList.add('connected');
            } else if (status === 'connecting') {
                connectionDot.classList.add('connecting');
            }
            connectionText.textContent = text;
        }

        async function createRoom() {
            roomCode = generateRoomCode();
            isHost = true;

            roomCodeSpan.textContent = roomCode;
            roomCodeDisplay.style.display = 'block';
            createRoomBtn.disabled = true;
            joinRoomBtn.disabled = true;
            roomCodeInput.disabled = true;

            updateConnectionStatus('connecting', 'Waiting for peer...');
            addLog('Room created: ' + roomCode, 'normal');

            // Setup WebRTC as host
            await setupWebRTC(true);
        }

        async function joinRoom() {
            const code = roomCodeInput.value.trim().toUpperCase();
            if (!code) {
                alert('Please enter a room code');
                return;
            }

            roomCode = code;
            isHost = false;

            roomCodeSpan.textContent = roomCode;
            roomCodeDisplay.style.display = 'block';
            createRoomBtn.disabled = true;
            joinRoomBtn.disabled = true;
            roomCodeInput.disabled = true;

            updateConnectionStatus('connecting', 'Connecting to peer...');
            addLog('Joining room: ' + roomCode, 'normal');

            // Setup WebRTC as joiner
            await setupWebRTC(false);
        }

        async function setupWebRTC(isInitiator) {
            // Create RTCPeerConnection
            const config = {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' }
                ]
            };

            peerConnection = new RTCPeerConnection(config);

            // Handle ICE candidates
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    // In a real app, send this to signaling server
                    // For this demo, we'll use manual exchange via prompt
                    console.log('ICE Candidate:', JSON.stringify(event.candidate));
                }
            };

            peerConnection.onconnectionstatechange = () => {
                console.log('Connection state:', peerConnection.connectionState);
                if (peerConnection.connectionState === 'connected') {
                    onPeerConnected();
                } else if (peerConnection.connectionState === 'disconnected' ||
                           peerConnection.connectionState === 'failed') {
                    onPeerDisconnected();
                }
            };

            if (isInitiator) {
                // Host creates data channel
                dataChannel = peerConnection.createDataChannel('recursion');
                setupDataChannel();

                // Create offer
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);

                // Show offer for manual exchange
                const offerStr = JSON.stringify(peerConnection.localDescription);
                addLog('Copy this offer and send to peer', 'prediction');

                // Simulate exchange - in real app this would go through signaling server
                const answerPrompt = 'Paste peer answer (from other browser):';
                setTimeout(() => {
                    const answerStr = prompt(offerStr + '

' + answerPrompt);
                    if (answerStr) {
                        try {
                            const answer = JSON.parse(answerStr);
                            peerConnection.setRemoteDescription(answer);
                        } catch (e) {
                            addLog('Invalid answer format', 'divergence');
                        }
                    }
                }, 1000);

            } else {
                // Joiner waits for offer
                peerConnection.ondatachannel = (event) => {
                    dataChannel = event.channel;
                    setupDataChannel();
                };

                // Get offer from host
                setTimeout(async () => {
                    const offerStr = prompt('Paste the offer from host:');
                    if (offerStr) {
                        try {
                            const offer = JSON.parse(offerStr);
                            await peerConnection.setRemoteDescription(offer);

                            // Create answer
                            const answer = await peerConnection.createAnswer();
                            await peerConnection.setLocalDescription(answer);

                            // Show answer for manual exchange
                            const answerStr = JSON.stringify(peerConnection.localDescription);
                            alert('Send this answer to host:

' + answerStr);
                            addLog('Answer sent - waiting for connection', 'prediction');
                        } catch (e) {
                            addLog('Invalid offer format', 'divergence');
                        }
                    }
                }, 500);
            }
        }

        function setupDataChannel() {
            dataChannel.onopen = () => {
                console.log('Data channel opened');
            };

            dataChannel.onclose = () => {
                console.log('Data channel closed');
                onPeerDisconnected();
            };

            dataChannel.onmessage = (event) => {
                const data = JSON.parse(event.data);
                handlePeerData(data);
            };
        }

        function onPeerConnected() {
            updateConnectionStatus('connected', 'Connected to peer');
            comparativeStats.style.display = 'grid';
            predictModePanel.style.display = 'block';
            peerCursor.style.display = 'block';
            addLog('Peer connected - now watching each other!', 'match');
        }

        function onPeerDisconnected() {
            updateConnectionStatus('disconnected', 'Peer disconnected');
            comparativeStats.style.display = 'none';
            predictModePanel.style.display = 'none';
            peerCursor.style.display = 'none';
            peerLayersContainer.innerHTML = '';
            addLog('Peer disconnected', 'divergence');
        }

        function sendToPeer(data) {
            if (dataChannel && dataChannel.readyState === 'open') {
                dataChannel.send(JSON.stringify(data));
            }
        }

        function handlePeerData(data) {
            if (data.type === 'cursor') {
                // Update peer cursor position
                peerCursor.style.left = data.x + 'px';
                peerCursor.style.top = data.y + 'px';
                peerState.cursorPos = { x: data.x, y: data.y };

                // Update peer layers
                updatePeerLayers(data.x, data.y);

                // Check predict mode
                if (predictMode && state.isObserving) {
                    checkPrediction(data.x, data.y);
                }
            } else if (data.type === 'stats') {
                // Update peer stats
                peerState.divergenceScore = data.divergenceScore;
                peerState.behaviorModel = data.behaviorModel;
                peerDivergence.textContent = data.divergenceScore.toFixed(1) + '%';
                myDivergence.textContent = state.divergenceScore.toFixed(1) + '%';

                // Generate comparative meta-commentary
                if (Math.random() > 0.95) {
                    showComparativeMetaCommentary();
                }
            } else if (data.type === 'action') {
                peerState.actions.push(data.action);
            }
        }

        function updatePeerLayers(x, y) {
            // Clear existing peer layers
            peerLayersContainer.innerHTML = '';

            if (!state.isObserving) return;

            const viewportRect = viewport.getBoundingClientRect();
            const padding = 40;

            // Create peer's recursion layers (mirrored)
            for (let i = 0; i < state.depth; i++) {
                const scale = Math.pow(0.7, i + 1);
                const width = (viewportRect.width - padding * 2) * scale;
                const height = (viewportRect.height - padding * 2) * scale;

                const offsetX = (viewportRect.width - width) / 2 + (i * 5);
                const offsetY = (viewportRect.height - height) / 2 + (i * 5);

                const layer = document.createElement('div');
                layer.className = 'peer-recursion-layer';
                layer.setAttribute('data-depth', `Peer L${i + 1}`);
                layer.style.cssText = `
                    width: ${width}px;
                    height: ${height}px;
                    left: ${offsetX}px;
                    top: ${offsetY}px;
                    z-index: ${state.depth - i - 10};
                    opacity: 0.6;
                `;

                // Add peer ghost cursor to this layer
                const cursor = document.createElement('div');
                cursor.className = 'ghost-cursor peer-ghost-cursor';
                cursor.style.opacity = 0.8 - (i * 0.1);

                // Calculate position within this layer with slight divergence
                const errorFactor = Math.pow(1.15, i + 1);
                const relX = (x - offsetX) / scale + (Math.random() - 0.5) * 10 * errorFactor;
                const relY = (y - offsetY) / scale + (Math.random() - 0.5) * 10 * errorFactor;

                cursor.style.left = relX + 'px';
                cursor.style.top = relY + 'px';

                layer.appendChild(cursor);
                peerLayersContainer.appendChild(layer);
            }
        }

        function showComparativeMetaCommentary() {
            const myDiv = state.divergenceScore;
            const peerDiv = peerState.divergenceScore;
            const diff = Math.abs(myDiv - peerDiv);

            let comment = '';
            if (diff < 10) {
                comment = 'You and your peer are eerily similar...';
            } else if (myDiv > peerDiv) {
                comment = 'You are more unpredictable than them.';
            } else {
                comment = 'They are more chaotic than you.';
            }

            if (state.behaviorModel.movementStyle === peerState.behaviorModel.movementStyle) {
                comment = 'You both move in the same way. Convergence detected.';
            }

            const meta = document.createElement('div');
            meta.className = 'meta-comment dual';
            meta.textContent = comment;

            const maxX = viewport.clientWidth - 320;
            const maxY = viewport.clientHeight - 100;
            meta.style.left = (Math.random() * maxX + 20) + 'px';
            meta.style.top = (Math.random() * maxY + 50) + 'px';

            viewport.appendChild(meta);
            setTimeout(() => meta.remove(), 8000);

            addLog(`Comparative: ${comment}`, 'prediction');
        }

        function checkPrediction(actualX, actualY) {
            // Check if you predicted where peer would move
            const distance = Math.sqrt(
                Math.pow(lastMousePos.x - actualX, 2) +
                Math.pow(lastMousePos.y - actualY, 2)
            );

            if (distance < 50) {
                predictScore += 10;
                addLog('Prediction match! +10', 'match');
            } else if (distance > 200) {
                predictScore = Math.max(0, predictScore - 5);
            }

            predictScoreEl.textContent = predictScore + ' pts';
        }

        // Event listeners
        createRoomBtn.addEventListener('click', createRoom);
        joinRoomBtn.addEventListener('click', joinRoom);

        roomCodeDisplay.addEventListener('click', () => {
            navigator.clipboard.writeText(roomCode);
            addLog('Room code copied to clipboard', 'match');
        });

        predictModeBtn.addEventListener('click', () => {
            predictMode = !predictMode;
            predictModePanel.classList.toggle('active', predictMode);
            predictModeBtn.textContent = predictMode ?
                'Stop Predict Mode' : 'Start "Predict Each Other" Mode';
            predictScore = 0;
            predictScoreEl.textContent = predictMode ? '0 pts' : '';
            addLog(predictMode ? 'Predict mode activated' : 'Predict mode deactivated', 'prediction');
        });

        // Modify existing mouse move handler to send position to peer
        const originalMouseMoveHandler = viewport.onmousemove;
        viewport.addEventListener('mousemove', (e) => {
            if (dataChannel && dataChannel.readyState === 'open') {
                const rect = viewport.getBoundingClientRect();
                sendToPeer({
                    type: 'cursor',
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                });
            }
        });

        // Send stats periodically
        setInterval(() => {
            if (dataChannel && dataChannel.readyState === 'open' && state.isObserving) {
                sendToPeer({
                    type: 'stats',
                    divergenceScore: state.divergenceScore,
                    behaviorModel: state.behaviorModel,
                    actionsCount: state.actions.length
                });
            }
        }, 1000);

        soundEnabled = false;
    </script>

    <!-- Replay Timeline -->
    <div class="replay-timeline" id="replayTimeline">
        <div class="timeline-scrubber" id="timelineScrubber">
            <div class="timeline-progress" id="timelineProgress"></div>
            <div class="timeline-events" id="timelineEvents"></div>
            <div class="timeline-playhead" id="timelinePlayhead"></div>
        </div>
        <div class="replay-controls">
            <button class="replay-button" id="replayPlayBtn">‚ñ∂ Play</button>
            <button class="replay-button" id="replayPauseBtn" disabled>‚è∏ Pause</button>
            <button class="replay-button" id="replayRewindBtn">‚èÆ Rewind</button>
            <div class="speed-control">
                <span style="font-size: 0.75em; color: #888; margin-right: 8px;">Speed:</span>
                <button class="speed-button" data-speed="0.5">0.5x</button>
                <button class="speed-button active" data-speed="1">1x</button>
                <button class="speed-button" data-speed="2">2x</button>
                <button class="speed-button" data-speed="4">4x</button>
            </div>
            <div class="time-display" id="timeDisplay">0:00 / 0:00</div>
        </div>
    </div>

</body>
</html>
