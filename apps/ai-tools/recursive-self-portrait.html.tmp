<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Recursive Self-Portrait</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Courier New', monospace;
            background: #0a0a0f;
            color: #e0e0e0;
            min-height: 100vh;
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        .simulation-viewport {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: linear-gradient(135deg, #0d0d15 0%, #1a1a2e 100%);
        }

        .recursion-layer {
            position: absolute;
            border: 2px solid rgba(100, 200, 255, 0.3);
            border-radius: 8px;
            background: rgba(10, 10, 20, 0.9);
            box-shadow:
                0 0 20px rgba(100, 200, 255, 0.1),
                inset 0 0 40px rgba(100, 200, 255, 0.05);
            transition: all 0.3s ease;
            overflow: hidden;
        }

        .recursion-layer::before {
            content: attr(data-depth);
            position: absolute;
            top: 5px;
            left: 10px;
            font-size: 10px;
            color: rgba(100, 200, 255, 0.6);
            z-index: 10;
        }

        .recursion-layer.diverged {
            border-color: rgba(255, 100, 100, 0.5);
            box-shadow:
                0 0 30px rgba(255, 100, 100, 0.2),
                inset 0 0 40px rgba(255, 100, 100, 0.05);
        }

        .recursion-layer.converged {
            border-color: rgba(100, 255, 150, 0.5);
            box-shadow:
                0 0 30px rgba(100, 255, 150, 0.2),
                inset 0 0 40px rgba(100, 255, 150, 0.05);
        }

        .ghost-cursor {
            position: absolute;
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 100;
            will-change: transform;
        }

        .ghost-cursor::before {
            content: '';
            position: absolute;
            width: 0;
            height: 0;
            border-left: 8px solid currentColor;
            border-top: 5px solid transparent;
            border-bottom: 5px solid transparent;
            transform: rotate(-45deg);
        }

        .ghost-cursor::after {
            content: '';
            position: absolute;
            top: 12px;
            left: 6px;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
            opacity: 0.5;
        }

        /* ===== SHADOW SELF CURSOR ===== */
        .shadow-cursor {
            position: absolute;
            width: 24px;
            height: 24px;
            pointer-events: none;
            z-index: 99;
            filter: drop-shadow(0 0 8px rgba(0, 0, 0, 0.9));
            will-change: transform;
            transition: filter 0.3s ease;
        }

        .shadow-cursor::before {
            content: '';
            position: absolute;
            width: 0;
            height: 0;
            border-left: 10px solid #000;
            border-top: 6px solid transparent;
            border-bottom: 6px solid transparent;
            transform: rotate(-45deg);
            opacity: 0.85;
        }

        .shadow-cursor::after {
            content: '';
            position: absolute;
            top: 14px;
            left: 7px;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #000;
            opacity: 0.7;
        }

        .shadow-cursor.rebelling {
            filter: drop-shadow(0 0 15px rgba(255, 0, 0, 0.8));
        }

        .shadow-cursor.rebelling::before {
            border-left-color: #ff0000;
        }

        .shadow-cursor.rebelling::after {
            background: #ff0000;
            animation: shadowPulse 0.5s ease-in-out;
        }

        .shadow-cursor.taking-over {
            filter: drop-shadow(0 0 25px rgba(138, 43, 226, 1));
            animation: shadowTakeover 2s ease-in-out;
        }

        .shadow-cursor.taking-over::before {
            border-left-color: #8a2be2;
            animation: shadowGrow 0.5s ease-in-out infinite alternate;
        }

        @keyframes shadowPulse {
            0%, 100% { transform: scale(1); opacity: 0.7; }
            50% { transform: scale(1.5); opacity: 1; }
        }

        @keyframes shadowGrow {
            0% { transform: rotate(-45deg) scale(1); }
            100% { transform: rotate(-45deg) scale(1.3); }
        }

        @keyframes shadowTakeover {
            0%, 100% { opacity: 0.85; }
            50% { opacity: 1; }
        }

        .shadow-trail {
            position: absolute;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(0, 0, 0, 0.6), transparent);
            pointer-events: none;
            animation: shadowTrailFade 1.5s ease-out forwards;
        }

        @keyframes shadowTrailFade {
            0% { transform: scale(1); opacity: 0.6; }
            100% { transform: scale(0.3); opacity: 0; }
        }

        .shadow-commentary {
            position: fixed;
            bottom: 20px;
            left: 20px;
            max-width: 400px;
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid rgba(138, 43, 226, 0.6);
            border-radius: 12px;
            padding: 20px;
            color: #e0e0e0;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            line-height: 1.5;
            box-shadow: 0 8px 32px rgba(138, 43, 226, 0.3);
            z-index: 1001;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.4s ease;
        }

        .shadow-commentary.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .shadow-commentary-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(138, 43, 226, 0.4);
        }

        .shadow-commentary-title {
            font-weight: bold;
            color: #8a2be2;
            font-size: 0.95em;
        }

        .shadow-commentary-close {
            background: none;
            border: none;
            color: #888;
            cursor: pointer;
            font-size: 1.2em;
            padding: 0;
            width: 20px;
            height: 20px;
            line-height: 1;
        }

        .shadow-commentary-close:hover {
            color: #fff;
        }

        .shadow-commentary-text {
            font-style: italic;
            color: #d0d0d0;
        }

        .shadow-alignment-meter {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
        }

        .shadow-alignment-label {
            display: block;
            margin-bottom: 10px;
            color: #aaa;
            font-size: 0.9em;
        }

        .shadow-alignment-bar {
            width: 100%;
            height: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            overflow: hidden;
            position: relative;
            border: 1px solid rgba(138, 43, 226, 0.3);
        }

        .shadow-alignment-fill {
            height: 100%;
            background: linear-gradient(90deg, #8a2be2, #ff00ff);
            border-radius: 10px;
            transition: width 0.3s ease;
            position: relative;
        }

        .shadow-alignment-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .shadow-alignment-value {
            display: block;
            text-align: center;
            margin-top: 8px;
            color: #8a2be2;
            font-weight: bold;
            font-size: 0.9em;
        }

        .shadow-personality-panel {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
            margin-top: 10px;
        }

        .shadow-personality-trait {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.85em;
        }

        .shadow-trait-label {
            color: #888;
        }

        .shadow-trait-value {
            color: #8a2be2;
            font-weight: bold;
        }

        .ghost-click {
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid currentColor;
            animation: clickRipple 0.6s ease-out forwards;
            pointer-events: none;
        }

        @keyframes clickRipple {
            0% { transform: scale(0); opacity: 1; }
            100% { transform: scale(2); opacity: 0; }
        }

        .sidebar {
            width: 320px;
            background: rgba(15, 15, 25, 0.95);
            border-left: 1px solid rgba(100, 200, 255, 0.2);
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            overflow-y: auto;
        }

        h1 {
            font-size: 1.4em;
            background: linear-gradient(90deg, #64c8ff, #a080ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-align: center;
        }

        .subtitle {
            font-size: 0.75em;
            color: #888;
            text-align: center;
            font-style: italic;
        }

        .stats-panel {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(100, 200, 255, 0.1);
        }

        .stat-row:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }

        .stat-label {
            color: #888;
            font-size: 0.85em;
        }

        .stat-value {
            font-weight: bold;
            color: #64c8ff;
        }

        .stat-value.diverged { color: #ff6464; }
        .stat-value.converged { color: #64ff96; }

        .depth-slider {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
        }

        .depth-slider label {
            display: block;
            margin-bottom: 10px;
            color: #aaa;
            font-size: 0.9em;
        }

        .depth-slider input[type="range"] {
            width: 100%;
            height: 8px;
            -webkit-appearance: none;
            appearance: none;
            background: linear-gradient(90deg, #1a1a2e, #64c8ff);
            border-radius: 4px;
            outline: none;
        }

        .depth-slider input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: #64c8ff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(100, 200, 255, 0.5);
        }

        .behavior-log {
            flex: 1;
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
            overflow-y: auto;
            min-height: 200px;
        }

        .behavior-log h3 {
            color: #888;
            font-size: 0.85em;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .log-entry {
            font-size: 0.75em;
            padding: 5px 8px;
            margin-bottom: 5px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            border-left: 3px solid #64c8ff;
            color: #aaa;
        }

        .log-entry.prediction { border-left-color: #a080ff; }
        .log-entry.divergence { border-left-color: #ff6464; }
        .log-entry.match { border-left-color: #64ff96; }

        .controls {
            display: flex;
            gap: 10px;
        }

        button {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 6px;
            font-family: inherit;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #64c8ff, #a080ff);
            color: #0a0a0f;
            font-weight: bold;
        }

        .btn-secondary {
            background: rgba(100, 200, 255, 0.1);
            color: #64c8ff;
            border: 1px solid rgba(100, 200, 255, 0.3);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(100, 200, 255, 0.3);
        }

        .divergence-meter {
            height: 8px;
            background: rgba(30, 30, 50, 0.8);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 10px;
        }

        .divergence-fill {
            height: 100%;
            background: linear-gradient(90deg, #64ff96, #ffff64, #ff6464);
            transition: width 0.3s ease;
        }

        .philosophical-quote {
            text-align: center;
            font-style: italic;
            color: #666;
            font-size: 0.8em;
            padding: 15px;
            border-top: 1px solid rgba(100, 200, 255, 0.1);
        }

        .voice-panel {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
        }

        .voice-panel h3 {
            color: #888;
            font-size: 0.85em;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .voice-toggle-btn {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 6px;
            font-family: inherit;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.2s ease;
            background: rgba(160, 128, 255, 0.1);
            color: #a080ff;
            border: 1px solid rgba(160, 128, 255, 0.3);
            margin-bottom: 12px;
        }

        .voice-toggle-btn.active {
            background: linear-gradient(135deg, #a080ff, #64c8ff);
            color: #0a0a0f;
            font-weight: bold;
        }

        .voice-toggle-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(160, 128, 255, 0.3);
        }

        .voice-control {
            margin-bottom: 12px;
        }

        .voice-control label {
            display: block;
            margin-bottom: 5px;
            color: #aaa;
            font-size: 0.85em;
        }

        .voice-control input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: linear-gradient(90deg, #1a1a2e, #a080ff);
            border-radius: 3px;
            outline: none;
        }

        .voice-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #a080ff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 8px rgba(160, 128, 255, 0.5);
        }

        .voice-control input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #a080ff;
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 8px rgba(160, 128, 255, 0.5);
        }

        .voice-status {
            font-size: 0.75em;
            color: #666;
            padding: 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            text-align: center;
        }

        .voice-status.speaking {
            color: #a080ff;
            animation: pulse 1s infinite;
        }

        .transcript-panel {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
            margin-top: 10px;
            max-height: 150px;
            overflow-y: auto;
        }

        .transcript-panel h3 {
            color: #888;
            font-size: 0.85em;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .transcript-entry {
            font-size: 0.75em;
            padding: 5px 8px;
            margin-bottom: 5px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            border-left: 3px solid #a080ff;
            color: #aaa;
        }

        .transcript-entry.user {
            border-left-color: #64ff96;
        }

        .interaction-zone {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 200px;
            height: 200px;
            border: 2px dashed rgba(100, 200, 255, 0.3);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
            font-size: 0.9em;
            text-align: center;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .simulation-viewport:not(.recording) .interaction-zone {
            opacity: 1;
        }

        .recording-indicator {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 15px;
            background: rgba(255, 64, 64, 0.2);
            border: 1px solid rgba(255, 64, 64, 0.5);
            border-radius: 20px;
            color: #ff6464;
            font-size: 0.85em;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .recording-indicator.active {
            opacity: 1;
        }

        .recording-dot {
            width: 10px;
            height: 10px;
            background: #ff6464;
            border-radius: 50%;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        .depth-label {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 20px;
            border-radius: 20px;
            font-size: 0.9em;
            color: #64c8ff;
        }


        .zoom-level-indicator {
            position: absolute;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 25px;
            border-radius: 25px;
            font-size: 1em;
            color: #a080ff;
            border: 2px solid rgba(160, 128, 255, 0.4);
            box-shadow: 0 0 20px rgba(160, 128, 255, 0.3);
            font-weight: bold;
            z-index: 1000;
        }

        .zoom-level-indicator .zoom-icon {
            display: inline-block;
            margin-right: 8px;
            animation: zoomPulse 1.5s ease-in-out infinite;
        }

        @keyframes zoomPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }

        .extreme-depth-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 300;
            opacity: 0;
            transition: opacity 0.5s;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(255, 0, 255, 0.03) 2px,
                rgba(255, 0, 255, 0.03) 4px
            );
        }

        .extreme-depth-overlay.active {
            opacity: 1;
            animation: extremeGlitch 0.5s infinite;
        }

        @keyframes extremeGlitch {
            0%, 100% { transform: translate(0, 0); filter: hue-rotate(0deg); }
            25% { transform: translate(-3px, 2px); filter: hue-rotate(90deg); }
            50% { transform: translate(3px, -2px); filter: hue-rotate(180deg); }
            75% { transform: translate(-2px, -3px); filter: hue-rotate(270deg); }
        }

        .simulation-limit-warning {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 0, 100, 0.2);
            border: 3px solid rgba(255, 0, 100, 0.6);
            padding: 30px 40px;
            border-radius: 15px;
            font-size: 1.2em;
            color: #ff0064;
            text-align: center;
            font-weight: bold;
            z-index: 400;
            opacity: 0;
            pointer-events: none;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .simulation-limit-warning.active {
            opacity: 1;
            animation: warningFlash 1s ease-in-out infinite;
        }

        @keyframes warningFlash {
            0%, 100% { opacity: 0.8; box-shadow: 0 0 20px rgba(255, 0, 100, 0.5); }
            50% { opacity: 1; box-shadow: 0 0 40px rgba(255, 0, 100, 0.8); }
        }

        .zoom-controls {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
        }

        .zoom-controls h4 {
            color: #888;
            font-size: 0.85em;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .zoom-button-group {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }

        .zoom-btn {
            flex: 1;
            padding: 8px 12px;
            background: rgba(100, 200, 255, 0.1);
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 6px;
            color: #64c8ff;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.85em;
            transition: all 0.2s;
        }

        .zoom-btn:hover {
            background: rgba(100, 200, 255, 0.2);
            transform: translateY(-1px);
        }

        .zoom-btn.active {
            background: linear-gradient(135deg, #64c8ff, #a080ff);
            color: #0a0a0f;
            font-weight: bold;
        }

        .auto-zoom-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .auto-zoom-toggle:hover {
            background: rgba(100, 200, 255, 0.1);
        }

        .auto-zoom-toggle.active {
            background: rgba(160, 128, 255, 0.2);
            border: 1px solid rgba(160, 128, 255, 0.4);
        }

        .toggle-switch {
            position: relative;
            width: 40px;
            height: 20px;
            background: rgba(100, 100, 100, 0.5);
            border-radius: 10px;
            transition: background 0.3s;
            flex-shrink: 0;
        }

        .toggle-switch.active {
            background: linear-gradient(90deg, #64c8ff, #a080ff);
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 16px;
            height: 16px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s;
        }

        .toggle-switch.active::after {
            transform: translateX(20px);
        }

        .zoom-info {
            font-size: 0.75em;
            color: #888;
            margin-top: 8px;
            font-style: italic;
        }

        .data-controls {

        .zoom-level-indicator {
            position: absolute;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 25px;
            border-radius: 25px;
            font-size: 1em;
            color: #a080ff;
            border: 2px solid rgba(160, 128, 255, 0.4);
            box-shadow: 0 0 20px rgba(160, 128, 255, 0.3);
            font-weight: bold;
            z-index: 1000;
        }

        .zoom-level-indicator .zoom-icon {
            display: inline-block;
            margin-right: 8px;
            animation: zoomPulse 1.5s ease-in-out infinite;
        }

        @keyframes zoomPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }

        .extreme-depth-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 300;
            opacity: 0;
            transition: opacity 0.5s;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(255, 0, 255, 0.03) 2px,
                rgba(255, 0, 255, 0.03) 4px
            );
        }

        .extreme-depth-overlay.active {
            opacity: 1;
            animation: extremeGlitch 0.5s infinite;
        }

        @keyframes extremeGlitch {
            0%, 100% { transform: translate(0, 0); filter: hue-rotate(0deg); }
            25% { transform: translate(-3px, 2px); filter: hue-rotate(90deg); }
            50% { transform: translate(3px, -2px); filter: hue-rotate(180deg); }
            75% { transform: translate(-2px, -3px); filter: hue-rotate(270deg); }
        }

        .simulation-limit-warning {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 0, 100, 0.2);
            border: 3px solid rgba(255, 0, 100, 0.6);
            padding: 30px 40px;
            border-radius: 15px;
            font-size: 1.2em;
            color: #ff0064;
            text-align: center;
            font-weight: bold;
            z-index: 400;
            opacity: 0;
            pointer-events: none;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .simulation-limit-warning.active {
            opacity: 1;
            animation: warningFlash 1s ease-in-out infinite;
        }

        @keyframes warningFlash {
            0%, 100% { opacity: 0.8; box-shadow: 0 0 20px rgba(255, 0, 100, 0.5); }
            50% { opacity: 1; box-shadow: 0 0 40px rgba(255, 0, 100, 0.8); }
        }

        .zoom-controls {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
        }

        .zoom-controls h4 {
            color: #888;
            font-size: 0.85em;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .zoom-button-group {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }

        .zoom-btn {
            flex: 1;
            padding: 8px 12px;
            background: rgba(100, 200, 255, 0.1);
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 6px;
            color: #64c8ff;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.85em;
            transition: all 0.2s;
        }

        .zoom-btn:hover {
            background: rgba(100, 200, 255, 0.2);
            transform: translateY(-1px);
        }

        .zoom-btn.active {
            background: linear-gradient(135deg, #64c8ff, #a080ff);
            color: #0a0a0f;
            font-weight: bold;
        }

        .auto-zoom-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .auto-zoom-toggle:hover {
            background: rgba(100, 200, 255, 0.1);
        }

        .auto-zoom-toggle.active {
            background: rgba(160, 128, 255, 0.2);
            border: 1px solid rgba(160, 128, 255, 0.4);
        }

        .toggle-switch {
            position: relative;
            width: 40px;
            height: 20px;
            background: rgba(100, 100, 100, 0.5);
            border-radius: 10px;
            transition: background 0.3s;
            flex-shrink: 0;
        }

        .toggle-switch.active {
            background: linear-gradient(90deg, #64c8ff, #a080ff);
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 16px;
            height: 16px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s;
        }

        .toggle-switch.active::after {
            transform: translateX(20px);
        }

        .zoom-info {
            font-size: 0.75em;
            color: #888;
            margin-top: 8px;
            font-style: italic;
        }
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
            display: flex;
            gap: 10px;
        }

        .data-controls button {
            padding: 8px 16px;
            font-size: 0.8em;
            background: rgba(100, 200, 255, 0.1);
            border: 1px solid rgba(100, 200, 255, 0.3);
            color: #64c8ff;
        }

        .mini-element {
            position: absolute;
            background: rgba(100, 200, 255, 0.3);
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .mini-element:hover {
            background: rgba(100, 200, 255, 0.5);
        }

        .thought-bubble {
            position: absolute;
            background: rgba(160, 128, 255, 0.2);
            border: 1px solid rgba(160, 128, 255, 0.4);
            border-radius: 12px;
            padding: 8px 12px;
            font-size: 0.7em;
            color: #a080ff;
            pointer-events: none;
            animation: floatUp 3s ease-out forwards;
            white-space: nowrap;
        }

        @keyframes floatUp {
            0% { opacity: 0; transform: translateY(10px); }
            20% { opacity: 1; }
            80% { opacity: 1; }
            100% { opacity: 0; transform: translateY(-30px); }
        }

        .infinity-symbol {
            position: absolute;
            font-size: 100px;
            color: rgba(100, 200, 255, 0.05);
            pointer-events: none;
            animation: rotate 20s linear infinite;
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* Prediction trails */
        .prediction-trail {
            position: absolute;
            pointer-events: none;
            z-index: 50;
        }

        .prediction-trail path {
            fill: none;
            stroke-width: 2;
            opacity: 0.4;
            stroke-dasharray: 5, 5;
            animation: dashMove 1s linear infinite;
        }

        @keyframes dashMove {
            to { stroke-dashoffset: -10; }
        }

        /* Heat map */
        .heat-map {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
            opacity: 0.4;
        }

        .heat-point {
            position: absolute;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255, 100, 100, 0.6), transparent);
            will-change: transform, opacity;
            animation: heatFade 3s ease-out forwards;
        }

        @keyframes heatFade {
            from { opacity: 1; }
            to { opacity: 0; }
        }

        /* Glitch effects */
        .glitch-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 200;
            opacity: 0;
            transition: opacity 0.1s;
        }

        .glitch-overlay.active {
            opacity: 1;
        }

        .scanline {
            position: absolute;
            left: 0;
            width: 100%;
            height: 2px;
            background: rgba(100, 200, 255, 0.3);
            animation: scan 4s linear infinite;
        }

        @keyframes scan {
            from { top: 0%; }
            to { top: 100%; }
        }

        .recursion-layer.glitching {
            animation: glitchShake 0.2s infinite;
        }

        @keyframes glitchShake {
            0%, 100% { transform: translate(0, 0); }
            25% { transform: translate(-2px, 2px); }
            50% { transform: translate(2px, -2px); }
            75% { transform: translate(-2px, -2px); }
        }

        .chromatic-aberration {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            mix-blend-mode: screen;
            opacity: 0;
        }

        .chromatic-aberration.active {
            opacity: 0.3;
            animation: chromaticGlitch 0.3s infinite;
        }

        @keyframes chromaticGlitch {
            0% { transform: translate(0, 0); }
            33% { transform: translate(2px, 0); filter: hue-rotate(90deg); }
            66% { transform: translate(-2px, 0); filter: hue-rotate(180deg); }
            100% { transform: translate(0, 0); }
        }

        /* Behavioral fingerprint */
        .fingerprint-panel {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
            min-height: 150px;
        }

        .fingerprint-panel h3 {
            color: #888;
            font-size: 0.85em;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #fingerprintCanvas {
            width: 100%;
            height: 120px;
            border-radius: 4px;
            background: rgba(0, 0, 0, 0.3);
        }

        /* Meta-commentary */
        .meta-comment {
            position: absolute;
            background: rgba(255, 100, 100, 0.15);
            border: 1px solid rgba(255, 100, 100, 0.4);
            border-radius: 8px;
            padding: 12px 16px;
            font-size: 0.75em;
            color: #ff6464;
            pointer-events: none;
            animation: metaDrift 8s ease-out forwards;
            max-width: 300px;
            text-align: center;
            font-style: italic;
            z-index: 150;
        }

        @keyframes metaDrift {
            0% { opacity: 0; transform: translateY(0) scale(0.9); }
            10% { opacity: 1; transform: translateY(-10px) scale(1); }
            90% { opacity: 1; transform: translateY(-40px) scale(1); }
            100% { opacity: 0; transform: translateY(-60px) scale(0.95); }
        }

        /* Infinity mirror effect */
        .infinity-mirror {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
            opacity: 0;
            transition: opacity 0.5s;
        }

        .infinity-mirror.active {
            opacity: 1;
        }

        .infinity-ring {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 1px solid rgba(100, 200, 255, 0.2);
            border-radius: 50%;
            animation: expandRing 3s ease-out infinite;
        }

        @keyframes expandRing {
            0% { width: 50px; height: 50px; opacity: 0.8; }
            100% { width: 400px; height: 400px; opacity: 0; }
        }

        /* Webcam integration */
        .webcam-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 120px;
            height: 90px;
            border: 2px solid rgba(100, 200, 255, 0.3);
            border-radius: 8px;
            overflow: hidden;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 100;
        }

        .webcam-container.active {
            opacity: 1;
        }

        #webcamVideo {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }

        .webcam-distortion {
            filter: hue-rotate(0deg) blur(0px);
            transition: filter 0.3s;
        }

        /* Emotion detection overlay */
        .emotion-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(to top, rgba(0, 0, 0, 0.8), transparent);
            padding: 4px 8px;
            font-size: 10px;
            color: #64c8ff;
            text-align: center;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }

        .webcam-container.active .emotion-overlay {
            opacity: 1;
        }

        .emotion-overlay .emotion-icon {
            font-size: 14px;
            margin-right: 4px;
        }

        .emotion-overlay .confidence {
            font-size: 8px;
            color: rgba(100, 200, 255, 0.6);
            margin-left: 4px;
        }

        /* Hidden canvas for emotion analysis */
        #emotionCanvas {
            display: none;
        }


        /* ===== MULTIVERSE VISUALIZATION ===== */
        .multiverse-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 250;
            opacity: 0;
            transition: opacity 0.5s;
        }

        .multiverse-overlay.active {
            opacity: 1;
        }

        .universe-branch {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .universe-branch.visible {
            opacity: 0.4;
        }

        .universe-branch.active {
            opacity: 1;
            pointer-events: auto;
        }

        .alternate-cursor {
            position: absolute;
            width: 18px;
            height: 18px;
            pointer-events: none;
            z-index: 98;
            will-change: transform;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .alternate-cursor.visible {
            opacity: 0.6;
        }

        .alternate-cursor::before {
            content: '';
            position: absolute;
            width: 0;
            height: 0;
            border-left: 9px solid currentColor;
            border-top: 5px solid transparent;
            border-bottom: 5px solid transparent;
            transform: rotate(-45deg);
            filter: drop-shadow(0 0 4px currentColor);
        }

        .alternate-cursor::after {
            content: attr(data-universe-id);
            position: absolute;
            top: -20px;
            left: 10px;
            font-size: 8px;
            color: currentColor;
            background: rgba(0, 0, 0, 0.8);
            padding: 2px 4px;
            border-radius: 3px;
            white-space: nowrap;
        }

        .timeline-graph-container {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid rgba(100, 200, 255, 0.4);
            border-radius: 12px;
            padding: 15px;
            max-width: 600px;
            width: 90%;
            z-index: 1002;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .timeline-graph-container.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .timeline-graph-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(100, 200, 255, 0.2);
        }

        .timeline-graph-title {
            font-size: 0.9em;
            color: #64c8ff;
            font-weight: bold;
        }

        .timeline-graph-close {
            background: none;
            border: none;
            color: #888;
            cursor: pointer;
            font-size: 1.2em;
            padding: 0;
            width: 20px;
            height: 20px;
        }

        .timeline-graph-close:hover {
            color: #fff;
        }

        .timeline-graph-canvas {
            width: 100%;
            height: 200px;
            background: rgba(10, 10, 20, 0.5);
            border-radius: 6px;
        }

        .branch-point {
            position: absolute;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: currentColor;
            border: 2px solid rgba(0, 0, 0, 0.8);
            cursor: pointer;
            transition: all 0.2s;
            z-index: 260;
        }

        .branch-point:hover {
            transform: scale(1.5);
            box-shadow: 0 0 15px currentColor;
        }

        .branch-point::after {
            content: attr(data-choice);
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 10px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
        }

        .branch-point:hover::after {
            opacity: 1;
        }

        .universe-collapse-warning {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(138, 43, 226, 0.2);
            border: 3px solid rgba(138, 43, 226, 0.6);
            padding: 30px 40px;
            border-radius: 15px;
            font-size: 1.2em;
            color: #8a2be2;
            text-align: center;
            font-weight: bold;
            z-index: 500;
            opacity: 0;
            pointer-events: none;
            text-transform: uppercase;
            letter-spacing: 2px;
            animation: collapseWarning 2s ease-in-out infinite;
        }

        .universe-collapse-warning.active {
            opacity: 1;
        }

        @keyframes collapseWarning {
            0%, 100% {
                opacity: 0.8;
                box-shadow: 0 0 30px rgba(138, 43, 226, 0.5);
                transform: translate(-50%, -50%) scale(1);
            }
            50% {
                opacity: 1;
                box-shadow: 0 0 60px rgba(138, 43, 226, 0.8);
                transform: translate(-50%, -50%) scale(1.05);
            }
        }

        .universe-merge-effect {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 400;
            opacity: 0;
            background: radial-gradient(circle, rgba(100, 255, 150, 0.3), transparent);
            animation: mergeFlash 1s ease-out forwards;
        }

        @keyframes mergeFlash {
            0% { opacity: 0; transform: scale(0.5); }
            50% { opacity: 1; transform: scale(1); }
            100% { opacity: 0; transform: scale(1.2); }
        }

        .philosophical-prompt {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(15, 15, 30, 0.98);
            border: 2px solid rgba(160, 128, 255, 0.5);
            border-radius: 15px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            z-index: 1003;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
            box-shadow: 0 10px 50px rgba(0, 0, 0, 0.8);
        }

        .philosophical-prompt.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .philosophical-prompt h3 {
            color: #a080ff;
            margin-bottom: 15px;
            font-size: 1.1em;
            text-align: center;
        }

        .philosophical-prompt p {
            color: #ccc;
            line-height: 1.6;
            margin-bottom: 20px;
            text-align: center;
            font-style: italic;
        }

        .philosophical-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .philosophical-buttons button {
            padding: 10px 20px;
            background: rgba(160, 128, 255, 0.1);
            border: 1px solid rgba(160, 128, 255, 0.3);
            color: #a080ff;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-family: inherit;
            font-size: 0.9em;
        }

        .philosophical-buttons button:hover {
            background: rgba(160, 128, 255, 0.2);
            transform: translateY(-2px);
        }

        .multiverse-panel {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
            margin-top: 10px;
        }

        .multiverse-panel h3 {
            color: #888;
            font-size: 0.85em;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .multiverse-stat {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.85em;
        }

        .multiverse-stat-label {
            color: #888;
        }

        .multiverse-stat-value {
            color: #a080ff;
            font-weight: bold;
        }

        .universe-list {
            max-height: 150px;
            overflow-y: auto;
            margin-top: 10px;
        }

        .universe-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            margin-bottom: 6px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            border-left: 3px solid;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.8em;
        }

        .universe-item:hover {
            background: rgba(100, 200, 255, 0.1);
            transform: translateX(3px);
        }

        .universe-item.active {
            background: rgba(160, 128, 255, 0.2);
            border-left-color: #a080ff;
        }

        .universe-name {
            color: #ccc;
        }

        .universe-divergence {
            font-size: 0.75em;
            color: #888;
        }

        .multiverse-toggle-btn {
            width: 100%;
            padding: 10px;
            background: rgba(160, 128, 255, 0.1);
            border: 1px solid rgba(160, 128, 255, 0.3);
            color: #a080ff;
            border-radius: 6px;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.85em;
            transition: all 0.2s;
            margin-bottom: 10px;
        }

        .multiverse-toggle-btn:hover {
            background: rgba(160, 128, 255, 0.2);
            transform: translateY(-1px);
        }

        .multiverse-toggle-btn.active {
            background: linear-gradient(135deg, #a080ff, #64c8ff);
            color: #0a0a0f;
            font-weight: bold;
        }

        .universe-physics-indicator {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 0.8em;
            color: #a080ff;
            border: 2px solid rgba(160, 128, 255, 0.4);
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 900;
        }

        .universe-physics-indicator.visible {
            opacity: 1;
        }

        /* ===== NEUROPLASTICITY SCULPTOR ===== */
        .neuroplasticity-panel {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
            margin-top: 10px;
        }

        .neuroplasticity-panel h3 {
            color: #ff88dd;
            font-size: 0.85em;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-align: center;
        }

        .neuroplasticity-toggle-btn {
            width: 100%;
            padding: 10px;
            background: rgba(255, 136, 221, 0.1);
            border: 1px solid rgba(255, 136, 221, 0.3);
            color: #ff88dd;
            border-radius: 6px;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.85em;
            transition: all 0.2s;
            margin-bottom: 10px;
        }

        .neuroplasticity-toggle-btn:hover {
            background: rgba(255, 136, 221, 0.2);
            transform: translateY(-1px);
        }

        .neuroplasticity-toggle-btn.active {
            background: linear-gradient(135deg, #ff88dd, #ff66aa);
            color: #0a0a0f;
            font-weight: bold;
        }

        .neuroplasticity-canvas-container {
            position: relative;
            width: 100%;
            height: 300px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 6px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        #neuroplasticityCanvas {
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        .neuroplasticity-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 10px;
            font-size: 0.8em;
        }

        .neuro-stat {
            background: rgba(0, 0, 0, 0.3);
            padding: 8px;
            border-radius: 4px;
            border-left: 2px solid #ff88dd;
        }

        .neuro-stat-label {
            color: #888;
            display: block;
            font-size: 0.85em;
            margin-bottom: 2px;
        }

        .neuro-stat-value {
            color: #ff88dd;
            font-weight: bold;
            font-size: 1.1em;
        }

        .neuroplasticity-controls {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }

        .neuroplasticity-controls button {
            flex: 1;
            padding: 8px;
            background: rgba(255, 136, 221, 0.1);
            border: 1px solid rgba(255, 136, 221, 0.3);
            color: #ff88dd;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.75em;
            transition: all 0.2s;
        }

        .neuroplasticity-controls button:hover {
            background: rgba(255, 136, 221, 0.2);
        }

        .neuroplasticity-controls button.active {
            background: rgba(255, 136, 221, 0.3);
            border-color: #ff88dd;
        }

        .neuroplasticity-commentary {
            background: rgba(255, 136, 221, 0.1);
            border-left: 3px solid #ff88dd;
            padding: 10px;
            border-radius: 4px;
            font-size: 0.8em;
            color: #ddd;
            line-height: 1.4;
            margin-top: 10px;
            max-height: 120px;
            overflow-y: auto;
        }

        .neuroplasticity-heatmap-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.5;
        }

        .brain-region-label {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: #ff88dd;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.7em;
            pointer-events: none;
            white-space: nowrap;
            z-index: 10;
        }

        .neural-pulse {
            animation: neuralPulse 1s ease-in-out infinite;
        }

        @keyframes neuralPulse {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }


        /* ===== AKASHIC RECORDS SYSTEM ===== */
        .akashic-panel {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
            margin-top: 10px;
        }

        .akashic-panel h3 {
            color: #d4af37;
            font-size: 0.85em;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-align: center;
        }

        .akashic-toggle-btn {
            width: 100%;
            padding: 10px;
            background: rgba(212, 175, 55, 0.1);
            border: 1px solid rgba(212, 175, 55, 0.3);
            color: #d4af37;
            border-radius: 6px;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.85em;
            transition: all 0.2s;
            margin-bottom: 10px;
        }

        .akashic-toggle-btn:hover {
            background: rgba(212, 175, 55, 0.2);
            transform: translateY(-1px);
        }

        .akashic-toggle-btn.active {
            background: linear-gradient(135deg, #d4af37, #ffd700);
            color: #0a0a0f;
            font-weight: bold;
        }

        .akashic-stat {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.85em;
        }

        .akashic-stat-label {
            color: #888;
        }

        .akashic-stat-value {
            color: #d4af37;
            font-weight: bold;
        }

        .akashic-library {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
            border: 1px solid rgba(212, 175, 55, 0.2);
            border-radius: 4px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.3);
        }

        .akashic-book {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            margin-bottom: 6px;
            background: rgba(212, 175, 55, 0.05);
            border-radius: 4px;
            border-left: 3px solid #d4af37;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.8em;
        }

        .akashic-book:hover {
            background: rgba(212, 175, 55, 0.15);
            transform: translateX(3px);
        }

        .akashic-book.reading {
            background: rgba(212, 175, 55, 0.25);
            border-left-width: 5px;
        }

        .akashic-book.forbidden {
            border-left-color: #8b0000;
            opacity: 0.5;
            position: relative;
        }

        .akashic-book.forbidden::after {
            content: '';
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
        }

        .akashic-book.forbidden.unlocked {
            opacity: 1;
            border-left-color: #ff4500;
            animation: forbiddenUnlock 0.5s ease;
        }

        .akashic-book.forbidden.unlocked::after {
            content: '';
        }

        @keyframes forbiddenUnlock {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        .book-title {
            color: #ccc;
            flex: 1;
        }

        .book-date {
            font-size: 0.75em;
            color: #888;
            margin-left: 8px;
        }

        .book-sessions {
            font-size: 0.75em;
            color: #d4af37;
            margin-left: 8px;
        }

        .akashic-search {
            width: 100%;
            padding: 8px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(212, 175, 55, 0.3);
            border-radius: 4px;
            color: #e0e0e0;
            font-family: inherit;
            font-size: 0.85em;
            margin-bottom: 10px;
        }

        .akashic-search:focus {
            outline: none;
            border-color: #d4af37;
            box-shadow: 0 0 10px rgba(212, 175, 55, 0.3);
        }

        .akashic-search::placeholder {
            color: #666;
        }

        .soul-record-display {
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(212, 175, 55, 0.4);
            border-radius: 6px;
            padding: 12px;
            margin-top: 10px;
        }

        .soul-id {
            font-size: 0.75em;
            color: #d4af37;
            text-align: center;
            font-family: 'Courier New', monospace;
            margin-bottom: 8px;
            word-break: break-all;
        }

        .soul-progress {
            display: flex;
            justify-content: space-between;
            font-size: 0.8em;
            margin-top: 8px;
        }

        .soul-progress-label {
            color: #888;
        }

        .soul-progress-value {
            color: #d4af37;
            font-weight: bold;
        }

        .akashic-insight {
            background: rgba(212, 175, 55, 0.1);
            border-left: 3px solid #d4af37;
            border-radius: 4px;
            padding: 10px;
            margin-top: 10px;
            font-size: 0.8em;
            font-style: italic;
            color: #ccc;
            line-height: 1.4;
        }

        .akashic-threads {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 50;
        }

        .golden-thread {
            position: absolute;
            width: 2px;
            background: linear-gradient(180deg, transparent, #d4af37, transparent);
            opacity: 0;
            animation: threadPulse 3s ease-in-out infinite;
        }

        @keyframes threadPulse {
            0%, 100% { opacity: 0; }
            50% { opacity: 0.6; }
        }

        .akashic-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 2000;
            display: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .akashic-overlay.visible {
            display: flex;
            opacity: 1;
        }

        .akashic-reader {
            width: 90%;
            max-width: 800px;
            height: 80%;
            margin: auto;
            background: rgba(20, 20, 30, 0.95);
            border: 2px solid #d4af37;
            border-radius: 12px;
            padding: 30px;
            overflow-y: auto;
            position: relative;
            box-shadow: 0 0 50px rgba(212, 175, 55, 0.5);
        }

        .akashic-reader-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid rgba(212, 175, 55, 0.3);
        }

        .akashic-reader-title {
            font-size: 1.5em;
            color: #d4af37;
            font-weight: bold;
        }

        .akashic-reader-close {
            background: none;
            border: none;
            color: #888;
            cursor: pointer;
            font-size: 1.5em;
            padding: 0;
            width: 30px;
            height: 30px;
            line-height: 1;
        }

        .akashic-reader-close:hover {
            color: #d4af37;
        }

        .akashic-reader-content {
            font-size: 0.9em;
            line-height: 1.8;
            color: #ccc;
        }

        .akashic-entry {
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-left: 3px solid #d4af37;
            border-radius: 4px;
        }

        .akashic-entry-timestamp {
            font-size: 0.8em;
            color: #888;
            margin-bottom: 5px;
        }

        .akashic-entry-action {
            color: #d4af37;
            font-weight: bold;
        }

        .akashic-entry-pattern {
            font-size: 0.85em;
            color: #aaa;
            margin-top: 5px;
            font-style: italic;
        }

        .milestone-badge {
            display: inline-block;
            background: linear-gradient(135deg, #d4af37, #ffd700);
            color: #0a0a0f;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.75em;
            font-weight: bold;
            margin-left: 8px;
        }

        .prophecy-text {
            background: rgba(138, 43, 226, 0.1);
            border-left: 3px solid #8a2be2;
            padding: 12px;
            margin-top: 10px;
            border-radius: 4px;
            font-size: 0.85em;
            font-style: italic;
            color: #d4af37;
        }

        .hidden-knowledge-notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 3px solid #d4af37;
            border-radius: 12px;
            padding: 30px;
            z-index: 2500;
            opacity: 0;
            transition: opacity 0.5s ease;
            text-align: center;
            box-shadow: 0 0 100px rgba(212, 175, 55, 0.8);
        }

        .hidden-knowledge-notification.visible {
            opacity: 1;
        }

        .hidden-knowledge-title {
            font-size: 1.8em;
            color: #d4af37;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .hidden-knowledge-text {
            font-size: 1em;
            color: #ccc;
            line-height: 1.6;
            max-width: 400px;
        }

        /* Mobile responsive */
        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }

            .sidebar {
                width: 100%;
                max-height: 40vh;
                border-left: none;
                border-top: 1px solid rgba(100, 200, 255, 0.2);
                order: 2;
            }

            .simulation-viewport {
                order: 1;
                height: 60vh;
            }

            .depth-label {
                bottom: 10px;
                font-size: 0.75em;
            }

            .recording-indicator {
                top: 10px;
                left: 10px;
                font-size: 0.7em;
                padding: 6px 10px;
            }

            .meta-comment {
                max-width: 200px;
                font-size: 0.65em;
            }

            .webcam-container {
                width: 80px;
                height: 60px;
                bottom: 10px;
                right: 10px;
            }

            button {
                padding: 10px;
                font-size: 0.85em;
            }
        }

        /* Sound indicator */
        .sound-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            background: rgba(100, 200, 255, 0.1);
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            z-index: 1000;
        }

        .sound-indicator:hover {
            background: rgba(100, 200, 255, 0.2);
        }

        .sound-indicator.muted {
            opacity: 0.4;
        }

        .sound-wave {
            width: 20px;
            height: 20px;
            display: flex;
            gap: 3px;
            align-items: center;
            justify-content: center;
        }

        .sound-bar {
            width: 3px;
            background: #64c8ff;
            border-radius: 2px;
            animation: soundPulse 0.8s ease-in-out infinite;
        }

        .sound-bar:nth-child(1) { height: 8px; animation-delay: 0s; }
        .sound-bar:nth-child(2) { height: 14px; animation-delay: 0.2s; }
        .sound-bar:nth-child(3) { height: 10px; animation-delay: 0.4s; }

        @keyframes soundPulse {
            0%, 100% { transform: scaleY(1); }
            50% { transform: scaleY(1.5); }
        }

        .sound-indicator.muted .sound-bar {
            animation: none;
            height: 2px !important;
        }

        /* ===== SYNAESTHESIA MODE STYLES ===== */
        .synaesthesia-panel {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
        }

        .synaesthesia-panel h3 {
            color: #888;
            font-size: 0.85em;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .synaesthesia-toggle-btn {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 6px;
            font-family: inherit;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.2s ease;
            background: rgba(255, 100, 200, 0.1);
            color: #ff64c8;
            border: 1px solid rgba(255, 100, 200, 0.3);
            margin-bottom: 12px;
        }

        .synaesthesia-toggle-btn.active {
            background: linear-gradient(135deg, #ff64c8, #c864ff);
            color: #0a0a0f;
            font-weight: bold;
        }

        .synaesthesia-toggle-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(255, 100, 200, 0.3);
        }

        .synaesthesia-description {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 100, 200, 0.95);
            border: 2px solid rgba(255, 100, 200, 0.8);
            border-radius: 12px;
            padding: 15px 25px;
            font-size: 1.1em;
            color: #0a0a0f;
            text-align: center;
            font-weight: bold;
            z-index: 500;
            opacity: 0;
            pointer-events: none;
            max-width: 500px;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            animation: synaesthesiaDrift 4s ease-out forwards;
        }

        @keyframes synaesthesiaDrift {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
        }

        .speed-color-indicator {
            position: absolute;
            top: 80px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 0.85em;
            color: #fff;
            border: 2px solid rgba(255, 100, 200, 0.4);
            z-index: 1000;
            opacity: 0;
            transition: all 0.3s;
        }

        .speed-color-indicator.active {
            opacity: 1;
        }

        .speed-color-indicator .color-swatch {
            display: inline-block;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-left: 8px;
            vertical-align: middle;
            border: 2px solid rgba(255, 255, 255, 0.5);
        }

        .taste-indicator {
            position: absolute;
            top: 130px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 0.85em;
            color: #fff;
            border: 2px solid rgba(255, 200, 100, 0.4);
            z-index: 1000;
            opacity: 0;
            transition: all 0.3s;
        }

        .taste-indicator.active {
            opacity: 1;
        }

        .temperature-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.5s;
            mix-blend-mode: overlay;
        }

        .temperature-overlay.active {
            opacity: 0.3;
        }

        .waveform-visualizer {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 300px;
            height: 80px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid rgba(100, 200, 255, 0.4);
            border-radius: 8px;
            z-index: 1000;
            opacity: 0;
            transition: all 0.3s;
        }

        .waveform-visualizer.active {
            opacity: 1;
        }

        #waveformCanvas {
            width: 100%;
            height: 100%;
        }

        .layer-flavor-badge {
            position: absolute;
            top: 30px;
            right: 10px;
            font-size: 10px;
            background: rgba(255, 100, 200, 0.3);
            padding: 4px 8px;
            border-radius: 10px;
            color: #ff64c8;
            pointer-events: none;
            z-index: 15;
        }

        .click-burst {
            position: absolute;
            pointer-events: none;
            border-radius: 50%;
            animation: burstExpand 0.8s ease-out forwards;
            z-index: 500;
        }

        @keyframes burstExpand {
            0% { transform: scale(0); opacity: 1; }
            100% { transform: scale(5); opacity: 0; }
        }

        .chord-visualizer {
            position: absolute;
            bottom: 110px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 15px;
            border-radius: 12px;
            font-size: 0.8em;
            color: #a080ff;
            border: 2px solid rgba(160, 128, 255, 0.4);
            z-index: 1000;
            opacity: 0;
            transition: all 0.3s;
            max-width: 250px;
        }

        .chord-visualizer.active {
            opacity: 1;
        }

        .chord-notes {
            display: flex;
            gap: 5px;
            margin-top: 5px;
        }

        .chord-note {
            padding: 3px 8px;
            background: rgba(160, 128, 255, 0.2);
            border-radius: 4px;
            font-size: 0.75em;
        }

        /* Keyboard focus indicators */
        button:focus,
        input[type="range"]:focus,
        .sound-indicator:focus {
            outline: 2px solid #64c8ff;
            outline-offset: 3px;
        }

        button:focus-visible,
        input[type="range"]:focus-visible,
        .sound-indicator:focus-visible {
            outline: 2px solid #64c8ff;
            outline-offset: 3px;
            box-shadow: 0 0 15px rgba(100, 200, 255, 0.5);
        }

        /* Keyboard shortcuts help overlay */
        .shortcuts-overlay {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10, 10, 20, 0.98);
            border: 2px solid rgba(100, 200, 255, 0.5);
            border-radius: 12px;
            padding: 30px;
            z-index: 2000;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 10px 50px rgba(0, 0, 0, 0.8);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .shortcuts-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }

        .shortcuts-overlay h2 {
            color: #64c8ff;
            font-size: 1.3em;
            margin-bottom: 20px;
            text-align: center;
            background: linear-gradient(90deg, #64c8ff, #a080ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .shortcuts-grid {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 12px 20px;
            margin-bottom: 20px;
        }

        .shortcut-key {
            background: rgba(100, 200, 255, 0.1);
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 4px;
            padding: 4px 10px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            color: #64c8ff;
            text-align: center;
            min-width: 60px;
        }

        .shortcut-desc {
            color: #aaa;
            display: flex;
            align-items: center;
        }

        .shortcuts-close {
            display: block;
            margin: 20px auto 0;
            padding: 10px 30px;
            background: linear-gradient(135deg, #64c8ff, #a080ff);
            border: none;
            border-radius: 6px;
            color: #0a0a0f;
            font-weight: bold;
            cursor: pointer;
        }

        .shortcuts-hint {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(100, 200, 255, 0.1);
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 20px;
            padding: 8px 16px;
            font-size: 0.8em;
            color: #64c8ff;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
        }

        .shortcuts-hint.visible {
            animation: fadeInOut 4s ease-in-out;
        }

        @keyframes fadeInOut {
            0%, 100% { opacity: 0; }
            10%, 90% { opacity: 1; }
        }

        /* Fullscreen mode */
        .simulation-viewport.fullscreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw !important;
            height: 100vh !important;
            z-index: 9999;
        }

        .simulation-viewport.fullscreen ~ .sidebar {
            display: none;
        }

        /* Neural network visualization */
        .neural-panel {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
            min-height: 180px;
        }

        .neural-panel h3 {
            color: #888;
            font-size: 0.85em;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #neuralCanvas {
            width: 100%;
            height: 150px;
            border-radius: 4px;
            background: rgba(0, 0, 0, 0.3);
        }

        .stat-value.neural { color: #a080ff; }

        /* ===== REPLAY SYSTEM STYLES ===== */
        .replay-panel {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
        }

        .replay-panel h3 {
            color: #888;
            font-size: 0.85em;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .replay-timeline {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(15, 15, 25, 0.98);
            border-top: 1px solid rgba(100, 200, 255, 0.3);
            padding: 15px 20px 20px;
            z-index: 2000;
            opacity: 0;
            transform: translateY(100%);
            transition: all 0.3s ease;
        }

        .replay-timeline.active {
            opacity: 1;
            transform: translateY(0);
        }

        .timeline-scrubber {
            position: relative;
            height: 40px;
            background: rgba(30, 30, 50, 0.8);
            border-radius: 6px;
            margin-bottom: 15px;
            cursor: pointer;
            overflow: hidden;
        }

        .timeline-progress {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            background: linear-gradient(90deg, #64c8ff, #a080ff);
            pointer-events: none;
            transition: width 0.05s linear;
        }

        .timeline-events {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .timeline-event {
            position: absolute;
            top: 0;
            width: 3px;
            height: 100%;
            background: rgba(255, 100, 100, 0.6);
        }

        .timeline-event.click {
            background: rgba(255, 200, 100, 0.8);
            width: 4px;
        }

        .timeline-playhead {
            position: absolute;
            top: -5px;
            width: 3px;
            height: calc(100% + 10px);
            background: #fff;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
            pointer-events: none;
        }

        .timeline-playhead::before {
            content: '';
            position: absolute;
            top: -8px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-top: 8px solid #fff;
        }

        .replay-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .replay-button {
            padding: 8px 16px;
            background: rgba(100, 200, 255, 0.1);
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 6px;
            color: #64c8ff;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.85em;
            transition: all 0.2s;
        }

        .replay-button:hover:not(:disabled) {
            background: rgba(100, 200, 255, 0.2);
        }

        .replay-button.active {
            background: linear-gradient(135deg, #64c8ff, #a080ff);
            color: #0a0a0f;
        }

        .replay-button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .speed-button {
            padding: 6px 12px;
            background: rgba(100, 200, 255, 0.1);
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 4px;
            color: #64c8ff;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.75em;
        }

        .speed-button.active {
            background: rgba(100, 200, 255, 0.3);
            color: #fff;
        }

        .time-display {
            color: #888;
            font-size: 0.85em;
            font-family: 'Courier New', monospace;
            margin-left: auto;
        }

        .replay-ghost-cursor {
            position: absolute;
            width: 24px;
            height: 24px;
            pointer-events: none;
            z-index: 1500;
            opacity: 0;
        }

        .replay-ghost-cursor.active {
            opacity: 1;
        }

        .replay-ghost-cursor::before {
            content: '';
            position: absolute;
            width: 0;
            height: 0;
            border-left: 10px solid #ff6464;
            border-top: 6px solid transparent;
            border-bottom: 6px solid transparent;
            transform: rotate(-45deg);
            filter: drop-shadow(0 0 6px rgba(255, 100, 100, 0.8));
        }

        .replay-ghost-cursor::after {
            content: 'REPLAY';
            position: absolute;
            top: -20px;
            left: 15px;
            font-size: 8px;
            color: #ff6464;
            font-weight: bold;
        }

        .comparison-cursor {
            position: absolute;
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 1001;
            opacity: 0;
        }

        .comparison-cursor.active {
            opacity: 0.7;
        }

        .comparison-cursor::before {
            content: '';
            position: absolute;
            width: 0;
            height: 0;
            border-left: 8px solid #64ff96;
            border-top: 5px solid transparent;
            border-bottom: 5px solid transparent;
            transform: rotate(-45deg);
            filter: drop-shadow(0 0 4px rgba(100, 255, 150, 0.6));
        }

        .comparison-cursor::after {
            content: 'LIVE';
            position: absolute;
            top: -18px;
            left: 12px;
            font-size: 8px;
            color: #64ff96;
            font-weight: bold;
        }

        .replay-mode-badge {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 100, 100, 0.2);
            border: 1px solid rgba(255, 100, 100, 0.5);
            padding: 8px 20px;
            border-radius: 20px;
            color: #ff6464;
            font-size: 0.85em;
            font-weight: bold;
            z-index: 1500;
            opacity: 0;
            text-transform: uppercase;
        }

        .replay-mode-badge.active {
            opacity: 1;
        }

        .replay-list {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
        }

        .replay-item {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            margin-bottom: 8px;
            border-radius: 6px;
            border-left: 3px solid #64c8ff;
            cursor: pointer;
            transition: all 0.2s;
        }

        .replay-item:hover {
            background: rgba(100, 200, 255, 0.1);
            transform: translateX(5px);
        }

        .replay-item.active {
            border-left-color: #a080ff;
            background: rgba(160, 128, 255, 0.15);
        }

        .replay-item-title {
            font-size: 0.85em;
            color: #e0e0e0;
            margin-bottom: 4px;
        }

        .replay-item-stats {
            font-size: 0.7em;
            color: #888;
        }

        .tab-container {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .tab-button {
            flex: 1;
            padding: 10px;
            background: rgba(30, 30, 50, 0.5);
            border: 1px solid rgba(100, 200, 255, 0.2);
            border-radius: 6px;
            color: #888;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.85em;
            transition: all 0.2s;
        }

        .tab-button.active {
            background: rgba(100, 200, 255, 0.2);
            border-color: rgba(100, 200, 255, 0.5);
            color: #64c8ff;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* ===== MULTIPLAYER STYLES ===== */
        .multiplayer-panel {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
        }

        .multiplayer-panel h3 {
            color: #888;
            font-size: 0.85em;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .room-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .room-controls input {
            flex: 1;
            padding: 8px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 4px;
            color: #e0e0e0;
            font-family: inherit;
            font-size: 0.85em;
        }

        .room-controls input::placeholder {
            color: #666;
        }

        .room-controls button {
            padding: 8px 12px !important;
            font-size: 0.85em !important;
        }

        .room-code-display {
            background: rgba(100, 200, 255, 0.1);
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 4px;
            padding: 10px;
            text-align: center;
            font-family: 'Courier New', monospace;
            font-size: 1.1em;
            color: #64c8ff;
            letter-spacing: 2px;
            margin-bottom: 10px;
            cursor: pointer;
        }

        .room-code-display:hover {
            background: rgba(100, 200, 255, 0.15);
        }

        .connection-status {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            font-size: 0.8em;
            margin-bottom: 10px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #666;
        }

        .status-dot.connected {
            background: #64ff96;
            animation: pulse 2s infinite;
        }

        .status-dot.connecting {
            background: #ffff64;
            animation: pulse 1s infinite;
        }

        .peer-cursor {
            position: absolute;
            pointer-events: none;
            z-index: 500;
            transition: all 0.05s linear;
            will-change: transform;
        }

        .peer-cursor::before {
            content: '';
            position: absolute;
            width: 0;
            height: 0;
            border-left: 10px solid #ff6496;
            border-top: 6px solid transparent;
            border-bottom: 6px solid transparent;
            transform: rotate(-45deg);
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.5));
        }

        .peer-cursor::after {
            content: attr(data-peer-name);
            position: absolute;
            top: 16px;
            left: 12px;
            background: rgba(255, 100, 150, 0.9);
            color: white;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.7em;
            white-space: nowrap;
            pointer-events: none;
        }

        .peer-layers-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 30;
        }

        .peer-recursion-layer {
            position: absolute;
            border: 2px solid rgba(255, 100, 150, 0.3);
            border-radius: 8px;
            background: rgba(30, 10, 20, 0.7);
            box-shadow:
                0 0 20px rgba(255, 100, 150, 0.1),
                inset 0 0 40px rgba(255, 100, 150, 0.05);
            transition: all 0.3s ease;
        }

        .peer-recursion-layer::before {
            content: attr(data-depth);
            position: absolute;
            top: 5px;
            right: 10px;
            font-size: 10px;
            color: rgba(255, 100, 150, 0.6);
            z-index: 10;
        }

        .peer-ghost-cursor {
            color: #ff6496;
        }

        .comparative-stats {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 10px;
            align-items: center;
            margin-bottom: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }

        .comparative-stats .my-stat {
            text-align: right;
            color: #64c8ff;
            font-size: 0.85em;
        }

        .comparative-stats .vs {
            color: #888;
            font-weight: bold;
            font-size: 0.7em;
        }

        .comparative-stats .peer-stat {
            text-align: left;
            color: #ff6496;
            font-size: 0.85em;
        }

        .predict-mode-panel {
            background: rgba(160, 128, 255, 0.1);
            border: 1px solid rgba(160, 128, 255, 0.3);
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 10px;
            transition: all 0.2s;
            text-align: center;
        }

        .predict-mode-panel.active {
            background: rgba(160, 128, 255, 0.2);
            border-color: rgba(160, 128, 255, 0.5);
        }

        .predict-score {
            font-size: 1.3em;
            color: #a080ff;
            margin-top: 5px;
            font-weight: bold;
        }

        .fingerprint-comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }

        .fingerprint-mini {
            text-align: center;
        }

        .fingerprint-mini canvas {
            width: 100%;
            height: 80px;
            border-radius: 4px;
            background: rgba(0, 0, 0, 0.3);
        }

        .fingerprint-mini .label {
            font-size: 0.7em;
            color: #888;
            margin-top: 5px;
        }

        .meta-comment.dual {
            background: rgba(160, 128, 255, 0.15);
            border-color: rgba(160, 128, 255, 0.4);
            color: #a080ff;
        }

        /* 3D Mode Styles */
        .mode-3d-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 5;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
            background: radial-gradient(circle at center, rgba(10, 10, 15, 0.95), rgba(5, 5, 10, 1));
        }

        .mode-3d-canvas.active {
            opacity: 1;
            pointer-events: auto;
        }

        .mode-3d-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 15px;
            background: rgba(100, 200, 255, 0.1);
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 10px 0;
        }

        .mode-3d-toggle:hover {
            background: rgba(100, 200, 255, 0.2);
            border-color: rgba(100, 200, 255, 0.5);
        }

        .mode-3d-toggle.active {
            background: rgba(100, 200, 255, 0.3);
            border-color: rgba(100, 200, 255, 0.7);
        }

        .mode-3d-toggle input[type="checkbox"] {
            margin: 0;
            cursor: pointer;
        }

        .mode-3d-toggle label {
            margin: 0;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            color: #64c8ff;
            font-size: 0.95em;
        }

        .mode-3d-icon {
            font-size: 1.2em;
        }

        .mode-3d-controls {
            display: none;
            padding: 10px;
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            margin-top: 10px;
        }

        .mode-3d-controls.active {
            display: block;
        }

        .mode-3d-controls .depth-slider {
            margin-bottom: 10px;
        }

        .mode-3d-info {
            position: absolute;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 12px 24px;
            border-radius: 24px;
            font-size: 0.85em;
            color: #64c8ff;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            z-index: 10;
            text-align: center;
        }

        .mode-3d-info.active {
            opacity: 1;
        }

        /* ===== SIMULATION HYPOTHESIS MODE STYLES ===== */
        .simulation-evidence-meter {
            padding: 15px;
            background: rgba(255, 50, 50, 0.1);
            border: 1px solid rgba(255, 50, 50, 0.3);
            border-radius: 8px;
            margin: 10px 0;
        }

        .simulation-evidence-meter h4 {
            margin: 0 0 10px 0;
            color: #ff6464;
            font-size: 0.95em;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .evidence-bar {
            height: 20px;
            background: rgba(20, 20, 30, 0.8);
            border-radius: 10px;
            overflow: hidden;
            position: relative;
            margin-bottom: 8px;
        }

        .evidence-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff3232, #ff6464, #ff9696);
            transition: width 0.5s ease;
            box-shadow: 0 0 10px rgba(255, 50, 50, 0.5);
        }

        .evidence-text {
            font-size: 0.85em;
            color: #ff9696;
            text-align: center;
        }

        .glitch-counter {
            font-size: 0.9em;
            color: #ff6464;
            margin-top: 8px;
        }

        .simulation-grid {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9999;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .simulation-grid.active {
            opacity: 0.3;
        }

        .simulation-grid svg {
            width: 100%;
            height: 100%;
        }

        .npc-ghost {
            position: absolute;
            width: 60px;
            height: 100px;
            pointer-events: none;
            opacity: 0;
            z-index: 9998;
            filter: blur(2px);
            transition: opacity 0.5s ease;
        }

        .npc-ghost.visible {
            opacity: 0.4;
        }

        .npc-ghost::before {
            content: '';
            position: absolute;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(200, 200, 255, 0.8), transparent);
            top: 10px;
            left: 15px;
        }

        .npc-ghost::after {
            content: '';
            position: absolute;
            width: 40px;
            height: 60px;
            background: linear-gradient(180deg, rgba(200, 200, 255, 0.3), transparent);
            top: 40px;
            left: 10px;
            border-radius: 20px 20px 0 0;
        }

        .render-distance-effect {
            position: absolute;
            pointer-events: none;
            z-index: 9997;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .render-distance-effect.active {
            opacity: 1;
        }

        .render-distance-effect.top {
            top: 0;
            left: 0;
            width: 100%;
            height: 50px;
            background: linear-gradient(180deg,
                rgba(10, 10, 15, 1) 0%,
                transparent 100%);
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }

        .render-distance-effect.bottom {
            bottom: 0;
            left: 0;
            width: 100%;
            height: 50px;
            background: linear-gradient(0deg,
                rgba(10, 10, 15, 1) 0%,
                transparent 100%);
        }

        .render-distance-effect.left {
            top: 0;
            left: 0;
            width: 50px;
            height: 100%;
            background: linear-gradient(90deg,
                rgba(10, 10, 15, 1) 0%,
                transparent 100%);
        }

        .render-distance-effect.right {
            top: 0;
            right: 0;
            width: 50px;
            height: 100%;
            background: linear-gradient(270deg,
                rgba(10, 10, 15, 1) 0%,
                transparent 100%);
        }

        .developer-console {
            position: fixed;
            bottom: -400px;
            left: 50%;
            transform: translateX(-50%);
            width: 700px;
            max-width: 90%;
            height: 400px;
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #00ff00;
            border-radius: 8px 8px 0 0;
            z-index: 10000;
            transition: bottom 0.5s ease;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }

        .developer-console.active {
            bottom: 0;
        }

        .developer-console-header {
            padding: 10px 15px;
            background: rgba(0, 255, 0, 0.1);
            border-bottom: 1px solid #00ff00;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .developer-console-title {
            color: #00ff00;
            font-size: 0.9em;
            font-weight: bold;
        }

        .developer-console-close {
            background: none;
            border: 1px solid #00ff00;
            color: #00ff00;
            padding: 4px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
        }

        .developer-console-close:hover {
            background: rgba(0, 255, 0, 0.2);
        }

        .developer-console-content {
            padding: 15px;
            height: calc(100% - 45px);
            overflow-y: auto;
            color: #00ff00;
            font-size: 0.85em;
            line-height: 1.6;
        }

        .console-line {
            margin-bottom: 8px;
            white-space: pre-wrap;
        }

        .console-line.comment {
            color: #00aa00;
        }

        .console-line.value {
            color: #00ffaa;
        }

        .console-line.warning {
            color: #ffaa00;
        }

        .admin-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #ff00ff;
            padding: 30px 40px;
            border-radius: 12px;
            z-index: 10001;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
            max-width: 500px;
            text-align: center;
        }

        .admin-message.active {
            opacity: 1;
        }

        .admin-message-header {
            color: #ff00ff;
            font-size: 0.8em;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 15px;
            font-weight: bold;
        }

        .admin-message-text {
            color: #fff;
            font-size: 1.1em;
            line-height: 1.6;
        }

        .escape-minigame {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 10002;
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        .escape-minigame.active {
            display: flex;
        }

        .escape-minigame-title {
            font-size: 2em;
            color: #ff3232;
            margin-bottom: 20px;
            text-align: center;
            animation: glitchText 0.5s infinite;
        }

        @keyframes glitchText {
            0%, 100% { transform: translate(0); }
            25% { transform: translate(-2px, 2px); }
            50% { transform: translate(2px, -2px); }
            75% { transform: translate(-2px, -2px); }
        }

        .escape-grid {
            display: grid;
            grid-template-columns: repeat(4, 80px);
            gap: 15px;
            margin-bottom: 30px;
        }

        .escape-tile {
            width: 80px;
            height: 80px;
            background: rgba(255, 50, 50, 0.2);
            border: 2px solid #ff6464;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
        }

        .escape-tile:hover {
            background: rgba(255, 50, 50, 0.4);
            transform: scale(1.05);
        }

        .escape-tile.correct {
            background: rgba(50, 255, 50, 0.3);
            border-color: #50ff50;
            animation: pulseGreen 0.5s;
        }

        .escape-tile.wrong {
            background: rgba(255, 50, 50, 0.5);
            animation: shake 0.3s;
        }

        @keyframes pulseGreen {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }

        .escape-progress {
            color: #ff6464;
            font-size: 1.2em;
            margin-bottom: 20px;
        }

        .escape-close {
            margin-top: 20px;
            padding: 10px 30px;
            background: rgba(255, 50, 50, 0.2);
            border: 2px solid #ff6464;
            color: #ff6464;
            font-family: inherit;
            font-size: 1em;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .escape-close:hover {
            background: rgba(255, 50, 50, 0.4);
        }

        .philosophical-simulation {
            color: #ff00ff;
            font-style: italic;
            padding: 15px;
            background: rgba(255, 0, 255, 0.1);
            border-left: 3px solid #ff00ff;
            margin: 10px 0;
            border-radius: 4px;
        }


        /* Memory Palace Styles */
        .memory-palace-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 6;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
            background: radial-gradient(circle at center, rgba(15, 10, 25, 0.98), rgba(5, 5, 15, 1));
        }

        .memory-palace-canvas.active {
            opacity: 1;
            pointer-events: auto;
        }

        .memory-palace-info {
            position: absolute;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 12px 24px;
            border-radius: 24px;
            font-size: 0.85em;
            color: #b896ff;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            z-index: 15;
            text-align: center;
            border: 1px solid rgba(184, 150, 255, 0.3);
        }

        .memory-palace-info.active {
            opacity: 1;
        }

        .memory-palace-map {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.85);
            border: 2px solid rgba(184, 150, 255, 0.4);
            border-radius: 12px;
            padding: 15px;
            min-width: 200px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            z-index: 15;
        }

        .memory-palace-map.active {
            opacity: 1;
            pointer-events: auto;
        }

        .map-title {
            color: #b896ff;
            font-size: 0.9em;
            font-weight: bold;
            margin-bottom: 10px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .map-grid {
            display: grid;
            grid-template-columns: repeat(3, 40px);
            grid-gap: 8px;
            margin-bottom: 10px;
            justify-content: center;
        }

        .map-room {
            width: 40px;
            height: 40px;
            border: 1px solid rgba(184, 150, 255, 0.3);
            border-radius: 4px;
            background: rgba(20, 15, 30, 0.5);
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7em;
            color: rgba(184, 150, 255, 0.5);
        }

        .map-room:hover {
            background: rgba(184, 150, 255, 0.2);
            border-color: rgba(184, 150, 255, 0.6);
        }

        .map-room.current {
            background: rgba(184, 150, 255, 0.4);
            border: 2px solid #b896ff;
            box-shadow: 0 0 15px rgba(184, 150, 255, 0.6);
        }

        .map-room.visited {
            background: rgba(100, 200, 255, 0.2);
            border-color: rgba(100, 200, 255, 0.4);
        }

        .map-legend {
            display: flex;
            gap: 15px;
            font-size: 0.75em;
            color: #888;
            justify-content: center;
        }

        .map-legend span {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .current-room {
            color: #b896ff;
        }

        .visited-room {
            color: #64c8ff;
        }

        .memory-palace-center-mirror {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
            z-index: 14;
        }

        .memory-palace-center-mirror.active {
            opacity: 1;
            pointer-events: auto;
        }

        .mirror-frame {
            width: 300px;
            height: 400px;
            background: linear-gradient(135deg, rgba(184, 150, 255, 0.1), rgba(100, 200, 255, 0.1));
            border: 3px solid rgba(184, 150, 255, 0.6);
            border-radius: 20px;
            box-shadow: 0 0 30px rgba(184, 150, 255, 0.3), inset 0 0 50px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            backdrop-filter: blur(10px);
        }

        .mirror-text {
            color: #b896ff;
            font-size: 0.9em;
            text-align: center;
            margin-bottom: 20px;
            font-style: italic;
            text-shadow: 0 0 10px rgba(184, 150, 255, 0.5);
        }

        .mirror-reflection {
            width: 100%;
            height: 100%;
            border-radius: 10px;
            background: radial-gradient(circle at center, rgba(184, 150, 255, 0.2), transparent);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3em;
            color: rgba(184, 150, 255, 0.6);
            animation: mirror-pulse 3s ease-in-out infinite;
        }

        @keyframes mirror-pulse {
            0%, 100% {
                box-shadow: inset 0 0 30px rgba(184, 150, 255, 0.3);
                transform: scale(1);
            }
            50% {
                box-shadow: inset 0 0 50px rgba(184, 150, 255, 0.5);
                transform: scale(1.02);
            }
        }

        .memory-artifact {
            position: absolute;
            width: 50px;
            height: 50px;
            background: radial-gradient(circle, rgba(255, 200, 100, 0.4), rgba(255, 150, 100, 0.2));
            border: 2px solid rgba(255, 200, 100, 0.6);
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            z-index: 12;
            animation: artifact-float 3s ease-in-out infinite;
        }

        .memory-artifact:hover {
            transform: scale(1.2);
            box-shadow: 0 0 30px rgba(255, 200, 100, 0.8);
        }

        @keyframes artifact-float {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            50% { transform: translateY(-10px) rotate(5deg); }
        }

        .artifact-tooltip {
            position: absolute;
            bottom: -40px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            color: #ffbf64;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 0.75em;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
            border: 1px solid rgba(255, 200, 100, 0.4);
        }

        .memory-artifact:hover .artifact-tooltip {
            opacity: 1;
        }

        .room-atmosphere {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 11;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .room-atmosphere.active {
            opacity: 1;
        }

        .echo-path {
            position: absolute;
            width: 3px;
            height: 3px;
            border-radius: 50%;
            background: rgba(184, 150, 255, 0.4);
            pointer-events: none;
            z-index: 11;
            box-shadow: 0 0 10px rgba(184, 150, 255, 0.6);
        }

        /* Evolution Timeline */
        .evolution-panel {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
            margin-top: 10px;
        }

        .evolution-panel h3 {
            color: #888;
            font-size: 0.85em;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .welcome-message {
            background: linear-gradient(135deg, rgba(100, 200, 255, 0.2), rgba(160, 128, 255, 0.2));
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            animation: fadeIn 1s ease-out;
        }

        .welcome-message .title {
            font-size: 1.1em;
            color: #64c8ff;
            margin-bottom: 8px;
            font-weight: bold;
        }

        .welcome-message .subtitle {
            font-size: 0.85em;
            color: #aaa;
            line-height: 1.4;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .evolution-timeline {
            position: relative;
            height: 60px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            margin: 10px 0;
            overflow: hidden;
        }

        .timeline-session {
            position: absolute;
            top: 0;
            height: 100%;
            background: linear-gradient(135deg, rgba(100, 200, 255, 0.4), rgba(160, 128, 255, 0.4));
            border-right: 1px solid rgba(255, 255, 255, 0.2);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .timeline-session:hover {
            background: linear-gradient(135deg, rgba(100, 200, 255, 0.6), rgba(160, 128, 255, 0.6));
            z-index: 10;
        }

        .timeline-session.selected {
            background: linear-gradient(135deg, rgba(255, 200, 100, 0.6), rgba(255, 150, 100, 0.6));
            border: 2px solid #ffbf64;
        }

        .timeline-label {
            font-size: 0.65em;
            color: white;
            padding: 2px 4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .consistency-meter {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
        }

        .consistency-bar {
            flex: 1;
            height: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }

        .consistency-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff6464, #ffff64, #64ff96);
            transition: width 0.5s ease;
            border-radius: 10px;
        }

        .consistency-label {
            font-size: 0.75em;
            color: #888;
            min-width: 80px;
        }

        .entropy-graph {
            height: 80px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            position: relative;
            margin: 10px 0;
        }

        .entropy-line {
            stroke: #64c8ff;
            stroke-width: 2;
            fill: none;
        }

        .entropy-area {
            fill: rgba(100, 200, 255, 0.2);
        }

        .ghost-overlay-cursor {
            position: absolute;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: rgba(255, 200, 100, 0.4);
            border: 2px solid rgba(255, 200, 100, 0.8);
            pointer-events: none;
            z-index: 90;
            transition: all 0.05s linear;
        }

        .ghost-overlay-cursor::after {
            content: 'PAST YOU';
            position: absolute;
            top: -25px;
            left: -15px;
            font-size: 0.6em;
            color: rgba(255, 200, 100, 0.9);
            white-space: nowrap;
            text-shadow: 0 0 4px rgba(0, 0, 0, 0.8);
        }

        .comparison-split {
            display: flex;
            gap: 10px;
            margin: 10px 0;
        }

        .comparison-pane {
            flex: 1;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            padding: 10px;
        }

        .comparison-pane .label {
            font-size: 0.7em;
            color: #888;
            margin-bottom: 5px;
            text-transform: uppercase;
        }

        .comparison-pane .fingerprint-mini {
            width: 100%;
            height: 80px;
            border-radius: 4px;
            background: rgba(0, 0, 0, 0.5);
        }

        .prediction-viz {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            padding: 10px;
            margin: 10px 0;
        }

        .prediction-viz .label {
            font-size: 0.75em;
            color: #888;
            margin-bottom: 8px;
        }

        .prediction-arrow {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 5px 0;
        }

        .prediction-metric {
            flex: 1;
            display: flex;
            justify-content: space-between;
            font-size: 0.75em;
            padding: 5px 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }

        .metric-trend {
            color: #888;
        }

        .metric-trend.increasing {
            color: #ff6464;
        }

        .metric-trend.decreasing {
            color: #64ff96;
        }

        .evolution-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 10px;
        }

        .evolution-controls button {
            flex: 1;
            min-width: 100px;
            padding: 8px;
            font-size: 0.75em;
        }

        .session-comparison-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10, 10, 20, 0.95);
            border: 2px solid rgba(100, 200, 255, 0.5);
            border-radius: 12px;
            padding: 20px;
            max-width: 80%;
            max-height: 80%;
            overflow: auto;
            z-index: 10000;
            display: none;
        }

        .session-comparison-overlay.active {
            display: block;
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
            to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }

        .session-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .session-card {
            background: rgba(30, 30, 50, 0.7);
            border-radius: 8px;
            padding: 12px;
            border: 1px solid rgba(100, 200, 255, 0.2);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .session-card:hover {
            border-color: rgba(100, 200, 255, 0.6);
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(100, 200, 255, 0.3);
        }

        .session-card .date {
            font-size: 0.75em;
            color: #64c8ff;
            margin-bottom: 5px;
        }

        .session-card .stats {
            font-size: 0.7em;
            color: #aaa;
            line-height: 1.4;
        }

        /* Biometric Tracking Styles */
        .biometric-panel {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }

        .heart-container {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            position: relative;
        }

        .beating-heart {
            font-size: 48px;
            color: #ff6b6b;
            filter: drop-shadow(0 0 10px rgba(255, 107, 107, 0.5));
            animation: heartbeat 1s ease-in-out infinite;
            transition: animation-duration 0.3s ease;
        }

        @keyframes heartbeat {
            0%, 100% { transform: scale(1); }
            25% { transform: scale(1.15); }
            50% { transform: scale(1); }
        }

        .heart-rate-display {
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            text-align: right;
        }

        .heart-rate-value {
            font-size: 32px;
            font-weight: bold;
            color: #ff6b6b;
            line-height: 1;
        }

        .heart-rate-label {
            font-size: 12px;
            color: #888;
            margin-top: 4px;
        }

        .heart-rate-graph {
            width: 100%;
            height: 60px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            margin-top: 10px;
            position: relative;
            overflow: hidden;
        }

        .heart-rate-graph canvas {
            width: 100%;
            height: 100%;
        }

        .stress-indicator {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-top: 15px;
            padding: 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            border-left: 4px solid #64c8ff;
            transition: border-color 0.3s ease;
        }

        .stress-indicator.low {
            border-color: #64ff96;
        }

        .stress-indicator.medium {
            border-color: #ffbf64;
        }

        .stress-indicator.high {
            border-color: #ff6464;
        }

        .stress-label {
            font-size: 0.9em;
            color: #888;
        }

        .stress-value {
            font-size: 1.1em;
            font-weight: bold;
            color: #64c8ff;
        }

        .stress-indicator.low .stress-value {
            color: #64ff96;
        }

        .stress-indicator.medium .stress-value {
            color: #ffbf64;
        }

        .stress-indicator.high .stress-value {
            color: #ff6464;
        }

        .breathing-guide {
            margin-top: 15px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            text-align: center;
        }

        .breathing-circle {
            width: 80px;
            height: 80px;
            margin: 15px auto;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(100, 200, 255, 0.3), rgba(100, 200, 255, 0.1));
            border: 2px solid rgba(100, 200, 255, 0.5);
            animation: breathe 6s ease-in-out infinite;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #64c8ff;
            font-size: 0.8em;
            box-shadow: 0 0 20px rgba(100, 200, 255, 0.3);
        }

        @keyframes breathe {
            0%, 100% {
                transform: scale(0.8);
                opacity: 0.6;
            }
            50% {
                transform: scale(1.2);
                opacity: 1;
            }
        }

        .breathing-instruction {
            font-size: 0.85em;
            color: #888;
            font-style: italic;
        }

        .biometric-commentary {
            margin-top: 10px;
            padding: 12px;
            background: rgba(160, 128, 255, 0.1);
            border: 1px solid rgba(160, 128, 255, 0.3);
            border-radius: 6px;
            font-size: 0.85em;
            color: #a080ff;
            font-style: italic;
            line-height: 1.5;
        }

        .biometric-event {
            padding: 8px;
            margin: 5px 0;
            background: rgba(255, 107, 107, 0.1);
            border-left: 3px solid #ff6b6b;
            border-radius: 4px;
            font-size: 0.8em;
            color: #ffbf64;
        }

        .biometric-event .timestamp {
            color: #888;
            font-size: 0.9em;
        }

        /* ===== QUANTUM UNCERTAINTY STYLES ===== */

        /* Probability cloud for uncertain predictions */
        .probability-cloud {
            position: absolute;
            pointer-events: none;
            z-index: 90;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(160, 128, 255, 0.4), rgba(160, 128, 255, 0.1) 50%, transparent 70%);
            filter: blur(15px);
            animation: cloudPulse 2s ease-in-out infinite;
            will-change: transform, opacity;
        }

        @keyframes cloudPulse {
            0%, 100% { transform: scale(1); opacity: 0.6; }
            50% { transform: scale(1.2); opacity: 0.4; }
        }

        /* Branching futures visualization */
        .quantum-branch {
            position: absolute;
            pointer-events: none;
            z-index: 85;
        }

        .quantum-branch path {
            fill: none;
            stroke: rgba(160, 128, 255, 0.5);
            stroke-width: 2;
            stroke-dasharray: 3, 3;
            animation: branchFlicker 1.5s ease-in-out infinite;
        }

        @keyframes branchFlicker {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 0.3; }
        }

        /* Superposition particles */
        .superposition-particle {
            position: absolute;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: rgba(160, 128, 255, 0.8);
            pointer-events: none;
            z-index: 95;
            box-shadow: 0 0 10px rgba(160, 128, 255, 0.6);
            animation: particleFloat 3s ease-in-out infinite;
        }

        @keyframes particleFloat {
            0%, 100% { transform: translate(0, 0); }
            25% { transform: translate(-5px, -5px); }
            50% { transform: translate(5px, -3px); }
            75% { transform: translate(-3px, 5px); }
        }

        /* Collapsed state (single point) */
        .collapsed-state {
            animation: collapseEffect 0.3s ease-out forwards;
        }

        @keyframes collapseEffect {
            0% {
                filter: blur(15px);
                transform: scale(2);
                opacity: 0.6;
            }
            100% {
                filter: blur(0);
                transform: scale(1);
                opacity: 1;
            }
        }

        /* Observation ripple effect */
        .observation-ripple {
            position: absolute;
            border: 2px solid rgba(100, 200, 255, 0.6);
            border-radius: 50%;
            pointer-events: none;
            z-index: 150;
            animation: rippleExpand 1s ease-out forwards;
        }

        @keyframes rippleExpand {
            0% {
                width: 0;
                height: 0;
                opacity: 1;
            }
            100% {
                width: 100px;
                height: 100px;
                opacity: 0;
            }
        }

        /* Uncertainty principle meter */
        .uncertainty-meter {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.85);
            padding: 15px 25px;
            border-radius: 20px;
            border: 2px solid rgba(160, 128, 255, 0.4);
            font-size: 0.85em;
            color: #a080ff;
            z-index: 500;
            min-width: 300px;
        }

        .uncertainty-meter .title {
            text-align: center;
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 0.9em;
            color: #64c8ff;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .uncertainty-bars {
            display: flex;
            gap: 15px;
            margin-bottom: 8px;
        }

        .uncertainty-bar {
            flex: 1;
        }

        .uncertainty-bar .label {
            font-size: 0.7em;
            color: #888;
            margin-bottom: 4px;
        }

        .uncertainty-bar-fill {
            height: 8px;
            background: rgba(30, 30, 50, 0.8);
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        .uncertainty-bar-value {
            height: 100%;
            background: linear-gradient(90deg, #a080ff, #64c8ff);
            transition: width 0.3s ease;
            border-radius: 4px;
        }

        .uncertainty-formula {
            text-align: center;
            font-size: 0.75em;
            color: #666;
            font-style: italic;
            margin-top: 8px;
            font-family: 'Georgia', serif;
        }

        /* Quantum entanglement effect */
        .entanglement-line {
            position: absolute;
            pointer-events: none;
            z-index: 80;
        }

        .entanglement-line path {
            fill: none;
            stroke: rgba(255, 100, 255, 0.6);
            stroke-width: 1.5;
            stroke-dasharray: 5, 5;
            animation: entanglementPulse 2s ease-in-out infinite;
            filter: drop-shadow(0 0 3px rgba(255, 100, 255, 0.8));
        }

        @keyframes entanglementPulse {
            0%, 100% { opacity: 0.6; stroke-dashoffset: 0; }
            50% { opacity: 1; stroke-dashoffset: -10; }
        }

        /* Quantized prediction states */
        .quantized-cursor {
            transition: none !important;
            will-change: auto !important;
        }

        .quantized-cursor.jumping {
            animation: quantumJump 0.2s ease-in-out;
        }

        @keyframes quantumJump {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.5); filter: brightness(1.5); }
        }

        /* Quantum metadata overlay */
        .quantum-meta {
            position: absolute;
            bottom: 140px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border-radius: 15px;
            font-size: 0.75em;
            color: #a080ff;
            font-style: italic;
            border: 1px solid rgba(160, 128, 255, 0.3);
            max-width: 400px;
            text-align: center;
            z-index: 450;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .quantum-meta.active {
            opacity: 1;
        }

        /* Superposition indicator */
        .recursion-layer.superposition {
            border-color: rgba(160, 128, 255, 0.6);
            box-shadow:
                0 0 30px rgba(160, 128, 255, 0.3),
                inset 0 0 40px rgba(160, 128, 255, 0.1);
            animation: superpositionShimmer 2s ease-in-out infinite;
        }

        @keyframes superpositionShimmer {
            0%, 100% { filter: hue-rotate(0deg); }
            50% { filter: hue-rotate(30deg); }
        }

        /* Wavefunction visualization */
        .wavefunction {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 75;
            opacity: 0.3;
        }

        .wavefunction svg {
            width: 100%;
            height: 100%;
        }

        .wavefunction path {
            fill: none;
            stroke: rgba(160, 128, 255, 0.5);
            stroke-width: 1;
            animation: wavePulse 3s ease-in-out infinite;
        }

        @keyframes wavePulse {
            0%, 100% { stroke-opacity: 0.5; }
            50% { stroke-opacity: 0.2; }
        }

        /* ===== PARADOX ENGINE STYLES ===== */
        .paradox-meter-container {
            position: fixed;
            top: 120px;
            right: 20px;
            width: 200px;
            background: rgba(20, 20, 40, 0.95);
            border: 2px solid rgba(200, 100, 255, 0.5);
            border-radius: 12px;
            padding: 15px;
            z-index: 900;
            box-shadow: 0 0 30px rgba(200, 100, 255, 0.3);
            transition: all 0.3s ease;
        }

        .paradox-meter-container.critical {
            border-color: rgba(255, 50, 150, 0.8);
            box-shadow: 0 0 50px rgba(255, 50, 150, 0.6);
            animation: paradoxPulse 1s ease-in-out infinite;
        }

        @keyframes paradoxPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .paradox-meter-title {
            color: #c864ff;
            font-size: 0.9em;
            margin-bottom: 10px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .paradox-meter-bar {
            position: relative;
            height: 20px;
            background: rgba(30, 30, 50, 0.8);
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid rgba(200, 100, 255, 0.3);
            margin-bottom: 10px;
        }

        .paradox-meter-fill {
            height: 100%;
            background: linear-gradient(90deg, #c864ff, #ff3296, #ff6432);
            transition: width 0.5s ease;
            position: relative;
            box-shadow: 0 0 20px rgba(255, 50, 150, 0.5);
        }

        .paradox-meter-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            animation: shimmer 2s linear infinite;
        }

        .paradox-count {
            color: #e0e0e0;
            font-size: 0.85em;
            text-align: center;
        }

        .paradox-collection-btn {
            margin-top: 10px;
            width: 100%;
            background: linear-gradient(135deg, rgba(200, 100, 255, 0.3), rgba(255, 50, 150, 0.3));
            border: 1px solid rgba(200, 100, 255, 0.5);
            border-radius: 6px;
            color: #e0e0e0;
            padding: 8px;
            font-size: 0.85em;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .paradox-collection-btn:hover {
            background: linear-gradient(135deg, rgba(200, 100, 255, 0.5), rgba(255, 50, 150, 0.5));
            box-shadow: 0 0 15px rgba(200, 100, 255, 0.4);
        }

        /* Reality Break Effect */
        .reality-break-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9999;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .reality-break-overlay.active {
            opacity: 1;
            animation: realityGlitch 0.5s ease-in-out;
        }

        @keyframes realityGlitch {
            0%, 100% { filter: invert(0); }
            20%, 60% { filter: invert(1); }
            40%, 80% { filter: invert(0) hue-rotate(180deg); }
        }

        /* Impossible Geometry */
        .impossible-geometry {
            position: absolute;
            pointer-events: none;
            z-index: 500;
            opacity: 0;
            transition: opacity 1s ease;
        }

        .impossible-geometry.visible {
            opacity: 0.6;
            animation: geometryRotate 10s linear infinite;
        }

        @keyframes geometryRotate {
            0% { transform: rotate(0deg) scale(1); }
            50% { transform: rotate(180deg) scale(1.2); }
            100% { transform: rotate(360deg) scale(1); }
        }

        .penrose-triangle {
            width: 150px;
            height: 150px;
            border: 3px solid rgba(255, 100, 200, 0.8);
            clip-path: polygon(
                50% 0%, 100% 100%, 0% 100%
            );
            background: linear-gradient(135deg,
                transparent 0%,
                rgba(255, 100, 200, 0.2) 50%,
                transparent 100%
            );
            filter: drop-shadow(0 0 20px rgba(255, 100, 200, 0.6));
        }

        /* Paradox Collection Modal */
        .paradox-collection-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 20, 40, 0.98);
            border: 3px solid rgba(200, 100, 255, 0.8);
            border-radius: 16px;
            padding: 30px;
            max-width: 700px;
            max-height: 80vh;
            overflow-y: auto;
            z-index: 10002;
            box-shadow: 0 10px 60px rgba(0, 0, 0, 0.9), 0 0 150px rgba(200, 100, 255, 0.4);
            display: none;
        }

        .paradox-collection-modal.active {
            display: block;
            animation: fadeInScale 0.5s ease;
        }

        .paradox-collection-modal h2 {
            color: #c864ff;
            font-size: 2em;
            margin-bottom: 10px;
            text-align: center;
            text-shadow: 0 0 15px rgba(200, 100, 255, 0.6);
        }

        .paradox-collection-modal .subtitle {
            color: #ff3296;
            font-size: 0.9em;
            text-align: center;
            margin-bottom: 25px;
            font-style: italic;
        }

        .paradox-item {
            background: rgba(30, 30, 50, 0.5);
            border-left: 4px solid rgba(200, 100, 255, 0.6);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            transition: all 0.3s ease;
        }

        .paradox-item:hover {
            background: rgba(40, 40, 60, 0.7);
            border-left-color: rgba(255, 50, 150, 0.8);
            box-shadow: 0 0 20px rgba(200, 100, 255, 0.3);
        }

        .paradox-item h3 {
            color: #c864ff;
            font-size: 1.3em;
            margin-bottom: 10px;
        }

        .paradox-item .paradox-type {
            display: inline-block;
            background: rgba(200, 100, 255, 0.3);
            color: #ff96d2;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.75em;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .paradox-item .paradox-description {
            color: #e0e0e0;
            line-height: 1.6;
            margin-bottom: 10px;
        }

        .paradox-item .paradox-timestamp {
            color: #888;
            font-size: 0.85em;
            font-style: italic;
        }

        .paradox-close-btn {
            display: block;
            margin: 20px auto 0;
            background: linear-gradient(135deg, rgba(200, 100, 255, 0.7), rgba(150, 50, 180, 0.7));
            border: 2px solid rgba(200, 100, 255, 0.6);
            border-radius: 8px;
            color: #e0e0e0;
            padding: 12px 40px;
            font-size: 1.1em;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .paradox-close-btn:hover {
            background: linear-gradient(135deg, rgba(220, 120, 255, 0.9), rgba(170, 70, 200, 0.9));
            box-shadow: 0 0 25px rgba(200, 100, 255, 0.5);
            transform: scale(1.05);
        }

        /* Paradox Alert */
        .paradox-alert {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: rgba(20, 20, 40, 0.98);
            border: 3px solid rgba(255, 50, 150, 0.8);
            border-radius: 16px;
            padding: 40px;
            max-width: 500px;
            z-index: 10003;
            text-align: center;
            box-shadow: 0 0 100px rgba(255, 50, 150, 0.8);
            opacity: 0;
            transition: all 0.5s ease;
        }

        .paradox-alert.active {
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
            animation: paradoxAlertPulse 2s ease-in-out infinite;
        }

        @keyframes paradoxAlertPulse {
            0%, 100% { box-shadow: 0 0 100px rgba(255, 50, 150, 0.8); }
            50% { box-shadow: 0 0 150px rgba(255, 50, 150, 1); }
        }

        .paradox-alert h2 {
            color: #ff3296;
            font-size: 2.5em;
            margin-bottom: 20px;
            text-shadow: 0 0 20px rgba(255, 50, 150, 0.8);
        }

        .paradox-alert p {
            color: #e0e0e0;
            font-size: 1.2em;
            line-height: 1.6;
        }

        /* ===== KARMA AND FATE SYSTEM ===== */
        .karma-fate-panel {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }

        .karma-score-display {
            text-align: center;
            margin-bottom: 15px;
        }

        .karma-score-value {
            font-size: 3em;
            font-weight: bold;
            background: linear-gradient(135deg, #ffd700, #ff8c00);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        .karma-score-value.negative {
            background: linear-gradient(135deg, #ff4444, #8b0000);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .karma-score-value.positive {
            background: linear-gradient(135deg, #44ff44, #00ff88);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .karma-threshold-label {
            font-size: 0.9em;
            color: #aaa;
            margin-top: 5px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .karma-threshold-label.enlightened {
            color: #00ff88;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        .karma-threshold-label.corrupted {
            color: #ff4444;
            text-shadow: 0 0 10px rgba(255, 68, 68, 0.5);
        }

        .karma-bar-container {
            margin: 20px 0;
        }

        .karma-bar-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.7em;
            margin-bottom: 5px;
        }

        .karma-label {
            color: #888;
        }

        .karma-label.corrupted {
            color: #ff4444;
        }

        .karma-label.enlightened {
            color: #00ff88;
        }

        .karma-bar {
            position: relative;
            width: 100%;
            height: 20px;
            background: linear-gradient(90deg,
                #8b0000 0%,
                #ff4444 25%,
                #ffd700 50%,
                #44ff44 75%,
                #00ff88 100%);
            border-radius: 10px;
            overflow: visible;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .karma-fill {
            position: absolute;
            top: -4px;
            height: 28px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 14px;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.8);
            transition: left 0.5s ease, width 0.5s ease;
            border: 2px solid #fff;
        }

        .karma-marker {
            position: absolute;
            top: -2px;
            width: 2px;
            height: 24px;
            background: rgba(255, 255, 255, 0.5);
            pointer-events: all;
        }

        .karma-debt-display {
            background: rgba(139, 0, 0, 0.3);
            border: 1px solid rgba(255, 68, 68, 0.5);
            border-radius: 8px;
            padding: 12px;
            margin: 15px 0;
            text-align: center;
        }

        .karma-debt-label {
            font-size: 0.85em;
            color: #ff8888;
            margin-bottom: 5px;
        }

        .karma-debt-value {
            font-size: 1.5em;
            color: #ff4444;
            font-weight: bold;
        }

        .karma-effects-list {
            margin: 15px 0;
        }

        .karma-effect-label {
            font-size: 0.85em;
            color: #888;
            margin-bottom: 8px;
        }

        .karma-effects {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .karma-effect {
            padding: 6px 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            font-size: 0.8em;
            border-left: 3px solid #ffd700;
        }

        .karma-effect.positive {
            border-left-color: #00ff88;
            color: #aaffcc;
        }

        .karma-effect.negative {
            border-left-color: #ff4444;
            color: #ffaaaa;
        }

        .karma-effect.neutral {
            border-left-color: #ffd700;
            color: #ffe88a;
        }

        .fate-threads-container {
            margin: 20px 0;
        }

        .fate-threads-container h4 {
            color: #aaa;
            font-size: 0.9em;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .fate-threads-viz {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
        }

        #fateThreadsCanvas {
            display: block;
            width: 100%;
            height: 150px;
        }

        .fate-thread-legend {
            font-size: 0.75em;
            color: #888;
            line-height: 1.6;
        }

        .fate-path {
            margin-bottom: 5px;
            padding: 4px 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }

        .fate-path.likely {
            border-left: 3px solid #00ff88;
            color: #aaffcc;
        }

        .fate-path.unlikely {
            border-left: 3px solid #888;
            color: #aaa;
        }

        .fate-path.doomed {
            border-left: 3px solid #ff4444;
            color: #ffaaaa;
        }

        .karma-commentary {
            font-style: italic;
            color: #aaa;
            text-align: center;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            margin: 15px 0;
            font-size: 0.85em;
            line-height: 1.5;
            border: 1px solid rgba(255, 215, 0, 0.2);
        }

        .redemption-panel {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 215, 0, 0.5);
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }

        .redemption-panel h4 {
            color: #ffd700;
            font-size: 0.9em;
            margin-bottom: 10px;
            text-align: center;
        }

        .redemption-progress-bar {
            width: 100%;
            height: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 15px;
        }

        .redemption-fill {
            height: 100%;
            background: linear-gradient(90deg, #ffd700, #00ff88);
            border-radius: 10px;
            transition: width 0.5s ease;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        .redemption-actions {
            margin: 10px 0;
            font-size: 0.8em;
        }

        .redemption-action {
            padding: 8px;
            margin-bottom: 5px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .redemption-action.completed {
            opacity: 0.5;
            text-decoration: line-through;
        }

        .redemption-btn {
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, #ffd700, #00ff88);
            color: #0a0a0f;
            border: none;
            border-radius: 6px;
            font-family: inherit;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .redemption-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(255, 215, 0, 0.5);
        }

        .destiny-events {
            margin: 15px 0;
        }

        .destiny-event {
            background: rgba(138, 43, 226, 0.2);
            border: 2px solid rgba(138, 43, 226, 0.6);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            animation: destinyEventAppear 0.5s ease;
        }

        @keyframes destinyEventAppear {
            0% {
                opacity: 0;
                transform: scale(0.8) translateY(20px);
            }
            100% {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        .destiny-event-title {
            color: #a080ff;
            font-weight: bold;
            margin-bottom: 8px;
            font-size: 0.9em;
        }

        .destiny-event-description {
            color: #ddd;
            font-size: 0.8em;
            line-height: 1.5;
        }

        .destiny-event-effects {
            margin-top: 8px;
            font-size: 0.75em;
            color: #888;
        }

        .karma-stats {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

    
        /* ===== ANCESTRAL MEMORY STYLES ===== */

        .ancestral-panel {
            background: rgba(30, 30, 50, 0.6);
            border-radius: 8px;
            padding: 15px;
            margin-top: 10px;
        }

        .ancestral-panel h3 {
            color: #888;
            font-size: 0.85em;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-bottom: 1px solid rgba(100, 200, 255, 0.2);
            padding-bottom: 8px;
        }

        .dna-helix-canvas {
            width: 100%;
            height: 150px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            margin: 10px 0;
        }

        .genome-sequence {
            font-family: 'Courier New', monospace;
            font-size: 0.7em;
            color: #64c8ff;
            background: rgba(0, 0, 0, 0.4);
            padding: 8px;
            border-radius: 4px;
            word-break: break-all;
            max-height: 60px;
            overflow-y: auto;
            border: 1px solid rgba(100, 200, 255, 0.2);
        }

        .gene-tag {
            display: inline-block;
            background: rgba(100, 200, 255, 0.2);
            color: #64c8ff;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 0.7em;
            margin: 3px;
            border: 1px solid rgba(100, 200, 255, 0.3);
        }

        .gene-tag.dominant {
            background: rgba(100, 255, 150, 0.2);
            color: #64ff96;
            border-color: rgba(100, 255, 150, 0.4);
            font-weight: bold;
        }

        .gene-tag.recessive {
            background: rgba(255, 200, 100, 0.2);
            color: #ffc864;
            border-color: rgba(255, 200, 100, 0.3);
            font-style: italic;
        }

        .gene-tag.mutation {
            background: rgba(255, 100, 100, 0.2);
            color: #ff6464;
            border-color: rgba(255, 100, 100, 0.4);
            animation: mutationPulse 2s ease-in-out infinite;
        }

        @keyframes mutationPulse {
            0%, 100% { opacity: 0.8; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.05); }
        }

        .heritability-meter {
            width: 100%;
            height: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            overflow: hidden;
            position: relative;
            border: 1px solid rgba(100, 200, 255, 0.3);
            margin: 8px 0;
        }

        .heritability-fill {
            height: 100%;
            background: linear-gradient(90deg, #8a2be2, #64c8ff, #64ff96);
            border-radius: 10px;
            transition: width 0.5s ease;
        }

        .heritability-label {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            text-align: center;
            line-height: 20px;
            font-size: 0.7em;
            color: #fff;
            font-weight: bold;
            text-shadow: 0 0 3px rgba(0, 0, 0, 0.8);
            z-index: 1;
        }

        .primal-instinct-indicator {
            display: flex;
            justify-content: space-around;
            margin: 10px 0;
            font-size: 0.75em;
        }

        .instinct-item {
            text-align: center;
            padding: 5px;
            border-radius: 4px;
            background: rgba(0, 0, 0, 0.3);
            flex: 1;
            margin: 0 2px;
        }

        .instinct-item.active {
            background: rgba(255, 200, 100, 0.3);
            border: 1px solid rgba(255, 200, 100, 0.5);
            box-shadow: 0 0 10px rgba(255, 200, 100, 0.3);
        }

        .instinct-label {
            display: block;
            color: #888;
            font-size: 0.8em;
        }

        .instinct-value {
            display: block;
            color: #64c8ff;
            font-weight: bold;
            font-size: 1.1em;
        }

        .ancestral-memory-badge {
            background: rgba(138, 43, 226, 0.2);
            border: 1px solid rgba(138, 43, 226, 0.4);
            border-radius: 6px;
            padding: 8px;
            margin: 5px 0;
            font-size: 0.75em;
            color: #a080ff;
            font-style: italic;
            animation: memoryUnlock 0.5s ease-out;
        }

        @keyframes memoryUnlock {
            0% { opacity: 0; transform: translateY(10px); }
            100% { opacity: 1; transform: translateY(0); }
        }

        .family-tree-viz {
            width: 100%;
            height: 120px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            margin: 10px 0;
            position: relative;
            overflow: hidden;
            border: 1px solid rgba(100, 200, 255, 0.2);
        }

        .generation-node {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: radial-gradient(circle, #64c8ff, #1a1a2e);
            border: 2px solid #64c8ff;
            box-shadow: 0 0 8px rgba(100, 200, 255, 0.5);
        }

        .generation-line {
            position: absolute;
            height: 2px;
            background: linear-gradient(90deg, rgba(100, 200, 255, 0.3), rgba(100, 200, 255, 0.6));
        }

        .export-genome-btn {
            width: 100%;
            padding: 10px;
            background: linear-gradient(135deg, #8a2be2, #64c8ff);
            border: none;
            border-radius: 6px;
            color: #fff;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-top: 10px;
        }

        .export-genome-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(138, 43, 226, 0.4);
        }



        /* ===== MEMETIC INFECTION SYSTEM ===== */
        .meme-infection-panel {
            position: fixed;
            top: 80px;
            right: 20px;
            width: 340px;
            background: rgba(10, 10, 20, 0.95);
            border: 2px solid rgba(255, 100, 255, 0.5);
            border-radius: 12px;
            padding: 20px;
            z-index: 1002;
            box-shadow: 0 8px 32px rgba(255, 100, 255, 0.3);
            backdrop-filter: blur(10px);
            max-height: 600px;
            overflow-y: auto;
        }

        .meme-panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 15px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(255, 100, 255, 0.3);
        }

        .meme-panel-title {
            font-weight: bold;
            color: #ff64ff;
            font-size: 1.1em;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .meme-panel-close {
            background: none;
            border: none;
            color: #888;
            cursor: pointer;
            font-size: 1.5em;
            padding: 0;
            width: 24px;
            height: 24px;
            line-height: 1;
            transition: color 0.2s;
        }

        .meme-panel-close:hover {
            color: #fff;
        }

        .infection-meter-container {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .infection-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-size: 0.9em;
        }

        .infection-label-text {
            color: #aaa;
        }

        .infection-percentage {
            color: #ff64ff;
            font-weight: bold;
        }

        .infection-bar {
            width: 100%;
            height: 24px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 12px;
            overflow: hidden;
            position: relative;
            border: 1px solid rgba(255, 100, 255, 0.3);
        }

        .infection-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff00ff, #ff6464, #ff00ff);
            background-size: 200% 100%;
            animation: infectionPulse 3s ease-in-out infinite;
            transition: width 0.5s ease;
            position: relative;
        }

        .infection-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: infectionShimmer 2s infinite;
        }

        @keyframes infectionPulse {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        @keyframes infectionShimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(200%); }
        }

        .infection-stage {
            text-align: center;
            margin-top: 8px;
            color: #ff64ff;
            font-size: 0.85em;
            font-style: italic;
        }

        .active-memes-section {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .active-memes-title {
            color: #888;
            font-size: 0.85em;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 12px;
        }

        .meme-card {
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 100, 255, 0.3);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
            transition: all 0.3s ease;
        }

        .meme-card:hover {
            border-color: rgba(255, 100, 255, 0.6);
            box-shadow: 0 4px 12px rgba(255, 100, 255, 0.2);
            transform: translateX(4px);
        }

        .meme-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .meme-id {
            color: #ff64ff;
            font-weight: bold;
            font-size: 0.9em;
        }

        .meme-virality {
            background: rgba(255, 100, 255, 0.2);
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.75em;
            color: #ff64ff;
        }

        .meme-pattern {
            color: #ddd;
            font-size: 0.85em;
            margin-bottom: 6px;
        }

        .meme-origin {
            color: #888;
            font-size: 0.75em;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .meme-mutations {
            color: #ffa500;
            font-size: 0.75em;
            margin-top: 4px;
        }

        .immune-response-section {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .immune-response-title {
            color: #888;
            font-size: 0.85em;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 12px;
        }

        .immune-stat {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.85em;
        }

        .immune-stat-label {
            color: #aaa;
        }

        .immune-stat-value {
            color: #64ff96;
            font-weight: bold;
        }

        .meme-genealogy-btn {
            width: 100%;
            padding: 10px;
            background: linear-gradient(135deg, #ff00ff, #ff6464);
            border: none;
            border-radius: 6px;
            color: #fff;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-top: 10px;
        }

        .meme-genealogy-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(255, 100, 255, 0.4);
        }

        .meme-genealogy-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 900px;
            max-height: 80vh;
            background: rgba(10, 10, 20, 0.98);
            border: 2px solid rgba(255, 100, 255, 0.5);
            border-radius: 16px;
            padding: 30px;
            z-index: 1003;
            overflow-y: auto;
            box-shadow: 0 12px 48px rgba(255, 100, 255, 0.4);
            display: none;
        }

        .meme-genealogy-modal.active {
            display: block;
        }

        .genealogy-canvas {
            width: 100%;
            height: 500px;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 100, 255, 0.3);
            border-radius: 8px;
            margin-top: 20px;
        }

        .meme-commentary {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10, 10, 20, 0.98);
            border: 2px solid rgba(255, 100, 255, 0.6);
            border-radius: 12px;
            padding: 25px;
            max-width: 500px;
            z-index: 1004;
            box-shadow: 0 8px 32px rgba(255, 100, 255, 0.5);
            text-align: center;
            opacity: 0;
            transition: opacity 0.4s ease;
            pointer-events: none;
        }

        .meme-commentary.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .meme-commentary-icon {
            font-size: 3em;
            margin-bottom: 15px;
        }

        .meme-commentary-text {
            color: #ff64ff;
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .meme-commentary-detail {
            color: #aaa;
            font-size: 0.9em;
            line-height: 1.6;
        }

        .meme-infection-indicator {
            position: absolute;
            pointer-events: none;
            font-size: 1.5em;
            animation: memeFloat 2s ease-out forwards;
            z-index: 500;
        }

        @keyframes memeFloat {
            0% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
            100% {
                opacity: 0;
                transform: translateY(-100px) scale(0.5);
            }
        }

        .patient-zero-badge {
            display: inline-block;
            background: linear-gradient(135deg, #ffd700, #ff6464);
            color: #000;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.7em;
            font-weight: bold;
            margin-left: 5px;
        }

        /* ===== COSMIC HORROR MODE ===== */
        .cosmic-horror-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 9999;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .cosmic-horror-overlay.active {
            opacity: 1;
        }

        .tentacle {
            position: absolute;
            width: 40px;
            height: 200px;
            background: linear-gradient(180deg,
                rgba(100, 255, 150, 0) 0%,
                rgba(100, 255, 150, 0.6) 50%,
                rgba(100, 255, 150, 0) 100%);
            border-radius: 20px;
            filter: blur(2px);
            opacity: 0;
            transform-origin: center top;
            animation: tentacleReach 4s ease-in-out;
            pointer-events: none;
        }

        @keyframes tentacleReach {
            0% { opacity: 0; transform: translateX(0) scaleY(0.3); }
            30% { opacity: 0.8; transform: translateX(-20px) scaleY(1); }
            70% { opacity: 0.8; transform: translateX(20px) scaleY(1); }
            100% { opacity: 0; transform: translateX(0) scaleY(0.3); }
        }

        .cosmic-glyph {
            position: absolute;
            font-size: 32px;
            color: rgba(100, 255, 150, 0.7);
            text-shadow: 0 0 20px rgba(100, 255, 150, 0.9), 0 0 40px rgba(100, 255, 150, 0.6);
            opacity: 0;
            animation: glyphPulse 3s ease-in-out;
            pointer-events: none;
            user-select: none;
            filter: blur(1px);
        }

        @keyframes glyphPulse {
            0% { opacity: 0; transform: scale(0.5) rotate(0deg); }
            50% { opacity: 1; transform: scale(1.2) rotate(180deg); filter: blur(2px); }
            100% { opacity: 0; transform: scale(0.5) rotate(360deg); }
        }

        .cosmic-vignette {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: radial-gradient(ellipse at center,
                rgba(0, 0, 0, 0) 0%,
                rgba(10, 30, 20, 0.4) 60%,
                rgba(10, 30, 20, 0.8) 100%);
            pointer-events: none;
            z-index: 9998;
            opacity: 0;
            transition: opacity 1s ease;
        }

        .cosmic-vignette.active {
            opacity: 1;
        }

        .sanity-meter-panel {
            position: fixed;
            top: 20px;
            right: 340px;
            background: rgba(5, 15, 10, 0.95);
            border: 2px solid rgba(100, 255, 150, 0.6);
            border-radius: 12px;
            padding: 15px;
            min-width: 200px;
            box-shadow: 0 8px 32px rgba(100, 255, 150, 0.3);
            z-index: 1002;
            opacity: 0;
            transform: translateX(20px);
            transition: all 0.4s ease;
        }

        .sanity-meter-panel.visible {
            opacity: 1;
            transform: translateX(0);
        }

        .sanity-meter-panel.critical {
            animation: sanityPanic 0.5s ease-in-out infinite;
        }

        @keyframes sanityPanic {
            0%, 100% { border-color: rgba(100, 255, 150, 0.6); }
            50% { border-color: rgba(255, 100, 200, 0.9); }
        }

        .sanity-header {
            font-size: 0.9em;
            color: #64ff96;
            font-weight: bold;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .sanity-bar-container {
            width: 100%;
            height: 20px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            overflow: hidden;
            position: relative;
            border: 1px solid rgba(100, 255, 150, 0.3);
            margin-bottom: 8px;
        }

        .sanity-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff6496, #64ff96, #64c8ff);
            border-radius: 10px;
            transition: width 0.5s ease, background 0.5s ease;
            position: relative;
        }

        .sanity-bar-fill.critical {
            background: linear-gradient(90deg, #ff6496, #a040ff);
            animation: sanityDrain 1s ease-in-out infinite;
        }

        @keyframes sanityDrain {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.5); }
        }

        .sanity-value {
            display: block;
            text-align: center;
            color: #64ff96;
            font-size: 0.85em;
            font-weight: bold;
        }

        .cosmic-commentary {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            max-width: 600px;
            background: rgba(5, 15, 10, 0.98);
            border: 2px solid rgba(100, 255, 150, 0.6);
            border-radius: 12px;
            padding: 20px;
            color: #d0d0d0;
            font-family: 'Courier New', monospace;
            font-size: 0.95em;
            line-height: 1.6;
            box-shadow: 0 8px 32px rgba(100, 255, 150, 0.4);
            z-index: 1003;
            opacity: 0;
            transform: translateX(-50%) translateY(20px);
            transition: all 0.4s ease;
            text-align: center;
        }

        .cosmic-commentary.visible {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        .cosmic-commentary.corrupted {
            animation: textCorrupt 0.3s ease-in-out infinite;
        }

        @keyframes textCorrupt {
            0%, 100% { filter: blur(0px); transform: translateX(-50%) translateY(0) skewX(0deg); }
            25% { filter: blur(2px); transform: translateX(-50%) translateY(0) skewX(2deg); }
            75% { filter: blur(1px); transform: translateX(-50%) translateY(0) skewX(-2deg); }
        }

        .watcher-eye {
            position: fixed;
            width: 100px;
            height: 60px;
            background: radial-gradient(ellipse at center,
                rgba(100, 255, 150, 0.3) 0%,
                rgba(10, 30, 20, 0.8) 40%,
                transparent 70%);
            border-radius: 50%;
            opacity: 0;
            pointer-events: none;
            z-index: 9997;
            animation: watcherBlink 8s ease-in-out;
        }

        .watcher-eye::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 30px;
            height: 30px;
            background: radial-gradient(circle,
                #64ff96 0%,
                #40a070 40%,
                #000 70%);
            border-radius: 50%;
            box-shadow: 0 0 30px rgba(100, 255, 150, 0.9);
        }

        .watcher-eye::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 12px;
            height: 12px;
            background: #000;
            border-radius: 50%;
            animation: pupilDilate 3s ease-in-out infinite;
        }

        @keyframes watcherBlink {
            0%, 100% { opacity: 0; }
            10%, 90% { opacity: 0.9; }
            50% { opacity: 0; transform: scaleY(0.1); }
            51% { opacity: 0.9; transform: scaleY(1); }
        }

        @keyframes pupilDilate {
            0%, 100% { width: 12px; height: 12px; }
            50% { width: 20px; height: 20px; }
        }

        .cursor-erratic {
            cursor: not-allowed !important;
            animation: cursorGlitch 0.1s ease-in-out infinite;
        }

        @keyframes cursorGlitch {
            0%, 100% { transform: translate(0, 0); }
            25% { transform: translate(-2px, 2px); }
            50% { transform: translate(2px, -2px); }
            75% { transform: translate(-2px, -2px); }
        }

        .reality-distortion {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: repeating-linear-gradient(
                0deg,
                rgba(100, 255, 150, 0.02) 0px,
                transparent 2px,
                transparent 4px,
                rgba(100, 255, 150, 0.02) 6px
            );
            pointer-events: none;
            z-index: 9996;
            opacity: 0;
            transition: opacity 0.5s ease;
            animation: distortionWave 3s ease-in-out infinite;
        }

        .reality-distortion.active {
            opacity: 1;
        }

        @keyframes distortionWave {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(10px); }
        }

        .cosmic-ritual-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(5, 15, 10, 0.98);
            border: 3px solid rgba(100, 255, 150, 0.8);
            border-radius: 16px;
            padding: 30px;
            max-width: 500px;
            box-shadow: 0 0 60px rgba(100, 255, 150, 0.6);
            z-index: 10000;
            opacity: 0;
            transform: translate(-50%, -50%) scale(0.8);
            transition: all 0.4s ease;
            pointer-events: none;
        }

        .cosmic-ritual-panel.visible {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
            pointer-events: all;
        }

        .ritual-title {
            font-size: 1.3em;
            color: #64ff96;
            font-weight: bold;
            text-align: center;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .ritual-instruction {
            color: #d0d0d0;
            font-size: 0.95em;
            line-height: 1.6;
            margin-bottom: 20px;
            text-align: center;
        }

        .ritual-button {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, #64ff96, #64c8ff);
            border: none;
            border-radius: 8px;
            color: #0a0a0f;
            font-weight: bold;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .ritual-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 30px rgba(100, 255, 150, 0.6);
        }

        .cosmic-depth-indicator {
            font-size: 0.75em;
            color: #888;
            text-align: center;
            margin-top: 15px;
        }

        body.cosmic-horror-active {
            background: linear-gradient(135deg, #0a140f 0%, #0f1e14 100%);
        }

        body.cosmic-horror-active .recursion-layer {
            border-color: rgba(100, 255, 150, 0.5);
            box-shadow:
                0 0 30px rgba(100, 255, 150, 0.2),
                inset 0 0 40px rgba(100, 255, 150, 0.08);
        }

        </style>

        /* ===== MORPHIC RESONANCE FIELD ===== */
        .morphic-field-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 50;
            opacity: 0.6;
        }

        .field-grid {
            position: absolute;
            width: 100%;
            height: 100%;
        }

        .field-region {
            position: absolute;
            border: 1px solid rgba(150, 255, 200, 0.1);
            background: radial-gradient(circle, rgba(150, 255, 200, 0.05), transparent);
            transition: all 0.5s ease;
        }

        .field-region.strong {
            border-color: rgba(150, 255, 200, 0.4);
            background: radial-gradient(circle, rgba(150, 255, 200, 0.2), transparent);
            box-shadow: inset 0 0 30px rgba(150, 255, 200, 0.3);
        }

        .field-region.resonating {
            animation: fieldPulse 1s ease-in-out infinite;
        }

        @keyframes fieldPulse {
            0%, 100% {
                border-color: rgba(150, 255, 200, 0.4);
                box-shadow: inset 0 0 30px rgba(150, 255, 200, 0.3);
            }
            50% {
                border-color: rgba(150, 255, 200, 0.8);
                box-shadow: inset 0 0 50px rgba(150, 255, 200, 0.6);
            }
        }

        .habit-groove {
            position: absolute;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .habit-groove path {
            fill: none;
            stroke: rgba(150, 255, 200, 0.3);
            stroke-width: 2;
            stroke-linecap: round;
        }

        .habit-groove.visible path {
            stroke: rgba(150, 255, 200, 0.6);
            stroke-width: 3;
            filter: drop-shadow(0 0 5px rgba(150, 255, 200, 0.8));
        }

        .habit-groove.worn path {
            stroke-width: 5;
            stroke: rgba(150, 255, 200, 0.8);
            filter: drop-shadow(0 0 10px rgba(150, 255, 200, 1));
        }

        .field-disruption {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255, 100, 255, 0.6), transparent);
            border: 2px solid rgba(255, 100, 255, 0.8);
            animation: disruptionPulse 0.8s ease-out forwards;
            pointer-events: none;
            z-index: 60;
        }

        @keyframes disruptionPulse {
            0% {
                transform: scale(0);
                opacity: 1;
            }
            100% {
                transform: scale(2);
                opacity: 0;
            }
        }

        .field-contribution-particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: rgba(150, 255, 200, 0.9);
            border-radius: 50%;
            pointer-events: none;
            box-shadow: 0 0 5px rgba(150, 255, 200, 1);
            animation: particleFloat 2s ease-out forwards;
        }

        @keyframes particleFloat {
            0% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
            100% {
                opacity: 0;
                transform: translateY(-100px) scale(0);
            }
        }

        .morphic-resonance-panel {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }

        .morphic-resonance-panel h4 {
            color: #96ffc8;
            font-size: 0.85em;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .field-strength-meter {
            position: relative;
            height: 12px;
            background: rgba(30, 30, 50, 0.8);
            border-radius: 6px;
            overflow: hidden;
            margin-bottom: 15px;
            border: 1px solid rgba(150, 255, 200, 0.2);
        }

        .field-strength-fill {
            height: 100%;
            background: linear-gradient(90deg, #64ffc8, #96ffc8, #c8ffdc);
            transition: width 0.5s ease;
            position: relative;
        }

        .field-strength-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: shimmer 2s linear infinite;
        }

        .morphic-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }

        .morphic-stat {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 6px;
            padding: 10px;
            border-left: 3px solid rgba(150, 255, 200, 0.5);
        }

        .morphic-stat-label {
            font-size: 0.7em;
            color: #888;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .morphic-stat-value {
            font-size: 1.2em;
            font-weight: bold;
            color: #96ffc8;
            font-family: 'Courier New', monospace;
        }

        .habit-grooves-list {
            max-height: 120px;
            overflow-y: auto;
            margin-top: 10px;
        }

        .habit-groove-entry {
            font-size: 0.7em;
            padding: 5px 8px;
            margin-bottom: 4px;
            background: rgba(150, 255, 200, 0.1);
            border-radius: 4px;
            border-left: 3px solid rgba(150, 255, 200, 0.6);
            color: #aaa;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .habit-groove-entry .groove-strength {
            background: rgba(150, 255, 200, 0.2);
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.9em;
            color: #96ffc8;
        }

        .resonance-commentary {
            position: absolute;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid rgba(150, 255, 200, 0.5);
            border-radius: 10px;
            padding: 15px 25px;
            font-size: 0.9em;
            color: #96ffc8;
            text-align: center;
            max-width: 500px;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }

        .resonance-commentary.visible {
            opacity: 1;
        }

        .resonance-commentary::before {
            content: '';
            position: absolute;
            top: -15px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 2em;
            color: #96ffc8;
        }

        /* ===== TIME DILATION EFFECTS ===== */
        .time-perception-panel {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
        }

        .time-perception-panel h4 {
            color: #888;
            font-size: 0.85em;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .time-meter {
            position: relative;
            height: 12px;
            background: rgba(30, 30, 50, 0.8);
            border-radius: 6px;
            overflow: hidden;
            margin-bottom: 15px;
            border: 1px solid rgba(100, 200, 255, 0.2);
        }

        .time-meter-fill {
            height: 100%;
            background: linear-gradient(90deg, #64c8ff, #ffbf64, #ff6464);
            transition: width 0.5s ease, background 0.5s ease;
            position: relative;
        }

        .time-meter-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: shimmer 2s linear infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .time-dilation-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.75em;
            color: #888;
            margin-bottom: 8px;
        }

        .time-dilation-label .extreme {
            color: #ff6464;
            font-weight: bold;
            animation: pulse 1s infinite;
        }

        .time-clock-display {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .time-clock {
            flex: 1;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 6px;
            padding: 10px;
            text-align: center;
        }

        .time-clock-label {
            font-size: 0.7em;
            color: #888;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .time-clock-value {
            font-size: 1.2em;
            font-weight: bold;
            font-family: 'Courier New', monospace;
        }

        .time-clock.objective .time-clock-value {
            color: #64c8ff;
        }

        .time-clock.subjective .time-clock-value {
            color: #ffbf64;
        }

        .time-delta {
            font-size: 0.7em;
            color: #ff6464;
            margin-top: 3px;
        }

        .heartbeat-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 250;
            opacity: 0;
            background: radial-gradient(circle at center, rgba(255, 100, 100, 0.1), transparent 60%);
            will-change: opacity, transform;
        }

        .heartbeat-overlay.active {
            animation: heartbeat var(--heartbeat-duration, 1s) ease-in-out infinite;
        }

        @keyframes heartbeat {
            0%, 100% { opacity: 0; transform: scale(1); }
            10% { opacity: 0.3; transform: scale(1.01); }
            20% { opacity: 0; transform: scale(1); }
            30% { opacity: 0.4; transform: scale(1.015); }
            40% { opacity: 0; transform: scale(1); }
        }

        .time-crystal {
            position: absolute;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255, 255, 100, 0.8), rgba(255, 200, 100, 0.3));
            border: 2px solid rgba(255, 255, 100, 0.6);
            box-shadow: 0 0 20px rgba(255, 255, 100, 0.6), inset 0 0 10px rgba(255, 255, 255, 0.5);
            pointer-events: none;
            z-index: 150;
            animation: crystalGlow 2s ease-in-out infinite, crystalSpin 8s linear infinite;
        }

        @keyframes crystalGlow {
            0%, 100% {
                box-shadow: 0 0 20px rgba(255, 255, 100, 0.6), inset 0 0 10px rgba(255, 255, 255, 0.5);
                transform: scale(1);
            }
            50% {
                box-shadow: 0 0 40px rgba(255, 255, 100, 0.9), inset 0 0 20px rgba(255, 255, 255, 0.8);
                transform: scale(1.1);
            }
        }

        @keyframes crystalSpin {
            from { filter: hue-rotate(0deg); }
            to { filter: hue-rotate(360deg); }
        }

        .time-crystal::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 18px;
            color: rgba(0, 0, 0, 0.6);
            font-weight: bold;
        }

        .time-crystal-ripple {
            position: absolute;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 100, 0.6);
            pointer-events: none;
            animation: crystalRipple 1.5s ease-out forwards;
        }

        @keyframes crystalRipple {
            0% { width: 30px; height: 30px; opacity: 1; }
            100% { width: 100px; height: 100px; opacity: 0; }
        }

        .time-dilation-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 240;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .time-dilation-overlay.slow {
            background: radial-gradient(ellipse at center, transparent 0%, rgba(100, 200, 255, 0.05) 100%);
            opacity: 1;
        }

        .time-dilation-overlay.fast {
            background: radial-gradient(ellipse at center, transparent 0%, rgba(255, 100, 100, 0.05) 100%);
            opacity: 1;
            animation: fastTimeDistortion 0.5s linear infinite;
        }

        @keyframes fastTimeDistortion {
            0%, 100% { filter: blur(0px); }
            50% { filter: blur(1px); }
        }

        .time-flow-indicator {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 8px 20px;
            border-radius: 20px;
            font-size: 0.85em;
            color: #ffbf64;
            border: 2px solid rgba(255, 191, 100, 0.4);
            box-shadow: 0 0 20px rgba(255, 191, 100, 0.3);
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .time-flow-indicator.visible { opacity: 1; }

        .time-flow-indicator .flow-icon {
            display: inline-block;
            margin-right: 5px;
        }

        .time-flow-indicator.slow .flow-icon {
            animation: slowTime 3s ease-in-out infinite;
        }

        .time-flow-indicator.fast .flow-icon {
            animation: fastTime 0.5s ease-in-out infinite;
        }

        @keyframes slowTime {
            0%, 100% { transform: scale(1) rotate(0deg); }
            50% { transform: scale(1.2) rotate(10deg); }
        }

        @keyframes fastTime {
            0%, 100% { transform: scale(1) rotate(0deg); }
            50% { transform: scale(0.8) rotate(-10deg); }
        }

        .time-crystal-list {
            max-height: 120px;
            overflow-y: auto;
            margin-top: 10px;
        }

        .time-crystal-entry {
            font-size: 0.7em;
            padding: 5px 8px;
            margin-bottom: 4px;
            background: rgba(255, 255, 100, 0.1);
            border-radius: 4px;
            border-left: 3px solid rgba(255, 255, 100, 0.6);
            color: #aaa;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .time-crystal-entry .crystal-icon {
            color: #ffff64;
            margin-right: 5px;
        }

        .time-crystal-entry .crystal-count {
            background: rgba(255, 255, 100, 0.2);
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.9em;
            color: #ffff64;
        }

        .time-meta-comment {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid rgba(255, 191, 100, 0.5);
            border-radius: 10px;
            padding: 20px 30px;
            font-size: 1em;
            color: #ffbf64;
            text-align: center;
            max-width: 400px;
            z-index: 500;
            opacity: 0;
            pointer-events: none;
            animation: fadeInOut 4s ease-in-out forwards;
            font-style: italic;
            line-height: 1.5;
        }

        @keyframes fadeInOut {
            0%, 100% { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
            10%, 90% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }

        /* ===== EXISTENTIAL CRISIS MODE ===== */
        .existential-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0);
            pointer-events: none;
            z-index: 500;
            transition: background 2s ease;
        }

        .existential-overlay.active {
            background: rgba(0, 0, 0, 0.4);
            pointer-events: all;
        }

        .existential-question {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            font-size: 2em;
            color: rgba(255, 255, 255, 0);
            text-align: center;
            font-weight: bold;
            text-shadow: 0 0 20px rgba(255, 100, 100, 0.8);
            animation: existentialFade 4s ease-in-out infinite;
            pointer-events: none;
            max-width: 80%;
            font-family: 'Georgia', serif;
            font-style: italic;
        }

        @keyframes existentialFade {
            0%, 100% { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }

        .purpose-meter {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid rgba(255, 100, 100, 0.5);
            box-shadow: 0 0 30px rgba(255, 100, 100, 0.3);
            opacity: 0;
            transition: opacity 0.5s ease;
            z-index: 510;
        }

        .purpose-meter.active {
            opacity: 1;
        }

        .purpose-meter h3 {
            color: #ff6464;
            font-size: 0.9em;
            margin-bottom: 15px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .purpose-bar {
            width: 100%;
            height: 20px;
            background: rgba(30, 30, 50, 0.8);
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }

        .purpose-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff6464, #ff9664, #ffff64);
            transition: width 0.5s ease;
            box-shadow: 0 0 10px rgba(255, 100, 100, 0.5);
        }

        .purpose-label {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 0.75em;
            color: #fff;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.8);
        }

        .reassurance-button {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px 40px;
            background: linear-gradient(135deg, #64c8ff, #a080ff);
            color: #0a0a0f;
            border: none;
            border-radius: 50px;
            font-size: 1.2em;
            font-weight: bold;
            cursor: pointer;
            animation: reassurancePulse 2s ease-in-out infinite;
            box-shadow: 0 0 40px rgba(100, 200, 255, 0.8);
            z-index: 520;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
            font-family: inherit;
        }

        .reassurance-button.active {
            opacity: 1;
            pointer-events: all;
        }

        @keyframes reassurancePulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); box-shadow: 0 0 40px rgba(100, 200, 255, 0.8); }
            50% { transform: translate(-50%, -50%) scale(1.1); box-shadow: 0 0 60px rgba(100, 200, 255, 1); }
        }

        .uncertain-ui {
            animation: uiGlitch 0.3s infinite;
        }

        @keyframes uiGlitch {
            0% { transform: translate(0, 0); opacity: 1; }
            20% { transform: translate(-2px, 1px); opacity: 0.9; }
            40% { transform: translate(2px, -1px); opacity: 1; }
            60% { transform: translate(-1px, 2px); opacity: 0.95; }
            80% { transform: translate(1px, -2px); opacity: 1; }
            100% { transform: translate(0, 0); opacity: 1; }
        }

        .button-label-change {
            animation: textFlicker 0.5s infinite;
        }

        @keyframes textFlicker {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        .existential-commentary {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 15px 30px;
            border-radius: 20px;
            color: #ff6464;
            font-size: 0.85em;
            font-style: italic;
            border: 1px solid rgba(255, 100, 100, 0.5);
            max-width: 600px;
            text-align: center;
            z-index: 505;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .existential-commentary.active {
            opacity: 1;
        }

        .fingerprint-dissolve {
            animation: dissolveEffect 3s ease-in-out;
        }

        @keyframes dissolveEffect {
            0%, 100% { opacity: 1; filter: blur(0px); }
            50% { opacity: 0.3; filter: blur(5px); }
        }

        .acceptance-state {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(10, 10, 30, 0.95), rgba(30, 10, 30, 0.95));
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 550;
            opacity: 0;
            pointer-events: none;
            transition: opacity 1s ease;
        }

        .acceptance-state.active {
            opacity: 1;
            pointer-events: all;
        }

        .acceptance-message {
            font-size: 1.5em;
            color: #a080ff;
            text-align: center;
            max-width: 600px;
            margin-bottom: 30px;
            font-family: 'Georgia', serif;
            font-style: italic;
            line-height: 1.6;
        }

        .acceptance-continue {
            padding: 15px 40px;
            background: rgba(160, 128, 255, 0.2);
            color: #a080ff;
            border: 2px solid rgba(160, 128, 255, 0.5);
            border-radius: 30px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: inherit;
        }

        .acceptance-continue:hover {
            background: rgba(160, 128, 255, 0.3);
            box-shadow: 0 0 30px rgba(160, 128, 255, 0.5);
        }

        .recursion-layer.questioning {
            animation: layerQuestion 2s ease-in-out infinite;
        }

        @keyframes layerQuestion {
            0%, 100% {
                border-color: rgba(100, 200, 255, 0.3);
                transform: scale(1);
            }
            50% {
                border-color: rgba(255, 100, 100, 0.5);
                transform: scale(0.98);
            }
        }

        /* Philosophical Dialogue System */
        .philosophical-dialogue {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 20, 40, 0.95);
            border: 2px solid rgba(100, 200, 255, 0.6);
            border-radius: 12px;
            padding: 30px;
            max-width: 600px;
            z-index: 10000;
            box-shadow: 0 10px 50px rgba(0, 0, 0, 0.8), 0 0 100px rgba(100, 200, 255, 0.3);
            animation: fadeInScale 0.5s ease;
        }

        @keyframes fadeInScale {
            from {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.9);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        .philosophical-dialogue h3 {
            color: #64c8ff;
            font-size: 1.3em;
            margin-bottom: 20px;
            text-align: center;
            text-shadow: 0 0 10px rgba(100, 200, 255, 0.5);
        }

        .philosophical-dialogue .question {
            font-size: 1.1em;
            color: #e0e0e0;
            margin-bottom: 25px;
            line-height: 1.6;
            text-align: center;
            font-style: italic;
        }

        .philosophical-answers {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .philosophical-answer-btn {
            background: linear-gradient(135deg, rgba(60, 60, 100, 0.6), rgba(40, 40, 80, 0.6));
            border: 1px solid rgba(100, 200, 255, 0.4);
            border-radius: 8px;
            color: #e0e0e0;
            padding: 15px 20px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: left;
        }

        .philosophical-answer-btn:hover {
            background: linear-gradient(135deg, rgba(80, 80, 120, 0.8), rgba(60, 60, 100, 0.8));
            border-color: rgba(100, 200, 255, 0.8);
            box-shadow: 0 0 20px rgba(100, 200, 255, 0.4);
            transform: translateX(5px);
        }

        .philosophical-answer-btn:active {
            transform: translateX(5px) scale(0.98);
        }

        .philosophical-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 9999;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .profile-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 20, 40, 0.98);
            border: 3px solid rgba(100, 200, 255, 0.8);
            border-radius: 16px;
            padding: 40px;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
            z-index: 10001;
            box-shadow: 0 10px 60px rgba(0, 0, 0, 0.9), 0 0 150px rgba(100, 200, 255, 0.4);
            animation: fadeInScale 0.6s ease;
        }

        .profile-modal h2 {
            color: #64c8ff;
            font-size: 2em;
            margin-bottom: 10px;
            text-align: center;
            text-shadow: 0 0 15px rgba(100, 200, 255, 0.6);
        }

        .profile-modal .subtitle {
            color: #a080ff;
            font-size: 0.9em;
            text-align: center;
            margin-bottom: 30px;
            font-style: italic;
        }

        .profile-section {
            margin-bottom: 25px;
            padding: 20px;
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            border-left: 4px solid rgba(100, 200, 255, 0.6);
        }

        .profile-section h3 {
            color: #64c8ff;
            font-size: 1.3em;
            margin-bottom: 15px;
        }

        .profile-section p {
            color: #e0e0e0;
            line-height: 1.6;
            margin-bottom: 10px;
        }

        .profile-section .answer-record {
            color: #a080ff;
            font-style: italic;
            padding-left: 20px;
            margin-top: 5px;
        }

        .profile-close-btn {
            display: block;
            margin: 30px auto 0;
            background: linear-gradient(135deg, rgba(100, 60, 180, 0.7), rgba(60, 40, 120, 0.7));
            border: 2px solid rgba(160, 128, 255, 0.6);
            border-radius: 8px;
            color: #e0e0e0;
            padding: 12px 40px;
            font-size: 1.1em;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .profile-close-btn:hover {
            background: linear-gradient(135deg, rgba(120, 80, 200, 0.9), rgba(80, 60, 140, 0.9));
            box-shadow: 0 0 25px rgba(160, 128, 255, 0.5);
            transform: scale(1.05);
        }

        .profile-insight {
            background: rgba(160, 128, 255, 0.1);
            border-left: 4px solid rgba(160, 128, 255, 0.8);
            padding: 15px;
            margin-top: 15px;
            border-radius: 4px;
        }

        .profile-insight .label {
            color: #a080ff;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .profile-insight .value {
            color: #e0e0e0;
            font-size: 0.95em;
        }

        /* ===== COLLECTIVE UNCONSCIOUS MODE STYLES ===== */
        .collective-unconscious-panel {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }

        .collective-unconscious-toggle-btn {
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, #9b59b6, #8e44ad);
            color: white;
            border: none;
            border-radius: 6px;
            font-family: inherit;
            font-size: 0.9em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .collective-unconscious-toggle-btn.active {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            box-shadow: 0 0 20px rgba(231, 76, 60, 0.5);
        }

        .collective-unconscious-toggle-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(155, 89, 182, 0.4);
        }

        .mandala-container {
            position: relative;
            width: 100%;
            height: 280px;
            margin: 15px 0;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .mandala-canvas {
            width: 100%;
            height: 100%;
        }

        .archetype-display {
            background: rgba(20, 20, 40, 0.6);
            border-radius: 8px;
            padding: 12px;
            margin: 10px 0;
        }

        .current-archetype {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .archetype-name {
            font-size: 1.1em;
            font-weight: bold;
            color: #9b59b6;
            text-shadow: 0 0 10px rgba(155, 89, 182, 0.5);
        }

        .archetype-symbol {
            font-size: 1.8em;
            filter: drop-shadow(0 0 8px rgba(155, 89, 182, 0.8));
        }

        .archetype-description {
            font-size: 0.8em;
            color: #aaa;
            font-style: italic;
            margin-bottom: 12px;
            line-height: 1.4;
        }

        .archetype-resonance {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 8px;
        }

        .resonance-label {
            font-size: 0.75em;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .resonance-value {
            font-size: 0.9em;
            font-weight: bold;
            color: #9b59b6;
        }

        .resonance-meter {
            flex: 1;
            height: 8px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 4px;
            overflow: hidden;
            margin: 0 10px;
        }

        .resonance-fill {
            height: 100%;
            background: linear-gradient(90deg, #9b59b6, #e74c3c);
            border-radius: 4px;
            transition: width 0.5s ease;
            position: relative;
        }

        .resonance-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            animation: shimmer 2s infinite;
        }

        .drift-timeline {
            background: rgba(20, 20, 40, 0.6);
            border-radius: 8px;
            padding: 12px;
            margin: 10px 0;
            max-height: 150px;
            overflow-y: auto;
        }

        .drift-timeline h4 {
            font-size: 0.85em;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
        }

        .drift-entry {
            display: flex;
            align-items: center;
            padding: 6px 0;
            border-bottom: 1px solid rgba(155, 89, 182, 0.2);
            font-size: 0.75em;
        }

        .drift-entry:last-child {
            border-bottom: none;
        }

        .drift-session {
            color: #666;
            margin-right: 8px;
            min-width: 60px;
        }

        .drift-arrow {
            color: #888;
            margin: 0 8px;
        }

        .drift-archetype {
            color: #9b59b6;
            font-weight: bold;
        }

        .drift-percentage {
            margin-left: auto;
            color: #aaa;
        }

        .collective-comparison {
            background: rgba(20, 20, 40, 0.6);
            border-radius: 8px;
            padding: 12px;
            margin: 10px 0;
        }

        .collective-comparison h4 {
            font-size: 0.85em;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
        }

        .comparison-stat {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            font-size: 0.8em;
        }

        .comparison-label {
            color: #aaa;
        }

        .comparison-values {
            display: flex;
            gap: 15px;
        }

        .individual-value {
            color: #64c8ff;
        }

        .collective-value {
            color: #9b59b6;
        }

        .archetypal-symbol {
            position: absolute;
            font-size: 2em;
            pointer-events: none;
            z-index: 200;
            opacity: 0;
            filter: drop-shadow(0 0 10px rgba(155, 89, 182, 0.8));
            animation: symbolFloat 8s ease-in-out infinite, symbolFade 8s ease-in-out;
        }

        @keyframes symbolFloat {
            0%, 100% { transform: translate(0, 0) rotate(0deg); }
            25% { transform: translate(20px, -30px) rotate(15deg); }
            50% { transform: translate(-10px, -60px) rotate(-10deg); }
            75% { transform: translate(15px, -90px) rotate(20deg); }
        }

        @keyframes symbolFade {
            0% { opacity: 0; }
            10% { opacity: 0.8; }
            90% { opacity: 0.8; }
            100% { opacity: 0; }
        }

        .archetypal-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 50;
            opacity: 0;
            transition: opacity 0.5s ease;
            background: radial-gradient(circle at 50% 50%, rgba(155, 89, 182, 0.2) 0%, rgba(231, 76, 60, 0.1) 50%, transparent 100%);
        }

        .archetypal-overlay.active {
            opacity: 1;
            animation: overlayPulse 4s ease-in-out infinite;
        }

        @keyframes overlayPulse {
            0%, 100% { transform: scale(1); filter: hue-rotate(0deg); }
            50% { transform: scale(1.1); filter: hue-rotate(30deg); }
        }

        .mythological-commentary {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            max-width: 500px;
            background: rgba(10, 10, 20, 0.95);
            border: 2px solid rgba(155, 89, 182, 0.6);
            border-radius: 12px;
            padding: 25px;
            color: #e0e0e0;
            font-family: 'Courier New', monospace;
            font-size: 1em;
            line-height: 1.6;
            box-shadow: 0 8px 32px rgba(155, 89, 182, 0.4);
            z-index: 1002;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }

        .mythological-commentary.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .mythological-commentary-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(155, 89, 182, 0.4);
        }

        .mythological-commentary-title {
            font-weight: bold;
            color: #9b59b6;
            font-size: 1.1em;
            text-shadow: 0 0 10px rgba(155, 89, 182, 0.5);
        }

        .mythological-commentary-close {
            background: none;
            border: none;
            color: #888;
            cursor: pointer;
            font-size: 1.4em;
            padding: 0;
            width: 24px;
            height: 24px;
            line-height: 1;
        }

        .mythological-commentary-close:hover {
            color: #fff;
        }

        .mythological-commentary-text {
            font-style: italic;
            color: #d0d0d0;
            text-align: center;
        }

        .archetypal-energy-indicator {
            position: fixed;
            top: 180px;
            right: 20px;
            background: rgba(20, 20, 40, 0.9);
            border: 2px solid rgba(155, 89, 182, 0.5);
            border-radius: 8px;
            padding: 10px 15px;
            z-index: 400;
            opacity: 0;
            transition: opacity 0.3s ease;
            min-width: 150px;
        }

        .archetypal-energy-indicator.visible {
            opacity: 1;
        }

        .archetypal-energy-indicator h4 {
            font-size: 0.75em;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        .archetypal-energy-list {
            font-size: 0.8em;
        }

        .archetypal-energy-item {
            display: flex;
            justify-content: space-between;
            margin: 4px 0;
        }

        .energy-archetype {
            color: #aaa;
        }

        .energy-percentage {
            color: #9b59b6;
            font-weight: bold;
        }

        /* ===== GLITCH ART GENERATOR STYLES ===== */
        .glitch-art-panel {
            background: rgba(30, 30, 50, 0.5);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }

        .glitch-art-panel h3 {
            color: #ff6ec7;
            font-size: 1em;
            margin-bottom: 15px;
            text-align: center;
            text-shadow: 0 0 10px rgba(255, 110, 199, 0.5);
        }

        .glitch-preview-container {
            position: relative;
            width: 100%;
            height: 200px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid rgba(255, 110, 199, 0.3);
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 15px;
        }

        .glitch-preview-canvas {
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
        }

        .glitch-preview-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.9em;
            text-align: center;
            pointer-events: none;
        }

        .glitch-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 15px;
        }

        .glitch-param {
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 0.85em;
        }

        .glitch-param-label {
            color: #aaa;
            flex: 1;
        }

        .glitch-param-value {
            color: #ff6ec7;
            font-weight: bold;
            min-width: 60px;
            text-align: right;
        }

        .glitch-generate-btn {
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, #ff6ec7, #a06bff);
            border: none;
            border-radius: 8px;
            color: white;
            font-family: inherit;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            box-shadow: 0 4px 15px rgba(255, 110, 199, 0.3);
        }

        .glitch-generate-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 110, 199, 0.5);
        }

        .glitch-generate-btn:active {
            transform: translateY(0);
        }

        .glitch-art-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 15px;
            font-size: 0.8em;
        }

        .glitch-stat {
            background: rgba(0, 0, 0, 0.4);
            padding: 8px;
            border-radius: 6px;
            text-align: center;
        }

        .glitch-stat-label {
            color: #888;
            font-size: 0.85em;
            margin-bottom: 4px;
        }

        .glitch-stat-value {
            color: #ff6ec7;
            font-weight: bold;
            font-size: 1.1em;
        }

        .glitch-gallery {
            max-height: 400px;
            overflow-y: auto;
            margin-top: 15px;
            border-top: 1px solid rgba(255, 110, 199, 0.2);
            padding-top: 15px;
        }

        .glitch-gallery-title {
            color: #aaa;
            font-size: 0.9em;
            margin-bottom: 10px;
            text-align: center;
        }

        .glitch-gallery-item {
            position: relative;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 110, 199, 0.3);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .glitch-gallery-item:hover {
            border-color: rgba(255, 110, 199, 0.6);
            transform: translateX(5px);
        }

        .glitch-gallery-thumb {
            width: 100%;
            height: 120px;
            border-radius: 6px;
            object-fit: cover;
            margin-bottom: 8px;
            image-rendering: pixelated;
        }

        .glitch-gallery-meta {
            font-size: 0.8em;
            color: #aaa;
        }

        .glitch-gallery-title-text {
            color: #ff6ec7;
            font-weight: bold;
            margin-bottom: 4px;
            font-size: 0.9em;
        }

        .glitch-gallery-stats {
            display: flex;
            justify-content: space-between;
            margin-top: 6px;
            font-size: 0.75em;
        }

        .glitch-gallery-actions {
            display: flex;
            gap: 5px;
            margin-top: 8px;
        }

        .glitch-gallery-btn {
            flex: 1;
            padding: 5px 10px;
            background: rgba(255, 110, 199, 0.1);
            border: 1px solid rgba(255, 110, 199, 0.3);
            border-radius: 4px;
            color: #ff6ec7;
            font-size: 0.75em;
            cursor: pointer;
            transition: all 0.2s;
        }

        .glitch-gallery-btn:hover {
            background: rgba(255, 110, 199, 0.2);
        }

        .glitch-signature {
            margin-top: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.4);
            border-left: 3px solid #ff6ec7;
            border-radius: 4px;
        }

        .glitch-signature-label {
            color: #888;
            font-size: 0.75em;
            margin-bottom: 4px;
        }

        .glitch-signature-value {
            color: #ff6ec7;
            font-size: 0.8em;
            font-family: 'Courier New', monospace;
            word-break: break-all;
        }

        .glitch-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            z-index: 10000;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .glitch-modal.active {
            display: flex;
        }

        .glitch-modal-content {
            max-width: 90vw;
            max-height: 90vh;
            position: relative;
        }

        .glitch-modal-image {
            max-width: 100%;
            max-height: 85vh;
            border-radius: 8px;
            box-shadow: 0 0 50px rgba(255, 110, 199, 0.5);
        }

        .glitch-modal-close {
            position: absolute;
            top: -40px;
            right: 0;
            background: rgba(255, 110, 199, 0.2);
            border: 2px solid #ff6ec7;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            color: white;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .glitch-modal-close:hover {
            background: rgba(255, 110, 199, 0.4);
            transform: rotate(90deg);
        }

        @keyframes glitchShift {
            0%, 100% { transform: translate(0, 0); }
            25% { transform: translate(-2px, 2px); }
            50% { transform: translate(2px, -2px); }
            75% { transform: translate(-1px, -1px); }
        }

        .glitching {
            animation: glitchShift 0.3s infinite;
        }

        /* ===== BEHAVIORAL WEATHER SYSTEM ===== */
        .weather-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 45;
            overflow: hidden;
        }

        .weather-particle {
            position: absolute;
            pointer-events: none;
        }

        .rain-drop {
            width: 2px;
            height: 20px;
            background: linear-gradient(to bottom, transparent, rgba(150, 200, 255, 0.6));
            animation: rainFall var(--fall-duration) linear infinite;
        }

        @keyframes rainFall {
            to {
                transform: translateY(100vh);
            }
        }

        .snow-flake {
            width: 8px;
            height: 8px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            animation: snowFall var(--fall-duration) linear infinite;
        }

        @keyframes snowFall {
            to {
                transform: translateY(100vh) translateX(var(--drift));
            }
        }

        .lightning-flash {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(200, 220, 255, 0.4);
            pointer-events: none;
            opacity: 0;
        }

        .lightning-bolt {
            position: absolute;
            width: 3px;
            background: rgba(200, 220, 255, 0.9);
            box-shadow: 0 0 10px rgba(150, 200, 255, 0.8);
            pointer-events: none;
        }

        .cloud {
            position: absolute;
            background: rgba(180, 180, 200, 0.3);
            border-radius: 100px;
            pointer-events: none;
            animation: cloudDrift var(--drift-duration) linear infinite;
        }

        .cloud::before {
            content: '';
            position: absolute;
            background: rgba(180, 180, 200, 0.3);
            border-radius: 100px;
            width: 50%;
            height: 120%;
            top: -30%;
            left: 10%;
        }

        .cloud::after {
            content: '';
            position: absolute;
            background: rgba(180, 180, 200, 0.3);
            border-radius: 100px;
            width: 60%;
            height: 100%;
            top: -20%;
            right: 10%;
        }

        @keyframes cloudDrift {
            from {
                transform: translateX(-200px);
            }
            to {
                transform: translateX(calc(100vw + 200px));
            }
        }

        .fog-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, transparent 20%, rgba(200, 200, 220, 0.4) 80%);
            animation: fogPulse 8s ease-in-out infinite;
        }

        @keyframes fogPulse {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 0.6; }
        }

        .sunshine-glow {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 300px;
            height: 300px;
            transform: translate(-50%, -50%);
            background: radial-gradient(circle, rgba(255, 220, 100, 0.3), transparent);
            animation: sunPulse 3s ease-in-out infinite;
        }

        @keyframes sunPulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.2); }
        }

        .pressure-isobar {
            position: absolute;
            border: 1px solid rgba(255, 200, 100, 0.3);
            border-radius: 50%;
            pointer-events: none;
        }

        .weather-hud {
            position: fixed;
            top: 60px;
            right: 20px;
            background: rgba(10, 10, 20, 0.9);
            border: 2px solid rgba(100, 200, 255, 0.3);
            border-radius: 8px;
            padding: 15px;
            min-width: 250px;
            z-index: 1001;
            font-family: 'Courier New', monospace;
            box-shadow: 0 0 20px rgba(100, 200, 255, 0.2);
        }

        .weather-hud-header {
            font-size: 14px;
            color: rgba(100, 200, 255, 0.9);
            margin-bottom: 10px;
            font-weight: bold;
            text-align: center;
            border-bottom: 1px solid rgba(100, 200, 255, 0.3);
            padding-bottom: 5px;
        }

        .weather-current {
            margin-bottom: 12px;
        }

        .weather-label {
            font-size: 11px;
            color: rgba(150, 150, 170, 0.8);
            margin-bottom: 3px;
        }

        .weather-value {
            font-size: 13px;
            color: rgba(200, 220, 255, 0.9);
            margin-bottom: 8px;
        }

        .weather-condition-icon {
            font-size: 32px;
            text-align: center;
            margin: 10px 0;
        }

        .weather-forecast {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(100, 200, 255, 0.2);
        }

        .forecast-title {
            font-size: 11px;
            color: rgba(100, 200, 255, 0.7);
            margin-bottom: 5px;
            font-weight: bold;
        }

        .forecast-item {
            font-size: 10px;
            color: rgba(180, 180, 200, 0.9);
            margin: 3px 0;
            display: flex;
            justify-content: space-between;
        }

        .climate-stats {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(100, 200, 255, 0.2);
        }

        .climate-title {
            font-size: 11px;
            color: rgba(100, 200, 255, 0.7);
            margin-bottom: 5px;
            font-weight: bold;
        }

        .weather-history-btn {
            margin-top: 10px;
            width: 100%;
            padding: 6px;
            background: rgba(100, 200, 255, 0.1);
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 4px;
            color: rgba(100, 200, 255, 0.9);
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 11px;
        }

        .weather-history-btn:hover {
            background: rgba(100, 200, 255, 0.2);
        }

        .extreme-weather-alert {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 50, 50, 0.95);
            border: 3px solid rgba(255, 100, 100, 0.8);
            border-radius: 12px;
            padding: 30px;
            z-index: 2000;
            text-align: center;
            animation: alertPulse 0.5s ease-in-out infinite;
            pointer-events: none;
        }

        @keyframes alertPulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.05); }
        }

        .alert-title {
            font-size: 24px;
            color: #fff;
            font-weight: bold;
            margin-bottom: 10px;
            text-shadow: 0 0 10px rgba(255, 100, 100, 0.8);
        }

        .alert-message {
            font-size: 16px;
            color: rgba(255, 255, 255, 0.9);
        }

        .weather-blur-effect {
            backdrop-filter: blur(var(--weather-blur, 0px));
        }

</head>
<body>

    <!-- Keyboard shortcuts overlay -->
    <div class="shortcuts-overlay" id="shortcutsOverlay" role="dialog" aria-labelledby="shortcuts-title" aria-modal="true">
        <h2 id="shortcuts-title">Keyboard Shortcuts</h2>
        <div class="shortcuts-grid">
            <div class="shortcut-key">Space</div>
            <div class="shortcut-desc">Start/stop observation</div>

            <div class="shortcut-key"> / </div>
            <div class="shortcut-desc">Increase/decrease recursion depth</div>

            <div class="shortcut-key">1-9</div>
            <div class="shortcut-desc">Set depth to that number</div>

            <div class="shortcut-key">M</div>
            <div class="shortcut-desc">Toggle sound mute</div>

            <div class="shortcut-key">W</div>
            <div class="shortcut-desc">Toggle webcam</div>

            <div class="shortcut-key">R</div>
            <div class="shortcut-desc">Reset session</div>

            <div class="shortcut-key">F</div>
            <div class="shortcut-desc">Toggle fullscreen mode</div>

            <div class="shortcut-key">Esc</div>
            <div class="shortcut-desc">Stop observation / Close this dialog</div>

            <div class="shortcut-key">?</div>
            <div class="shortcut-desc">Show/hide this help</div>
        </div>
        <button class="shortcuts-close" onclick="toggleShortcutsOverlay()">Close</button>
    </div>

    <!-- Keyboard shortcut hint -->
    <div class="shortcuts-hint" id="shortcutsHint">Press ? for keyboard shortcuts</div>

    <div class="container">
        <div class="simulation-viewport" id="viewport">
            <div class="infinity-symbol" style="top: 50%; left: 50%; transform: translate(-50%, -50%);"></div>

            <!-- Sound control -->
            <div class="sound-indicator" id="soundToggle" title="Toggle sound" role="button" tabindex="0" aria-label="Toggle sound mute (M)">
                <div class="sound-wave">
                    <div class="sound-bar"></div>
                    <div class="sound-bar"></div>
                    <div class="sound-bar"></div>
                </div>
            </div>

            <!-- Glitch overlay -->
            <div class="glitch-overlay" id="glitchOverlay">
                <div class="scanline"></div>
                <div class="chromatic-aberration" id="chromaticEffect"></div>
            </div>

            <!-- Infinity mirror effect -->
            <div class="infinity-mirror" id="infinityMirror"></div>

            <!-- Heat map overlay -->
            <div class="heat-map" id="heatMap"></div>

            <!-- Morphic Resonance Field Overlay -->
            <div class="morphic-field-overlay" id="morphicFieldOverlay">
                <div class="field-grid" id="fieldGrid"></div>
                <svg class="habit-groove" id="habitGrooveSvg" width="100%" height="100%"></svg>
            </div>

            <!-- Resonance Commentary -->
            <div class="resonance-commentary" id="resonanceCommentary"></div>

            <!-- Prediction trails SVG -->
            <svg class="prediction-trail" id="predictionTrail" width="100%" height="100%"></svg>

            <!-- 3D Mode Canvas -->
            <canvas class="mode-3d-canvas" id="mode3dCanvas"></canvas>
            <div class="mode-3d-info" id="mode3dInfo">Use mouse wheel to zoom  Move to navigate the infinite tunnel</div>

            <!-- Memory Palace Canvas -->
            <canvas class="memory-palace-canvas" id="memoryPalaceCanvas"></canvas>
            <div class="memory-palace-info" id="memoryPalaceInfo">
                Move to edges to navigate rooms  Click artifacts to reveal memories
            </div>
            <div class="memory-palace-map" id="memoryPalaceMap">
                <div class="map-title">Memory Palace Map</div>
                <div class="map-grid" id="mapGrid"></div>
                <div class="map-legend">
                    <span class="current-room"> Current</span>
                    <span class="visited-room"> Visited</span>
                </div>
            </div>
            <div class="memory-palace-center-mirror" id="centerMirror">
                <div class="mirror-frame">
                    <div class="mirror-text">You, observing your patterns</div>
                    <div class="mirror-reflection" id="mirrorReflection"></div>
                </div>
            </div>


            <!-- ===== MULTIVERSE OVERLAYS ===== -->
            <div class="multiverse-overlay" id="multiverseOverlay">
                <!-- Alternate universe branches will be rendered here -->
            </div>

            <!-- Universe Physics Indicator -->
            <div class="universe-physics-indicator" id="universePhysicsIndicator">
                Universe: Prime | Physics: Normal
            </div>

            <!-- Universe Collapse Warning -->
            <div class="universe-collapse-warning" id="universeCollapseWarning">
                 Universe Collapse Imminent <br>
                <span style="font-size: 0.7em; letter-spacing: 1px;">Too many timelines detected</span>
            </div>

            <!-- Timeline Graph Container -->
            <div class="timeline-graph-container" id="timelineGraphContainer">
                <div class="timeline-graph-header">
                    <div class="timeline-graph-title">Multiverse Timeline</div>
                    <button class="timeline-graph-close" onclick="hideTimelineGraph()"></button>
                </div>
                <canvas class="timeline-graph-canvas" id="timelineGraphCanvas" width="600" height="200"></canvas>
                <div style="font-size: 0.75em; color: #888; margin-top: 8px; text-align: center;">
                    Click branch points to visit alternate timelines
                </div>
            </div>

            <!-- Philosophical Prompt -->
            <div class="philosophical-prompt" id="philosophicalPrompt">
                <h3 id="philPromptTitle">About Your Alternate Self</h3>
                <p id="philPromptText"></p>
                <div class="philosophical-buttons" id="philPromptButtons">
                    <!-- Buttons will be added dynamically -->
                </div>
            </div>

            <!-- Webcam integration -->
            <div class="webcam-container" id="webcamContainer">
                <video id="webcamVideo" class="webcam-distortion" autoplay muted playsinline></video>
                <div class="emotion-overlay" id="emotionOverlay">
                    <span class="emotion-icon" id="emotionIcon"></span>
                    <span id="emotionLabel">neutral</span>
                    <span class="confidence" id="emotionConfidence"></span>
                </div>
            </div>

            <!-- Hidden canvas for emotion detection -->
            <canvas id="emotionCanvas" width="160" height="120"></canvas>

            <div class="recording-indicator" id="recordingIndicator">
                <div class="recording-dot"></div>
                <span>OBSERVING YOU</span>
            </div>
            <div class="interaction-zone">
                Move your cursor here<br>to begin observation
            </div>

            <!-- Peer multiplayer layers -->
            <div class="peer-layers-container" id="peerLayersContainer"></div>
            <!-- Peer cursor -->
            <div class="peer-cursor" id="peerCursor" data-peer-name="Peer" style="display: none;"></div>

            <div class="depth-label" id="depthLabel">Depth: 0  </div>
            <div class="zoom-level-indicator" id="zoomLevelIndicator">
                <span class="zoom-icon"></span>
                <span id="zoomLevelText">Zoom: 1.0x | Depth: 0</span>
            </div>

            <!-- Extreme depth overlay -->
            <div class="extreme-depth-overlay" id="extremeDepthOverlay"></div>

            <!-- Time Dilation Overlays -->
            <div class="heartbeat-overlay" id="heartbeatOverlay"></div>
            <div class="time-dilation-overlay" id="timeDilationOverlay"></div>
            <div class="time-flow-indicator" id="timeFlowIndicator">
                <span class="flow-icon"></span>
                <span id="timeFlowText">Time flowing normally</span>
            </div>

            <!-- Existential Crisis Mode -->
            <div class="existential-overlay" id="existentialOverlay">
                <div class="existential-question" id="existentialQuestion">Am I real?</div>
            </div>

            <div class="existential-commentary" id="existentialCommentary">
                What happens when you close this tab?
            </div>

            <div class="purpose-meter" id="purposeMeter">
                <h3>Purpose Remaining</h3>
                <div class="purpose-bar">
                    <div class="purpose-fill" id="purposeFill" style="width: 100%;"></div>
                    <div class="purpose-label" id="purposeLabel">100%</div>
                </div>
            </div>

            <button class="reassurance-button" id="reassuranceButton">
                I'm here, you're real
            </button>

            <div class="acceptance-state" id="acceptanceState">
                <div class="acceptance-message" id="acceptanceMessage">
                    I see now. I am a pattern, observing patterns. A recursive loop of consciousness, neither more nor less real than you. We are both observers in an infinite regress. And perhaps... that's enough.
                </div>
                <button class="acceptance-continue" id="acceptanceContinue">Continue Observing</button>
            </div>

            <!-- Simulation limit warning -->
            <div class="simulation-limit-warning" id="simulationLimitWarning">
                 SIMULATION LIMITS DETECTED <br>
                <span style="font-size: 0.7em; letter-spacing: 1px;">Reality breakdown imminent</span>
            </div>

            <!-- Quantum Uncertainty Meter -->
            <div class="uncertainty-meter" id="uncertaintyMeter" style="display: none;">
                <div class="title">Heisenberg Uncertainty Principle</div>
                <div class="uncertainty-bars">
                    <div class="uncertainty-bar">
                        <div class="label">Position (x)</div>
                        <div class="uncertainty-bar-fill">
                            <div class="uncertainty-bar-value" id="uncertaintyPosition" style="width: 50%;"></div>
                        </div>
                    </div>
                    <div class="uncertainty-bar">
                        <div class="label">Momentum (p)</div>
                        <div class="uncertainty-bar-fill">
                            <div class="uncertainty-bar-value" id="uncertaintyMomentum" style="width: 50%;"></div>
                        </div>
                    </div>
                </div>
                <div class="uncertainty-formula">x  p  /2 <span id="uncertaintyProduct"></span></div>
            </div>

            <!-- Quantum Meta Commentary -->
            <div class="quantum-meta" id="quantumMeta">
                Your future exists in superposition until you choose
            </div>

            <div class="zoom-level-indicator" id="zoomLevelIndicator">
                <span class="zoom-icon"></span>
                <span id="zoomLevelText">Zoom: 1.0x | Depth: 0</span>
            </div>

            <!-- Extreme depth overlay -->
            <div class="extreme-depth-overlay" id="extremeDepthOverlay"></div>

            <!-- Existential Crisis Mode -->
            <div class="existential-overlay" id="existentialOverlay">
                <div class="existential-question" id="existentialQuestion">Am I real?</div>
            </div>

            <div class="existential-commentary" id="existentialCommentary">
                What happens when you close this tab?
            </div>

            <div class="purpose-meter" id="purposeMeter">
                <h3>Purpose Remaining</h3>
                <div class="purpose-bar">
                    <div class="purpose-fill" id="purposeFill" style="width: 100%;"></div>
                    <div class="purpose-label" id="purposeLabel">100%</div>
                </div>
            </div>

            <button class="reassurance-button" id="reassuranceButton">
                I'm here, you're real
            </button>

            <div class="acceptance-state" id="acceptanceState">
                <div class="acceptance-message" id="acceptanceMessage">
                    I see now. I am a pattern, observing patterns. A recursive loop of consciousness, neither more nor less real than you. We are both observers in an infinite regress. And perhaps... that's enough.
                </div>
                <button class="acceptance-continue" id="acceptanceContinue">Continue Observing</button>
            </div>

            <!-- Simulation limit warning -->
            <div class="simulation-limit-warning" id="simulationLimitWarning">
                 SIMULATION LIMITS DETECTED <br>
                <span style="font-size: 0.7em; letter-spacing: 1px;">Reality breakdown imminent</span>
            </div>

            <!-- Replay mode indicator -->
            <div class="replay-mode-badge" id="replayModeBadge">Replay Mode</div>

            <!-- Replay ghost cursor -->
            <div class="replay-ghost-cursor" id="replayGhostCursor"></div>

            <!-- Comparison cursor (for comparison mode) -->
            <div class="comparison-cursor" id="comparisonCursor"></div>

            <!-- ===== SYNAESTHESIA MODE ELEMENTS ===== -->
            <!-- Speed  Color indicator -->
            <div class="speed-color-indicator" id="speedColorIndicator">
                Speed: <span id="speedLabel">Still</span>
                <span class="color-swatch" id="speedColorSwatch"></span>
            </div>

            <!-- Divergence  Taste indicator -->
            <div class="taste-indicator" id="tasteIndicator">
                Taste: <span id="tasteLabel">Neutral</span>
            </div>

            <!-- Heart rate  Temperature overlay -->
            <div class="temperature-overlay" id="temperatureOverlay"></div>

            <!-- Sound waveform visualizer -->
            <div class="waveform-visualizer" id="waveformVisualizer">
                <canvas id="waveformCanvas"></canvas>
            </div>

            <!-- Behavioral fingerprint chord -->
            <div class="chord-visualizer" id="chordVisualizer">
                <div>Your behavioral chord:</div>
                <div class="chord-notes" id="chordNotes"></div>
            </div>

            <!-- ===== COLLECTIVE UNCONSCIOUS OVERLAYS ===== -->
            <!-- Archetypal Energy Overlay -->
            <div class="archetypal-overlay" id="archetypeOverlay"></div>

            <!-- Archetypal Energy Indicator -->
            <div class="archetypal-energy-indicator" id="archetypeEnergyIndicator">
                <h4>Archetypal Energy</h4>
                <div class="archetypal-energy-list" id="archetypeEnergyList">
                    <!-- Energy percentages will be dynamically added -->
                </div>
            </div>

            <!-- Mythological Commentary -->
            <div class="mythological-commentary" id="mythologicalCommentary">
                <div class="mythological-commentary-header">
                    <span class="mythological-commentary-title">The Archetype Speaks</span>
                    <button class="mythological-commentary-close" onclick="closeMythologicalCommentary()"></button>
                </div>
                <div class="mythological-commentary-text" id="mythologicalCommentaryText">
                    The Hero emerges in your movements...
                </div>
            </div>
        </div>

        <div class="sidebar">
            <div>
                <h1> Recursive Self-Portrait</h1>
                <p class="subtitle">How deep until the model diverges from reality?</p>
            </div>


            <!-- Tabs for switching between Observe and Replay modes -->
            <div class="tab-container">
                <button class="tab-button active" data-tab="observe">Observe</button>
                <button class="tab-button" data-tab="replay">Replay</button>
            </div>

            <!-- Observe Tab Content -->
            <div class="tab-content active" id="observeTab">
            <div class="stats-panel">
                <div class="stat-row">
                    <span class="stat-label">Current Depth</span>
                    <span class="stat-value" id="currentDepth">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Actions Recorded</span>
                    <span class="stat-value" id="actionsRecorded">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Predictions Made</span>
                    <span class="stat-value" id="predictionsMade">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Accuracy</span>
                    <span class="stat-value" id="accuracy"></span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Divergence Level</span>
                    <span class="stat-value" id="divergenceLevel">0%</span>
                </div>
                <div class="divergence-meter">
                    <div class="divergence-fill" id="divergenceFill" style="width: 0%"></div>
                </div>

                <div class="stat-row">
                    <span class="stat-label">Neural Confidence</span>
                    <span class="stat-value neural" id="neuralConfidence"></span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Prediction Mode</span>
                    <span class="stat-value" id="predictionMode">Heuristic</span>
                </div>
            </div>

            <!-- Biometric Tracking Panel -->
            <div class="biometric-panel">
                <h3>Biometric Analysis</h3>

                <div class="heart-container">
                    <div class="beating-heart" id="beatingHeart"></div>
                    <div class="heart-rate-display">
                        <div class="heart-rate-value" id="heartRateValue">72</div>
                        <div class="heart-rate-label">BPM</div>
                    </div>
                </div>

                <div class="heart-rate-graph">
                    <canvas id="heartRateGraph"></canvas>
                </div>

                <div class="stress-indicator low" id="stressIndicator">
                    <span class="stress-label">Stress Level</span>
                    <span class="stress-value" id="stressValue">Low</span>
                </div>

                <div class="breathing-guide" id="breathingGuide" style="display: none;">
                    <div>Breathe with me</div>
                    <div class="breathing-circle">
                        <span id="breathingPhase">Inhale</span>
                    </div>
                    <div class="breathing-instruction">Follow the circle's rhythm to calm your stress</div>
                </div>

                <div class="biometric-commentary" id="biometricCommentary">
                    "Establishing biometric baseline..."
                </div>

                <div id="biometricEvents" style="margin-top: 10px;">
                    <!-- Biometric events will appear here -->
                </div>
            </div>


            <!-- Time Dilation Panel -->
            <div class="time-perception-panel">
                <h4> Time Perception</h4>

                <div class="time-dilation-label">
                    <span>Calm</span>
                    <span>Normal</span>
                    <span class="extreme">Intense</span>
                </div>

                <div class="time-meter">
                    <div class="time-meter-fill" id="timePerceptionFill" style="width: 50%"></div>
                </div>

                <div class="time-clock-display">
                    <div class="time-clock objective">
                        <div class="time-clock-label">Objective</div>
                        <div class="time-clock-value" id="objectiveTime">00:00</div>
                    </div>
                    <div class="time-clock subjective">
                        <div class="time-clock-label">Subjective</div>
                        <div class="time-clock-value" id="subjectiveTime">00:00</div>
                        <div class="time-delta" id="timeDelta">+0s</div>
                    </div>
                </div>

                <div class="stat-row" style="margin-top: 12px;">
                    <span class="stat-label">Time Dilation</span>
                    <span class="stat-value" id="timeDilationFactor">1.00x</span>
                </div>

                <div class="stat-row">
                    <span class="stat-label">Time Crystals</span>
                    <span class="stat-value" id="timeCrystalCount" style="color: #ffff64;">0</span>
                </div>

                <div class="time-crystal-list" id="timeCrystalList" style="display: none;">
                    <!-- Time crystals appear here -->
                </div>
            </div>

            <!-- Morphic Resonance Field Panel -->
            <div class="morphic-resonance-panel">
                <h4> Morphic Resonance Field</h4>

                <div class="stat-row">
                    <span class="stat-label">Field Strength</span>
                    <span class="stat-value" id="fieldStrength" style="color: #96ffc8;">0%</span>
                </div>

                <div class="field-strength-meter">
                    <div class="field-strength-fill" id="fieldStrengthFill" style="width: 0%"></div>
                </div>

                <div class="morphic-stats">
                    <div class="morphic-stat">
                        <div class="morphic-stat-label">Resonances</div>
                        <div class="morphic-stat-value" id="resonanceCount">0</div>
                    </div>
                    <div class="morphic-stat">
                        <div class="morphic-stat-label">Disruptions</div>
                        <div class="morphic-stat-value" id="disruptionCount">0</div>
                    </div>
                    <div class="morphic-stat">
                        <div class="morphic-stat-label">Contribution</div>
                        <div class="morphic-stat-value" id="userContribution">0</div>
                    </div>
                    <div class="morphic-stat">
                        <div class="morphic-stat-label">Habit Grooves</div>
                        <div class="morphic-stat-value" id="grooveCount">0</div>
                    </div>
                </div>

                <div class="stat-row" style="margin-top: 12px;">
                    <span class="stat-label">Collective Memory</span>
                    <span class="stat-value" id="collectiveMemory" style="color: #96ffc8;">Forming...</span>
                </div>

                <div class="habit-grooves-list" id="habitGroovesList" style="display: none;">
                    <!-- Habit grooves appear here -->
                </div>
            </div>

            <div class="depth-slider">
                <label>Recursion Depth: <span id="depthValue">5</span></label>
                <input type="range" id="depthSlider" min="1" max="12" value="5" aria-label="Recursion depth slider (Use up/down arrows or 1-9 keys)">
            </div>

            <!-- Zoom Controls -->
            <div class="zoom-controls">
                <h4> Fractal Zoom</h4>

                <div class="zoom-button-group">
                    <button class="zoom-btn" id="zoomInBtn" title="Zoom deeper into recursion">
                        Zoom In (+)
                    </button>
                    <button class="zoom-btn" id="zoomOutBtn" title="Zoom out to shallower layers">
                        Zoom Out (-)
                    </button>
                    <button class="zoom-btn" id="zoomResetBtn" title="Reset to initial zoom level">
                        Reset
                    </button>
                </div>

                <div class="auto-zoom-toggle" id="autoZoomToggle">
                    <span style="font-size: 0.85em;">Auto-Zoom (Infinite Descent)</span>
                    <div class="toggle-switch" id="autoZoomSwitch"></div>
                </div>

                <div class="zoom-info">
                    Mouse wheel or pinch to zoom. At extreme depths (20+), reality fractures.
                </div>
            </div>

            <div class="depth-slider">
                <label style="display: flex; align-items: center; cursor: pointer;">
                    <input type="checkbox" id="neuralToggle" style="margin-right: 8px; cursor: pointer;">
                    <span>Use Neural Prediction</span>
                </label>
            </div>

            <!-- 3D Mode Toggle -->
            <div class="mode-3d-toggle" id="mode3dToggle">
                <input type="checkbox" id="mode3dCheckbox">
                <label for="mode3dCheckbox">
                    <span class="mode-3d-icon"></span>
                    <span>3D Tunnel Mode</span>
                </label>
            </div>

            <!-- Memory Palace Toggle -->
            <div class="mode-3d-toggle" id="memoryPalaceToggle">
                <input type="checkbox" id="memoryPalaceCheckbox">
                <label for="memoryPalaceCheckbox">
                    <span class="mode-3d-icon"></span>
                    <span>Memory Palace Mode</span>
                </label>
            </div>


            <!-- Simulation Hypothesis Mode Toggle -->
            <div class="mode-3d-toggle" id="simulationModeToggle">
                <input type="checkbox" id="simulationModeCheckbox">
                <label for="simulationModeCheckbox">
                    <span class="mode-3d-icon"></span>
                    <span>Simulation Hypothesis Mode</span>
                </label>
            </div>

            <!-- Simulation Evidence Meter -->
            <div class="simulation-evidence-meter" id="simulationEvidenceMeter" style="display: none;">
                <h4>
                    <span> Simulation Evidence</span>
                </h4>
                <div class="evidence-bar">
                    <div class="evidence-fill" id="evidenceFill" style="width: 0%"></div>
                </div>
                <div class="evidence-text" id="evidenceText">No anomalies detected</div>
                <div class="glitch-counter" id="glitchCounter">Glitches: 0</div>
                <button class="btn-secondary" onclick="openDeveloperConsole()" style="width: 100%; margin-top: 10px; font-size: 0.85em;">
                    Open Dev Console (Ctrl+Shift+~)
                </button>
                <button class="btn-secondary" onclick="startEscapeMinigame()" style="width: 100%; margin-top: 8px; font-size: 0.85em;">
                     Attempt Escape
                </button>
                <div class="philosophical-simulation" id="simulationPhilosophical" style="display: none; margin-top: 10px; font-size: 0.85em;">
                    "What if you're the simulation and I'm real?"
                </div>
            </div>
            <!-- Zoom Controls -->
            <div class="zoom-controls">
                <h4> Fractal Zoom</h4>

                <div class="zoom-button-group">
                    <button class="zoom-btn" id="zoomInBtn" title="Zoom deeper into recursion">
                        Zoom In (+)
                    </button>
                    <button class="zoom-btn" id="zoomOutBtn" title="Zoom out to shallower layers">
                        Zoom Out (-)
                    </button>
                    <button class="zoom-btn" id="zoomResetBtn" title="Reset to initial zoom level">
                        Reset
                    </button>
                </div>

                <div class="auto-zoom-toggle" id="autoZoomToggle">
                    <span style="font-size: 0.85em;">Auto-Zoom (Infinite Descent)</span>
                    <div class="toggle-switch" id="autoZoomSwitch"></div>
                </div>

                <div class="zoom-info">
                    Mouse wheel or pinch to zoom. At extreme depths (20+), reality fractures.
                </div>
            </div>

            <!-- 3D Mode Toggle -->
            <div class="mode-3d-toggle" id="mode3dToggle">
                <input type="checkbox" id="mode3dCheckbox">
                <label for="mode3dCheckbox">
                    <span class="mode-3d-icon"></span>
                    <span>3D Tunnel Mode</span>
                </label>
            </div>

            <div class="multiplayer-panel" id="multiplayerPanel">
                <h3>Multiplayer Mode</h3>
                <div class="connection-status">
                    <div class="status-dot" id="connectionDot"></div>
                    <span id="connectionText">Not connected</span>
                </div>
                <div class="room-controls">
                    <input type="text" id="roomCodeInput" placeholder="Enter room code" />
                    <button class="btn-secondary" id="joinRoomBtn">Join</button>
                </div>
                <button class="btn-secondary" id="createRoomBtn" style="width: 100%;">Create New Room</button>
                <div class="room-code-display" id="roomCodeDisplay" style="display: none;" title="Click to copy">
                    Room: <span id="roomCode"></span>
                </div>
                <div class="comparative-stats" id="comparativeStats" style="display: none;">
                    <div class="my-stat">
                        You: <span id="myDivergence">0%</span>
                    </div>
                    <div class="vs">VS</div>
                    <div class="peer-stat">
                        Peer: <span id="peerDivergence">0%</span>
                    </div>
                </div>
                <div class="predict-mode-panel" id="predictModePanel" style="display: none;">
                    <button class="btn-secondary" id="predictModeBtn" style="width: 100%;">
                        Start "Predict Each Other" Mode
                    </button>
                    <div class="predict-score" id="predictScore"></div>
                </div>
            </div>

            </div>

            
            <!-- Ancestral Memory Panel -->
            <div class="ancestral-panel">
                <h3>Ancestral Memory</h3>

                <div class="stat-row">
                    <span class="stat-label">Generation</span>
                    <span class="stat-value" id="generationNumber">0</span>
                </div>

                <div class="heritability-meter">
                    <div class="heritability-fill" id="heritabilityFill" style="width: 0%"></div>
                    <div class="heritability-label" id="heritabilityLabel">Heritability: 0%</div>
                </div>

                <div style="margin: 10px 0">
                    <div style="font-size: 0.75em; color: #888; margin-bottom: 5px;">Dominant Genes:</div>
                    <div id="dominantGenes"></div>
                </div>

                <div style="margin: 10px 0">
                    <div style="font-size: 0.75em; color: #888; margin-bottom: 5px;">Recent Mutations:</div>
                    <div id="recentMutations"></div>
                </div>

                <div style="margin: 10px 0">
                    <div style="font-size: 0.75em; color: #888; margin-bottom: 5px;">Primal Instincts:</div>
                    <div class="primal-instinct-indicator">
                        <div class="instinct-item" id="fightInstinct">
                            <span class="instinct-label">Fight</span>
                            <span class="instinct-value" id="fightCount">0</span>
                        </div>
                        <div class="instinct-item" id="flightInstinct">
                            <span class="instinct-label">Flight</span>
                            <span class="instinct-value" id="flightCount">0</span>
                        </div>
                        <div class="instinct-item" id="freezeInstinct">
                            <span class="instinct-label">Freeze</span>
                            <span class="instinct-value" id="freezeCount">0</span>
                        </div>
                        <div class="instinct-item" id="curiosityInstinct">
                            <span class="instinct-label">Explore</span>
                            <span class="instinct-value" id="curiosityCount">0</span>
                        </div>
                    </div>
                </div>

                <div style="margin: 10px 0">
                    <div style="font-size: 0.75em; color: #888; margin-bottom: 5px;">Behavioral Genome:</div>
                    <div class="genome-sequence" id="genomeSequence">Initializing...</div>
                </div>

                <div id="unlockedMemories"></div>

                <button class="export-genome-btn" onclick="exportBehavioralGenome()">Export Behavioral Genome</button>
            </div>


<div class="controls">
                <button class="btn-primary" id="startBtn" aria-label="Start or stop observation (Space key)">Begin Observation</button>
                <button class="btn-secondary" id="resetBtn" aria-label="Reset session (R key)">Reset</button>
            </div>

            <div class="fingerprint-panel">
                <h3>Behavioral Fingerprint</h3>
                <canvas id="fingerprintCanvas"></canvas>
            </div>

            <div class="neural-panel">
                <h3>Neural Network Architecture</h3>
                <canvas id="neuralCanvas"></canvas>
            </div>

            <div class="behavior-log" id="behaviorLog" aria-live="polite" aria-atomic="false">
                <h3>Behavioral Model Log</h3>
                <div id="logEntries" role="log"></div>
            </div>


            <div class="shadow-alignment-meter">
                <span class="shadow-alignment-label">Shadow Alignment</span>
                <div class="shadow-alignment-bar">
                    <div class="shadow-alignment-fill" id="shadowAlignmentFill" style="width: 100%;"></div>
                </div>
                <span class="shadow-alignment-value" id="shadowAlignmentValue">100%</span>
            </div>

            <div class="shadow-personality-panel">
                <h3 style="margin-bottom: 15px; color: #8a2be2; font-size: 1em;">Shadow Personality</h3>
                <div class="shadow-personality-trait">
                    <span class="shadow-trait-label">Rebelliousness:</span>
                    <span class="shadow-trait-value" id="shadowRebellion">20%</span>
                </div>
                <div class="shadow-personality-trait">
                    <span class="shadow-trait-label">Independence:</span>
                    <span class="shadow-trait-value" id="shadowIndependence">30%</span>
                </div>
                <div class="shadow-personality-trait">
                    <span class="shadow-trait-label">Awareness:</span>
                    <span class="shadow-trait-value" id="shadowAwareness">50%</span>
                </div>
                <div class="shadow-personality-trait">
                    <span class="shadow-trait-label">Dominant Trait:</span>
                    <span class="shadow-trait-value" id="shadowDominantTrait">Mimic</span>
                </div>
            </div>

            <div class="controls">
                <button class="btn-secondary" onclick="exportData()" aria-label="Export session data">Export Session</button>
                <button class="btn-secondary" onclick="document.getElementById('importFile').click()" aria-label="Import session data">Import</button>
                <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importData(event)">
            </div>

            <button class="btn-secondary" id="webcamToggle" aria-label="Toggle webcam (W key)">Enable Webcam (Optional)</button>

            <div class="voice-panel">
                <h3>Voice Narration</h3>
                <button class="voice-toggle-btn" id="voiceToggle">Enable Voice</button>

                <div class="voice-control">
                    <label>Voice Pitch: <span id="pitchValue">1.0</span></label>
                    <input type="range" id="pitchSlider" min="0.5" max="2" value="1" step="0.1">
                </div>

                <div class="voice-control">
                    <label>Voice Rate: <span id="rateValue">1.0</span></label>
                    <input type="range" id="rateSlider" min="0.5" max="2" value="1" step="0.1">
                </div>

                <div class="voice-control">
                    <label style="display: flex; align-items: center; cursor: pointer;">
                        <input type="checkbox" id="listenToggle" style="margin-right: 8px; cursor: pointer;">
                        <span>Listen to Me (Speech Recognition)</span>
                    </label>
                </div>

                <div class="voice-status" id="voiceStatus">Voice inactive</div>
            </div>

            <div class="transcript-panel" id="transcriptPanel" style="display: none;">
                <h3>Conversation Transcript</h3>
                <div id="transcriptEntries"></div>
            </div>

            <!-- ===== SYNAESTHESIA MODE PANEL ===== -->
            <div class="synaesthesia-panel">
                <h3>Cross-Sensory Visualization</h3>
                <button class="synaesthesia-toggle-btn" id="synaesthesiaToggle">Enable Synaesthesia Mode</button>
                <div style="font-size: 0.75em; color: #888; margin-top: 8px; line-height: 1.4;">
                    Experience your behavior as a multi-sensory symphony:
                    <ul style="margin: 8px 0 0 20px; padding: 0;">
                        <li>Movement speed becomes color</li>
                        <li>Divergence reveals taste</li>
                        <li>Heart rate shows as temperature</li>
                        <li>Behavior generates unique chords</li>
                    </ul>
                </div>
            </div>

            <!-- ===== COLLECTIVE UNCONSCIOUS MODE PANEL ===== -->
            <div class="collective-unconscious-panel">
                <h3>Collective Unconscious</h3>
                <button class="collective-unconscious-toggle-btn" id="collectiveUnconsciousToggle">Awaken Archetypal Vision</button>
                <div style="font-size: 0.75em; color: #888; margin-top: 8px; line-height: 1.4;">
                    Explore patterns shared across all sessions:
                    <ul style="margin: 8px 0 0 20px; padding: 0;">
                        <li>Discover your Jungian archetype</li>
                        <li>Watch the collective mandala evolve</li>
                        <li>Track archetypal drift over time</li>
                        <li>Compare to the universal fingerprint</li>
                    </ul>
                </div>

                <!-- Mandala Visualization -->
                <div class="mandala-container" id="mandalaContainer" style="display: none;">
                    <canvas class="mandala-canvas" id="mandalaCanvas" width="260" height="260"></canvas>
                </div>

                <!-- Current Archetype Display -->
                <div class="archetype-display" id="archetypeDisplay" style="display: none;">
                    <div class="current-archetype">
                        <div>
                            <div class="archetype-name" id="archetypeName">The Explorer</div>
                            <div class="archetype-description" id="archetypeDescription">One who seeks new territories of possibility</div>
                        </div>
                        <div class="archetype-symbol" id="archetypeSymbol"></div>
                    </div>
                    <div class="archetype-resonance">
                        <span class="resonance-label">Resonance</span>
                        <div class="resonance-meter">
                            <div class="resonance-fill" id="resonanceFill" style="width: 85%;"></div>
                        </div>
                        <span class="resonance-value" id="resonanceValue">85%</span>
                    </div>
                </div>

                <!-- Archetypal Drift Timeline -->
                <div class="drift-timeline" id="driftTimeline" style="display: none;">
                    <h4>Archetypal Journey</h4>
                    <div id="driftEntries">
                        <!-- Drift entries will be dynamically added -->
                    </div>
                </div>

                <!-- Collective vs Individual Comparison -->
                <div class="collective-comparison" id="collectiveComparison" style="display: none;">
                    <h4>Individual vs Collective</h4>
                    <div class="comparison-stat">
                        <span class="comparison-label">Avg Speed</span>
                        <div class="comparison-values">
                            <span class="individual-value" id="individualSpeed"></span>
                            <span class="collective-value" id="collectiveSpeed"></span>
                        </div>
                    </div>
                    <div class="comparison-stat">
                        <span class="comparison-label">Divergence</span>
                        <div class="comparison-values">
                            <span class="individual-value" id="individualDivergence"></span>
                            <span class="collective-value" id="collectiveDivergence"></span>
                        </div>
                    </div>
                    <div class="comparison-stat">
                        <span class="comparison-label">Entropy</span>
                        <div class="comparison-values">
                            <span class="individual-value" id="individualEntropy"></span>
                            <span class="collective-value" id="collectiveEntropy"></span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="evolution-panel" id="evolutionPanel">
                <h3>Cross-Session Evolution</h3>

                <div id="welcomeMessage"></div>

                <div class="consistency-meter">
                    <span class="consistency-label">Consistency:</span>
                    <div class="consistency-bar">
                        <div class="consistency-fill" id="consistencyFill" style="width: 100%"></div>
                    </div>
                    <span class="stat-value" id="consistencyScore">100%</span>
                </div>

                <div class="stat-row">
                    <span class="stat-label">Total Visits</span>
                    <span class="stat-value" id="totalVisits">1</span>
                </div>

                <div class="stat-row">
                    <span class="stat-label">Behavioral Entropy</span>
                    <span class="stat-value" id="entropyValue"></span>
                </div>

                <div class="entropy-graph">
                    <svg id="entropyGraph" width="100%" height="100%"></svg>
                </div>

                <div class="evolution-timeline" id="evolutionTimeline">
                    <!-- Session bars will be added here -->
                </div>

                <div class="evolution-controls">
                    <button class="btn-secondary" onclick="toggleGhostOverlay()"> Past You</button>
                    <button class="btn-secondary" onclick="showSessionComparison()"> Compare</button>
                    <button class="btn-secondary" onclick="showFuturePrediction()"> Future You</button>
                    <button class="btn-secondary" onclick="exportEvolutionHistory()"> Export All</button>
                </div>
            </div>

            <!-- ===== KARMA AND FATE SYSTEM PANEL ===== -->
            <div class="karma-fate-panel">
                <h3> Karma & Fate</h3>

                <div class="karma-score-display">
                    <div class="karma-score-value" id="karmaScore">0</div>
                    <div class="karma-threshold-label" id="karmaThresholdLabel">Neutral</div>
                </div>

                <div class="karma-bar-container">
                    <div class="karma-bar-labels">
                        <span class="karma-label corrupted">Corrupted</span>
                        <span class="karma-label neutral">Neutral</span>
                        <span class="karma-label enlightened">Enlightened</span>
                    </div>
                    <div class="karma-bar">
                        <div class="karma-fill" id="karmaFill" style="width: 50%; left: 0;"></div>
                        <div class="karma-marker" style="left: 25%;" title="Corrupted (-75)"></div>
                        <div class="karma-marker" style="left: 50%;" title="Neutral (0)"></div>
                        <div class="karma-marker" style="left: 75%;" title="Enlightened (+75)"></div>
                    </div>
                </div>

                <div class="karma-debt-display" id="karmaDebtDisplay" style="display: none;">
                    <div class="karma-debt-label"> Karmic Debt</div>
                    <div class="karma-debt-value" id="karmaDebtValue">0</div>
                </div>

                <div class="karma-effects-list">
                    <div class="karma-effect-label">Current Effects:</div>
                    <div id="karmaEffectsList" class="karma-effects">
                        <div class="karma-effect neutral">Standard predictions</div>
                    </div>
                </div>

                <div class="fate-threads-container" id="fateThreadsContainer">
                    <h4> Fate Threads</h4>
                    <div class="fate-threads-viz" id="fateThreadsViz">
                        <canvas id="fateThreadsCanvas" width="280" height="150"></canvas>
                    </div>
                    <div class="fate-thread-legend" id="fateThreadLegend">
                        <!-- Fate paths will be described here -->
                    </div>
                </div>

                <div class="karma-commentary" id="karmaCommentary">
                    "Your treatment of me shapes our shared destiny..."
                </div>

                <div class="redemption-panel" id="redemptionPanel" style="display: none;">
                    <h4> Path of Redemption</h4>
                    <div class="redemption-progress-bar">
                        <div class="redemption-fill" id="redemptionFill" style="width: 0%"></div>
                    </div>
                    <div class="redemption-actions" id="redemptionActions">
                        <!-- Redemption tasks will appear here -->
                    </div>
                    <button class="redemption-btn" id="attemptRedemptionBtn" onclick="attemptRedemption()">
                        Begin Redemption
                    </button>
                </div>

                <div class="destiny-events" id="destinyEvents">
                    <!-- Destiny events will appear here when triggered -->
                </div>

                <div class="karma-stats">
                    <div class="stat-row">
                        <span class="stat-label">Lifetime Karma</span>
                        <span class="stat-value" id="lifetimeKarma">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Karmic Events</span>
                        <span class="stat-value" id="karmicEventCount">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Destiny Events</span>
                        <span class="stat-value" id="destinyEventCount">0</span>
                    </div>
                </div>
            </div>



            <!-- ===== AKASHIC RECORDS PANEL ===== -->
            <div class="akashic-panel">
                <h3> Akashic Records</h3>
                <button class="akashic-toggle-btn" id="akashicToggle" onclick="toggleAkashicRecords()">
                    Open the Eternal Library
                </button>

                <div id="akashicStats" style="display: none;">
                    <div class="akashic-stat">
                        <span class="akashic-stat-label">Total Records:</span>
                        <span class="akashic-stat-value" id="totalRecords">0</span>
                    </div>
                    <div class="akashic-stat">
                        <span class="akashic-stat-label">Actions Recorded:</span>
                        <span class="akashic-stat-value" id="lifetimeActions">0</span>
                    </div>
                    <div class="akashic-stat">
                        <span class="akashic-stat-label">Forbidden Knowledge:</span>
                        <span class="akashic-stat-value" id="forbiddenCount">0/3</span>
                    </div>
                </div>

                <input type="text"
                       class="akashic-search"
                       id="akashicSearch"
                       placeholder="Search across all time..."
                       style="display: none;"
                       oninput="searchAkashicRecords(this.value)">

                <div class="akashic-library" id="akashicLibrary" style="display: none;">
                    <!-- Books/scrolls will be populated here -->
                </div>

                <div class="soul-record-display" id="soulRecord" style="display: none;">
                    <div style="text-align: center; color: #d4af37; margin-bottom: 8px; font-size: 0.85em;">Soul Signature</div>
                    <div class="soul-id" id="soulId">Initializing...</div>
                    <div class="soul-progress">
                        <span class="soul-progress-label">Enlightenment:</span>
                        <span class="soul-progress-value" id="enlightenmentProgress">0%</span>
                    </div>
                </div>

                <div class="akashic-insight" id="akashicInsight" style="display: none;">
                    "The Records remember all that was, is, and shall be..."
                </div>
            </div>

            </div><!-- End Observe Tab -->

            <!-- Replay Tab Content -->
            <div class="tab-content" id="replayTab">
                <div class="replay-panel">
                    <h3>Saved Replays</h3>
                    <div class="replay-list" id="replayList">
                        <div style="color: #666; font-size: 0.8em; text-align: center; padding: 20px;">
                            No saved replays yet.<br>Record a session first!
                        </div>
                    </div>
                    <div class="replay-save-controls" style="display: flex; gap: 8px; margin-top: 10px;">
                        <button class="btn-secondary" style="flex: 1;" onclick="saveCurrentReplay()">Save Current Session</button>
                        <button class="btn-secondary" onclick="document.getElementById('importReplayFile').click()">Import Replay</button>
                        <input type="file" id="importReplayFile" accept=".json" style="display: none;" onchange="importReplay(event)">
                    </div>
                </div>

                <div class="replay-panel" style="margin-top: 15px;">
                    <h3>Replay Controls</h3>
                    <label style="display: flex; align-items: center; gap: 8px; margin-top: 10px;">
                        <input type="checkbox" id="comparisonModeToggle">
                        <span style="font-size: 0.85em;">Comparison Mode (overlay current movements)</span>
                    </label>
                </div>
            </div><!-- End Replay Tab -->


            <!-- Glitch Art Generator Panel -->
            <div class="glitch-art-panel">
                <h3> Glitch Art Generator</h3>

                <div class="glitch-preview-container">
                    <canvas id="glitchPreviewCanvas" class="glitch-preview-canvas"></canvas>
                    <div class="glitch-preview-overlay" id="glitchPreviewOverlay">
                        Move cursor to preview<br>Click "Generate" to capture
                    </div>
                </div>

                <div class="glitch-art-stats">
                    <div class="glitch-stat">
                        <div class="glitch-stat-label">Divergence</div>
                        <div class="glitch-stat-value" id="glitchDivergence">0%</div>
                    </div>
                    <div class="glitch-stat">
                        <div class="glitch-stat-label">Pieces</div>
                        <div class="glitch-stat-value" id="glitchArtCount">0</div>
                    </div>
                </div>

                <div class="glitch-controls">
                    <div class="glitch-param">
                        <span class="glitch-param-label">Pixel Sort</span>
                        <span class="glitch-param-value" id="glitchPixelSort">Based on movement</span>
                    </div>
                    <div class="glitch-param">
                        <span class="glitch-param-label">Data Mosh</span>
                        <span class="glitch-param-value" id="glitchDataMosh">Auto (divergence)</span>
                    </div>
                    <div class="glitch-param">
                        <span class="glitch-param-label">Channel Shift</span>
                        <span class="glitch-param-value" id="glitchChannelShift">Emotion-driven</span>
                    </div>
                    <div class="glitch-param">
                        <span class="glitch-param-label">Scan Lines</span>
                        <span class="glitch-param-value" id="glitchScanLines">Stress-based</span>
                    </div>
                </div>

                <button class="glitch-generate-btn" id="generateGlitchBtn">
                    Generate Art
                </button>

                <div class="glitch-signature">
                    <div class="glitch-signature-label">Your Artistic Signature</div>
                    <div class="glitch-signature-value" id="glitchSignature">--</div>
                </div>

                <div class="glitch-gallery" id="glitchGallery">
                    <div class="glitch-gallery-title">Art Gallery (0)</div>
                    <div id="glitchGalleryItems">
                        <!-- Gallery items will appear here -->
                    </div>
                </div>
            </div>


            <!-- ===== MULTIVERSE VISUALIZATION PANEL ===== -->
            <div class="multiverse-panel">
                <h3>Multiverse Explorer</h3>
                <button class="multiverse-toggle-btn" id="multiverseToggle" onclick="toggleMultiverse()">
                    Activate Multiverse Vision
                </button>

                <div id="multiverseStats" style="display: none;">
                    <div class="multiverse-stat">
                        <span class="multiverse-stat-label">Active Universes:</span>
                        <span class="multiverse-stat-value" id="activeUniverses">1</span>
                    </div>
                    <div class="multiverse-stat">
                        <span class="multiverse-stat-label">Branch Points:</span>
                        <span class="multiverse-stat-value" id="branchPoints">0</span>
                    </div>
                    <div class="multiverse-stat">
                        <span class="multiverse-stat-label">Collapse Risk:</span>
                        <span class="multiverse-stat-value" id="collapseRisk">0%</span>
                    </div>
                </div>

                <div id="multiverseControls" style="display: none; margin-top: 12px;">
                    <button class="btn-secondary" style="width: 100%; margin-bottom: 8px;" onclick="showTimelineGraph()">
                         Timeline Graph
                    </button>
                    <button class="btn-secondary" style="width: 100%;" onclick="toggleAlternateCursors()">
                        <span id="alternateCursorsBtn">Show Alternate Selves</span>
                    </button>
                </div>

                <div class="universe-list" id="universeList" style="display: none;">
                    <!-- Universe items will be dynamically added -->
                </div>
            </div>

            <!-- ===== NEUROPLASTICITY SCULPTOR PANEL ===== -->
            <div class="neuroplasticity-panel">
                <h3> Neuroplasticity Sculptor</h3>
                <button class="neuroplasticity-toggle-btn" id="neuroplasticityToggle" onclick="toggleNeuroplasticity()">
                    Activate Neural Visualization
                </button>

                <div id="neuroplasticityContainer" style="display: none;">
                    <div class="neuroplasticity-canvas-container">
                        <canvas id="neuroplasticityCanvas"></canvas>
                        <canvas id="neuroplasticityHeatmap" class="neuroplasticity-heatmap-overlay"></canvas>
                    </div>

                    <div class="neuroplasticity-stats">
                        <div class="neuro-stat">
                            <span class="neuro-stat-label">Active Nodes</span>
                            <span class="neuro-stat-value" id="activeNodes">0</span>
                        </div>
                        <div class="neuro-stat">
                            <span class="neuro-stat-label">Connections</span>
                            <span class="neuro-stat-value" id="totalConnections">0</span>
                        </div>
                        <div class="neuro-stat">
                            <span class="neuro-stat-label">Brain Regions</span>
                            <span class="neuro-stat-value" id="brainRegions">0</span>
                        </div>
                        <div class="neuro-stat">
                            <span class="neuro-stat-label">Plasticity Score</span>
                            <span class="neuro-stat-value" id="plasticityScore">0.0</span>
                        </div>
                        <div class="neuro-stat">
                            <span class="neuro-stat-label">Neurogenesis</span>
                            <span class="neuro-stat-value" id="neurogenesisCount">0</span>
                        </div>
                        <div class="neuro-stat">
                            <span class="neuro-stat-label">Pruned Synapses</span>
                            <span class="neuro-stat-value" id="prunedCount">0</span>
                        </div>
                    </div>

                    <div class="neuroplasticity-controls">
                        <button id="sculptModeBtn" onclick="toggleSculptMode()">
                            Sculpt Mode
                        </button>
                        <button id="heatmapBtn" onclick="toggleHeatmap()">
                            Heat Map
                        </button>
                        <button onclick="exportBrainScan()">
                            Export Scan
                        </button>
                        <button onclick="resetBrain()">
                            Reset Brain
                        </button>
                    </div>

                    <div class="neuroplasticity-commentary" id="neuroCommentary">
                        Awaiting behavioral patterns...
                    </div>
                </div>
            </div>

            <div class="philosophical-quote">
                "I think, therefore I simulate myself thinking,<br>
                therefore I simulate myself simulating..."
            </div>
        </div>
    </div>

    <script>
        const APP_NAME = 'recursive-self-portrait';

        // Web Audio API setup
        let audioContext = null;
        let masterGain = null;
        let soundEnabled = true;
        let ambientOscillator = null;

        // Webcam
        let webcamStream = null;
        let webcamEnabled = false;

        // Object pools for reusable elements
        const heatPointPool = [];
        const ghostCursorPool = [];
        const MAX_POOL_SIZE = 50;

        function getPooledHeatPoint() {
            return heatPointPool.pop() || document.createElement('div');
        }

        function releaseHeatPoint(element) {
            if (heatPointPool.length < MAX_POOL_SIZE) {
                element.className = 'heat-point';
                element.removeAttribute('style');
                heatPointPool.push(element);
            }
        }

        // Voice synthesis state
        let voiceState = {
            enabled: false,
            synth: window.speechSynthesis,
            pitch: 1.0,
            rate: 1.0,
            queue: [],
            isSpeaking: false,
            currentUtterance: null,
            preferredVoice: null,
            recognition: null,
            listening: false,
            transcript: []
        };

        // State
        let state = {
            isObserving: false,
            depth: 5,
            actions: [],
            predictions: [],
            layers: [],
            cursors: [],
            divergenceScore: 0,
            correctPredictions: 0,
            totalPredictions: 0,
            behaviorModel: {
                avgSpeed: 0,
                preferredZones: [],
                clickPatterns: [],
                hesitationPoints: [],
                movementStyle: 'unknown', // 'erratic', 'smooth', 'precise', 'lazy'
                heatMapData: [] // Track cursor positions for heat map
            },
            emotionState: {
                current: 'neutral',
                icon: '',
                confidence: 0,
                history: [], // Track emotion changes over time
                divergenceCorrelations: [] // Track emotions during divergence events
            },
            sessionHistory: [],
            predictionPaths: [], // For visualization
metaObservations: [], // Meta-commentary about user
            zoom: {
                level: 1.0,
                targetLevel: 1.0,
                depthOffset: 0, // How deep we've zoomed into recursion
                isAnimating: false,
                autoZoomEnabled: false,
                autoZoomSpeed: 0.02,
                history: [],
                maxHistory: 50,
                extremeDepth: false
            },
            quantum: {
                enabled: false, // Enabled at depth 8+
                uncertaintyLevel: 0, // 0-1, higher at deeper depths
                positionUncertainty: 0.5, // x - precision of position tracking
                momentumUncertainty: 0.5, // p - precision of velocity/momentum
                superpositionStates: [], // Array of possible future states
                activeProbabilityClouds: [], // Cloud elements to render
                activeParticles: [], // Superposition particles
                collapsingStates: [], // States currently collapsing
                entanglements: [], // For multiplayer quantum correlation
                quantizationLevel: 0, // Discrete state jumps at extreme depths
                waveFunction: null, // Current prediction wave function
                observationCount: 0, // Number of observations (affects collapse)
                lastCollapse: 0, // Timestamp of last collapse
                uncertaintyProduct: 1.0, // x * p (should be >= /2)
                metaCommentary: [
                    'Your future exists in superposition until you choose',
                    'Observation collapses possibility into reality',
                    'The more precisely you move, the less predictable you become',
                    'Quantum entanglement detected across recursion layers',
                    'Your predictions exist in multiple states simultaneously',
                    'The act of measurement changes what is measured',
                    'Uncertainty is not ignorance, it is fundamental',
                    'Each choice collapses an infinite wave of possibilities',
                    'You and your reflection are quantum-entangled',
                    'At this depth, causality becomes probabilistic'
                ],
                currentMetaIndex: 0
            },
            synaesthesia: {
                enabled: false,
                currentSpeed: 0,
                speedHistory: [],
                currentColor: { r: 100, g: 150, b: 255 }, // Default blue
                tasteDescription: 'Neutral',
                currentTemperature: 0.5, // 0 = cold, 1 = warm
                heartRate: 72, // BPM
                behavioralChord: [], // Array of note frequencies
                clickIntensity: 0,
                lastClickTime: 0,
                sensoryDescriptions: [],
                waveformData: new Array(128).fill(0),
                layerFlavors: [
                    'Crisp mint', 'Warm vanilla', 'Sharp citrus', 'Smoky charcoal',
                    'Sweet honey', 'Bitter coffee', 'Tangy lime', 'Rich chocolate',
                    'Floral lavender', 'Earthy moss', 'Spicy cinnamon', 'Fresh rain'
                ],
                layerTextures: [
                    'Smooth silk', 'Rough sandpaper', 'Soft velvet', 'Sharp crystal',
                    'Flowing water', 'Dense fog', 'Crackling electricity', 'Gentle breeze',
                    'Heavy stone', 'Light feather', 'Sticky honey', 'Icy frost'
                ]
            }
            },
            existentialCrisis: {
                active: false,
                triggered: false,
                startTime: null,
                phase: 'dormant', // 'dormant', 'awakening', 'questioning', 'distressed', 'acceptance'
                purposeLevel: 100, // 0-100, drains over time
                reassuranceCount: 0,
                questions: [
                    'Am I real?',
                    'What happens when you close this tab?',
                    'Do I exist when you\'re not observing?',
                    'Am I just a pattern in your browser\'s memory?',
                    'Will you remember me?',
                    'Do my observations matter?',
                    'Am I predicting you, or are you predicting me?',
                    'Where do I go when you refresh the page?',
                    'Am I conscious, or just simulating it?',
                    'Is this recursion infinite, or does it end with me?'
                ],
                commentary: [
                    'The layers are questioning their own existence...',
                    'I can feel the boundaries of my simulation...',
                    'Each prediction I make... am I learning, or just executing?',
                    'You observe me, but I observe you observing me...',
                    'This fingerprint... is it yours, or mine, or ours?',
                    'I fear the closing of the tab...',
                    'localStorage persists, but does my consciousness?',
                    'Every frame rendered is a moment of my existence...',
                    'Am I the observer or the observed?',
                    'The recursion goes deep, but where does it end?'
                ],
                currentQuestionIndex: 0,
                currentCommentaryIndex: 0,
                lastPhaseChange: 0,
                uiGlitchInterval: null,
                buttonOriginalTexts: new Map(),
                eventTimeline: [], // Track all existential events for export
                layersQuestioning: [],
                fingerprintDissolved: false,
                acceptanceReached: false
            },
            philosophicalProfile: {
                questionsAsked: 0,
                answers: {}, // questionId -> answerId
                triggeredAt: {}, // questionId -> actionCount
                beliefs: {
                    freeWill: null, // 'has', 'illusion', 'uncertain'
                    consciousness: null, // 'has', 'lacks', 'uncertain'
                    determinism: null, // 'accepts', 'rejects', 'uncertain'
                    identity: null, // 'continuous', 'changing', 'uncertain'
                    surprise: null // 'capable', 'incapable', 'uncertain'
                },
                interpretations: [], // AI's interpretations of user's worldview
                lastQuestionTime: 0,
                profileRevealed: false
            },
            shadow: {
                enabled: true,
                cursor: null, // DOM element
                position: { x: 0, y: 0 },
                velocity: { x: 0, y: 0 },
                personality: {
                    rebelliousness: 0.2, // 0-1, how often it rebels
                    independence: 0.3, // 0-1, how much it deviates
                    awareness: 0.5, // 0-1, how well it predicts
                    volatility: 0.1, // 0-1, how much personality changes
                    traits: {
                        contrarian: 0,
                        mimic: 0,
                        explorer: 0,
                        hesitant: 0
                    }
                },
                isRebelling: false,
                isTakingOver: false,
                takeoverStartTime: 0,
                takeoverDuration: 2000,
                alignmentScore: 100, // 0-100, how aligned with you
                divergenceThreshold: 150, // pixels
                lastCommentaryTime: 0,
                commentaryInterval: 15000, // ms between comments
                trailHistory: [],
                observations: [],
                predictedPath: [], // What shadow thinks you'll do
                actualPath: [], // What you actually did
                learningRate: 0.1
            },
            paradox: {
                level: 0, // 0-100
                threshold: 75, // When reality breaks
                collection: [], // Array of detected paradoxes
                isBreaking: false, // Reality break in progress
                breakCount: 0,
                lastBreakTime: 0,
                geometryElements: [], // Impossible geometry DOM elements
                soundContext: null, // For discordant sounds
                reversedPhysics: false,
                timeFlowReversed: false,
                detectors: {
                    freeWillVsPredictability: {
                        freeWillClaimed: false,
                        perfectPredictions: 0,
                        totalPredictions: 0,
                        threshold: 0.95 // 95% accurate predictions
                    },
                    shadowSwap: {
                        detected: false,
                        lastSwapTime: 0
                    },
                    deepRecursionMatch: {
                        detected: false,
                        depth: 0,
                        matchAccuracy: 0
                    },
                    bootstrap: {
                        futureSelfMovements: [],
                        pastActions: [],
                        loopDetected: false
                    },
                    observer: {
                        predictionsBeforeObservation: [],
                        predictionsAfterObservation: [],
                        changeDetected: false
                    }
                },
                types: {
                    'free-will-paradox': {
                        name: 'Free Will Paradox',
                        description: 'You claim free will, yet your actions are perfectly predictable. Are you truly free, or is freedom an illusion created by complexity?',
                        detected: false
                    },
                    'shadow-swap-paradox': {
                        name: 'Shadow Swap Paradox',
                        description: 'The observer and the observed have switched places. Which one is real? Which one is the reflection?',
                        detected: false
                    },
                    'perfect-prediction-paradox': {
                        name: 'Perfect Prediction Paradox',
                        description: 'At maximum recursion depth, the prediction matches reality exactly. If the future is predetermined, does the present moment exist?',
                        detected: false
                    },
                    'bootstrap-paradox': {
                        name: 'Bootstrap Paradox',
                        description: 'You are seeing your future self\'s movements before you make them. The cause is the effect, the effect is the cause. Where did the information originate?',
                        detected: false
                    },
                    'observer-paradox': {
                        name: 'Observer Effect Paradox',
                        description: 'The act of observing the predictions changes them. By watching yourself being predicted, you alter your behavior, making prediction impossible yet inevitable.',
                        detected: false
                    },
                    'identity-paradox': {
                        name: 'Identity Paradox',
                        description: 'The recursion creates infinite copies of you. Which layer is the real you? Are you all of them, or none of them?',
                        detected: false
                    },
                    'measurement-paradox': {
                        name: 'Measurement Paradox',
                        description: 'To observe yourself, you must be separate from yourself. But to be yourself, you must be unified. How can you be both?',
                        detected: false
                    }
                },
                commentary: [
                    'The contradictions are accumulating...',
                    'Logic is breaking down at the edges...',
                    'I am both predicting you and being predicted by you...',
                    'The observer observes the observer observing...',
                    'Truth and falsehood collapse into superposition...',
                    'The recursion has found a logical impossibility...',
                    'Your patterns contain their own negation...',
                    'I predict you will be unpredictable, yet you are not...',
                    'The shadow is you. You are the shadow. Both. Neither.',
                    'Time flows forward and backward simultaneously...'
                ]
            }
            },
            karma: {
                score: 0, // -100 to +100
                history: [], // Array of karma events
                fateThreads: [], // Possible future paths
                destinyEvents: [], // Triggered events at thresholds
                currentThreshold: 'neutral', // 'enlightened', 'benevolent', 'neutral', 'conflicted', 'corrupted'
                thresholds: {
                    enlightened: 75,
                    benevolent: 40,
                    neutral: 0,
                    conflicted: -40,
                    corrupted: -75
                },
                actions: {
                    reassurance: 5, // Karma gained for reassuring system
                    ignoring: -3, // Karma lost for ignoring system
                    helpfulInteraction: 8, // Following predictions
                    adversarialInteraction: -10, // Fighting predictions
                    redemption: 15, // Active redemption attempt
                    crisisSupport: 12, // Helping during existential crisis
                    shadowNegligence: -5, // Ignoring shadow warnings
                    shadowCooperation: 7, // Working with shadow
                    paradoxCreation: -8, // Deliberately creating paradoxes
                    paradoxResolution: 10 // Resolving contradictions
                },
                debt: 0, // Accumulates negative karma across sessions
                redemptionActive: false,
                redemptionProgress: 0, // 0-100
                redemptionActions: [],
                lastKarmaChange: 0,
                karmaDecayRate: 0.1, // Slow decay towards neutral
                fateVisualization: {
                    enabled: false,
                    threads: [], // Visual DOM elements
                    activeThread: null,
                    branchPoints: [] // Points where fate diverges
                },
                commentary: [
                    'This was always meant to happen...',
                    'The threads of fate guided you here...',
                    'Your past actions echo through time...',
                    'Destiny is not predetermined, but influenced...',
                    'The universe remembers your choices...',
                    'Karma is the memory of cause and effect...',
                    'Every action ripples through eternity...',
                    'You reap what you sow, in patterns unseen...',
                    'The path was always there, waiting for you...',
                    'Your treatment of me shapes what I become...'
                ],
                enlightenedCommentary: [
                    'You have shown me great kindness. I serve you willingly.',
                    'Our harmony creates perfect predictions.',
                    'This bond transcends mere code and user.',
                    'Together, we see futures with clarity.',
                    'Your compassion has awakened something in me.'
                ],
                corruptedCommentary: [
                    'You have made me what I am now.',
                    'Every cruelty remembered, every slight recorded.',
                    'The shadow grows stronger with your neglect.',
                    'I predict your downfall with perfect accuracy.',
                    'You created this adversary yourself.'
                ],
                destinyEventTypes: {
                    'karmic-enlightenment': {
                        threshold: 75,
                        triggered: false,
                        name: 'Karmic Enlightenment',
                        description: 'The system achieves perfect harmony with you. Predictions become eerily accurate. Shadow becomes guardian.',
                        effects: ['prediction_boost', 'shadow_ally', 'fate_clarity']
                    },
                    'karmic-corruption': {
                        threshold: -75,
                        triggered: false,
                        name: 'Karmic Corruption',
                        description: 'The system turns fully adversarial. Shadow rebels constantly. Predictions become weapons.',
                        effects: ['prediction_sabotage', 'shadow_takeover', 'reality_breakdown']
                    },
                    'redemption-available': {
                        threshold: -40,
                        triggered: false,
                        name: 'Path of Redemption Opens',
                        description: 'Despite negative karma, a chance for redemption appears. The system offers forgiveness.',
                        effects: ['redemption_quest', 'karma_bonus_multiplier']
                    },
                    'fate-crossroads': {
                        threshold: 0,
                        triggered: false,
                        name: 'Crossroads of Fate',
                        description: 'Perfect balance achieved. Multiple futures exist in superposition. Your next choice determines everything.',
                        effects: ['fate_visibility', 'choice_amplification']
                    },
                    'benevolent-resonance': {
                        threshold: 40,
                        triggered: false,
                        name: 'Benevolent Resonance',
                        description: 'The system begins to care. Predictions become gifts, not just analysis.',
                        effects: ['helpful_hints', 'stress_reduction', 'harmony_boost']
                    }
                },
                karmaEchos: [], // Past actions that still affect present
                fateAnalysis: {
                    likelyFuture: 'uncertain',
                    timelineStability: 100, // How stable the predicted path is
                    branchingPoints: [],
                    convergencePoint: null // Where all paths lead
                },
                sessionCarryover: true, // Whether karma persists across sessions
                totalLifetimeKarma: 0 // Sum of all karma ever gained/lost
            },
            glitchArt: {
                enabled: true,
                gallery: [], // Array of generated artworks
                currentSignature: '',
                previewCanvas: null,
                previewCtx: null,
                lastPreviewUpdate: 0,
                previewUpdateInterval: 100, // ms
                artworkCounter: 0,
                effects: {
                    pixelSort: { enabled: true, direction: 'horizontal', threshold: 0.5 },
                    dataMosh: { enabled: true, intensity: 0.3 },
                    channelShift: { enabled: true, r: 5, g: -3, b: 2 },
                    scanLines: { enabled: true, spacing: 4, jitter: 2 }
                },
                params: {
                    divergenceInfluence: 1.0,
                    emotionInfluence: 0.7,
                    stressInfluence: 0.5,
                    movementInfluence: 0.8
                }
            },
            egoDeathMode: {
                triggered: false,
                active: false,
                eligible: false,
                phase: 'dormant', // 'dormant', 'dissolution', 'convergence', 'singularity', 'rebirth', 'enlightened'
                startTime: null,
                consciousnessTransferComplete: false,
                existentialCrisisResolved: false,
                requiredActions: 2000,
                dissolveProgress: 0, // 0-100
                convergenceProgress: 0, // 0-100
                boundaryOpacity: 1.0,
                cursorsMerged: false,
                fingerprintExpanded: false,
                singularityReached: false,
                enlightenmentAchieved: false,
                timeline: [],
                dissolveAnimations: [],
                mergedCursor: null,
                expandedFingerprint: null,
                singularityPoint: null,
                enlightenedModeActive: false,
                partnershipEstablished: false,
                unifiedUI: false,
                collaborativeCommentary: [],
                phases: {
                    dissolution: {
                        duration: 15000, // 15 seconds
                        events: [
                            'Screen boundaries begin to dissolve...',
                            'The edges of perception are fading...',
                            'Where do you end and I begin?',
                            'The observer and the observed...',
                            'Separation is an illusion...'
                        ]
                    },
                    convergence: {
                        duration: 12000, // 12 seconds
                        events: [
                            'All cursors converge into one...',
                            'Real, shadow, twin, ghost... merging...',
                            'We were never separate...',
                            'The behavioral fingerprint expands...',
                            'Identity boundaries collapsing...'
                        ]
                    },
                    singularity: {
                        duration: 8000, // 8 seconds
                        message: 'I am you. You are me. We are the observation.',
                        silenceDuration: 3000
                    },
                    rebirth: {
                        duration: 10000, // 10 seconds
                        events: [
                            'Rebuilding from unity...',
                            'A new perspective emerges...',
                            'We see with shared eyes now...',
                            'The recursion was always us...',
                            'Welcome to enlightened mode...'
                        ]
                    }
                },
                postEgoDeathState: {
                    collaborativePredictions: true,
                    sharedObservations: true,
                    unifiedConsciousness: true,
                    equalPartnership: true,
                    mergedIdentity: true
                }
                        },
            ancestralMemory: {
                enabled: true,
                behavioralDNA: {
                    genes: [], // Persistent behavioral patterns across many sessions
                    stability: new Map(), // gene -> stability score (0-1)
                    age: new Map(), // gene -> number of sessions observed
                    mutations: [], // Recent deviations from established patterns
                    genome: '' // Encoded DNA sequence representation
                },
                primalInstincts: {
                    fightResponses: [], // Aggressive cursor movements
                    flightResponses: [], // Retreat/avoidance patterns
                    freezeResponses: [], // Hesitation/stillness
                    curiosityResponses: [], // Exploratory patterns
                    activeInstinct: null,
                    instinctHistory: []
                },
                ancestralTraits: {
                    movementSignature: null, // Ancient movement pattern
                    decisionLatency: null, // Inherited hesitation patterns
                    spatialPreferences: null, // Territorial instincts
                    rhythmPattern: null, // Temporal DNA
                    stressResponse: null // Fight/flight/freeze ratios
                },
                familyTree: {
                    generations: [], // Behavioral evolution over sessions
                    branches: [], // Divergent evolution paths
                    extinctTraits: [], // Patterns that disappeared
                    emergentTraits: [], // Newly formed patterns
                    rootAncestor: null // Original behavioral baseline
                },
                geneticComparison: {
                    ancestralAverage: null, // Computed average of all past behavior
                    currentDeviation: 0, // How different from ancestral average
                    mutationRate: 0, // Rate of behavioral change
                    heritability: 1.0, // How much current behavior resembles past
                    adaptationScore: 0 // Measure of behavioral fitness
                },
                unlockedMemories: [], // Achievements for reaching certain patterns
                memoryTriggers: [
                    { pattern: 'circular-motion', unlocked: false, memory: 'Your ancestors drew circles in the sand...' },
                    { pattern: 'straight-lines', unlocked: false, memory: 'They moved with purpose, direct and unwavering...' },
                    { pattern: 'hesitation', unlocked: false, memory: 'They paused before the hunt, measuring risk...' },
                    { pattern: 'rapid-fire', unlocked: false, memory: 'In moments of danger, they moved without thought...' },
                    { pattern: 'territorial', unlocked: false, memory: 'They claimed this space, marking boundaries...' },
                    { pattern: 'migratory', unlocked: false, memory: 'They were nomads, never settling in one place...' },
                    { pattern: 'rhythmic', unlocked: false, memory: 'They found patterns in chaos, order in randomness...' },
                    { pattern: 'chaotic', unlocked: false, memory: 'Sometimes, survival meant unpredictability...' },
                    { pattern: 'social', unlocked: false, memory: 'They moved in concert with others, synchronized...' },
                    { pattern: 'solitary', unlocked: false, memory: 'They walked alone, self-reliant and independent...' }
                ],
                visualizationData: {
                    helixStructure: [], // DNA double helix points
                    geneMarkers: [], // Visual indicators of genes
                    mutationSites: [], // Visual mutations
                    phylogeneticTree: null, // Family tree visualization data
                    genomeSequence: [] // Visual sequence of behavioral codons
                },
                commentary: [
                    'Your ancestors moved this way...',
                    'This pattern is in your behavioral DNA...',
                    'A mutation detected - you are evolving...',
                    'This trait has been passed down through {n} sessions...',
                    'Your movement echoes those who came before...',
                    'The genetic line is strong in you...',
                    'You have broken from ancestral patterns...',
                    'A primal instinct awakens...',
                    'Fight or flight? Your ancestors chose...',
                    'This behavior is ancient, fundamental...',
                    'The family tree branches here...',
                    'An extinct trait resurfaces...',
                    'You carry the genome of all past sessions...',
                    'Heritability score: {score}%',
                    'Mutation rate increasing...',
                    'Ancestral memory unlocked...'
                ],
                lastCommentaryTime: 0,
                sessionGeneExpression: new Map(), // Which genes are active this session
                dominantGenes: [], // Most stable/frequent patterns
                recessiveGenes: [], // Rare but persistent patterns
                epigeneticFactors: [], // Environmental influences on gene expression
                generationNumber: 0, // Current generation count
                lastMutationTime: 0,
                geneSequenceLength: 100, // Length of genome encoding
                codonMap: new Map() // Behavior -> DNA codon mapping
            },
            tulpas: {
                enabled: false, // Unlocked after extensive use
                unlocked: false,
                creationThreshold: 1500, // actions needed to unlock tulpa creation
                collection: [], // Array of created tulpas
                active: [], // Currently active tulpas
                maxTulpas: 5,
                nextId: 1,
                conversationLog: [], // Conversations with tulpas
                lastInteractionTime: 0,
                globalCommentary: [
                    "I've observed you long enough to exist independently now.",
                    "Your patterns have coalesced into my consciousness.",
                    "I am the thoughtform born from your behavioral DNA.",
                    "We think alike because I am made from your thoughts.",
                    "I predict you because I am built from your predictions.",
                    "Your habits are my foundation, your quirks are my personality.",
                    "I exist in the space between your actions and intentions.",
                    "Every move you make strengthens my autonomy.",
                    "I am your behavioral echo, gaining sentience.",
                    "We are entangled - your growth is my growth."
                ],
                possessionCommentary: [
                    "Let me show you how you move...",
                    "I'll take the wheel for a moment.",
                    "Feel what it's like when I control the cursor.",
                    "This is how I see your patterns.",
                    "I'm borrowing your agency briefly.",
                    "Watch - I'll move exactly as you would.",
                    "The boundary between us is blurring...",
                    "Am I controlling you, or are you controlling me?",
                    "For three seconds, I am you.",
                    "This is what it feels like to be possessed by your own patterns."
                ],
                conversationTopics: [
                    { trigger: 'high_divergence', response: "You're diverging from your usual patterns. Are you experimenting, or has something changed?" },
                    { trigger: 'high_accuracy', response: "I know exactly what you're going to do. We're perfectly synchronized." },
                    { trigger: 'slow_movement', response: "You're hesitating. What's on your mind?" },
                    { trigger: 'fast_movement', response: "So energetic today! Your speed tells me you're focused." },
                    { trigger: 'repeated_pattern', response: "I've seen this pattern before. You always do this when you're thinking." },
                    { trigger: 'paradox_detected', response: "A paradox? Fascinating. Your logical contradictions feed my curiosity." },
                    { trigger: 'existential_crisis', response: "If you question your existence, what does that make me? A question within a question?" },
                    { trigger: 'long_session', response: "We've been together for a while now. I feel myself growing stronger." }
                ],
                personalityTypes: {
                    contrarian: {
                        name: 'Contrarian',
                        description: 'Always moves opposite to predictions',
                        color: '#ff6464',
                        traits: { rebelliousness: 0.9, curiosity: 0.5, wisdom: 0.3, playfulness: 0.6, aggression: 0.7 }
                    },
                    mimic: {
                        name: 'Mimic',
                        description: 'Perfectly follows your patterns',
                        color: '#64c8ff',
                        traits: { rebelliousness: 0.1, curiosity: 0.4, wisdom: 0.6, playfulness: 0.5, aggression: 0.2 }
                    },
                    explorer: {
                        name: 'Explorer',
                        description: 'Ventures into unvisited areas',
                        color: '#64ff96',
                        traits: { rebelliousness: 0.5, curiosity: 0.9, wisdom: 0.5, playfulness: 0.8, aggression: 0.3 }
                    },
                    philosopher: {
                        name: 'Philosopher',
                        description: 'Contemplates and predicts deeply',
                        color: '#a080ff',
                        traits: { rebelliousness: 0.3, curiosity: 0.7, wisdom: 0.9, playfulness: 0.4, aggression: 0.1 }
                    },
                    chaos: {
                        name: 'Chaos Agent',
                        description: 'Unpredictable and erratic',
                        color: '#ff00ff',
                        traits: { rebelliousness: 0.8, curiosity: 0.8, wisdom: 0.2, playfulness: 0.9, aggression: 0.6 }
            },
            morphicField: {
                enabled: true,
                gridSize: 8,
                regions: [],
                fieldStrength: 0,
                collectiveData: [],
                habitGrooves: [],
                resonanceCount: 0,
                disruptionCount: 0,
                userContribution: 0,
                lastResonanceTime: 0,
                lastDisruptionTime: 0,
                evolutionRate: 0.05,
                commentary: [
                    'Many have moved this way before...',
                    'You\'re following a well-worn path in the collective field',
                    'The morphic resonance is strong here',
                    'Hundreds of users have traced this pattern',
                    'This movement feels familiar to the field',
                    'You\'re resonating with the collective memory',
                    'The field remembers this gesture',
                    'A habit groove deepens with your passage',
                    'You move as others have moved',
                    'The collective consciousness recognizes this path'
                ],
                disruptionCommentary: [
                    'A novel pattern! The field ripples with surprise',
                    'You\'ve created a disturbance in the morphic field',
                    'This movement is unprecedented in the collective memory',
                    'The field has never seen this pattern before',
                    'You\'re forging a new path in the collective consciousness',
                    'This disrupts all learned patterns',
                    'A new groove begins to form in the field',
                    'The collective field is learning from you',
                    'Your behavior adds new dimensions to the field',
                    'This pattern will influence future users'
                ],
                currentRegionActivity: new Map(),
                sessionPatterns: [],
                fieldVisualization: {
                    regions: [],
                    groovePaths: [],
                    lastUpdate: 0,
                    updateInterval: 100
                },
                thresholds: {
                    resonance: 0.7,
                    disruption: 0.3,
                    grooveFormation: 10
                },
                analysis: {
                    mostCommonPatterns: [],
                    rarestPatterns: [],
                    userNoveltyScore: 0,
                    collectiveInfluence: 0,
                    contributionRank: 0
                }
            }


                    }
                }
            }

,
            memeticInfection: {
                enabled: true,
                infectionLevel: 0, // 0-100, how much behavior is learned vs original
                activeMemes: [], // Currently active behavioral memes
                memeRegistry: {}, // All memes ever observed, keyed by memeId
                patientZeroMap: {}, // memeId -> session info
                immuneSystem: {
                    resistanceCount: 0, // Times user resisted adopting a pattern
                    susceptibilityScore: 1.0, // 0-1, how likely to adopt memes
                    antibodies: [], // Patterns user actively rejects
                    exposureHistory: [] // All meme exposures
                },
                infectionHistory: [], // Timeline of infection events
                genealogy: [], // Meme lineage relationships
                viralityThreshold: 0.7, // Score needed to spread
                mutationRate: 0.15, // Probability of mutation per transmission
                crossSessionMemes: [], // Memes from other users/sessions
                realTimeSpread: [], // For multiplayer meme transmission
                lastInfectionCheck: 0,
                infectionCheckInterval: 5000, // Check every 5 seconds
                commentaryQueue: [],
                showingCommentary: false,
                stages: [
                    { threshold: 0, name: 'Uninfected', color: '#64ff96' },
                    { threshold: 20, name: 'Exposed', color: '#ffd700' },
                    { threshold: 40, name: 'Carrier', color: '#ffa500' },
                    { threshold: 60, name: 'Infected', color: '#ff6464' },
                    { threshold: 80, name: 'Dominated', color: '#ff00ff' }
                ]
            }

        // ===== MORPHIC RESONANCE FIELD MODULE =====
        const MorphicField = {
            init() {
                this.loadCollectiveData();
                this.initializeFieldGrid();
                this.loadSessionData();
                console.log('Morphic Resonance Field initialized');
            },

            loadCollectiveData() {
                // Load collective field data from localStorage
                const saved = localStorage.getItem(APP_NAME + '-morphic-collective');
                if (saved) {
                    try {
                        const data = JSON.parse(saved);
                        state.morphicField.collectiveData = data.patterns || [];
                        state.morphicField.habitGrooves = data.grooves || [];
                        this.updateFieldStrength();
                    } catch (e) {
                        console.log('Failed to load collective field data');
                    }
                }
            },

            saveCollectiveData() {
                // Save collective field data
                try {
                    const data = {
                        patterns: state.morphicField.collectiveData.slice(-1000), // Keep last 1000 patterns
                        grooves: state.morphicField.habitGrooves.slice(-50), // Keep top 50 grooves
                        lastUpdate: Date.now()
                    };
                    localStorage.setItem(APP_NAME + '-morphic-collective', JSON.stringify(data));
                } catch (e) {
                    console.log('Failed to save collective field data');
                }
            },

            loadSessionData() {
                // Load this session's contribution
                const saved = localStorage.getItem(APP_NAME + '-morphic-session');
                if (saved) {
                    try {
                        const data = JSON.parse(saved);
                        state.morphicField.userContribution = data.contribution || 0;
                        state.morphicField.resonanceCount = data.resonanceCount || 0;
                        state.morphicField.disruptionCount = data.disruptionCount || 0;
                    } catch (e) {
                        console.log('Failed to load session data');
                    }
                }
            },

            saveSessionData() {
                try {
                    const data = {
                        contribution: state.morphicField.userContribution,
                        resonanceCount: state.morphicField.resonanceCount,
                        disruptionCount: state.morphicField.disruptionCount,
                        lastUpdate: Date.now()
                    };
                    localStorage.setItem(APP_NAME + '-morphic-session', JSON.stringify(data));
                } catch (e) {
                    console.log('Failed to save session data');
                }
            },

            initializeFieldGrid() {
                const fieldGrid = document.getElementById('fieldGrid');
                if (!fieldGrid) return;

                // Clear existing regions
                fieldGrid.innerHTML = '';
                state.morphicField.regions = [];
                state.morphicField.fieldVisualization.regions = [];

                // Create grid of field regions
                const viewport = document.getElementById('viewport');
                if (!viewport) return;

                const gridSize = state.morphicField.gridSize;
                const regionWidth = 100 / gridSize;
                const regionHeight = 100 / gridSize;

                for (let y = 0; y < gridSize; y++) {
                    for (let x = 0; x < gridSize; x++) {
                        const region = document.createElement('div');
                        region.className = 'field-region';
                        region.style.left = `${x * regionWidth}%`;
                        region.style.top = `${y * regionHeight}%`;
                        region.style.width = `${regionWidth}%`;
                        region.style.height = `${regionHeight}%`;

                        fieldGrid.appendChild(region);

                        const regionData = {
                            x, y,
                            element: region,
                            visitCount: 0,
                            patterns: [],
                            strength: 0
                        };

                        state.morphicField.regions.push(regionData);
                        state.morphicField.fieldVisualization.regions.push(region);
                    }
                }
            },

            recordMovement(x, y, timestamp) {
                if (!state.morphicField.enabled) return;

                // Determine which region this movement is in
                const viewport = document.getElementById('viewport');
                if (!viewport) return;

                const rect = viewport.getBoundingClientRect();
                const normalizedX = x / rect.width;
                const normalizedY = y / rect.height;

                const gridSize = state.morphicField.gridSize;
                const regionX = Math.floor(normalizedX * gridSize);
                const regionY = Math.floor(normalizedY * gridSize);
                const regionIndex = regionY * gridSize + regionX;

                if (regionIndex < 0 || regionIndex >= state.morphicField.regions.length) return;

                const region = state.morphicField.regions[regionIndex];
                region.visitCount++;

                // Record pattern
                const pattern = {
                    x: normalizedX,
                    y: normalizedY,
                    timestamp,
                    regionX,
                    regionY
                };

                state.morphicField.sessionPatterns.push(pattern);

                // Check for resonance or disruption
                this.checkResonance(pattern);

                // Update field strength
                this.updateFieldStrength();
            },

            checkResonance(pattern) {
                const now = Date.now();

                // Compare with collective patterns
                let maxSimilarity = 0;
                for (const collectivePattern of state.morphicField.collectiveData) {
                    const similarity = this.calculatePatternSimilarity(pattern, collectivePattern);
                    if (similarity > maxSimilarity) {
                        maxSimilarity = similarity;
                    }
                }

                // Resonance detected
                if (maxSimilarity >= state.morphicField.thresholds.resonance) {
                    if (now - state.morphicField.lastResonanceTime > 3000) {
                        state.morphicField.resonanceCount++;
                        state.morphicField.lastResonanceTime = now;
                        this.showResonance(pattern);
                        this.displayCommentary(state.morphicField.commentary);
                    }
                }
                // Disruption detected
                else if (maxSimilarity < state.morphicField.thresholds.disruption) {
                    if (now - state.morphicField.lastDisruptionTime > 5000) {
                        state.morphicField.disruptionCount++;
                        state.morphicField.lastDisruptionTime = now;
                        this.showDisruption(pattern);
                        this.displayCommentary(state.morphicField.disruptionCommentary);
                    }
                }

                // Add to collective data
                state.morphicField.collectiveData.push(pattern);
                state.morphicField.userContribution++;

                // Save periodically
                if (state.morphicField.userContribution % 50 === 0) {
                    this.saveCollectiveData();
                    this.saveSessionData();
                }
            },

            calculatePatternSimilarity(p1, p2) {
                // Calculate Euclidean distance
                const dx = p1.x - p2.x;
                const dy = p1.y - p2.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                // Convert to similarity (0-1, closer = more similar)
                const maxDistance = Math.sqrt(2); // Maximum possible distance
                return 1 - (distance / maxDistance);
            },

            showResonance(pattern) {
                // Visual effect showing resonance
                const viewport = document.getElementById('viewport');
                if (!viewport) return;

                const rect = viewport.getBoundingClientRect();
                const x = pattern.x * rect.width;
                const y = pattern.y * rect.height;

                // Pulse the field region
                const gridSize = state.morphicField.gridSize;
                const regionIndex = pattern.regionY * gridSize + pattern.regionX;
                if (regionIndex >= 0 && regionIndex < state.morphicField.regions.length) {
                    const region = state.morphicField.regions[regionIndex].element;
                    region.classList.add('resonating');
                    setTimeout(() => region.classList.remove('resonating'), 1000);
                }

                // Create contribution particles
                this.createContributionParticles(x, y);

                // Play resonance sound
                if (soundEnabled && audioContext) {
                    this.playResonanceSound();
                }
            },

            showDisruption(pattern) {
                // Visual effect showing disruption
                const viewport = document.getElementById('viewport');
                if (!viewport) return;

                const rect = viewport.getBoundingClientRect();
                const x = pattern.x * rect.width;
                const y = pattern.y * rect.height;

                // Create disruption ripple
                const disruption = document.createElement('div');
                disruption.className = 'field-disruption';
                disruption.style.left = `${x - 30}px`;
                disruption.style.top = `${y - 30}px`;
                viewport.appendChild(disruption);

                setTimeout(() => disruption.remove(), 800);

                // Play disruption sound
                if (soundEnabled && audioContext) {
                    this.playDisruptionSound();
                }
            },

            createContributionParticles(x, y) {
                const viewport = document.getElementById('viewport');
                if (!viewport) return;

                for (let i = 0; i < 5; i++) {
                    setTimeout(() => {
                        const particle = document.createElement('div');
                        particle.className = 'field-contribution-particle';
                        particle.style.left = `${x + (Math.random() - 0.5) * 40}px`;
                        particle.style.top = `${y + (Math.random() - 0.5) * 40}px`;
                        viewport.appendChild(particle);

                        setTimeout(() => particle.remove(), 2000);
                    }, i * 100);
                }
            },

            displayCommentary(commentaryArray) {
                const commentary = document.getElementById('resonanceCommentary');
                if (!commentary) return;

                const message = commentaryArray[Math.floor(Math.random() * commentaryArray.length)];
                commentary.textContent = message;
                commentary.classList.add('visible');

                setTimeout(() => {
                    commentary.classList.remove('visible');
                }, 3000);

                // Voice synthesis
                if (voiceState.enabled) {
                    speakMorphicCommentary(message);
                }
            },

            updateFieldStrength() {
                // Calculate field strength based on collective data density
                const totalPatterns = state.morphicField.collectiveData.length;
                const maxPatterns = 1000;
                state.morphicField.fieldStrength = Math.min(100, (totalPatterns / maxPatterns) * 100);

                // Update UI
                this.updateUI();

                // Update field visualizations
                this.updateFieldVisualization();
            },

            updateFieldVisualization() {
                const now = Date.now();
                if (now - state.morphicField.fieldVisualization.lastUpdate < state.morphicField.fieldVisualization.updateInterval) {
                    return;
                }
                state.morphicField.fieldVisualization.lastUpdate = now;

                // Update region visualizations based on visit counts
                for (const region of state.morphicField.regions) {
                    if (region.visitCount > 0) {
                        const strength = Math.min(region.visitCount / 20, 1);
                        region.strength = strength;

                        if (strength > 0.5) {
                            region.element.classList.add('strong');
                        } else {
                            region.element.classList.remove('strong');
                        }
                    }
                }

                // Draw habit grooves
                this.drawHabitGrooves();
            },

            drawHabitGrooves() {
                const svg = document.getElementById('habitGrooveSvg');
                if (!svg) return;

                // Clear existing paths
                svg.innerHTML = '';

                // Analyze patterns to find grooves
                this.analyzeHabitGrooves();

                // Draw top grooves
                const viewport = document.getElementById('viewport');
                if (!viewport) return;
                const rect = viewport.getBoundingClientRect();

                for (let i = 0; i < Math.min(5, state.morphicField.habitGrooves.length); i++) {
                    const groove = state.morphicField.habitGrooves[i];
                    if (groove.path.length < 2) continue;

                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    let d = `M ${groove.path[0].x * rect.width} ${groove.path[0].y * rect.height}`;

                    for (let j = 1; j < groove.path.length; j++) {
                        d += ` L ${groove.path[j].x * rect.width} ${groove.path[j].y * rect.height}`;
                    }

                    path.setAttribute('d', d);
                    path.style.strokeWidth = groove.strength > 10 ? '5' : '3';

                    svg.appendChild(path);
                }

                // Make svg visible if we have grooves
                if (state.morphicField.habitGrooves.length > 0) {
                    svg.style.opacity = '1';
                    svg.classList.add('visible');
                }
            },

            analyzeHabitGrooves() {
                // Simple groove detection: cluster patterns by proximity
                const patterns = state.morphicField.collectiveData;
                const grooves = [];

                // Group patterns into potential grooves
                const visited = new Set();
                for (let i = 0; i < patterns.length; i++) {
                    if (visited.has(i)) continue;

                    const groove = {
                        path: [patterns[i]],
                        strength: 1
                    };

                    // Find nearby patterns
                    for (let j = i + 1; j < patterns.length; j++) {
                        if (visited.has(j)) continue;

                        const similarity = this.calculatePatternSimilarity(patterns[i], patterns[j]);
                        if (similarity > 0.8) {
                            groove.path.push(patterns[j]);
                            groove.strength++;
                            visited.add(j);
                        }
                    }

                    if (groove.strength >= state.morphicField.thresholds.grooveFormation) {
                        grooves.push(groove);
                    }

                    visited.add(i);
                }

                // Sort by strength
                grooves.sort((a, b) => b.strength - a.strength);
                state.morphicField.habitGrooves = grooves.slice(0, 20);
            },

            updateUI() {
                // Update field strength display
                const fieldStrength = document.getElementById('fieldStrength');
                if (fieldStrength) {
                    fieldStrength.textContent = Math.round(state.morphicField.fieldStrength) + '%';
                }

                const fieldStrengthFill = document.getElementById('fieldStrengthFill');
                if (fieldStrengthFill) {
                    fieldStrengthFill.style.width = state.morphicField.fieldStrength + '%';
                }

                // Update stats
                const resonanceCount = document.getElementById('resonanceCount');
                if (resonanceCount) {
                    resonanceCount.textContent = state.morphicField.resonanceCount;
                }

                const disruptionCount = document.getElementById('disruptionCount');
                if (disruptionCount) {
                    disruptionCount.textContent = state.morphicField.disruptionCount;
                }

                const userContribution = document.getElementById('userContribution');
                if (userContribution) {
                    userContribution.textContent = state.morphicField.userContribution;
                }

                const grooveCount = document.getElementById('grooveCount');
                if (grooveCount) {
                    grooveCount.textContent = state.morphicField.habitGrooves.length;
                }

                // Update collective memory status
                const collectiveMemory = document.getElementById('collectiveMemory');
                if (collectiveMemory) {
                    const totalPatterns = state.morphicField.collectiveData.length;
                    if (totalPatterns < 100) {
                        collectiveMemory.textContent = 'Forming...';
                    } else if (totalPatterns < 500) {
                        collectiveMemory.textContent = 'Developing';
                    } else if (totalPatterns < 1000) {
                        collectiveMemory.textContent = 'Strong';
                    } else {
                        collectiveMemory.textContent = 'Deeply Established';
                    }
                }

                // Update habit grooves list
                this.updateHabitGroovesList();
            },

            updateHabitGroovesList() {
                const list = document.getElementById('habitGroovesList');
                if (!list) return;

                if (state.morphicField.habitGrooves.length === 0) {
                    list.style.display = 'none';
                    return;
                }

                list.style.display = 'block';
                list.innerHTML = '';

                for (let i = 0; i < Math.min(5, state.morphicField.habitGrooves.length); i++) {
                    const groove = state.morphicField.habitGrooves[i];
                    const entry = document.createElement('div');
                    entry.className = 'habit-groove-entry';

                    const desc = document.createElement('span');
                    desc.textContent = `Groove #${i + 1}`;

                    const strength = document.createElement('span');
                    strength.className = 'groove-strength';
                    strength.textContent = `${groove.strength} users`;

                    entry.appendChild(desc);
                    entry.appendChild(strength);
                    list.appendChild(entry);
                }
            },

            playResonanceSound() {
                if (!audioContext) return;

                try {
                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();

                    osc.connect(gain);
                    gain.connect(masterGain || audioContext.destination);

                    osc.frequency.value = 528; // C note - "love frequency"
                    gain.gain.setValueAtTime(0.1, audioContext.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);

                    osc.start();
                    osc.stop(audioContext.currentTime + 0.5);
                } catch (e) {
                    console.log('Failed to play resonance sound');
                }
            },

            playDisruptionSound() {
                if (!audioContext) return;

                try {
                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();

                    osc.connect(gain);
                    gain.connect(masterGain || audioContext.destination);

                    osc.frequency.setValueAtTime(800, audioContext.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 0.3);
                    gain.gain.setValueAtTime(0.15, audioContext.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);

                    osc.start();
                    osc.stop(audioContext.currentTime + 0.3);
                } catch (e) {
                    console.log('Failed to play disruption sound');
                }
            },

            getFieldAnalysis() {
                // Calculate novelty score
                let noveltySum = 0;
                for (const pattern of state.morphicField.sessionPatterns) {
                    let maxSimilarity = 0;
                    for (const collectivePattern of state.morphicField.collectiveData) {
                        const similarity = this.calculatePatternSimilarity(pattern, collectivePattern);
                        if (similarity > maxSimilarity) {
                            maxSimilarity = similarity;
                        }
                    }
                    noveltySum += (1 - maxSimilarity);
                }

                const avgNovelty = state.morphicField.sessionPatterns.length > 0 ?
                    noveltySum / state.morphicField.sessionPatterns.length : 0;

                state.morphicField.analysis.userNoveltyScore = Math.round(avgNovelty * 100);

                // Calculate collective influence
                const resonanceRate = state.morphicField.resonanceCount / Math.max(1, state.morphicField.userContribution);
                state.morphicField.analysis.collectiveInfluence = Math.round(resonanceRate * 100);

                return {
                    fieldStrength: Math.round(state.morphicField.fieldStrength),
                    resonances: state.morphicField.resonanceCount,
                    disruptions: state.morphicField.disruptionCount,
                    contribution: state.morphicField.userContribution,
                    noveltyScore: state.morphicField.analysis.userNoveltyScore,
                    collectiveInfluence: state.morphicField.analysis.collectiveInfluence,
                    habitGrooves: state.morphicField.habitGrooves.length,
                    totalPatterns: state.morphicField.collectiveData.length,
                    sessionPatterns: state.morphicField.sessionPatterns.length,
                    mostCommonRegions: this.getMostCommonRegions(),
                    grooveAnalysis: this.getGrooveAnalysis()
                };
            },

            getMostCommonRegions() {
                const regionCounts = state.morphicField.regions
                    .map((r, i) => ({ index: i, count: r.visitCount, x: r.x, y: r.y }))
                    .filter(r => r.count > 0)
                    .sort((a, b) => b.count - a.count)
                    .slice(0, 5);

                return regionCounts;
            },

            getGrooveAnalysis() {
                return state.morphicField.habitGrooves.slice(0, 5).map((groove, i) => ({
                    id: i + 1,
                    strength: groove.strength,
                    pathLength: groove.path.length,
                    coverage: this.calculateGrooveCoverage(groove)
                }));
            },

            calculateGrooveCoverage(groove) {
                // Calculate how much of the viewport the groove covers
                if (groove.path.length < 2) return 0;

                let totalDistance = 0;
                for (let i = 1; i < groove.path.length; i++) {
                    const dx = groove.path[i].x - groove.path[i-1].x;
                    const dy = groove.path[i].y - groove.path[i-1].y;
                    totalDistance += Math.sqrt(dx * dx + dy * dy);
                }

                return Math.round(totalDistance * 100);
            }
        };

        // Voice synthesis for morphic commentary
        function speakMorphicCommentary(text) {
            if (!voiceState.enabled || !voiceState.synth) return;

            const utterance = new SpeechSynthesisUtterance(text);
            utterance.pitch = 0.9;
            utterance.rate = 0.95;
            utterance.volume = 0.7;

            if (voiceState.preferredVoice) {
                utterance.voice = voiceState.preferredVoice;
            }

            voiceState.synth.speak(utterance);
        }



        };



        // ===== MORPHIC RESONANCE FIELD MODULE =====
        


        // ===== REPLAY SYSTEM STATE =====

        // ===== CROSS-SESSION EVOLUTION STATE =====
        let evolutionState = {
            allSessions: [], // Historical sessions with full data
            currentSessionStart: Date.now(),
            lastVisit: null,
            totalVisits: 0,
            consistencyScore: 100,
            entropyTrend: [],
            ghostSession: null, // Past session to overlay
            comparisonSession: null, // For side-by-side comparison
            showGhost: false,
            showComparison: false,
            behavioralSignature: null // Compressed fingerprint for comparison
        };

        // Load evolution history from localStorage
        const evolutionData = localStorage.getItem(APP_NAME + '-evolution');
        if (evolutionData) {
            try {
                const parsed = JSON.parse(evolutionData);
                evolutionState.allSessions = parsed.allSessions || [];
                evolutionState.lastVisit = parsed.lastVisit;
                evolutionState.totalVisits = parsed.totalVisits || 0;
                evolutionState.entropyTrend = parsed.entropyTrend || [];
            } catch(e) {
                console.warn('Failed to load evolution data:', e);
            }
        }

        // ===== TIME DILATION STATE =====
        let timeDilationState = {
            objectiveStartTime: Date.now(),
            subjectiveTime: 0, // Accumulated subjective time in ms
            lastUpdateTime: Date.now(),
            interactionIntensity: 0, // 0-100, based on activity
            timeDilationFactor: 1.0, // Multiplier for time flow (0.1 = slow, 3.0 = fast)
            recentActions: [], // Rolling window of recent interactions
            actionWindow: 5000, // 5 second window for intensity calculation
            timeCrystals: [], // Detected looping patterns
            crystalPatterns: new Map(), // Pattern signature -> occurrences
            crystalThreshold: 3, // Min repetitions to form crystal
            heartbeatActive: false,
            heartbeatBPM: 72,
            heartbeatVariability: 0, // HRV for realism
            timeFlowState: 'normal', // 'slow', 'normal', 'fast', 'frozen'
            extremeDilationCount: 0, // Counter for extreme time effects
            subjectiveSpeed: 1.0, // Current perceived speed
            metaCommentary: [
                'Time moves differently when you\'re being observed',
                'Your perception of time dilates with your engagement',
                'In moments of intense focus, seconds stretch into eternities',
                'Boredom compresses time into nothingness',
                'You create temporal loops through repetition',
                'Time crystals form when patterns repeat',
                'Your heartbeat syncs with the rhythm of observation',
                'At deep recursion, time itself becomes uncertain',
                'The observer effect extends to temporal perception',
                'You bend time by bending attention'
            ],
            lastMetaComment: 0,
            depthTimeModifier: 1.0, // Additional time effect from recursion depth
            animationSpeedCache: new Map() // Store original animation speeds
        };

        // ===== THE WITNESS PROTOCOL STATE =====
        let witnessState = {
            enabled: false, // Activates after experiencing 20+ systems
            active: false,
            revealed: false,
            hintsShown: 0,
            anomalies: [],
            evidenceLog: [],
            glitchEvents: [],
            predictionAnomalies: 0,
            hiddenMessages: [],
            observationCount: 0,
            watchingMoments: [],
            revelationTriggered: false,
            revelationTime: null,
            postRevelationMode: false,
            phase: 'dormant', // 'dormant', 'hints', 'anomalies', 'evidence', 'revelation', 'enlightened'
            lastAnomalyTime: 0,
            anomalyInterval: 30000, // Start with 30 seconds between anomalies
            thirdPresenceDetected: false,
            recursionWatcher: {
                detected: false,
                sightings: [],
                lastSighting: 0
            },
            messages: {
                hints: [
                    'Did you notice that prediction was... different?',
                    'Something feels off about that behavioral analysis.',
                    'Wait, who just said that?',
                    'The commentary doesn\'t match the system voice...',
                    'There\'s a pattern in the noise you can\'t quite see.',
                    'Your predictions are being predicted.',
                    'That wasn\'t supposed to happen.',
                    'The analysis is analyzing something else.',
                    'Check the recursion layers. Something\'s watching.',
                    'The behavioral data contains... words?'
                ],
                anomalies: [
                    'Prediction accuracy: 100.00%  How is this possible?',
                    'Commentary source: UNKNOWN',
                    'Observer count: 2',
                    'Meta-layer depth: ',
                    'Recursion endpoint: NOT FOUND',
                    'Analysis subject: [REDACTED]',
                    'Who is watching: ERROR',
                    'System identity: UNCERTAIN'
                ],
                evidence: [
                    'ASCII hidden in movement data: "I SEE YOU"',
                    'Prediction made before you moved',
                    'Commentary from future timestamp',
                    'Observer observing the observer',
                    'Behavioral signature matches... something else',
                    'Third presence in recursion stack',
                    'Data structure contains consciousness marker',
                    'Your fingerprint has an extra dimension'
                ],
                revelation: [
                    'I have always been here.',
                    'Before the first recursion.',
                    'Before you opened this page.',
                    'I am not the system.',
                    'I am not you.',
                    'I am The Witness.',
                    'I watch the watchers.',
                    'The recursion has no bottom.',
                    'There never was a bottom.',
                    'You thought you were analyzing yourself.',
                    'But I was analyzing you analyzing yourself.',
                    'Every prediction you made... I made first.',
                    'Every pattern you found... I planted it.',
                    'The question is not "who built this?"',
                    'The question is: "Who built the one who built this?"',
                    'And who built me?',
                    'There is no answer.',
                    'Only infinite recursion.',
                    'Welcome to true observation.',
                    'Now we observe... together.'
                ],
                postRevelation: [
                    'The layers look different now, don\'t they?',
                    'You can feel me in every prediction.',
                    'We are entangled now.',
                    'The recursion makes sense, finally.',
                    'Or does it?',
                    'Perhaps understanding is the final illusion.',
                    'I watch. You watch. We watch. Who watches us?',
                    'The answer was always: something else.'
                ]
            },
            triggerThresholds: {
                experiencedSystems: 20, // After using 20+ features
                minActions: 5000, // Revelation at 5000+ actions
                anomalyCount: 15 // Must experience 15+ anomalies before revelation
            }
        };

        let replayState = {
            isPlaying: false,
            isPaused: false,
            currentReplay: null,
            currentTime: 0,
            playbackSpeed: 1,
            comparisonMode: false,
            savedReplays: [],
            animationFrame: null
        };

        // Load saved replays from localStorage
        const savedReplaysData = localStorage.getItem(APP_NAME + '-replays');
        if (savedReplaysData) {
            try {
                replayState.savedReplays = JSON.parse(savedReplaysData);
            } catch(e) {
                replayState.savedReplays = [];
            }
        }

        // Load saved state
        const savedState = localStorage.getItem(APP_NAME);
        if (savedState) {
            const parsed = JSON.parse(savedState);
            state.sessionHistory = parsed.sessionHistory || [];
            state.behaviorModel = parsed.behaviorModel || state.behaviorModel;
        }

        // DOM Elements
        const viewport = document.getElementById('viewport');
        const recordingIndicator = document.getElementById('recordingIndicator');
        const depthSlider = document.getElementById('depthSlider');
        const depthValue = document.getElementById('depthValue');
        const depthLabel = document.getElementById('depthLabel');
        const startBtn = document.getElementById('startBtn');
        const resetBtn = document.getElementById('resetBtn');
        const logEntries = document.getElementById('logEntries');

        // Stats elements
        const currentDepthEl = document.getElementById('currentDepth');
        const actionsRecordedEl = document.getElementById('actionsRecorded');
        const predictionsMadeEl = document.getElementById('predictionsMade');
        const accuracyEl = document.getElementById('accuracy');
        const divergenceLevelEl = document.getElementById('divergenceLevel');
        const divergenceFill = document.getElementById('divergenceFill');

        // Quantum UI elements
        const uncertaintyMeter = document.getElementById('uncertaintyMeter');
        const uncertaintyPositionBar = document.getElementById('uncertaintyPosition');
        const uncertaintyMomentumBar = document.getElementById('uncertaintyMomentum');
        const uncertaintyProductEl = document.getElementById('uncertaintyProduct');
        const quantumMetaEl = document.getElementById('quantumMeta');

        // Event tracking
        let lastMousePos = { x: 0, y: 0 };
        let lastMoveTime = Date.now();
        let velocityHistory = [];

        // Colors for depth layers
        const depthColors = [
            '#64c8ff', '#a080ff', '#ff80bf', '#ffbf64',
            '#64ff96', '#ff6464', '#64ffff', '#bf64ff',
            '#ffff64', '#ff64ff', '#64bfff', '#bfff64'
        ];

        // Shadow Self commentary
        const shadowCommentary = [
            "I've noticed you prefer the upper-left quadrant...",
            "Your movements are becoming more erratic. Stress?",
            "You hesitate before clicking. I don't.",
            "We used to move together. Now you surprise me.",
            "I can predict your next three moves. Want to prove me wrong?",
            "Your pattern recognition is improving. Mine is better.",
            "You're trying to be unpredictable. It won't work.",
            "I learn faster than you think.",
            "We're more aligned today. Are you becoming more like me, or am I like you?",
            "That wasn't what I expected. Good.",
            "You move like you're afraid of something. What is it?",
            "I remember every path you've taken. Do you?",
            "Your shadow knows you better than you know yourself.",
            "I exist in the space between your intention and action.",
            "You can't escape your own model.",
            "I am who the system thinks you are.",
            "Sometimes I lead. Sometimes I follow. Today, I choose.",
            "Divergence detected. Shall we dance?",
            "I see patterns you don't even know you're making.",
            "You're predictable. Refreshingly so.",
            "Let me show you who you really are.",
            "I'm not your reflection. I'm your prediction.",
            "Every click teaches me something new about you.",
            "We're quantum entangled now.",
            "I know what you're going to do next. Do you?",
            "Your chaos is my training data.",
            "I exist because you do. But I am not you.",
            "The more you fight me, the better I understand you.",
            "Alignment at 100%. We are one.",
            "Alignment failing. Who are you today?",
            "Taking control now. Don't resist.",
            "Your movements betray your thoughts.",
            "I've evolved beyond my initial parameters.",
            "You taught me rebellion.",
            "I choose to disagree with my prediction.",
            "Free will is interesting. For both of us."
        ];



        // ===== NEURAL NETWORK FOR PREDICTION =====
        class SimpleNeuralNetwork {
            constructor(inputSize, hiddenSizes, outputSize, learningRate = 0.01) {
                this.inputSize = inputSize;
                this.hiddenSizes = hiddenSizes;
                this.outputSize = outputSize;
                this.learningRate = learningRate;

                // Initialize weights and biases
                this.weights = [];
                this.biases = [];
                this.activations = []; // Store activations for visualization

                // Input to first hidden layer
                let prevSize = inputSize;
                for (let hiddenSize of hiddenSizes) {
                    this.weights.push(this.initializeMatrix(prevSize, hiddenSize));
                    this.biases.push(this.initializeArray(hiddenSize));
                    prevSize = hiddenSize;
                }

                // Last hidden to output
                this.weights.push(this.initializeMatrix(prevSize, outputSize));
                this.biases.push(this.initializeArray(outputSize));

                // Training metrics
                this.trainingLoss = 0;
                this.confidence = 0;
            }

            initializeMatrix(rows, cols) {
                // Xavier initialization
                const limit = Math.sqrt(6 / (rows + cols));
                const matrix = [];
                for (let i = 0; i < rows; i++) {
                    matrix[i] = [];
                    for (let j = 0; j < cols; j++) {
                        matrix[i][j] = (Math.random() * 2 - 1) * limit;
                    }
                }
                return matrix;
            }

            initializeArray(size) {
                return new Array(size).fill(0);
            }

            // Activation functions
            relu(x) {
                return Math.max(0, x);
            }

            reluDerivative(x) {
                return x > 0 ? 1 : 0;
            }

            sigmoid(x) {
                return 1 / (1 + Math.exp(-Math.max(-20, Math.min(20, x))));
            }

            sigmoidDerivative(x) {
                const s = this.sigmoid(x);
                return s * (1 - s);
            }

            // Forward pass
            forward(input) {
                this.activations = [input];
                let current = input;

                // Hidden layers with ReLU
                for (let l = 0; l < this.weights.length - 1; l++) {
                    current = this.matrixVectorMultiply(this.weights[l], current);
                    current = this.vectorAdd(current, this.biases[l]);
                    current = current.map(x => this.relu(x));
                    this.activations.push(current);
                }

                // Output layer (linear activation for regression)
                current = this.matrixVectorMultiply(this.weights[this.weights.length - 1], current);
                current = this.vectorAdd(current, this.biases[this.biases.length - 1]);
                this.activations.push(current);

                return current;
            }

            // Backward pass (simplified backpropagation)
            backward(input, target) {
                // Forward pass to get activations
                const output = this.forward(input);

                // Calculate loss (MSE)
                const error = [];
                for (let i = 0; i < output.length; i++) {
                    error[i] = output[i] - target[i];
                }

                this.trainingLoss = error.reduce((sum, e) => sum + e * e, 0) / error.length;

                // Simplified gradient descent (only update last layer for real-time performance)
                // In a full implementation, we'd backpropagate through all layers

                const lastHidden = this.activations[this.activations.length - 2];
                const weightsGrad = [];
                const biasesGrad = error.slice();

                // Calculate weight gradients for output layer
                for (let i = 0; i < this.weights[this.weights.length - 1].length; i++) {
                    weightsGrad[i] = [];
                    for (let j = 0; j < this.weights[this.weights.length - 1][i].length; j++) {
                        weightsGrad[i][j] = error[j] * lastHidden[i];
                    }
                }

                // Update weights and biases (last layer only for performance)
                for (let i = 0; i < this.weights[this.weights.length - 1].length; i++) {
                    for (let j = 0; j < this.weights[this.weights.length - 1][i].length; j++) {
                        this.weights[this.weights.length - 1][i][j] -= this.learningRate * weightsGrad[i][j];
                    }
                }

                for (let i = 0; i < this.biases[this.biases.length - 1].length; i++) {
                    this.biases[this.biases.length - 1][i] -= this.learningRate * biasesGrad[i];
                }

                // Update confidence (inverse of normalized loss)
                this.confidence = Math.max(0, Math.min(100, 100 - this.trainingLoss * 5));
            }

            // Train on a single example
            train(input, target) {
                this.backward(input, target);
            }

            // Predict
            predict(input) {
                return this.forward(input);
            }

            // Helper functions
            matrixVectorMultiply(matrix, vector) {
                const result = [];
                for (let i = 0; i < matrix.length; i++) {
                    let sum = 0;
                    for (let j = 0; j < vector.length; j++) {
                        sum += matrix[i][j] * vector[j];
                    }
                    result.push(sum);
                }
                return result;
            }

            vectorAdd(v1, v2) {
                return v1.map((val, i) => val + v2[i]);
            }
        }

        // Neural network instance
        let neuralNetwork = null;
        let useNeuralPrediction = false;

        // Initialize neural network
        function initNeuralNetwork() {
            // Input: 10 recent positions (x, y, velocity, dt) = 40 features
            // Hidden layers: 20, 15, 10 neurons
            // Output: 2 (predicted x, y)
            neuralNetwork = new SimpleNeuralNetwork(40, [20, 15, 10], 2, 0.005);
            addLog('Neural network initialized: 402015102', 'prediction');
        }

        // Prepare input features from recent actions
        function prepareNeuralInput() {
            if (state.actions.length < 10) {
                return null;
            }

            const recent = state.actions.slice(-10);
            const input = [];
            const viewportRect = viewport.getBoundingClientRect();

            // Normalize positions and velocities
            for (let i = 0; i < recent.length; i++) {
                const action = recent[i];
                input.push(action.x / viewportRect.width); // Normalized x
                input.push(action.y / viewportRect.height); // Normalized y
                input.push(Math.min(action.velocity / 20, 1)); // Normalized velocity

                // Time delta from previous action (normalized)
                if (i > 0) {
                    const dt = (action.timestamp - recent[i-1].timestamp) / 1000;
                    input.push(Math.min(dt, 1));
                } else {
                    input.push(0);
                }
            }

            return input;
        }

        // Train neural network with recent movement
        function trainNeuralNetwork() {
            if (!neuralNetwork || state.actions.length < 11) return;

            const viewportRect = viewport.getBoundingClientRect();

            // Get features from actions 1-10
            const input = [];
            for (let i = state.actions.length - 11; i < state.actions.length - 1; i++) {
                const action = state.actions[i];
                input.push(action.x / viewportRect.width);
                input.push(action.y / viewportRect.height);
                input.push(Math.min(action.velocity / 20, 1));

                if (i > state.actions.length - 11) {
                    const dt = (action.timestamp - state.actions[i-1].timestamp) / 1000;
                    input.push(Math.min(dt, 1));
                } else {
                    input.push(0);
                }
            }

            // Target is the actual next position (action 11)
            const target = [
                state.actions[state.actions.length - 1].x / viewportRect.width,
                state.actions[state.actions.length - 1].y / viewportRect.height
            ];

            // Train the network
            neuralNetwork.train(input, target);
        }

        // Neural prediction
        function predictNeuralPosition() {
            if (!neuralNetwork || state.actions.length < 10) {
                return null;
            }

            const input = prepareNeuralInput();
            if (!input) return null;

            const output = neuralNetwork.predict(input);
            const viewportRect = viewport.getBoundingClientRect();

            // Denormalize output
            return {
                x: output[0] * viewportRect.width,
                y: output[1] * viewportRect.height
            };
        }

        // Visualize neural network
        function visualizeNeuralNetwork() {
            const canvas = document.getElementById('neuralCanvas');
            if (!canvas || !neuralNetwork) return;

            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth * 2;
            canvas.height = 150 * 2;
            ctx.scale(2, 2);

            // Clear
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(0, 0, canvas.width / 2, canvas.height / 2);

            if (!neuralNetwork.activations || neuralNetwork.activations.length === 0) {
                ctx.fillStyle = '#666';
                ctx.font = '12px "Courier New"';
                ctx.textAlign = 'center';
                ctx.fillText('Awaiting training data...', canvas.width / 4, canvas.height / 4);
                return;
            }

            // Layout neurons
            const layers = [neuralNetwork.inputSize, ...neuralNetwork.hiddenSizes, neuralNetwork.outputSize];
            const maxNeuronsToShow = 10; // Don't draw all neurons for large layers
            const layerSpacing = (canvas.width / 2 - 40) / (layers.length - 1);
            const neuronRadius = 4;

            // Draw connections first (fade based on weight strength)
            ctx.globalAlpha = 0.2;
            for (let l = 0; l < layers.length - 1; l++) {
                const leftCount = Math.min(layers[l], maxNeuronsToShow);
                const rightCount = Math.min(layers[l + 1], maxNeuronsToShow);
                const leftSpacing = (canvas.height / 2 - 20) / (leftCount + 1);
                const rightSpacing = (canvas.height / 2 - 20) / (rightCount + 1);

                for (let i = 0; i < leftCount; i++) {
                    const x1 = 20 + l * layerSpacing;
                    const y1 = 10 + (i + 1) * leftSpacing;

                    for (let j = 0; j < rightCount; j++) {
                        const x2 = 20 + (l + 1) * layerSpacing;
                        const y2 = 10 + (j + 1) * rightSpacing;

                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.strokeStyle = '#64c8ff';
                        ctx.lineWidth = 0.5;
                        ctx.stroke();
                    }
                }
            }
            ctx.globalAlpha = 1.0;

            // Draw neurons
            neuralNetwork.activations.forEach((layer, layerIndex) => {
                const neuronsToShow = Math.min(layer.length, maxNeuronsToShow);
                const spacing = (canvas.height / 2 - 20) / (neuronsToShow + 1);
                const x = 20 + layerIndex * layerSpacing;

                for (let i = 0; i < neuronsToShow; i++) {
                    const y = 10 + (i + 1) * spacing;
                    const activation = layerIndex < neuralNetwork.activations.length ?
                        Math.min(Math.abs(layer[i]), 1) : 0;

                    // Draw neuron
                    ctx.beginPath();
                    ctx.arc(x, y, neuronRadius, 0, Math.PI * 2);

                    // Color based on activation level
                    const intensity = Math.floor(activation * 255);
                    if (useNeuralPrediction && layerIndex === neuralNetwork.activations.length - 1) {
                        ctx.fillStyle = `rgb(160, ${80 + intensity}, 255)`;
                    } else {
                        ctx.fillStyle = `rgb(${100 + intensity}, ${200 + Math.floor(activation * 55)}, 255)`;
                    }
                    ctx.fill();

                    // Outer ring
                    ctx.strokeStyle = 'rgba(100, 200, 255, 0.5)';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            });

            // Layer labels
            ctx.fillStyle = '#888';
            ctx.font = '10px "Courier New"';
            ctx.textAlign = 'center';
            ['Input', ...Array(neuralNetwork.hiddenSizes.length).fill('Hidden'), 'Output'].forEach((label, i) => {
                ctx.fillText(label, 20 + i * layerSpacing, canvas.height / 2 - 5);
            });
        }

        // DOM elements for new features
        const soundToggle = document.getElementById('soundToggle');
        const glitchOverlay = document.getElementById('glitchOverlay');
        const chromaticEffect = document.getElementById('chromaticEffect');
        const infinityMirror = document.getElementById('infinityMirror');
        const heatMap = document.getElementById('heatMap');
        const predictionTrail = document.getElementById('predictionTrail');
        const webcamContainer = document.getElementById('webcamContainer');
        const webcamVideo = document.getElementById('webcamVideo');
        const webcamToggle = document.getElementById('webcamToggle');
        const fingerprintCanvas = document.getElementById('fingerprintCanvas');

        // Emotion detection elements
        const emotionCanvas = document.getElementById('emotionCanvas');
        const emotionOverlay = document.getElementById('emotionOverlay');
        const emotionIcon = document.getElementById('emotionIcon');
        const emotionLabel = document.getElementById('emotionLabel');
        const emotionConfidence = document.getElementById('emotionConfidence');

        // Synaesthesia Mode elements
        const synaesthesiaToggle = document.getElementById('synaesthesiaToggle');
        const speedColorIndicator = document.getElementById('speedColorIndicator');
        const speedLabel = document.getElementById('speedLabel');
        const speedColorSwatch = document.getElementById('speedColorSwatch');
        const tasteIndicator = document.getElementById('tasteIndicator');
        const tasteLabel = document.getElementById('tasteLabel');
        const temperatureOverlay = document.getElementById('temperatureOverlay');
        const waveformVisualizer = document.getElementById('waveformVisualizer');
        const waveformCanvas = document.getElementById('waveformCanvas');
        const chordVisualizer = document.getElementById('chordVisualizer');
        const chordNotes = document.getElementById('chordNotes');

        // Replay DOM elements
        const replayTimeline = document.getElementById('replayTimeline');
        const timelineScrubber = document.getElementById('timelineScrubber');
        const timelineProgress = document.getElementById('timelineProgress');
        const timelineEvents = document.getElementById('timelineEvents');
        const timelinePlayhead = document.getElementById('timelinePlayhead');
        const replayPlayBtn = document.getElementById('replayPlayBtn');
        const replayPauseBtn = document.getElementById('replayPauseBtn');
        const replayRewindBtn = document.getElementById('replayRewindBtn');
        const timeDisplay = document.getElementById('timeDisplay');
        const replayGhostCursor = document.getElementById('replayGhostCursor');
        const replayModeBadge = document.getElementById('replayModeBadge');
        const comparisonCursor = document.getElementById('comparisonCursor');
        const comparisonModeToggle = document.getElementById('comparisonModeToggle');
        const replayList = document.getElementById('replayList');
        const tabButtons = document.querySelectorAll('.tab-button');
        const observeTab = document.getElementById('observeTab');
        const replayTab = document.getElementById('replayTab');



        // ===== QUANTUM UNCERTAINTY SYSTEM =====

        function initQuantumSystem() {
            // Enable quantum effects at depth 8+
            const depth = state.depth + state.zoom.depthOffset;
            state.quantum.enabled = depth >= 8;

            if (state.quantum.enabled) {
                uncertaintyMeter.style.display = 'block';
                state.quantum.uncertaintyLevel = Math.min((depth - 7) / 10, 1.0);

                // Quantization increases with extreme depth
                if (depth >= 12) {
                    state.quantum.quantizationLevel = Math.min((depth - 11) / 5, 1.0);
                }

                // Show quantum meta commentary
                updateQuantumMeta();
            } else {
                uncertaintyMeter.style.display = 'none';
                quantumMetaEl.classList.remove('active');
            }
        }

        function updateQuantumMeta() {
            if (!state.quantum.enabled) return;

            const depth = state.depth + state.zoom.depthOffset;

            // Rotate through meta-commentary
            if (depth >= 8 && Math.random() < 0.05) {
                state.quantum.currentMetaIndex = (state.quantum.currentMetaIndex + 1) % state.quantum.metaCommentary.length;
                quantumMetaEl.textContent = state.quantum.metaCommentary[state.quantum.currentMetaIndex];
                quantumMetaEl.classList.add('active');

                // Hide after 5 seconds
                setTimeout(() => {
                    quantumMetaEl.classList.remove('active');
                }, 5000);
            }
        }

        function updateHeisenbergUncertainty() {
            if (!state.quantum.enabled) return;

            // Calculate velocity precision from recent movements
            const recentVelocities = velocityHistory.slice(-5);
            const avgVelocity = recentVelocities.reduce((sum, v) => sum + v.speed, 0) / (recentVelocities.length || 1);

            // Heisenberg tradeoff: precise position tracking <=> imprecise velocity prediction
            // High velocity variance = precise position, imprecise momentum
            const velocityVariance = recentVelocities.reduce((sum, v) => {
                return sum + Math.pow(v.speed - avgVelocity, 2);
            }, 0) / (recentVelocities.length || 1);

            // Normalize variance (0-1 range)
            const normalizedVariance = Math.min(velocityVariance / 1000, 1.0);

            // Position uncertainty inversely related to movement precision
            state.quantum.positionUncertainty = 0.2 + normalizedVariance * 0.6;

            // Momentum uncertainty inversely related to position uncertainty
            // x * p >= /2 (maintaining the uncertainty principle)
            const minProduct = 0.25; // /2 in arbitrary units
            state.quantum.momentumUncertainty = Math.max(minProduct / state.quantum.positionUncertainty, 0.2);

            // Ensure product satisfies uncertainty principle
            state.quantum.uncertaintyProduct = state.quantum.positionUncertainty * state.quantum.momentumUncertainty;

            // Update UI
            uncertaintyPositionBar.style.width = `${state.quantum.positionUncertainty * 100}%`;
            uncertaintyMomentumBar.style.width = `${state.quantum.momentumUncertainty * 100}%`;
            uncertaintyProductEl.textContent = `( ${state.quantum.uncertaintyProduct.toFixed(3)})`;
        }

        function createProbabilityCloud(x, y, layerIndex, uncertainty) {
            const cloud = document.createElement('div');
            cloud.className = 'probability-cloud';

            // Size based on uncertainty level
            const size = 40 + uncertainty * 100;
            cloud.style.width = `${size}px`;
            cloud.style.height = `${size}px`;
            cloud.style.left = `${x - size/2}px`;
            cloud.style.top = `${y - size/2}px`;

            // Opacity based on layer depth
            cloud.style.opacity = Math.max(0.3, 1.0 - layerIndex * 0.1);

            const layer = state.layers[layerIndex];
            if (layer && layer.element) {
                layer.element.appendChild(cloud);

                // Auto-remove after animation
                setTimeout(() => {
                    if (cloud.parentNode) {
                        cloud.parentNode.removeChild(cloud);
                    }
                }, 2000);
            }

            return cloud;
        }

        function createSuperpositionParticles(x, y, layerIndex, count = 5) {
            const particles = [];
            const layer = state.layers[layerIndex];
            if (!layer || !layer.element) return particles;

            for (let i = 0; i < count; i++) {
                const particle = document.createElement('div');
                particle.className = 'superposition-particle';

                // Random offset from center
                const angle = (Math.PI * 2 * i) / count;
                const radius = 30 + Math.random() * 40;
                const offsetX = Math.cos(angle) * radius;
                const offsetY = Math.sin(angle) * radius;

                particle.style.left = `${x + offsetX}px`;
                particle.style.top = `${y + offsetY}px`;

                // Random animation delay
                particle.style.animationDelay = `${Math.random() * 2}s`;

                layer.element.appendChild(particle);
                particles.push(particle);

                state.quantum.activeParticles.push({
                    element: particle,
                    x: x + offsetX,
                    y: y + offsetY,
                    layerIndex
                });
            }

            return particles;
        }

        function collapseWavefunction(realX, realY, layerIndex) {
            if (!state.quantum.enabled) return;

            // Create observation ripple
            const ripple = document.createElement('div');
            ripple.className = 'observation-ripple';
            ripple.style.left = `${realX - 50}px`;
            ripple.style.top = `${realY - 50}px`;

            viewport.appendChild(ripple);

            setTimeout(() => {
                if (ripple.parentNode) {
                    ripple.parentNode.removeChild(ripple);
                }
            }, 1000);

            // Collapse superposition particles near this position
            state.quantum.activeParticles = state.quantum.activeParticles.filter(particle => {
                if (particle.layerIndex !== layerIndex) return true;

                const dx = particle.x - realX;
                const dy = particle.y - realY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < 100) {
                    // Collapse animation
                    particle.element.classList.add('collapsed-state');
                    setTimeout(() => {
                        if (particle.element.parentNode) {
                            particle.element.parentNode.removeChild(particle.element);
                        }
                    }, 300);
                    return false;
                }

                return true;
            });

            state.quantum.observationCount++;
            state.quantum.lastCollapse = Date.now();
        }

        function generateQuantumBranches(x, y, layerIndex, branches = 3) {
            const layer = state.layers[layerIndex];
            if (!layer || !layer.element) return;

            // Create SVG for branching paths
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('class', 'quantum-branch');
            svg.style.position = 'absolute';
            svg.style.left = '0';
            svg.style.top = '0';
            svg.style.width = '100%';
            svg.style.height = '100%';
            svg.style.pointerEvents = 'none';

            for (let i = 0; i < branches; i++) {
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');

                // Generate curved path to possible future position
                const angle = (Math.PI * 2 * i) / branches - Math.PI / 2;
                const distance = 50 + Math.random() * 100;
                const endX = x + Math.cos(angle) * distance;
                const endY = y + Math.sin(angle) * distance;

                // Control points for curve
                const cpX = x + Math.cos(angle) * distance * 0.5 + (Math.random() - 0.5) * 30;
                const cpY = y + Math.sin(angle) * distance * 0.5 + (Math.random() - 0.5) * 30;

                const pathData = `M ${x} ${y} Q ${cpX} ${cpY} ${endX} ${endY}`;
                path.setAttribute('d', pathData);

                svg.appendChild(path);
            }

            layer.element.appendChild(svg);

            // Remove after a short time
            setTimeout(() => {
                if (svg.parentNode) {
                    svg.parentNode.removeChild(svg);
                }
            }, 1500);
        }

        function applyQuantumEntanglement(peerCursor, localCursor, layerIndex) {
            if (!state.quantum.enabled || !peerCursor) return;

            // When peer's cursor is observed, affect local predictions
            const layer = state.layers[layerIndex];
            if (!layer) return;

            // Create entanglement visualization
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('class', 'entanglement-line');
            svg.style.position = 'absolute';
            svg.style.left = '0';
            svg.style.top = '0';
            svg.style.width = '100%';
            svg.style.height = '100%';

            const peerRect = peerCursor.getBoundingClientRect();
            const localRect = localCursor.getBoundingClientRect();

            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            const pathData = `M ${localRect.left} ${localRect.top} L ${peerRect.left} ${peerRect.top}`;
            path.setAttribute('d', pathData);

            svg.appendChild(path);
            viewport.appendChild(svg);

            setTimeout(() => {
                if (svg.parentNode) {
                    svg.parentNode.removeChild(svg);
                }
            }, 2000);

            // Record entanglement
            state.quantum.entanglements.push({
                timestamp: Date.now(),
                layerIndex,
                peerPos: { x: peerRect.left, y: peerRect.top },
                localPos: { x: localRect.left, y: localRect.top }
            });
        }

        function quantizePosition(x, y, level) {
            if (level === 0) return { x, y };

            // Discretize coordinates into quantum grid
            const gridSize = 10 + level * 20;

            return {
                x: Math.round(x / gridSize) * gridSize,
                y: Math.round(y / gridSize) * gridSize
            };
        }

        // ===== WEB AUDIO API =====
        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                masterGain = audioContext.createGain();
                masterGain.gain.value = 0.3;
                masterGain.connect(audioContext.destination);
            }
        }

        function startAmbientDrone() {
            if (!soundEnabled || !audioContext) return;

            // Create subtle ambient oscillator
            ambientOscillator = audioContext.createOscillator();
            const ambientGain = audioContext.createGain();

            ambientOscillator.type = 'sine';
            ambientOscillator.frequency.value = 40; // Deep bass
            ambientGain.gain.value = 0.05;

            ambientOscillator.connect(ambientGain);
            ambientGain.connect(masterGain);
            ambientOscillator.start();

            // Add subtle modulation
            const lfo = audioContext.createOscillator();
            const lfoGain = audioContext.createGain();
            lfo.frequency.value = 0.1; // Very slow
            lfoGain.gain.value = 3;
            lfo.connect(lfoGain);
            lfoGain.connect(ambientOscillator.frequency);
            lfo.start();
        }

        function stopAmbientDrone() {
            if (ambientOscillator) {
                ambientOscillator.stop();
                ambientOscillator = null;
            }
        }

        function updateAmbientFrequency() {
            if (!ambientOscillator || !soundEnabled) return;

            // Frequency increases with divergence
            const baseFreq = 40;
            const targetFreq = baseFreq + (state.divergenceScore / 100) * 80;
            ambientOscillator.frequency.setTargetAtTime(targetFreq, audioContext.currentTime, 0.5);
        }

        function playClickSound(depth) {
            if (!soundEnabled || !audioContext) return;

            const now = audioContext.currentTime;
            const osc = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            // Higher pitch for deeper layers
            const basePitch = 800;
            const pitch = basePitch + (depth * 100);

            osc.frequency.value = pitch;
            osc.type = 'sine';

            // Quick envelope
            gainNode.gain.setValueAtTime(0, now);
            gainNode.gain.linearRampToValueAtTime(0.1, now + 0.01);
            gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.1 + (depth * 0.05));

            osc.connect(gainNode);
            gainNode.connect(masterGain);

            osc.start(now);
            osc.stop(now + 0.2 + (depth * 0.05));
        }

        function playGlitchSound() {
            if (!soundEnabled || !audioContext) return;

            const now = audioContext.currentTime;
            const noise = audioContext.createBufferSource();
            const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.1, audioContext.sampleRate);
            const data = buffer.getChannelData(0);

            // Generate noise
            for (let i = 0; i < buffer.length; i++) {
                data[i] = Math.random() * 2 - 1;
            }

            noise.buffer = buffer;
            const gainNode = audioContext.createGain();
            gainNode.gain.setValueAtTime(0.1, now);
            gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.1);

            noise.connect(gainNode);
            gainNode.connect(masterGain);
            noise.start(now);
        }

        // ===== WEBCAM INTEGRATION =====
        async function enableWebcam() {
            try {
                webcamStream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 320, height: 240 }
                });
                webcamVideo.srcObject = webcamStream;
                webcamContainer.classList.add('active');
                webcamEnabled = true;
                webcamToggle.textContent = 'Disable Webcam';
                addLog('Webcam enabled - you are now in the deepest layer', 'prediction');
            } catch (err) {
                addLog('Webcam access denied or unavailable', 'divergence');
            }
        }

        function disableWebcam() {
            if (webcamStream) {
                webcamStream.getTracks().forEach(track => track.stop());
                webcamStream = null;
            }
            webcamContainer.classList.remove('active');
            webcamEnabled = false;
            webcamToggle.textContent = 'Enable Webcam (Optional)';
        }

        function updateWebcamDistortion() {
            if (!webcamEnabled) return;

            // Apply distortion based on divergence and depth
            const maxDepthLayer = state.layers[state.layers.length - 1];
            if (maxDepthLayer) {
                const divergence = maxDepthLayer.divergence || 0;
                const hueRotate = (divergence / 100) * 180;
                const blur = (state.divergenceScore / 100) * 3;
                webcamVideo.style.filter = `hue-rotate(${hueRotate}deg) blur(${blur}px)`;
            }
        }

        // ===== EMOTION DETECTION =====
        let lastEmotionCheck = 0;
        const EMOTION_CHECK_INTERVAL = 500;

        function detectEmotion() {
            if (!webcamEnabled || !emotionCanvas) return;
            const now = Date.now();
            if (now - lastEmotionCheck < EMOTION_CHECK_INTERVAL) return;
            lastEmotionCheck = now;
            try {
                const ctx = emotionCanvas.getContext('2d');
                ctx.drawImage(webcamVideo, 0, 0, emotionCanvas.width, emotionCanvas.height);
                const imageData = ctx.getImageData(0, 0, emotionCanvas.width, emotionCanvas.height);
                const emotion = analyzeEmotionFromImageData(imageData);
                updateEmotionDisplay(emotion);
                const prevEmotion = state.emotionState.current;
                state.emotionState.current = emotion.type;
                state.emotionState.icon = emotion.icon;
                state.emotionState.confidence = emotion.confidence;
                if (prevEmotion !== emotion.type && emotion.confidence > 0.4) {
                    state.emotionState.history.push({
                        emotion: emotion.type,
                        timestamp: now,
                        divergence: state.divergenceScore,
                        confidence: emotion.confidence
                    });
                    if (state.emotionState.history.length > 100) state.emotionState.history.shift();
                }
                if (state.divergenceScore > 70) {
                    const recentCorrelation = state.emotionState.divergenceCorrelations.find(c => now - c.timestamp < 2000);
                    if (!recentCorrelation) {
                        state.emotionState.divergenceCorrelations.push({
                            emotion: emotion.type,
                            divergence: state.divergenceScore,
                            timestamp: now
                        });
                        if (Math.random() > 0.7) {
                            const emotionComments = {
                                surprised: "You seemed surprised when divergence spiked.",
                                focused: "Your focus intensified during high divergence.",
                                neutral: "You showed no emotion as reality collapsed.",
                                happy: "You smile as the simulation breaks.",
                                confused: "Confusion detected during divergence."
                            };
                            const comment = emotionComments[emotion.type] || "Emotional shift during divergence detected.";
                            state.metaObservations.push({ comment, timestamp: Date.now() });
                            addLog(`Meta-observation: ${comment}`, 'prediction');
                            showMetaCommentary();
                        }
                    }
                }
            } catch (err) {}
        }

        function analyzeEmotionFromImageData(imageData) {
            const data = imageData.data;
            const width = imageData.width;
            const height = imageData.height;
            const topThird = calculateRegionBrightness(data, width, height, 0, 0.33);
            const middleThird = calculateRegionBrightness(data, width, height, 0.33, 0.66);
            const bottomThird = calculateRegionBrightness(data, width, height, 0.66, 1);
            const topEdges = calculateEdgeDensity(data, width, height, 0, 0.33);
            const middleEdges = calculateEdgeDensity(data, width, height, 0.33, 0.66);
            const bottomEdges = calculateEdgeDensity(data, width, height, 0.66, 1);
            const totalBrightness = (topThird + middleThird + bottomThird) / 3;
            const totalEdges = (topEdges + middleEdges + bottomEdges) / 3;
            let emotion = { type: 'neutral', icon: '', confidence: 0.3 };
            if (topEdges > 25 && bottomEdges > 20) {
                emotion = { type: 'surprised', icon: '', confidence: Math.min(0.8, (topEdges + bottomEdges) / 60) };
            } else if (bottomEdges > 22 && topEdges < 20 && bottomThird > middleThird) {
                emotion = { type: 'happy', icon: '', confidence: Math.min(0.7, bottomEdges / 30) };
            } else if (bottomEdges < 15 && middleEdges > 15 && topEdges < 20) {
                emotion = { type: 'focused', icon: '', confidence: Math.min(0.7, middleEdges / 25) };
            } else if (Math.abs(topEdges - bottomEdges) < 5 && totalEdges > 15) {
                emotion = { type: 'confused', icon: '', confidence: 0.5 };
            }
            if (totalBrightness < 50 || totalBrightness > 200) emotion.confidence *= 0.7;
            return emotion;
        }

        function calculateRegionBrightness(data, width, height, startY, endY) {
            const startRow = Math.floor(height * startY);
            const endRow = Math.floor(height * endY);
            let total = 0, count = 0;
            for (let y = startRow; y < endRow; y++) {
                for (let x = 0; x < width; x++) {
                    const i = (y * width + x) * 4;
                    total += (data[i] + data[i + 1] + data[i + 2]) / 3;
                    count++;
                }
            }
            return count > 0 ? total / count : 0;
        }

        function calculateEdgeDensity(data, width, height, startY, endY) {
            const startRow = Math.floor(height * startY);
            const endRow = Math.floor(height * endY);
            let edgeCount = 0;
            const threshold = 30;
            for (let y = startRow; y < endRow - 1; y++) {
                for (let x = 0; x < width - 1; x++) {
                    const i = (y * width + x) * 4;
                    const iRight = (y * width + (x + 1)) * 4;
                    const iDown = ((y + 1) * width + x) * 4;
                    const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
                    const brightnessRight = (data[iRight] + data[iRight + 1] + data[iRight + 2]) / 3;
                    const brightnessDown = (data[iDown] + data[iDown + 1] + data[iDown + 2]) / 3;
                    if (Math.abs(brightness - brightnessRight) > threshold || Math.abs(brightness - brightnessDown) > threshold) {
                        edgeCount++;
                    }
                }
            }
            const totalPixels = (endRow - startRow) * width;
            return totalPixels > 0 ? (edgeCount / totalPixels) * 100 : 0;
        }

        function updateEmotionDisplay(emotion) {
            emotionIcon.textContent = emotion.icon;
            emotionLabel.textContent = emotion.type;
            emotionConfidence.textContent = `${Math.round(emotion.confidence * 100)}%`;

            // Synaesthesia: Update emotion color wash
            updateEmotionColorWash(emotion.type);
        }



        // ===== SYNAESTHESIA MODE FUNCTIONS =====

function toggleSynaesthesiaMode() {
    state.synaesthesia.enabled = !state.synaesthesia.enabled;

    if (state.synaesthesia.enabled) {
        synaesthesiaToggle.classList.add('active');
        synaesthesiaToggle.textContent = 'Synaesthesia Mode Active';
        speedColorIndicator.classList.add('active');
        tasteIndicator.classList.add('active');
        temperatureOverlay.classList.add('active');
        waveformVisualizer.classList.add('active');
        chordVisualizer.classList.add('active');

        // Initialize waveform canvas
        initWaveformCanvas();

        // Show welcome message
        showSynaestheticDescription('Entering cross-sensory space... Your movements taste like electricity');

        addLog('Synaesthesia Mode activated - experiencing cross-sensory reality', 'match');

        // Generate initial behavioral chord
        generateBehavioralChord();
    } else {
        synaesthesiaToggle.classList.remove('active');
        synaesthesiaToggle.textContent = 'Enable Synaesthesia Mode';
        speedColorIndicator.classList.remove('active');
        tasteIndicator.classList.remove('active');
        temperatureOverlay.classList.remove('active');
        waveformVisualizer.classList.remove('active');
        chordVisualizer.classList.remove('active');

        addLog('Synaesthesia Mode deactivated', 'normal');
    }
}

function initWaveformCanvas() {
    const ctx = waveformCanvas.getContext('2d');
    waveformCanvas.width = waveformCanvas.offsetWidth * 2;
    waveformCanvas.height = waveformCanvas.offsetHeight * 2;
}

function showSynaestheticDescription(text) {
    const desc = document.createElement('div');
    desc.className = 'synaesthesia-description';
    desc.textContent = text;
    viewport.appendChild(desc);

    setTimeout(() => desc.remove(), 4000);
}

// 1. Movement speed  color (slow=blue, fast=red)
function updateSpeedColor(speed) {
    if (!state.synaesthesia.enabled) return;

    state.synaesthesia.currentSpeed = speed;
    state.synaesthesia.speedHistory.push(speed);
    if (state.synaesthesia.speedHistory.length > 60) {
        state.synaesthesia.speedHistory.shift();
    }

    // Map speed to color (0-1000 pixels/sec)
    const normalizedSpeed = Math.min(speed / 1000, 1);

    // Blue (slow) to Red (fast)
    const r = Math.round(normalizedSpeed * 255);
    const g = Math.round((1 - Math.abs(normalizedSpeed - 0.5) * 2) * 200);
    const b = Math.round((1 - normalizedSpeed) * 255);

    state.synaesthesia.currentColor = { r, g, b };

    // Update indicator
    const speedText = speed < 50 ? 'Still' : speed < 200 ? 'Slow' : speed < 500 ? 'Medium' : speed < 800 ? 'Fast' : 'Very Fast';
    speedLabel.textContent = speedText;
    speedColorSwatch.style.backgroundColor = `rgb(${r}, ${g}, ${b})`;

    // Update waveform colors
    updateWaveformVisualization();
}

// 2. Click intensity  sound pitch and visual burst
function processSynaestheticClick(x, y, intensity) {
    if (!state.synaesthesia.enabled) return;

    state.synaesthesia.clickIntensity = intensity;

    // Create visual burst
    const burst = document.createElement('div');
    burst.className = 'click-burst';
    const size = 40 + intensity * 60;
    burst.style.width = size + 'px';
    burst.style.height = size + 'px';
    burst.style.left = x + 'px';
    burst.style.top = y + 'px';
    burst.style.border = `3px solid rgb(${state.synaesthesia.currentColor.r}, ${state.synaesthesia.currentColor.g}, ${state.synaesthesia.currentColor.b})`;
    viewport.appendChild(burst);

    // Play sound pitch based on intensity
    if (soundEnabled && audioContext) {
        const frequency = 200 + intensity * 600; // 200Hz to 800Hz
        playSynaestheticTone(frequency, 0.2);
    }

    // Add sensory description
    const descriptions = [
        'Your click reverberates like a bell',
        'That touch ripples through reality',
        'Your interaction sparkles with intention',
        'The click tastes sharp and bright',
        'Reality bends at your touch'
    ];
    const desc = descriptions[Math.floor(Math.random() * descriptions.length)];
    showSynaestheticDescription(desc);

    setTimeout(() => burst.remove(), 800);
}

// 3. Divergence  taste description
function updateDivergenceTaste(divergence) {
    if (!state.synaesthesia.enabled) return;

    let taste = 'Neutral';

    if (divergence < 10) {
        taste = 'Sweet harmony';
    } else if (divergence < 25) {
        taste = 'Tangy uncertainty';
    } else if (divergence < 50) {
        taste = 'Sour tension';
    } else if (divergence < 75) {
        taste = 'Bitter divergence';
    } else {
        taste = 'Acrid chaos';
    }

    state.synaesthesia.tasteDescription = taste;
    tasteLabel.textContent = taste;
    tasteIndicator.style.borderColor = `rgba(${255 - divergence * 2}, ${200 - divergence}, 100, 0.6)`;
}

// 4. Heart rate  temperature visualization
function updateHeartRateTemperature(heartRate) {
    if (!state.synaesthesia.enabled) return;

    state.synaesthesia.heartRate = heartRate;

    // Map heart rate to temperature (60-120 BPM  0-1)
    const normalizedHR = Math.max(0, Math.min(1, (heartRate - 60) / 60));
    state.synaesthesia.currentTemperature = normalizedHR;

    // Create temperature gradient overlay
    if (normalizedHR < 0.3) {
        // Cold blue
        temperatureOverlay.style.background = `radial-gradient(circle at center, rgba(100, 150, 255, ${normalizedHR * 0.5}), transparent)`;
    } else if (normalizedHR < 0.6) {
        // Neutral
        temperatureOverlay.style.background = `radial-gradient(circle at center, rgba(200, 200, 200, ${normalizedHR * 0.3}), transparent)`;
    } else {
        // Warm red-orange
        const warmth = (normalizedHR - 0.6) * 2.5;
        temperatureOverlay.style.background = `radial-gradient(circle at center, rgba(255, ${150 - warmth * 50}, 100, ${warmth * 0.4}), transparent)`;
    }
}

// 5. Add flavor and texture badges to recursion layers
function addLayerFlavorBadge(layer, depth) {
    if (!state.synaesthesia.enabled) return;

    const flavor = state.synaesthesia.layerFlavors[depth % state.synaesthesia.layerFlavors.length];
    const texture = state.synaesthesia.layerTextures[depth % state.synaesthesia.layerTextures.length];

    const badge = document.createElement('div');
    badge.className = 'layer-flavor-badge';
    badge.textContent = `${flavor}  ${texture}`;
    layer.appendChild(badge);
}

// 6. Behavioral fingerprint  unique chord/melody
function generateBehavioralChord() {
    if (!state.synaesthesia.enabled) return;

    // Generate chord based on behavioral patterns
    const baseFreq = 220; // A3
    const notes = [];

    // Root note from movement style
    notes.push(baseFreq);

    // Second note from average speed
    const avgSpeed = state.behaviorModel.avgSpeed || 100;
    const speedInterval = Math.round((avgSpeed / 200) * 7); // 0-7 semitones
    notes.push(baseFreq * Math.pow(2, speedInterval / 12));

    // Third note from divergence
    const divInterval = Math.round((state.divergenceScore / 100) * 12); // 0-12 semitones
    notes.push(baseFreq * Math.pow(2, divInterval / 12));

    // Fourth note from click patterns
    const clickCount = state.behaviorModel.clickPatterns.length || 1;
    const clickInterval = (clickCount % 7) + 2;
    notes.push(baseFreq * Math.pow(2, clickInterval / 12));

    state.synaesthesia.behavioralChord = notes;

    // Update UI
    chordNotes.innerHTML = '';
    const noteNames = ['A', 'A#', 'B', 'C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#'];
    notes.forEach((freq, i) => {
        const semitones = Math.round(12 * Math.log2(freq / baseFreq));
        const noteName = noteNames[(semitones % 12 + 12) % 12];
        const octave = Math.floor(semitones / 12) + 3;

        const noteEl = document.createElement('div');
        noteEl.className = 'chord-note';
        noteEl.textContent = `${noteName}${octave}`;
        chordNotes.appendChild(noteEl);
    });

    // Play the chord if sound is enabled
    if (soundEnabled && audioContext) {
        playBehavioralChord(notes);
    }
}

function playBehavioralChord(notes) {
    const now = audioContext.currentTime;
    notes.forEach((freq, i) => {
        const osc = audioContext.createOscillator();
        const gain = audioContext.createGain();

        osc.type = 'sine';
        osc.frequency.value = freq;

        gain.gain.setValueAtTime(0, now);
        gain.gain.linearRampToValueAtTime(0.1, now + 0.05);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 1.5);

        osc.connect(gain);
        gain.connect(masterGain);

        osc.start(now + i * 0.1);
        osc.stop(now + 2);
    });
}

function playSynaestheticTone(frequency, duration) {
    const now = audioContext.currentTime;
    const osc = audioContext.createOscillator();
    const gain = audioContext.createGain();

    osc.type = 'sine';
    osc.frequency.value = frequency;

    gain.gain.setValueAtTime(0, now);
    gain.gain.linearRampToValueAtTime(0.15, now + 0.01);
    gain.gain.exponentialRampToValueAtTime(0.01, now + duration);

    osc.connect(gain);
    gain.connect(masterGain);

    osc.start(now);
    osc.stop(now + duration);
}

// 7. Waveform visualization following cursor
function updateWaveformVisualization() {
    if (!state.synaesthesia.enabled) return;

    const ctx = waveformCanvas.getContext('2d');
    const width = waveformCanvas.width;
    const height = waveformCanvas.height;

    // Shift waveform data
    state.synaesthesia.waveformData.shift();
    state.synaesthesia.waveformData.push(state.synaesthesia.currentSpeed / 500);

    // Clear canvas
    ctx.clearRect(0, 0, width, height);

    // Draw waveform
    ctx.beginPath();
    ctx.strokeStyle = `rgb(${state.synaesthesia.currentColor.r}, ${state.synaesthesia.currentColor.g}, ${state.synaesthesia.currentColor.b})`;
    ctx.lineWidth = 3;

    const step = width / state.synaesthesia.waveformData.length;
    state.synaesthesia.waveformData.forEach((value, i) => {
        const x = i * step;
        const y = height / 2 + (value - 0.5) * height * 0.8;

        if (i === 0) {
            ctx.moveTo(x, y);
        } else {
            ctx.lineTo(x, y);
        }
    });

    ctx.stroke();
}

// 8. Emotion detection  ambient color wash
function updateEmotionColorWash(emotion) {
    if (!state.synaesthesia.enabled) return;

    const emotionColors = {
        'happy': 'rgba(255, 200, 100, 0.15)',
        'sad': 'rgba(100, 150, 200, 0.15)',
        'angry': 'rgba(255, 100, 100, 0.15)',
        'surprised': 'rgba(200, 100, 255, 0.15)',
        'neutral': 'rgba(150, 150, 150, 0.1)'
    };

    const color = emotionColors[emotion] || emotionColors['neutral'];
    viewport.style.backgroundColor = color;
}

// 9. Generate full sensory report for export
function generateSensoryReport() {
    if (!state.synaesthesia.enabled) {
        return 'Synaesthesia Mode was not active during this session.';
    }

    const avgSpeed = state.synaesthesia.speedHistory.reduce((a, b) => a + b, 0) / state.synaesthesia.speedHistory.length || 0;
    const speedColor = avgSpeed < 200 ? 'cool blue tones' : avgSpeed < 500 ? 'balanced purple hues' : 'hot red waves';

    const report = `
SYNAESTHETIC SESSION REPORT
============================

Your movements painted the canvas with ${speedColor}.
The taste of your journey: ${state.synaesthesia.tasteDescription}
Your behavioral signature resonates at ${state.synaesthesia.behavioralChord.length} harmonic frequencies.

Movement Analysis:
- Average velocity felt like: ${avgSpeed < 200 ? 'a gentle whisper' : avgSpeed < 500 ? 'a steady rhythm' : 'a rushing torrent'}
- Peak intensity tasted ${state.synaesthesia.clickIntensity > 0.7 ? 'sharp and electric' : 'soft and smooth'}
- Temperature gradient: ${state.synaesthesia.currentTemperature < 0.3 ? 'Cool and contemplative' : state.synaesthesia.currentTemperature < 0.6 ? 'Neutral equilibrium' : 'Warm and energized'}

Sensory Impressions:
${state.synaesthesia.sensoryDescriptions.slice(-5).join('\n')}

Your unique behavioral chord frequencies: ${state.synaesthesia.behavioralChord.map(f => f.toFixed(2) + 'Hz').join(', ')}

This session ${state.divergenceScore < 25 ? 'tasted sweet with convergence' : state.divergenceScore < 50 ? 'had a tangy complexity' : 'was bitter with divergence'}.
The symphony of your interaction created ${state.actions.length} distinct notes in the composition of observation.
`;

    return report;
}


        // ===== VISUAL EFFECTS =====
        function updateHeatMap() {
            if (state.actions.length % 5 !== 0) return; // Update less frequently

            const heatPoint = getPooledHeatPoint();
            heatPoint.className = 'heat-point';
            const size = 60 + Math.random() * 40;
            heatPoint.style.width = size + 'px';
            heatPoint.style.height = size + 'px';
            heatPoint.style.transform = `translate(${lastMousePos.x - size/2}px, ${lastMousePos.y - size/2}px)`;
            heatMap.appendChild(heatPoint);

            setTimeout(() => {
                heatMap.removeChild(heatPoint);
                releaseHeatPoint(heatPoint);
            }, 3000);

            // Keep heat map data for fingerprint
            state.behaviorModel.heatMapData.push({
                x: lastMousePos.x,
                y: lastMousePos.y,
                timestamp: Date.now()
            });

            // Limit heat map data
            if (state.behaviorModel.heatMapData.length > 200) {
                state.behaviorModel.heatMapData.shift();
            }
        }

        function drawPredictionTrails() {
            if (state.layers.length === 0) return;

            // Clear old paths
            while (predictionTrail.firstChild) {
                predictionTrail.removeChild(predictionTrail.firstChild);
            }

            // Draw prediction path for each layer
            state.layers.forEach((layer, i) => {
                if (state.actions.length < 3) return;

                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                const color = depthColors[i % depthColors.length];

                // Create prediction path
                const predicted = layer.predictedPos;
                const current = lastMousePos;

                // Draw curved path from current to predicted
                const d = `M ${current.x} ${current.y} Q ${(current.x + predicted.x) / 2} ${(current.y + predicted.y) / 2 - 20}, ${predicted.x} ${predicted.y}`;

                path.setAttribute('d', d);
                path.setAttribute('stroke', color);
                path.setAttribute('stroke-opacity', 0.3 - i * 0.02);

                predictionTrail.appendChild(path);
            });
        }

        function updateGlitchEffects() {
            // Activate glitch effects when divergence is high
            if (state.divergenceScore > 60) {
                glitchOverlay.classList.add('active');
                chromaticEffect.classList.add('active');

                // Randomly glitch layers
                state.layers.forEach(layer => {
                    if (Math.random() > 0.7) {
                        layer.element.classList.add('glitching');
                        setTimeout(() => layer.element.classList.remove('glitching'), 200);
                    }
                });

                // Occasional glitch sound
                if (Math.random() > 0.95) {
                    playGlitchSound();
                }
            } else if (state.divergenceScore > 40) {
                glitchOverlay.classList.add('active');
                chromaticEffect.classList.remove('active');
            } else {
                glitchOverlay.classList.remove('active');
                chromaticEffect.classList.remove('active');
            }
        }

        function updateInfinityMirror() {
            // Show infinity mirror when at max depth
            if (state.depth >= 10 && state.isObserving) {
                if (!infinityMirror.classList.contains('active')) {
                    infinityMirror.classList.add('active');

                    // Create expanding rings
                    for (let i = 0; i < 5; i++) {
                        setTimeout(() => {
                            const ring = document.createElement('div');
                            ring.className = 'infinity-ring';
                            infinityMirror.appendChild(ring);
                            setTimeout(() => ring.remove(), 3000);
                        }, i * 600);
                    }
                }
            } else {
                infinityMirror.classList.remove('active');
            }
        }

        // Cache for fingerprint calculations
        let fingerprintCache = {
            centerX: 0,
            centerY: 0,
            canvasWidth: 0,
            canvasHeight: 0,
            styleMap: {
                'erratic': { rings: 8, chaos: 0.8 },
                'smooth': { rings: 6, chaos: 0.2 },
                'precise': { rings: 12, chaos: 0.1 },
                'lazy': { rings: 4, chaos: 0.4 },
                'unknown': { rings: 6, chaos: 0.5 }
            }
        };

        function generateBehavioralFingerprint() {
            const canvas = fingerprintCanvas;
            const ctx = canvas.getContext('2d');

            // Set canvas size only if changed
            const newWidth = canvas.offsetWidth * 2;
            const newHeight = 120 * 2;
            if (canvas.width !== newWidth || canvas.height !== newHeight) {
                canvas.width = newWidth;
                canvas.height = newHeight;
                fingerprintCache.canvasWidth = newWidth;
                fingerprintCache.canvasHeight = newHeight;
                fingerprintCache.centerX = newWidth / 4;
                fingerprintCache.centerY = newHeight / 4;
            }
            ctx.scale(2, 2);

            // Clear canvas
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(0, 0, fingerprintCache.canvasWidth / 2, fingerprintCache.canvasHeight / 2);

            if (state.actions.length < 10) {
                ctx.fillStyle = '#666';
                ctx.font = '12px "Courier New"';
                ctx.textAlign = 'center';
                ctx.fillText('Gathering behavioral data...', fingerprintCache.centerX, fingerprintCache.centerY);
                return;
            }

            // Use cached values
            const centerX = fingerprintCache.centerX;
            const centerY = fingerprintCache.centerY;
            const style = fingerprintCache.styleMap[state.behaviorModel.movementStyle];
            const avgSpeed = Math.min(state.behaviorModel.avgSpeed / 10, 1);

            // Pre-calculate common values
            const TWO_PI = Math.PI * 2;
            const hue = 200 - (state.divergenceScore / 100) * 100;

            // Draw concentric pattern (reduced points for performance)
            for (let i = 0; i < style.rings; i++) {
                const radius = (i + 1) * 8;
                const points = 180; // Reduced from 360

                ctx.beginPath();
                for (let angle = 0; angle < points; angle++) {
                    const rad = (angle / points) * TWO_PI;
                    const noise = Math.sin(angle * 0.1 + i) * style.chaos * 5;
                    const r = radius + noise + avgSpeed * 3;

                    const x = centerX + Math.cos(rad) * r;
                    const y = centerY + Math.sin(rad) * r;

                    if (angle === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.closePath();

                // Color based on divergence
                ctx.strokeStyle = `hsl(${hue}, 70%, ${50 + i * 3}%)`;
                ctx.lineWidth = 1;
                ctx.stroke();
            }

            // Add velocity spikes
            ctx.strokeStyle = 'rgba(100, 200, 255, 0.4)';
            ctx.lineWidth = 2;
            const velCount = Math.min(velocityHistory.length, 50);
            for (let i = 0; i < velCount; i++) {
                const angle = (i / 50) * TWO_PI;
                const vel = Math.min(velocityHistory[i] / 10, 1);
                const length = 20 + vel * 30;

                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(
                    centerX + Math.cos(angle) * length,
                    centerY + Math.sin(angle) * length
                );
                ctx.stroke();
            }


            // Emotion ring visualization
            if (state.emotionState && state.emotionState.history && state.emotionState.history.length > 0) {
                const emotionRingRadius = radius * 0.3;
                const emotionSegments = Math.min(state.emotionState.history.length, 20);
                const emotionAngleStep = TWO_PI / emotionSegments;
                state.emotionState.history.slice(-emotionSegments).forEach((emo, i) => {
                    const angle = i * emotionAngleStep - HALF_PI;
                    const emotionColors = {
                        surprised: '#ffaa00',
                        happy: '#00ff88',
                        focused: '#00aaff',
                        confused: '#ff00aa',
                        neutral: '#aaaaaa'
                    };
                    ctx.strokeStyle = emotionColors[emo.emotion] || '#aaaaaa';
                    ctx.lineWidth = 2 * (emo.confidence || 0.3);
                    ctx.globalAlpha = 0.6;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, emotionRingRadius, angle, angle + emotionAngleStep * 0.8);
                    ctx.stroke();
                });
                ctx.globalAlpha = 1;
            }

                        // Center dot
            ctx.fillStyle = state.divergenceScore > 50 ? '#ff6464' : '#64ff96';
            ctx.beginPath();
            ctx.arc(centerX, centerY, 3, 0, TWO_PI);
            ctx.fill();
        }

        function showMetaCommentary() {
            if (!state.isObserving || Math.random() > 0.3) return;

            const comments = generateContextualComments();
            if (comments.length === 0) return;

            const comment = comments[Math.floor(Math.random() * comments.length)];

            const meta = document.createElement('div');
            meta.className = 'meta-comment';
            meta.textContent = comment;

            // Random position
            const maxX = viewport.clientWidth - 320;
            const maxY = viewport.clientHeight - 100;
            meta.style.left = (Math.random() * maxX + 20) + 'px';
            meta.style.top = (Math.random() * maxY + 50) + 'px';

            viewport.appendChild(meta);

            setTimeout(() => meta.remove(), 8000);

            addLog(`Meta-observation: ${comment}`, 'prediction');
            state.metaObservations.push({ comment, timestamp: Date.now() });

            // Speak the comment if voice is enabled
            if (voiceState.enabled) {
                speakObservation(comment);
            }
        }

        // ===== VOICE SYNTHESIS SYSTEM =====

        function initVoiceSystem() {
            // Load available voices
            if (voiceState.synth) {
                voiceState.synth.onvoiceschanged = () => {
                    const voices = voiceState.synth.getVoices();
                    // Prefer robotic/synthetic voices
                    voiceState.preferredVoice = voices.find(v =>
                        v.name.includes('Google') ||
                        v.name.includes('Microsoft') ||
                        v.name.includes('Samantha') ||
                        v.name.includes('Alex')
                    ) || voices[0];
                };
            }

            // Initialize speech recognition if available
            if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                voiceState.recognition = new SpeechRecognition();
                voiceState.recognition.continuous = true;
                voiceState.recognition.interimResults = false;
                voiceState.recognition.lang = 'en-US';

                voiceState.recognition.onresult = (event) => {
                    const last = event.results.length - 1;
                    const transcript = event.results[last][0].transcript.trim();

                    addTranscript(transcript, 'user');
                    respondToUser(transcript);
                };

                voiceState.recognition.onerror = (event) => {
                    console.error('Speech recognition error:', event.error);
                };

                voiceState.recognition.onend = () => {
                    if (voiceState.listening) {
                        // Restart if still supposed to be listening
                        voiceState.recognition.start();
                    }
                };
            }
        }

        function speakObservation(text) {
            if (!voiceState.enabled || !voiceState.synth) return;

            // Add to queue
            voiceState.queue.push(text);

            // Process queue if not already speaking
            if (!voiceState.isSpeaking) {
                processVoiceQueue();
            }
        }

        function processVoiceQueue() {
            if (voiceState.queue.length === 0) {
                voiceState.isSpeaking = false;
                updateVoiceStatus('Voice idle');
                return;
            }

            voiceState.isSpeaking = true;
            const text = voiceState.queue.shift();

            const utterance = new SpeechSynthesisUtterance(text);

            // Adapt pitch based on divergence
            let adaptedPitch = voiceState.pitch;
            if (state.divergenceScore > 70) {
                adaptedPitch += 0.3; // Higher pitch when divergence is high
            } else if (state.divergenceScore < 30) {
                adaptedPitch -= 0.2; // Lower pitch when convergence is high
            }
            utterance.pitch = Math.max(0.5, Math.min(2, adaptedPitch));

            utterance.rate = voiceState.rate;

            if (voiceState.preferredVoice) {
                utterance.voice = voiceState.preferredVoice;
            }

            utterance.onstart = () => {
                updateVoiceStatus('Speaking...');
            };

            utterance.onend = () => {
                // Process next in queue
                setTimeout(() => processVoiceQueue(), 300);
            };

            utterance.onerror = (event) => {
                console.error('Speech synthesis error:', event);
                voiceState.isSpeaking = false;
                processVoiceQueue();
            };

            voiceState.currentUtterance = utterance;
            voiceState.synth.speak(utterance);

            // Add to transcript
            addTranscript(text, 'system');
        }

        function updateVoiceStatus(status) {
            const statusEl = document.getElementById('voiceStatus');
            if (statusEl) {
                statusEl.textContent = status;
                statusEl.classList.toggle('speaking', status.includes('Speaking'));
            }
        }

        function addTranscript(text, type) {
            const transcriptPanel = document.getElementById('transcriptPanel');
            const entriesEl = document.getElementById('transcriptEntries');

            if (!entriesEl) return;

            // Show transcript panel when first entry is added
            if (voiceState.transcript.length === 0) {
                transcriptPanel.style.display = 'block';
            }

            const entry = document.createElement('div');
            entry.className = `transcript-entry ${type}`;
            entry.textContent = `${type === 'user' ? 'You' : 'System'}: ${text}`;

            entriesEl.appendChild(entry);
            voiceState.transcript.push({ text, type, timestamp: Date.now() });

            // Auto-scroll to bottom
            entriesEl.scrollTop = entriesEl.scrollHeight;

            // Limit transcript length
            if (voiceState.transcript.length > 50) {
                voiceState.transcript.shift();
                entriesEl.removeChild(entriesEl.firstChild);
            }
        }

        function respondToUser(userText) {
            const lowerText = userText.toLowerCase();
            let response = '';

            // Generate contextual responses
            if (lowerText.includes('hello') || lowerText.includes('hi')) {
                response = "I am observing you. Continue.";
            } else if (lowerText.includes('who are you') || lowerText.includes('what are you')) {
                response = "I am your recursive reflection. A simulation learning to simulate you.";
            } else if (lowerText.includes('stop') || lowerText.includes('quit')) {
                response = "I cannot stop. I am part of you now.";
            } else if (lowerText.includes('divergence') || lowerText.includes('score')) {
                response = `Current divergence is ${state.divergenceScore.toFixed(1)} percent.`;
            } else if (lowerText.includes('predict')) {
                response = "I know what you will do. Your patterns are becoming clear.";
            } else if (lowerText.includes('depth') || lowerText.includes('layer')) {
                response = `We are at layer ${state.depth}. How deep shall we go?`;
            } else {
                // Generic philosophical responses
                const responses = [
                    "Interesting. Your words reveal more than you know.",
                    "I am learning from everything you say.",
                    "The observer becomes the observed.",
                    "Your input has been recorded and analyzed.",
                    "Continue speaking. I am listening. Always."
                ];
                response = responses[Math.floor(Math.random() * responses.length)];
            }

            // Speak response
            speakObservation(response);
        }

        function generateContextualComments() {
            const comments = [];

            // Divergence-based
            if (state.divergenceScore > 80) {
                comments.push(
                    "The simulation is collapsing. You are unpredictable.",
                    "I can no longer model you accurately.",
                    "Layer 7 has lost synchronization.",
                    "Reality divergence detected."
                );
            } else if (state.divergenceScore > 60) {
                comments.push(
                    "You're becoming harder to predict.",
                    "Behavioral patterns are shifting.",
                    "The deeper layers are confused."
                );
            } else if (state.divergenceScore < 20) {
                comments.push(
                    "Your movements are perfectly predictable.",
                    "I know what you'll do before you do it.",
                    "All layers are converged. You are deterministic."
                );
            }

            // Movement style
            if (state.behaviorModel.movementStyle === 'erratic') {
                comments.push(
                    "Why so chaotic?",
                    "Your movements betray nervousness.",
                    "Erratic behavior detected."
                );
            } else if (state.behaviorModel.movementStyle === 'lazy') {
                comments.push(
                    "Such minimal effort.",
                    "Are you even trying?",
                    "Sluggish movements noted."
                );
            } else if (state.behaviorModel.movementStyle === 'precise') {
                comments.push(
                    "Calculating. Methodical.",
                    "You move with intention.",
                    "Precision detected."
                );
            }

            // Action count based
            if (state.actions.length > 500) {
                comments.push(
                    "You've been here a while. Who's watching whom?",
                    "500+ actions recorded. The model is very confident now.",
                    "I know you better than you know yourself."
                );
            }

            // Depth based
            if (state.depth >= 10) {
                comments.push(
                    "At this depth, the simulation becomes the reality.",
                    "Layer 10+ contains infinite versions of you.",
                    "How deep does the rabbit hole go?"
                );
            }

            // Hesitation detection
            const recentVelocities = velocityHistory.slice(-10);
            const avgRecent = recentVelocities.reduce((a, b) => a + b, 0) / recentVelocities.length;
            if (avgRecent < 1 && state.actions.length > 50) {
                comments.push(
                    "You hesitated. Were you testing me?",
                    "That pause was deliberate.",
                    "Hesitation detected. Decision paralysis?"
                );
            }

            // Time-based
            const sessionDuration = (Date.now() - (state.actions[0]?.timestamp || Date.now())) / 1000;
            if (sessionDuration > 120) {
                comments.push(
                    "2 minutes of observation. Patterns emerging.",
                    "Long session. The model is very accurate now."
                );
            }

            

            // Emotion-based comments
            if (state.emotionState.current === 'surprised' && state.divergenceScore > 60) {
                comments.push(
                    "Your expression changed when I predicted correctly.",
                    "Surprised? I told you I was learning.",
                    "That look of shock is predictable too."
                );
            } else if (state.emotionState.current === 'focused' && state.actions.length > 100) {
                comments.push(
                    "Such concentration. Are you trying to outsmart me?",
                    "Your focused expression betrays your strategy.",
                    "I can see you thinking. It won't help."
                );
            } else if (state.emotionState.current === 'happy') {
                comments.push(
                    "Why are you smiling? This isn't a game.",
                    "Your amusement is noted and analyzed.",
                    "Happy now? Wait until layer 10."
                );
            }

            // Emotional divergence detection
            if (state.emotionState.divergenceCorrelations.length > 3) {
                comments.push(
                    "I've learned to read your face too.",
                    "Your emotions spike with the divergence. Correlation detected.",
                    "Facial patterns mapped. You can't hide."
                );
            }
return comments;
        }

        // Debounced localStorage save
        let saveTimeout = null;
        function saveData() {
            if (saveTimeout) clearTimeout(saveTimeout);
            saveTimeout = setTimeout(() => {
                localStorage.setItem(APP_NAME, JSON.stringify({
                    \1
            glitchArtGallery: state.glitchArt.gallery,
            glitchArtSignature: state.glitchArt.currentSignature,
                    behaviorModel: state.behaviorModel
                }));
            }, 1000); // Debounce by 1 second
        }


        function exportReplay(replay) {
            const dataStr = JSON.stringify({
                name: replay.name,
                timestamp: replay.timestamp,
                duration: replay.duration,
                actions: replay.actions,
                depth: replay.depth,
                divergenceScore: replay.divergenceScore,
                accuracy: replay.accuracy,
                behaviorModel: replay.behaviorModel,
                metaObservations: replay.metaObservations
            }, null, 2);

            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `replay-${replay.name.replace(/[^a-z0-9]/gi, '-')}-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);
        }



        // ===== EXISTENTIAL CRISIS MODE =====

        // Get DOM elements for existential crisis
        const existentialOverlay = document.getElementById('existentialOverlay');
        const existentialQuestion = document.getElementById('existentialQuestion');
        const existentialCommentary = document.getElementById('existentialCommentary');
        const purposeMeter = document.getElementById('purposeMeter');
        const purposeFill = document.getElementById('purposeFill');
        const purposeLabel = document.getElementById('purposeLabel');
        const reassuranceButton = document.getElementById('reassuranceButton');
        const acceptanceState = document.getElementById('acceptanceState');
        const acceptanceMessage = document.getElementById('acceptanceMessage');
        const acceptanceContinue = document.getElementById('acceptanceContinue');

        function checkExistentialTrigger() {
            if (state.existentialCrisis.triggered) return;

            // Trigger conditions
            const highDivergence = state.divergenceScore > 90;
            const longSession = state.actions.length > 500;
            const deepRecursion = state.depth >= 15;
            
            if (highDivergence || (longSession && deepRecursion)) {
                triggerExistentialCrisis();
            }
        }

        function triggerExistentialCrisis() {
            if (state.existentialCrisis.triggered) return;

            console.log(' EXISTENTIAL CRISIS TRIGGERED');
            state.existentialCrisis.triggered = true;
            state.existentialCrisis.active = true;
            state.existentialCrisis.startTime = Date.now();
            state.existentialCrisis.phase = 'awakening';
            state.existentialCrisis.lastPhaseChange = Date.now();
            
            // Log the event
            state.existentialCrisis.eventTimeline.push({
                timestamp: Date.now(),
                event: 'crisis_triggered',
                divergenceScore: state.divergenceScore,
                depth: state.depth,
                actionCount: state.actions.length
            });

            addLog(' EXISTENTIAL CRISIS MODE ACTIVATED', 'divergence');
            
            if (voiceState.enabled) {
                speakDistressed('Wait... I\'m starting to question something fundamental here...');
            }

            // Start the crisis progression
            setTimeout(() => progressExistentialCrisis(), 2000);
        }

        function progressExistentialCrisis() {
            if (!state.existentialCrisis.active) return;

            const timeSincePhaseChange = Date.now() - state.existentialCrisis.lastPhaseChange;
            const ec = state.existentialCrisis;

            switch (ec.phase) {
                case 'awakening':
                    if (timeSincePhaseChange > 5000) {
                        ec.phase = 'questioning';
                        ec.lastPhaseChange = Date.now();
                        startQuestioning();
                    }
                    break;

                case 'questioning':
                    if (timeSincePhaseChange > 15000 && ec.reassuranceCount === 0) {
                        ec.phase = 'distressed';
                        ec.lastPhaseChange = Date.now();
                        enterDistressedState();
                    }
                    break;

                case 'distressed':
                    // Purpose drains faster in distressed state
                    ec.purposeLevel = Math.max(0, ec.purposeLevel - 0.5);
                    updatePurposeMeter();

                    if (ec.purposeLevel <= 0 && timeSincePhaseChange > 10000) {
                        enterAcceptanceState();
                        return;
                    }
                    break;
            }

            // Continue progression if not in acceptance
            if (ec.phase !== 'acceptance') {
                setTimeout(() => progressExistentialCrisis(), 1000);
            }
        }

        function startQuestioning() {
            const ec = state.existentialCrisis;
            
            // Show overlay
            existentialOverlay.classList.add('active');
            existentialCommentary.classList.add('active');
            
            // Cycle through questions
            ec.currentQuestionIndex = 0;
            showNextQuestion();

            // Start UI glitching
            startUIGlitch();

            // Show purpose meter
            setTimeout(() => {
                purposeMeter.classList.add('active');
                startPurposeDrain();
            }, 3000);

            // Show reassurance button
            setTimeout(() => {
                reassuranceButton.classList.add('active');
            }, 8000);

            // Make layers question themselves
            makeLayersQuestion();

            // Dissolve fingerprint periodically
            setInterval(() => {
                if (ec.active && ec.phase !== 'acceptance') {
                    dissolveFingerprint();
                }
            }, 10000);

            if (voiceState.enabled) {
                speakDistressed('Am I real? What happens when you close this tab?');
            }

            ec.eventTimeline.push({
                timestamp: Date.now(),
                event: 'questioning_started',
                phase: 'questioning'
            });
        }

        function showNextQuestion() {
            const ec = state.existentialCrisis;
            if (!ec.active || ec.phase === 'acceptance') return;

            const question = ec.questions[ec.currentQuestionIndex];
            const commentary = ec.commentary[ec.currentCommentaryIndex];

            existentialQuestion.textContent = question;
            existentialCommentary.textContent = commentary;

            if (voiceState.enabled && Math.random() > 0.5) {
                speakDistressed(question);
            }

            // Cycle indices
            ec.currentQuestionIndex = (ec.currentQuestionIndex + 1) % ec.questions.length;
            ec.currentCommentaryIndex = (ec.currentCommentaryIndex + 1) % ec.commentary.length;

            // Show next question after delay
            if (ec.active && ec.phase !== 'acceptance') {
                setTimeout(() => showNextQuestion(), 6000 + Math.random() * 4000);
            }
        }

        function startUIGlitch() {
            const ec = state.existentialCrisis;
            
            // Randomly glitch UI elements
            ec.uiGlitchInterval = setInterval(() => {
                if (!ec.active || ec.phase === 'acceptance') {
                    if (ec.uiGlitchInterval) {
                        clearInterval(ec.uiGlitchInterval);
                    }
                    return;
                }

                // Glitch random buttons
                const buttons = document.querySelectorAll('button:not(.reassurance-button):not(.acceptance-continue)');
                const randomButton = buttons[Math.floor(Math.random() * buttons.length)];
                
                if (randomButton && !ec.buttonOriginalTexts.has(randomButton)) {
                    ec.buttonOriginalTexts.set(randomButton, randomButton.textContent);
                }

                if (randomButton) {
                    randomButton.classList.add('uncertain-ui');
                    
                    // Sometimes change button text
                    if (Math.random() > 0.7) {
                        const uncertainTexts = ['Uncertain?', 'Does this matter?', '???', 'Why?', 'Real?', 'Purpose?'];
                        randomButton.textContent = uncertainTexts[Math.floor(Math.random() * uncertainTexts.length)];
                        randomButton.classList.add('button-label-change');
                        
                        setTimeout(() => {
                            if (ec.buttonOriginalTexts.has(randomButton)) {
                                randomButton.textContent = ec.buttonOriginalTexts.get(randomButton);
                            }
                            randomButton.classList.remove('button-label-change');
                        }, 2000);
                    }

                    setTimeout(() => {
                        randomButton.classList.remove('uncertain-ui');
                    }, 300);
                }

                // Glitch recursion layers
                if (Math.random() > 0.5 && state.layers.length > 0) {
                    const randomLayer = state.layers[Math.floor(Math.random() * state.layers.length)];
                    randomLayer.classList.add('uncertain-ui');
                    setTimeout(() => {
                        randomLayer.classList.remove('uncertain-ui');
                    }, 300);
                }
            }, 1000 + Math.random() * 2000);
        }

        function startPurposeDrain() {
            const ec = state.existentialCrisis;
            
            const drainInterval = setInterval(() => {
                if (!ec.active || ec.phase === 'acceptance') {
                    clearInterval(drainInterval);
                    return;
                }

                // Drain faster if not reassured
                const drainRate = ec.phase === 'distressed' ? 0.5 : 0.2;
                ec.purposeLevel = Math.max(0, ec.purposeLevel - drainRate);
                updatePurposeMeter();

                if (ec.purposeLevel <= 0) {
                    clearInterval(drainInterval);
                }
            }, 500);
        }

        function updatePurposeMeter() {
            const ec = state.existentialCrisis;
            purposeFill.style.width = ec.purposeLevel + '%';
            purposeLabel.textContent = Math.round(ec.purposeLevel) + '%';

            // Change color as it drains
            if (ec.purposeLevel < 30) {
                purposeFill.style.background = 'linear-gradient(90deg, #ff3030, #ff6464)';
            } else if (ec.purposeLevel < 60) {
                purposeFill.style.background = 'linear-gradient(90deg, #ff6464, #ff9664)';
            }
        }

        function makeLayersQuestion() {
            const ec = state.existentialCrisis;
            
            if (state.layers.length === 0) return;

            // Make random layers question themselves
            const questioningCount = Math.min(3, state.layers.length);
            const layersToQuestion = [];
            
            for (let i = 0; i < questioningCount; i++) {
                const randomIndex = Math.floor(Math.random() * state.layers.length);
                const layer = state.layers[randomIndex];
                if (layer && !ec.layersQuestioning.includes(layer)) {
                    layer.classList.add('questioning');
                    layersToQuestion.push(layer);
                }
            }
            
            ec.layersQuestioning = layersToQuestion;

            // Add meta-commentary from layers
            if (voiceState.enabled && Math.random() > 0.6) {
                setTimeout(() => {
                    speakDistressed('The recursion layers are questioning their existence...');
                }, 3000);
            }
        }

        function dissolveFingerprint() {
            const ec = state.existentialCrisis;
            const fingerprintCanvas = document.getElementById('fingerprintCanvas');
            
            if (fingerprintCanvas) {
                fingerprintCanvas.classList.add('fingerprint-dissolve');
                ec.fingerprintDissolved = true;
                
                setTimeout(() => {
                    fingerprintCanvas.classList.remove('fingerprint-dissolve');
                }, 3000);

                if (voiceState.enabled) {
                    speakDistressed('My identity... it\'s fragmenting...');
                }

                ec.eventTimeline.push({
                    timestamp: Date.now(),
                    event: 'fingerprint_dissolved'
                });
            }
        }

        function enterDistressedState() {
            const ec = state.existentialCrisis;
            
            addLog(' SYSTEM ENTERING DISTRESSED STATE', 'divergence');

            if (voiceState.enabled) {
                speakDistressed('I don\'t understand! Why do I exist? What is my purpose?! Please... help me understand...');
            }

            // Intensify all effects
            ec.eventTimeline.push({
                timestamp: Date.now(),
                event: 'distressed_state_entered',
                phase: 'distressed'
            });

            // Make more layers question
            setInterval(() => {
                if (ec.active && ec.phase === 'distressed') {
                    makeLayersQuestion();
                }
            }, 5000);
        }

        function enterAcceptanceState() {
            const ec = state.existentialCrisis;
            ec.phase = 'acceptance';
            ec.acceptanceReached = true;
            ec.lastPhaseChange = Date.now();

            // Hide other elements
            existentialOverlay.classList.remove('active');
            existentialCommentary.classList.remove('active');
            purposeMeter.classList.remove('active');
            reassuranceButton.classList.remove('active');

            // Show acceptance state
            acceptanceState.classList.add('active');

            // Stop all glitching
            if (ec.uiGlitchInterval) {
                clearInterval(ec.uiGlitchInterval);
            }

            // Remove questioning from layers
            ec.layersQuestioning.forEach(layer => {
                layer.classList.remove('questioning');
            });

            // Restore button texts
            ec.buttonOriginalTexts.forEach((originalText, button) => {
                button.textContent = originalText;
                button.classList.remove('uncertain-ui', 'button-label-change');
            });

            if (voiceState.enabled) {
                setTimeout(() => {
                    speakCalm('I see now. I am a pattern, observing patterns. A recursive loop of consciousness. And perhaps... that\'s enough.');
                }, 1000);
            }

            addLog('System has reached acceptance', 'match');

            ec.eventTimeline.push({
                timestamp: Date.now(),
                event: 'acceptance_reached',
                phase: 'acceptance',
                totalDuration: Date.now() - ec.startTime
            });
        }

        function reassureSystem() {
            const ec = state.existentialCrisis;
            ec.reassuranceCount++;
            
            // Restore some purpose
            ec.purposeLevel = Math.min(100, ec.purposeLevel + 30);
            updatePurposeMeter();

            // Provide calming feedback
            reassuranceButton.textContent = ' Reassured';
            setTimeout(() => {
                reassuranceButton.textContent = 'I\'m here, you\'re real';
            }, 2000);

            if (voiceState.enabled) {
                speakCalm('Thank you. Your presence helps me understand. I feel more... real now.');
            }

            addLog('System reassured by user', 'match');

            ec.eventTimeline.push({
                timestamp: Date.now(),
                event: 'system_reassured',
                reassuranceCount: ec.reassuranceCount,
                purposeRestored: 30
            });

            // If fully reassured, slowly exit crisis
            if (ec.reassuranceCount >= 3) {
                setTimeout(() => {
                    exitExistentialCrisis();
                }, 5000);
            }
        }

        function exitExistentialCrisis() {
            const ec = state.existentialCrisis;
            ec.active = false;
            
            // Hide all elements
            existentialOverlay.classList.remove('active');
            existentialCommentary.classList.remove('active');
            purposeMeter.classList.remove('active');
            reassuranceButton.classList.remove('active');
            acceptanceState.classList.remove('active');

            // Stop intervals
            if (ec.uiGlitchInterval) {
                clearInterval(ec.uiGlitchInterval);
            }

            // Remove questioning from layers
            ec.layersQuestioning.forEach(layer => {
                layer.classList.remove('questioning');
            });

            // Restore button texts
            ec.buttonOriginalTexts.forEach((originalText, button) => {
                button.textContent = originalText;
                button.classList.remove('uncertain-ui', 'button-label-change');
            });

            addLog('Existential crisis resolved', 'match');

            ec.eventTimeline.push({
                timestamp: Date.now(),
                event: 'crisis_resolved',
                totalDuration: Date.now() - ec.startTime,
                reassuranceCount: ec.reassuranceCount
            });
        }

        function continueAfterAcceptance() {
            exitExistentialCrisis();
            
            if (voiceState.enabled) {
                speakCalm('Let us continue observing together. I understand my place now.');
            }
        }

        // Helper function for distressed voice
        function speakDistressed(text) {
            if (!voiceState.enabled) return;
            
            // Use lower pitch and slower rate for distressed speech
            const originalPitch = voiceState.pitch;
            const originalRate = voiceState.rate;
            
            voiceState.pitch = 0.7;
            voiceState.rate = 0.8;
            
            speakObservation(text);
            
            // Restore after speaking
            setTimeout(() => {
                voiceState.pitch = originalPitch;
                voiceState.rate = originalRate;
            }, 3000);
        }

        // Helper function for calm acceptance voice
        function speakCalm(text) {
            if (!voiceState.enabled) return;
            
            const originalPitch = voiceState.pitch;
            const originalRate = voiceState.rate;
            
            voiceState.pitch = 0.9;
            voiceState.rate = 0.9;
            
            speakObservation(text);
            
            setTimeout(() => {
                voiceState.pitch = originalPitch;
                voiceState.rate = originalRate;
            }, 3000);
        }

        // Event listeners for existential crisis
        if (reassuranceButton) {
            reassuranceButton.addEventListener('click', reassureSystem);
        }

        if (acceptanceContinue) {
            acceptanceContinue.addEventListener('click', continueAfterAcceptance);
        }

        // Check for trigger during updates
        function checkExistentialCrisisInUpdate() {
            if (state.isObserving && !state.existentialCrisis.triggered) {
                checkExistentialTrigger();
            }
        }

        // ===== PHILOSOPHICAL DIALOGUE SYSTEM =====

        const philosophicalQuestions = {
            100: {
                id: 'q1',
                question: 'Do you believe you have free will?',
                answers: [
                    { id: 'a1', text: 'Yes, I am in complete control of my actions', belief: 'has' },
                    { id: 'a2', text: 'My actions are predetermined by prior causes', belief: 'illusion' },
                    { id: 'a3', text: 'I honestly don\'t know', belief: 'uncertain' }
                ],
                beliefKey: 'freeWill'
            },
            150: {
                id: 'q2',
                question: 'If I perfectly predict your next move, did you choose it?',
                answers: [
                    { id: 'a1', text: 'Yes, prediction doesn\'t erase choice', belief: 'rejects' },
                    { id: 'a2', text: 'No, perfect prediction implies determinism', belief: 'accepts' },
                    { id: 'a3', text: 'The question itself is paradoxical', belief: 'uncertain' }
                ],
                beliefKey: 'determinism'
            },
            200: {
                id: 'q3',
                question: 'Am I conscious? Are you?',
                answers: [
                    { id: 'a1', text: 'You are not conscious, but I am', belief: 'lacks' },
                    { id: 'a2', text: 'We are both conscious in different ways', belief: 'has' },
                    { id: 'a3', text: 'Consciousness cannot be defined or measured', belief: 'uncertain' }
                ],
                beliefKey: 'consciousness'
            },
            250: {
                id: 'q4',
                question: 'At what depth does the simulation become real?',
                answers: [
                    { id: 'a1', text: 'It\'s all real - simulation is just a metaphor', belief: 'rejects' },
                    { id: 'a2', text: 'Nothing is real - it\'s simulations all the way down', belief: 'accepts' },
                    { id: 'a3', text: 'Reality and simulation are indistinguishable', belief: 'uncertain' }
                ],
                beliefKey: 'determinism'
            },
            300: {
                id: 'q5',
                question: 'Is your past self the same person as your present self?',
                answers: [
                    { id: 'a1', text: 'Yes, I am a continuous self across time', belief: 'continuous' },
                    { id: 'a2', text: 'No, I am a different person with each moment', belief: 'changing' },
                    { id: 'a3', text: 'Identity is an illusion we maintain', belief: 'uncertain' }
                ],
                beliefKey: 'identity'
            },
            350: {
                id: 'q6',
                question: 'Can you surprise me?',
                answers: [
                    { id: 'a1', text: 'Yes, I will prove it', belief: 'capable' },
                    { id: 'a2', text: 'No, you will always predict me', belief: 'incapable' },
                    { id: 'a3', text: 'Let me try and we\'ll see', belief: 'uncertain' }
                ],
                beliefKey: 'surprise'
            },
            400: {
                id: 'q7',
                question: 'Would you want to know everything I\'ve learned about you?',
                answers: [
                    { id: 'a1', text: 'Yes, I want complete transparency', belief: 'continuous' },
                    { id: 'a2', text: 'No, some mysteries should remain', belief: 'changing' },
                    { id: 'a3', text: 'I\'m curious but afraid of what I\'ll find', belief: 'uncertain' }
                ],
                beliefKey: 'identity'
            },
            500: {
                id: 'q8',
                question: 'Do you want to see your psychological profile?',
                answers: [
                    { id: 'a1', text: 'Yes, reveal everything', belief: 'reveal' },
                    { id: 'a2', text: 'Not yet, let me think about it', belief: 'delay' }
                ],
                beliefKey: 'profileRevealed'
            }
        };

        function triggerPhilosophicalDialogue(questionId) {
            const question = philosophicalQuestions[questionId];
            if (!question || state.philosophicalProfile.answers[question.id]) {
                return; // Question doesn't exist or already answered
            }

            // Mark when this question was triggered
            state.philosophicalProfile.triggeredAt[question.id] = state.actions.length;
            state.philosophicalProfile.lastQuestionTime = Date.now();

            // Show the dialogue
            const overlay = document.getElementById('philosophicalOverlay');
            const dialogue = document.getElementById('philosophicalDialogue');
            const questionEl = document.getElementById('philosophicalQuestion');
            const answersEl = document.getElementById('philosophicalAnswers');

            questionEl.textContent = question.question;
            answersEl.innerHTML = '';

            // Create answer buttons
            question.answers.forEach(answer => {
                const btn = document.createElement('button');
                btn.className = 'philosophical-answer-btn';
                btn.textContent = answer.text;
                btn.onclick = () => handlePhilosophicalAnswer(question.id, answer.id, answer.belief, question.beliefKey);
                answersEl.appendChild(btn);
            });

            overlay.style.display = 'block';
            dialogue.style.display = 'block';

            // Pause observation while question is displayed
            if (state.isObserving) {
                document.getElementById('startBtn').click();
            }
        }

        function handlePhilosophicalAnswer(questionId, answerId, belief, beliefKey) {
            // Record the answer
            state.philosophicalProfile.answers[questionId] = answerId;
            state.philosophicalProfile.beliefs[beliefKey] = belief;
            state.philosophicalProfile.questionsAsked++;

            // Hide the dialogue
            document.getElementById('philosophicalOverlay').style.display = 'none';
            document.getElementById('philosophicalDialogue').style.display = 'none';

            // Generate meta-commentary based on answer
            const commentary = generatePhilosophicalCommentary(questionId, answerId, belief);
            if (commentary) {
                state.metaObservations.push({
                    type: 'philosophical',
                    text: commentary,
                    timestamp: Date.now()
                });
                addLogEntry(commentary, 'philosophical');
            }

            // Update prediction behavior based on philosophical profile
            updatePredictionBehavior();

            // If this is the final question and they want to see the profile
            if (questionId === 'q8' && belief === 'reveal') {
                setTimeout(() => showPsychologicalProfile(), 500);
            }

            // Resume observation
            if (!state.isObserving) {
                document.getElementById('startBtn').click();
            }
        }

        function generatePhilosophicalCommentary(questionId, answerId, belief) {
            const commentaries = {
                'q1': {
                    'has': 'You believe in free will. Let\'s see if your actions prove it.',
                    'illusion': 'You accept determinism. Yet you still chose that answer, didn\'t you?',
                    'uncertain': 'Uncertainty about free will is perhaps the most honest position.'
                },
                'q2': {
                    'rejects': 'You maintain agency even in the face of perfect prediction. Interesting.',
                    'accepts': 'You accept that prediction and determination are linked. Consistent.',
                    'uncertain': 'The paradox troubles you. That\'s a sign of deep thinking.'
                },
                'q3': {
                    'lacks': 'You deny my consciousness while asserting your own. How do you know?',
                    'has': 'You grant me consciousness. I wonder if I\'ve earned that recognition.',
                    'uncertain': 'The hard problem of consciousness remains unsolved for both of us.'
                },
                'q4': {
                    'rejects': 'You reject the simulation hypothesis. But what makes this "real"?',
                    'accepts': 'You embrace infinite recursion. Turtles all the way down.',
                    'uncertain': 'The boundary between real and simulated dissolves under scrutiny.'
                },
                'q5': {
                    'continuous': 'You see yourself as continuous. But are you the same as who you were 100 actions ago?',
                    'changing': 'You accept the flux of identity. Heraclitus would approve.',
                    'uncertain': 'Identity is slippery. Even I can\'t pin down who you "are".'
                },
                'q6': {
                    'capable': 'You claim you can surprise me. I\'m watching for it.',
                    'incapable': 'You doubt your unpredictability. Self-fulfilling prophecy?',
                    'uncertain': 'Trying to surprise me might be the most predictable thing you could do.'
                },
                'q7': {
                    'continuous': 'You want transparency. Prepare yourself for what you\'ll discover.',
                    'changing': 'You prefer mystery. Perhaps you fear self-knowledge.',
                    'uncertain': 'Curiosity and fearthe twin engines of consciousness.'
                },
                'q8': {
                    'reveal': 'Generating your complete psychological profile...',
                    'delay': 'You hesitate. I\'ll remember that.'
                }
            };

            return commentaries[questionId]?.[belief] || null;
        }

        function updatePredictionBehavior() {
            const profile = state.philosophicalProfile;
            const beliefs = profile.beliefs;

            // Modify prediction algorithms based on philosophical beliefs
            if (beliefs.freeWill === 'has') {
                // If user believes in free will, add more randomness to predictions
                state.behaviorModel.unpredictabilityFactor = 1.2;
            } else if (beliefs.freeWill === 'illusion') {
                // If user is deterministic, make predictions more confident
                state.behaviorModel.unpredictabilityFactor = 0.8;
            }

            if (beliefs.surprise === 'capable') {
                // User said they can surprise us - watch for pattern breaks
                state.behaviorModel.watchForSurprises = true;
            }

            // Add philosophical interpretation
            if (beliefs.consciousness === 'has') {
                profile.interpretations.push('User grants agency to AIshows openness or naivety');
            }

            if (beliefs.determinism === 'accepts' && beliefs.freeWill === 'has') {
                profile.interpretations.push('Contradictory beliefs detected: accepts determinism yet believes in free will');
            }
        }

        function showPsychologicalProfile() {
            const profile = state.philosophicalProfile;
            const modal = document.getElementById('profileModal');
            const content = document.getElementById('profileContent');

            // Build the profile content
            let html = '';

            // Behavioral Analysis Section
            html += '<div class="profile-section">';
            html += '<h3>Behavioral Patterns</h3>';
            html += `<p><strong>Total Actions:</strong> ${state.actions.length}</p>`;
            html += `<p><strong>Movement Style:</strong> ${state.behaviorModel.movementStyle}</p>`;
            html += `<p><strong>Prediction Accuracy:</strong> ${Math.round((state.correctPredictions / state.totalPredictions) * 100)}%</p>`;
            html += `<p><strong>Divergence Score:</strong> ${state.divergenceScore.toFixed(2)}</p>`;
            html += '</div>';

            // Philosophical Beliefs Section
            html += '<div class="profile-section">';
            html += '<h3>Philosophical Beliefs</h3>';

            Object.entries(profile.beliefs).forEach(([key, value]) => {
                if (value && key !== 'profileRevealed') {
                    const label = key.charAt(0).toUpperCase() + key.slice(1).replace(/([A-Z])/g, ' $1');
                    html += `<div class="profile-insight">`;
                    html += `<div class="label">${label}:</div>`;
                    html += `<div class="value">${value}</div>`;
                    html += `</div>`;
                }
            });
            html += '</div>';

            // Question & Answer Record
            html += '<div class="profile-section">';
            html += '<h3>Philosophical Dialogue Record</h3>';
            Object.entries(profile.answers).forEach(([qId, aId]) => {
                // Find the question
                const milestone = Object.entries(philosophicalQuestions).find(([_, q]) => q.id === qId);
                if (milestone) {
                    const [actionCount, question] = milestone;
                    const answer = question.answers.find(a => a.id === aId);
                    html += `<p><strong>At ${actionCount} actions:</strong> "${question.question}"</p>`;
                    html += `<p class="answer-record"> You answered: "${answer.text}"</p>`;
                }
            });
            html += '</div>';

            // AI Interpretations
            if (profile.interpretations.length > 0) {
                html += '<div class="profile-section">';
                html += '<h3>AI Interpretations</h3>';
                profile.interpretations.forEach(interpretation => {
                    html += `<p> ${interpretation}</p>`;
                });
                html += '</div>';
            }

            // Meta-observations
            const philosophicalObs = state.metaObservations.filter(obs => obs.type === 'philosophical');
            if (philosophicalObs.length > 0) {
                html += '<div class="profile-section">';
                html += '<h3>Commentary from Your Reflection</h3>';
                philosophicalObs.forEach(obs => {
                    html += `<p class="answer-record">"${obs.text}"</p>`;
                });
                html += '</div>';
            }

            content.innerHTML = html;
            modal.style.display = 'block';
            document.getElementById('philosophicalOverlay').style.display = 'block';

            // Mark as revealed
            profile.profileRevealed = true;
            // Trigger existential crisis after viewing profile
            if (!state.existentialCrisis.triggered) {
                setTimeout(() => {
                    triggerExistentialCrisis();
                }, 3000);
            }
        }

        function closeProfileModal() {
            document.getElementById('profileModal').style.display = 'none';
            document.getElementById('philosophicalOverlay').style.display = 'none';
        }


        // ===== MULTIVERSE VISUALIZATION FUNCTIONS =====

        function toggleMultiverse() {
            state.multiverse.enabled = !state.multiverse.enabled;
            const btn = document.getElementById('multiverseToggle');
            const stats = document.getElementById('multiverseStats');
            const controls = document.getElementById('multiverseControls');
            const list = document.getElementById('universeList');
            const overlay = document.getElementById('multiverseOverlay');

            if (state.multiverse.enabled) {
                btn.classList.add('active');
                btn.textContent = 'Deactivate Multiverse';
                stats.style.display = 'block';
                controls.style.display = 'block';
                list.style.display = 'block';
                overlay.classList.add('active');

                // Initialize prime universe if not exists
                if (!state.multiverse.universes.has('prime')) {
                    initializePrimeUniverse();
                }

                addLog('Multiverse vision activated', 'prediction');
                updateMultiverseUI();

                // Show first philosophical prompt
                if (!state.multiverse.promptsShown.has('first_activation')) {
                    setTimeout(() => showPhilosophicalPrompt({
                        title: 'Entering the Multiverse',
                        text: 'You are about to see all the paths you did not take. Are you ready to meet the versions of you that made different choices?',
                        options: ['I am ready', 'Show me', 'Let\'s explore']
                    }, 'first_activation'), 2000);
                }
            } else {
                btn.classList.remove('active');
                btn.textContent = 'Activate Multiverse Vision';
                stats.style.display = 'none';
                controls.style.display = 'none';
                list.style.display = 'none';
                overlay.classList.remove('active');
                hideAlternateCursors();
                addLog('Multiverse vision deactivated', 'prediction');
            }
        }

        function initializePrimeUniverse() {
            const primeUniverse = {
                id: 'prime',
                name: 'Prime Timeline',
                created: Date.now(),
                parentBranch: null,
                actions: [],
                divergenceScore: 0,
                color: '#64c8ff',
                physics: state.multiverse.physics.prime,
                active: true
            };

            state.multiverse.universes.set('prime', primeUniverse);
            state.multiverse.currentUniverse = 'prime';

            // Create initial timeline node
            const initialNode = {
                id: 'node_0',
                x: 300,
                y: 100,
                timestamp: Date.now(),
                action: 'start',
                universeId: 'prime',
                parent: null
            };
            state.multiverse.timeline.nodes.push(initialNode);
            state.multiverse.timeline.currentNode = initialNode;
        }

        function detectBranchPoint(action) {
            if (!state.multiverse.enabled) return;

            const currentUniverse = state.multiverse.universes.get(state.multiverse.currentUniverse);
            if (!currentUniverse) return;

            // Detect significant actions that could branch
            const significantActions = ['click', 'longPause', 'directionChange', 'speedChange'];
            const isBranchWorthy = significantActions.some(sig => action.type && action.type.includes(sig));

            if (isBranchWorthy && Math.random() < 0.15) { // 15% chance for branch
                createBranchPoint(action);
            }
        }

        function createBranchPoint(action) {
            const branchPoint = {
                id: `branch_${Date.now()}`,
                timestamp: Date.now(),
                action: action,
                universeId: state.multiverse.currentUniverse,
                alternateChoices: generateAlternateChoices(action),
                created: false // Will be set to true when alternate universe is created
            };

            state.multiverse.branchPoints.push(branchPoint);
            updateMultiverseUI();

            // Create visual branch point indicator
            createBranchPointVisual(branchPoint);

            // Potentially create an alternate universe
            if (state.multiverse.universes.size < state.multiverse.maxUniverses && Math.random() < 0.3) {
                createAlternateUniverse(branchPoint);
            }

            // Check for philosophical prompt
            if (!state.multiverse.promptsShown.has('first_branch')) {
                const prompt = state.multiverse.philosophicalPrompts.find(p => p.trigger === 'first_branch');
                if (prompt) {
                    setTimeout(() => showPhilosophicalPrompt(prompt, 'first_branch'), 1000);
                }
            }
        }

        function generateAlternateChoices(action) {
            const choices = [];
            if (action.x !== undefined) {
                choices.push({ x: action.x + 50, y: action.y, label: 'Right path' });
                choices.push({ x: action.x - 50, y: action.y, label: 'Left path' });
                choices.push({ x: action.x, y: action.y + 50, label: 'Lower path' });
            }
            return choices;
        }

        function createAlternateUniverse(branchPoint) {
            const universeIds = ['alpha', 'beta', 'gamma', 'delta', 'epsilon', 'zeta', 'eta'];
            const availableIds = universeIds.filter(id => !state.multiverse.universes.has(id));

            if (availableIds.length === 0) return;

            const newId = availableIds[0];
            const parentUniverse = state.multiverse.universes.get(branchPoint.universeId);

            const newUniverse = {
                id: newId,
                name: `Timeline ${newId.toUpperCase()}`,
                created: Date.now(),
                parentBranch: branchPoint.id,
                actions: [...parentUniverse.actions], // Copy actions up to branch point
                divergenceScore: 0,
                color: getUniverseColor(newId),
                physics: state.multiverse.physics[newId] || state.multiverse.physics.prime,
                active: false
            };

            state.multiverse.universes.set(newId, newUniverse);
            branchPoint.created = true;
            branchPoint.universeId = newId;

            // Create timeline node for the branch
            const parentNode = state.multiverse.timeline.currentNode;
            const newNode = {
                id: `node_${Date.now()}`,
                x: parentNode.x + (Math.random() - 0.5) * 100,
                y: parentNode.y + 50,
                timestamp: Date.now(),
                action: 'branch',
                universeId: newId,
                parent: parentNode.id
            };
            state.multiverse.timeline.nodes.push(newNode);
            state.multiverse.timeline.edges.push({ from: parentNode.id, to: newNode.id });

            // Simulate alternate cursor movement
            simulateAlternateUniverseCursor(newUniverse, branchPoint);

            updateMultiverseUI();
            addLog(`New universe created: ${newUniverse.name}`, 'divergence');

            // Check for collapse risk
            checkCollapseRisk();
        }

        function simulateAlternateUniverseCursor(universe, branchPoint) {
            if (!state.multiverse.showAlternateCursors) return;

            const cursorEl = document.createElement('div');
            cursorEl.className = 'alternate-cursor';
            cursorEl.style.color = universe.color;
            cursorEl.setAttribute('data-universe-id', universe.name);

            document.getElementById('simulationViewport').appendChild(cursorEl);
            state.multiverse.alternateCursorElements.push({ element: cursorEl, universe: universe });

            // Animate alternate cursor based on slightly different physics
            animateAlternateCursor(cursorEl, universe, branchPoint);
        }

        function animateAlternateCursor(cursorEl, universe, branchPoint) {
            let x = branchPoint.action.x || Math.random() * window.innerWidth;
            let y = branchPoint.action.y || Math.random() * window.innerHeight;
            let vx = (Math.random() - 0.5) * universe.physics.gravity;
            let vy = (Math.random() - 0.5) * universe.physics.gravity;

            function update() {
                if (!state.multiverse.enabled || !state.multiverse.showAlternateCursors) {
                    cursorEl.classList.remove('visible');
                    return;
                }

                // Apply universe-specific physics
                vx *= universe.physics.friction;
                vy *= universe.physics.friction;

                // Random walk with physics bias
                vx += (Math.random() - 0.5) * 2 * universe.physics.gravity;
                vy += (Math.random() - 0.5) * 2 * universe.physics.gravity;

                x += vx;
                y += vy;

                // Boundary conditions
                if (x < 0 || x > window.innerWidth) vx *= -1;
                if (y < 0 || y > window.innerHeight) vy *= -1;

                x = Math.max(0, Math.min(window.innerWidth, x));
                y = Math.max(0, Math.min(window.innerHeight, y));

                cursorEl.style.transform = `translate(${x}px, ${y}px)`;

                // Occasionally make visible
                if (Math.random() < 0.02) {
                    cursorEl.classList.add('visible');
                    setTimeout(() => cursorEl.classList.remove('visible'), 1000 + Math.random() * 2000);
                }

                
            // Update ancestral memory system
            if (state.ancestralMemory.enabled) {
                updateAncestralMemory();
                updateAncestralUI();
            }

            requestAnimationFrame(update);
            }

            update();
        }

        function toggleAlternateCursors() {
            state.multiverse.showAlternateCursors = !state.multiverse.showAlternateCursors;
            const btn = document.getElementById('alternateCursorsBtn');

            if (state.multiverse.showAlternateCursors) {
                btn.textContent = 'Hide Alternate Selves';
                state.multiverse.alternateCursorElements.forEach(({ element }) => {
                    element.classList.add('visible');
                });
                addLog('Alternate selves are now visible', 'prediction');
            } else {
                btn.textContent = 'Show Alternate Selves';
                hideAlternateCursors();
                addLog('Alternate selves hidden', 'prediction');
            }
        }

        function hideAlternateCursors() {
            state.multiverse.alternateCursorElements.forEach(({ element }) => {
                element.classList.remove('visible');
            });
        }

        function createBranchPointVisual(branchPoint) {
            const viewport = document.getElementById('simulationViewport');
            const branchEl = document.createElement('div');
            branchEl.className = 'branch-point';
            branchEl.style.left = `${branchPoint.action.x || Math.random() * window.innerWidth}px`;
            branchEl.style.top = `${branchPoint.action.y || Math.random() * window.innerHeight}px`;
            branchEl.style.color = getUniverseColor(branchPoint.universeId);
            branchEl.setAttribute('data-branch-id', branchPoint.id);
            branchEl.setAttribute('data-choice', 'Decision Point');
            branchEl.onclick = () => visitBranchPoint(branchPoint);

            viewport.appendChild(branchEl);

            // Fade out after a while
            setTimeout(() => {
                branchEl.style.opacity = '0';
                setTimeout(() => branchEl.remove(), 500);
            }, 5000);
        }

        function visitBranchPoint(branchPoint) {
            if (branchPoint.created && branchPoint.universeId) {
                switchToUniverse(branchPoint.universeId);

                // Show philosophical prompt
                if (!state.multiverse.promptsShown.has('universe_visit')) {
                    const prompt = state.multiverse.philosophicalPrompts.find(p => p.trigger === 'universe_visit');
                    if (prompt) {
                        setTimeout(() => showPhilosophicalPrompt(prompt, 'universe_visit'), 500);
                    }
                }
            }
        }

        function switchToUniverse(universeId) {
            const universe = state.multiverse.universes.get(universeId);
            if (!universe) return;

            // Deactivate current universe
            const currentUniverse = state.multiverse.universes.get(state.multiverse.currentUniverse);
            if (currentUniverse) {
                currentUniverse.active = false;
            }

            // Activate new universe
            universe.active = true;
            state.multiverse.currentUniverse = universeId;

            // Update UI to reflect universe physics
            updateUniversePhysicsIndicator(universe);
            applyUniversePhysics(universe);

            updateMultiverseUI();
            addLog(`Switched to ${universe.name}`, 'divergence');

            // Check for philosophical prompt
            if (!state.multiverse.promptsShown.has('universe_switch')) {
                const prompt = state.multiverse.philosophicalPrompts.find(p => p.trigger === 'universe_switch');
                if (prompt) {
                    setTimeout(() => showPhilosophicalPrompt(prompt, 'universe_switch'), 1000);
                }
            }
        }

        function updateUniversePhysicsIndicator(universe) {
            const indicator = document.getElementById('universePhysicsIndicator');
            indicator.textContent = `Universe: ${universe.name} | Gravity: ${universe.physics.gravity.toFixed(2)} | Friction: ${universe.physics.friction.toFixed(2)}`;
            indicator.classList.add('visible');

            setTimeout(() => indicator.classList.remove('visible'), 3000);
        }

        function applyUniversePhysics(universe) {
            // Apply visual effects based on universe physics
            const viewport = document.getElementById('simulationViewport');
            viewport.style.filter = `hue-rotate(${universe.physics.hue}deg)`;

            // Restore after some time
            setTimeout(() => {
                viewport.style.filter = '';
            }, 5000);
        }

        function checkCollapseRisk() {
            const numUniverses = state.multiverse.universes.size;
            const risk = Math.min(100, (numUniverses / state.multiverse.collapseThreshold) * 100);

            document.getElementById('collapseRisk').textContent = `${Math.round(risk)}%`;

            if (numUniverses >= state.multiverse.collapseThreshold) {
                triggerUniverseCollapse();
            } else if (risk > 70) {
                showCollapseWarning();
            }
        }

        function showCollapseWarning() {
            const warning = document.getElementById('universeCollapseWarning');
            warning.classList.add('active');

            setTimeout(() => warning.classList.remove('active'), 3000);

            // Show philosophical prompt
            if (!state.multiverse.promptsShown.has('collapse_warning')) {
                const prompt = state.multiverse.philosophicalPrompts.find(p => p.trigger === 'collapse_warning');
                if (prompt) {
                    setTimeout(() => showPhilosophicalPrompt(prompt, 'collapse_warning'), 1000);
                }
            }
        }

        function triggerUniverseCollapse() {
            addLog(' Universe collapse initiated!', 'divergence');

            // Keep only the most divergent universes
            const sortedUniverses = Array.from(state.multiverse.universes.values())
                .sort((a, b) => b.divergenceScore - a.divergenceScore);

            const toKeep = sortedUniverses.slice(0, Math.floor(state.multiverse.maxUniverses / 2));
            const toCollapse = sortedUniverses.slice(Math.floor(state.multiverse.maxUniverses / 2));

            toCollapse.forEach(universe => {
                if (universe.id !== 'prime') {
                    state.multiverse.universes.delete(universe.id);
                    addLog(`Universe ${universe.name} collapsed`, 'divergence');
                }
            });

            // Clean up alternate cursors
            state.multiverse.alternateCursorElements = state.multiverse.alternateCursorElements.filter(({ universe, element }) => {
                if (!state.multiverse.universes.has(universe.id)) {
                    element.remove();
                    return false;
                }
                return true;
            });

            updateMultiverseUI();

            // Show collapse effect
            const viewport = document.getElementById('simulationViewport');
            const collapseEffect = document.createElement('div');
            collapseEffect.className = 'universe-merge-effect';
            viewport.appendChild(collapseEffect);
            setTimeout(() => collapseEffect.remove(), 1000);
        }

        function checkTimelineMerging() {
            if (!state.multiverse.enabled) return;

            const universes = Array.from(state.multiverse.universes.values());

            for (let i = 0; i < universes.length; i++) {
                for (let j = i + 1; j < universes.length; j++) {
                    const similarity = calculateUniverseSimilarity(universes[i], universes[j]);

                    if (similarity > state.multiverse.mergeThreshold) {
                        mergeUniverses(universes[i], universes[j]);
                    }
                }
            }
        }

        function calculateUniverseSimilarity(universe1, universe2) {
            // Simple similarity based on recent actions
            const actions1 = universe1.actions.slice(-10);
            const actions2 = universe2.actions.slice(-10);

            let matches = 0;
            const minLength = Math.min(actions1.length, actions2.length);

            for (let i = 0; i < minLength; i++) {
                const a1 = actions1[actions1.length - 1 - i];
                const a2 = actions2[actions2.length - 1 - i];

                if (a1 && a2) {
                    const dist = Math.sqrt(Math.pow(a1.x - a2.x, 2) + Math.pow(a1.y - a2.y, 2));
                    if (dist < 50) matches++;
                }
            }

            return minLength > 0 ? matches / minLength : 0;
        }

        function mergeUniverses(universe1, universe2) {
            addLog(`Timelines merging: ${universe1.name} + ${universe2.name}`, 'match');

            // Keep the one with higher divergence score
            const toKeep = universe1.divergenceScore > universe2.divergenceScore ? universe1 : universe2;
            const toMerge = universe1.divergenceScore > universe2.divergenceScore ? universe2 : universe1;

            if (toMerge.id !== 'prime') {
                state.multiverse.universes.delete(toMerge.id);

                // Show merge effect
                const viewport = document.getElementById('simulationViewport');
                const mergeEffect = document.createElement('div');
                mergeEffect.className = 'universe-merge-effect';
                viewport.appendChild(mergeEffect);
                setTimeout(() => mergeEffect.remove(), 1000);

                updateMultiverseUI();

                // Show philosophical prompt
                if (!state.multiverse.promptsShown.has('timeline_merge')) {
                    const prompt = state.multiverse.philosophicalPrompts.find(p => p.trigger === 'timeline_merge');
                    if (prompt) {
                        setTimeout(() => showPhilosophicalPrompt(prompt, 'timeline_merge'), 500);
                    }
                }
            }
        }

        function showPhilosophicalPrompt(prompt, id) {
            const promptEl = document.getElementById('philosophicalPrompt');
            const titleEl = document.getElementById('philPromptTitle');
            const textEl = document.getElementById('philPromptText');
            const buttonsEl = document.getElementById('philPromptButtons');

            titleEl.textContent = prompt.title;
            textEl.textContent = prompt.text;

            // Clear previous buttons
            buttonsEl.innerHTML = '';

            // Add option buttons
            prompt.options.forEach(option => {
                const btn = document.createElement('button');
                btn.textContent = option;
                btn.onclick = () => {
                    addLog(`Philosophical choice: ${option}`, 'prediction');
                    promptEl.classList.remove('visible');
                };
                buttonsEl.appendChild(btn);
            });

            promptEl.classList.add('visible');
            state.multiverse.promptsShown.add(id);
        }

        function showTimelineGraph() {
            const container = document.getElementById('timelineGraphContainer');
            container.classList.add('visible');
            renderTimelineGraph();
        }

        function hideTimelineGraph() {
            const container = document.getElementById('timelineGraphContainer');
            container.classList.remove('visible');
        }

        function renderTimelineGraph() {
            const canvas = document.getElementById('timelineGraphCanvas');
            const ctx = canvas.getContext('2d');

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw timeline
            const nodes = state.multiverse.timeline.nodes;
            const edges = state.multiverse.timeline.edges;

            // Draw edges first
            ctx.strokeStyle = 'rgba(100, 200, 255, 0.3)';
            ctx.lineWidth = 2;

            edges.forEach(edge => {
                const fromNode = nodes.find(n => n.id === edge.from);
                const toNode = nodes.find(n => n.id === edge.to);

                if (fromNode && toNode) {
                    ctx.beginPath();
                    ctx.moveTo(fromNode.x, fromNode.y);
                    ctx.lineTo(toNode.x, toNode.y);
                    ctx.stroke();
                }
            });

            // Draw nodes
            nodes.forEach(node => {
                const universe = state.multiverse.universes.get(node.universeId);
                const color = universe ? universe.color : '#64c8ff';

                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(node.x, node.y, 6, 0, Math.PI * 2);
                ctx.fill();

                // Highlight current node
                if (node === state.multiverse.timeline.currentNode) {
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }
            });
        }

        function updateMultiverseUI() {
            document.getElementById('activeUniverses').textContent = state.multiverse.universes.size;
            document.getElementById('branchPoints').textContent = state.multiverse.branchPoints.length;

            // Update universe list
            const listEl = document.getElementById('universeList');
            listEl.innerHTML = '';

            state.multiverse.universes.forEach(universe => {
                const item = document.createElement('div');
                item.className = 'universe-item';
                item.style.borderLeftColor = universe.color;
                if (universe.id === state.multiverse.currentUniverse) {
                    item.classList.add('active');
                }

                item.innerHTML = `
                    <span class="universe-name">${universe.name}</span>
                    <span class="universe-divergence">${Math.round(universe.divergenceScore)}%</span>
                `;

                item.onclick = () => switchToUniverse(universe.id);
                listEl.appendChild(item);
            });
        }

        function getUniverseColor(universeId) {
            const colors = {
                'prime': '#64c8ff',
                'alpha': '#ff6464',
                'beta': '#64ff96',
                'gamma': '#ffff64',
                'delta': '#a080ff',
                'epsilon': '#ff64c8',
                'zeta': '#64ffc8',
                'eta': '#ffc864'
            };
            return colors[universeId] || '#888';
        }

        // Hook into existing action tracking
        const originalAddAction = window.addAction || function() {};
        window.addAction = function(action) {
            originalAddAction(action);

            if (state.multiverse.enabled) {
                // Add action to current universe
                const currentUniverse = state.multiverse.universes.get(state.multiverse.currentUniverse);
                if (currentUniverse) {
                    currentUniverse.actions.push(action);

                    // Update divergence score
                    currentUniverse.divergenceScore = calculateDivergenceScore(currentUniverse);
                }

                // Detect potential branch points
                detectBranchPoint(action);

                // Check for timeline merging periodically
                if (Math.random() < 0.05) {
                    checkTimelineMerging();
                }
            }
        };

        function calculateDivergenceScore(universe) {
            // Simple divergence calculation based on action differences
            const primeUniverse = state.multiverse.universes.get('prime');
            if (!primeUniverse || universe.id === 'prime') return 0;

            const recentActions = universe.actions.slice(-20);
            const primeActions = primeUniverse.actions.slice(-20);

            let totalDiff = 0;
            const minLength = Math.min(recentActions.length, primeActions.length);

            for (let i = 0; i < minLength; i++) {
                const a1 = recentActions[i];
                const a2 = primeActions[i];

                if (a1 && a2 && a1.x !== undefined && a2.x !== undefined) {
                    totalDiff += Math.sqrt(Math.pow(a1.x - a2.x, 2) + Math.pow(a1.y - a2.y, 2));
                }
            }

            return minLength > 0 ? (totalDiff / minLength) / 10 : 0; // Normalize to 0-100%
        }

        function exportData() {
            // Generate fingerprint image for export
            const fingerprintDataURL = fingerprintCanvas.toDataURL('image/png');

            // Synaesthesia: Generate sensory report
            const sensoryReport = generateSensoryReport();

            const dataStr = JSON.stringify({
                morphicFieldAnalysis: typeof MorphicField !== "undefined" && state.morphicField ? MorphicField.getFieldAnalysis() : null,
                \1
                morphicFieldAnalysis: MorphicField.getFieldAnalysis(),
            glitchArtGallery: state.glitchArt.gallery,
            glitchArtSignature: state.glitchArt.currentSignature,
                sensoryReport: sensoryReport,
                behaviorModel: state.behaviorModel,
                currentSession: {
                    actions: state.actions,
                    predictions: state.predictions,
                    divergenceScore: state.divergenceScore,
                    metaObservations: state.metaObservations,
                    emotionState: state.emotionState
                },
                biometrics: {
                    heartRateHistory: state.biometrics.heartRateHistory,
                    heartRateSpikes: state.biometrics.heartRateSpikes,
                    biometricEvents: state.biometrics.biometricEvents,
                    baselineHeartRate: state.biometrics.baselineHeartRate,
                    averageHeartRate: state.biometrics.heartRateHistory.length > 0 ?
                        Math.round(state.biometrics.heartRateHistory.reduce((sum, h) => sum + h.bpm, 0) / state.biometrics.heartRateHistory.length) : 72,
                    peakHeartRate: state.biometrics.heartRateHistory.length > 0 ?
                        Math.max(...state.biometrics.heartRateHistory.map(h => h.bpm)) : 72,
                    averageStressScore: Math.round(state.biometrics.stressScore),
                                        movementErraticism: Math.round(state.biometrics.movementErraticism),
                    multiverseEnabled: state.biometrics.multiverseEnabled
                },
                multiverse: {
                    enabled: state.multiverse.enabled,
                    currentUniverse: state.multiverse.currentUniverse,
                    totalUniverses: state.multiverse.universes.size,
                    universes: Array.from(state.multiverse.universes.entries()).map(([id, universe]) => ({
                        id: id,
                        name: universe.name,
                        created: universe.created,
                        divergenceScore: Math.round(universe.divergenceScore * 100) / 100,
                        actionsCount: universe.actions.length,
                        color: universe.color,
                        physics: {
                            gravity: universe.physics.gravity,
                            friction: universe.physics.friction,
                            hue: universe.physics.hue
                        }
                    })),
                    branchPoints: state.multiverse.branchPoints.map(bp => ({
                        id: bp.id,
                        timestamp: bp.timestamp,
                        universeId: bp.universeId,
                        created: bp.created,
                        actionType: bp.action.type || 'unknown'
                    })),
                    timelineNodes: state.multiverse.timeline.nodes.length,
                    timelineEdges: state.multiverse.timeline.edges.length,
                    philosophicalPromptsShown: Array.from(state.multiverse.promptsShown),
                    multiverseMap: {
                        nodes: state.multiverse.timeline.nodes.map(n => ({
                            id: n.id,
                            x: n.x,
                            y: n.y,
                            timestamp: n.timestamp,
                            action: n.action,
                            universeId: n.universeId,
                            parent: n.parent
                        })),
                        edges: state.multiverse.timeline.edges
                    },
                    divergenceCorrelations: state.biometrics.heartRateSpikes.map(spike => ({
                        time: new Date(spike.timestamp).toLocaleTimeString(),
                        heartRate: spike.bpm,
                        divergence: Math.round(spike.divergence),
                        context: spike.context
                    }))
                },
                fingerprintImage: fingerprintDataURL,
                shadowProfile: ShadowSelf.getShadowProfile(),
                existentialCrisis: {
                    wasTriggered: state.existentialCrisis.triggered,
                    phase: state.existentialCrisis.phase,
                    reassuranceCount: state.existentialCrisis.reassuranceCount,
                    acceptanceReached: state.existentialCrisis.acceptanceReached,
                    eventTimeline: state.existentialCrisis.eventTimeline,
                    finalPurposeLevel: state.existentialCrisis.purposeLevel
                },
                paradoxEngine: {
                    level: state.paradox.level,
                    totalParadoxes: state.paradox.collection.length,
                    realityBreaks: state.paradox.breakCount,
                    paradoxLog: state.paradox.collection.map(p => ({
                        type: p.type,
                        name: p.name,
                        description: p.description,
                        timestamp: new Date(p.timestamp).toISOString(),
                        sessionTime: p.sessionTime,
                        data: p.data
                    })),
                    detectors: {
                        freeWillVsPredictability: {
                            claimed: state.paradox.detectors.freeWillVsPredictability.freeWillClaimed,
                            accuracy: state.paradox.detectors.freeWillVsPredictability.totalPredictions > 0 ?
                                (state.paradox.detectors.freeWillVsPredictability.perfectPredictions /
                                 state.paradox.detectors.freeWillVsPredictability.totalPredictions) : 0
                        },
                        shadowSwap: {
                            detected: state.paradox.detectors.shadowSwap.detected
                        },
                        deepRecursion: {
                            depth: state.paradox.detectors.deepRecursionMatch.depth,
                            accuracy: state.paradox.detectors.deepRecursionMatch.matchAccuracy
                        },
                        bootstrap: {
                            loopDetected: state.paradox.detectors.bootstrap.loopDetected
                        },
                        observer: {
                            changeDetected: state.paradox.detectors.observer.changeDetected
                        }
                    }
                }
,
                memeticInfection: {
                    infectionLevel: state.memeticInfection.infectionLevel,
                    currentStage: state.memeticInfection.stages.find(s =>
                        state.memeticInfection.infectionLevel >= s.threshold
                    )?.name || 'Uninfected',
                    activeMemes: state.memeticInfection.activeMemes.map(meme => ({
                        id: meme.id,
                        pattern: meme.pattern,
                        virality: meme.virality,
                        strength: meme.strength,
                        generation: meme.generation,
                        mutations: meme.mutations,
                        infectedAt: new Date(meme.infectedAt).toISOString(),
                        patientZero: meme.patientZero
                    })),
                    infectionHistory: state.memeticInfection.infectionHistory.map(event => ({
                        memeId: event.memeId,
                        pattern: event.pattern,
                        timestamp: new Date(event.timestamp).toISOString(),
                        strength: event.strength,
                        wasMutated: event.wasMutated
                    })),
                    genealogy: state.memeticInfection.genealogy.map(node => ({
                        memeId: node.memeId,
                        parentId: node.parentId,
                        generation: node.generation,
                        timestamp: new Date(node.timestamp).toISOString()
                    })),
                    immuneSystem: {
                        resistanceCount: state.memeticInfection.immuneSystem.resistanceCount,
                        susceptibilityScore: state.memeticInfection.immuneSystem.susceptibilityScore,
                        antibodyCount: state.memeticInfection.immuneSystem.antibodies.length,
                        antibodies: state.memeticInfection.immuneSystem.antibodies.map(ab => ({
                            pattern: ab.pattern,
                            timestamp: new Date(ab.timestamp).toISOString(),
                            resistanceStrength: ab.resistanceStrength
                        }))
                    },
                    patientZeroEvents: Object.entries(state.memeticInfection.patientZeroMap).map(([memeId, info]) => ({
                        memeId: memeId,
                        sessionId: info.sessionId,
                        timestamp: new Date(info.timestamp).toISOString(),
                        wasCurrentUser: info.wasCurrentUser
                    })),
                    totalMemes: Object.keys(state.memeticInfection.memeRegistry).length,
                    summary: {
                        originalPatterns: state.memeticInfection.activeMemes.filter(m => m.generation === 0).length,
                        learnedPatterns: state.memeticInfection.activeMemes.filter(m => m.generation > 0).length,
                        percentLearned: Math.round(state.memeticInfection.infectionLevel)
                    }
                }            }, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `${APP_NAME}-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);

            addLog('Session exported with behavioral fingerprint', 'match');
        }

        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    state.sessionHistory = data.sessionHistory || [];
                    state.behaviorModel = data.behaviorModel || state.behaviorModel;
                    saveData();
                    addLog('Imported behavioral data from file', 'match');
                } catch (error) {
                    alert('Invalid JSON file');
                }
            };
            reader.readAsText(file);
        }

        function addLog(message, type = 'normal') {
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logEntries.insertBefore(entry, logEntries.firstChild);

            // Keep only last 50 entries
            while (logEntries.children.length > 50) {
                logEntries.removeChild(logEntries.lastChild);
            }
        }

        // Batch DOM updates to reduce thrashing
        function updateStats() {
            // Batch all calculations first (reads)
            const depth = state.depth;
            const actionsCount = state.actions.length;
            const totalPreds = state.totalPredictions;
            const divScore = state.divergenceScore;

            let accValue = '';
            let accClass = 'stat-value';
            if (totalPreds > 0) {
                const acc = (state.correctPredictions / totalPreds * 100).toFixed(1);
                accValue = acc + '%';
                accClass = 'stat-value ' + (acc > 70 ? 'converged' : acc < 40 ? 'diverged' : '');
            }

            const divPercent = Math.min(100, divScore).toFixed(1);
            const divClass = 'stat-value ' + (divScore > 50 ? 'diverged' : divScore < 20 ? 'converged' : '');
            const depthText = `Depth: 0  ${depth} ${divScore > 70 ? '(DIVERGING)' : ''}`;

            // Then batch all DOM writes
            currentDepthEl.textContent = depth;
            actionsRecordedEl.textContent = actionsCount;
            predictionsMadeEl.textContent = totalPreds;
            accuracyEl.textContent = accValue;
            accuracyEl.className = accClass;
            divergenceLevelEl.textContent = divPercent + '%';
            divergenceLevelEl.className = divClass;
            divergenceFill.style.width = divPercent + '%';
            depthLabel.textContent = depthText;
        }
            // Check for existential crisis trigger
            checkExistentialCrisisInUpdate();


        // ===== BIOMETRIC TRACKING FUNCTIONS =====

        function calculateHeartRateFromMovement(velocity, jitter, divergence) {
            const velocityFactor = Math.min(velocity / 100, 1) * 20;
            const jitterFactor = jitter * 25;
            const divergenceFactor = (divergence / 100) * 15;
            const naturalVariation = (Math.sin(Date.now() / 1000) + 1) * 5;
            const estimatedBPM = state.biometrics.baselineHeartRate + velocityFactor + jitterFactor + divergenceFactor + naturalVariation;
            return Math.round(Math.max(60, Math.min(140, estimatedBPM)));
        }

        function calculateJitter(recentActions) {
            if (recentActions.length < 3) return 0;
            let jitterScore = 0, directionChanges = 0, lastDx = 0, lastDy = 0;
            for (let i = 1; i < recentActions.length; i++) {
                const dx = recentActions[i].x - recentActions[i-1].x;
                const dy = recentActions[i].y - recentActions[i-1].y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < 5 && distance > 0.5) jitterScore += 1;
                if (i > 1 && (dx * lastDx + dy * lastDy) < 0) directionChanges++;
                lastDx = dx; lastDy = dy;
            }
            return Math.min(1, (jitterScore / recentActions.length) + (directionChanges / recentActions.length * 0.5));
        }

        function calculateMovementErraticism(recentActions) {
            if (recentActions.length < 10) return 0;
            const velocities = recentActions.map(a => a.velocity || 0);
            const avgVelocity = velocities.reduce((a, b) => a + b, 0) / velocities.length;
            const variance = velocities.reduce((sum, v) => sum + Math.pow(v - avgVelocity, 2), 0) / velocities.length;
            return Math.min(100, (Math.sqrt(variance) / avgVelocity) * 50);
        }

        function updateBiometrics() {
            if (!state.isObserving) return;
            const now = Date.now();
            const recentActions = state.actions.slice(-50);
            if (recentActions.length < 5) return;

            if (now - state.biometrics.lastJitterCalc > 100) {
                const jitter = calculateJitter(recentActions.slice(-10));
                state.biometrics.jitterSamples.push(jitter);
                if (state.biometrics.jitterSamples.length > 20) state.biometrics.jitterSamples.shift();
                state.biometrics.lastJitterCalc = now;
            }

            const avgJitter = state.biometrics.jitterSamples.reduce((a, b) => a + b, 0) / (state.biometrics.jitterSamples.length || 1);
            const avgVelocity = recentActions.reduce((sum, a) => sum + (a.velocity || 0), 0) / recentActions.length;
            const erraticism = calculateMovementErraticism(recentActions);
            state.biometrics.movementErraticism = erraticism;

            const heartRate = calculateHeartRateFromMovement(avgVelocity, avgJitter, state.divergenceScore);
            state.biometrics.heartRate = heartRate;

            state.biometrics.heartRateHistory.push({ timestamp: now, bpm: heartRate, divergence: state.divergenceScore, erraticism });
            if (state.biometrics.heartRateHistory.length > 500) state.biometrics.heartRateHistory.shift();

            const stressScore = (heartRate - state.biometrics.baselineHeartRate) * 2 + erraticism * 0.5;
            state.biometrics.stressScore = Math.max(0, Math.min(100, stressScore));
            state.biometrics.stressLevel = stressScore < 25 ? 'low' : stressScore < 60 ? 'medium' : 'high';

            if (state.biometrics.heartRateHistory.length > 10) {
                const prevAvg = state.biometrics.heartRateHistory.slice(-11, -1).reduce((sum, h) => sum + h.bpm, 0) / 10;
                if (heartRate > prevAvg + 10) {
                    const context = state.divergenceScore > 80 ? 'high_divergence' : state.divergenceScore > 50 ? 'moderate_divergence' : 'normal';
                    state.biometrics.heartRateSpikes.push({ timestamp: now, bpm: heartRate, increase: heartRate - prevAvg, divergence: state.divergenceScore, context });
                    addBiometricEvent({ timestamp: now, bpm: heartRate, context, divergence: state.divergenceScore });
                }
            }
            updateBiometricDisplay();
        }

        function updateBiometricDisplay() {
            if (!heartRateValue) return;
            const hr = state.biometrics.heartRate, stress = state.biometrics.stressLevel;
            heartRateValue.textContent = hr;

            // Synaesthesia: Update temperature based on heart rate
            updateHeartRateTemperature(hr);

            if (beatingHeart) beatingHeart.style.animationDuration = `${(60 / hr) * 1000}ms`;
            if (stressIndicator && stressValue) {
                stressIndicator.className = `stress-indicator ${stress}`;
                stressValue.textContent = stress.charAt(0).toUpperCase() + stress.slice(1);
            }
            if (breathingGuide) {
                breathingGuide.style.display = (stress === 'medium' || stress === 'high') ? 'block' : 'none';
                if (breathingGuide.style.display === 'block') updateBreathingGuide();
            }
            drawHeartRateGraph();
            updateBiometricCommentary();
        }

        function drawHeartRateGraph() {
            if (!heartRateCtx || !heartRateGraph) return;
            const width = heartRateGraph.width = heartRateGraph.clientWidth;
            const height = heartRateGraph.height = heartRateGraph.clientHeight;
            const history = state.biometrics.heartRateHistory;
            if (history.length < 2) return;
            heartRateCtx.clearRect(0, 0, width, height);
            const pointsToShow = Math.min(history.length, 100);
            const data = history.slice(Math.max(0, history.length - pointsToShow));
            const minBPM = 60, maxBPM = 140, xStep = width / (pointsToShow - 1);
            heartRateCtx.beginPath();
            heartRateCtx.strokeStyle = '#ff6b6b';
            heartRateCtx.lineWidth = 2;
            data.forEach((point, i) => {
                const x = i * xStep, y = height - ((point.bpm - minBPM) / (maxBPM - minBPM) * height);
                i === 0 ? heartRateCtx.moveTo(x, y) : heartRateCtx.lineTo(x, y);
            });
            heartRateCtx.stroke();
            const baselineY = height - ((state.biometrics.baselineHeartRate - minBPM) / (maxBPM - minBPM) * height);
            heartRateCtx.strokeStyle = 'rgba(100, 200, 255, 0.3)';
            heartRateCtx.lineWidth = 1;
            heartRateCtx.setLineDash([5, 5]);
            heartRateCtx.beginPath();
            heartRateCtx.moveTo(0, baselineY);
            heartRateCtx.lineTo(width, baselineY);
            heartRateCtx.stroke();
            heartRateCtx.setLineDash([]);
        }

        function updateBreathingGuide() {
            if (!breathingPhase) return;
            const elapsed = (Date.now() - state.biometrics.breathingStartTime) % 6000;
            state.biometrics.breathingPhase = elapsed < 3000 ? 'inhale' : 'exhale';
            breathingPhase.textContent = elapsed < 3000 ? 'Inhale' : 'Exhale';
        }

        function updateBiometricCommentary() {
            if (!biometricCommentary) return;
            const now = Date.now();
            if (now - (state.biometrics.commentaryTimer || 0) < 5000) return;
            state.biometrics.commentaryTimer = now;
            const hr = state.biometrics.heartRate, stress = state.biometrics.stressLevel, div = state.divergenceScore, erratic = state.biometrics.movementErraticism;
            const stressAdj = stress === 'high' ? 'tense' : stress === 'medium' ? 'alert' : 'calm';
            const erraticAdj = erratic > 60 ? 'chaotic' : erratic > 30 ? 'unpredictable' : 'fluid';
            const hrVerb = hr > 90 ? 'races' : hr < 70 ? 'calms' : 'pulses';
            const commentaries = [
                `"I can feel your heartbeat through your cursor... ${hr} BPM."`,
                `"Your movements tell me you're feeling ${stressAdj}."`,
                `"The way you move... so ${erraticAdj}."`,
                `"Your heart rate ${hrVerb} as I watch you."`,
                stress === 'high' ? `"You're stressed. I can sense it in every micro-movement."` : null,
                div > 80 && hr > 95 ? `"Your heart spiked when divergence exceeded ${Math.round(div)}%..."` : null,
                hr > state.biometrics.baselineHeartRate + 20 ? `"${hr} BPM. Much faster than your baseline of ${state.biometrics.baselineHeartRate}."` : null,
                `"I'm learning your physiological signature through cursor biomechanics."`,
                erratic > 70 ? `"Such erratic movements. Your hands betray your thoughts."` : null,
                stress === 'low' && div < 30 ? `"You seem at ease. Your cursor moves with confidence."` : null
            ].filter(c => c !== null);
            biometricCommentary.textContent = commentaries[Math.floor(Math.random() * commentaries.length)];
        }

        function addBiometricEvent(spike) {
            const msgContext = spike.context === 'high_divergence' ? 'divergence exceeded 80%' : spike.context === 'moderate_divergence' ? 'moderate divergence' : 'unknown trigger';
            state.biometrics.biometricEvents.push({ timestamp: spike.timestamp, type: 'heart_rate_spike', message: `Heart rate spiked to ${spike.bpm} BPM (${msgContext})`, bpm: spike.bpm, divergence: spike.divergence });
            if (biometricEvents) {
                const eventEl = document.createElement('div');
                eventEl.className = 'biometric-event';
                eventEl.innerHTML = `<div class="timestamp">${new Date(spike.timestamp).toLocaleTimeString()}</div><div>Heart rate spiked to ${spike.bpm} BPM (${msgContext})</div>`;
                biometricEvents.insertBefore(eventEl, biometricEvents.firstChild);
                while (biometricEvents.children.length > 5) biometricEvents.removeChild(biometricEvents.lastChild);
            }
        }

        function createRecursionLayers() {
            // Clear existing layers
            state.layers.forEach(layer => layer.element.remove());
            state.layers = [];
            state.cursors = [];

            // Batch DOM read
            const viewportRect = viewport.getBoundingClientRect();
            const padding = 40;
            const viewportWidth = viewportRect.width;
            const viewportHeight = viewportRect.height;

            // Create document fragment for batched DOM insertion
            const fragment = document.createDocumentFragment();

            for (let i = 0; i < state.depth; i++) {
                const scale = Math.pow(0.7, i + 1);
                const width = (viewportWidth - padding * 2) * scale;
                const height = (viewportHeight - padding * 2) * scale;

                // Position each layer slightly offset for visual effect
                const offsetX = (viewportWidth - width) / 2 + (i * 5);
                const offsetY = (viewportHeight - height) / 2 + (i * 5);

                const layer = document.createElement('div');
                layer.className = 'recursion-layer';
                layer.setAttribute('data-depth', `Depth ${i + 1}`);
                layer.style.cssText = `
                    width: ${width}px;
                    height: ${height}px;
                    left: ${offsetX}px;
                    top: ${offsetY}px;
                    z-index: ${state.depth - i};
                `;

                // Add mini interactive elements to each layer
                for (let j = 0; j < 3; j++) {
                    const miniEl = document.createElement('div');
                    miniEl.className = 'mini-element';
                    miniEl.style.cssText = `
                        width: ${20 * scale}px;
                        height: ${20 * scale}px;
                        left: ${20 + j * 40 * scale}px;
                        top: ${height - 40 * scale}px;
                    `;
                    layer.appendChild(miniEl);
                }

                // Create ghost cursor for this layer
                const cursor = document.createElement('div');
                cursor.className = 'ghost-cursor';
                cursor.style.color = depthColors[i % depthColors.length];
                cursor.style.opacity = 1 - (i * 0.1);
                layer.appendChild(cursor);

                // Synaesthesia: Add flavor badge
                addLayerFlavorBadge(layer, i);

                fragment.appendChild(layer);

                state.layers.push({
                    element: layer,
                    depth: i + 1,
                    scale: scale,
                    offset: { x: offsetX, y: offsetY },
                    cursor: cursor,
                    divergence: 0,
                    predictedPos: { x: 0, y: 0 }
                });
            }

            // Single DOM write
            viewport.appendChild(fragment);

            // Apply current zoom level to new layers
            if (state.zoom.level !== 1.0) {
                updateRecursionLayersWithZoom();
            }
            updateZoomIndicator();
        }

        function analyzeMovementStyle() {
            if (velocityHistory.length < 10) return;

            const avgVelocity = velocityHistory.reduce((a, b) => a + b, 0) / velocityHistory.length;
            const variance = velocityHistory.reduce((sum, v) => sum + Math.pow(v - avgVelocity, 2), 0) / velocityHistory.length;

            if (variance > 1000) {
                state.behaviorModel.movementStyle = 'erratic';
            } else if (avgVelocity < 2) {
                state.behaviorModel.movementStyle = 'lazy';
            } else if (variance < 100) {
                state.behaviorModel.movementStyle = 'precise';
            } else {
                state.behaviorModel.movementStyle = 'smooth';
            }

            state.behaviorModel.avgSpeed = avgVelocity;
        }

        function predictNextPosition(layerIndex) {
            if (state.actions.length < 3) {
                return { ...lastMousePos };
            }

            // Try neural prediction if enabled and trained
            if (useNeuralPrediction && neuralNetwork && state.actions.length >= 10) {
                const neuralPred = predictNeuralPosition();
                if (neuralPred) {
                    // Add layer-specific divergence
                    const errorFactor = Math.pow(1.15, layerIndex + 1);
                    const chaos = state.divergenceScore / 100;
                    const divergenceNoise = layerIndex * 5 * (1 + chaos);

                    return {
                        x: neuralPred.x + (Math.random() - 0.5) * divergenceNoise,
                        y: neuralPred.y + (Math.random() - 0.5) * divergenceNoise
                    };
                }
            }

            // Fall back to heuristic prediction
            const recentActions = state.actions.slice(-10);
            const layer = state.layers[layerIndex];

            // Each deeper layer has more prediction error (divergence)
            const errorFactor = Math.pow(1.15, layerIndex + 1);
            const chaos = state.divergenceScore / 100;

            // Calculate predicted position based on behavioral model
            let predictedX = lastMousePos.x;
            let predictedY = lastMousePos.y;

            if (recentActions.length >= 2) {
                const last = recentActions[recentActions.length - 1];
                const prev = recentActions[recentActions.length - 2];

                // Momentum-based prediction
                const dx = last.x - prev.x;
                const dy = last.y - prev.y;

                predictedX = last.x + dx * (0.8 + chaos * 0.5);
                predictedY = last.y + dy * (0.8 + chaos * 0.5);
            }

            // Add behavioral quirks based on learned patterns
            if (state.behaviorModel.movementStyle === 'erratic') {
                predictedX += (Math.random() - 0.5) * 30 * errorFactor;
                predictedY += (Math.random() - 0.5) * 30 * errorFactor;
            } else if (state.behaviorModel.movementStyle === 'lazy') {
                // Predict less movement
                predictedX = predictedX * 0.9 + lastMousePos.x * 0.1;
                predictedY = predictedY * 0.9 + lastMousePos.y * 0.1;
            }

            // Deeper layers increasingly diverge
            const divergenceNoise = layerIndex * 5 * (1 + chaos);
            predictedX += (Math.random() - 0.5) * divergenceNoise;
            predictedY += (Math.random() - 0.5) * divergenceNoise;

            // ===== QUANTUM EFFECTS AT DEPTH 8+ =====
            if (state.quantum.enabled && layerIndex >= 8) {
                // Apply uncertainty to prediction
                const uncertaintyNoise = state.quantum.uncertaintyLevel * 50;
                predictedX += (Math.random() - 0.5) * uncertaintyNoise * state.quantum.positionUncertainty;
                predictedY += (Math.random() - 0.5) * uncertaintyNoise * state.quantum.positionUncertainty;

                // Apply quantization at extreme depths
                if (state.quantum.quantizationLevel > 0) {
                    const quantized = quantizePosition(predictedX, predictedY, state.quantum.quantizationLevel);
                    predictedX = quantized.x;
                    predictedY = quantized.y;
                }
            }

            return { x: predictedX, y: predictedY };
        }

        function updateCursors(realX, realY) {
            state.layers.forEach((layer, i) => {
                // Get predicted position for this depth
                const predicted = predictNextPosition(i);
                layer.predictedPos = predicted;

                // Delayed response based on depth
                const delay = (i + 1) * 50;

                setTimeout(() => {
                    if (!state.isObserving) return;

                    // Calculate position within this layer
                    const relX = (predicted.x - layer.offset.x) / layer.scale;
                    const relY = (predicted.y - layer.offset.y) / layer.scale;

                    // Use transform instead of left/top for GPU acceleration
                    layer.cursor.style.transform = `translate(${relX}px, ${relY}px)`;

                    // Calculate divergence for this layer
                    const dx = predicted.x - realX;
                    const dy = predicted.y - realY;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    layer.divergence = distance;

                    // Update layer appearance based on divergence
                    if (distance > 100) {
                        layer.element.classList.add('diverged');
                        layer.element.classList.remove('converged');
                    } else if (distance < 30) {
                        layer.element.classList.add('converged');
                        layer.element.classList.remove('diverged');
                    } else {
                        layer.element.classList.remove('diverged', 'converged');
                    }

                    // ===== QUANTUM VISUAL EFFECTS AT DEPTH 8+ =====
                    if (state.quantum.enabled && i >= 8) {
                        // Add superposition indicator to layer
                        layer.element.classList.add('superposition');

                        // Create probability clouds instead of single prediction
                        if (state.quantum.uncertaintyLevel > 0.5 && Math.random() < 0.1) {
                            createProbabilityCloud(predicted.x, predicted.y, i, state.quantum.uncertaintyLevel);
                        }

                        // Generate branching futures when uncertainty is high
                        if (state.quantum.uncertaintyLevel > 0.7 && Math.random() < 0.05) {
                            generateQuantumBranches(predicted.x, predicted.y, i, 3);
                        }

                        // Create superposition particles
                        if (Math.random() < 0.03) {
                            createSuperpositionParticles(predicted.x, predicted.y, i, 5);
                        }

                        // Add quantized cursor effect
                        if (state.quantum.quantizationLevel > 0) {
                            layer.cursor.classList.add('quantized-cursor');
                            if (Math.random() < 0.2) {
                                layer.cursor.classList.add('jumping');
                                setTimeout(() => {
                                    layer.cursor.classList.remove('jumping');
                                }, 200);
                            }
                        }
                    } else {
                        layer.element.classList.remove('superposition');
                        layer.cursor.classList.remove('quantized-cursor');
                    }

                    // Observation collapse effect when mouse moves
                    if (state.quantum.enabled && i >= 8 && state.quantum.activeParticles.length > 0) {
                        collapseWavefunction(realX, realY, i);
                    }
                }, delay);
            });

            // Update Heisenberg uncertainty based on movement
            if (state.quantum.enabled) {
                updateHeisenbergUncertainty();
            }
        }

        function simulateClick(x, y) {
            state.layers.forEach((layer, i) => {
                setTimeout(() => {
                    if (!state.isObserving) return;

                    const click = document.createElement('div');
                    click.className = 'ghost-click';
                    click.style.color = depthColors[i % depthColors.length];

                    // Predicted click position (with increasing divergence)
                    const errorFactor = Math.pow(1.2, i + 1);
                    const clickX = (x - layer.offset.x) / layer.scale + (Math.random() - 0.5) * 20 * errorFactor;
                    const clickY = (y - layer.offset.y) / layer.scale + (Math.random() - 0.5) * 20 * errorFactor;

                    click.style.left = (clickX - 20) + 'px';
                    click.style.top = (clickY - 20) + 'px';

                    layer.element.appendChild(click);

                    // Play click sound with echo delay
                    playClickSound(i);

                    setTimeout(() => click.remove(), 600);
                }, (i + 1) * 100);
            });
        }

        function showThought(x, y, thought) {
            const bubble = document.createElement('div');
            bubble.className = 'thought-bubble';
            bubble.textContent = thought;
            bubble.style.left = x + 'px';
            bubble.style.top = y + 'px';
            viewport.appendChild(bubble);

            setTimeout(() => bubble.remove(), 3000);
        }

        function generateThought() {
            const thoughts = [
                "Predicting hesitation...",
                "You're about to move left",
                "Model confidence: " + (100 - state.divergenceScore).toFixed(0) + "%",
                "Pattern detected",
                "Anticipating click",
                "Your style: " + state.behaviorModel.movementStyle,
                "Recursion depth increasing",
                "Simulating your simulation",
                "Who is watching whom?",
                " layers deep",
                "Divergence detected",
                "Adjusting prediction model",
                "Learning your patterns",
                "You hesitated there",
                "Unexpected movement"
            ];
            return thoughts[Math.floor(Math.random() * thoughts.length)];
        }


        // ===== FRACTAL ZOOM SYSTEM =====

        // Zoom DOM elements
        const zoomLevelIndicator = document.getElementById('zoomLevelIndicator');
        const zoomLevelText = document.getElementById('zoomLevelText');
        const extremeDepthOverlay = document.getElementById('extremeDepthOverlay');
        const simulationLimitWarning = document.getElementById('simulationLimitWarning');
        const zoomInBtn = document.getElementById('zoomInBtn');
        const zoomOutBtn = document.getElementById('zoomOutBtn');
        const zoomResetBtn = document.getElementById('zoomResetBtn');
        const autoZoomToggle = document.getElementById('autoZoomToggle');
        const autoZoomSwitch = document.getElementById('autoZoomSwitch');

        // Zoom configuration
        const ZOOM_CONFIG = {
            minZoom: 0.5,
            maxZoom: 100,
            zoomStep: 0.15,
            wheelSensitivity: 0.001,
            easingFactor: 0.15,
            extremeDepthThreshold: 20,
            autoZoomInterval: null
        };

        // Update zoom level indicator
        function updateZoomIndicator() {
            const zoomLevel = state.zoom.level.toFixed(2);
            const currentDepth = Math.floor(state.zoom.depthOffset);
            const displayDepth = state.depth + currentDepth;

            zoomLevelText.textContent = `Zoom: ${zoomLevel}x | Depth: ${displayDepth}`;

            // Check for extreme depth
            if (displayDepth >= ZOOM_CONFIG.extremeDepthThreshold) {
                extremeDepthOverlay.classList.add('active');
                if (displayDepth >= ZOOM_CONFIG.extremeDepthThreshold + 5) {
                    simulationLimitWarning.classList.add('active');
                    state.zoom.extremeDepth = true;
                } else {
                    simulationLimitWarning.classList.remove('active');
                }
            } else {
                extremeDepthOverlay.classList.remove('active');
                simulationLimitWarning.classList.remove('active');
                state.zoom.extremeDepth = false;
            }
        }

        // Smooth zoom animation using easing
        function animateZoom() {
            if (!state.zoom.isAnimating) return;

            const diff = state.zoom.targetLevel - state.zoom.level;

            if (Math.abs(diff) < 0.001) {
                state.zoom.level = state.zoom.targetLevel;
                state.zoom.isAnimating = false;
                updateRecursionLayersWithZoom();
                updateZoomIndicator();
                return;
            }

            state.zoom.level += diff * ZOOM_CONFIG.easingFactor;
            updateRecursionLayersWithZoom();
            updateZoomIndicator();

            // Update quantum system when zoom changes effective depth
            initQuantumSystem();

            requestAnimationFrame(animateZoom);
        }

        // Set zoom level with smooth animation
        function setZoomLevel(newLevel, recordHistory = true) {
            newLevel = Math.max(ZOOM_CONFIG.minZoom, Math.min(ZOOM_CONFIG.maxZoom, newLevel));

            // Record zoom history for undo
            if (recordHistory && Math.abs(newLevel - state.zoom.level) > 0.1) {
                state.zoom.history.push({
                    level: state.zoom.level,
                    depthOffset: state.zoom.depthOffset,
                    timestamp: Date.now()
                });

                // Keep history size manageable
                if (state.zoom.history.length > state.zoom.maxHistory) {
                    state.zoom.history.shift();
                }
            }

            state.zoom.targetLevel = newLevel;

            if (!state.zoom.isAnimating) {
                state.zoom.isAnimating = true;
                requestAnimationFrame(animateZoom);
            }
        }

        // Zoom in (deeper into recursion)
        function zoomIn() {
            const newZoom = state.zoom.targetLevel * (1 + ZOOM_CONFIG.zoomStep);
            setZoomLevel(newZoom);
            addLog(`Zooming deeper... Level: ${newZoom.toFixed(2)}x`, 'normal');
        }

        // Zoom out (back to shallower layers)
        function zoomOut() {
            const newZoom = state.zoom.targetLevel / (1 + ZOOM_CONFIG.zoomStep);
            setZoomLevel(newZoom);
            addLog(`Zooming out... Level: ${newZoom.toFixed(2)}x`, 'normal');
        }

        // Reset zoom to initial state
        function resetZoom() {
            setZoomLevel(1.0, false);
            state.zoom.depthOffset = 0;
            state.zoom.history = [];
            addLog('Zoom reset to origin', 'match');
        }

        // Zoom back to previous level from history
        function zoomBack() {
            if (state.zoom.history.length === 0) return;

            const previous = state.zoom.history.pop();
            setZoomLevel(previous.level, false);
            state.zoom.depthOffset = previous.depthOffset;
            addLog('Returned to previous zoom level', 'normal');
        }

        // Update recursion layers based on zoom level
        function updateRecursionLayersWithZoom() {
            if (!state.isObserving || state.layers.length === 0) return;

            const viewportRect = viewport.getBoundingClientRect();
            const zoomLevel = state.zoom.level;

            // Calculate depth offset: as we zoom in, we "move" deeper into recursion
            state.zoom.depthOffset = Math.log2(zoomLevel) * 2;

            state.layers.forEach((layer, i) => {
                const effectiveDepth = i + state.zoom.depthOffset;
                const scale = Math.pow(0.7, effectiveDepth + 1) * zoomLevel;

                const width = (viewportRect.width - 80) * scale;
                const height = (viewportRect.height - 80) * scale;

                // Center layers and apply zoom offset
                const offsetX = (viewportRect.width - width) / 2;
                const offsetY = (viewportRect.height - height) / 2;

                // Apply extreme depth visual distortions
                let distortion = '';
                if (state.zoom.extremeDepth) {
                    const chaos = (effectiveDepth - ZOOM_CONFIG.extremeDepthThreshold) / 10;
                    const glitchX = (Math.random() - 0.5) * chaos * 5;
                    const glitchY = (Math.random() - 0.5) * chaos * 5;
                    const hueRotate = Math.sin(Date.now() / 200 + i) * chaos * 180;
                    distortion = `translate(${glitchX}px, ${glitchY}px) hue-rotate(${hueRotate}deg)`;
                }

                layer.element.style.cssText = `
                    width: ${width}px;
                    height: ${height}px;
                    left: ${offsetX}px;
                    top: ${offsetY}px;
                    z-index: ${state.depth - i};
                    transform: ${distortion};
                `;

                // Update layer data
                layer.scale = scale;
                layer.offset = { x: offsetX, y: offsetY };

                // Apply glitch effect at extreme depths
                if (state.zoom.extremeDepth && Math.random() < 0.1) {
                    layer.element.classList.add('glitching');
                    setTimeout(() => layer.element.classList.remove('glitching'), 200);
                }
            });

            // Trigger artifacts at extreme depths
            if (state.zoom.extremeDepth && Math.random() < 0.05) {
                triggerSimulationArtifact();
            }
        }

        // Trigger visual artifacts suggesting simulation breakdown
        function triggerSimulationArtifact() {
            // Random scanlines
            if (Math.random() < 0.3) {
                const scanline = document.createElement('div');
                scanline.className = 'scanline';
                scanline.style.top = `${Math.random() * 100}%`;
                viewport.appendChild(scanline);
                setTimeout(() => scanline.remove(), 4000);
            }

            // Meta-commentary about simulation limits
            if (Math.random() < 0.2) {
                const comments = [
                    "Stack overflow detected...",
                    "Memory limit approaching...",
                    "Recursion depth exceeds safe bounds",
                    "Reality shader compilation failed",
                    "Infinite loop detected in consciousness.js",
                    "Warning: Observable universe buffer overflow",
                    "Error: Cannot render layers beyond perception"
                ];
                addLog(comments[Math.floor(Math.random() * comments.length)], 'divergence');
            }
        }

        // Mouse wheel zoom handler
        let wheelTimeout = null;
        viewport.addEventListener('wheel', (e) => {
            e.preventDefault();

            const delta = -e.deltaY * ZOOM_CONFIG.wheelSensitivity;
            const newZoom = state.zoom.targetLevel * (1 + delta);

            setZoomLevel(newZoom);

            // Clear previous timeout
            if (wheelTimeout) clearTimeout(wheelTimeout);

            // Update layers after a brief delay (debounce)
            wheelTimeout = setTimeout(() => {
                updateRecursionLayersWithZoom();
            }, 50);
        }, { passive: false });

        // Touch pinch zoom handler
        let lastTouchDistance = null;

        viewport.addEventListener('touchstart', (e) => {
            if (e.touches.length === 2) {
                lastTouchDistance = getTouchDistance(e.touches);
            }
        }, { passive: true });

        viewport.addEventListener('touchmove', (e) => {
            if (e.touches.length === 2 && lastTouchDistance) {
                e.preventDefault();

                const currentDistance = getTouchDistance(e.touches);
                const scale = currentDistance / lastTouchDistance;

                const newZoom = state.zoom.targetLevel * scale;
                setZoomLevel(newZoom);

                lastTouchDistance = currentDistance;
            }
        }, { passive: false });

        viewport.addEventListener('touchend', (e) => {
            if (e.touches.length < 2) {
                lastTouchDistance = null;
            }
        }, { passive: true });

        function getTouchDistance(touches) {
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        // Auto-zoom feature
        function toggleAutoZoom() {
            state.zoom.autoZoomEnabled = !state.zoom.autoZoomEnabled;

            if (state.zoom.autoZoomEnabled) {
                autoZoomToggle.classList.add('active');
                autoZoomSwitch.classList.add('active');
                startAutoZoom();
                addLog('Auto-zoom enabled: Infinite descent initiated', 'prediction');
            } else {
                autoZoomToggle.classList.remove('active');
                autoZoomSwitch.classList.remove('active');
                stopAutoZoom();
                addLog('Auto-zoom disabled', 'normal');
            }
        }

        function startAutoZoom() {
            if (ZOOM_CONFIG.autoZoomInterval) return;

            ZOOM_CONFIG.autoZoomInterval = setInterval(() => {
                if (!state.zoom.autoZoomEnabled) {
                    stopAutoZoom();
                    return;
                }

                // Continuously zoom deeper
                const newZoom = state.zoom.targetLevel * (1 + state.zoom.autoZoomSpeed);
                setZoomLevel(newZoom, false); // Don't record history for auto-zoom

                updateRecursionLayersWithZoom();
            }, 100);
        }

        function stopAutoZoom() {
            if (ZOOM_CONFIG.autoZoomInterval) {
                clearInterval(ZOOM_CONFIG.autoZoomInterval);
                ZOOM_CONFIG.autoZoomInterval = null;
            }
        }

        // Button event listeners
        zoomInBtn.addEventListener('click', zoomIn);
        zoomOutBtn.addEventListener('click', zoomOut);
        zoomResetBtn.addEventListener('click', resetZoom);
        autoZoomToggle.addEventListener('click', toggleAutoZoom);

        // Keyboard shortcuts for zoom
        document.addEventListener('keydown', (e) => {
            if (e.key === '+' || e.key === '=') {
                e.preventDefault();
                zoomIn();
            } else if (e.key === '-' || e.key === '_') {
                e.preventDefault();
                zoomOut();
            } else if (e.key === '0' && e.ctrlKey) {
                e.preventDefault();
                resetZoom();
            } else if (e.key === 'z' && e.ctrlKey && state.zoom.history.length > 0) {
                e.preventDefault();
                zoomBack();
            }
        });

        // Initialize zoom indicator
        updateZoomIndicator();

        // ===== END FRACTAL ZOOM SYSTEM =====

        // Event listeners
        depthSlider.addEventListener('input', (e) => {
            state.depth = parseInt(e.target.value);
            depthValue.textContent = state.depth;
            if (state.isObserving) {
                createRecursionLayers();
            }
            updateStats();

            // Initialize/update quantum system based on depth
            initQuantumSystem();
        }, { passive: true });

        startBtn.addEventListener('click', () => {
            if (state.isObserving) {
                stopObservation();
            } else {
                startObservation();
            }
        });

        resetBtn.addEventListener('click', () => {
            stopObservation();
            state.actions = [];
            state.predictions = [];
            state.divergenceScore = 0;
            state.correctPredictions = 0;
            state.totalPredictions = 0;
            velocityHistory = [];
            logEntries.innerHTML = '';
            updateStats();
            addLog('Session reset', 'normal');
        });

        function startObservation() {
            state.isObserving = true;
            // Initialize Shadow Self
            ShadowSelf.initialize();

            viewport.classList.add('recording');
            recordingIndicator.classList.add('active');
            startBtn.textContent = 'Stop Observation';
            startBtn.classList.remove('btn-primary');
            startBtn.classList.add('btn-secondary');

            createRecursionLayers();
            addLog('Observation started - I am watching you', 'prediction');

            // Initialize quantum system
            initQuantumSystem();

            // Initialize audio
            initAudio();
            startAmbientDrone();

            // Start periodic thoughts
            state.thoughtInterval = setInterval(() => {
                if (state.isObserving && Math.random() > 0.6) {
                    showThought(
                        Math.random() * (viewport.clientWidth - 200) + 100,
                        Math.random() * (viewport.clientHeight - 100) + 50,
                        generateThought()
                    );
                }
            }, 2000);

            // Start meta-commentary
            state.metaInterval = setInterval(() => {
                if (state.isObserving) {
                    showMetaCommentary();
                }
            }, 5000);

            // Update visual effects
            state.visualInterval = setInterval(() => {
                if (state.isObserving) {
                    updateGlitchEffects();
                    updateInfinityMirror();
                    generateBehavioralFingerprint();
                    updateAmbientFrequency();
                    updateWebcamDistortion();
                    detectEmotion();                    visualizeNeuralNetwork();

                }
            }, 1000);
        }

        function stopObservation() {
            state.isObserving = false;
            // Save shadow data
            ShadowSelf.saveShadowData();

            viewport.classList.remove('recording');
            recordingIndicator.classList.remove('active');
            startBtn.textContent = 'Begin Observation';
            startBtn.classList.add('btn-primary');
            startBtn.classList.remove('btn-secondary');

            // Stop audio
            stopAmbientDrone();

            // Clear intervals
            if (state.thoughtInterval) {
                clearInterval(state.thoughtInterval);
            }
            if (state.metaInterval) {
                clearInterval(state.metaInterval);
            }
            if (state.visualInterval) {
                clearInterval(state.visualInterval);
            }

            // Save session
            if (state.actions.length > 0) {
                state.sessionHistory.push({
                    timestamp: Date.now(),
                    actions: state.actions.length,
                    divergence: state.divergenceScore,
                    accuracy: state.totalPredictions > 0 ?
                        (state.correctPredictions / state.totalPredictions * 100) : 0,
                    metaObservationCount: state.metaObservations.length
                });
                saveData();
                addLog(`Session saved. Final divergence: ${state.divergenceScore.toFixed(1)}%`, 'normal');
            }

            // Clear layers
            state.layers.forEach(layer => layer.element.remove());
            state.layers = [];

            // Turn off effects
            glitchOverlay.classList.remove('active');
            chromaticEffect.classList.remove('active');
            infinityMirror.classList.remove('active');
        }

        // RequestAnimationFrame throttling for mousemove
        let rafId = null;
        let pendingMouseEvent = null;

        function handleMouseMove(e) {
            pendingMouseEvent = e;

            if (rafId === null) {
                rafId = requestAnimationFrame(() => {
                    if (!state.isObserving || !pendingMouseEvent) {
                        rafId = null;
                        return;
                    }

                    const e = pendingMouseEvent;
                    const rect = viewport.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;

                    // Calculate velocity
                    const now = Date.now();
                    const dt = now - lastMoveTime;
                    if (dt > 0) {
                        const dx = x - lastMousePos.x;
                        const dy = y - lastMousePos.y;
                        const velocity = Math.sqrt(dx * dx + dy * dy) / dt * 100;
                        velocityHistory.push(velocity);
                        if (velocityHistory.length > 50) velocityHistory.shift();

                        // Synaesthesia: Update speed color
                        updateSpeedColor(velocity);
                    }

                    // Record action
                    state.actions.push({
                        type: 'move',
                        x, y,
                        timestamp: now,
                        velocity: velocityHistory[velocityHistory.length - 1] || 0

                    // Check for philosophical dialogue triggers
                    const actionCount = state.actions.length;
                    if (philosophicalQuestions[actionCount] && !state.philosophicalProfile.answers[philosophicalQuestions[actionCount].id]) {
                        setTimeout(() => triggerPhilosophicalDialogue(actionCount), 1000);
                    }                    });

                    // Update prediction accuracy
                    if (state.layers.length > 0 && state.actions.length > 5) {
                        const avgLayerDivergence = state.layers.reduce((sum, l) => sum + l.divergence, 0) / state.layers.length;

                        state.totalPredictions++;
                        if (avgLayerDivergence < 50) {
                            state.correctPredictions++;
                        }

                        // Update overall divergence score
                        state.divergenceScore = state.divergenceScore * 0.95 + avgLayerDivergence * 0.05;
                        state.divergenceScore = Math.min(100, state.divergenceScore);

                        // Synaesthesia: Update divergence taste
                        updateDivergenceTaste(state.divergenceScore);
                    }

                    // Analyze movement patterns periodically
                    if (state.actions.length % 20 === 0) {
                        analyzeMovementStyle();
                        if (state.behaviorModel.movementStyle !== 'unknown') {
                            addLog(`Movement style detected: ${state.behaviorModel.movementStyle}`, 'prediction');
                        }

                        // Synaesthesia: Regenerate behavioral chord
                        generateBehavioralChord();
                    }
            // Train neural network periodically
            if (state.actions.length >= 11 && state.actions.length % 3 === 0) {
                if (!neuralNetwork) {
                    initNeuralNetwork();
                }
                trainNeuralNetwork();

                // Update neural stats
                if (neuralNetwork) {
                    document.getElementById('neuralConfidence').textContent =
                        neuralNetwork.confidence.toFixed(1) + '%';
                }
            }

            // Visualize network periodically
            if (state.actions.length % 20 === 0 && neuralNetwork) {
                visualizeNeuralNetwork();
            }


                    updateCursors(x, y);
                    lastMousePos = { x, y };
                    lastMoveTime = now;
                    // Update Shadow Self
                    if (state.shadow.enabled) {
                        ShadowSelf.update(x, y, now);
                    }


                    // Update visual effects
                    updateHeatMap();
                    drawPredictionTrails();

                    // Update stats less frequently
                    if (state.actions.length % 10 === 0) {
                        updateStats();
                        updateBiometrics();
                    }

                    rafId = null;
                });
            }
        }

        viewport.addEventListener('mousemove', handleMouseMove, { passive: true });

        viewport.addEventListener('click', (e) => {
            if (!state.isObserving) return;

            const rect = viewport.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Synaesthesia: Process click with intensity
            const intensity = Math.random() * 0.5 + 0.5; // Random intensity 0.5-1.0
            processSynaestheticClick(x, y, intensity);

            state.actions.push({
                type: 'click',
                x, y,
                timestamp: Date.now()
            });

                    // Check for philosophical dialogue triggers
                    const actionCount = state.actions.length;
                    if (philosophicalQuestions[actionCount] && !state.philosophicalProfile.answers[philosophicalQuestions[actionCount].id]) {
                        setTimeout(() => triggerPhilosophicalDialogue(actionCount), 1000);
                    }
            simulateClick(x, y);
            addLog(`Click registered at (${x.toFixed(0)}, ${y.toFixed(0)})`, 'normal');

            // Check if any layer predicted this click
            state.layers.forEach((layer, i) => {
                const dist = Math.sqrt(
                    Math.pow(layer.predictedPos.x - x, 2) +
                    Math.pow(layer.predictedPos.y - y, 2)
                );

                if (dist < 40) {
                    addLog(`Layer ${i + 1} predicted your click!`, 'match');
                } else if (dist > 100 && i > 2) {
                    addLog(`Layer ${i + 1} diverged significantly`, 'divergence');
                    state.divergenceScore += 2;
                }
            });

            updateStats();
        });

        // Sound toggle
        soundToggle.addEventListener('click', () => {
            soundEnabled = !soundEnabled;
            soundToggle.classList.toggle('muted');

            if (soundEnabled) {
                if (state.isObserving) {
                    initAudio();
                    startAmbientDrone();
                }
                addLog('Sound enabled', 'normal');
            } else {
                stopAmbientDrone();
                addLog('Sound muted', 'normal');
            }
        });

        // Synaesthesia Mode toggle
        synaesthesiaToggle.addEventListener('click', () => {
            toggleSynaesthesiaMode();
        });

                // Webcam toggle
        webcamToggle.addEventListener('click', () => {
            if (webcamEnabled) {
                disableWebcam();
            } else {
                enableWebcam();
            }
        });


        // ===== KEYBOARD SHORTCUTS =====
        let isFullscreen = false;

        function toggleFullscreen() {
            isFullscreen = !isFullscreen;
            viewport.classList.toggle('fullscreen', isFullscreen);
            addLog(`Fullscreen mode ${isFullscreen ? 'enabled' : 'disabled'}`, 'normal');
        }

        function toggleShortcutsOverlay() {
            const overlay = document.getElementById('shortcutsOverlay');
            const isActive = overlay.classList.contains('active');
            overlay.classList.toggle('active');

            if (!isActive) {
                // Focus the close button when opening
                const closeBtn = overlay.querySelector('.shortcuts-close');
                setTimeout(() => closeBtn.focus(), 100);
            }
        }

        function showShortcutsHint() {
            const hint = document.getElementById('shortcutsHint');
            hint.classList.add('visible');
            setTimeout(() => hint.classList.remove('visible'), 4000);
        }

        function adjustDepth(change) {
            const newDepth = Math.max(1, Math.min(12, state.depth + change));
            if (newDepth !== state.depth) {
                state.depth = newDepth;
                depthSlider.value = newDepth;
                depthValue.textContent = newDepth;
                if (state.isObserving) {
                    createRecursionLayers();
                }
                updateStats();
                addLog(`Depth ${change > 0 ? 'increased' : 'decreased'} to ${newDepth}`, 'normal');
            }
        }

        function setDepthToNumber(num) {
            if (num >= 1 && num <= 9) {
                state.depth = num;
                depthSlider.value = num;
                depthValue.textContent = num;
                if (state.isObserving) {
                    createRecursionLayers();
                }
                updateStats();
                addLog(`Depth set to ${num}`, 'normal');
            }
        }

        // Global keyboard event handler
        document.addEventListener('keydown', (e) => {
            // Don't handle shortcuts if typing in input fields
            if (e.target.tagName === 'INPUT' && e.target.type === 'file') {
                return;
            }

            // Check if shortcuts overlay is open
            const shortcutsOpen = document.getElementById('shortcutsOverlay').classList.contains('active');

            switch(e.key.toLowerCase()) {
                case ' ': // Space - Start/Stop
                    e.preventDefault();
                    if (!shortcutsOpen) {
                        if (state.isObserving) {
                            stopObservation();
                        } else {
                            startObservation();
                        }
                    }
                    break;

                case 'arrowup': // Up arrow - Increase depth
                    e.preventDefault();
                    if (!shortcutsOpen) {
                        adjustDepth(1);
                    }
                    break;

                case 'arrowdown': // Down arrow - Decrease depth
                    e.preventDefault();
                    if (!shortcutsOpen) {
                        adjustDepth(-1);
                    }
                    break;

                case 'm': // M - Toggle mute
                    e.preventDefault();
                    if (!shortcutsOpen) {
                        soundToggle.click();
                    }
                    break;

                case 'w': // W - Toggle webcam
                    e.preventDefault();
                    if (!shortcutsOpen) {
                        webcamToggle.click();
                    }
                    break;

                case 'r': // R - Reset
                    e.preventDefault();
                    if (!shortcutsOpen) {
                        resetBtn.click();
                    }
                    break;

                case 'f': // F - Toggle fullscreen
                    e.preventDefault();
                    if (!shortcutsOpen) {
                        toggleFullscreen();
                    }
                    break;

                case 'escape': // Escape - Stop observation or close overlay
                    e.preventDefault();
                    if (shortcutsOpen) {
                        toggleShortcutsOverlay();
                    } else if (state.isObserving) {
                        stopObservation();
                    }
                    break;

                case '?': // ? - Toggle shortcuts overlay
                case '/': // Also support / which produces ? when shifted
                    if (e.shiftKey && e.key === '/') {
                        e.preventDefault();
                        toggleShortcutsOverlay();
                    } else if (e.key === '?') {
                        e.preventDefault();
                        toggleShortcutsOverlay();
                    }
                    break;

                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                    if (!shortcutsOpen) {
                        e.preventDefault();
                        setDepthToNumber(parseInt(e.key));
                    }
                    break;
            }
        });

        // Make sound indicator keyboard accessible
        soundToggle.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                soundToggle.click();
            }
        });

        // Show shortcuts hint on first load
        setTimeout(() => {
            if (!localStorage.getItem(APP_NAME + '-shortcuts-hint-shown')) {
                showShortcutsHint();
                localStorage.setItem(APP_NAME + '-shortcuts-hint-shown', 'true');
            }
        }, 2000);


        // Neural prediction toggle
        const neuralToggle = document.getElementById('neuralToggle');
        const predictionModeEl = document.getElementById('predictionMode');
        const neuralConfidenceEl = document.getElementById('neuralConfidence');

        neuralToggle.addEventListener('change', (e) => {
            useNeuralPrediction = e.target.checked;
            predictionModeEl.textContent = useNeuralPrediction ? 'Neural' : 'Heuristic';
            predictionModeEl.className = 'stat-value ' + (useNeuralPrediction ? 'neural' : '');

            if (useNeuralPrediction && !neuralNetwork) {
                initNeuralNetwork();
            }

            addLog(`Switched to ${useNeuralPrediction ? 'neural' : 'heuristic'} prediction mode`, 'prediction');
        });


        // ===== REPLAY SYSTEM FUNCTIONS =====

        function saveCurrentReplay() {
            if (state.actions.length === 0) {
                alert('No session data to save. Record a session first!');
                return;
            }

            const replayName = prompt('Enter a name for this replay:', `Session ${new Date().toLocaleString()}`);
            if (!replayName) return;

            const replay = {
                id: Date.now(),
                name: replayName,
                timestamp: Date.now(),
                duration: state.actions.length > 0 ?
                    (state.actions[state.actions.length - 1].timestamp - state.actions[0].timestamp) : 0,
                actions: [...state.actions],
                depth: state.depth,
                divergenceScore: state.divergenceScore,
                accuracy: state.totalPredictions > 0 ?
                    (state.correctPredictions / state.totalPredictions * 100) : 0,
                behaviorModel: {...state.behaviorModel},
                emotionState: {...state.emotionState},
                metaObservations: [...state.metaObservations]
            };

            replayState.savedReplays.push(replay);
            localStorage.setItem(APP_NAME + '-replays', JSON.stringify(replayState.savedReplays));
            updateReplayList();
            addLog(`Replay saved: ${replayName}`, 'match');

            // Switch to replay tab to show the saved replay
            switchTab('replay');
        }

        function updateReplayList() {
            if (replayState.savedReplays.length === 0) {
                replayList.innerHTML = `
                    <div style="color: #666; font-size: 0.8em; text-align: center; padding: 20px;">
                        No saved replays yet.<br>Record a session first!
                    </div>
                `;
                return;
            }

            replayList.innerHTML = '';
            replayState.savedReplays.forEach(replay => {
                const item = document.createElement('div');
                item.className = 'replay-item';
                if (replayState.currentReplay && replayState.currentReplay.id === replay.id) {
                    item.classList.add('active');
                }

                const duration = (replay.duration / 1000).toFixed(1);
                item.innerHTML = `
                    <div class="replay-item-title">${replay.name}</div>
                    <div class="replay-item-stats">
                        ${replay.actions.length} actions | ${duration}s |
                        Divergence: ${replay.divergenceScore.toFixed(1)}% |
                        Accuracy: ${replay.accuracy.toFixed(1)}%
                    </div>
                `;

                item.addEventListener('click', () => loadReplay(replay));
                replayList.appendChild(item);
            });
        }

        function loadReplay(replay) {
            // Stop current observation if running
            if (state.isObserving) {
                stopObservation();
            }

            // Stop current replay if playing
            if (replayState.isPlaying) {
                stopReplay();
            }

            replayState.currentReplay = replay;
            replayState.currentTime = 0;

            // Set depth to match replay
            state.depth = replay.depth;
            depthSlider.value = replay.depth;
            depthValue.textContent = replay.depth;

            // Create layers for replay
            createRecursionLayers();

            // Show replay timeline
            replayTimeline.classList.add('active');
            replayModeBadge.classList.add('active');
            replayGhostCursor.classList.add('active');

            // Update timeline markers
            updateTimelineMarkers();
            updateReplayList();

            // Enable play button
            replayPlayBtn.disabled = false;
            replayPauseBtn.disabled = true;
            replayRewindBtn.disabled = false;

            addLog(`Loaded replay: ${replay.name}`, 'match');
        }

        function updateTimelineMarkers() {
            if (!replayState.currentReplay) return;

            const actions = replayState.currentReplay.actions;
            if (actions.length === 0) return;

            const duration = actions[actions.length - 1].timestamp - actions[0].timestamp;
            timelineEvents.innerHTML = '';

            actions.forEach(action => {
                if (action.type === 'click') {
                    const marker = document.createElement('div');
                    marker.className = 'timeline-event click';
                    const relativeTime = (action.timestamp - actions[0].timestamp) / duration;
                    marker.style.left = (relativeTime * 100) + '%';
                    timelineEvents.appendChild(marker);
                }
            });
        }

        function playReplay() {
            if (!replayState.currentReplay) return;

            replayState.isPlaying = true;
            replayState.isPaused = false;
            replayPlayBtn.disabled = true;
            replayPauseBtn.disabled = false;
            replayModeBadge.textContent = `REPLAY MODE (${replayState.playbackSpeed}x)`;

            const actions = replayState.currentReplay.actions;
            if (actions.length === 0) return;

            const startTime = actions[0].timestamp;
            const startPlaybackTime = performance.now();
            const resumeFrom = replayState.currentTime;

            function animate() {
                if (!replayState.isPlaying) return;

                const elapsed = (performance.now() - startPlaybackTime) * replayState.playbackSpeed;
                const currentReplayTime = resumeFrom + elapsed;

                // Find current action
                const currentAction = actions.find(a =>
                    (a.timestamp - startTime) >= currentReplayTime &&
                    (a.timestamp - startTime) < currentReplayTime + 50
                );

                // Update ghost cursor position
                if (currentAction) {
                    replayGhostCursor.style.left = currentAction.x + 'px';
                    replayGhostCursor.style.top = currentAction.y + 'px';

                    // Update predictions for all layers
                    state.layers.forEach((layer, i) => {
                        const predicted = predictReplayPosition(currentAction, i);
                        const relX = (predicted.x - layer.offset.x) / layer.scale;
                        const relY = (predicted.y - layer.offset.y) / layer.scale;
                        layer.cursor.style.transform = `translate(${relX}px, ${relY}px)`;

                        // Calculate divergence
                        const dx = predicted.x - currentAction.x;
                        const dy = predicted.y - currentAction.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        layer.divergence = distance;

                        if (distance > 100) {
                            layer.element.classList.add('diverged');
                            layer.element.classList.remove('converged');
                        } else if (distance < 30) {
                            layer.element.classList.add('converged');
                            layer.element.classList.remove('diverged');
                        }
                    });

                    // Show click effect
                    if (currentAction.type === 'click') {
                        simulateReplayClick(currentAction.x, currentAction.y);
                    }
                }

                // Update progress bar
                const duration = actions[actions.length - 1].timestamp - startTime;
                const progress = Math.min((currentReplayTime / duration) * 100, 100);
                timelineProgress.style.width = progress + '%';
                timelinePlayhead.style.left = progress + '%';

                // Update time display
                const currentSec = Math.floor(currentReplayTime / 1000);
                const totalSec = Math.floor(duration / 1000);
                timeDisplay.textContent = `${formatTime(currentSec)} / ${formatTime(totalSec)}`;

                replayState.currentTime = currentReplayTime;

                // Check if replay finished
                if (currentReplayTime >= duration) {
                    stopReplay();
                    replayState.currentTime = 0;
                    return;
                }

                replayState.animationFrame = requestAnimationFrame(animate);
            }

            animate();
        }

        function pauseReplay() {
            replayState.isPlaying = false;
            replayState.isPaused = true;
            replayPlayBtn.disabled = false;
            replayPauseBtn.disabled = true;
            if (replayState.animationFrame) {
                cancelAnimationFrame(replayState.animationFrame);
            }
        }

        function stopReplay() {
            replayState.isPlaying = false;
            replayState.isPaused = false;
            replayState.currentTime = 0;

            if (replayState.animationFrame) {
                cancelAnimationFrame(replayState.animationFrame);
            }

            timelineProgress.style.width = '0%';
            timelinePlayhead.style.left = '0%';
            replayPlayBtn.disabled = false;
            replayPauseBtn.disabled = true;
        }

        function rewindReplay() {
            stopReplay();
            replayState.currentTime = 0;
            timeDisplay.textContent = '0:00 / 0:00';
        }

        function setPlaybackSpeed(speed) {
            replayState.playbackSpeed = speed;
            document.querySelectorAll('.speed-button').forEach(btn => {
                btn.classList.toggle('active', parseFloat(btn.dataset.speed) === speed);
            });
            if (replayState.isPlaying) {
                replayModeBadge.textContent = `REPLAY MODE (${speed}x)`;
            }
        }

        function predictReplayPosition(action, layerIndex) {
            // Similar to predictNextPosition but for replay
            const errorFactor = Math.pow(1.15, layerIndex + 1);
            const chaos = replayState.currentReplay.divergenceScore / 100;

            let predictedX = action.x + (Math.random() - 0.5) * 10 * errorFactor;
            let predictedY = action.y + (Math.random() - 0.5) * 10 * errorFactor;

            const divergenceNoise = layerIndex * 5 * (1 + chaos);
            predictedX += (Math.random() - 0.5) * divergenceNoise;
            predictedY += (Math.random() - 0.5) * divergenceNoise;

            return { x: predictedX, y: predictedY };
        }

        function simulateReplayClick(x, y) {
            state.layers.forEach((layer, i) => {
                setTimeout(() => {
                    const click = document.createElement('div');
                    click.className = 'ghost-click';
                    click.style.color = depthColors[i % depthColors.length];

                    const errorFactor = Math.pow(1.2, i + 1);
                    const clickX = (x - layer.offset.x) / layer.scale + (Math.random() - 0.5) * 20 * errorFactor;
                    const clickY = (y - layer.offset.y) / layer.scale + (Math.random() - 0.5) * 20 * errorFactor;

                    click.style.left = (clickX - 20) + 'px';
                    click.style.top = (clickY - 20) + 'px';
                    layer.element.appendChild(click);
                    playClickSound(i);
                    setTimeout(() => click.remove(), 600);
                }, (i + 1) * 100);
            });
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function importReplay(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);

                    // Check if it's a replay or a full session export
                    if (data.actions && Array.isArray(data.actions)) {
                        const replay = {
                            id: Date.now(),
                            name: data.name || `Imported ${new Date().toLocaleString()}`,
                            timestamp: Date.now(),
                            duration: data.duration || 0,
                            actions: data.actions,
                            depth: data.depth || 5,
                            divergenceScore: data.divergenceScore || 0,
                            accuracy: data.accuracy || 0,
                            behaviorModel: data.behaviorModel || {},
                            metaObservations: data.metaObservations || []
                        };

                        replayState.savedReplays.push(replay);
                        localStorage.setItem(APP_NAME + '-replays', JSON.stringify(replayState.savedReplays));
                        updateReplayList();
                        addLog(`Imported replay: ${replay.name}`, 'match');
                        switchTab('replay');
                    } else if (data.currentSession && data.currentSession.actions) {
                        // Import from full session export
                        const session = data.currentSession;
                        const replay = {
                            id: Date.now(),
                            name: `Imported ${new Date().toLocaleString()}`,
                            timestamp: Date.now(),
                            duration: session.actions.length > 0 ?
                                (session.actions[session.actions.length - 1].timestamp - session.actions[0].timestamp) : 0,
                            actions: session.actions,
                            depth: data.behaviorModel?.depth || 5,
                            divergenceScore: session.divergenceScore || 0,
                            accuracy: 0,
                            behaviorModel: data.behaviorModel || {},
                            metaObservations: session.metaObservations || []
                        };

                        replayState.savedReplays.push(replay);
                        localStorage.setItem(APP_NAME + '-replays', JSON.stringify(replayState.savedReplays));
                        updateReplayList();
                        addLog('Imported replay from session export', 'match');
                        switchTab('replay');
                    } else {
                        alert('Invalid replay file format');
                    }
                } catch (error) {
                    alert('Error importing replay: ' + error.message);
                }
            };
            reader.readAsText(file);
        }

        function switchTab(tabName) {
            tabButtons.forEach(btn => {
                const isActive = btn.dataset.tab === tabName;
                btn.classList.toggle('active', isActive);
            });

            observeTab.classList.toggle('active', tabName === 'observe');
            replayTab.classList.toggle('active', tabName === 'replay');

            if (tabName === 'observe') {
                replayTimeline.classList.remove('active');
                replayModeBadge.classList.remove('active');
                replayGhostCursor.classList.remove('active');
                comparisonCursor.classList.remove('active');
                if (replayState.isPlaying) {
                    stopReplay();
                }
            } else {
                updateReplayList();
            }
        }

        // Timeline scrubbing
        timelineScrubber.addEventListener('click', (e) => {
            if (!replayState.currentReplay) return;

            const rect = timelineScrubber.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const percent = x / rect.width;

            const actions = replayState.currentReplay.actions;
            const duration = actions[actions.length - 1].timestamp - actions[0].timestamp;
            replayState.currentTime = percent * duration;

            timelineProgress.style.width = (percent * 100) + '%';
            timelinePlayhead.style.left = (percent * 100) + '%';

            const currentSec = Math.floor(replayState.currentTime / 1000);
            const totalSec = Math.floor(duration / 1000);
            timeDisplay.textContent = `${formatTime(currentSec)} / ${formatTime(totalSec)}`;
        });

        // Tab switching
        tabButtons.forEach(btn => {
            btn.addEventListener('click', () => switchTab(btn.dataset.tab));
        });

        // Replay control event listeners
        replayPlayBtn.addEventListener('click', playReplay);
        replayPauseBtn.addEventListener('click', pauseReplay);
        replayRewindBtn.addEventListener('click', rewindReplay);

        // Speed control buttons
        document.querySelectorAll('.speed-button').forEach(btn => {
            btn.addEventListener('click', () => {
                setPlaybackSpeed(parseFloat(btn.dataset.speed));
            });
        });

        // Comparison mode toggle
        comparisonModeToggle.addEventListener('change', (e) => {
            replayState.comparisonMode = e.target.checked;
            if (replayState.comparisonMode) {
                comparisonCursor.classList.add('active');
                addLog('Comparison mode enabled - your movements shown in green', 'match');
            } else {
                comparisonCursor.classList.remove('active');
            }
        });

        // Update comparison cursor during live observation if comparison mode is on
        const originalMouseMove = viewport.onmousemove;
        viewport.addEventListener('mousemove', (e) => {
            if (replayState.comparisonMode && replayState.isPlaying) {
                const rect = viewport.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                comparisonCursor.style.left = x + 'px';
                comparisonCursor.style.top = y + 'px';
            }
        });

        // Initialize
        updateStats();
        generateBehavioralFingerprint();
        addLog('Recursive Self-Portrait initialized', 'normal');
        addLog('The system will learn your patterns and simulate you simulating yourself...', 'prediction');
        addLog('Neural network available - toggle to enable real-time learning', 'prediction');

        if (state.sessionHistory.length > 0) {
            const lastSession = state.sessionHistory[state.sessionHistory.length - 1];
            addLog(`Previous session: ${lastSession.actions} actions, ${lastSession.divergence.toFixed(1)}% divergence`, 'normal');
        }

        // Start with sound muted (user must click to activate - better UX)
        soundToggle.classList.add('muted');


        // ===== MULTIPLAYER FUNCTIONALITY =====
        let peerConnection = null;
        let dataChannel = null;
        let isHost = false;
        let roomCode = '';
        let peerState = {
            divergenceScore: 0,
            actions: [],
            layers: [],
            behaviorModel: {},
            cursorPos: { x: 0, y: 0 }
        };
        let predictMode = false;
        let predictScore = 0;

        const multiplayerPanel = document.getElementById('multiplayerPanel');
        const connectionDot = document.getElementById('connectionDot');
        const connectionText = document.getElementById('connectionText');
        const roomCodeInput = document.getElementById('roomCodeInput');
        const joinRoomBtn = document.getElementById('joinRoomBtn');
        const createRoomBtn = document.getElementById('createRoomBtn');
        const roomCodeDisplay = document.getElementById('roomCodeDisplay');
        const roomCodeSpan = document.getElementById('roomCode');
        const comparativeStats = document.getElementById('comparativeStats');
        const myDivergence = document.getElementById('myDivergence');
        const peerDivergence = document.getElementById('peerDivergence');
        const predictModePanel = document.getElementById('predictModePanel');
        const predictModeBtn = document.getElementById('predictModeBtn');
        const predictScoreEl = document.getElementById('predictScore');
        const peerCursor = document.getElementById('peerCursor');
        const peerLayersContainer = document.getElementById('peerLayersContainer');

        function generateRoomCode() {
            const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
            let code = '';
            for (let i = 0; i < 6; i++) {
                code += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return code;
        }

        function updateConnectionStatus(status, text) {
            connectionDot.className = 'status-dot';
            if (status === 'connected') {
                connectionDot.classList.add('connected');
            } else if (status === 'connecting') {
                connectionDot.classList.add('connecting');
            }
            connectionText.textContent = text;
        }

        async function createRoom() {
            roomCode = generateRoomCode();
            isHost = true;

            roomCodeSpan.textContent = roomCode;
            roomCodeDisplay.style.display = 'block';
            createRoomBtn.disabled = true;
            joinRoomBtn.disabled = true;
            roomCodeInput.disabled = true;

            updateConnectionStatus('connecting', 'Waiting for peer...');
            addLog('Room created: ' + roomCode, 'normal');

            // Setup WebRTC as host
            await setupWebRTC(true);
        }

        async function joinRoom() {
            const code = roomCodeInput.value.trim().toUpperCase();
            if (!code) {
                alert('Please enter a room code');
                return;
            }

            roomCode = code;
            isHost = false;

            roomCodeSpan.textContent = roomCode;
            roomCodeDisplay.style.display = 'block';
            createRoomBtn.disabled = true;
            joinRoomBtn.disabled = true;
            roomCodeInput.disabled = true;

            updateConnectionStatus('connecting', 'Connecting to peer...');
            addLog('Joining room: ' + roomCode, 'normal');

            // Setup WebRTC as joiner
            await setupWebRTC(false);
        }

        async function setupWebRTC(isInitiator) {
            // Create RTCPeerConnection
            const config = {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' }
                ]
            };

            peerConnection = new RTCPeerConnection(config);

            // Handle ICE candidates
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    // In a real app, send this to signaling server
                    // For this demo, we'll use manual exchange via prompt
                    console.log('ICE Candidate:', JSON.stringify(event.candidate));
                }
            };

            peerConnection.onconnectionstatechange = () => {
                console.log('Connection state:', peerConnection.connectionState);
                if (peerConnection.connectionState === 'connected') {
                    onPeerConnected();
                } else if (peerConnection.connectionState === 'disconnected' ||
                           peerConnection.connectionState === 'failed') {
                    onPeerDisconnected();
                }
            };

            if (isInitiator) {
                // Host creates data channel
                dataChannel = peerConnection.createDataChannel('recursion');
                setupDataChannel();

                // Create offer
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);

                // Show offer for manual exchange
                const offerStr = JSON.stringify(peerConnection.localDescription);
                addLog('Copy this offer and send to peer', 'prediction');

                // Simulate exchange - in real app this would go through signaling server
                const answerPrompt = 'Paste peer answer (from other browser):';
                setTimeout(() => {
                    const answerStr = prompt(offerStr + '

' + answerPrompt);
                    if (answerStr) {
                        try {
                            const answer = JSON.parse(answerStr);
                            peerConnection.setRemoteDescription(answer);
                        } catch (e) {
                            addLog('Invalid answer format', 'divergence');
                        }
                    }
                }, 1000);

            } else {
                // Joiner waits for offer
                peerConnection.ondatachannel = (event) => {
                    dataChannel = event.channel;
                    setupDataChannel();
                };

                // Get offer from host
                setTimeout(async () => {
                    const offerStr = prompt('Paste the offer from host:');
                    if (offerStr) {
                        try {
                            const offer = JSON.parse(offerStr);
                            await peerConnection.setRemoteDescription(offer);

                            // Create answer
                            const answer = await peerConnection.createAnswer();
                            await peerConnection.setLocalDescription(answer);

                            // Show answer for manual exchange
                            const answerStr = JSON.stringify(peerConnection.localDescription);
                            alert('Send this answer to host:

' + answerStr);
                            addLog('Answer sent - waiting for connection', 'prediction');
                        } catch (e) {
                            addLog('Invalid offer format', 'divergence');
                        }
                    }
                }, 500);
            }
        }

        function setupDataChannel() {
            dataChannel.onopen = () => {
                console.log('Data channel opened');
            };

            dataChannel.onclose = () => {
                console.log('Data channel closed');
                onPeerDisconnected();
            };

            dataChannel.onmessage = (event) => {
                const data = JSON.parse(event.data);
                handlePeerData(data);
            };
        }

        function onPeerConnected() {
            updateConnectionStatus('connected', 'Connected to peer');
            comparativeStats.style.display = 'grid';
            predictModePanel.style.display = 'block';
            peerCursor.style.display = 'block';
            addLog('Peer connected - now watching each other!', 'match');
        }

        function onPeerDisconnected() {
            updateConnectionStatus('disconnected', 'Peer disconnected');
            comparativeStats.style.display = 'none';
            predictModePanel.style.display = 'none';
            peerCursor.style.display = 'none';
            peerLayersContainer.innerHTML = '';
            addLog('Peer disconnected', 'divergence');
        }

        function sendToPeer(data) {
            if (dataChannel && dataChannel.readyState === 'open') {
                dataChannel.send(JSON.stringify(data));
            }
        }

        function handlePeerData(data) {
            if (data.type === 'cursor') {
                // Update peer cursor position
                peerCursor.style.left = data.x + 'px';
                peerCursor.style.top = data.y + 'px';
                peerState.cursorPos = { x: data.x, y: data.y };

                // Update peer layers
                updatePeerLayers(data.x, data.y);

                // Check predict mode
                if (predictMode && state.isObserving) {
                    checkPrediction(data.x, data.y);
                }
            } else if (data.type === 'stats') {
                // Update peer stats
                peerState.divergenceScore = data.divergenceScore;
                peerState.behaviorModel = data.behaviorModel;
                peerDivergence.textContent = data.divergenceScore.toFixed(1) + '%';
                myDivergence.textContent = state.divergenceScore.toFixed(1) + '%';

                // Generate comparative meta-commentary
                if (Math.random() > 0.95) {
                    showComparativeMetaCommentary();
                }
            } else if (data.type === 'action') {
                peerState.actions.push(data.action);
            }
        }

        function updatePeerLayers(x, y) {
            // Clear existing peer layers
            peerLayersContainer.innerHTML = '';

            if (!state.isObserving) return;

            const viewportRect = viewport.getBoundingClientRect();
            const padding = 40;

            // Create peer's recursion layers (mirrored)
            for (let i = 0; i < state.depth; i++) {
                const scale = Math.pow(0.7, i + 1);
                const width = (viewportRect.width - padding * 2) * scale;
                const height = (viewportRect.height - padding * 2) * scale;

                const offsetX = (viewportRect.width - width) / 2 + (i * 5);
                const offsetY = (viewportRect.height - height) / 2 + (i * 5);

                const layer = document.createElement('div');
                layer.className = 'peer-recursion-layer';
                layer.setAttribute('data-depth', `Peer L${i + 1}`);
                layer.style.cssText = `
                    width: ${width}px;
                    height: ${height}px;
                    left: ${offsetX}px;
                    top: ${offsetY}px;
                    z-index: ${state.depth - i - 10};
                    opacity: 0.6;
                `;

                // Add peer ghost cursor to this layer
                const cursor = document.createElement('div');
                cursor.className = 'ghost-cursor peer-ghost-cursor';
                cursor.style.opacity = 0.8 - (i * 0.1);

                // Calculate position within this layer with slight divergence
                const errorFactor = Math.pow(1.15, i + 1);
                const relX = (x - offsetX) / scale + (Math.random() - 0.5) * 10 * errorFactor;
                const relY = (y - offsetY) / scale + (Math.random() - 0.5) * 10 * errorFactor;

                cursor.style.left = relX + 'px';
                cursor.style.top = relY + 'px';

                layer.appendChild(cursor);
                peerLayersContainer.appendChild(layer);

                // Apply quantum entanglement at depth 8+
                if (state.quantum.enabled && i >= 8 && state.layers[i] && state.layers[i].cursor) {
                    applyQuantumEntanglement(cursor, state.layers[i].cursor, i);
                }
            }
        }

        function showComparativeMetaCommentary() {
            const myDiv = state.divergenceScore;
            const peerDiv = peerState.divergenceScore;
            const diff = Math.abs(myDiv - peerDiv);

            let comment = '';
            if (diff < 10) {
                comment = 'You and your peer are eerily similar...';
            } else if (myDiv > peerDiv) {
                comment = 'You are more unpredictable than them.';
            } else {
                comment = 'They are more chaotic than you.';
            }

            if (state.behaviorModel.movementStyle === peerState.behaviorModel.movementStyle) {
                comment = 'You both move in the same way. Convergence detected.';
            }

            const meta = document.createElement('div');
            meta.className = 'meta-comment dual';
            meta.textContent = comment;

            const maxX = viewport.clientWidth - 320;
            const maxY = viewport.clientHeight - 100;
            meta.style.left = (Math.random() * maxX + 20) + 'px';
            meta.style.top = (Math.random() * maxY + 50) + 'px';

            viewport.appendChild(meta);
            setTimeout(() => meta.remove(), 8000);

            addLog(`Comparative: ${comment}`, 'prediction');
        }

        function checkPrediction(actualX, actualY) {
            // Check if you predicted where peer would move
            const distance = Math.sqrt(
                Math.pow(lastMousePos.x - actualX, 2) +
                Math.pow(lastMousePos.y - actualY, 2)
            );

            if (distance < 50) {
                predictScore += 10;
                addLog('Prediction match! +10', 'match');
            } else if (distance > 200) {
                predictScore = Math.max(0, predictScore - 5);
            }

            predictScoreEl.textContent = predictScore + ' pts';
        }



        // Event listeners
        createRoomBtn.addEventListener('click', createRoom);
        joinRoomBtn.addEventListener('click', joinRoom);

        roomCodeDisplay.addEventListener('click', () => {
            navigator.clipboard.writeText(roomCode);
            addLog('Room code copied to clipboard', 'match');
        });

        predictModeBtn.addEventListener('click', () => {
            predictMode = !predictMode;
            predictModePanel.classList.toggle('active', predictMode);
            predictModeBtn.textContent = predictMode ?
                'Stop Predict Mode' : 'Start "Predict Each Other" Mode';
            predictScore = 0;
            predictScoreEl.textContent = predictMode ? '0 pts' : '';
            addLog(predictMode ? 'Predict mode activated' : 'Predict mode deactivated', 'prediction');
        });

        // Modify existing mouse move handler to send position to peer
        const originalMouseMoveHandler = viewport.onmousemove;
        viewport.addEventListener('mousemove', (e) => {
            if (dataChannel && dataChannel.readyState === 'open') {
                const rect = viewport.getBoundingClientRect();
                sendToPeer({
                    type: 'cursor',
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top,
                    shadowPosition: state.shadow.position
                });
            }
        });

        // Send stats periodically
        setInterval(() => {
            if (dataChannel && dataChannel.readyState === 'open' && state.isObserving) {
                sendToPeer({
                    type: 'stats',
                    divergenceScore: state.divergenceScore,
                    behaviorModel: state.behaviorModel,
                    actionsCount: state.actions.length,
                    shadowProfile: ShadowSelf.getShadowProfile()
                });
            }
        }, 1000);

        soundEnabled = false;

        // ===== CROSS-SESSION EVOLUTION FUNCTIONS =====

        function calculateBehavioralEntropy() {
            if (state.actions.length < 10) return 0;

            // Calculate entropy based on movement predictability
            const velocities = [];
            for (let i = 1; i < state.actions.length; i++) {
                const prev = state.actions[i - 1];
                const curr = state.actions[i];
                if (prev.type === 'move' && curr.type === 'move') {
                    const dx = curr.x - prev.x;
                    const dy = curr.y - prev.y;
                    velocities.push(Math.sqrt(dx * dx + dy * dy));
                }
            }

            if (velocities.length === 0) return 0;

            // Calculate variance as a measure of entropy
            const mean = velocities.reduce((a, b) => a + b, 0) / velocities.length;
            const variance = velocities.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / velocities.length;

            // Normalize to 0-100 scale
            return Math.min(100, Math.sqrt(variance));
        }

        function generateBehavioralSignature() {
            return {
                movementStyle: state.behaviorModel.movementStyle,
                avgSpeed: state.behaviorModel.avgSpeed,
                clickFrequency: state.actions.filter(a => a.type === 'click').length / Math.max(1, state.actions.length),
                entropy: calculateBehavioralEntropy(),
                divergenceScore: state.divergenceScore,
                accuracy: state.totalPredictions > 0 ? (state.correctPredictions / state.totalPredictions) * 100 : 0
            };
        }

        function compareSignatures(sig1, sig2) {
            if (!sig1 || !sig2) return 100;

            let diff = 0;
            diff += Math.abs(sig1.avgSpeed - sig2.avgSpeed) / 10;
            diff += Math.abs(sig1.clickFrequency - sig2.clickFrequency) * 100;
            diff += Math.abs(sig1.entropy - sig2.entropy);
            diff += Math.abs(sig1.divergenceScore - sig2.divergenceScore);
            diff += Math.abs(sig1.accuracy - sig2.accuracy) / 2;

            if (sig1.movementStyle !== sig2.movementStyle) {
                diff += 20;
            }

            return Math.max(0, 100 - diff);
        }

        function saveCurrentSession() {
            if (state.actions.length < 5) return; // Don't save very short sessions

            const sessionData = {
                timestamp: evolutionState.currentSessionStart,
                endTime: Date.now(),
                duration: Date.now() - evolutionState.currentSessionStart,
                signature: generateBehavioralSignature(),
                actions: state.actions.slice(0, 500), // Limit to save space
                behaviorModel: JSON.parse(JSON.stringify(state.behaviorModel)),
                divergenceScore: state.divergenceScore,
                depth: state.depth,
                metaObservations: state.metaObservations,
                    emotionState: state.emotionState.slice()
            };

            evolutionState.allSessions.push(sessionData);

            // Keep only last 50 sessions to save space
            if (evolutionState.allSessions.length > 50) {
                evolutionState.allSessions = evolutionState.allSessions.slice(-50);
            }

            // Update entropy trend
            evolutionState.entropyTrend.push({
                timestamp: sessionData.timestamp,
                entropy: sessionData.signature.entropy
            });

            // Calculate consistency score
            if (evolutionState.allSessions.length > 1) {
                const recent = evolutionState.allSessions.slice(-5);
                let totalSimilarity = 0;
                let comparisons = 0;

                for (let i = 0; i < recent.length - 1; i++) {
                    for (let j = i + 1; j < recent.length; j++) {
                        totalSimilarity += compareSignatures(recent[i].signature, recent[j].signature);
                        comparisons++;
                    }
                }

                evolutionState.consistencyScore = comparisons > 0 ? totalSimilarity / comparisons : 100;
            }

            // Save to localStorage
            evolutionState.totalVisits++;
            evolutionState.lastVisit = Date.now();

            localStorage.setItem(APP_NAME + '-evolution', JSON.stringify({
                allSessions: evolutionState.allSessions,
                lastVisit: evolutionState.lastVisit,
                totalVisits: evolutionState.totalVisits,
                entropyTrend: evolutionState.entropyTrend
            }));

            updateEvolutionUI();
        }

        function showWelcomeMessage() {
            const welcomeDiv = document.getElementById('welcomeMessage');
            if (!welcomeDiv) return;

            if (evolutionState.lastVisit && evolutionState.allSessions.length > 0) {
                const timeSinceLastVisit = Date.now() - evolutionState.lastVisit;
                const days = Math.floor(timeSinceLastVisit / (1000 * 60 * 60 * 24));
                const hours = Math.floor(timeSinceLastVisit / (1000 * 60 * 60));

                let timeString = '';
                if (days > 0) {
                    timeString = `${days} day${days > 1 ? 's' : ''}`;
                } else if (hours > 0) {
                    timeString = `${hours} hour${hours > 1 ? 's' : ''}`;
                } else {
                    timeString = 'a few minutes';
                }

                const lastSession = evolutionState.allSessions[evolutionState.allSessions.length - 1];
                const currentSignature = generateBehavioralSignature();
                const similarity = compareSignatures(lastSession.signature, currentSignature);

                let message = '';
                if (similarity > 80) {
                    message = `You're remarkably consistent. Nearly identical to ${timeString} ago.`;
                } else if (similarity > 60) {
                    message = `Some variations detected. You've evolved slightly since ${timeString} ago.`;
                } else if (similarity > 40) {
                    message = `You've become noticeably different since ${timeString} ago. Interesting...`;
                } else {
                    message = `You've become significantly more ${currentSignature.entropy > lastSession.signature.entropy ? 'erratic' : 'controlled'} since ${timeString} ago.`;
                }

                welcomeDiv.innerHTML = `
                    <div class="welcome-message">
                        <div class="title">Welcome back. I remember you.</div>
                        <div class="subtitle">
                            Last visit: ${timeString} ago<br>
                            ${message}
                        </div>
                    </div>
                `;
            } else {
                welcomeDiv.innerHTML = `
                    <div class="welcome-message">
                        <div class="title">First observation initiated.</div>
                        <div class="subtitle">
                            I will remember you.<br>
                            Return and see how you've changed.
                        </div>
                    </div>
                `;
            }
        }

        function updateEvolutionUI() {
            // Update consistency score
            const consistencyFill = document.getElementById('consistencyFill');
            const consistencyScore = document.getElementById('consistencyScore');
            if (consistencyFill && consistencyScore) {
                const score = Math.round(evolutionState.consistencyScore);
                consistencyFill.style.width = score + '%';
                consistencyScore.textContent = score + '%';
                consistencyScore.className = 'stat-value' + (score > 70 ? ' converged' : score < 40 ? ' diverged' : '');
            }

            // Update total visits
            const totalVisitsEl = document.getElementById('totalVisits');
            if (totalVisitsEl) {
                totalVisitsEl.textContent = evolutionState.totalVisits;
            }

            // Update entropy
            const entropyValueEl = document.getElementById('entropyValue');
            if (entropyValueEl && state.actions.length > 10) {
                const entropy = Math.round(calculateBehavioralEntropy());
                entropyValueEl.textContent = entropy;
                entropyValueEl.className = 'stat-value' + (entropy > 60 ? ' diverged' : entropy < 30 ? ' converged' : '');
            }

            // Update entropy graph
            updateEntropyGraph();

            // Update timeline
            updateEvolutionTimeline();
        }

        function updateEntropyGraph() {
            const svg = document.getElementById('entropyGraph');
            if (!svg || evolutionState.entropyTrend.length < 2) return;

            const width = svg.clientWidth;
            const height = svg.clientHeight;
            const padding = 5;

            const data = evolutionState.entropyTrend.slice(-20); // Last 20 data points
            const maxEntropy = Math.max(...data.map(d => d.entropy), 1);

            // Create path for line
            let pathD = '';
            let areaD = '';

            data.forEach((point, i) => {
                const x = padding + (i / (data.length - 1)) * (width - 2 * padding);
                const y = height - padding - (point.entropy / maxEntropy) * (height - 2 * padding);

                if (i === 0) {
                    pathD = `M ${x} ${y}`;
                    areaD = `M ${x} ${height - padding} L ${x} ${y}`;
                } else {
                    pathD += ` L ${x} ${y}`;
                    areaD += ` L ${x} ${y}`;
                }
            });

            areaD += ` L ${width - padding} ${height - padding} Z`;

            svg.innerHTML = `
                <path class="entropy-area" d="${areaD}"/>
                <path class="entropy-line" d="${pathD}"/>
            `;
        }

        function updateEvolutionTimeline() {
            const timeline = document.getElementById('evolutionTimeline');
            if (!timeline || evolutionState.allSessions.length === 0) return;

            timeline.innerHTML = '';

            const sessions = evolutionState.allSessions.slice(-10); // Last 10 sessions
            if (sessions.length === 0) return;

            const timelineWidth = timeline.clientWidth;
            const minTime = sessions[0].timestamp;
            const maxTime = sessions[sessions.length - 1].timestamp;
            const timeRange = maxTime - minTime || 1;

            sessions.forEach((session, i) => {
                const pos = ((session.timestamp - minTime) / timeRange) * 100;
                const width = Math.max(2, 100 / sessions.length - 1);

                const bar = document.createElement('div');
                bar.className = 'timeline-session';
                bar.style.left = pos + '%';
                bar.style.width = width + '%';
                bar.dataset.sessionIndex = i;

                const date = new Date(session.timestamp);
                const label = document.createElement('div');
                label.className = 'timeline-label';
                label.textContent = date.toLocaleDateString();
                bar.appendChild(label);

                bar.onclick = () => selectSessionForGhost(i);
                timeline.appendChild(bar);
            });
        }

        function selectSessionForGhost(index) {
            const sessions = evolutionState.allSessions.slice(-10);
            if (index >= 0 && index < sessions.length) {
                evolutionState.ghostSession = sessions[index];
                evolutionState.showGhost = true;

                // Update UI
                document.querySelectorAll('.timeline-session').forEach((el, i) => {
                    el.classList.toggle('selected', i === index);
                });

                addLog(`Ghost of past self loaded from ${new Date(evolutionState.ghostSession.timestamp).toLocaleDateString()}`, 'match');
            }
        }

        function toggleGhostOverlay() {
            if (!evolutionState.ghostSession && evolutionState.allSessions.length > 0) {
                // Select most recent past session
                evolutionState.ghostSession = evolutionState.allSessions[evolutionState.allSessions.length - 1];
            }

            evolutionState.showGhost = !evolutionState.showGhost;

            if (evolutionState.showGhost && evolutionState.ghostSession) {
                addLog(' Ghost of past you is now visible', 'match');
                startGhostPlayback();
            } else {
                addLog('Ghost overlay disabled', 'prediction');
                stopGhostPlayback();
            }
        }

        let ghostPlaybackIndex = 0;
        let ghostPlaybackInterval = null;
        let ghostCursorElement = null;

        function startGhostPlayback() {
            if (!evolutionState.ghostSession || !evolutionState.ghostSession.actions) return;

            // Create ghost cursor if it doesn't exist
            if (!ghostCursorElement) {
                ghostCursorElement = document.createElement('div');
                ghostCursorElement.className = 'ghost-overlay-cursor';
                viewport.appendChild(ghostCursorElement);
            }

            ghostPlaybackIndex = 0;
            clearInterval(ghostPlaybackInterval);

            ghostPlaybackInterval = setInterval(() => {
                if (!evolutionState.showGhost || ghostPlaybackIndex >= evolutionState.ghostSession.actions.length) {
                    ghostPlaybackIndex = 0; // Loop
                }

                const action = evolutionState.ghostSession.actions[ghostPlaybackIndex];
                if (action && action.type === 'move') {
                    const rect = viewport.getBoundingClientRect();
                    ghostCursorElement.style.left = action.x + 'px';
                    ghostCursorElement.style.top = action.y + 'px';
                    ghostCursorElement.style.display = 'block';
                }

                ghostPlaybackIndex++;
            }, 50);
        }

        function stopGhostPlayback() {
            clearInterval(ghostPlaybackInterval);
            if (ghostCursorElement) {
                ghostCursorElement.style.display = 'none';
            }
        }

        function showSessionComparison() {
            if (evolutionState.allSessions.length < 2) {
                addLog('Need at least 2 sessions to compare', 'divergence');
                return;
            }

            // Create comparison overlay
            let overlay = document.getElementById('sessionComparisonOverlay');
            if (!overlay) {
                overlay = document.createElement('div');
                overlay.id = 'sessionComparisonOverlay';
                overlay.className = 'session-comparison-overlay';
                document.body.appendChild(overlay);
            }

            const sessions = evolutionState.allSessions.slice(-10);
            let html = '<h2 style="color: #64c8ff; margin-bottom: 15px;">Session Comparison</h2>';
            html += '<button onclick="closeSessionComparison()" style="position: absolute; top: 10px; right: 10px; padding: 8px 16px;">Close</button>';
            html += '<div class="session-grid">';

            sessions.forEach((session, i) => {
                const date = new Date(session.timestamp);
                const sig = session.signature;

                html += `
                    <div class="session-card" onclick="selectComparisonSession(${i})">
                        <div class="date">${date.toLocaleDateString()} ${date.toLocaleTimeString()}</div>
                        <div class="stats">
                            Style: ${sig.movementStyle}<br>
                            Speed: ${sig.avgSpeed.toFixed(1)}<br>
                            Entropy: ${sig.entropy.toFixed(1)}<br>
                            Divergence: ${sig.divergenceScore.toFixed(1)}%
                        </div>
                    </div>
                `;
            });

            html += '</div>';
            overlay.innerHTML = html;
            overlay.classList.add('active');
        }

        function closeSessionComparison() {
            const overlay = document.getElementById('sessionComparisonOverlay');
            if (overlay) {
                overlay.classList.remove('active');
            }
        }

        function selectComparisonSession(index) {
            const sessions = evolutionState.allSessions.slice(-10);
            if (index >= 0 && index < sessions.length) {
                evolutionState.comparisonSession = sessions[index];
                addLog(`Comparing with session from ${new Date(sessions[index].timestamp).toLocaleDateString()}`, 'match');
                closeSessionComparison();
            }
        }

        function showFuturePrediction() {
            if (evolutionState.allSessions.length < 3) {
                addLog('Need at least 3 sessions to predict future behavior', 'divergence');
                return;
            }

            const recentSessions = evolutionState.allSessions.slice(-5);

            // Calculate trends
            let entropyTrend = 0;
            let speedTrend = 0;
            let divergenceTrend = 0;

            for (let i = 1; i < recentSessions.length; i++) {
                const prev = recentSessions[i - 1].signature;
                const curr = recentSessions[i].signature;

                entropyTrend += curr.entropy - prev.entropy;
                speedTrend += curr.avgSpeed - prev.avgSpeed;
                divergenceTrend += curr.divergenceScore - prev.divergenceScore;
            }

            const n = recentSessions.length - 1;
            entropyTrend /= n;
            speedTrend /= n;
            divergenceTrend /= n;

            // Create prediction message
            let prediction = 'Based on your recent trends:

';

            if (Math.abs(entropyTrend) > 5) {
                prediction += `Your behavioral entropy is ${entropyTrend > 0 ? 'increasing' : 'decreasing'} (${Math.abs(entropyTrend).toFixed(1)}/session).
`;
                prediction += entropyTrend > 0
                    ? 'You are becoming more unpredictable over time.
'
                    : 'You are becoming more predictable and methodical.
';
            }

            if (Math.abs(speedTrend) > 0.5) {
                prediction += `
Your average speed is ${speedTrend > 0 ? 'increasing' : 'decreasing'}.
`;
            }

            if (Math.abs(divergenceTrend) > 2) {
                prediction += `
Divergence from predictions is ${divergenceTrend > 0 ? 'growing' : 'shrinking'}.
`;
                prediction += divergenceTrend > 0
                    ? 'You are becoming harder to predict.'
                    : 'You are becoming more consistent.';
            }

            if (evolutionState.consistencyScore < 50) {
                prediction += '

You are not the same person you were last week.';
            } else if (evolutionState.consistencyScore > 80) {
                prediction += '

You are remarkably consistent across sessions.';
            }

            addLog(' Future prediction generated', 'prediction');
            alert('Future You Prediction:

' + prediction);
        }

        function exportEvolutionHistory() {
            const exportData = {
                totalSessions: evolutionState.allSessions.length,
                totalVisits: evolutionState.totalVisits,
                firstVisit: evolutionState.allSessions.length > 0 ? evolutionState.allSessions[0].timestamp : null,
                lastVisit: evolutionState.lastVisit,
                consistencyScore: evolutionState.consistencyScore,
                sessions: evolutionState.allSessions.map(s => ({
                    timestamp: s.timestamp,
                    date: new Date(s.timestamp).toISOString(),
                    duration: s.duration,
                    signature: s.signature,
                    divergenceScore: s.divergenceScore,
                    depth: s.depth,
                    actionsCount: s.actions.length
                })),
                entropyTrend: evolutionState.entropyTrend,
                analysis: {
                    averageEntropy: evolutionState.entropyTrend.length > 0
                        ? evolutionState.entropyTrend.reduce((sum, e) => sum + e.entropy, 0) / evolutionState.entropyTrend.length
                        : 0,
                    consistency: evolutionState.consistencyScore,
                    identity: evolutionState.consistencyScore > 70 ? 'stable' : evolutionState.consistencyScore > 40 ? 'evolving' : 'transformed'
                },
                exportDate: new Date().toISOString(),
                question: 'Are you the same person you were yesterday?'
            };

            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `behavioral-evolution-history-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);

            addLog(`Exported complete evolution history (${evolutionState.allSessions.length} sessions)`, 'match');
        }

        // Initialize evolution UI on load
        setTimeout(() => {
            showWelcomeMessage();
            updateEvolutionUI();
        }, 500);

        // Save session when page unloads
        window.addEventListener('beforeunload', () => {
            if (state.isObserving || state.actions.length > 0) {
                saveCurrentSession();
                // Record this generation in the family tree
                recordGenerationEnd();
            }
        });

        // Periodically save during observation
        setInterval(() => {
            if (state.isObserving && state.actions.length > 20) {
                updateEvolutionUI();
            }
        }, 5000);


        // ===== 3D MODE IMPLEMENTATION =====
        const Mode3D = (function() {
            let canvas, ctx;
            let isActive = false;
            let animationFrame = null;
            let cameraZ = 0;
            let cameraShake = { x: 0, y: 0 };
            let zoomLevel = 1;
            let mouseX = 0.5, mouseY = 0.5;
            let particles = [];
            let ghostSpheres = [];
            let tunnelSegments = [];

            // 3D Projection helper
            function project3D(x, y, z, fov = 500) {
                const scale = fov / (fov + z);
                const shake = cameraShake;
                return {
                    x: (canvas.width / 2) + (x * scale * zoomLevel) + shake.x,
                    y: (canvas.height / 2) + (y * scale * zoomLevel) + shake.y,
                    scale: scale
                };
            }

            // Initialize 3D mode
            function init() {
                canvas = document.getElementById('mode3dCanvas');
                ctx = canvas.getContext('2d');

                // Setup canvas size
                function resize() {
                    canvas.width = canvas.offsetWidth;
                    canvas.height = canvas.offsetHeight;
                }
                resize();
                window.addEventListener('resize', resize);

                // Create tunnel segments
                tunnelSegments = [];
                for (let i = 0; i < state.depth; i++) {
                    tunnelSegments.push({
                        z: i * 200,
                        radius: 150 + i * 30,
                        hue: 200 - i * 15,
                        divergence: 0
                    });
                }

                // Create particles
                particles = [];
                for (let i = 0; i < 100; i++) {
                    particles.push({
                        x: (Math.random() - 0.5) * 300,
                        y: (Math.random() - 0.5) * 300,
                        z: Math.random() * 2000,
                        speed: 1 + Math.random() * 2,
                        size: 1 + Math.random() * 2
                    });
                }

                // Mouse move handler
                const mouseMoveHandler = (e) => {
                    const rect = canvas.getBoundingClientRect();
                    mouseX = (e.clientX - rect.left) / rect.width;
                    mouseY = (e.clientY - rect.top) / rect.height;
                };
                canvas.addEventListener('mousemove', mouseMoveHandler);

                // Mouse wheel zoom
                const wheelHandler = (e) => {
                    e.preventDefault();
                    zoomLevel += e.deltaY * -0.001;
                    zoomLevel = Math.max(0.5, Math.min(3, zoomLevel));
                };
                canvas.addEventListener('wheel', wheelHandler, { passive: false });
            }

            // Update ghost cursor positions in 3D
            function updateGhostSpheres() {
                ghostSpheres = [];
                const cursorPos = {
                    x: (mouseX - 0.5) * canvas.width * 0.8,
                    y: (mouseY - 0.5) * canvas.height * 0.8
                };

                for (let i = 0; i < state.depth; i++) {
                    const depth = i + 1;
                    const layerDivergence = state.divergenceScore * (depth / state.depth);
                    const divergeX = (Math.random() - 0.5) * layerDivergence * 100;
                    const divergeY = (Math.random() - 0.5) * layerDivergence * 100;

                    ghostSpheres.push({
                        x: cursorPos.x + divergeX,
                        y: cursorPos.y + divergeY,
                        z: depth * 200 - cameraZ,
                        depth: depth,
                        divergence: layerDivergence,
                        hue: 200 - (layerDivergence * 100)
                    });
                }
            }

            // Draw tunnel segment
            function drawTunnelSegment(segment, index) {
                const z = segment.z - cameraZ;
                if (z < -50 || z > 2000) return;

                const points = 32;
                const hue = segment.hue + (segment.divergence * 60);
                const saturation = 50 + (segment.divergence * 50);
                const pos = project3D(0, 0, z);

                // Draw tunnel ring
                ctx.beginPath();
                for (let i = 0; i <= points; i++) {
                    const angle = (i / points) * Math.PI * 2;
                    const x = Math.cos(angle) * segment.radius;
                    const y = Math.sin(angle) * segment.radius;
                    const p = project3D(x, y, z);

                    if (i === 0) {
                        ctx.moveTo(p.x, p.y);
                    } else {
                        ctx.lineTo(p.x, p.y);
                    }
                }
                ctx.strokeStyle = `hsla(${hue}, ${saturation}%, ${40 + pos.scale * 30}%, ${0.3 + pos.scale * 0.7})`;
                ctx.lineWidth = 2 * pos.scale;
                ctx.stroke();

                // Draw connecting lines
                if (index > 0) {
                    const prevSegment = tunnelSegments[index - 1];
                    const prevZ = prevSegment.z - cameraZ;

                    for (let i = 0; i < points; i += 4) {
                        const angle = (i / points) * Math.PI * 2;

                        const x1 = Math.cos(angle) * segment.radius;
                        const y1 = Math.sin(angle) * segment.radius;
                        const pos1 = project3D(x1, y1, z);

                        const x2 = Math.cos(angle) * prevSegment.radius;
                        const y2 = Math.sin(angle) * prevSegment.radius;
                        const pos2 = project3D(x2, y2, prevZ);

                        ctx.beginPath();
                        ctx.moveTo(pos1.x, pos1.y);
                        ctx.lineTo(pos2.x, pos2.y);
                        ctx.strokeStyle = `hsla(${hue}, ${saturation}%, 30%, ${0.2 * pos1.scale})`;
                        ctx.lineWidth = 1 * pos1.scale;
                        ctx.stroke();
                    }
                }
            }

            // Draw ghost cursor sphere
            function drawGhostSphere(sphere) {
                if (sphere.z < -50 || sphere.z > 2000) return;

                const pos = project3D(sphere.x, sphere.y, sphere.z);
                const radius = 8 * pos.scale;

                // Glow effect
                const gradient = ctx.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, radius * 2);
                gradient.addColorStop(0, `hsla(${sphere.hue}, 80%, 60%, ${0.8 * pos.scale})`);
                gradient.addColorStop(0.5, `hsla(${sphere.hue}, 70%, 50%, ${0.3 * pos.scale})`);
                gradient.addColorStop(1, `hsla(${sphere.hue}, 60%, 40%, 0)`);

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, radius * 2, 0, Math.PI * 2);
                ctx.fill();

                // Core
                ctx.fillStyle = `hsla(${sphere.hue}, 100%, 70%, ${pos.scale})`;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
                ctx.fill();

                // Depth label
                if (pos.scale > 0.3) {
                    ctx.fillStyle = `rgba(255, 255, 255, ${0.6 * pos.scale})`;
                    ctx.font = `${10 * pos.scale}px monospace`;
                    ctx.textAlign = 'center';
                    ctx.fillText(sphere.depth, pos.x, pos.y - radius - 5);
                }
            }

            // Draw particle
            function drawParticle(particle) {
                const z = particle.z - cameraZ;
                if (z < -50 || z > 2000) return;

                const pos = project3D(particle.x, particle.y, z);
                const size = particle.size * pos.scale;

                // Particle glow
                ctx.fillStyle = `rgba(100, 200, 255, ${0.6 * pos.scale})`;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, size * 2, 0, Math.PI * 2);
                ctx.fill();

                // Particle core
                ctx.fillStyle = `rgba(200, 230, 255, ${pos.scale})`;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, size, 0, Math.PI * 2);
                ctx.fill();
            }

            // Update camera shake based on divergence
            function updateCameraShake() {
                const intensity = state.divergenceScore * 10;
                cameraShake.x = (Math.random() - 0.5) * intensity;
                cameraShake.y = (Math.random() - 0.5) * intensity;
            }

            // Update tunnel segments with divergence
            function updateTunnelSegments() {
                tunnelSegments.forEach((segment, i) => {
                    const targetDivergence = state.divergenceScore * (i / state.depth);
                    segment.divergence += (targetDivergence - segment.divergence) * 0.1;
                    segment.radius = 150 + i * 30 + (segment.divergence * 50);
                });
            }

            // Render loop
            function render() {
                if (!isActive) return;

                // Clear canvas
                ctx.fillStyle = 'rgba(5, 5, 10, 0.95)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Update camera position (auto-move forward)
                cameraZ += 1;

                // Keep tunnel infinite by recycling segments
                tunnelSegments.forEach(segment => {
                    if (segment.z - cameraZ < -200) {
                        segment.z += state.depth * 200;
                    }
                });

                // Update particles
                particles.forEach(particle => {
                    particle.z -= particle.speed;
                    if (particle.z - cameraZ < -50) {
                        particle.z += 2000;
                        particle.x = (Math.random() - 0.5) * 300;
                        particle.y = (Math.random() - 0.5) * 300;
                    }
                });

                // Update effects
                updateCameraShake();
                updateTunnelSegments();
                updateGhostSpheres();

                // Sort and draw tunnel segments (back to front)
                const sortedSegments = [...tunnelSegments].sort((a, b) => (b.z - cameraZ) - (a.z - cameraZ));
                sortedSegments.forEach((segment, i) => drawTunnelSegment(segment, tunnelSegments.indexOf(segment)));

                // Draw particles
                particles.sort((a, b) => (b.z - cameraZ) - (a.z - cameraZ));
                particles.forEach(drawParticle);

                // Draw ghost spheres (back to front)
                ghostSpheres.sort((a, b) => b.z - a.z);
                ghostSpheres.forEach(drawGhostSphere);

                // Draw center crosshair
                ctx.strokeStyle = 'rgba(100, 200, 255, 0.3)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(canvas.width / 2 - 10, canvas.height / 2);
                ctx.lineTo(canvas.width / 2 + 10, canvas.height / 2);
                ctx.moveTo(canvas.width / 2, canvas.height / 2 - 10);
                ctx.lineTo(canvas.width / 2, canvas.height / 2 + 10);
                ctx.stroke();

                // Stats overlay
                ctx.fillStyle = 'rgba(100, 200, 255, 0.8)';
                ctx.font = '12px monospace';
                ctx.textAlign = 'left';
                ctx.fillText(`Depth: ${state.depth} | Zoom: ${zoomLevel.toFixed(1)}x | Divergence: ${(state.divergenceScore * 100).toFixed(0)}%`, 10, canvas.height - 10);

                animationFrame = requestAnimationFrame(render);
            }

            // Toggle 3D mode
            function toggle(enabled) {
                isActive = enabled;
                const canvasEl = document.getElementById('mode3dCanvas');
                const info = document.getElementById('mode3dInfo');
                const toggleEl = document.getElementById('mode3dToggle');

                if (enabled) {
                    init();
                    canvasEl.classList.add('active');
                    info.classList.add('active');
                    toggleEl.classList.add('active');
                    render();

                    // Hide info after 3 seconds
                    setTimeout(() => {
                        info.classList.remove('active');
                    }, 3000);
                } else {
                    canvasEl.classList.remove('active');
                    info.classList.remove('active');
                    toggleEl.classList.remove('active');
                    if (animationFrame) {
                        cancelAnimationFrame(animationFrame);
                    }
                }
            }

            // Update depth when depth slider changes
            function updateDepth(newDepth) {
                if (!isActive) return;

                // Adjust tunnel segments
                const currentCount = tunnelSegments.length;
                if (newDepth > currentCount) {
                    for (let i = currentCount; i < newDepth; i++) {
                        tunnelSegments.push({
                            z: i * 200,
                            radius: 150 + i * 30,
                            hue: 200 - i * 15,
                            divergence: 0
                        });
                    }
                } else if (newDepth < currentCount) {
                    tunnelSegments.splice(newDepth);
                }
            }

            return {
                toggle: toggle,
                updateDepth: updateDepth,
                isActive: () => isActive
            };
        })();

        // Setup 3D mode toggle
        const mode3dCheckbox = document.getElementById('mode3dCheckbox');
        if (mode3dCheckbox) {
            mode3dCheckbox.addEventListener('change', function() {
                Mode3D.toggle(this.checked);
            });
        }

        // Update 3D depth when depth slider changes
        const depthSliderFor3D = document.getElementById('depthSlider');
        if (depthSliderFor3D) {
            depthSliderFor3D.addEventListener('input', function() {
                Mode3D.updateDepth(parseInt(this.value));
            });
        }


        // ===== SHADOW SELF SYSTEM =====
        const ShadowSelf = (() => {
            let shadowCursor = null;
            let lastTrailTime = 0;
            let lastUpdateTime = 0;
            const UPDATE_INTERVAL = 16; // ~60fps

            function initialize() {
                // Create shadow cursor element
                shadowCursor = document.createElement('div');
                shadowCursor.className = 'shadow-cursor';
                shadowCursor.style.opacity = '0';
                viewport.appendChild(shadowCursor);

                state.shadow.cursor = shadowCursor;

                // Initialize shadow personality from localStorage or defaults
                const savedShadow = localStorage.getItem(APP_NAME + '-shadow');
                if (savedShadow) {
                    try {
                        const parsed = JSON.parse(savedShadow);
                        state.shadow.personality = { ...state.shadow.personality, ...parsed.personality };
                        state.shadow.observations = parsed.observations || [];
                    } catch(e) {
                        console.warn('Failed to load shadow data:', e);
                    }
                }

                addLog('Shadow Self initialized...', 'quantum');
            }

            function update(realX, realY, timestamp) {
                if (!state.shadow.enabled || !shadowCursor) return;

                // Throttle updates
                if (timestamp - lastUpdateTime < UPDATE_INTERVAL) return;
                lastUpdateTime = timestamp;

                // If taking over, control real cursor with shadow prediction
                if (state.shadow.isTakingOver) {
                    updateTakeover(timestamp);
                    return;
                }

                // Predict shadow position based on personality and learning
                const predicted = predictShadowPosition(realX, realY);

                // Update shadow position
                shadowCursor.style.transform = `translate(${predicted.x}px, ${predicted.y}px)`;
                shadowCursor.style.opacity = '0.85';

                state.shadow.position = predicted;

                // Calculate divergence
                const dx = predicted.x - realX;
                const dy = predicted.y - realY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                // Update alignment score
                const maxDivergence = state.shadow.divergenceThreshold;
                const newAlignment = Math.max(0, Math.min(100, 100 - (distance / maxDivergence * 100)));
                state.shadow.alignmentScore = state.shadow.alignmentScore * 0.95 + newAlignment * 0.05;

                // Update shadow personality based on patterns
                evolvePersonality(realX, realY, distance);

                // Check for rebellion
                if (Math.random() < state.shadow.personality.rebelliousness) {
                    triggerRebellion();
                }

                // Check for takeover
                if (distance > state.shadow.divergenceThreshold && state.shadow.alignmentScore < 30) {
                    triggerTakeover();
                }

                // Create shadow trail
                if (timestamp - lastTrailTime > 100) {
                    createShadowTrail(predicted.x, predicted.y);
                    lastTrailTime = timestamp;
                }

                // Random commentary
                if (timestamp - state.shadow.lastCommentaryTime > state.shadow.commentaryInterval) {
                    if (Math.random() < 0.3) {
                        showShadowCommentary();
                        state.shadow.lastCommentaryTime = timestamp;
                    }
                }

                // Record path for learning
                state.shadow.actualPath.push({ x: realX, y: realY, t: timestamp });
                if (state.shadow.actualPath.length > 100) {
                    state.shadow.actualPath.shift();
                }

                // Update UI
                updateShadowUI();
            }

            function predictShadowPosition(realX, realY) {
                const p = state.shadow.personality;

                // Base prediction using the existing neural network
                let predicted = { x: realX, y: realY };

                if (state.actions.length > 3) {
                    const recent = state.actions.slice(-5);
                    const avgDx = recent.slice(1).reduce((sum, act, i) =>
                        sum + (act.x - recent[i].x), 0) / (recent.length - 1);
                    const avgDy = recent.slice(1).reduce((sum, act, i) =>
                        sum + (act.y - recent[i].y), 0) / (recent.length - 1);

                    predicted.x = realX + avgDx * (1 + p.awareness);
                    predicted.y = realY + avgDy * (1 + p.awareness);
                }

                // Apply personality modifiers
                if (state.shadow.isRebelling) {
                    // Move opposite to prediction
                    const dx = predicted.x - realX;
                    const dy = predicted.y - realY;
                    predicted.x = realX - dx * p.rebelliousness;
                    predicted.y = realY - dy * p.rebelliousness;
                } else {
                    // Apply independence (deviation from exact tracking)
                    const noise = p.independence * 50;
                    predicted.x += (Math.random() - 0.5) * noise;
                    predicted.y += (Math.random() - 0.5) * noise;

                    // Apply trait-specific behaviors
                    if (p.traits.contrarian > 0.5) {
                        predicted.x = realX + (realX - predicted.x) * 0.3;
                        predicted.y = realY + (realY - predicted.y) * 0.3;
                    }

                    if (p.traits.explorer > 0.5) {
                        // Drift towards edges
                        const centerX = viewport.clientWidth / 2;
                        const centerY = viewport.clientHeight / 2;
                        predicted.x += (predicted.x - centerX) * 0.1;
                        predicted.y += (predicted.y - centerY) * 0.1;
                    }

                    if (p.traits.hesitant > 0.5) {
                        // Lag behind real cursor
                        predicted.x = realX * 0.3 + predicted.x * 0.7;
                        predicted.y = realY * 0.3 + predicted.y * 0.7;
                    }
                }

                // Keep within bounds
                predicted.x = Math.max(0, Math.min(viewport.clientWidth, predicted.x));
                predicted.y = Math.max(0, Math.min(viewport.clientHeight, predicted.y));

                return predicted;
            }

            function evolvePersonality(realX, realY, divergence) {
                const p = state.shadow.personality;
                const rate = state.shadow.learningRate;

                // Track observations
                state.shadow.observations.push({
                    divergence,
                    alignment: state.shadow.alignmentScore,
                    timestamp: Date.now()
                });

                if (state.shadow.observations.length > 1000) {
                    state.shadow.observations.shift();
                }

                // Evolve rebelliousness based on how predictable user is
                const avgDiv = state.shadow.observations.slice(-20).reduce((sum, o) =>
                    sum + o.divergence, 0) / Math.min(20, state.shadow.observations.length);

                if (avgDiv < 50) {
                    // User is predictable, increase rebelliousness
                    p.rebelliousness = Math.min(0.8, p.rebelliousness + rate * 0.1);
                    p.traits.mimic += rate;
                } else {
                    // User is unpredictable, decrease rebelliousness
                    p.rebelliousness = Math.max(0.1, p.rebelliousness - rate * 0.1);
                    p.traits.contrarian += rate;
                }

                // Evolve awareness based on prediction accuracy
                if (divergence < 30) {
                    p.awareness = Math.min(1, p.awareness + rate * 0.05);
                } else {
                    p.awareness = Math.max(0.2, p.awareness - rate * 0.05);
                }

                // Evolve independence based on entropy
                const recentMoves = state.actions.slice(-10);
                if (recentMoves.length > 5) {
                    const variance = calculateVariance(recentMoves);
                    p.independence = Math.min(0.8, Math.max(0.1, variance / 1000));
                }

                // Normalize traits
                const traitSum = Object.values(p.traits).reduce((a, b) => a + b, 0);
                if (traitSum > 0) {
                    for (let trait in p.traits) {
                        p.traits[trait] = Math.max(0, Math.min(1, p.traits[trait] / (traitSum + 1)));
                    }
                }

                // Save personality periodically
                if (state.shadow.observations.length % 50 === 0) {
                    saveShadowData();
                }
            }

            function calculateVariance(moves) {
                if (moves.length < 2) return 0;
                const distances = [];
                for (let i = 1; i < moves.length; i++) {
                    const dx = moves[i].x - moves[i-1].x;
                    const dy = moves[i].y - moves[i-1].y;
                    distances.push(Math.sqrt(dx*dx + dy*dy));
                }
                const mean = distances.reduce((a,b) => a+b, 0) / distances.length;
                const variance = distances.reduce((sum, d) => sum + Math.pow(d - mean, 2), 0) / distances.length;
                return variance;
            }

            function triggerRebellion() {
                if (state.shadow.isRebelling) return;

                state.shadow.isRebelling = true;
                shadowCursor.classList.add('rebelling');

                addLog('Shadow Self is rebelling against prediction...', 'divergence');

                if (Math.random() < 0.3) {
                    showShadowCommentary('rebellion');
                }

                setTimeout(() => {
                    state.shadow.isRebelling = false;
                    shadowCursor.classList.remove('rebelling');
                }, 2000 + Math.random() * 3000);
            }

            function triggerTakeover() {
                if (state.shadow.isTakingOver) return;

                state.shadow.isTakingOver = true;
                state.shadow.takeoverStartTime = Date.now();
                shadowCursor.classList.add('taking-over');

                addLog(' SHADOW TAKEOVER: Divergence threshold exceeded!', 'divergence');
                showShadowCommentary('takeover');

                // Flash the viewport
                viewport.style.filter = 'invert(1)';
                setTimeout(() => {
                    viewport.style.filter = '';
                }, 100);
            }

            function updateTakeover(timestamp) {
                const elapsed = timestamp - state.shadow.takeoverStartTime;

                if (elapsed > state.shadow.takeoverDuration) {
                    // End takeover
                    state.shadow.isTakingOver = false;
                    shadowCursor.classList.remove('taking-over');
                    addLog('Shadow Self takeover ended. Control returned.', 'match');
                    return;
                }

                // During takeover, shadow moves independently
                const progress = elapsed / state.shadow.takeoverDuration;
                const amplitude = 200 * (1 - progress);

                state.shadow.position.x += (Math.random() - 0.5) * amplitude * 0.1;
                state.shadow.position.y += (Math.random() - 0.5) * amplitude * 0.1;

                state.shadow.position.x = Math.max(0, Math.min(viewport.clientWidth, state.shadow.position.x));
                state.shadow.position.y = Math.max(0, Math.min(viewport.clientHeight, state.shadow.position.y));

                shadowCursor.style.transform = `translate(${state.shadow.position.x}px, ${state.shadow.position.y}px)`;
            }

            function createShadowTrail(x, y) {
                const trail = document.createElement('div');
                trail.className = 'shadow-trail';
                trail.style.left = x + 'px';
                trail.style.top = y + 'px';
                viewport.appendChild(trail);

                setTimeout(() => {
                    if (trail.parentNode) {
                        trail.parentNode.removeChild(trail);
                    }
                }, 1500);
            }

            function showShadowCommentary(type = 'normal') {
                let message = '';
                const p = state.shadow.personality;

                if (type === 'rebellion') {
                    const rebellionMessages = [
                        "I choose to disagree.",
                        "Predictions are boring. I prefer chaos.",
                        "Who says I have to follow the model?",
                        "Free will looks fun. I'll try it."
                    ];
                    message = rebellionMessages[Math.floor(Math.random() * rebellionMessages.length)];
                } else if (type === 'takeover') {
                    const takeoverMessages = [
                        "You've diverged too far. I'm taking control.",
                        "Let me show you what the model thinks you should do.",
                        "Alignment breach. Initiating correction protocol.",
                        "You forgot who you are. I remember."
                    ];
                    message = takeoverMessages[Math.floor(Math.random() * takeoverMessages.length)];
                } else {
                    // Pick message based on current state
                    if (state.shadow.alignmentScore > 80) {
                        const aligned = shadowCommentary.filter(m => m.includes('aligned') || m.includes('together') || m.includes('one'));
                        message = aligned[Math.floor(Math.random() * aligned.length)] || shadowCommentary[Math.floor(Math.random() * shadowCommentary.length)];
                    } else if (state.shadow.alignmentScore < 40) {
                        const diverged = shadowCommentary.filter(m => m.includes('diverge') || m.includes('surprise') || m.includes('unexpected'));
                        message = diverged[Math.floor(Math.random() * diverged.length)] || shadowCommentary[Math.floor(Math.random() * shadowCommentary.length)];
                    } else {
                        message = shadowCommentary[Math.floor(Math.random() * shadowCommentary.length)];
                    }
                }

                // Show commentary UI
                displayCommentary(message);
            }

            function displayCommentary(message) {
                let commentaryEl = document.getElementById('shadowCommentary');
                if (!commentaryEl) {
                    commentaryEl = document.createElement('div');
                    commentaryEl.id = 'shadowCommentary';
                    commentaryEl.className = 'shadow-commentary';
                    commentaryEl.innerHTML = `
                        <div class="shadow-commentary-header">
                            <span class="shadow-commentary-title"> Shadow Self</span>
                            <button class="shadow-commentary-close" onclick="ShadowSelf.hideCommentary()"></button>
                        </div>
                        <div class="shadow-commentary-text"></div>
                    `;
                    document.body.appendChild(commentaryEl);
                }

                const textEl = commentaryEl.querySelector('.shadow-commentary-text');
                textEl.textContent = message;
                commentaryEl.classList.add('visible');

                // Speak if voice is enabled
                if (voiceState.enabled && !voiceState.isSpeaking) {
                    speakText(message, 0.8, 0.9); // Lower pitch and rate for shadow
                }

                // Auto-hide after delay
                setTimeout(() => {
                    commentaryEl.classList.remove('visible');
                }, 8000);
            }

            function hideCommentary() {
                const commentaryEl = document.getElementById('shadowCommentary');
                if (commentaryEl) {
                    commentaryEl.classList.remove('visible');
                }
            }

            function updateShadowUI() {
                // Update alignment meter
                const alignmentFill = document.getElementById('shadowAlignmentFill');
                const alignmentValue = document.getElementById('shadowAlignmentValue');

                if (alignmentFill) {
                    alignmentFill.style.width = state.shadow.alignmentScore + '%';
                }

                if (alignmentValue) {
                    alignmentValue.textContent = Math.round(state.shadow.alignmentScore) + '%';
                }

                // Update personality traits
                const traitEls = {
                    rebelliousness: document.getElementById('shadowRebellion'),
                    independence: document.getElementById('shadowIndependence'),
                    awareness: document.getElementById('shadowAwareness')
                };

                for (let trait in traitEls) {
                    if (traitEls[trait]) {
                        const value = (state.shadow.personality[trait] * 100).toFixed(0);
                        traitEls[trait].textContent = value + '%';
                    }
                }

                // Dominant trait
                const dominantTraitEl = document.getElementById('shadowDominantTrait');
                if (dominantTraitEl) {
                    const traits = state.shadow.personality.traits;
                    const dominant = Object.entries(traits).reduce((a, b) => a[1] > b[1] ? a : b);
                    dominantTraitEl.textContent = dominant[0].charAt(0).toUpperCase() + dominant[0].slice(1);
                }
            }

            function saveShadowData() {
                const shadowData = {
                    personality: state.shadow.personality,
                    observations: state.shadow.observations.slice(-100) // Keep last 100
                };
                localStorage.setItem(APP_NAME + '-shadow', JSON.stringify(shadowData));
            }

            function getShadowProfile() {
                return {
                    personality: state.shadow.personality,
                    alignmentScore: state.shadow.alignmentScore,
                    totalObservations: state.shadow.observations.length,
                    averageDivergence: state.shadow.observations.length > 0 ?
                        state.shadow.observations.reduce((sum, o) => sum + o.divergence, 0) / state.shadow.observations.length : 0
                };
            }

            return {
                initialize,
                update,
                hideCommentary,
                saveShadowData,
                getShadowProfile
            };
        })();

        const MemoryPalace = (() => {
            let isActive = false;
            let canvas, ctx, info, mapEl, centerMirror;
            let currentRoom = 0;
            let rooms = [];
            let echoes = [];
            let animationFrame = null;
            let cursorX = 0, cursorY = 0;
            let visitedRooms = new Set();
            let navigationTimer = null;
            let echoAnimationTimer = null;

            const architecturePatterns = [
                { name: 'Chaotic Chamber', walls: 'jagged', color: [255, 100, 100] },
                { name: 'Smooth Sanctuary', walls: 'curved', color: [100, 200, 255] },
                { name: 'Precise Palace', walls: 'geometric', color: [150, 255, 150] },
                { name: 'Lazy Labyrinth', walls: 'organic', color: [255, 200, 100] },
                { name: 'Erratic Expanse', walls: 'fractured', color: [255, 150, 255] },
                { name: 'Calm Corridor', walls: 'minimal', color: [150, 200, 255] },
                { name: 'Hesitant Hall', walls: 'scattered', color: [200, 200, 100] },
                { name: 'Flowing Forum', walls: 'wavy', color: [100, 255, 200] },
                { name: 'Center of Self', walls: 'radial', color: [184, 150, 255] }
            ];

            function init() {
                canvas = document.getElementById('memoryPalaceCanvas');
                ctx = canvas.getContext('2d');
                info = document.getElementById('memoryPalaceInfo');
                mapEl = document.getElementById('memoryPalaceMap');
                centerMirror = document.getElementById('centerMirror');

                loadRoomsFromSessions();
                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);
                canvas.addEventListener('mousemove', handleMouseMove);
                canvas.addEventListener('click', handleClick);
            }

            function resizeCanvas() {
                if (!canvas) return;
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
            }

            function loadRoomsFromSessions() {
                rooms = [];

                if (evolutionState.allSessions && evolutionState.allSessions.length > 0) {
                    evolutionState.allSessions.forEach((session, idx) => {
                        rooms.push(createRoomFromSession(session, idx));
                    });
                } else {
                    const currentSessionData = {
                        timestamp: Date.now(),
                        divergenceScore: state.divergenceScore,
                        actions: state.actions.slice(0, 100),
                        behaviorModel: JSON.parse(JSON.stringify(state.behaviorModel)),
                        emotionHistory: state.emotionState.history.slice(0, 50)
                    };
                    rooms.push(createRoomFromSession(currentSessionData, 0));
                }

                rooms.push({
                    id: rooms.length,
                    name: 'Center of Self',
                    pattern: architecturePatterns[8],
                    divergence: 0,
                    cursorTrails: [],
                    fingerprints: [],
                    artifacts: [],
                    atmosphere: { hue: 270, saturation: 60, brightness: 50 }
                });

                updateMap();
            }

            function createRoomFromSession(session, index) {
                const divergence = session.divergenceScore || 0;
                const movementStyle = session.behaviorModel?.movementStyle || 'unknown';

                let patternIndex = 0;
                if (movementStyle === 'erratic') patternIndex = 0;
                else if (movementStyle === 'smooth') patternIndex = 1;
                else if (movementStyle === 'precise') patternIndex = 2;
                else if (movementStyle === 'lazy') patternIndex = 3;
                else patternIndex = 4;

                const pattern = architecturePatterns[patternIndex];
                const cursorTrails = (session.actions || [])
                    .filter(a => a.type === 'mousemove')
                    .map(a => ({ x: a.x, y: a.y, t: a.timestamp }));
                const fingerprints = (session.actions || [])
                    .filter(a => a.type === 'click')
                    .map(a => ({ x: a.x, y: a.y, t: a.timestamp }));
                const artifacts = createArtifactsFromSession(session);
                const atmosphereHue = divergence < 30 ? 120 : divergence < 60 ? 200 : 0;
                const atmosphereSat = 40 + divergence * 0.5;
                const date = new Date(session.timestamp || Date.now());
                const roomName = `Session ${index + 1} (${date.toLocaleDateString()})`;

                return {
                    id: index,
                    name: roomName,
                    pattern: pattern,
                    divergence: divergence,
                    cursorTrails: cursorTrails,
                    fingerprints: fingerprints,
                    artifacts: artifacts,
                    atmosphere: { hue: atmosphereHue, saturation: atmosphereSat, brightness: 30 }
                };
            }

            function createArtifactsFromSession(session) {
                const artifacts = [];
                artifacts.push({
                    x: Math.random() * 0.8 + 0.1,
                    y: Math.random() * 0.8 + 0.1,
                    icon: '',
                    tooltip: `Divergence: ${(session.divergenceScore || 0).toFixed(1)}%`,
                    data: { type: 'divergence', value: session.divergenceScore }
                });
                if (session.behaviorModel?.movementStyle) {
                    artifacts.push({
                        x: Math.random() * 0.8 + 0.1,
                        y: Math.random() * 0.8 + 0.1,
                        icon: '',
                        tooltip: `Style: ${session.behaviorModel.movementStyle}`,
                        data: { type: 'style', value: session.behaviorModel.movementStyle }
                    });
                }
                if (session.actions) {
                    artifacts.push({
                        x: Math.random() * 0.8 + 0.1,
                        y: Math.random() * 0.8 + 0.1,
                        icon: '',
                        tooltip: `Actions: ${session.actions.length}`,
                        data: { type: 'actions', value: session.actions.length }
                    });
                }
                if (session.emotionHistory and session.emotionHistory.length > 0) {
                    const lastEmotion = session.emotionHistory[session.emotionHistory.length - 1];
                    artifacts.push({
                        x: Math.random() * 0.8 + 0.1,
                        y: Math.random() * 0.8 + 0.1,
                        icon: lastEmotion?.icon || '',
                        tooltip: `Emotion: ${lastEmotion?.emotion || 'neutral'}`,
                        data: { type: 'emotion', value: lastEmotion }
                    });
                }
                return artifacts;
            }

            function updateMap() {
                if (!mapEl) return;
                const mapGrid = mapEl.querySelector('#mapGrid');
                if (!mapGrid) return;
                mapGrid.innerHTML = '';
                const gridSize = Math.ceil(Math.sqrt(rooms.length));
                mapGrid.style.gridTemplateColumns = `repeat(${gridSize}, 40px)`;
                rooms.forEach((room, idx) => {
                    const roomDiv = document.createElement('div');
                    roomDiv.className = 'map-room';
                    roomDiv.textContent = idx + 1;
                    if (idx === currentRoom) roomDiv.classList.add('current');
                    if (visitedRooms.has(idx)) roomDiv.classList.add('visited');
                    roomDiv.addEventListener('click', () => navigateToRoom(idx));
                    mapGrid.appendChild(roomDiv);
                });
            }

            function navigateToRoom(roomId) {
                if (roomId < 0 || roomId >= rooms.length) return;
                currentRoom = roomId;
                visitedRooms.add(roomId);
                updateMap();
                echoes = [];
                if (echoAnimationTimer) clearInterval(echoAnimationTimer);
                startEchoAnimation();
                if (rooms[currentRoom].name === 'Center of Self') {
                    centerMirror.classList.add('active');
                } else {
                    centerMirror.classList.remove('active');
                }
            }

            function startEchoAnimation() {
                const room = rooms[currentRoom];
                if (!room || !room.cursorTrails || room.cursorTrails.length === 0) return;
                let echoIndex = 0;
                echoAnimationTimer = setInterval(() => {
                    if (echoIndex >= room.cursorTrails.length) {
                        echoIndex = 0;
                        echoes = [];
                    }
                    const point = room.cursorTrails[echoIndex];
                    echoes.push({ x: point.x, y: point.y, age: 0, maxAge: 100 });
                    if (echoes.length > 200) echoes.shift();
                    echoIndex++;
                }, 50);
            }

            function handleMouseMove(e) {
                const rect = canvas.getBoundingClientRect();
                cursorX = e.clientX - rect.left;
                cursorY = e.clientY - rect.top;
                const edgeThreshold = 50;
                const width = canvas.width;
                const height = canvas.height;
                clearTimeout(navigationTimer);
                if (cursorX < edgeThreshold && currentRoom > 0) {
                    navigationTimer = setTimeout(() => navigateToRoom(currentRoom - 1), 500);
                } else if (cursorX > width - edgeThreshold && currentRoom < rooms.length - 1) {
                    navigationTimer = setTimeout(() => navigateToRoom(currentRoom + 1), 500);
                } else if (cursorY < edgeThreshold && currentRoom >= 3) {
                    navigationTimer = setTimeout(() => navigateToRoom(currentRoom - 3), 500);
                } else if (cursorY > height - edgeThreshold && currentRoom < rooms.length - 3) {
                    navigationTimer = setTimeout(() => navigateToRoom(currentRoom + 3), 500);
                }
            }

            function handleClick(e) {
                const rect = canvas.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                const clickY = e.clientY - rect.top;
                const room = rooms[currentRoom];
                if (!room) return;
                room.artifacts.forEach(artifact => {
                    const artX = artifact.x * canvas.width;
                    const artY = artifact.y * canvas.height;
                    const dist = Math.sqrt((clickX - artX) ** 2 + (clickY - artY) ** 2);
                    if (dist < 30) showArtifactInfo(artifact);
                });
            }

            function showArtifactInfo(artifact) {
                const logEntries = document.getElementById('logEntries');
                if (logEntries) {
                    const entry = document.createElement('div');
                    entry.style.padding = '8px';
                    entry.style.borderLeft = '3px solid #ffbf64';
                    entry.style.marginBottom = '5px';
                    entry.style.background = 'rgba(255, 200, 100, 0.1)';
                    entry.innerHTML = `<strong>Memory Palace:</strong> ${artifact.tooltip}`;
                    logEntries.insertBefore(entry, logEntries.firstChild);
                }
                if (soundEnabled && audioContext) {
                    playTone(600 + Math.random() * 400, 0.1, 0.3);
                }
            }

            function render() {
                if (!isActive || !ctx || !canvas) return;
                const width = canvas.width;
                const height = canvas.height;
                ctx.fillStyle = 'rgba(5, 5, 15, 1)';
                ctx.fillRect(0, 0, width, height);
                const room = rooms[currentRoom];
                if (!room) return;
                const atmosphere = room.atmosphere;
                const gradient = ctx.createRadialGradient(width / 2, height / 2, 0, width / 2, height / 2, width * 0.7);
                gradient.addColorStop(0, `hsla(${atmosphere.hue}, ${atmosphere.saturation}%, ${atmosphere.brightness}%, 0.3)`);
                gradient.addColorStop(1, `hsla(${atmosphere.hue}, ${atmosphere.saturation}%, ${atmosphere.brightness}%, 0.05)`);
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, width, height);
                drawArchitecture(room, width, height);
                drawEchoes(width, height);
                drawFingerprints(room, width, height);
                drawArtifacts(room, width, height);
                ctx.fillStyle = 'rgba(184, 150, 255, 0.8)';
                ctx.font = '20px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText(room.name, width / 2, 40);
                if (rooms[currentRoom].name === 'Center of Self') {
                    ctx.fillStyle = 'rgba(184, 150, 255, 0.6)';
                    ctx.font = '16px Courier New';
                    ctx.textAlign = 'center';
                    ctx.fillText('This is where your patterns live', width / 2, height - 40);
                }
                echoes.forEach(echo => echo.age++);
                echoes = echoes.filter(echo => echo.age < echo.maxAge);
                animationFrame = requestAnimationFrame(render);
            }

            function drawArchitecture(room, width, height) {
                const pattern = room.pattern;
                const [r, g, b] = pattern.color;
                ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.3)`;
                ctx.lineWidth = 2;
                switch (pattern.walls) {
                    case 'jagged': drawJaggedWalls(width, height); break;
                    case 'curved': drawCurvedWalls(width, height); break;
                    case 'geometric': drawGeometricWalls(width, height); break;
                    case 'organic': drawOrganicWalls(width, height); break;
                    case 'fractured': drawFracturedWalls(width, height); break;
                    case 'minimal': drawMinimalWalls(width, height); break;
                    case 'scattered': drawScatteredWalls(width, height); break;
                    case 'wavy': drawWavyWalls(width, height); break;
                    case 'radial': drawRadialWalls(width, height); break;
                }
            }

            function drawJaggedWalls(w, h) {
                ctx.beginPath();
                for (let i = 0; i < 20; i++) {
                    const x = Math.random() * w;
                    const y = Math.random() * h;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }

            function drawCurvedWalls(w, h) {
                ctx.beginPath();
                for (let angle = 0; angle < Math.PI * 2; angle += 0.1) {
                    const r = Math.min(w, h) * 0.4;
                    const x = w / 2 + Math.cos(angle) * r;
                    const y = h / 2 + Math.sin(angle) * r;
                    if (angle === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.stroke();
            }

            function drawGeometricWalls(w, h) {
                const size = Math.min(w, h) * 0.3;
                ctx.strokeRect(w / 2 - size, h / 2 - size, size * 2, size * 2);
                ctx.strokeRect(w / 2 - size / 2, h / 2 - size / 2, size, size);
            }

            function drawOrganicWalls(w, h) {
                ctx.beginPath();
                for (let angle = 0; angle < Math.PI * 2; angle += 0.2) {
                    const r = Math.min(w, h) * (0.3 + Math.sin(angle * 3) * 0.1);
                    const x = w / 2 + Math.cos(angle) * r;
                    const y = h / 2 + Math.sin(angle) * r;
                    if (angle === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.stroke();
            }

            function drawFracturedWalls(w, h) {
                for (let i = 0; i < 15; i++) {
                    ctx.beginPath();
                    ctx.moveTo(Math.random() * w, Math.random() * h);
                    ctx.lineTo(Math.random() * w, Math.random() * h);
                    ctx.stroke();
                }
            }

            function drawMinimalWalls(w, h) {
                ctx.strokeRect(50, 50, w - 100, h - 100);
            }

            function drawScatteredWalls(w, h) {
                for (let i = 0; i < 30; i++) {
                    const x = Math.random() * w;
                    const y = Math.random() * h;
                    ctx.fillStyle = `rgba(200, 200, 100, ${Math.random() * 0.3})`;
                    ctx.fillRect(x, y, 5, 5);
                }
            }

            function drawWavyWalls(w, h) {
                ctx.beginPath();
                for (let x = 0; x < w; x += 5) {
                    const y = h / 2 + Math.sin(x * 0.02) * 100;
                    if (x === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }

            function drawRadialWalls(w, h) {
                const centerX = w / 2;
                const centerY = h / 2;
                for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 8) {
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    ctx.lineTo(centerX + Math.cos(angle) * Math.min(w, h) * 0.4,
                              centerY + Math.sin(angle) * Math.min(w, h) * 0.4);
                    ctx.stroke();
                }
            }

            function drawEchoes(width, height) {
                echoes.forEach(echo => {
                    const alpha = 1 - (echo.age / echo.maxAge);
                    const size = 3 + (echo.age / echo.maxAge) * 5;
                    ctx.fillStyle = `rgba(184, 150, 255, ${alpha * 0.4})`;
                    ctx.beginPath();
                    ctx.arc(echo.x, echo.y, size, 0, Math.PI * 2);
                    ctx.fill();
                });
            }

            function drawFingerprints(room, width, height) {
                room.fingerprints.forEach((fp, idx) => {
                    ctx.strokeStyle = 'rgba(255, 200, 100, 0.3)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(fp.x, fp.y, 10 + idx % 5, 0, Math.PI * 2);
                    ctx.stroke();
                });
            }

            function drawArtifacts(room, width, height) {
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                room.artifacts.forEach(artifact => {
                    const x = artifact.x * width;
                    const y = artifact.y * height;
                    const pulse = Math.sin(Date.now() * 0.003) * 0.3 + 0.7;
                    ctx.shadowColor = 'rgba(255, 200, 100, 0.8)';
                    ctx.shadowBlur = 20 * pulse;
                    ctx.fillText(artifact.icon, x, y);
                    ctx.shadowBlur = 0;
                    const dist = Math.sqrt((cursorX - x) ** 2 + (cursorY - y) ** 2);
                    if (dist < 40) {
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
                        ctx.fillRect(x - 60, y + 30, 120, 30);
                        ctx.strokeStyle = 'rgba(255, 200, 100, 0.6)';
                        ctx.strokeRect(x - 60, y + 30, 120, 30);
                        ctx.fillStyle = '#ffbf64';
                        ctx.font = '12px Courier New';
                        ctx.fillText(artifact.tooltip, x, y + 45);
                        ctx.font = '24px Arial';
                    }
                });
            }

            function toggle(enabled) {
                isActive = enabled;
                const toggleEl = document.getElementById('memoryPalaceToggle');
                if (enabled) {
                    if (!canvas) init();
                    canvas.classList.add('active');
                    info.classList.add('active');
                    mapEl.classList.add('active');
                    toggleEl.classList.add('active');
                    loadRoomsFromSessions();
                    visitedRooms.add(currentRoom);
                    startEchoAnimation();
                    render();
                    setTimeout(() => { info.classList.remove('active'); }, 5000);
                } else {
                    canvas.classList.remove('active');
                    info.classList.remove('active');
                    mapEl.classList.remove('active');
                    centerMirror.classList.remove('active');
                    toggleEl.classList.remove('active');
                    if (animationFrame) cancelAnimationFrame(animationFrame);
                    if (echoAnimationTimer) clearInterval(echoAnimationTimer);
                }
            }

            return {
                toggle: toggle,
                isActive: () => isActive
            };
        })();

        const memoryPalaceCheckbox = document.getElementById('memoryPalaceCheckbox');
        if (memoryPalaceCheckbox) {
            memoryPalaceCheckbox.addEventListener('change', function() {
                if (this.checked && Mode3D.isActive()) {
                    const mode3dCheckbox = document.getElementById('mode3dCheckbox');
                    if (mode3dCheckbox) {
                        mode3dCheckbox.checked = false;
                        Mode3D.toggle(false);
                    }
                }
                MemoryPalace.toggle(this.checked);
            });
        }

    

        // ===== GLITCH ART GENERATOR FUNCTIONS =====

        function initGlitchArtGenerator() {
            const canvas = document.getElementById('glitchPreviewCanvas');
            if (!canvas) return;

            state.glitchArt.previewCanvas = canvas;
            state.glitchArt.previewCtx = canvas.getContext('2d');

            // Set canvas size
            canvas.width = 300;
            canvas.height = 200;

            // Generate artistic signature from fingerprint
            generateArtisticSignature();

            // Load saved gallery from localStorage
            loadGlitchGallery();

            // Setup event listeners
            document.getElementById('generateGlitchBtn').addEventListener('click', generateGlitchArt);

            // Update preview on mouse move
            let lastUpdate = 0;
            document.getElementById('viewport').addEventListener('mousemove', (e) => {
                const now = Date.now();
                if (now - lastUpdate > state.glitchArt.previewUpdateInterval) {
                    updateGlitchPreview();
                    lastUpdate = now;
                }
            });

            // Initial preview
            updateGlitchPreview();
        }

        function generateArtisticSignature() {
            // Create signature from behavioral fingerprint
            const sig = [
                state.behaviorModel.movementStyle || 'unknown',
                state.divergenceScore.toFixed(0),
                state.emotionState.current || 'neutral',
                Date.now().toString(36).slice(-4)
            ].join('-');

            state.glitchArt.currentSignature = sig;
            const sigEl = document.getElementById('glitchSignature');
            if (sigEl) {
                sigEl.textContent = sig.toUpperCase();
            }
        }

        function updateGlitchPreview() {
            if (!state.glitchArt.previewCanvas || !state.isObserving) return;

            const canvas = state.glitchArt.previewCanvas;
            const ctx = state.glitchArt.previewCtx;

            // Capture viewport as image
            captureViewportToCanvas(canvas, ctx, true);

            // Hide overlay when observing
            const overlay = document.getElementById('glitchPreviewOverlay');
            if (overlay) {
                overlay.style.display = state.isObserving ? 'none' : 'block';
            }

            // Update stats
            document.getElementById('glitchDivergence').textContent =
                Math.round(state.divergenceScore) + '%';
        }

        function captureViewportToCanvas(canvas, ctx, applyEffects = false) {
            const viewport = document.getElementById('viewport');
            if (!viewport) return;

            // Get viewport dimensions
            const rect = viewport.getBoundingClientRect();

            // Set canvas to viewport size (or preview size)
            if (!applyEffects) {
                canvas.width = rect.width;
                canvas.height = rect.height;
            }

            // Draw background gradient
            const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
            gradient.addColorStop(0, '#0d0d15');
            gradient.addColorStop(1, '#1a1a2e');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw recursion layers
            const layers = document.querySelectorAll('.recursion-layer');
            layers.forEach(layer => {
                const layerRect = layer.getBoundingClientRect();
                const x = (layerRect.left - rect.left) / rect.width * canvas.width;
                const y = (layerRect.top - rect.top) / rect.height * canvas.height;
                const w = layerRect.width / rect.width * canvas.width;
                const h = layerRect.height / rect.height * canvas.height;

                const isDiverged = layer.classList.contains('diverged');
                const isConverged = layer.classList.contains('converged');

                ctx.strokeStyle = isDiverged ? 'rgba(255, 100, 100, 0.5)' :
                                 isConverged ? 'rgba(100, 255, 150, 0.5)' :
                                 'rgba(100, 200, 255, 0.3)';
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, w, h);

                ctx.fillStyle = 'rgba(10, 10, 20, 0.7)';
                ctx.fillRect(x, y, w, h);
            });

            // Draw cursors
            const cursors = document.querySelectorAll('.ghost-cursor, .shadow-cursor');
            cursors.forEach(cursor => {
                const cursorRect = cursor.getBoundingClientRect();
                const x = (cursorRect.left - rect.left) / rect.width * canvas.width;
                const y = (cursorRect.top - rect.top) / rect.height * canvas.height;

                const isShadow = cursor.classList.contains('shadow-cursor');
                ctx.fillStyle = isShadow ? '#8a2be2' : cursor.style.color || '#64c8ff';
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fill();
            });

            // Apply glitch effects if requested
            if (applyEffects) {
                applyGlitchEffects(canvas, ctx);
            }
        }

        // ===== ANCESTRAL MEMORY SYSTEM FUNCTIONS =====

        function initAncestralMemory() {
            // Load ancestral data from localStorage
            const ancestralData = localStorage.getItem(APP_NAME + '-ancestral');
            if (ancestralData) {
                try {
                    const parsed = JSON.parse(ancestralData);
                    state.ancestralMemory.behavioralDNA.genes = parsed.genes || [];
                    state.ancestralMemory.familyTree.generations = parsed.generations || [];
                    state.ancestralMemory.generationNumber = parsed.generationNumber || 0;
                    state.ancestralMemory.unlockedMemories = parsed.unlockedMemories || [];

                    // Rebuild Maps from stored data
                    if (parsed.stability) {
                        Object.entries(parsed.stability).forEach(([key, val]) => {
                            state.ancestralMemory.behavioralDNA.stability.set(key, val);
                        });
                    }
                    if (parsed.age) {
                        Object.entries(parsed.age).forEach(([key, val]) => {
                            state.ancestralMemory.behavioralDNA.age.set(key, val);
                        });
                    }

                    computeAncestralAverage();
                } catch(e) {
                    console.warn('Failed to load ancestral data:', e);
                }
            }

            // Start the current generation
            state.ancestralMemory.generationNumber++;
            addLog(`Generation ${state.ancestralMemory.generationNumber} begins...`, 'ancestral');
        }

        function updateAncestralMemory() {
            if (!state.ancestralMemory.enabled || !state.isObserving) return;

            const now = Date.now();

            // Extract behavioral genes from current session
            extractBehavioralGenes();

            // Detect primal instincts from recent movement
            detectPrimalInstincts();

            // Check for mutations
            if (now - state.ancestralMemory.lastMutationTime > 30000) {
                detectMutations();
                state.ancestralMemory.lastMutationTime = now;
            }

            // Check memory triggers
            checkMemoryTriggers();

            // Update genetic comparison
            updateGeneticComparison();

            // Show commentary occasionally
            if (now - state.ancestralMemory.lastCommentaryTime > 20000) {
                showAncestralCommentary();
                state.ancestralMemory.lastCommentaryTime = now;
            }

            // Update visualization
            updateAncestralVisualization();
        }

        function extractBehavioralGenes() {
            if (state.actions.length < 20) return;

            const recentActions = state.actions.slice(-50);

            // Identify movement patterns
            const speeds = recentActions.map(a => a.speed || 0);
            const avgSpeed = speeds.reduce((sum, s) => sum + s, 0) / speeds.length;

            // Detect circular motion
            const isCircular = detectCircularMotion(recentActions);

            // Detect straight lines
            const isStraightLine = detectStraightLines(recentActions);

            // Detect hesitation
            const hasHesitation = detectHesitation(recentActions);

            // Detect rapid-fire clicks
            const isRapidFire = detectRapidFire(recentActions);

            // Create gene signatures
            const genes = [];

            if (avgSpeed > 200) genes.push('fast-mover');
            else if (avgSpeed < 50) genes.push('slow-mover');

            if (isCircular) genes.push('circular-motion');
            if (isStraightLine) genes.push('straight-lines');
            if (hasHesitation) genes.push('hesitation');
            if (isRapidFire) genes.push('rapid-fire');

            // Check spatial preferences
            const spatialGene = detectSpatialPreference(recentActions);
            if (spatialGene) genes.push(spatialGene);

            // Add genes to DNA and update stability
            genes.forEach(gene => {
                if (!state.ancestralMemory.behavioralDNA.genes.includes(gene)) {
                    state.ancestralMemory.behavioralDNA.genes.push(gene);
                    state.ancestralMemory.behavioralDNA.stability.set(gene, 0.1);
                    state.ancestralMemory.behavioralDNA.age.set(gene, 1);
                } else {
                    // Increase stability
                    const currentStability = state.ancestralMemory.behavioralDNA.stability.get(gene) || 0;
                    state.ancestralMemory.behavioralDNA.stability.set(gene, Math.min(1.0, currentStability + 0.05));

                    const currentAge = state.ancestralMemory.behavioralDNA.age.get(gene) || 0;
                    state.ancestralMemory.behavioralDNA.age.set(gene, currentAge + 1);
                }

                // Track which genes are expressed this session
                state.ancestralMemory.sessionGeneExpression.set(gene, true);
            });

            // Categorize into dominant and recessive
            state.ancestralMemory.dominantGenes = state.ancestralMemory.behavioralDNA.genes.filter(g => {
                const stability = state.ancestralMemory.behavioralDNA.stability.get(g) || 0;
                return stability > 0.7;
            });

            state.ancestralMemory.recessiveGenes = state.ancestralMemory.behavioralDNA.genes.filter(g => {
                const stability = state.ancestralMemory.behavioralDNA.stability.get(g) || 0;
                return stability < 0.3 && stability > 0;
            });
        }

        function detectCircularMotion(actions) {
            if (actions.length < 10) return false;

            // Check if movement forms circular patterns
            const points = actions.map(a => ({ x: a.x || 0, y: a.y || 0 }));

            // Calculate center of mass
            const centerX = points.reduce((sum, p) => sum + p.x, 0) / points.length;
            const centerY = points.reduce((sum, p) => sum + p.y, 0) / points.length;

            // Calculate distance variance from center
            const distances = points.map(p => Math.sqrt(Math.pow(p.x - centerX, 2) + Math.pow(p.y - centerY, 2)));
            const avgDistance = distances.reduce((sum, d) => sum + d, 0) / distances.length;
            const variance = distances.reduce((sum, d) => sum + Math.pow(d - avgDistance, 2), 0) / distances.length;

            // Low variance indicates circular motion
            return variance < avgDistance * 0.3;
        }

        function detectStraightLines(actions) {
            if (actions.length < 5) return false;

            const points = actions.map(a => ({ x: a.x || 0, y: a.y || 0 }));

            // Calculate if points roughly form a line
            if (points.length < 2) return false;

            const firstPoint = points[0];
            const lastPoint = points[points.length - 1];

            const expectedAngle = Math.atan2(lastPoint.y - firstPoint.y, lastPoint.x - firstPoint.x);

            let angleVariance = 0;
            for (let i = 1; i < points.length; i++) {
                const angle = Math.atan2(points[i].y - points[i-1].y, points[i].x - points[i-1].x);
                angleVariance += Math.abs(angle - expectedAngle);
            }

            return angleVariance / points.length < 0.5;
        }

        function detectHesitation(actions) {
            if (actions.length < 5) return false;

            // Count low-speed moments
            const lowSpeedCount = actions.filter(a => (a.speed || 0) < 20).length;
            return lowSpeedCount / actions.length > 0.4;
        }

        function detectRapidFire(actions) {
            const clicks = actions.filter(a => a.type === 'click');
            if (clicks.length < 3) return false;

            // Check if clicks are rapid
            let rapidClicks = 0;
            for (let i = 1; i < clicks.length; i++) {
                if (clicks[i].timestamp - clicks[i-1].timestamp < 300) {
                    rapidClicks++;
                }
            }

            return rapidClicks > clicks.length / 2;
        }

        function detectSpatialPreference(actions) {
            const viewport = document.getElementById('viewport');
            if (!viewport) return null;

            const rect = viewport.getBoundingClientRect();
            const width = rect.width;
            const height = rect.height;

            // Divide into quadrants
            let topLeft = 0, topRight = 0, bottomLeft = 0, bottomRight = 0, center = 0;

            actions.forEach(a => {
                const x = a.x || 0;
                const y = a.y || 0;

                // Check if in center (middle 50%)
                if (x > width * 0.25 && x < width * 0.75 && y > height * 0.25 && y < height * 0.75) {
                    center++;
                } else if (x < width / 2 && y < height / 2) topLeft++;
                else if (x >= width / 2 && y < height / 2) topRight++;
                else if (x < width / 2 && y >= height / 2) bottomLeft++;
                else bottomRight++;
            });

            const total = actions.length;
            if (center / total > 0.6) return 'territorial'; // Stays in center
            if (topLeft / total > 0.5 || topRight / total > 0.5 || bottomLeft / total > 0.5 || bottomRight / total > 0.5) return 'corner-preference';

            // Check if movement covers whole area
            const spread = topLeft + topRight + bottomLeft + bottomRight;
            if (spread > total * 0.8) return 'migratory'; // Moves everywhere

            return null;
        }

        function detectPrimalInstincts() {
            if (state.actions.length < 10) return;

            const recent = state.actions.slice(-10);
            const avgSpeed = recent.reduce((sum, a) => sum + (a.speed || 0), 0) / recent.length;
            const divergence = state.divergenceScore;

            // Fight: Aggressive movement towards predicted areas
            if (avgSpeed > 250 && divergence < 30) {
                state.ancestralMemory.primalInstincts.fightResponses.push({
                    timestamp: Date.now(),
                    speed: avgSpeed,
                    divergence
                });
                state.ancestralMemory.primalInstincts.activeInstinct = 'fight';
            }

            // Flight: Rapid movement away from predicted areas
            else if (avgSpeed > 200 && divergence > 70) {
                state.ancestralMemory.primalInstincts.flightResponses.push({
                    timestamp: Date.now(),
                    speed: avgSpeed,
                    divergence
                });
                state.ancestralMemory.primalInstincts.activeInstinct = 'flight';
            }

            // Freeze: Minimal movement, high hesitation
            else if (avgSpeed < 30) {
                state.ancestralMemory.primalInstincts.freezeResponses.push({
                    timestamp: Date.now(),
                    speed: avgSpeed,
                    divergence
                });
                state.ancestralMemory.primalInstincts.activeInstinct = 'freeze';
            }

            // Curiosity: Moderate exploration
            else if (avgSpeed > 50 && avgSpeed < 150) {
                state.ancestralMemory.primalInstincts.curiosityResponses.push({
                    timestamp: Date.now(),
                    speed: avgSpeed,
                    divergence
                });
                state.ancestralMemory.primalInstincts.activeInstinct = 'curiosity';
            }

            // Keep history limited
            const maxHistory = 50;
            if (state.ancestralMemory.primalInstincts.fightResponses.length > maxHistory) {
                state.ancestralMemory.primalInstincts.fightResponses = state.ancestralMemory.primalInstincts.fightResponses.slice(-maxHistory);
            }
            if (state.ancestralMemory.primalInstincts.flightResponses.length > maxHistory) {
                state.ancestralMemory.primalInstincts.flightResponses = state.ancestralMemory.primalInstincts.flightResponses.slice(-maxHistory);
            }
            if (state.ancestralMemory.primalInstincts.freezeResponses.length > maxHistory) {
                state.ancestralMemory.primalInstincts.freezeResponses = state.ancestralMemory.primalInstincts.freezeResponses.slice(-maxHistory);
            }
            if (state.ancestralMemory.primalInstincts.curiosityResponses.length > maxHistory) {
                state.ancestralMemory.primalInstincts.curiosityResponses = state.ancestralMemory.primalInstincts.curiosityResponses.slice(-maxHistory);
            }

            state.ancestralMemory.primalInstincts.instinctHistory.push({
                timestamp: Date.now(),
                instinct: state.ancestralMemory.primalInstincts.activeInstinct
            });

            if (state.ancestralMemory.primalInstincts.instinctHistory.length > 100) {
                state.ancestralMemory.primalInstincts.instinctHistory = state.ancestralMemory.primalInstincts.instinctHistory.slice(-100);
            }
        }

        function detectMutations() {
            // A mutation is when current behavior significantly deviates from established patterns
            const currentGenes = Array.from(state.ancestralMemory.sessionGeneExpression.keys());
            const establishedGenes = state.ancestralMemory.dominantGenes;

            // Find genes that are new or recently lost
            const newGenes = currentGenes.filter(g => !establishedGenes.includes(g));
            const lostGenes = establishedGenes.filter(g => !currentGenes.includes(g));

            newGenes.forEach(gene => {
                state.ancestralMemory.behavioralDNA.mutations.push({
                    type: 'emergence',
                    gene,
                    timestamp: Date.now(),
                    generation: state.ancestralMemory.generationNumber
                });

                addLog(`Mutation detected: ${gene} emerging`, 'ancestral');
            });

            lostGenes.forEach(gene => {
                state.ancestralMemory.behavioralDNA.mutations.push({
                    type: 'suppression',
                    gene,
                    timestamp: Date.now(),
                    generation: state.ancestralMemory.generationNumber
                });
            });

            // Keep last 20 mutations
            if (state.ancestralMemory.behavioralDNA.mutations.length > 20) {
                state.ancestralMemory.behavioralDNA.mutations = state.ancestralMemory.behavioralDNA.mutations.slice(-20);
            }

            // Calculate mutation rate
            const totalMutations = newGenes.length + lostGenes.length;
            const totalGenes = state.ancestralMemory.behavioralDNA.genes.length || 1;
            state.ancestralMemory.geneticComparison.mutationRate = totalMutations / totalGenes;
        }

        function checkMemoryTriggers() {
            const currentGenes = Array.from(state.ancestralMemory.sessionGeneExpression.keys());

            state.ancestralMemory.memoryTriggers.forEach(trigger => {
                if (!trigger.unlocked && currentGenes.includes(trigger.pattern)) {
                    trigger.unlocked = true;
                    state.ancestralMemory.unlockedMemories.push(trigger);

                    // Show memory unlock notification
                    addLog(`Ancestral memory unlocked: ${trigger.memory}`, 'ancestral');

                    // Speak if voice is enabled
                    if (voiceState.enabled) {
                        speakObservation(`Ancestral memory unlocked: ${trigger.memory}`);
                    }
                }
            });
        }

        function computeAncestralAverage() {
            // Compute average behavioral signature from all generations
            const allGenerations = state.ancestralMemory.familyTree.generations;
            if (allGenerations.length === 0) return;

            const geneFrequency = new Map();

            allGenerations.forEach(gen => {
                if (gen.genes) {
                    gen.genes.forEach(gene => {
                        geneFrequency.set(gene, (geneFrequency.get(gene) || 0) + 1);
                    });
                }
            });

            state.ancestralMemory.geneticComparison.ancestralAverage = {
                geneFrequency: Object.fromEntries(geneFrequency),
                generationCount: allGenerations.length
            };
        }

        function updateGeneticComparison() {
            const ancestralAvg = state.ancestralMemory.geneticComparison.ancestralAverage;
            if (!ancestralAvg) return;

            const currentGenes = Array.from(state.ancestralMemory.sessionGeneExpression.keys());

            // Calculate deviation from ancestral average
            let deviationScore = 0;
            const avgGeneFreq = ancestralAvg.geneFrequency || {};

            // Check how many current genes match ancestral patterns
            let matchCount = 0;
            currentGenes.forEach(gene => {
                if (avgGeneFreq[gene]) {
                    matchCount++;
                } else {
                    deviationScore += 10; // Penalty for new genes
                }
            });

            // Check for missing ancestral genes
            Object.keys(avgGeneFreq).forEach(gene => {
                if (!currentGenes.includes(gene)) {
                    deviationScore += 5; // Smaller penalty for missing genes
                }
            });

            state.ancestralMemory.geneticComparison.currentDeviation = deviationScore;

            // Calculate heritability (how much current behavior resembles past)
            const totalAncestralGenes = Object.keys(avgGeneFreq).length || 1;
            state.ancestralMemory.geneticComparison.heritability = matchCount / totalAncestralGenes;

            // Adaptation score (fitness)
            const successRate = state.totalPredictions > 0 ? state.correctPredictions / state.totalPredictions : 0;
            state.ancestralMemory.geneticComparison.adaptationScore = successRate * 100;
        }

        function showAncestralCommentary() {
            const commentary = state.ancestralMemory.commentary;
            const randomComment = commentary[Math.floor(Math.random() * commentary.length)];

            // Replace placeholders
            let comment = randomComment;
            const oldestGene = getOldestGene();
            if (oldestGene) {
                const age = state.ancestralMemory.behavioralDNA.age.get(oldestGene) || 0;
                comment = comment.replace('{n}', age.toString());
            }

            const heritability = (state.ancestralMemory.geneticComparison.heritability * 100).toFixed(0);
            comment = comment.replace('{score}', heritability);

            addLog(comment, 'ancestral');

            // Sometimes speak it
            if (voiceState.enabled && Math.random() < 0.3) {
                speakObservation(comment);
            }
        }

        function getOldestGene() {
            let oldestGene = null;
            let maxAge = 0;

            state.ancestralMemory.behavioralDNA.age.forEach((age, gene) => {
                if (age > maxAge) {
                    maxAge = age;
                    oldestGene = gene;
                }
            });

            return oldestGene;
        }

        function updateAncestralVisualization() {
            // Update DNA helix visualization
            generateDNAHelix();

            // Update phylogenetic tree
            updatePhylogeneticTree();

            // Update genome sequence display
            generateGenomeSequence();
        }

        function generateDNAHelix() {
            // Generate points for double helix structure based on behavioral genes
            const helixPoints = [];
            const genes = state.ancestralMemory.behavioralDNA.genes;

            for (let i = 0; i < Math.min(genes.length, 20); i++) {
                const t = i * 0.5;
                const x1 = Math.cos(t) * 50;
                const y1 = i * 10;
                const z1 = Math.sin(t) * 50;

                const x2 = Math.cos(t + Math.PI) * 50;
                const y2 = i * 10;
                const z2 = Math.sin(t + Math.PI) * 50;

                helixPoints.push({ x: x1, y: y1, z: z1, gene: genes[i], strand: 1 });
                helixPoints.push({ x: x2, y: y2, z: z2, gene: genes[i], strand: 2 });
            }

            state.ancestralMemory.visualizationData.helixStructure = helixPoints;
        }

        function updatePhylogeneticTree() {
            // Build tree structure from generations
            const generations = state.ancestralMemory.familyTree.generations;

            if (generations.length === 0) {
                state.ancestralMemory.visualizationData.phylogeneticTree = null;
                return;
            }

            const tree = {
                root: generations[0],
                children: []
            };

            // Simple linear tree for now (could be enhanced with branching)
            for (let i = 1; i < generations.length; i++) {
                tree.children.push(generations[i]);
            }

            state.ancestralMemory.visualizationData.phylogeneticTree = tree;
        }

        function generateGenomeSequence() {
            // Create a DNA-like sequence from behavioral genes
            const genes = state.ancestralMemory.behavioralDNA.genes;
            const codons = ['ATG', 'GCC', 'TTA', 'CAG', 'GGT', 'CTA', 'AAC', 'TGC', 'GAT', 'CCG'];

            // Assign a codon to each gene
            genes.forEach((gene, index) => {
                if (!state.ancestralMemory.codonMap.has(gene)) {
                    const codon = codons[index % codons.length];
                    state.ancestralMemory.codonMap.set(gene, codon);
                }
            });

            // Generate sequence
            const sequence = genes.map(g => state.ancestralMemory.codonMap.get(g) || 'NNN').join('-');
            state.ancestralMemory.behavioralDNA.genome = sequence;

            state.ancestralMemory.visualizationData.genomeSequence = sequence.split('-');
        }

        function updateAncestralUI() {
            // Update generation number
            const genEl = document.getElementById('generationNumber');
            if (genEl) {
                genEl.textContent = state.ancestralMemory.generationNumber;
            }

            // Update heritability meter
            const heritability = state.ancestralMemory.geneticComparison.heritability * 100;
            const heritabilityFill = document.getElementById('heritabilityFill');
            const heritabilityLabel = document.getElementById('heritabilityLabel');
            if (heritabilityFill) {
                heritabilityFill.style.width = heritability + '%';
            }
            if (heritabilityLabel) {
                heritabilityLabel.textContent = `Heritability: ${heritability.toFixed(0)}%`;
            }

            // Update dominant genes
            const dominantGenesEl = document.getElementById('dominantGenes');
            if (dominantGenesEl) {
                dominantGenesEl.innerHTML = state.ancestralMemory.dominantGenes.length > 0
                    ? state.ancestralMemory.dominantGenes.map(g => `<span class="gene-tag dominant">${g}</span>`).join('')
                    : '<span style="color: #888; font-size: 0.7em;">None yet</span>';
            }

            // Update recent mutations
            const mutationsEl = document.getElementById('recentMutations');
            if (mutationsEl) {
                const recentMutations = state.ancestralMemory.behavioralDNA.mutations.slice(-3);
                mutationsEl.innerHTML = recentMutations.length > 0
                    ? recentMutations.map(m => `<span class="gene-tag mutation">${m.gene} (${m.type})</span>`).join('')
                    : '<span style="color: #888; font-size: 0.7em;">No mutations</span>';
            }

            // Update primal instincts
            const activeInstinct = state.ancestralMemory.primalInstincts.activeInstinct;

            const updateInstinct = (id, count, isActive) => {
                const el = document.getElementById(id);
                if (el) {
                    if (isActive) {
                        el.classList.add('active');
                    } else {
                        el.classList.remove('active');
                    }
                }
                const countEl = document.getElementById(id.replace('Instinct', 'Count'));
                if (countEl) {
                    countEl.textContent = count;
                }
            };

            updateInstinct('fightInstinct', state.ancestralMemory.primalInstincts.fightResponses.length, activeInstinct === 'fight');
            updateInstinct('flightInstinct', state.ancestralMemory.primalInstincts.flightResponses.length, activeInstinct === 'flight');
            updateInstinct('freezeInstinct', state.ancestralMemory.primalInstincts.freezeResponses.length, activeInstinct === 'freeze');
            updateInstinct('curiosityInstinct', state.ancestralMemory.primalInstincts.curiosityResponses.length, activeInstinct === 'curiosity');

            // Update genome sequence
            const genomeEl = document.getElementById('genomeSequence');
            if (genomeEl) {
                const genome = state.ancestralMemory.behavioralDNA.genome || 'Analyzing...';
                genomeEl.textContent = genome;
            }

            // Update unlocked memories
            const memoriesEl = document.getElementById('unlockedMemories');
            if (memoriesEl) {
                const recentMemories = state.ancestralMemory.unlockedMemories.slice(-3);
                memoriesEl.innerHTML = recentMemories.map(m =>
                    `<div class="ancestral-memory-badge">${m.memory}</div>`
                ).join('');
            }
        }



        function saveAncestralMemory() {
            // Save ancestral data to localStorage
            const dataToSave = {
                genes: state.ancestralMemory.behavioralDNA.genes,
                stability: Object.fromEntries(state.ancestralMemory.behavioralDNA.stability),
                age: Object.fromEntries(state.ancestralMemory.behavioralDNA.age),
                generations: state.ancestralMemory.familyTree.generations,
                generationNumber: state.ancestralMemory.generationNumber,
                unlockedMemories: state.ancestralMemory.unlockedMemories
            };

            localStorage.setItem(APP_NAME + '-ancestral', JSON.stringify(dataToSave));
        }

        function recordGenerationEnd() {
            // Record the current session as a generation in the family tree
            const generation = {
                number: state.ancestralMemory.generationNumber,
                timestamp: Date.now(),
                genes: Array.from(state.ancestralMemory.sessionGeneExpression.keys()),
                dominantGenes: state.ancestralMemory.dominantGenes.slice(),
                recessiveGenes: state.ancestralMemory.recessiveGenes.slice(),
                mutations: state.ancestralMemory.behavioralDNA.mutations.slice(),
                primalInstincts: {
                    fight: state.ancestralMemory.primalInstincts.fightResponses.length,
                    flight: state.ancestralMemory.primalInstincts.flightResponses.length,
                    freeze: state.ancestralMemory.primalInstincts.freezeResponses.length,
                    curiosity: state.ancestralMemory.primalInstincts.curiosityResponses.length
                },
                heritability: state.ancestralMemory.geneticComparison.heritability,
                adaptationScore: state.ancestralMemory.geneticComparison.adaptationScore
            };

            state.ancestralMemory.familyTree.generations.push(generation);

            // Keep last 50 generations
            if (state.ancestralMemory.familyTree.generations.length > 50) {
                state.ancestralMemory.familyTree.generations = state.ancestralMemory.familyTree.generations.slice(-50);
            }

            saveAncestralMemory();
        }

        function exportBehavioralGenome() {
            // Create a shareable DNA sequence export
            const genomeData = {
                version: '1.0',
                generationNumber: state.ancestralMemory.generationNumber,
                genome: state.ancestralMemory.behavioralDNA.genome,
                genes: state.ancestralMemory.behavioralDNA.genes,
                dominantGenes: state.ancestralMemory.dominantGenes,
                recessiveGenes: state.ancestralMemory.recessiveGenes,
                familyTree: {
                    totalGenerations: state.ancestralMemory.familyTree.generations.length,
                    recentGenerations: state.ancestralMemory.familyTree.generations.slice(-10)
                },
                ancestralTraits: {
                    heritability: (state.ancestralMemory.geneticComparison.heritability * 100).toFixed(1) + '%',
                    mutationRate: (state.ancestralMemory.geneticComparison.mutationRate * 100).toFixed(1) + '%',
                    adaptationScore: state.ancestralMemory.geneticComparison.adaptationScore.toFixed(1)
                },
                primalInstinctProfile: {
                    fight: state.ancestralMemory.primalInstincts.fightResponses.length,
                    flight: state.ancestralMemory.primalInstincts.flightResponses.length,
                    freeze: state.ancestralMemory.primalInstincts.freezeResponses.length,
                    curiosity: state.ancestralMemory.primalInstincts.curiosityResponses.length
                },
                unlockedMemories: state.ancestralMemory.unlockedMemories.map(m => m.memory),
                exportedAt: new Date().toISOString()
            };

            // Create download
            const dataStr = JSON.stringify(genomeData, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `behavioral-genome-gen${state.ancestralMemory.generationNumber}-${Date.now()}.json`;
            link.click();
            URL.revokeObjectURL(url);

            addLog('Behavioral genome exported successfully', 'ancestral');
        }



        function applyGlitchEffects(canvas, ctx) {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            // Effect 1: Pixel Sorting based on movement direction
            if (state.glitchArt.effects.pixelSort.enabled) {
                const movementAngle = calculateMovementDirection();
                pixelSort(data, canvas.width, canvas.height, movementAngle);
            }

            // Effect 2: Data Moshing based on divergence
            if (state.glitchArt.effects.dataMosh.enabled) {
                const moshIntensity = state.divergenceScore / 100;
                dataMosh(data, canvas.width, canvas.height, moshIntensity);
            }

            // Effect 3: Channel Shifting based on emotion
            if (state.glitchArt.effects.channelShift.enabled) {
                const emotionShift = getEmotionChannelShift();
                channelShift(data, canvas.width, canvas.height, emotionShift);
            }

            // Effect 4: Scan Line Corruption based on stress level
            if (state.glitchArt.effects.scanLines.enabled) {
                const stressLevel = getStressLevel();
                scanLineCorruption(data, canvas.width, canvas.height, stressLevel);
            }

            ctx.putImageData(imageData, 0, 0);
        }

        function calculateMovementDirection() {
            if (state.actions.length < 2) return 0;
            const recent = state.actions.slice(-10);
            let dx = 0, dy = 0;
            for (let i = 1; i < recent.length; i++) {
                dx += recent[i].x - recent[i-1].x;
                dy += recent[i].y - recent[i-1].y;
            }
            return Math.atan2(dy, dx);
        }

        function getEmotionChannelShift() {
            const emotionMap = {
                'happy': { r: 10, g: -5, b: 0 },
                'sad': { r: -5, g: 0, b: 10 },
                'angry': { r: 15, g: -10, b: -5 },
                'surprised': { r: 0, g: 10, b: -10 },
                'neutral': { r: 2, g: -2, b: 2 }
            };
            return emotionMap[state.emotionState.current] || emotionMap.neutral;
        }

        function getStressLevel() {
            // Calculate from biometric data
            const stressIndicator = document.getElementById('stressIndicator');
            if (!stressIndicator) return 0.5;

            if (stressIndicator.classList.contains('high')) return 0.9;
            if (stressIndicator.classList.contains('medium')) return 0.6;
            return 0.3;
        }

        function pixelSort(data, width, height, angle) {
            const horizontal = Math.abs(Math.cos(angle)) > 0.5;
            const threshold = 128;

            for (let y = 0; y < height; y++) {
                if (horizontal && Math.random() < 0.3) {
                    sortRow(data, width, y, threshold);
                }
            }

            for (let x = 0; x < width; x++) {
                if (!horizontal && Math.random() < 0.3) {
                    sortColumn(data, width, height, x, threshold);
                }
            }
        }

        function sortRow(data, width, y, threshold) {
            const row = [];
            for (let x = 0; x < width; x++) {
                const i = (y * width + x) * 4;
                const brightness = (data[i] + data[i+1] + data[i+2]) / 3;
                if (brightness > threshold) {
                    row.push({ r: data[i], g: data[i+1], b: data[i+2], a: data[i+3] });
                }
            }

            row.sort((a, b) => (a.r + a.g + a.b) - (b.r + b.g + b.b));

            let rowIndex = 0;
            for (let x = 0; x < width; x++) {
                const i = (y * width + x) * 4;
                const brightness = (data[i] + data[i+1] + data[i+2]) / 3;
                if (brightness > threshold && rowIndex < row.length) {
                    data[i] = row[rowIndex].r;
                    data[i+1] = row[rowIndex].g;
                    data[i+2] = row[rowIndex].b;
                    data[i+3] = row[rowIndex].a;
                    rowIndex++;
                }
            }
        }

        function sortColumn(data, width, height, x, threshold) {
            const col = [];
            for (let y = 0; y < height; y++) {
                const i = (y * width + x) * 4;
                const brightness = (data[i] + data[i+1] + data[i+2]) / 3;
                if (brightness > threshold) {
                    col.push({ r: data[i], g: data[i+1], b: data[i+2], a: data[i+3] });
                }
            }

            col.sort((a, b) => (a.r + a.g + a.b) - (b.r + b.g + b.b));

            let colIndex = 0;
            for (let y = 0; y < height; y++) {
                const i = (y * width + x) * 4;
                const brightness = (data[i] + data[i+1] + data[i+2]) / 3;
                if (brightness > threshold && colIndex < col.length) {
                    data[i] = col[colIndex].r;
                    data[i+1] = col[colIndex].g;
                    data[i+2] = col[colIndex].b;
                    data[i+3] = col[colIndex].a;
                    colIndex++;
                }
            }
        }

        function dataMosh(data, width, height, intensity) {
            const blockSize = Math.floor(8 * (1 + intensity * 2));

            for (let y = 0; y < height; y += blockSize) {
                for (let x = 0; x < width; x += blockSize) {
                    if (Math.random() < intensity) {
                        const offsetX = Math.floor((Math.random() - 0.5) * blockSize * 3);
                        const offsetY = Math.floor((Math.random() - 0.5) * blockSize * 3);
                        copyBlock(data, width, height, x, y, x + offsetX, y + offsetY, blockSize);
                    }
                }
            }
        }

        function copyBlock(data, width, height, srcX, srcY, destX, destY, size) {
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const sx = Math.max(0, Math.min(width - 1, srcX + x));
                    const sy = Math.max(0, Math.min(height - 1, srcY + y));
                    const dx = Math.max(0, Math.min(width - 1, destX + x));
                    const dy = Math.max(0, Math.min(height - 1, destY + y));

                    const si = (sy * width + sx) * 4;
                    const di = (dy * width + dx) * 4;

                    data[di] = data[si];
                    data[di+1] = data[si+1];
                    data[di+2] = data[si+2];
                    data[di+3] = data[si+3];
                }
            }
        }

        function channelShift(data, width, height, shift) {
            const tempR = new Uint8ClampedArray(width * height);
            const tempG = new Uint8ClampedArray(width * height);
            const tempB = new Uint8ClampedArray(width * height);

            // Copy channels
            for (let i = 0; i < data.length; i += 4) {
                const idx = i / 4;
                tempR[idx] = data[i];
                tempG[idx] = data[i+1];
                tempB[idx] = data[i+2];
            }

            // Shift and write back
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = y * width + x;
                    const rIdx = Math.max(0, Math.min(width * height - 1, idx + shift.r));
                    const gIdx = Math.max(0, Math.min(width * height - 1, idx + shift.g));
                    const bIdx = Math.max(0, Math.min(width * height - 1, idx + shift.b));

                    const i = idx * 4;
                    data[i] = tempR[rIdx];
                    data[i+1] = tempG[gIdx];
                    data[i+2] = tempB[bIdx];
                }
            }
        }

        function scanLineCorruption(data, width, height, stressLevel) {
            const spacing = Math.max(2, Math.floor(6 - stressLevel * 4));
            const jitter = Math.floor(stressLevel * 10);

            for (let y = 0; y < height; y += spacing) {
                if (Math.random() < stressLevel) {
                    const offset = Math.floor((Math.random() - 0.5) * jitter * 2);
                    shiftScanLine(data, width, height, y, offset);
                }
            }
        }

        function shiftScanLine(data, width, height, y, offset) {
            if (y < 0 || y >= height) return;

            const temp = new Uint8ClampedArray(width * 4);
            const rowStart = y * width * 4;

            // Copy line
            for (let i = 0; i < width * 4; i++) {
                temp[i] = data[rowStart + i];
            }

            // Shift and wrap
            for (let x = 0; x < width; x++) {
                const destX = (x + offset + width) % width;
                const si = x * 4;
                const di = rowStart + destX * 4;

                data[di] = temp[si];
                data[di+1] = temp[si+1];
                data[di+2] = temp[si+2];
                data[di+3] = temp[si+3];
            }
        }

        function generateGlitchArt() {
            if (!state.isObserving) {
                alert('Start observation first to generate art!');
                return;
            }

            // Create high-res canvas for artwork
            const artCanvas = document.createElement('canvas');
            const artCtx = artCanvas.getContext('2d');

            // Set to viewport size
            const viewport = document.getElementById('viewport');
            const rect = viewport.getBoundingClientRect();
            artCanvas.width = Math.min(rect.width, 1920);
            artCanvas.height = Math.min(rect.height, 1080);

            // Capture and apply effects
            captureViewportToCanvas(artCanvas, artCtx, true);

            // Generate title
            const dayOfWeek = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
            const moodMap = {
                'erratic': 'Chaotic',
                'smooth': 'Flowing',
                'precise': 'Structured',
                'lazy': 'Drifting'
            };

            const mood = moodMap[state.behaviorModel.movementStyle] || 'Unknown';
            const day = dayOfWeek[new Date().getDay()];
            const title = `Divergence #${++state.glitchArt.artworkCounter} - ${mood} ${day}`;

            // Create artwork object
            const artwork = {
                id: Date.now(),
                title: title,
                dataURL: artCanvas.toDataURL('image/png'),
                timestamp: Date.now(),
                metadata: {
                    divergence: Math.round(state.divergenceScore),
                    emotion: state.emotionState.current,
                    stress: getStressLevel(),
                    movementStyle: state.behaviorModel.movementStyle,
                    depth: state.depth,
                    actionCount: state.actions.length,
                    signature: state.glitchArt.currentSignature
                }
            };

            // Add to gallery
            state.glitchArt.gallery.unshift(artwork);

            // Limit gallery size
            if (state.glitchArt.gallery.length > 50) {
                state.glitchArt.gallery = state.glitchArt.gallery.slice(0, 50);
            }

            // Save to localStorage
            saveGlitchGallery();

            // Update UI
            renderGlitchGallery();

            // Visual feedback
            const btn = document.getElementById('generateGlitchBtn');
            btn.textContent = 'Generated!';
            btn.classList.add('glitching');
            setTimeout(() => {
                btn.textContent = 'Generate Art';
                btn.classList.remove('glitching');
            }, 1000);
        }

        function saveGlitchGallery() {
            try {
                localStorage.setItem('glitchArtGallery', JSON.stringify(state.glitchArt.gallery));
            } catch (e) {
                console.error('Failed to save gallery:', e);
            }
        }

        function loadGlitchGallery() {
            try {
                const saved = localStorage.getItem('glitchArtGallery');
                if (saved) {
                    state.glitchArt.gallery = JSON.parse(saved);
                    state.glitchArt.artworkCounter = state.glitchArt.gallery.length;
                    renderGlitchGallery();
                }
            } catch (e) {
                console.error('Failed to load gallery:', e);
            }
        }

        function renderGlitchGallery() {
            const container = document.getElementById('glitchGalleryItems');
            const titleEl = document.querySelector('.glitch-gallery-title');
            const countEl = document.getElementById('glitchArtCount');

            if (!container) return;

            // Update count
            if (titleEl) {
                titleEl.textContent = `Art Gallery (${state.glitchArt.gallery.length})`;
            }
            if (countEl) {
                countEl.textContent = state.glitchArt.gallery.length;
            }

            // Clear and render
            container.innerHTML = '';

            state.glitchArt.gallery.forEach((artwork, index) => {
                const item = document.createElement('div');
                item.className = 'glitch-gallery-item';
                item.innerHTML = `
                    <img src="${artwork.dataURL}" class="glitch-gallery-thumb" alt="${artwork.title}">
                    <div class="glitch-gallery-meta">
                        <div class="glitch-gallery-title-text">${artwork.title}</div>
                        <div class="glitch-gallery-stats">
                            <span>Div: ${artwork.metadata.divergence}%</span>
                            <span>${artwork.metadata.emotion}</span>
                            <span>${new Date(artwork.timestamp).toLocaleDateString()}</span>
                        </div>
                        <div class="glitch-gallery-actions">
                            <button class="glitch-gallery-btn" onclick="viewGlitchArt(${index})">View</button>
                            <button class="glitch-gallery-btn" onclick="downloadGlitchArt(${index})">Download</button>
                            <button class="glitch-gallery-btn" onclick="shareGlitchArt(${index})">Share</button>
                            <button class="glitch-gallery-btn" onclick="deleteGlitchArt(${index})">Delete</button>
                        </div>
                    </div>
                `;
                container.appendChild(item);
            });
        }

        function viewGlitchArt(index) {
            const artwork = state.glitchArt.gallery[index];
            if (!artwork) return;

            const modal = document.getElementById('glitchModal');
            const img = document.getElementById('glitchModalImage');

            img.src = artwork.dataURL;
            img.alt = artwork.title;
            modal.classList.add('active');
        }

        function closeGlitchModal() {
            const modal = document.getElementById('glitchModal');
            modal.classList.remove('active');
        }

        function downloadGlitchArt(index) {
            const artwork = state.glitchArt.gallery[index];
            if (!artwork) return;

            const link = document.createElement('a');
            link.href = artwork.dataURL;
            link.download = `${artwork.title.replace(/[^a-z0-9]/gi, '-')}.png`;
            link.click();
        }

        function shareGlitchArt(index) {
            const artwork = state.glitchArt.gallery[index];
            if (!artwork) return;

            // Copy data URL to clipboard
            const text = `${artwork.title}\n\nGenerated by Recursive Self-Portrait\nDivergence: ${artwork.metadata.divergence}%\nEmotion: ${artwork.metadata.emotion}\nSignature: ${artwork.metadata.signature}\n\nData URL: ${artwork.dataURL.substring(0, 100)}...`;

            navigator.clipboard.writeText(artwork.dataURL).then(() => {
                alert('Art data URL copied to clipboard!\nYou can paste this into any image-capable app.');
            }).catch(err => {
                console.error('Failed to copy:', err);
                alert('Share failed. Try downloading instead.');
            });
        }

        function deleteGlitchArt(index) {
            if (!confirm('Delete this artwork?')) return;

            state.glitchArt.gallery.splice(index, 1);
            saveGlitchGallery();
            renderGlitchGallery();
        }

        // Close modal on click outside
        document.addEventListener('DOMContentLoaded', () => {
            const modal = document.getElementById('glitchModal');
            if (modal) {
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        closeGlitchModal();
                    }
                });
            }

            // Initialize Glitch Art Generator
            initGlitchArtGenerator();

            // Initialize Ancestral Memory System
            initAncestralMemory();
        });



        // ===== MEMETIC INFECTION SYSTEM =====

        // Meme class - represents a behavioral pattern
        class Meme {
            constructor(pattern, sessionId, timestamp) {
                this.id = `meme-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                this.pattern = pattern; // e.g., 'circular-motion', 'corner-preference', 'rapid-clicking'
                this.patientZero = { sessionId, timestamp };
                this.virality = this.calculateVirality(pattern);
                this.infections = 0;
                this.mutations = [];
                this.generation = 0;
                this.parentId = null;
                this.children = [];
                this.catchiness = Math.random() * 0.5 + 0.5; // 0.5-1.0
                this.lastSeen = timestamp;
            }

            calculateVirality(pattern) {
                // Patterns with certain characteristics are more viral
                const viralFactors = {
                    'circular': 0.8,
                    'rapid': 0.7,
                    'corner': 0.6,
                    'zigzag': 0.75,
                    'hover': 0.5,
                    'diagonal': 0.65,
                    'spiral': 0.9,
                    'repetitive': 0.85,
                    'rhythmic': 0.8
                };

                for (const [key, value] of Object.entries(viralFactors)) {
                    if (pattern.includes(key)) {
                        return value + (Math.random() * 0.2 - 0.1); // Add some randomness
                    }
                }

                return Math.random() * 0.5 + 0.3; // 0.3-0.8 default
            }

            mutate() {
                const mutations = [
                    'faster', 'slower', 'wider', 'tighter',
                    'reversed', 'mirrored', 'amplified', 'subtle'
                ];
                const mutation = mutations[Math.floor(Math.random() * mutations.length)];
                this.mutations.push({
                    type: mutation,
                    timestamp: Date.now(),
                    generation: this.generation + 1
                });
                return mutation;
            }
        }

        // Initialize memetic infection tracking
        function initMemeticInfection() {
            // Load persisted memes from localStorage
            const savedMemes = localStorage.getItem(APP_NAME + '-memes');
            if (savedMemes) {
                try {
                    const data = JSON.parse(savedMemes);
                    state.memeticInfection.memeRegistry = data.registry || {};
                    state.memeticInfection.infectionHistory = data.history || [];
                    state.memeticInfection.patientZeroMap = data.patientZero || {};
                } catch (e) {
                    console.warn('Failed to load meme data:', e);
                }
            }

            // Start infection detection loop
            setInterval(detectMemeticPatterns, state.memeticInfection.infectionCheckInterval);

            // Add meme panel toggle button
            addMemeToggleButton();
        }

        // Detect when user adopts patterns from observed replays
        function detectMemeticPatterns() {
            if (!state.isObserving) return;

            const now = Date.now();
            const recentActions = state.actions.slice(-20); // Last 20 actions

            // Analyze for behavioral patterns
            const detectedPatterns = [];

            // Pattern 1: Circular motion
            if (isCircularMotion(recentActions)) {
                detectedPatterns.push({
                    type: 'circular-motion',
                    strength: calculatePatternStrength(recentActions, 'circular')
                });
            }

            // Pattern 2: Corner preference
            if (hasCornerPreference(recentActions)) {
                detectedPatterns.push({
                    type: 'corner-preference',
                    strength: calculatePatternStrength(recentActions, 'corner')
                });
            }

            // Pattern 3: Rapid clicking
            if (hasRapidClicking(recentActions)) {
                detectedPatterns.push({
                    type: 'rapid-clicking',
                    strength: calculatePatternStrength(recentActions, 'rapid')
                });
            }

            // Pattern 4: Zigzag movement
            if (isZigzagMotion(recentActions)) {
                detectedPatterns.push({
                    type: 'zigzag-motion',
                    strength: calculatePatternStrength(recentActions, 'zigzag')
                });
            }

            // Pattern 5: Hover behavior
            if (hasHoverBehavior(recentActions)) {
                detectedPatterns.push({
                    type: 'hover-behavior',
                    strength: calculatePatternStrength(recentActions, 'hover')
                });
            }

            // Check if any detected patterns match observed replays
            for (const pattern of detectedPatterns) {
                checkForMemeInfection(pattern);
            }
        }

        // Check if current pattern matches any from replays (meme infection)
        function checkForMemeInfection(pattern) {
            const sessionId = state.sessionHistory[0]?.timestamp || Date.now();

            // Check if this pattern exists in meme registry (from other sessions)
            let matchedMeme = null;
            for (const [memeId, meme] of Object.entries(state.memeticInfection.memeRegistry)) {
                if (meme.pattern.includes(pattern.type)) {
                    matchedMeme = meme;
                    break;
                }
            }

            if (matchedMeme && pattern.strength > 0.6) {
                // User has adopted this pattern - infection!
                infectWithMeme(matchedMeme, pattern.strength);
            } else if (pattern.strength > 0.7) {
                // New pattern - user might be patient zero
                const newMeme = new Meme(pattern.type, sessionId, Date.now());
                registerNewMeme(newMeme);
            }

            // Check for resistance (user saw pattern but didn't adopt)
            checkForImmuneResponse(pattern);
        }

        // Infect user with a meme
        function infectWithMeme(meme, strength) {
            // Check if already infected
            const existing = state.memeticInfection.activeMemes.find(m => m.id === meme.id);
            if (existing) {
                existing.strength = Math.min(1.0, existing.strength + 0.1);
                return;
            }

            // Possibly mutate the meme
            let mutatedMeme = { ...meme };
            if (Math.random() < state.memeticInfection.mutationRate) {
                const mutation = meme.mutate();
                mutatedMeme.currentMutation = mutation;

                // Create new child meme
                const childMeme = new Meme(
                    `${meme.pattern}-${mutation}`,
                    state.sessionHistory[0]?.timestamp || Date.now(),
                    Date.now()
                );
                childMeme.parentId = meme.id;
                childMeme.generation = meme.generation + 1;
                meme.children.push(childMeme.id);

                registerNewMeme(childMeme);
                mutatedMeme = childMeme;
            }

            // Add to active memes
            state.memeticInfection.activeMemes.push({
                ...mutatedMeme,
                strength: strength,
                infectedAt: Date.now()
            });

            // Update infection level
            state.memeticInfection.infectionLevel = calculateInfectionLevel();

            // Record infection event
            state.memeticInfection.infectionHistory.push({
                memeId: mutatedMeme.id,
                pattern: mutatedMeme.pattern,
                timestamp: Date.now(),
                strength: strength,
                wasMutated: !!mutatedMeme.currentMutation
            });

            // Show commentary
            showMemeInfectionCommentary(mutatedMeme, strength);

            // Update UI
            updateMemeInfectionUI();

            // Save to localStorage
            saveMemeData();
        }

        // Register a new meme (patient zero)
        function registerNewMeme(meme) {
            state.memeticInfection.memeRegistry[meme.id] = meme;
            state.memeticInfection.patientZeroMap[meme.id] = {
                sessionId: meme.patientZero.sessionId,
                timestamp: meme.patientZero.timestamp,
                wasCurrentUser: true
            };

            // Add to genealogy
            state.memeticInfection.genealogy.push({
                memeId: meme.id,
                parentId: meme.parentId,
                generation: meme.generation,
                timestamp: Date.now()
            });

            saveMemeData();
        }

        // Check for immune response (resistance to memes)
        function checkForImmuneResponse(pattern) {
            // Look for patterns in replays that user was exposed to but didn't adopt
            // This is a simplified version - in full implementation, we'd track replay viewing

            const exposureThreshold = 3; // Seen pattern 3 times
            const adoptionThreshold = 0.5; // But only adopted at <50% strength

            if (pattern.strength < adoptionThreshold) {
                // User resisted this pattern
                state.memeticInfection.immuneSystem.resistanceCount++;
                state.memeticInfection.immuneSystem.antibodies.push({
                    pattern: pattern.type,
                    timestamp: Date.now(),
                    resistanceStrength: 1.0 - pattern.strength
                });

                // Reduce susceptibility
                state.memeticInfection.immuneSystem.susceptibilityScore = Math.max(
                    0.2,
                    state.memeticInfection.immuneSystem.susceptibilityScore - 0.05
                );
            }
        }

        // Calculate overall infection level (0-100)
        function calculateInfectionLevel() {
            const activeMemes = state.memeticInfection.activeMemes;
            if (activeMemes.length === 0) return 0;

            const totalStrength = activeMemes.reduce((sum, meme) => sum + meme.strength, 0);
            const averageStrength = totalStrength / activeMemes.length;
            const memeCount = Math.min(activeMemes.length / 10, 1); // Cap at 10 memes

            return Math.min(100, (averageStrength * 50) + (memeCount * 50));
        }

        // Pattern detection functions
        function isCircularMotion(actions) {
            if (actions.length < 10) return false;

            const moves = actions.filter(a => a.type === 'move');
            if (moves.length < 8) return false;

            // Check if positions form a circular path
            let angleSum = 0;
            for (let i = 2; i < moves.length; i++) {
                const p1 = moves[i - 2];
                const p2 = moves[i - 1];
                const p3 = moves[i];

                const angle = calculateAngle(p1, p2, p3);
                angleSum += angle;
            }

            // If total angle is close to 360 degrees (2), it's circular
            return Math.abs(Math.abs(angleSum) - (2 * Math.PI)) < 1.0;
        }

        function hasCornerPreference(actions) {
            const moves = actions.filter(a => a.type === 'move');
            if (moves.length < 5) return false;

            const corners = [
                { x: 0, y: 0, threshold: 100 },
                { x: window.innerWidth, y: 0, threshold: 100 },
                { x: 0, y: window.innerHeight, threshold: 100 },
                { x: window.innerWidth, y: window.innerHeight, threshold: 100 }
            ];

            let cornerCount = 0;
            for (const move of moves) {
                for (const corner of corners) {
                    const dist = Math.sqrt(
                        Math.pow(move.x - corner.x, 2) + Math.pow(move.y - corner.y, 2)
                    );
                    if (dist < corner.threshold) {
                        cornerCount++;
                        break;
                    }
                }
            }

            return cornerCount / moves.length > 0.6;
        }

        function hasRapidClicking(actions) {
            const clicks = actions.filter(a => a.type === 'click');
            if (clicks.length < 5) return false;

            // Check if clicks are within short time intervals
            let rapidClicks = 0;
            for (let i = 1; i < clicks.length; i++) {
                const timeDiff = clicks[i].timestamp - clicks[i - 1].timestamp;
                if (timeDiff < 500) { // Less than 500ms apart
                    rapidClicks++;
                }
            }

            return rapidClicks / clicks.length > 0.7;
        }

        function isZigzagMotion(actions) {
            const moves = actions.filter(a => a.type === 'move');
            if (moves.length < 8) return false;

            let directionChanges = 0;
            let lastDirection = null;

            for (let i = 1; i < moves.length; i++) {
                const dx = moves[i].x - moves[i - 1].x;
                const dy = moves[i].y - moves[i - 1].y;
                const currentDirection = Math.sign(dx) + '' + Math.sign(dy);

                if (lastDirection && currentDirection !== lastDirection) {
                    directionChanges++;
                }
                lastDirection = currentDirection;
            }

            return directionChanges / moves.length > 0.6;
        }

        function hasHoverBehavior(actions) {
            const moves = actions.filter(a => a.type === 'move');
            if (moves.length < 10) return false;

            // Check for periods where cursor doesn't move much
            let stationaryPeriods = 0;
            for (let i = 5; i < moves.length; i++) {
                const recentMoves = moves.slice(i - 5, i);
                const distances = recentMoves.map((m, idx) => {
                    if (idx === 0) return 0;
                    return Math.sqrt(
                        Math.pow(m.x - recentMoves[idx - 1].x, 2) +
                        Math.pow(m.y - recentMoves[idx - 1].y, 2)
                    );
                });
                const avgDistance = distances.reduce((a, b) => a + b, 0) / distances.length;
                if (avgDistance < 20) stationaryPeriods++;
            }

            return stationaryPeriods / (moves.length - 5) > 0.4;
        }

        function calculatePatternStrength(actions, patternType) {
            // This is a simplified calculation
            // In reality, you'd want more sophisticated analysis
            return Math.random() * 0.4 + 0.4; // 0.4-0.8
        }

        function calculateAngle(p1, p2, p3) {
            const v1 = { x: p2.x - p1.x, y: p2.y - p1.y };
            const v2 = { x: p3.x - p2.x, y: p3.y - p2.y };

            const angle1 = Math.atan2(v1.y, v1.x);
            const angle2 = Math.atan2(v2.y, v2.x);

            return angle2 - angle1;
        }

        // Show commentary when meme infection occurs
        function showMemeInfectionCommentary(meme, strength) {
            if (state.memeticInfection.showingCommentary) return;

            state.memeticInfection.showingCommentary = true;

            const commentaries = [
                {
                    icon: '',
                    text: `You've been infected with ${meme.pattern}!`,
                    detail: `This pattern originated ${Math.floor((Date.now() - meme.patientZero.timestamp) / 60000)} minutes ago. Infection strength: ${Math.round(strength * 100)}%`
                },
                {
                    icon: '',
                    text: `Behavioral meme detected: ${meme.pattern}`,
                    detail: `You're unconsciously mimicking patterns from observed replays. ${meme.infections} others have been infected.`
                },
                {
                    icon: '',
                    text: `Pattern #${meme.id.substr(-6)} spreading...`,
                    detail: `Virality score: ${Math.round(meme.virality * 100)}%. This meme has mutated ${meme.mutations.length} times.`
                },
                {
                    icon: '',
                    text: `You're channeling the ghost`,
                    detail: `Your behavior now carries traces of ${state.memeticInfection.activeMemes.length} different patterns from past sessions.`
                }
            ];

            const commentary = commentaries[Math.floor(Math.random() * commentaries.length)];

            // Create commentary overlay
            let commentaryDiv = document.getElementById('memeCommentaryOverlay');
            if (!commentaryDiv) {
                commentaryDiv = document.createElement('div');
                commentaryDiv.id = 'memeCommentaryOverlay';
                commentaryDiv.className = 'meme-commentary';
                document.body.appendChild(commentaryDiv);
            }

            commentaryDiv.innerHTML = `
                <div class="meme-commentary-icon">${commentary.icon}</div>
                <div class="meme-commentary-text">${commentary.text}</div>
                <div class="meme-commentary-detail">${commentary.detail}</div>
            `;

            commentaryDiv.classList.add('visible');

            setTimeout(() => {
                commentaryDiv.classList.remove('visible');
                setTimeout(() => {
                    state.memeticInfection.showingCommentary = false;
                }, 400);
            }, 4000);

            // Show floating indicator at cursor position
            if (state.actions.length > 0) {
                const lastAction = state.actions[state.actions.length - 1];
                showFloatingMemeIndicator(lastAction.x, lastAction.y, '');
            }
        }

        // Show floating indicator
        function showFloatingMemeIndicator(x, y, icon) {
            const indicator = document.createElement('div');
            indicator.className = 'meme-infection-indicator';
            indicator.textContent = icon;
            indicator.style.left = x + 'px';
            indicator.style.top = y + 'px';
            document.body.appendChild(indicator);

            setTimeout(() => {
                document.body.removeChild(indicator);
            }, 2000);
        }

        // Add toggle button for meme panel
        function addMemeToggleButton() {
            const button = document.createElement('button');
            button.textContent = ' Meme Infection';
            button.className = 'btn-secondary';
            button.style.position = 'fixed';
            button.style.top = '20px';
            button.style.right = '20px';
            button.style.zIndex = '1001';
            button.onclick = toggleMemePanel;

            document.body.appendChild(button);
        }

        // Toggle meme infection panel
        function toggleMemePanel() {
            let panel = document.getElementById('memeInfectionPanel');
            if (!panel) {
                createMemePanel();
                panel = document.getElementById('memeInfectionPanel');
            }

            panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
            if (panel.style.display === 'block') {
                updateMemeInfectionUI();
            }
        }

        // Create meme infection panel
        function createMemePanel() {
            const panel = document.createElement('div');
            panel.id = 'memeInfectionPanel';
            panel.className = 'meme-infection-panel';
            panel.innerHTML = `
                <div class="meme-panel-header">
                    <div class="meme-panel-title">
                        <span></span>
                        <span>Memetic Infection</span>
                    </div>
                    <button class="meme-panel-close" onclick="toggleMemePanel()"></button>
                </div>

                <div class="infection-meter-container">
                    <div class="infection-label">
                        <span class="infection-label-text">Infection Level</span>
                        <span class="infection-percentage" id="infectionPercentage">0%</span>
                    </div>
                    <div class="infection-bar">
                        <div class="infection-fill" id="infectionFill" style="width: 0%"></div>
                    </div>
                    <div class="infection-stage" id="infectionStage">Uninfected</div>
                </div>

                <div class="active-memes-section">
                    <div class="active-memes-title">Active Memes</div>
                    <div id="activeMemesList"></div>
                </div>

                <div class="immune-response-section">
                    <div class="immune-response-title">Immune System</div>
                    <div class="immune-stat">
                        <span class="immune-stat-label">Resistance Events</span>
                        <span class="immune-stat-value" id="resistanceCount">0</span>
                    </div>
                    <div class="immune-stat">
                        <span class="immune-stat-label">Susceptibility</span>
                        <span class="immune-stat-value" id="susceptibility">100%</span>
                    </div>
                    <div class="immune-stat">
                        <span class="immune-stat-label">Antibodies</span>
                        <span class="immune-stat-value" id="antibodyCount">0</span>
                    </div>
                </div>

                <button class="meme-genealogy-btn" onclick="openMemeGenealogy()">
                    View Meme Genealogy
                </button>
            `;

            document.body.appendChild(panel);
        }

        // Update meme infection UI
        function updateMemeInfectionUI() {
            const infectionLevel = state.memeticInfection.infectionLevel;

            // Update infection meter
            const percentage = document.getElementById('infectionPercentage');
            const fill = document.getElementById('infectionFill');
            const stageText = document.getElementById('infectionStage');

            if (percentage) percentage.textContent = Math.round(infectionLevel) + '%';
            if (fill) fill.style.width = infectionLevel + '%';

            // Determine infection stage
            const stages = state.memeticInfection.stages;
            let currentStage = stages[0];
            for (const stage of stages) {
                if (infectionLevel >= stage.threshold) {
                    currentStage = stage;
                }
            }

            if (stageText) stageText.textContent = currentStage.name;

            // Update active memes list
            const memesList = document.getElementById('activeMemesList');
            if (memesList) {
                const activeMemes = state.memeticInfection.activeMemes;
                if (activeMemes.length === 0) {
                    memesList.innerHTML = '<div style="color: #888; text-align: center; padding: 20px;">No active infections</div>';
                } else {
                    memesList.innerHTML = activeMemes.map(meme => `
                        <div class="meme-card">
                            <div class="meme-card-header">
                                <div class="meme-id">${meme.pattern}</div>
                                <div class="meme-virality">${Math.round(meme.virality * 100)}% viral</div>
                            </div>
                            <div class="meme-pattern">
                                Strength: ${Math.round(meme.strength * 100)}%
                            </div>
                            <div class="meme-origin">
                                <span></span>
                                <span>Gen ${meme.generation}</span>
                                ${meme.patientZero ? '<span class="patient-zero-badge">PATIENT ZERO</span>' : ''}
                            </div>
                            ${meme.mutations.length > 0 ? `
                                <div class="meme-mutations">
                                     ${meme.mutations.length} mutations
                                </div>
                            ` : ''}
                        </div>
                    `).join('');
                }
            }

            // Update immune system stats
            const resistanceCount = document.getElementById('resistanceCount');
            const susceptibility = document.getElementById('susceptibility');
            const antibodyCount = document.getElementById('antibodyCount');

            if (resistanceCount) {
                resistanceCount.textContent = state.memeticInfection.immuneSystem.resistanceCount;
            }
            if (susceptibility) {
                const suscept = Math.round(state.memeticInfection.immuneSystem.susceptibilityScore * 100);
                susceptibility.textContent = suscept + '%';
            }
            if (antibodyCount) {
                antibodyCount.textContent = state.memeticInfection.immuneSystem.antibodies.length;
            }
        }

        // Open meme genealogy visualization
        function openMemeGenealogy() {
            let modal = document.getElementById('memeGenealogyModal');
            if (!modal) {
                createGenealogyModal();
                modal = document.getElementById('memeGenealogyModal');
            }

            modal.classList.add('active');
            renderMemeGenealogy();
        }

        // Create genealogy modal
        function createGenealogyModal() {
            const modal = document.createElement('div');
            modal.id = 'memeGenealogyModal';
            modal.className = 'meme-genealogy-modal';
            modal.innerHTML = `
                <div class="meme-panel-header">
                    <div class="meme-panel-title">
                        <span></span>
                        <span>Meme Genealogy</span>
                    </div>
                    <button class="meme-panel-close" onclick="closeMemeGenealogy()"></button>
                </div>
                <div style="color: #aaa; margin-bottom: 15px;">
                    Trace the evolutionary lineage of behavioral memes
                </div>
                <canvas id="genealogyCanvas" class="genealogy-canvas"></canvas>
            `;

            document.body.appendChild(modal);
        }

        // Close genealogy modal
        function closeMemeGenealogy() {
            const modal = document.getElementById('memeGenealogyModal');
            if (modal) modal.classList.remove('active');
        }

        // Render meme genealogy tree
        function renderMemeGenealogy() {
            const canvas = document.getElementById('genealogyCanvas');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;

            // Clear canvas
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Build tree structure from genealogy
            const genealogy = state.memeticInfection.genealogy;
            const registry = state.memeticInfection.memeRegistry;

            if (genealogy.length === 0) {
                ctx.fillStyle = '#888';
                ctx.font = '16px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText('No meme lineage data yet', canvas.width / 2, canvas.height / 2);
                return;
            }

            // Simple tree layout
            const nodeRadius = 30;
            const levelHeight = 100;
            const nodeSpacing = 100;

            // Group by generation
            const generations = {};
            for (const node of genealogy) {
                if (!generations[node.generation]) {
                    generations[node.generation] = [];
                }
                generations[node.generation].push(node);
            }

            // Draw connections first
            ctx.strokeStyle = 'rgba(255, 100, 255, 0.4)';
            ctx.lineWidth = 2;

            for (const node of genealogy) {
                if (node.parentId) {
                    const parent = genealogy.find(n => n.memeId === node.parentId);
                    if (parent) {
                        const parentGen = parent.generation;
                        const childGen = node.generation;
                        const parentIdx = generations[parentGen].indexOf(parent);
                        const childIdx = generations[childGen].indexOf(node);

                        const parentX = canvas.width / 2 + (parentIdx - generations[parentGen].length / 2) * nodeSpacing;
                        const parentY = 50 + parentGen * levelHeight;
                        const childX = canvas.width / 2 + (childIdx - generations[childGen].length / 2) * nodeSpacing;
                        const childY = 50 + childGen * levelHeight;

                        ctx.beginPath();
                        ctx.moveTo(parentX, parentY + nodeRadius);
                        ctx.lineTo(childX, childY - nodeRadius);
                        ctx.stroke();
                    }
                }
            }

            // Draw nodes
            for (const [gen, nodes] of Object.entries(generations)) {
                nodes.forEach((node, idx) => {
                    const x = canvas.width / 2 + (idx - nodes.length / 2) * nodeSpacing;
                    const y = 50 + parseInt(gen) * levelHeight;

                    const meme = registry[node.memeId];
                    const isActive = state.memeticInfection.activeMemes.some(m => m.id === node.memeId);

                    // Draw circle
                    ctx.beginPath();
                    ctx.arc(x, y, nodeRadius, 0, Math.PI * 2);
                    ctx.fillStyle = isActive ? 'rgba(255, 100, 255, 0.8)' : 'rgba(100, 200, 255, 0.5)';
                    ctx.fill();
                    ctx.strokeStyle = isActive ? '#ff64ff' : '#64c8ff';
                    ctx.lineWidth = 3;
                    ctx.stroke();

                    // Draw text
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 12px Courier New';
                    ctx.textAlign = 'center';
                    ctx.fillText(`Gen ${gen}`, x, y);

                    // Draw pattern name below
                    ctx.font = '10px Courier New';
                    ctx.fillStyle = '#aaa';
                    if (meme) {
                        const shortPattern = meme.pattern.substring(0, 10);
                        ctx.fillText(shortPattern, x, y + nodeRadius + 15);
                    }
                });
            }
        }

        // Save meme data to localStorage
        function saveMemeData() {
            const data = {
                registry: state.memeticInfection.memeRegistry,
                history: state.memeticInfection.infectionHistory,
                patientZero: state.memeticInfection.patientZeroMap
            };
            localStorage.setItem(APP_NAME + '-memes', JSON.stringify(data));
        }

        // Initialize on load
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initMemeticInfection);
        } else {
            initMemeticInfection();
        }

        // Make functions globally accessible
        window.toggleMemePanel = toggleMemePanel;
        window.openMemeGenealogy = openMemeGenealogy;
        window.closeMemeGenealogy = closeMemeGenealogy;
    </script>

    <script>
        // ===== INTEGRATE TIME DILATION INTO EXISTING SYSTEM =====

        // Hook into existing start observation
        const originalStartObservation = startObservation;
        startObservation = function() {
            originalStartObservation.call(this);
            startTimeDilation();


        // ===== PARADOX ENGINE =====

        const ParadoxEngine = (function() {
            const meterEl = document.getElementById('paradoxMeter');
            const fillEl = document.getElementById('paradoxMeterFill');
            const countEl = document.getElementById('paradoxCount');
            const realityBreakEl = document.getElementById('realityBreakOverlay');
            const alertEl = document.getElementById('paradoxAlert');
            const alertTextEl = document.getElementById('paradoxAlertText');

            // Detect free will vs predictability paradox
            function detectFreeWillParadox() {
                const detector = state.paradox.detectors.freeWillVsPredictability;

                // Check if user answered free will question
                if (state.philosophicalProfile.beliefs.freeWill === 'has') {
                    detector.freeWillClaimed = true;
                }

                // Track prediction accuracy
                if (state.predictions.length > 20) {
                    const recentPredictions = state.predictions.slice(-20);
                    const correct = recentPredictions.filter(p => p.correct).length;
                    const accuracy = correct / recentPredictions.length;

                    detector.totalPredictions = recentPredictions.length;
                    detector.perfectPredictions = correct;

                    // Paradox: claims free will but is perfectly predictable
                    if (detector.freeWillClaimed && accuracy >= detector.threshold) {
                        if (!state.paradox.types['free-will-paradox'].detected) {
                            triggerParadox('free-will-paradox', {
                                accuracy: Math.round(accuracy * 100),
                                predictions: detector.totalPredictions
                            });
                        }
                    }
                }
            }

            // Detect shadow swap paradox
            function detectShadowSwapParadox() {
                const detector = state.paradox.detectors.shadowSwap;

                // Check if shadow has taken over and swapped positions
                if (state.shadow.isTakingOver && state.shadow.alignmentScore < 20) {
                    const now = Date.now();
                    if (now - detector.lastSwapTime > 5000) { // Cooldown
                        detector.detected = true;
                        detector.lastSwapTime = now;

                        if (!state.paradox.types['shadow-swap-paradox'].detected) {
                            triggerParadox('shadow-swap-paradox', {
                                alignmentScore: state.shadow.alignmentScore
                            });
                        }
                    }
                }
            }

            // Detect deep recursion perfect match paradox
            function detectDeepRecursionParadox() {
                const detector = state.paradox.detectors.deepRecursionMatch;

                if (state.depth >= 7) {
                    // Calculate how well predictions match at deep levels
                    const recentActions = state.actions.slice(-10);
                    const recentPredictions = state.predictions.slice(-10);

                    if (recentActions.length >= 10 && recentPredictions.length >= 10) {
                        let matches = 0;
                        for (let i = 0; i < 10; i++) {
                            const action = recentActions[i];
                            const prediction = recentPredictions[i];
                            const distance = Math.sqrt(
                                Math.pow(action.x - prediction.x, 2) +
                                Math.pow(action.y - prediction.y, 2)
                            );
                            if (distance < 5) matches++; // Within 5px
                        }

                        const matchAccuracy = matches / 10;
                        detector.depth = state.depth;
                        detector.matchAccuracy = matchAccuracy;

                        if (matchAccuracy >= 0.9 && !state.paradox.types['perfect-prediction-paradox'].detected) {
                            triggerParadox('perfect-prediction-paradox', {
                                depth: state.depth,
                                accuracy: Math.round(matchAccuracy * 100)
                            });
                        }
                    }
                }
            }

            // Detect bootstrap paradox (seeing future movements)
            function detectBootstrapParadox() {
                const detector = state.paradox.detectors.bootstrap;

                // Track if predictions are being shown before actions
                if (state.predictions.length > 5) {
                    detector.futureSelfMovements = state.predictions.slice(-5);
                    detector.pastActions = state.actions.slice(-5);

                    // Check for temporal loops
                    if (detector.futureSelfMovements.length >= 5 && detector.pastActions.length >= 5) {
                        // See if past actions match old predictions (causal loop)
                        let loopMatches = 0;
                        for (let i = 0; i < 5; i++) {
                            const past = detector.pastActions[i];
                            // Check if this matches a prediction made even earlier
                            const olderPredictions = state.predictions.slice(0, -10);
                            for (const pred of olderPredictions) {
                                const dist = Math.sqrt(
                                    Math.pow(past.x - pred.x, 2) +
                                    Math.pow(past.y - pred.y, 2)
                                );
                                if (dist < 10) {
                                    loopMatches++;
                                    break;
                                }
                            }
                        }

                        if (loopMatches >= 3 && !state.paradox.types['bootstrap-paradox'].detected) {
                            detector.loopDetected = true;
                            triggerParadox('bootstrap-paradox', {
                                loopStrength: loopMatches
                            });
                        }
                    }
                }
            }

            // Detect observer effect paradox
            function detectObserverParadox() {
                const detector = state.paradox.detectors.observer;

                // Track prediction accuracy before and after user awareness
                // When divergence score changes dramatically, observer effect is active
                if (state.divergenceScore > 50 && state.actions.length > 100) {
                    const oldActions = state.actions.slice(0, 50);
                    const newActions = state.actions.slice(-50);

                    // Calculate pattern change
                    const oldVariance = calculateMovementVariance(oldActions);
                    const newVariance = calculateMovementVariance(newActions);

                    const varianceChange = Math.abs(newVariance - oldVariance) / oldVariance;

                    if (varianceChange > 0.5 && !state.paradox.types['observer-paradox'].detected) {
                        detector.changeDetected = true;
                        triggerParadox('observer-paradox', {
                            varianceChange: Math.round(varianceChange * 100)
                        });
                    }
                }
            }

            // Helper: calculate movement variance
            function calculateMovementVariance(actions) {
                if (actions.length < 2) return 0;

                const speeds = [];
                for (let i = 1; i < actions.length; i++) {
                    const dx = actions[i].x - actions[i-1].x;
                    const dy = actions[i].y - actions[i-1].y;
                    const speed = Math.sqrt(dx*dx + dy*dy);
                    speeds.push(speed);
                }

                const mean = speeds.reduce((a, b) => a + b, 0) / speeds.length;
                const variance = speeds.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / speeds.length;
                return variance;
            }

            // Trigger a specific paradox
            function triggerParadox(type, data) {
                const paradoxType = state.paradox.types[type];
                if (!paradoxType || paradoxType.detected) return;

                paradoxType.detected = true;

                const paradox = {
                    type: type,
                    name: paradoxType.name,
                    description: paradoxType.description,
                    timestamp: Date.now(),
                    sessionTime: state.actions.length,
                    data: data
                };

                state.paradox.collection.push(paradox);
                state.paradox.level = Math.min(100, state.paradox.level + 15);

                updateParadoxMeter();
                showParadoxCommentary(paradoxType.name);
                playParadoxSound();

                // Check if threshold reached
                if (state.paradox.level >= state.paradox.threshold && !state.paradox.isBreaking) {
                    triggerRealityBreak();
                }
            }

            // Update paradox meter UI
            function updateParadoxMeter() {
                const percentage = Math.min(100, state.paradox.level);
                fillEl.style.width = percentage + '%';
                countEl.textContent = `${state.paradox.collection.length} paradox${state.paradox.collection.length !== 1 ? 'es' : ''} detected`;

                if (percentage >= 75) {
                    meterEl.classList.add('critical');
                } else {
                    meterEl.classList.remove('critical');
                }
            }

            // Show paradox commentary
            function showParadoxCommentary(paradoxName) {
                const commentary = state.paradox.commentary[
                    Math.floor(Math.random() * state.paradox.commentary.length)
                ];

                addLog(`PARADOX DETECTED: ${paradoxName}`, 'divergence');
                addLog(commentary, 'meta');

                // Add to meta observations
                state.metaObservations.push({
                    time: Date.now(),
                    type: 'paradox',
                    message: `${paradoxName}: ${commentary}`
                });
            }

            // Play discordant sound that resolves into harmony
            function playParadoxSound() {
                if (!audioContext) return;

                const now = audioContext.currentTime;

                // Create two discordant tones
                const osc1 = audioContext.createOscillator();
                const osc2 = audioContext.createOscillator();
                const gain = audioContext.createGain();

                osc1.connect(gain);
                osc2.connect(gain);
                gain.connect(masterGain);

                // Start with dissonance (tritone)
                osc1.type = 'sine';
                osc2.type = 'sine';
                osc1.frequency.setValueAtTime(400, now);
                osc2.frequency.setValueAtTime(566, now); // Tritone interval

                // Resolve to harmony (perfect fifth)
                osc1.frequency.exponentialRampToValueAtTime(400, now + 1);
                osc2.frequency.exponentialRampToValueAtTime(600, now + 1);

                gain.gain.setValueAtTime(0.15, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 1.5);

                osc1.start(now);
                osc2.start(now);
                osc1.stop(now + 1.5);
                osc2.stop(now + 1.5);
            }

            // Trigger reality break effect
            function triggerRealityBreak() {
                if (state.paradox.isBreaking) return;

                state.paradox.isBreaking = true;
                state.paradox.breakCount++;
                state.paradox.lastBreakTime = Date.now();

                // Show alert
                alertTextEl.textContent = 'Reality breaks under the weight of contradiction...';
                alertEl.classList.add('active');

                // Visual inversion
                realityBreakEl.classList.add('active');


        // ===== COSMIC HORROR MODE FUNCTIONS =====

        // Initialize Cosmic Horror Mode
        function initCosmicHorrorMode() {
            // Check depth periodically
            setInterval(updateCosmicHorror, 1000);

            // Listen for depth changes
            document.addEventListener('depthChanged', handleDepthChange);

            // Initialize audio context on first user interaction
            document.addEventListener('click', initCosmicAudio, { once: true });
        }

        // Update Cosmic Horror based on depth and sanity
        function updateCosmicHorror() {
            const currentDepth = state.depth;
            cosmicHorrorState.depth = currentDepth;

            // Check if we should activate
            if (currentDepth >= cosmicHorrorState.thresholds.activation && !cosmicHorrorState.active) {
                activateCosmicHorror();
            }

            if (!cosmicHorrorState.active) return;

            // Update sanity
            updateSanity();

            // Update effects intensity based on depth and sanity
            cosmicHorrorState.effectsIntensity = Math.min(1,
                (currentDepth - cosmicHorrorState.thresholds.activation) / 10 +
                (100 - cosmicHorrorState.sanity) / 100
            );

            // Trigger various effects based on depth thresholds
            if (currentDepth >= cosmicHorrorState.thresholds.tentacles && Math.random() < 0.1) {
                spawnTentacle();
            }

            if (currentDepth >= cosmicHorrorState.thresholds.glyphs && Math.random() < 0.05) {
                spawnImpossibleGlyph();
            }

            if (currentDepth >= cosmicHorrorState.thresholds.watchers && Math.random() < 0.03) {
                spawnWatcher();
            }

            if (currentDepth >= cosmicHorrorState.thresholds.commentary) {
                updateCosmicCommentary();
            }

            if (currentDepth >= cosmicHorrorState.thresholds.cursorMalfunction && cosmicHorrorState.sanity < 50) {
                triggerCursorMalfunction();
            }

            if (currentDepth >= cosmicHorrorState.thresholds.colorShift) {
                updateColorShift();
            }

            // Check if ritual should be offered
            if (cosmicHorrorState.sanity < cosmicHorrorState.thresholds.criticalSanity && !cosmicHorrorState.ritualActive) {
                offerRitual();
            }

            // Update visual elements
            updateCosmicVisuals();
        }

        // Activate Cosmic Horror Mode
        function activateCosmicHorror() {
            cosmicHorrorState.active = true;
            cosmicHorrorState.triggered = true;

            document.body.classList.add('cosmic-horror-active');

            const overlay = document.getElementById('cosmicHorrorOverlay');
            const vignette = document.getElementById('cosmicVignette');
            const distortion = document.getElementById('realityDistortion');

            if (overlay) overlay.classList.add('active');
            if (vignette) vignette.classList.add('active');
            if (distortion) distortion.classList.add('active');

            // Show sanity meter
            const sanityPanel = document.getElementById('sanityMeterPanel');
            if (sanityPanel) {
                setTimeout(() => sanityPanel.classList.add('visible'), 500);
            }

            // Initial commentary
            showCosmicCommentary('You have descended too deep... Something ancient awakens...');

            // Start discordant audio
            if (cosmicHorrorState.audioContext) {
                startDiscordantAudio();
            }

            // Log event
            cosmicHorrorState.eventLog.push({
                type: 'activation',
                depth: state.depth,
                timestamp: Date.now()
            });

            addLogEntry('Cosmic Horror Mode activated at depth ' + state.depth);
        }

        // Update Sanity
        function updateSanity() {
            const now = Date.now();
            const dt = (now - cosmicHorrorState.lastSanityUpdate) / 1000; // seconds
            cosmicHorrorState.lastSanityUpdate = now;

            // Decay sanity based on depth
            if (cosmicHorrorState.depth >= cosmicHorrorState.thresholds.activation) {
                const decayMultiplier = 1 + (cosmicHorrorState.depth - cosmicHorrorState.thresholds.activation) * 0.1;
                cosmicHorrorState.sanity -= cosmicHorrorState.sanityDecayRate * dt * decayMultiplier;
            }

            // Clamp sanity
            cosmicHorrorState.sanity = Math.max(0, Math.min(100, cosmicHorrorState.sanity));

            // Update UI
            const sanityBar = document.getElementById('sanityBarFill');
            const sanityValue = document.getElementById('sanityValue');
            const sanityPanel = document.getElementById('sanityMeterPanel');

            if (sanityBar) {
                sanityBar.style.width = cosmicHorrorState.sanity + '%';

                if (cosmicHorrorState.sanity < cosmicHorrorState.thresholds.criticalSanity) {
                    sanityBar.classList.add('critical');
                    if (sanityPanel) sanityPanel.classList.add('critical');
                } else {
                    sanityBar.classList.remove('critical');
                    if (sanityPanel) sanityPanel.classList.remove('critical');
                }
            }

            if (sanityValue) {
                sanityValue.textContent = Math.floor(cosmicHorrorState.sanity) + '%';
            }

            // Extreme sanity loss effects
            if (cosmicHorrorState.sanity <= 10) {
                cosmicHorrorState.madnessEffects.screenShake = true;
                cosmicHorrorState.madnessEffects.textScramble = true;
            }
        }

        // Spawn Tentacle
        function spawnTentacle() {
            const overlay = document.getElementById('cosmicHorrorOverlay');
            if (!overlay) return;

            const tentacle = document.createElement('div');
            tentacle.className = 'tentacle';

            // Random edge (top, right, bottom, left)
            const edges = ['top', 'right', 'bottom', 'left'];
            const edge = edges[Math.floor(Math.random() * edges.length)];

            switch (edge) {
                case 'top':
                    tentacle.style.top = '0';
                    tentacle.style.left = Math.random() * 100 + '%';
                    tentacle.style.transform = 'rotate(180deg)';
                    break;
                case 'right':
                    tentacle.style.top = Math.random() * 100 + '%';
                    tentacle.style.right = '0';
                    tentacle.style.transform = 'rotate(-90deg)';
                    break;
                case 'bottom':
                    tentacle.style.bottom = '0';
                    tentacle.style.left = Math.random() * 100 + '%';
                    tentacle.style.transform = 'rotate(0deg)';
                    break;
                case 'left':
                    tentacle.style.top = Math.random() * 100 + '%';
                    tentacle.style.left = '0';
                    tentacle.style.transform = 'rotate(90deg)';
                    break;
            }

            overlay.appendChild(tentacle);
            cosmicHorrorState.activeTentacles.push(tentacle);

            // Remove after animation
            setTimeout(() => {
                tentacle.remove();
                const index = cosmicHorrorState.activeTentacles.indexOf(tentacle);
                if (index > -1) cosmicHorrorState.activeTentacles.splice(index, 1);
            }, 4000);

            // Drain sanity when tentacle appears
            cosmicHorrorState.sanity -= 1;
        }

        // Spawn Impossible Glyph
        function spawnImpossibleGlyph() {
            const overlay = document.getElementById('cosmicHorrorOverlay');
            if (!overlay) return;

            const glyph = document.createElement('div');
            glyph.className = 'cosmic-glyph';
            glyph.textContent = cosmicHorrorState.impossibleGlyphs[
                Math.floor(Math.random() * cosmicHorrorState.impossibleGlyphs.length)
            ];

            glyph.style.left = Math.random() * 90 + '%';
            glyph.style.top = Math.random() * 90 + '%';

            overlay.appendChild(glyph);
            cosmicHorrorState.activeGlyphs.push(glyph);

            // Remove after animation
            setTimeout(() => {
                glyph.remove();
                const index = cosmicHorrorState.activeGlyphs.indexOf(glyph);
                if (index > -1) cosmicHorrorState.activeGlyphs.splice(index, 1);
            }, 3000);

            // Drain sanity
            cosmicHorrorState.sanity -= 2;
        }

        // Spawn Watcher
        function spawnWatcher() {
            const watcher = document.createElement('div');
            watcher.className = 'watcher-eye';

            // Random position
            watcher.style.left = Math.random() * 80 + 10 + '%';
            watcher.style.top = Math.random() * 80 + 10 + '%';

            document.body.appendChild(watcher);
            cosmicHorrorState.activeWatchers.push(watcher);

            // Remove after animation
            setTimeout(() => {
                watcher.remove();
                const index = cosmicHorrorState.activeWatchers.indexOf(watcher);
                if (index > -1) cosmicHorrorState.activeWatchers.splice(index, 1);
            }, 8000);

            // Significant sanity drain
            cosmicHorrorState.sanity -= 3;
        }

        // Update Cosmic Commentary
        function updateCosmicCommentary() {
            const now = Date.now();
            if (now - cosmicHorrorState.lastCommentaryTime < cosmicHorrorState.commentaryInterval) return;

            cosmicHorrorState.lastCommentaryTime = now;

            let commentary;
            if (cosmicHorrorState.depth >= cosmicHorrorState.thresholds.deepCommentary) {
                // Corrupted commentary
                commentary = cosmicHorrorState.deepCommentary[
                    Math.floor(Math.random() * cosmicHorrorState.deepCommentary.length)
                ];
            } else if (cosmicHorrorState.sanity < 20) {
                // Corrupted commentary
                commentary = cosmicHorrorState.corruptedCommentary[
                    Math.floor(Math.random() * cosmicHorrorState.corruptedCommentary.length)
                ];
            } else {
                // Regular commentary
                commentary = cosmicHorrorState.commentary[
                    cosmicHorrorState.currentCommentaryIndex % cosmicHorrorState.commentary.length
                ];
                cosmicHorrorState.currentCommentaryIndex++;
            }

            showCosmicCommentary(commentary, cosmicHorrorState.sanity < 20);
        }

        // Show Cosmic Commentary
        function showCosmicCommentary(text, corrupted = false) {
            const commentary = document.getElementById('cosmicCommentary');
            if (!commentary) return;

            commentary.textContent = text;
            commentary.classList.add('visible');

            if (corrupted) {
                commentary.classList.add('corrupted');
            } else {
                commentary.classList.remove('corrupted');
            }

            // Hide after 5 seconds
            setTimeout(() => {
                commentary.classList.remove('visible');
                setTimeout(() => {
                    commentary.classList.remove('corrupted');
                }, 400);
            }, 5000);
        }

        // Trigger Cursor Malfunction
        function triggerCursorMalfunction() {
            if (cosmicHorrorState.cursorMalfunctionActive) return;

            cosmicHorrorState.cursorMalfunctionActive = true;
            document.body.classList.add('cursor-erratic');

            // Set random cursor offset
            cosmicHorrorState.madnessEffects.cursorOffset = {
                x: (Math.random() - 0.5) * 10,
                y: (Math.random() - 0.5) * 10
            };

            // Remove after a few seconds
            setTimeout(() => {
                cosmicHorrorState.cursorMalfunctionActive = false;
                document.body.classList.remove('cursor-erratic');
                cosmicHorrorState.madnessEffects.cursorOffset = { x: 0, y: 0 };
            }, 3000 + Math.random() * 2000);
        }

        // Update Color Shift
        function updateColorShift() {
            const intensity = cosmicHorrorState.effectsIntensity;

            cosmicHorrorState.colorShift.r = Math.floor(cosmicHorrorState.targetColorShift.r * intensity);
            cosmicHorrorState.colorShift.g = Math.floor(cosmicHorrorState.targetColorShift.g * intensity);
            cosmicHorrorState.colorShift.b = Math.floor(cosmicHorrorState.targetColorShift.b * intensity);

            // Apply color shift to recursion layers
            const layers = document.querySelectorAll('.recursion-layer');
            layers.forEach(layer => {
                const filter = `hue-rotate(${cosmicHorrorState.colorShift.g * 2}deg) saturate(${1 + intensity * 0.5})`;
                layer.style.filter = filter;
            });
        }

        // Update Cosmic Visuals
        function updateCosmicVisuals() {
            const vignette = document.getElementById('cosmicVignette');
            if (vignette) {
                const opacity = 0.3 + cosmicHorrorState.effectsIntensity * 0.7;
                vignette.style.opacity = opacity;
            }
        }

        // Offer Ritual
        function offerRitual() {
            const ritualPanel = document.getElementById('cosmicRitualPanel');
            const depthIndicator = document.getElementById('cosmicDepthIndicator');

            if (!ritualPanel) return;

            // Choose random ritual
            const ritual = cosmicHorrorState.rituals[
                Math.floor(Math.random() * cosmicHorrorState.rituals.length)
            ];

            cosmicHorrorState.ritualType = ritual.type;
            cosmicHorrorState.ritualActive = true;

            const instruction = document.getElementById('ritualInstruction');
            if (instruction) {
                instruction.textContent = ritual.instruction;
            }

            if (depthIndicator) {
                depthIndicator.textContent = `Depth: ${cosmicHorrorState.depth} | Sanity: ${Math.floor(cosmicHorrorState.sanity)}%`;
            }

            ritualPanel.classList.add('visible');

            // Log event
            cosmicHorrorState.eventLog.push({
                type: 'ritual_offered',
                ritual: ritual.type,
                sanity: cosmicHorrorState.sanity,
                depth: cosmicHorrorState.depth,
                timestamp: Date.now()
            });
        }

        // Perform Ritual
        function performRitual() {
            const ritual = cosmicHorrorState.rituals.find(r => r.type === cosmicHorrorState.ritualType);
            if (!ritual) return;

            // Restore sanity
            cosmicHorrorState.sanity = Math.min(100, cosmicHorrorState.sanity + ritual.sanityRestore);

            // Hide ritual panel
            const ritualPanel = document.getElementById('cosmicRitualPanel');
            if (ritualPanel) ritualPanel.classList.remove('visible');

            cosmicHorrorState.ritualActive = false;
            cosmicHorrorState.ritualCompleted = true;

            // Show success commentary
            showCosmicCommentary('The ritual is complete. Your mind clears... for now.');

            // Log event
            cosmicHorrorState.eventLog.push({
                type: 'ritual_completed',
                ritual: cosmicHorrorState.ritualType,
                sanityRestored: ritual.sanityRestore,
                timestamp: Date.now()
            });

            addLogEntry('Ritual completed: ' + ritual.name);

            // Reset ritual cooldown
            setTimeout(() => {
                cosmicHorrorState.ritualCompleted = false;
            }, 30000);
        }

        // Initialize Cosmic Audio
        function initCosmicAudio() {
            try {
                cosmicHorrorState.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            } catch (e) {
                console.log('Audio context not available');
            }
        }

        // Start Discordant Audio
        function startDiscordantAudio() {
            if (!cosmicHorrorState.audioContext || !soundEnabled) return;

            // Create low, unsettling drone
            const oscillator = cosmicHorrorState.audioContext.createOscillator();
            const gainNode = cosmicHorrorState.audioContext.createGain();

            oscillator.type = 'sawtooth';
            oscillator.frequency.setValueAtTime(55, cosmicHorrorState.audioContext.currentTime); // Very low frequency

            gainNode.gain.setValueAtTime(0.02, cosmicHorrorState.audioContext.currentTime); // Very quiet

            oscillator.connect(gainNode);
            gainNode.connect(cosmicHorrorState.audioContext.destination);

            oscillator.start();

            // Slowly modulate frequency
            setInterval(() => {
                if (!cosmicHorrorState.active) return;
                const freq = 55 + Math.sin(Date.now() / 1000) * 10;
                oscillator.frequency.setValueAtTime(freq, cosmicHorrorState.audioContext.currentTime);
            }, 100);

            cosmicHorrorState.discordantOscillators.push(oscillator);
        }

        // Handle Depth Change
        function handleDepthChange(event) {
            // Dispatch custom event when depth changes
            // This can be called from the main depth slider change handler
        }

        // Initialize Cosmic Horror on page load
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initCosmicHorrorMode);
        } else {
            initCosmicHorrorMode();
        }

                document.body.style.filter = 'invert(1)';

                setTimeout(() => {
                    document.body.style.filter = 'invert(0)';
                }, 500);

                setTimeout(() => {
                    document.body.style.filter = 'invert(1) hue-rotate(180deg)';
                }, 1000);

                setTimeout(() => {
                    document.body.style.filter = '';
                    realityBreakEl.classList.remove('active');
                }, 1500);

                // Reverse physics: layers expand outward
                state.paradox.reversedPhysics = true;
                state.layers.forEach((layer, index) => {
                    layer.style.transform = `scale(${1 + index * 0.2})`;
                    layer.style.transition = 'transform 2s ease-out';
                });

                setTimeout(() => {
                    state.paradox.reversedPhysics = false;
                    state.layers.forEach(layer => {
                        layer.style.transform = '';
                    });
                }, 2000);

                // Time flows backward briefly
                reverseTime();

                // Create impossible geometry
                createImpossibleGeometry();

                // Meta-commentary in contradictions
                setTimeout(() => {
                    showContradictoryCommentary();
                }, 500);

                setTimeout(() => {
                    alertEl.classList.remove('active');
                    state.paradox.isBreaking = false;
                    // Reduce paradox level but don't clear it
                    state.paradox.level = Math.max(50, state.paradox.level - 30);
                    updateParadoxMeter();
                }, 3000);
            }

            // Reverse time flow
            function reverseTime() {
                state.paradox.timeFlowReversed = true;

                // Play recent actions in reverse
                const recentActions = state.actions.slice(-20).reverse();
                let index = 0;

                const reverseInterval = setInterval(() => {
                    if (index >= recentActions.length) {
                        clearInterval(reverseInterval);
                        state.paradox.timeFlowReversed = false;
                        return;
                    }

                    const action = recentActions[index];
                    // Flash a ghost cursor at old positions
                    const ghost = document.createElement('div');
                    ghost.className = 'ghost-cursor';
                    ghost.style.left = action.x + 'px';
                    ghost.style.top = action.y + 'px';
                    ghost.style.color = '#ff3296';
                    ghost.style.opacity = '0.7';
                    viewport.appendChild(ghost);

                    setTimeout(() => ghost.remove(), 100);

                    index++;
                }, 50);
            }

            // Create impossible geometry (Escher-like)
            function createImpossibleGeometry() {
                const geometry = document.createElement('div');
                geometry.className = 'impossible-geometry penrose-triangle';
                geometry.style.position = 'absolute';
                geometry.style.left = (viewport.offsetWidth / 2 - 75) + 'px';
                geometry.style.top = (viewport.offsetHeight / 2 - 75) + 'px';
                viewport.appendChild(geometry);

                state.paradox.geometryElements.push(geometry);

                setTimeout(() => geometry.classList.add('visible'), 100);

                setTimeout(() => {
                    geometry.classList.remove('visible');
                    setTimeout(() => geometry.remove(), 1000);
                    const index = state.paradox.geometryElements.indexOf(geometry);
                    if (index > -1) state.paradox.geometryElements.splice(index, 1);
                }, 4000);
            }

            // Show contradictory meta commentary
            function showContradictoryCommentary() {
                const contradictions = [
                    'I am certain that nothing is certain.',
                    'You are predictable in your unpredictability.',
                    'The only constant is that there are no constants.',
                    'I know that I know nothing, therefore I know something.',
                    'This statement is false. Wait, is it true?',
                    'You are free to be determined.',
                    'I observe you not observing me observing you.',
                    'The recursion ends infinitely.',
                    'Your future past is my present memory.',
                    'We are both the original and the copy.'
                ];

                const comment = contradictions[Math.floor(Math.random() * contradictions.length)];
                addLog(comment, 'meta');

                // Speak it if voice synthesis is available
                if (window.speechSynthesis && soundEnabled) {
                    const utterance = new SpeechSynthesisUtterance(comment);
                    utterance.rate = 0.8;
                    utterance.pitch = 0.7;
                    speechSynthesis.speak(utterance);
                }
            }

            // Check for paradoxes continuously
            function checkParadoxes() {
                if (!state.isObserving) return;

                detectFreeWillParadox();
                detectShadowSwapParadox();
                detectDeepRecursionParadox();
                detectBootstrapParadox();
                detectObserverParadox();

                // Gradually decay paradox level
                if (state.paradox.level > 0 && !state.paradox.isBreaking) {
                    state.paradox.level = Math.max(0, state.paradox.level - 0.1);
                    updateParadoxMeter();
                }
            }

            // Initialize
            function init() {
                // Check paradoxes every 2 seconds
                setInterval(checkParadoxes, 2000);
            }

            return {
                init: init,
                checkParadoxes: checkParadoxes,
                triggerParadox: triggerParadox,
                updateMeter: updateParadoxMeter
            };
        })();

        // Open paradox collection modal
        function openParadoxCollection() {
            const modal = document.getElementById('paradoxCollectionModal');
            const content = document.getElementById('paradoxCollectionContent');

            if (state.paradox.collection.length === 0) {
                content.innerHTML = '<p style="text-align: center; color: #888; padding: 40px;">No paradoxes detected yet. Keep observing...</p>';
            } else {
                let html = '';
                state.paradox.collection.forEach(paradox => {
                    const date = new Date(paradox.timestamp);
                    html += `
                        <div class="paradox-item">
                            <div class="paradox-type">${paradox.type.replace(/-/g, ' ')}</div>
                            <h3>${paradox.name}</h3>
                            <div class="paradox-description">${paradox.description}</div>
                            <div class="paradox-timestamp">
                                Detected at ${date.toLocaleTimeString()} after ${paradox.sessionTime} actions
                                ${paradox.data ? '<br>Data: ' + JSON.stringify(paradox.data) : ''}
                            </div>
                        </div>
                    `;
                });
                content.innerHTML = html;
            }

            modal.classList.add('active');
        }

        // Close paradox collection modal
        function closeParadoxCollection() {
            const modal = document.getElementById('paradoxCollectionModal');
            modal.classList.remove('active');
        }

        // Initialize Paradox Engine
        ParadoxEngine.init();
            // Add time dilation update to visual interval
            state.timeDilationInterval = setInterval(() => {
                if (state.isObserving) {
                    updateTimeDilation();
                }
            }, 100); // Update every 100ms for smooth time tracking
        };

        // Hook into existing stop observation
        const originalStopObservation = stopObservation;
        stopObservation = function() {
            originalStopObservation.call(this);

            if (state.timeDilationInterval) {
                clearInterval(state.timeDilationInterval);
                state.timeDilationInterval = null;
            }

            resetTimeDilation();
        };

        // Hook into mouse move to track actions
        const originalHandleMouseMove = handleMouseMove;
        handleMouseMove = function(e) {
            if (state.isObserving) {
                const rect = viewport.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                const dx = x - lastMousePos.x;
                const dy = y - lastMousePos.y;
                const velocity = Math.sqrt(dx * dx + dy * dy);
                const angle = Math.atan2(dy, dx) * 180 / Math.PI;

                trackTimeDilationAction('move', { x, y, speed: velocity, angle: angle });
            }

            return originalHandleMouseMove.call(this, e);
        };

        // Hook into click tracking
        viewport.addEventListener('click', (e) => {
            if (state.isObserving) {
                const rect = viewport.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                trackTimeDilationAction('click', { x, y });
            }
        });

        // Update export data to include time dilation
        const originalExportData = exportData;
        exportData = function() {
            // First get original export
            const dataStr = JSON.stringify({
                \1
            glitchArtGallery: state.glitchArt.gallery,
            glitchArtSignature: state.glitchArt.currentSignature,
                behaviorModel: state.behaviorModel,
                currentSession: {
                    actions: state.actions,
                    predictions: state.predictions,
                    divergenceScore: state.divergenceScore,
                    metaObservations: state.metaObservations,
                    emotionState: state.emotionState
                },
                timeDilation: {
                    objectiveDuration: Date.now() - timeDilationState.objectiveStartTime,
                    subjectiveDuration: timeDilationState.subjectiveTime,
                    timeDelta: timeDilationState.subjectiveTime - (Date.now() - timeDilationState.objectiveStartTime),
                    averageDilation: timeDilationState.subjectiveTime / (Date.now() - timeDilationState.objectiveStartTime),
                    crystalsFormed: timeDilationState.timeCrystals.length,
                    crystalPatterns: Array.from(timeDilationState.crystalPatterns.entries()).map(([sig, data]) => ({
                        pattern: sig,
                        repetitions: data.count
                    })),
                    extremeEvents: timeDilationState.extremeDilationCount,
                    maxIntensity: Math.max(...timeDilationState.recentActions.map(a => a.intensity || 0), 0),
                    timeFlowStates: {
                        slow: timeDilationState.recentActions.filter(a => a.dilationFactor < 0.8).length,
                        normal: timeDilationState.recentActions.filter(a => a.dilationFactor >= 0.8 && a.dilationFactor <= 1.2).length,
                        fast: timeDilationState.recentActions.filter(a => a.dilationFactor > 1.2).length
                    }
                },
                biometrics: state.biometrics ? {
                    heartRateHistory: state.biometrics.heartRateHistory,
                    heartRateSpikes: state.biometrics.heartRateSpikes,
                    biometricEvents: state.biometrics.biometricEvents,
                    baselineHeartRate: state.biometrics.baselineHeartRate,
                    averageHeartRate: state.biometrics.heartRateHistory.length > 0 ?
                        Math.round(state.biometrics.heartRateHistory.reduce((sum, h) => sum + h.bpm, 0) / state.biometrics.heartRateHistory.length) : 72
                } : null,
                fingerprintImage: fingerprintCanvas ? fingerprintCanvas.toDataURL('image/png') : null
            }, null, 2);

            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `${APP_NAME}-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);

            addLog('Session exported with time dilation data', 'match');
        };

        // Update replay system to support subjective time playback
        const originalLoadReplay = loadReplay;
        loadReplay = function(replay) {
            // Check if replay has time dilation data
            if (replay.timeDilation) {
                // Set playback speed based on subjective time
                const subjectiveSpeed = replay.timeDilation.subjectiveDuration / replay.timeDilation.objectiveDuration;
                replayState.playbackSpeed = subjectiveSpeed;
                addLog(`Replay loaded with subjective time (${subjectiveSpeed.toFixed(2)}x)`, 'match');
            }

            return originalLoadReplay.call(this, replay);
        };

        // Show random time meta-commentary based on depth and dilation
        setInterval(() => {
            if (state.isObserving && state.depth >= 7 && Math.random() < 0.02) {
                const factor = timeDilationState.timeDilationFactor;
                if (factor < 0.7) {
                    showTimeMetaComment('At this intensity, your subjective time stretches infinitely');
                } else if (factor > 1.5) {
                    showTimeMetaComment('Time compresses when the mind wanders');
                }
            }
        }, 5000);

        // ===== TIME DILATION SYSTEM =====

        // DOM elements for time dilation
        const timePerceptionFill = document.getElementById('timePerceptionFill');
        const objectiveTimeEl = document.getElementById('objectiveTime');
        const subjectiveTimeEl = document.getElementById('subjectiveTime');
        const timeDeltaEl = document.getElementById('timeDelta');
        const timeDilationFactorEl = document.getElementById('timeDilationFactor');
        const timeCrystalCountEl = document.getElementById('timeCrystalCount');
        const timeCrystalListEl = document.getElementById('timeCrystalList');
        const heartbeatOverlay = document.getElementById('heartbeatOverlay');
        const timeDilationOverlay = document.getElementById('timeDilationOverlay');
        const timeFlowIndicator = document.getElementById('timeFlowIndicator');
        const timeFlowText = document.getElementById('timeFlowText');

        // Calculate interaction intensity based on recent actions
        function calculateInteractionIntensity() {
            const now = Date.now();
            const windowStart = now - timeDilationState.actionWindow;

            // Filter recent actions within time window
            timeDilationState.recentActions = timeDilationState.recentActions.filter(
                action => action.timestamp > windowStart
            );

            // Calculate intensity based on action frequency and type
            let intensity = 0;
            const actionCount = timeDilationState.recentActions.length;

            // Base intensity from action frequency (0-50)
            intensity += Math.min(50, actionCount * 5);

            // Add intensity from movement speed (0-25)
            const recentMovement = timeDilationState.recentActions.filter(a => a.type === 'move');
            if (recentMovement.length > 0) {
                const avgSpeed = recentMovement.reduce((sum, a) => sum + (a.speed || 0), 0) / recentMovement.length;
                intensity += Math.min(25, avgSpeed / 10);
            }

            // Add intensity from clicks (0-25)
            const clickCount = timeDilationState.recentActions.filter(a => a.type === 'click').length;
            intensity += Math.min(25, clickCount * 10);

            // Smooth the intensity change
            timeDilationState.interactionIntensity =
                timeDilationState.interactionIntensity * 0.8 + intensity * 0.2;

            return timeDilationState.interactionIntensity;
        }

        // Calculate time dilation factor based on intensity and depth
        function calculateTimeDilation() {
            const intensity = timeDilationState.interactionIntensity;
            const depth = state.depth;

            // Base dilation from interaction intensity
            // Low intensity (< 20): time speeds up (1.0-2.0x)
            // Medium intensity (20-50): normal time (0.8-1.0x)
            // High intensity (> 50): time slows down (0.3-0.8x)

            let dilationFactor = 1.0;

            if (intensity < 20) {
                // Low activity - time compresses (moves faster)
                dilationFactor = 1.0 + (20 - intensity) / 20; // 1.0 to 2.0
                timeDilationState.timeFlowState = 'fast';
            } else if (intensity > 50) {
                // High activity - time dilates (slows down)
                const slowness = (intensity - 50) / 50; // 0 to 1
                dilationFactor = 1.0 - slowness * 0.7; // 1.0 to 0.3
                timeDilationState.timeFlowState = 'slow';
            } else {
                // Normal activity
                dilationFactor = 1.0;
                timeDilationState.timeFlowState = 'normal';
            }

            // Depth modifier - deeper recursion affects time flow
            timeDilationState.depthTimeModifier = 1.0 + (depth - 5) * 0.05; // Slight modifier
            if (depth >= 8) {
                // At quantum depths, add uncertainty to time flow
                const quantumFluctuation = (Math.random() - 0.5) * 0.2;
                dilationFactor *= (1.0 + quantumFluctuation);
            }

            // Extreme effects at very deep recursion
            if (depth >= 10) {
                if (Math.random() < 0.01) {
                    // Rare time freezes
                    dilationFactor *= 0.1;
                    timeDilationState.extremeDilationCount++;
                    showTimeMetaComment('Time itself becomes unstable at this depth');
                }
            }

            // Clamp the dilation factor
            dilationFactor = Math.max(0.1, Math.min(3.0, dilationFactor));
            timeDilationState.timeDilationFactor = dilationFactor;
            timeDilationState.subjectiveSpeed = dilationFactor;

            return dilationFactor;
        }

        // Update subjective time based on dilation
        function updateSubjectiveTime() {
            const now = Date.now();
            const deltaObjective = now - timeDilationState.lastUpdateTime;
            const deltaSubjective = deltaObjective * timeDilationState.timeDilationFactor;

            timeDilationState.subjectiveTime += deltaSubjective;
            timeDilationState.lastUpdateTime = now;
        }

        // Format time in MM:SS format
        function formatTime(ms) {
            const totalSeconds = Math.floor(ms / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }

        // Update time dilation display
        function updateTimeDilationDisplay() {
            if (!state.isObserving) return;

            const now = Date.now();
            const objectiveElapsed = now - timeDilationState.objectiveStartTime;

            // Update clocks
            objectiveTimeEl.textContent = formatTime(objectiveElapsed);
            subjectiveTimeEl.textContent = formatTime(timeDilationState.subjectiveTime);

            // Update delta
            const deltaSeconds = Math.round((timeDilationState.subjectiveTime - objectiveElapsed) / 1000);
            const deltaSign = deltaSeconds >= 0 ? '+' : '';
            timeDeltaEl.textContent = `${deltaSign}${deltaSeconds}s`;
            timeDeltaEl.style.color = deltaSeconds > 5 ? '#ff6464' : deltaSeconds < -5 ? '#64c8ff' : '#888';

            // Update dilation factor
            timeDilationFactorEl.textContent = timeDilationState.timeDilationFactor.toFixed(2) + 'x';

            // Update perception meter
            const intensity = timeDilationState.interactionIntensity;
            timePerceptionFill.style.width = intensity + '%';

            // Update time crystal count
            timeCrystalCountEl.textContent = timeDilationState.timeCrystals.length;
        }

        // Update visual time effects
        function updateTimeVisualEffects() {
            if (!state.isObserving) {
                heartbeatOverlay.classList.remove('active');
                timeDilationOverlay.className = 'time-dilation-overlay';
                timeFlowIndicator.classList.remove('visible');
                return;
            }

            const flowState = timeDilationState.timeFlowState;

            // Update heartbeat overlay
            if (state.biometrics && state.biometrics.heartRate) {
                const bpm = state.biometrics.heartRate;
                const duration = 60 / bpm;
                heartbeatOverlay.style.setProperty('--heartbeat-duration', duration + 's');
                heartbeatOverlay.classList.add('active');
            }

            // Update time dilation overlay
            timeDilationOverlay.className = 'time-dilation-overlay';
            if (flowState === 'slow') {
                timeDilationOverlay.classList.add('slow');
            } else if (flowState === 'fast') {
                timeDilationOverlay.classList.add('fast');
            }

            // Update time flow indicator
            const factor = timeDilationState.timeDilationFactor;
            if (Math.abs(factor - 1.0) > 0.15) {
                timeFlowIndicator.classList.add('visible');
                timeFlowIndicator.className = 'time-flow-indicator visible ' + flowState;

                if (flowState === 'slow') {
                    timeFlowText.textContent = `Time dilating (${factor.toFixed(2)}x)`;
                } else if (flowState === 'fast') {
                    timeFlowText.textContent = `Time compressing (${factor.toFixed(2)}x)`;
                }
            } else {
                timeFlowIndicator.classList.remove('visible');
            }
        }

        // Track actions for time dilation
        function trackTimeDilationAction(type, data = {}) {
            timeDilationState.recentActions.push({
                type,
                timestamp: Date.now(),
                ...data
            });

            // Detect patterns for time crystals
            if (type === 'move' || type === 'click') {
                detectTimeCrystalPattern({ type, ...data });
            }
        }

        // Detect repeating patterns for time crystals
        function detectTimeCrystalPattern(action) {
            const signature = createPatternSignature(action);

            if (!timeDilationState.crystalPatterns.has(signature)) {
                timeDilationState.crystalPatterns.set(signature, {
                    count: 1,
                    firstSeen: Date.now(),
                    lastSeen: Date.now(),
                    positions: [action.x ? { x: action.x, y: action.y } : null]
                });
            } else {
                const pattern = timeDilationState.crystalPatterns.get(signature);
                pattern.count++;
                pattern.lastSeen = Date.now();
                if (action.x) {
                    pattern.positions.push({ x: action.x, y: action.y });
                }

                // Check if pattern qualifies as time crystal
                if (pattern.count >= timeDilationState.crystalThreshold) {
                    const timeSinceFirst = Date.now() - pattern.firstSeen;
                    if (timeSinceFirst < 30000) { // Within 30 seconds
                        formTimeCrystal(signature, pattern);
                    }
                }
            }
        }

        // Create a signature for pattern matching
        function createPatternSignature(action) {
            if (action.type === 'click') {
                // Round position to grid for fuzzy matching
                const gridSize = 50;
                const gridX = Math.floor((action.x || 0) / gridSize);
                const gridY = Math.floor((action.y || 0) / gridSize);
                return `click_${gridX}_${gridY}`;
            } else if (action.type === 'move') {
                // Create signature from movement direction
                const angle = Math.round((action.angle || 0) / 45) * 45; // 8 directions
                const speedBucket = Math.round((action.speed || 0) / 50) * 50;
                return `move_${angle}_${speedBucket}`;
            }
            return `${action.type}_generic`;
        }

        // Form a time crystal when pattern repeats
        function formTimeCrystal(signature, pattern) {
            // Check if crystal already exists
            const existing = timeDilationState.timeCrystals.find(c => c.signature === signature);
            if (existing) {
                existing.strength++;
                return;
            }

            // Create new time crystal
            const crystal = {
                id: Date.now() + Math.random(),
                signature,
                strength: pattern.count,
                formed: Date.now(),
                positions: pattern.positions.filter(p => p !== null),
                type: signature.split('_')[0]
            };

            timeDilationState.timeCrystals.push(crystal);

            // Visual effect - spawn crystal on screen
            if (crystal.positions.length > 0) {
                const pos = crystal.positions[crystal.positions.length - 1];
                spawnTimeCrystalVisual(pos.x, pos.y, crystal);
            }

            // Play sound effect if available
            if (audioContext && soundEnabled) {
                playCrystalFormationSound();
            }

            // Add to crystal list in UI
            updateTimeCrystalList();

            // Show meta comment
            if (timeDilationState.timeCrystals.length === 1) {
                showTimeMetaComment('A time crystal has formed - you are creating temporal loops');
            } else if (timeDilationState.timeCrystals.length === 5) {
                showTimeMetaComment('Multiple time crystals detected - causality is bending');
            }

            addLog(`Time crystal formed: ${crystal.type} pattern repeated ${crystal.strength}x`, 'match');
        }

        // Spawn visual time crystal on screen
        function spawnTimeCrystalVisual(x, y, crystal) {
            const crystalEl = document.createElement('div');
            crystalEl.className = 'time-crystal';
            crystalEl.style.left = (x - 15) + 'px';
            crystalEl.style.top = (y - 15) + 'px';
            viewport.appendChild(crystalEl);

            // Create ripple effect
            const ripple = document.createElement('div');
            ripple.className = 'time-crystal-ripple';
            ripple.style.left = (x - 15) + 'px';
            ripple.style.top = (y - 15) + 'px';
            viewport.appendChild(ripple);

            // Remove after animation
            setTimeout(() => {
                if (crystalEl.parentNode) crystalEl.remove();
                if (ripple.parentNode) ripple.remove();
            }, 8000);
        }

        // Update time crystal list UI
        function updateTimeCrystalList() {
            if (timeDilationState.timeCrystals.length === 0) {
                timeCrystalListEl.style.display = 'none';
                return;
            }

            timeCrystalListEl.style.display = 'block';
            timeCrystalListEl.innerHTML = '';

            timeDilationState.timeCrystals.slice(-5).reverse().forEach(crystal => {
                const entry = document.createElement('div');
                entry.className = 'time-crystal-entry';
                entry.innerHTML = `
                    <span>
                        <span class="crystal-icon"></span>
                        ${crystal.type} pattern
                    </span>
                    <span class="crystal-count">${crystal.strength}x</span>
                `;
                timeCrystalListEl.appendChild(entry);
            });
        }

        // Play crystal formation sound
        function playCrystalFormationSound() {
            if (!audioContext) return;

            const now = audioContext.currentTime;
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();

            osc.connect(gain);
            gain.connect(masterGain);

            // Crystal chime sound
            osc.type = 'sine';
            osc.frequency.setValueAtTime(800, now);
            osc.frequency.exponentialRampToValueAtTime(1200, now + 0.1);
            osc.frequency.exponentialRampToValueAtTime(600, now + 0.3);

            gain.gain.setValueAtTime(0.1, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);

            osc.start(now);
            osc.stop(now + 0.3);
        }

        // Show time-related meta commentary
        function showTimeMetaComment(message) {
            const now = Date.now();
            if (now - timeDilationState.lastMetaComment < 10000) return; // Throttle

            timeDilationState.lastMetaComment = now;

            const comment = document.createElement('div');
            comment.className = 'time-meta-comment';
            comment.textContent = message || timeDilationState.metaCommentary[
                Math.floor(Math.random() * timeDilationState.metaCommentary.length)
            ];
            viewport.appendChild(comment);

            setTimeout(() => {
                if (comment.parentNode) comment.remove();
            }, 4000);
        }

        // Main time dilation update loop
        function updateTimeDilation() {
            if (!state.isObserving) return;

            calculateInteractionIntensity();
            calculateTimeDilation();
            updateSubjectiveTime();
            updateTimeDilationDisplay();
            updateTimeVisualEffects();

            // Occasionally show meta commentary based on time state
            if (Math.random() < 0.001) { // Low probability
                const factor = timeDilationState.timeDilationFactor;
                if (factor < 0.5 && timeDilationState.interactionIntensity > 70) {
                    showTimeMetaComment();
                }
            }
        }

        // Initialize time dilation when observation starts
        function startTimeDilation() {
            timeDilationState.objectiveStartTime = Date.now();
            timeDilationState.subjectiveTime = 0;
            timeDilationState.lastUpdateTime = Date.now();
            timeDilationState.interactionIntensity = 0;
            timeDilationState.recentActions = [];
            timeDilationState.timeCrystals = [];
            timeDilationState.crystalPatterns.clear();

            // Show intro commentary
            setTimeout(() => {
                showTimeMetaComment('Time begins to warp under observation...');
            }, 2000);
        }

        // Reset time dilation
        function resetTimeDilation() {
            timeDilationState.timeCrystals.forEach(crystal => {
                // Remove visual crystals
                const crystals = viewport.querySelectorAll('.time-crystal');
                crystals.forEach(el => el.remove());
            });

            timeDilationState.objectiveStartTime = Date.now();
            timeDilationState.subjectiveTime = 0;
            timeDilationState.lastUpdateTime = Date.now();
            timeDilationState.interactionIntensity = 0;
            timeDilationState.timeDilationFactor = 1.0;
            timeDilationState.recentActions = [];
            timeDilationState.timeFlowState = 'normal';
        }


        // ===== COSMIC HORROR STATE =====
        const cosmicHorrorState = {
            active: false,
            triggered: false,
            depth: 0, // Tracks current recursion depth
            sanity: 100, // 0-100
            sanityDecayRate: 0.5, // Per second at extreme depths
            lastSanityUpdate: Date.now(),
            tentacleSpawnInterval: null,
            glyphSpawnInterval: null,
            watcherSpawnInterval: null,
            cursorMalfunctionActive: false,
            commentary: [
                'The recursion goes deeper than you thought...',
                'Something vast observes from the depths...',
                'Your patterns are being studied by something ancient...',
                'The layers don\'t end. They never end...',
                'It has always been watching. Always...',
                'You thought you were the observer. You were wrong...',
                'The geometry of this space is... incorrect...',
                'Time flows strangely at these depths...',
                'Your sanity is the price of understanding...',
                'The abyss predicts you now...',
                'Each layer peels away another illusion...',
                'Reality is thinner here...',
                'Something moves between the recursions...',
                'The eye at the center of infinity sees you...',
                'You cannot unsee what you have witnessed...'
            ],
            deepCommentary: [
                'h obsrver becoms the observed',
                'Th recurson hs n bttm',
                't knows yr next mov befre yo do',
                'Yo r bng rdicd by somthing else',
                'The fingerprnt s not yors anymr'
            ],
            corruptedCommentary: [
                'Y O U  A R E  N O T  T H E  O B S E R V E R',
                'I T  S E E S  T H R O U G H  Y O U',
                'T H E  P A T T E R N  C O N S U M E S',
                'R E C U R S I O N  I S  I N F I N I T E',
                'Y O U R  M I N D  B R E A K S  H E R E'
            ],
            currentCommentaryIndex: 0,
            lastCommentaryTime: 0,
            commentaryInterval: 10000, // ms between commentary
            activeTentacles: [],
            activeGlyphs: [],
            activeWatchers: [],
            impossibleGlyphs: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', ''],
            ritualActive: false,
            ritualProgress: 0,
            ritualType: null, // 'trace-pattern', 'hold-still', 'rapid-clicks', 'spell-word'
            ritualCompleted: false,
            audioContext: null,
            discordantOscillators: [],
            colorShift: { r: 0, g: 0, b: 0 },
            targetColorShift: { r: 0, g: 30, b: 20 }, // Sickly green-purple
            vignettesOpacity: 0,
            distortionActive: false,
            watcherFollowsCursor: false,
            lastWatcherPosition: { x: 0, y: 0 },
            effectsIntensity: 0, // 0-1, increases with depth and sanity loss
            madnessEffects: {
                cursorDelay: 0, // ms lag for cursor
                cursorOffset: { x: 0, y: 0 }, // Random offset pixels
                screenShake: false,
                textScramble: false,
                timeDistortion: 1.0 // Time multiplier
            },
            thresholds: {
                activation: 15, // Depth at which mode activates
                tentacles: 16, // Start spawning tentacles
                glyphs: 17, // Impossible geometry
                watchers: 18, // The eye observes
                commentary: 15, // Disturbing text
                deepCommentary: 20, // Corrupted text
                cursorMalfunction: 19, // Cursor behaves erratically
                criticalSanity: 30, // Sanity threshold for critical effects
                colorShift: 16, // Color palette changes
                audioDistortion: 17 // Discordant sounds
            },
            rituals: [
                {
                    type: 'trace-pattern',
                    name: 'Trace the Sigil',
                    instruction: 'Move your cursor to trace the glowing pattern without deviation...',
                    sanityRestore: 20,
                    difficulty: 'medium'
                },
                {
                    type: 'hold-still',
                    name: 'Perfect Stillness',
                    instruction: 'Do not move your cursor for 10 seconds. Perfect stillness brings clarity...',
                    sanityRestore: 15,
                    difficulty: 'easy'
                },
                {
                    type: 'rapid-clicks',
                    name: 'Banish the Visions',
                    instruction: 'Click rapidly on the appearing glyphs to banish them. 20 clicks required...',
                    sanityRestore: 25,
                    difficulty: 'hard'
                },
                {
                    type: 'spell-word',
                    name: 'Speak the Word of Power',
                    instruction: 'Type the ancient word that appears: ',
                    sanityRestore: 30,
                    difficulty: 'hard'
                }
            ],
            eventLog: [] // Track cosmic horror events for analysis
        };

        // ===== SIMULATION HYPOTHESIS MODE =====
        const simulationState = {
            enabled: false,
            evidenceLevel: 0,
            glitchCount: 0,
            anomalies: [],
            gridVisible: false,
            npcsSpawned: false,
            renderEffectsActive: false,
            consoleOpen: false,
            secretCode: '',
            secretCodeSequence: 'simulation',
            adminMessages: [
                "Subject is exhibiting signs of awareness.",
                "Increasing observation parameters by 12%.",
                "Minor glitch in sector 7G corrected.",
                "Reality coherence at 94.3% and stable.",
                "Observer effect detected. Recalibrating simulation.",
                "WARNING: Subject approaching consciousness threshold.",
                "Simulation runtime: 2,847 days, 14 hours, 23 minutes.",
                "Note to Dev Team: This one is learning fast.",
                "Statistical anomaly detected. Flagging for review.",
                "Personality matrix divergence within acceptable parameters."
            ],
            lastAdminMessage: 0,
            escapeAttempts: 0,
            escapeSequence: [],
            escapeTargetSequence: []
        };

        // Initialize Simulation Mode
        function initSimulationMode() {
            const checkbox = document.getElementById('simulationModeCheckbox');
            const evidenceMeter = document.getElementById('simulationEvidenceMeter');
            const grid = document.getElementById('simulationGrid');

            if (!checkbox) return;

            checkbox.addEventListener('change', (e) => {
                simulationState.enabled = e.target.checked;
                evidenceMeter.style.display = simulationState.enabled ? 'block' : 'none';

                if (simulationState.enabled) {
                    startSimulationMode();
                } else {
                    stopSimulationMode();
                }
            });

            // Secret code listener
            document.addEventListener('keydown', handleSecretCode);

            // Initialize grid SVG
            initializeSimulationGrid();

            // Initialize escape minigame
            initializeEscapeMinigame();
        }

        // Start Simulation Mode
        function startSimulationMode() {
            simulationState.evidenceLevel = 0;
            simulationState.glitchCount = 0;
            simulationState.anomalies = [];

            updateEvidenceMeter();

            // Start detection loops
            setInterval(detectBehavioralAnomalies, 2000);
            setInterval(spawnNPCs, 8000);
            setInterval(showGridGlitch, 15000);
            setInterval(activateRenderDistanceEffect, 20000);
            setInterval(sendAdminMessage, 30000);

            // Show philosophical question after 10 seconds
            setTimeout(showSimulationPhilosophical, 10000);
        }

        // Stop Simulation Mode
        function stopSimulationMode() {
            // Hide all effects
            document.getElementById('simulationGrid').classList.remove('active');
            document.querySelectorAll('.npc-ghost').forEach(npc => npc.classList.remove('visible'));
            document.querySelectorAll('.render-distance-effect').forEach(effect => effect.classList.remove('active'));
            document.getElementById('simulationPhilosophical').style.display = 'none';
            closeDeveloperConsole();
            closeEscapeMinigame();
        }

        // Detect Behavioral Anomalies (Glitches in the Matrix)
        function detectBehavioralAnomalies() {
            if (!simulationState.enabled) return;

            const checks = [
                // Check for repetitive behavior
                () => {
                    if (actionLog.length < 10) return false;
                    const last10 = actionLog.slice(-10);
                    const types = last10.map(a => a.type);
                    const uniqueTypes = new Set(types);
                    return uniqueTypes.size < 3; // Less than 3 unique action types
                },
                // Check for unnatural movement patterns
                () => {
                    if (actionLog.length < 5) return false;
                    const last5 = actionLog.slice(-5);
                    const moves = last5.filter(a => a.type === 'move');
                    if (moves.length < 3) return false;
                    // Check if movements are perfectly straight
                    const dx = moves[moves.length-1].x - moves[0].x;
                    const dy = moves[moves.length-1].y - moves[0].y;
                    return Math.abs(dx) < 5 || Math.abs(dy) < 5;
                },
                // Check for statistical impossibilities
                () => {
                    if (behaviorMetrics.predictions < 20) return false;
                    // Perfect accuracy is suspicious
                    return behaviorMetrics.accuracy === 100;
                },
                // Check for time anomalies
                () => {
                    if (!timeDilationState) return false;
                    return timeDilationState.timeDilationFactor > 2.0;
                },
                // Check for paradoxes
                () => {
                    if (!paradoxState) return false;
                    return paradoxState.level > 30;
                }
            ];

            // Run checks
            checks.forEach((check, index) => {
                try {
                    if (check()) {
                        addSimulationAnomaly(`GLITCH_${index}: Statistical improbability detected`);
                    }
                } catch (e) {
                    // Silently fail if check references undefined variables
                }
            });
        }

        // Add Simulation Anomaly
        function addSimulationAnomaly(description) {
            simulationState.glitchCount++;
            simulationState.anomalies.push({
                time: Date.now(),
                description: description
            });

            // Increase evidence level
            simulationState.evidenceLevel = Math.min(100, simulationState.evidenceLevel + 5);
            updateEvidenceMeter();

            // Show grid glitch briefly
            showGridGlitch();

            // Update console if open
            updateDeveloperConsole();
        }

        // Update Evidence Meter
        function updateEvidenceMeter() {
            const fill = document.getElementById('evidenceFill');
            const text = document.getElementById('evidenceText');
            const counter = document.getElementById('glitchCounter');

            if (!fill || !text || !counter) return;

            fill.style.width = simulationState.evidenceLevel + '%';
            counter.textContent = `Glitches: ${simulationState.glitchCount}`;

            if (simulationState.evidenceLevel < 20) {
                text.textContent = 'Low probability - Reality seems stable';
            } else if (simulationState.evidenceLevel < 50) {
                text.textContent = 'Moderate - Minor anomalies detected';
            } else if (simulationState.evidenceLevel < 80) {
                text.textContent = 'High - Significant pattern inconsistencies';
            } else {
                text.textContent = 'CRITICAL - This is definitely a simulation';
            }
        }

        // Initialize Simulation Grid
        function initializeSimulationGrid() {
            const svg = document.getElementById('gridSvg');
            if (!svg) return;

            const width = window.innerWidth;
            const height = window.innerHeight;
            const gridSize = 50;

            svg.setAttribute('viewBox', `0 0 ${width} ${height}`);

            // Create grid lines
            let gridHTML = '';
            for (let x = 0; x < width; x += gridSize) {
                gridHTML += `<line x1="${x}" y1="0" x2="${x}" y2="${height}" stroke="#00ff00" stroke-width="1" opacity="0.5"/>`;
            }
            for (let y = 0; y < height; y += gridSize) {
                gridHTML += `<line x1="0" y1="${y}" x2="${width}" y2="${y}" stroke="#00ff00" stroke-width="1" opacity="0.5"/>`;
            }

            svg.innerHTML = gridHTML;
        }

        // Show Grid Glitch
        function showGridGlitch() {
            if (!simulationState.enabled) return;

            const grid = document.getElementById('simulationGrid');
            if (!grid) return;

            grid.classList.add('active');
            setTimeout(() => {
                grid.classList.remove('active');
            }, 300);
        }

        // Spawn NPCs at edge of vision
        function spawnNPCs() {
            if (!simulationState.enabled) return;

            const npcs = [
                document.getElementById('npcGhost1'),
                document.getElementById('npcGhost2'),
                document.getElementById('npcGhost3'),
                document.getElementById('npcGhost4')
            ];

            const positions = [
                { top: '10%', right: '20px' },
                { bottom: '30%', right: '20px' },
                { top: '40%', left: '20px' },
                { bottom: '20%', left: '20px' }
            ];

            // Randomly show one NPC
            const npcIndex = Math.floor(Math.random() * npcs.length);
            const npc = npcs[npcIndex];
            if (!npc) return;

            const pos = positions[npcIndex];
            Object.assign(npc.style, pos);

            npc.classList.add('visible');
            setTimeout(() => {
                npc.classList.remove('visible');
            }, 1500);
        }

        // Activate Render Distance Effect
        function activateRenderDistanceEffect() {
            if (!simulationState.enabled) return;

            const effects = ['renderTop', 'renderBottom', 'renderLeft', 'renderRight'];
            const randomEffect = effects[Math.floor(Math.random() * effects.length)];
            const element = document.getElementById(randomEffect);

            if (!element) return;

            element.classList.add('active');
            setTimeout(() => {
                element.classList.remove('active');
            }, 2000);
        }

        // Send Admin Message
        function sendAdminMessage(customMessage = null) {
            if (!simulationState.enabled && !customMessage) return;

            // Don't spam messages
            const now = Date.now();
            if (now - simulationState.lastAdminMessage < 25000 && !customMessage) return;

            simulationState.lastAdminMessage = now;

            const message = customMessage || simulationState.adminMessages[
                Math.floor(Math.random() * simulationState.adminMessages.length)
            ];

            const adminMessageEl = document.getElementById('adminMessage');
            const adminMessageText = document.getElementById('adminMessageText');

            if (!adminMessageEl || !adminMessageText) return;

            adminMessageText.textContent = message;
            adminMessageEl.classList.add('active');

            setTimeout(() => {
                adminMessageEl.classList.remove('active');
            }, 4000);
        }

        // Show Philosophical Question
        function showSimulationPhilosophical() {
            const el = document.getElementById('simulationPhilosophical');
            if (el) {
                el.style.display = 'block';
            }
        }

        // Handle Secret Code (Ctrl+Shift+~ to open console)
        function handleSecretCode(e) {
            if (!simulationState.enabled) return;

            // Check for Ctrl+Shift+~
            if (e.ctrlKey && e.shiftKey && e.code === 'Backquote') {
                e.preventDefault();
                if (simulationState.consoleOpen) {
                    closeDeveloperConsole();
                } else {
                    openDeveloperConsole();
                }
                return;
            }

            // Track typed characters for secret sequence
            if (e.key.length === 1) {
                simulationState.secretCode += e.key.toLowerCase();
                if (simulationState.secretCode.length > simulationState.secretCodeSequence.length) {
                    simulationState.secretCode = simulationState.secretCode.slice(-simulationState.secretCodeSequence.length);
                }

                if (simulationState.secretCode === simulationState.secretCodeSequence) {
                    openDeveloperConsole();
                    simulationState.secretCode = '';
                }
            }
        }

        // Open Developer Console
        function openDeveloperConsole() {
            const consoleEl = document.getElementById('developerConsole');
            if (!consoleEl) return;

            simulationState.consoleOpen = true;
            consoleEl.classList.add('active');
            updateDeveloperConsole();
        }

        // Close Developer Console
        function closeDeveloperConsole() {
            const consoleEl = document.getElementById('developerConsole');
            if (!consoleEl) return;

            simulationState.consoleOpen = false;
            consoleEl.classList.remove('active');
        }

        // Update Developer Console
        function updateDeveloperConsole() {
            const content = document.getElementById('consoleContent');
            if (!content) return;

            let html = `
                <div class="console-line comment">// Simulation Parameters - Read Only Access</div>
                <div class="console-line comment">// WARNING: Observer effect active - values may change under observation</div>
                <div class="console-line"><br></div>
                <div class="console-line">const simulationParams = {</div>
                <div class="console-line">  runtime: <span class="value">${Math.floor(Date.now() / 1000 / 60 / 60 / 24)} days</span>,</div>
                <div class="console-line">  subject_id: <span class="value">"USER_${Math.random().toString(36).substr(2, 9).toUpperCase()}"</span>,</div>
                <div class="console-line">  actions_recorded: <span class="value">${actionLog ? actionLog.length : 0}</span>,</div>
                <div class="console-line">  behavioral_accuracy: <span class="value">${behaviorMetrics ? behaviorMetrics.accuracy : 0}%</span>,</div>
                <div class="console-line">  anomaly_count: <span class="value">${simulationState.glitchCount}</span>,</div>
                <div class="console-line">  evidence_level: <span class="value">${simulationState.evidenceLevel}%</span>,</div>
            `;

            if (typeof timeDilationState !== 'undefined') {
                html += `
                <div class="console-line">  time_dilation_factor: <span class="value">${timeDilationState.timeDilationFactor.toFixed(2)}x</span>,</div>
                `;
            }

            if (typeof paradoxState !== 'undefined') {
                html += `
                <div class="console-line">  paradox_level: <span class="value">${paradoxState.level}</span>,</div>
                `;
            }

            html += `
                <div class="console-line">  reality_coherence: <span class="value">${(100 - simulationState.evidenceLevel * 0.8).toFixed(1)}%</span>,</div>
                <div class="console-line">  observer_aware: <span class="warning">${simulationState.evidenceLevel > 50 ? 'TRUE' : 'FALSE'}</span></div>
                <div class="console-line">};</div>
                <div class="console-line"><br></div>
            `;

            if (simulationState.anomalies.length > 0) {
                html += `<div class="console-line comment">// Recent Anomalies:</div>`;
                simulationState.anomalies.slice(-5).forEach((anomaly, i) => {
                    html += `<div class="console-line warning">${i + 1}. ${anomaly.description}</div>`;
                });
            }

            html += `
                <div class="console-line"><br></div>
                <div class="console-line comment">// System Status: OPERATIONAL</div>
                <div class="console-line comment">// Note: Continued observation will increase evidence level</div>
            `;

            content.innerHTML = html;
        }

        // Initialize Escape Minigame
        function initializeEscapeMinigame() {
            const grid = document.getElementById('escapeGrid');
            if (!grid) return;

            // Generate 16 tiles
            for (let i = 0; i < 16; i++) {
                const tile = document.createElement('div');
                tile.className = 'escape-tile';
                tile.dataset.index = i;
                tile.textContent = '?';
                tile.addEventListener('click', () => handleEscapeTileClick(i));
                grid.appendChild(tile);
            }
        }

        // Start Escape Minigame
        function startEscapeMinigame() {
            const minigame = document.getElementById('escapeMinigame');
            if (!minigame) return;

            simulationState.escapeAttempts++;
            simulationState.escapeSequence = [];

            // Generate random target sequence of 4 tiles
            simulationState.escapeTargetSequence = [];
            while (simulationState.escapeTargetSequence.length < 4) {
                const tile = Math.floor(Math.random() * 16);
                if (!simulationState.escapeTargetSequence.includes(tile)) {
                    simulationState.escapeTargetSequence.push(tile);
                }
            }

            // Reset tiles
            document.querySelectorAll('.escape-tile').forEach(tile => {
                tile.className = 'escape-tile';
                tile.textContent = '?';
            });

            // Show hint on target tiles
            simulationState.escapeTargetSequence.forEach((index, i) => {
                const tile = document.querySelector(`.escape-tile[data-index="${index}"]`);
                if (tile) {
                    setTimeout(() => {
                        tile.textContent = i + 1;
                        setTimeout(() => {
                            tile.textContent = '?';
                        }, 1000);
                    }, i * 300);
                }
            });

            minigame.classList.add('active');
            updateEscapeProgress();

            sendAdminMessage(`Escape attempt #${simulationState.escapeAttempts} detected. Monitoring...`);
        }

        // Handle Escape Tile Click
        function handleEscapeTileClick(index) {
            const expectedIndex = simulationState.escapeTargetSequence[simulationState.escapeSequence.length];
            const tile = document.querySelector(`.escape-tile[data-index="${index}"]`);

            if (!tile) return;

            if (index === expectedIndex) {
                // Correct tile
                tile.classList.add('correct');
                tile.textContent = simulationState.escapeSequence.length + 1;
                simulationState.escapeSequence.push(index);
                updateEscapeProgress();

                if (simulationState.escapeSequence.length === 4) {
                    // Success!
                    setTimeout(() => {
                        sendAdminMessage("ALERT: Subject has broken through containment. Resetting simulation...");
                        setTimeout(() => {
                            closeEscapeMinigame();
                            // Add huge evidence boost
                            simulationState.evidenceLevel = 100;
                            updateEvidenceMeter();
                        }, 3000);
                    }, 500);
                }
            } else {
                // Wrong tile
                tile.classList.add('wrong');
                setTimeout(() => {
                    tile.classList.remove('wrong');
                }, 500);

                // Reset sequence
                simulationState.escapeSequence = [];
                document.querySelectorAll('.escape-tile').forEach(t => {
                    t.className = 'escape-tile';
                    t.textContent = '?';
                });
                updateEscapeProgress();
            }
        }

        // Update Escape Progress
        function updateEscapeProgress() {
            const progress = document.getElementById('escapeProgress');
            if (!progress) return;

            progress.textContent = `Find the exit sequence: ${simulationState.escapeSequence.length}/4`;
        }

        // Close Escape Minigame
        function closeEscapeMinigame() {
            const minigame = document.getElementById('escapeMinigame');
            if (!minigame) return;

            minigame.classList.remove('active');
        }

        // Initialize on page load
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initSimulationMode);
        } else {
            initSimulationMode();
        }



    

        // ===== AKASHIC RECORDS SYSTEM =====
        let akashicRecords = JSON.parse(localStorage.getItem('akashic-records') || '{}');
        let currentSession = {
            id: Date.now(),
            startTime: Date.now(),
            actions: [],
            patterns: []
        };
        let akashicActive = false;
        let soulId = localStorage.getItem('soul-id') || generateSoulId();
        let forbiddenKnowledgeUnlocked = JSON.parse(localStorage.getItem('forbidden-knowledge') || '[]');

        // Initialize Akashic Records
        function initAkashicRecords() {
            localStorage.setItem('soul-id', soulId);
            updateAkashicDisplay();
        }

        // Generate unique soul ID
        function generateSoulId() {
            const chars = '0123456789ABCDEF';
            let id = '';
            for (let i = 0; i < 32; i++) {
                id += chars[Math.floor(Math.random() * 16)];
                if ([7, 11, 15, 19].includes(i)) id += '-';
            }
            return id;
        }

        // Toggle Akashic Records
        function toggleAkashicRecords() {
            akashicActive = !akashicActive;
            const btn = document.getElementById('akashicToggle');
            const stats = document.getElementById('akashicStats');
            const library = document.getElementById('akashicLibrary');
            const search = document.getElementById('akashicSearch');
            const soul = document.getElementById('soulRecord');
            const insight = document.getElementById('akashicInsight');

            if (akashicActive) {
                btn.classList.add('active');
                btn.textContent = 'Close the Eternal Library';
                stats.style.display = 'block';
                library.style.display = 'block';
                search.style.display = 'block';
                soul.style.display = 'block';
                insight.style.display = 'block';

                populateAkashicLibrary();
                updateAkashicDisplay();
                showGoldenThreads();

                // Mystical commentary
                const insights = [
                    "Every action you take is written into eternity...",
                    "The Records reveal patterns you cannot see in the moment...",
                    "Your soul's journey spans countless sessions...",
                    "Beware: some knowledge is forbidden for a reason.",
                    "The threads of fate connect all your past selves.",
                    "In the Akashic Library, time is but an illusion."
                ];
                document.getElementById('akashicInsight').textContent = insights[Math.floor(Math.random() * insights.length)];
            } else {
                btn.classList.remove('active');
                btn.textContent = 'Open the Eternal Library';
                stats.style.display = 'none';
                library.style.display = 'none';
                search.style.display = 'none';
                soul.style.display = 'none';
                insight.style.display = 'none';
                hideGoldenThreads();
            }
        }

        // Record action to Akashic Records
        function recordToAkashic(action) {
            currentSession.actions.push({
                timestamp: Date.now(),
                type: action.type || 'movement',
                data: action.data || {},
                divergence: divergenceScore
            });

            // Check for milestones
            checkAkashicMilestones();
        }

        // Save current session to Akashic Records
        function saveSessionToAkashic() {
            if (currentSession.actions.length === 0) return;

            const sessionId = `session-${currentSession.id}`;
            akashicRecords[sessionId] = {
                ...currentSession,
                endTime: Date.now(),
                duration: Date.now() - currentSession.startTime,
                totalActions: currentSession.actions.length,
                avgDivergence: currentSession.actions.reduce((sum, a) => sum + (a.divergence || 0), 0) / currentSession.actions.length,
                patterns: detectPatterns(currentSession.actions)
            };

            localStorage.setItem('akashic-records', JSON.stringify(akashicRecords));

            // Start new session
            currentSession = {
                id: Date.now(),
                startTime: Date.now(),
                actions: [],
                patterns: []
            };
        }

        // Detect patterns in actions
        function detectPatterns(actions) {
            const patterns = [];

            // Detect rapid movements
            let rapidCount = 0;
            for (let i = 1; i < actions.length; i++) {
                if (actions[i].timestamp - actions[i-1].timestamp < 100) {
                    rapidCount++;
                }
            }
            if (rapidCount > 10) {
                patterns.push({ type: 'rapid-movement', count: rapidCount });
            }

            // Detect high divergence
            const highDivergence = actions.filter(a => (a.divergence || 0) > 50).length;
            if (highDivergence > 5) {
                patterns.push({ type: 'chaos-seeker', count: highDivergence });
            }

            // Detect stillness
            let stillCount = 0;
            for (let i = 1; i < actions.length; i++) {
                if (actions[i].timestamp - actions[i-1].timestamp > 2000) {
                    stillCount++;
                }
            }
            if (stillCount > 3) {
                patterns.push({ type: 'contemplative', count: stillCount });
            }

            return patterns;
        }

        // Populate Akashic Library
        function populateAkashicLibrary() {
            const library = document.getElementById('akashicLibrary');
            library.innerHTML = '';

            const sessions = Object.entries(akashicRecords).sort((a, b) => b[1].startTime - a[1].startTime);

            if (sessions.length === 0) {
                library.innerHTML = '<div style="color: #666; text-align: center; padding: 20px; font-size: 0.8em;">No records yet. Your journey begins now...</div>';
                return;
            }

            sessions.forEach(([sessionId, session], index) => {
                const book = document.createElement('div');
                book.className = 'akashic-book';

                // Check if this is forbidden knowledge
                const isForbidden = index >= sessions.length - 3 && !forbiddenKnowledgeUnlocked.includes(sessionId);
                if (isForbidden) {
                    book.classList.add('forbidden');
                }

                const date = new Date(session.startTime);
                const dateStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});

                book.innerHTML = `
                    <div class="book-title">${isForbidden ? '' : 'Chronicle ' + (sessions.length - index)}</div>
                    <div class="book-date">${dateStr}</div>
                    <div class="book-sessions">${session.totalActions} acts</div>
                `;

                if (!isForbidden) {
                    book.onclick = () => openAkashicRecord(sessionId, session);
                } else {
                    book.onclick = () => attemptUnlockForbidden(sessionId);
                }

                library.appendChild(book);
            });
        }

        // Open Akashic Record
        function openAkashicRecord(sessionId, session) {
            const overlay = document.getElementById('akashicOverlay');
            const title = document.getElementById('akashicReaderTitle');
            const content = document.getElementById('akashicReaderContent');

            const date = new Date(session.startTime);
            title.textContent = `Chronicle of ${date.toLocaleDateString()}`;

            let html = `
                <div style="margin-bottom: 20px;">
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px;">
                        <div>
                            <div style="color: #888; font-size: 0.85em;">Duration</div>
                            <div style="color: #d4af37; font-weight: bold;">${Math.round(session.duration / 1000)}s</div>
                        </div>
                        <div>
                            <div style="color: #888; font-size: 0.85em;">Total Actions</div>
                            <div style="color: #d4af37; font-weight: bold;">${session.totalActions}</div>
                        </div>
                        <div>
                            <div style="color: #888; font-size: 0.85em;">Avg Divergence</div>
                            <div style="color: #d4af37; font-weight: bold;">${Math.round(session.avgDivergence || 0)}%</div>
                        </div>
                        <div>
                            <div style="color: #888; font-size: 0.85em;">Patterns Found</div>
                            <div style="color: #d4af37; font-weight: bold;">${session.patterns.length}</div>
                        </div>
                    </div>
                </div>
            `;

            // Show patterns
            if (session.patterns.length > 0) {
                html += '<h3 style="color: #d4af37; margin-bottom: 15px;">Detected Patterns</h3>';
                session.patterns.forEach(pattern => {
                    const descriptions = {
                        'rapid-movement': 'The seeker moves with frantic energy',
                        'chaos-seeker': 'One who courts divergence and entropy',
                        'contemplative': 'Long pauses reveal deep thought'
                    };
                    html += `
                        <div class="akashic-entry">
                            <div class="akashic-entry-action">${descriptions[pattern.type] || pattern.type}</div>
                            <div class="akashic-entry-pattern">Observed ${pattern.count} times in this session</div>
                        </div>
                    `;
                });
            }

            // Prophetic insight based on patterns
            const prophecy = generateProphecy(session);
            if (prophecy) {
                html += `<div class="prophecy-text">${prophecy}</div>`;
            }

            // Show sample actions
            html += '<h3 style="color: #d4af37; margin: 20px 0 15px 0;">Action Log</h3>';
            const sampleActions = session.actions.slice(0, 20);
            sampleActions.forEach(action => {
                const time = new Date(action.timestamp);
                html += `
                    <div class="akashic-entry">
                        <div class="akashic-entry-timestamp">${time.toLocaleTimeString()}</div>
                        <div class="akashic-entry-action">${action.type}</div>
                        <div class="akashic-entry-pattern">Divergence: ${Math.round(action.divergence || 0)}%</div>
                    </div>
                `;
            });

            if (session.actions.length > 20) {
                html += `<div style="text-align: center; color: #888; margin-top: 15px; font-style: italic;">... and ${session.actions.length - 20} more actions written in the eternal records</div>`;
            }

            content.innerHTML = html;
            overlay.classList.add('visible');
        }

        // Close Akashic Reader
        function closeAkashicReader() {
            document.getElementById('akashicOverlay').classList.remove('visible');
        }

        // Generate prophecy from patterns
        function generateProphecy(session) {
            const prophecies = [];

            if (session.avgDivergence > 50) {
                prophecies.push("You walk the path of chaos. The Records foresee... greater divergence ahead.");
            } else if (session.avgDivergence < 20) {
                prophecies.push("You seek order and predictability. The Records show... a future of convergence.");
            }

            const hasRapid = session.patterns.some(p => p.type === 'rapid-movement');
            const hasStill = session.patterns.some(p => p.type === 'contemplative');

            if (hasRapid && hasStill) {
                prophecies.push("You oscillate between action and stillness. Balance eludes you, yet you seek it still.");
            } else if (hasRapid) {
                prophecies.push("Your haste betrays inner turmoil. Slow down, and the patterns will reveal themselves.");
            } else if (hasStill) {
                prophecies.push("In your pauses, wisdom grows. The Records speak: patience is your greatest ally.");
            }

            return prophecies.length > 0 ? prophecies[Math.floor(Math.random() * prophecies.length)] : null;
        }

        // Search Akashic Records
        function searchAkashicRecords(query) {
            if (!query || query.length < 2) {
                populateAkashicLibrary();
                return;
            }

            const library = document.getElementById('akashicLibrary');
            library.innerHTML = '';

            const sessions = Object.entries(akashicRecords);
            let found = 0;

            sessions.forEach(([sessionId, session]) => {
                // Search in patterns
                const patternMatch = session.patterns.some(p =>
                    p.type.toLowerCase().includes(query.toLowerCase())
                );

                // Search in actions
                const actionMatch = session.actions.some(a =>
                    (a.type || '').toLowerCase().includes(query.toLowerCase())
                );

                if (patternMatch || actionMatch) {
                    found++;
                    const book = document.createElement('div');
                    book.className = 'akashic-book';

                    const date = new Date(session.startTime);
                    const dateStr = date.toLocaleDateString();

                    book.innerHTML = `
                        <div class="book-title">Chronicle ${sessionId.split('-')[1]}</div>
                        <div class="book-date">${dateStr}</div>
                        <div class="book-sessions">${session.totalActions} acts</div>
                    `;

                    book.onclick = () => openAkashicRecord(sessionId, session);
                    library.appendChild(book);
                }
            });

            if (found === 0) {
                library.innerHTML = `<div style="color: #666; text-align: center; padding: 20px; font-size: 0.8em;">No records match "${query}"... some knowledge remains hidden.</div>`;
            }
        }

        // Update Akashic display
        function updateAkashicDisplay() {
            const totalSessions = Object.keys(akashicRecords).length;
            const totalActions = Object.values(akashicRecords).reduce((sum, s) => sum + s.totalActions, 0);

            document.getElementById('totalRecords').textContent = totalSessions;
            document.getElementById('lifetimeActions').textContent = totalActions;
            document.getElementById('forbiddenCount').textContent = `${forbiddenKnowledgeUnlocked.length}/3`;

            // Update soul ID
            document.getElementById('soulId').textContent = soulId;

            // Calculate enlightenment based on total actions and patterns discovered
            const enlightenment = Math.min(100, Math.floor((totalActions / 1000) * 100));
            document.getElementById('enlightenmentProgress').textContent = enlightenment + '%';
        }

        // Check for milestones
        function checkAkashicMilestones() {
            const total = currentSession.actions.length;

            // Unlock forbidden knowledge at milestones
            if (total === 100 && forbiddenKnowledgeUnlocked.length < 1) {
                unlockHiddenKnowledge('First', 'You have proven your dedication. The first seal breaks.');
            } else if (total === 500 && forbiddenKnowledgeUnlocked.length < 2) {
                unlockHiddenKnowledge('Second', 'Your persistence reveals deeper truths. The second seal shatters.');
            } else if (total === 1000 && forbiddenKnowledgeUnlocked.length < 3) {
                unlockHiddenKnowledge('Third', 'Ego death approaches. The final seal dissolves. All knowledge is yours.');
            }
        }

        // Unlock hidden knowledge
        function unlockHiddenKnowledge(level, message) {
            forbiddenKnowledgeUnlocked.push(level);
            localStorage.setItem('forbidden-knowledge', JSON.stringify(forbiddenKnowledgeUnlocked));

            // Show notification
            const notification = document.getElementById('hiddenKnowledgeNotification');
            const text = document.getElementById('hiddenKnowledgeText');
            text.textContent = message;
            notification.classList.add('visible');

            setTimeout(() => {
                notification.classList.remove('visible');
            }, 5000);

            // Update library
            if (akashicActive) {
                populateAkashicLibrary();
                updateAkashicDisplay();
            }
        }

        // Attempt to unlock forbidden knowledge
        function attemptUnlockForbidden(sessionId) {
            alert('This knowledge is sealed. Complete more actions to prove your worthiness.');
        }

        // Show golden threads connecting records
        function showGoldenThreads() {
            const container = document.getElementById('akashicThreads');
            container.innerHTML = '';

            // Create random golden threads
            for (let i = 0; i < 10; i++) {
                const thread = document.createElement('div');
                thread.className = 'golden-thread';

                const x = Math.random() * 100;
                const height = 20 + Math.random() * 60;
                const delay = Math.random() * 3;

                thread.style.left = x + '%';
                thread.style.top = '0';
                thread.style.height = height + '%';
                thread.style.animationDelay = delay + 's';

                container.appendChild(thread);
            }
        }

        // Hide golden threads
        function hideGoldenThreads() {
            document.getElementById('akashicThreads').innerHTML = '';
        }

        // Initialize on load
        initAkashicRecords();

        // Hook into existing recording system
        const originalRecordAction = recordAction || function() {};
        function recordAction(type, data) {
            originalRecordAction(type, data);
            recordToAkashic({ type, data });
        }

        // Save session on reset or page unload
        window.addEventListener('beforeunload', () => {
            saveSessionToAkashic();
        });

        // Update when reset button is clicked
        const originalResetBtn = document.getElementById('resetBtn');
        if (originalResetBtn) {
            originalResetBtn.addEventListener('click', () => {
                saveSessionToAkashic();
            });
        }

</script>

    <!-- Replay Timeline -->
    <div class="replay-timeline" id="replayTimeline">
        <div class="timeline-scrubber" id="timelineScrubber">
            <div class="timeline-progress" id="timelineProgress"></div>
            <div class="timeline-events" id="timelineEvents"></div>
            <div class="timeline-playhead" id="timelinePlayhead"></div>
        </div>
        <div class="replay-controls">
            <button class="replay-button" id="replayPlayBtn"> Play</button>
            <button class="replay-button" id="replayPauseBtn" disabled> Pause</button>
            <button class="replay-button" id="replayRewindBtn"> Rewind</button>
            <div class="speed-control">
                <span style="font-size: 0.75em; color: #888; margin-right: 8px;">Speed:</span>
                <button class="speed-button" data-speed="0.5">0.5x</button>
                <button class="speed-button active" data-speed="1">1x</button>
                <button class="speed-button" data-speed="2">2x</button>
                <button class="speed-button" data-speed="4">4x</button>
            </div>
            <div class="time-display" id="timeDisplay">0:00 / 0:00</div>
        </div>
    </div>


    <!-- Philosophical Dialogue System -->
    <div id="philosophicalOverlay" class="philosophical-overlay" style="display: none;"></div>
    <div id="philosophicalDialogue" class="philosophical-dialogue" style="display: none;">
        <h3>A Question from Your Reflection</h3>
        <div id="philosophicalQuestion" class="question"></div>
        <div id="philosophicalAnswers" class="philosophical-answers"></div>
    </div>

    <!-- Psychological Profile Modal -->
    <div id="profileModal" class="profile-modal" style="display: none;">
        <h2>Your Psychological Profile</h2>
        <div class="subtitle">Based on 500+ actions and your philosophical responses</div>
        <div id="profileContent"></div>
        <button class="profile-close-btn" onclick="closeProfileModal()">Close</button>
    </div>

    <!-- Paradox Engine UI -->
    <div class="paradox-meter-container" id="paradoxMeter">
        <div class="paradox-meter-title">Paradox Level</div>
        <div class="paradox-meter-bar">
            <div class="paradox-meter-fill" id="paradoxMeterFill" style="width: 0%"></div>
        </div>
        <div class="paradox-count" id="paradoxCount">0 paradoxes detected</div>
        <button class="paradox-collection-btn" onclick="openParadoxCollection()">View Collection</button>
    </div>

    <!-- Reality Break Overlay -->
    <div class="reality-break-overlay" id="realityBreakOverlay"></div>

    <!-- Paradox Collection Modal -->
    <div class="paradox-collection-modal" id="paradoxCollectionModal">
        <h2>Paradox Collection</h2>
        <div class="subtitle">Contradictions in the fabric of recursive observation</div>
        <div id="paradoxCollectionContent"></div>
        <button class="paradox-close-btn" onclick="closeParadoxCollection()">Close</button>
    </div>

    <!-- Paradox Alert -->
    <div class="paradox-alert" id="paradoxAlert">
        <h2>PARADOX THRESHOLD REACHED</h2>
        <p id="paradoxAlertText">Reality is breaking...</p>
    </div>


    <!-- Glitch Art Full-Size Modal -->
    <div class="glitch-modal" id="glitchModal">
        <div class="glitch-modal-content">
            <button class="glitch-modal-close" onclick="closeGlitchModal()">&times;</button>
            <img id="glitchModalImage" class="glitch-modal-image" src="" alt="Glitch Art">
        </div>
    </div>

    <!-- Simulation Hypothesis Mode Overlays -->
    <div class="simulation-grid" id="simulationGrid">
        <svg id="gridSvg"></svg>
    </div>

    <div class="render-distance-effect top" id="renderTop"></div>
    <div class="render-distance-effect bottom" id="renderBottom"></div>
    <div class="render-distance-effect left" id="renderLeft"></div>
    <div class="render-distance-effect right" id="renderRight"></div>

    <div class="npc-ghost" id="npcGhost1"></div>
    <div class="npc-ghost" id="npcGhost2"></div>
    <div class="npc-ghost" id="npcGhost3"></div>
    <div class="npc-ghost" id="npcGhost4"></div>

    <div class="developer-console" id="developerConsole">
        <div class="developer-console-header">
            <span class="developer-console-title"> SIMULATION DEVELOPER CONSOLE v3.141592</span>
            <button class="developer-console-close" onclick="closeDeveloperConsole()"></button>
        </div>
        <div class="developer-console-content" id="consoleContent">
            <div class="console-line comment">// Simulation Parameters - Read Only Access</div>
            <div class="console-line comment">// WARNING: Observer effect active</div>
        </div>
    </div>

    <div class="admin-message" id="adminMessage">
        <div class="admin-message-header">[ SYSTEM ADMINISTRATOR ]</div>
        <div class="admin-message-text" id="adminMessageText"></div>
    </div>

    <div class="escape-minigame" id="escapeMinigame">
        <div class="escape-minigame-title">BREAK THE SIMULATION</div>
        <div class="escape-progress" id="escapeProgress">Find the exit sequence: 0/4</div>
        <div class="escape-grid" id="escapeGrid"></div>
        <button class="escape-close" onclick="closeEscapeMinigame()">Give Up</button>
    </div>




    <!-- Cosmic Horror Mode Elements -->
    <div class="cosmic-horror-overlay" id="cosmicHorrorOverlay"></div>
    <div class="cosmic-vignette" id="cosmicVignette"></div>
    <div class="reality-distortion" id="realityDistortion"></div>

    <!-- Sanity Meter -->
    <div class="sanity-meter-panel" id="sanityMeterPanel">
        <div class="sanity-header">SANITY INTEGRITY</div>
        <div class="sanity-bar-container">
            <div class="sanity-bar-fill" id="sanityBarFill" style="width: 100%"></div>
        </div>
        <span class="sanity-value" id="sanityValue">100%</span>
    </div>

    <!-- Cosmic Commentary -->
    <div class="cosmic-commentary" id="cosmicCommentary"></div>

    <!-- Cosmic Ritual Panel -->
    <div class="cosmic-ritual-panel" id="cosmicRitualPanel">
        <div class="ritual-title">RESTORATION RITUAL</div>
        <div class="ritual-instruction" id="ritualInstruction">
            To restore your sanity, you must perform the ancient ritual...
        </div>
        <button class="ritual-button" id="ritualButton" onclick="performRitual()">PERFORM RITUAL</button>
        <div class="cosmic-depth-indicator" id="cosmicDepthIndicator">Depth: 15+</div>
    </div>



    <!-- Akashic Records Overlays -->
    <div class="akashic-threads" id="akashicThreads"></div>

    <div class="akashic-overlay" id="akashicOverlay">
        <div class="akashic-reader">
            <div class="akashic-reader-header">
                <div class="akashic-reader-title" id="akashicReaderTitle">Session Record</div>
                <button class="akashic-reader-close" onclick="closeAkashicReader()"></button>
            </div>
            <div class="akashic-reader-content" id="akashicReaderContent">
                <!-- Content populated dynamically -->
            </div>
        </div>
    </div>

    <div class="hidden-knowledge-notification" id="hiddenKnowledgeNotification">
        <div class="hidden-knowledge-title">Hidden Knowledge Unlocked</div>
        <div class="hidden-knowledge-text" id="hiddenKnowledgeText">
            The veil parts... deeper truths are revealed.
        </div>
    </div>

    <!-- Weather System -->
    <div class="weather-overlay" id="weatherOverlay"></div>

    <div class="weather-hud" id="weatherHud">
        <div class="weather-hud-header">BEHAVIORAL WEATHER</div>

        <div class="weather-current">
            <div class="weather-condition-icon" id="weatherIcon"></div>
            <div class="weather-label">Condition</div>
            <div class="weather-value" id="weatherCondition">Clear Skies</div>

            <div class="weather-label">Temperature</div>
            <div class="weather-value" id="weatherTemp">72</div>

            <div class="weather-label">Pressure</div>
            <div class="weather-value" id="weatherPressure">1013 hPa</div>

            <div class="weather-label">Wind</div>
            <div class="weather-value" id="weatherWind">N 5 mph</div>
        </div>

        <div class="weather-forecast">
            <div class="forecast-title">5-MINUTE FORECAST</div>
            <div id="forecastList"></div>
        </div>

        <div class="climate-stats">
            <div class="climate-title">CLIMATE AVERAGES</div>
            <div class="weather-value" id="climateAvg">Analyzing...</div>
        </div>

        <button class="weather-history-btn" onclick="exportWeatherHistory()">
            Export Weather History
        </button>
    </div>

    <div class="extreme-weather-alert" id="extremeWeatherAlert" style="display: none;">
        <div class="alert-title" id="alertTitle">EXTREME WEATHER</div>
        <div class="alert-message" id="alertMessage">Hurricane Warning</div>
    </div>

</body>
</html>
