<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Network Zoo - Watch AI Learn in Real-Time</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Courier New', monospace;
            background: linear-gradient(135deg, #0f0c29 0%, #302b63 50%, #24243e 100%);
            color: #fff;
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* Header */
        .header {
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-bottom: 2px solid rgba(0, 255, 136, 0.3);
            position: relative;
        }

        .title {
            font-size: 2.5em;
            font-weight: bold;
            background: linear-gradient(90deg, #00ff88, #00ddff, #ff00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 5px;
        }

        .subtitle {
            color: #00ff88;
            font-size: 1.1em;
            opacity: 0.9;
        }

        /* Data Controls */
        .data-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 1000;
            display: flex;
            gap: 10px;
        }

        .data-controls button {
            padding: 10px 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 25px;
            color: white;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .data-controls button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        #importFile {
            display: none;
        }

        /* Main Container */
        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Exhibits Selection */
        .exhibits {
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid rgba(0, 255, 136, 0.2);
        }

        .exhibits-title {
            color: #00ff88;
            font-size: 1.3em;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .exhibit-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }

        .exhibit-card {
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.1), rgba(0, 221, 255, 0.1));
            border: 2px solid transparent;
            border-radius: 10px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .exhibit-card:hover {
            border-color: #00ff88;
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
        }

        .exhibit-card.active {
            border-color: #00ff88;
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.2), rgba(0, 221, 255, 0.2));
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.5);
        }

        .exhibit-icon {
            font-size: 2em;
            margin-bottom: 10px;
        }

        .exhibit-name {
            font-weight: bold;
            color: #00ddff;
        }

        .exhibit-description {
            font-size: 0.85em;
            color: #aaa;
            margin-top: 5px;
        }

        /* Visualization Panel */
        .visualization-panel {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .network-container {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 15px;
            padding: 20px;
            border: 2px solid rgba(0, 255, 136, 0.2);
            position: relative;
            min-height: 500px;
        }

        #networkCanvas {
            width: 100%;
            height: 500px;
            border-radius: 10px;
        }

        .controls-panel {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(0, 255, 136, 0.2);
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-label {
            color: #00ff88;
            font-weight: bold;
            margin-bottom: 10px;
            display: block;
        }

        .control-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .control-btn {
            padding: 8px 16px;
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.2), rgba(0, 221, 255, 0.2));
            border: 1px solid #00ff88;
            border-radius: 20px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .control-btn:hover {
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.3), rgba(0, 221, 255, 0.3));
            transform: scale(1.05);
        }

        .control-btn.active {
            background: linear-gradient(135deg, #00ff88, #00ddff);
            color: #000;
        }

        .slider-control {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .slider {
            flex: 1;
            -webkit-appearance: none;
            appearance: none;
            height: 5px;
            background: rgba(0, 255, 136, 0.2);
            outline: none;
            opacity: 0.7;
            transition: opacity 0.2s;
            border-radius: 5px;
        }

        .slider:hover {
            opacity: 1;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: linear-gradient(135deg, #00ff88, #00ddff);
            cursor: pointer;
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        .slider-value {
            color: #00ddff;
            font-weight: bold;
            min-width: 60px;
        }

        /* Architecture Builder */
        .architecture-builder {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid rgba(0, 255, 136, 0.2);
        }

        .layer-config {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 10px;
            padding: 10px;
            background: rgba(0, 255, 136, 0.05);
            border-radius: 10px;
        }

        .layer-number {
            color: #00ff88;
            font-weight: bold;
            min-width: 80px;
        }

        .layer-input {
            width: 80px;
            padding: 5px 10px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid #00ff88;
            border-radius: 5px;
            color: white;
            text-align: center;
        }

        .layer-remove {
            padding: 5px 10px;
            background: rgba(255, 0, 0, 0.2);
            border: 1px solid #ff4444;
            border-radius: 5px;
            color: #ff4444;
            cursor: pointer;
        }

        /* Stats Panel */
        .stats-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(0, 255, 136, 0.2);
        }

        .stat-title {
            color: #00ff88;
            font-weight: bold;
            margin-bottom: 15px;
        }

        .stat-canvas {
            width: 100%;
            height: 150px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
        }

        .stat-value {
            font-size: 2em;
            color: #00ddff;
            text-align: center;
            margin-top: 10px;
        }

        /* Datasets */
        .dataset-selector {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-bottom: 15px;
        }

        .dataset-option {
            padding: 10px;
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid transparent;
            border-radius: 10px;
            cursor: pointer;
            text-align: center;
            transition: all 0.3s ease;
        }

        .dataset-option:hover {
            border-color: #00ff88;
            background: rgba(0, 255, 136, 0.2);
        }

        .dataset-option.active {
            border-color: #00ff88;
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.3), rgba(0, 221, 255, 0.3));
        }

        /* Drawing Canvas */
        .drawing-area {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(0, 255, 136, 0.2);
            text-align: center;
        }

        #drawingCanvas {
            background: #000;
            border: 2px solid #00ff88;
            border-radius: 10px;
            cursor: crosshair;
            margin: 10px auto;
            display: block;
        }

        /* Info Panel */
        .info-panel {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(0, 255, 136, 0.2);
            margin-top: 20px;
        }

        .info-title {
            color: #00ff88;
            font-size: 1.3em;
            margin-bottom: 15px;
        }

        .info-content {
            color: #aaa;
            line-height: 1.6;
        }

        .info-content h3 {
            color: #00ddff;
            margin-top: 15px;
            margin-bottom: 10px;
        }

        /* Animations */
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.1); opacity: 1; }
        }

        @keyframes flow {
            0% { stroke-dashoffset: 0; }
            100% { stroke-dashoffset: -100; }
        }

        @keyframes glow {
            0%, 100% { box-shadow: 0 0 5px rgba(0, 255, 136, 0.5); }
            50% { box-shadow: 0 0 20px rgba(0, 255, 136, 0.8); }
        }

        .neuron-active {
            animation: pulse 0.5s ease-in-out;
        }

        .connection-flow {
            stroke-dasharray: 5, 5;
            animation: flow 2s linear infinite;
        }

        /* Speed Controls */
        .speed-control {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-top: 15px;
        }

        .speed-options {
            display: flex;
            gap: 10px;
        }

        .speed-btn {
            padding: 5px 15px;
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 15px;
            color: #00ff88;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .speed-btn.active {
            background: rgba(0, 255, 136, 0.3);
            border-color: #00ff88;
        }

        /* Responsive Design */
        @media (max-width: 1200px) {
            .visualization-panel {
                grid-template-columns: 1fr;
            }

            .exhibit-grid {
                grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            }
        }

        @media (max-width: 768px) {
            .title {
                font-size: 1.8em;
            }

            .data-controls {
                position: static;
                margin-top: 15px;
            }

            .stats-panel {
                grid-template-columns: 1fr;
            }

            #networkCanvas {
                height: 300px;
            }
        }

        /* Loading Animation */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(0, 255, 136, 0.3);
            border-radius: 50%;
            border-top-color: #00ff88;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Tooltip */
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: #00ff88;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 0.9em;
            pointer-events: none;
            z-index: 1000;
            border: 1px solid rgba(0, 255, 136, 0.3);
            display: none;
        }

        .tooltip.show {
            display: block;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="header">
        <div class="title">üß† Neural Network Zoo</div>
        <div class="subtitle">Watch AI Learn in Real-Time ‚Ä¢ Interactive Machine Learning Playground</div>

        <!-- Data Controls -->
        <div class="data-controls">
            <button onclick="exportData()">üì• Export Model</button>
            <button onclick="document.getElementById('importFile').click()">üì§ Import Model</button>
            <input type="file" id="importFile" accept=".json" onchange="importData(event)">
        </div>
    </div>

    <!-- Main Container -->
    <div class="container">
        <!-- Exhibits Selection -->
        <div class="exhibits">
            <div class="exhibits-title">
                üé≠ Choose Your Exhibit
            </div>
            <div class="exhibit-grid">
                <div class="exhibit-card active" data-exhibit="feedforward">
                    <div class="exhibit-icon">üîÑ</div>
                    <div class="exhibit-name">Feedforward</div>
                    <div class="exhibit-description">Classic neural network</div>
                </div>
                <div class="exhibit-card" data-exhibit="cnn">
                    <div class="exhibit-icon">üñºÔ∏è</div>
                    <div class="exhibit-name">CNN</div>
                    <div class="exhibit-description">Image recognition</div>
                </div>
                <div class="exhibit-card" data-exhibit="rnn">
                    <div class="exhibit-icon">üîÅ</div>
                    <div class="exhibit-name">RNN</div>
                    <div class="exhibit-description">Sequence learning</div>
                </div>
                <div class="exhibit-card" data-exhibit="gan">
                    <div class="exhibit-icon">üé®</div>
                    <div class="exhibit-name">GAN</div>
                    <div class="exhibit-description">Generative AI</div>
                </div>
                <div class="exhibit-card" data-exhibit="autoencoder">
                    <div class="exhibit-icon">üóúÔ∏è</div>
                    <div class="exhibit-name">Autoencoder</div>
                    <div class="exhibit-description">Data compression</div>
                </div>
                <div class="exhibit-card" data-exhibit="transformer">
                    <div class="exhibit-icon">‚ö°</div>
                    <div class="exhibit-name">Transformer</div>
                    <div class="exhibit-description">Attention mechanism</div>
                </div>
            </div>
        </div>

        <!-- Architecture Builder -->
        <div class="architecture-builder">
            <div class="control-label">üèóÔ∏è Network Architecture</div>
            <div id="architectureLayers">
                <div class="layer-config">
                    <span class="layer-number">Input Layer:</span>
                    <input type="number" class="layer-input" value="2" min="1" max="100">
                    <span style="color: #666;">neurons</span>
                </div>
                <div class="layer-config">
                    <span class="layer-number">Hidden 1:</span>
                    <input type="number" class="layer-input" value="4" min="1" max="100">
                    <span style="color: #666;">neurons</span>
                </div>
                <div class="layer-config">
                    <span class="layer-number">Output Layer:</span>
                    <input type="number" class="layer-input" value="2" min="1" max="100">
                    <span style="color: #666;">neurons</span>
                </div>
            </div>
            <div class="control-buttons" style="margin-top: 15px;">
                <button class="control-btn" onclick="addLayer()">‚ûï Add Layer</button>
                <button class="control-btn" onclick="buildNetwork()">üî® Build Network</button>
            </div>
        </div>

        <!-- Visualization Panel -->
        <div class="visualization-panel">
            <div class="network-container">
                <canvas id="networkCanvas"></canvas>
                <div class="tooltip" id="neuronTooltip"></div>
            </div>

            <div class="controls-panel">
                <div class="control-group">
                    <div class="control-label">üìä Dataset</div>
                    <div class="dataset-selector">
                        <div class="dataset-option active" data-dataset="xor">XOR</div>
                        <div class="dataset-option" data-dataset="spiral">Spiral</div>
                        <div class="dataset-option" data-dataset="circles">Circles</div>
                        <div class="dataset-option" data-dataset="moons">Moons</div>
                        <div class="dataset-option" data-dataset="gaussian">Gaussian</div>
                        <div class="dataset-option" data-dataset="custom">Draw</div>
                    </div>
                </div>

                <div class="control-group">
                    <div class="control-label">‚öôÔ∏è Training Controls</div>
                    <div class="slider-control">
                        <span style="color: #aaa;">Learning Rate:</span>
                        <input type="range" class="slider" id="learningRate" min="0.001" max="0.5" step="0.001" value="0.01">
                        <span class="slider-value" id="learningRateValue">0.01</span>
                    </div>
                    <div class="slider-control" style="margin-top: 10px;">
                        <span style="color: #aaa;">Batch Size:</span>
                        <input type="range" class="slider" id="batchSize" min="1" max="32" step="1" value="4">
                        <span class="slider-value" id="batchSizeValue">4</span>
                    </div>
                    <div class="control-buttons" style="margin-top: 15px;">
                        <button class="control-btn" id="trainBtn" onclick="toggleTraining()">‚ñ∂Ô∏è Train</button>
                        <button class="control-btn" onclick="resetNetwork()">üîÑ Reset</button>
                        <button class="control-btn" onclick="stepTraining()">‚è≠Ô∏è Step</button>
                    </div>
                </div>

                <div class="control-group">
                    <div class="control-label">üëÅÔ∏è Visualization</div>
                    <div style="color: #aaa;">
                        <label style="display: block; margin: 5px 0;">
                            <input type="checkbox" id="showWeights" checked> Show Weights
                        </label>
                        <label style="display: block; margin: 5px 0;">
                            <input type="checkbox" id="showGradients" checked> Show Gradients
                        </label>
                        <label style="display: block; margin: 5px 0;">
                            <input type="checkbox" id="showActivations" checked> Show Activations
                        </label>
                        <label style="display: block; margin: 5px 0;">
                            <input type="checkbox" id="animateFlow" checked> Animate Data Flow
                        </label>
                    </div>
                </div>

                <div class="speed-control">
                    <span style="color: #aaa;">Speed:</span>
                    <div class="speed-options">
                        <button class="speed-btn" data-speed="slow">üê¢ Slow</button>
                        <button class="speed-btn active" data-speed="normal">üö∂ Normal</button>
                        <button class="speed-btn" data-speed="fast">üèÉ Fast</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Stats Panel -->
        <div class="stats-panel">
            <div class="stat-card">
                <div class="stat-title">üìâ Loss History</div>
                <canvas id="lossCanvas" class="stat-canvas"></canvas>
            </div>
            <div class="stat-card">
                <div class="stat-title">üéØ Accuracy</div>
                <div class="stat-value" id="accuracyValue">0.00%</div>
                <canvas id="accuracyCanvas" class="stat-canvas"></canvas>
            </div>
            <div class="stat-card">
                <div class="stat-title">üìä Decision Boundary</div>
                <canvas id="boundaryCanvas" class="stat-canvas"></canvas>
            </div>
            <div class="stat-card">
                <div class="stat-title">‚ö° Training Stats</div>
                <div style="color: #aaa; font-size: 0.9em;">
                    <div>Epoch: <span id="epochCount" style="color: #00ddff;">0</span></div>
                    <div>Samples: <span id="sampleCount" style="color: #00ddff;">0</span></div>
                    <div>Time: <span id="trainingTime" style="color: #00ddff;">0s</span></div>
                    <div>Loss: <span id="currentLoss" style="color: #00ddff;">0.000</span></div>
                </div>
            </div>
        </div>

        <!-- Drawing Area (for custom dataset) -->
        <div class="drawing-area" id="drawingArea" style="display: none;">
            <div class="control-label">‚úèÔ∏è Draw Your Dataset</div>
            <canvas id="drawingCanvas" width="400" height="400"></canvas>
            <div class="control-buttons" style="margin-top: 15px;">
                <button class="control-btn" onclick="setDrawClass(0)">üîµ Class A</button>
                <button class="control-btn" onclick="setDrawClass(1)">üî¥ Class B</button>
                <button class="control-btn" onclick="clearDrawing()">üóëÔ∏è Clear</button>
            </div>
        </div>

        <!-- Info Panel -->
        <div class="info-panel">
            <div class="info-title">üìö Understanding Neural Networks</div>
            <div class="info-content" id="infoContent">
                <h3>What You're Seeing</h3>
                <p>This is a real neural network learning in your browser! Each circle represents a neuron, and the lines show connections with weights. Watch as the network adjusts these weights to learn patterns in the data.</p>

                <h3>How It Learns</h3>
                <p><strong>Forward Pass:</strong> Data flows from left to right through the network. Each neuron receives inputs, applies weights, adds bias, and uses an activation function.</p>
                <p><strong>Backward Pass:</strong> The network calculates its error and adjusts weights using backpropagation - sending error signals backward through the network.</p>

                <h3>Visual Indicators</h3>
                <p>üü¢ <strong>Green connections:</strong> Positive weights (excitatory)</p>
                <p>üî¥ <strong>Red connections:</strong> Negative weights (inhibitory)</p>
                <p>üí´ <strong>Brightness:</strong> Activation strength or weight magnitude</p>
                <p>‚ö° <strong>Animation:</strong> Data or gradients flowing through the network</p>

                <h3>Tips</h3>
                <p>‚Ä¢ Try different datasets to see how the network adapts</p>
                <p>‚Ä¢ Adjust the learning rate to control training speed</p>
                <p>‚Ä¢ Add more hidden layers for complex patterns</p>
                <p>‚Ä¢ Click on neurons to see detailed information</p>
            </div>
        </div>
    </div>

    <script>
        // Neural Network Zoo - Core Implementation
        const APP_NAME = 'neural-network-zoo';

        // Global State
        let appData = JSON.parse(localStorage.getItem(APP_NAME) || '{}');
        let network = null;
        let dataset = [];
        let isTraining = false;
        let trainingStats = {
            epoch: 0,
            samples: 0,
            startTime: Date.now(),
            lossHistory: [],
            accuracyHistory: []
        };
        let visualizationSpeed = 'normal';
        let currentExhibit = 'feedforward';
        let drawingClass = 0;

        // Neural Network Implementation
        class NeuralNetwork {
            constructor(architecture) {
                this.layers = [];
                this.weights = [];
                this.biases = [];
                this.architecture = architecture;

                // Initialize layers
                for (let i = 0; i < architecture.length; i++) {
                    this.layers.push({
                        size: architecture[i],
                        neurons: new Array(architecture[i]).fill(0),
                        activations: new Array(architecture[i]).fill(0),
                        gradients: new Array(architecture[i]).fill(0)
                    });
                }

                // Initialize weights and biases
                for (let i = 0; i < architecture.length - 1; i++) {
                    const rows = architecture[i];
                    const cols = architecture[i + 1];

                    // Xavier initialization
                    const weights = [];
                    for (let r = 0; r < rows; r++) {
                        weights[r] = [];
                        for (let c = 0; c < cols; c++) {
                            weights[r][c] = (Math.random() * 2 - 1) * Math.sqrt(2 / rows);
                        }
                    }
                    this.weights.push(weights);

                    // Initialize biases to small values
                    this.biases.push(new Array(cols).fill(0).map(() => (Math.random() * 2 - 1) * 0.1));
                }
            }

            sigmoid(x) {
                return 1 / (1 + Math.exp(-x));
            }

            sigmoidDerivative(x) {
                const s = this.sigmoid(x);
                return s * (1 - s);
            }

            relu(x) {
                return Math.max(0, x);
            }

            reluDerivative(x) {
                return x > 0 ? 1 : 0;
            }

            tanh(x) {
                return Math.tanh(x);
            }

            tanhDerivative(x) {
                const t = Math.tanh(x);
                return 1 - t * t;
            }

            forward(input) {
                // Set input layer
                this.layers[0].activations = [...input];

                // Forward propagation
                for (let l = 0; l < this.weights.length; l++) {
                    const currentLayer = this.layers[l];
                    const nextLayer = this.layers[l + 1];
                    const weights = this.weights[l];
                    const biases = this.biases[l];

                    // Calculate next layer activations
                    for (let j = 0; j < nextLayer.size; j++) {
                        let sum = biases[j];
                        for (let i = 0; i < currentLayer.size; i++) {
                            sum += currentLayer.activations[i] * weights[i][j];
                        }

                        // Apply activation function
                        if (l === this.weights.length - 1) {
                            // Output layer - use sigmoid for classification
                            nextLayer.neurons[j] = sum;
                            nextLayer.activations[j] = this.sigmoid(sum);
                        } else {
                            // Hidden layers - use ReLU
                            nextLayer.neurons[j] = sum;
                            nextLayer.activations[j] = this.relu(sum);
                        }
                    }
                }

                return this.layers[this.layers.length - 1].activations;
            }

            backward(target, learningRate) {
                const outputLayer = this.layers[this.layers.length - 1];

                // Calculate output layer gradients
                for (let i = 0; i < outputLayer.size; i++) {
                    const output = outputLayer.activations[i];
                    const error = output - target[i];
                    outputLayer.gradients[i] = error * this.sigmoidDerivative(outputLayer.neurons[i]);
                }

                // Backpropagate gradients
                for (let l = this.layers.length - 2; l >= 0; l--) {
                    const currentLayer = this.layers[l];
                    const nextLayer = this.layers[l + 1];
                    const weights = this.weights[l];

                    // Calculate gradients for current layer
                    for (let i = 0; i < currentLayer.size; i++) {
                        let gradient = 0;
                        for (let j = 0; j < nextLayer.size; j++) {
                            gradient += nextLayer.gradients[j] * weights[i][j];
                        }

                        if (l > 0) {
                            // Hidden layer - use ReLU derivative
                            currentLayer.gradients[i] = gradient * this.reluDerivative(currentLayer.neurons[i]);
                        }
                    }

                    // Update weights and biases
                    for (let i = 0; i < currentLayer.size; i++) {
                        for (let j = 0; j < nextLayer.size; j++) {
                            const delta = learningRate * nextLayer.gradients[j] * currentLayer.activations[i];
                            weights[i][j] -= delta;
                        }
                    }

                    // Update biases
                    for (let j = 0; j < nextLayer.size; j++) {
                        this.biases[l][j] -= learningRate * nextLayer.gradients[j];
                    }
                }

                return this.calculateLoss(outputLayer.activations, target);
            }

            calculateLoss(output, target) {
                let loss = 0;
                for (let i = 0; i < output.length; i++) {
                    const error = output[i] - target[i];
                    loss += error * error;
                }
                return loss / output.length;
            }

            predict(input) {
                const output = this.forward(input);
                return output.indexOf(Math.max(...output));
            }
        }

        // Network Visualizer
        class NetworkVisualizer {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.neuronPositions = [];
                this.animationFrame = 0;
            }

            draw(network) {
                // Clear canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                if (!network) return;

                const padding = 60;
                const layerWidth = (this.canvas.width - 2 * padding) / (network.layers.length - 1);

                // Calculate neuron positions
                this.neuronPositions = [];
                for (let l = 0; l < network.layers.length; l++) {
                    const layer = network.layers[l];
                    const layerPositions = [];
                    const x = padding + l * layerWidth;
                    const neuronSpacing = Math.min(60, (this.canvas.height - 2 * padding) / layer.size);
                    const startY = (this.canvas.height - neuronSpacing * (layer.size - 1)) / 2;

                    for (let n = 0; n < layer.size; n++) {
                        layerPositions.push({
                            x: x,
                            y: startY + n * neuronSpacing,
                            activation: layer.activations[n],
                            gradient: layer.gradients[n]
                        });
                    }
                    this.neuronPositions.push(layerPositions);
                }

                // Draw connections
                if (document.getElementById('showWeights').checked) {
                    this.drawConnections(network);
                }

                // Draw neurons
                this.drawNeurons(network);

                // Draw layer labels
                this.drawLayerLabels(network);

                this.animationFrame++;
            }

            drawConnections(network) {
                for (let l = 0; l < network.weights.length; l++) {
                    const weights = network.weights[l];
                    const layer1 = this.neuronPositions[l];
                    const layer2 = this.neuronPositions[l + 1];

                    for (let i = 0; i < layer1.length; i++) {
                        for (let j = 0; j < layer2.length; j++) {
                            const weight = weights[i][j];
                            const from = layer1[i];
                            const to = layer2[j];

                            // Draw connection
                            this.ctx.beginPath();
                            this.ctx.moveTo(from.x, from.y);
                            this.ctx.lineTo(to.x, to.y);

                            // Style based on weight
                            const absWeight = Math.abs(weight);
                            this.ctx.lineWidth = Math.min(3, absWeight * 2);

                            if (weight > 0) {
                                this.ctx.strokeStyle = `rgba(0, 255, 136, ${Math.min(0.8, absWeight)})`;
                            } else {
                                this.ctx.strokeStyle = `rgba(255, 77, 77, ${Math.min(0.8, absWeight)})`;
                            }

                            // Animate if enabled
                            if (document.getElementById('animateFlow').checked && from.activation > 0.1) {
                                this.ctx.setLineDash([5, 5]);
                                this.ctx.lineDashOffset = this.animationFrame % 10;
                            } else {
                                this.ctx.setLineDash([]);
                            }

                            this.ctx.stroke();
                        }
                    }
                }

                this.ctx.setLineDash([]);
            }

            drawNeurons(network) {
                for (let l = 0; l < this.neuronPositions.length; l++) {
                    const layer = this.neuronPositions[l];
                    const isInput = l === 0;
                    const isOutput = l === this.neuronPositions.length - 1;

                    for (let n = 0; n < layer.length; n++) {
                        const neuron = layer[n];
                        const radius = 18;

                        // Draw neuron circle
                        this.ctx.beginPath();
                        this.ctx.arc(neuron.x, neuron.y, radius, 0, Math.PI * 2);

                        // Fill based on activation
                        if (document.getElementById('showActivations').checked) {
                            const activation = Math.abs(neuron.activation);
                            const hue = neuron.activation > 0 ? 120 : 0;
                            this.ctx.fillStyle = `hsla(${hue}, 100%, 50%, ${Math.min(1, activation)})`;

                            // Glow effect for high activation
                            if (activation > 0.7) {
                                this.ctx.shadowBlur = 20;
                                this.ctx.shadowColor = this.ctx.fillStyle;
                            }
                        } else {
                            this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                        }

                        this.ctx.fill();
                        this.ctx.shadowBlur = 0;

                        // Border
                        this.ctx.strokeStyle = isInput ? '#00ddff' : (isOutput ? '#ff00ff' : '#00ff88');
                        this.ctx.lineWidth = 2;
                        this.ctx.stroke();

                        // Show gradient if training
                        if (document.getElementById('showGradients').checked && Math.abs(neuron.gradient) > 0.001) {
                            this.ctx.beginPath();
                            this.ctx.arc(neuron.x, neuron.y, radius + 5, 0, Math.PI * 2);
                            this.ctx.strokeStyle = `rgba(255, 255, 0, ${Math.min(1, Math.abs(neuron.gradient) * 10)})`;
                            this.ctx.lineWidth = 2;
                            this.ctx.stroke();
                        }

                        // Show value on hover (would need mouse tracking)
                        if (document.getElementById('showActivations').checked) {
                            this.ctx.fillStyle = '#fff';
                            this.ctx.font = '10px monospace';
                            this.ctx.textAlign = 'center';
                            this.ctx.fillText(neuron.activation.toFixed(2), neuron.x, neuron.y + 3);
                        }
                    }
                }
            }

            drawLayerLabels(network) {
                const labels = ['Input', ...Array(network.layers.length - 2).fill(0).map((_, i) => `Hidden ${i + 1}`), 'Output'];

                this.ctx.fillStyle = '#00ff88';
                this.ctx.font = 'bold 12px sans-serif';
                this.ctx.textAlign = 'center';

                for (let l = 0; l < this.neuronPositions.length; l++) {
                    const x = this.neuronPositions[l][0].x;
                    this.ctx.fillText(labels[l], x, 30);
                    this.ctx.fillText(`(${network.layers[l].size})`, x, 45);
                }
            }
        }

        // Dataset Generators
        function generateXORDataset() {
            return [
                { input: [0, 0], output: [1, 0] },
                { input: [0, 1], output: [0, 1] },
                { input: [1, 0], output: [0, 1] },
                { input: [1, 1], output: [1, 0] }
            ];
        }

        function generateSpiralDataset(numPoints = 100) {
            const data = [];
            const classes = 2;

            for (let c = 0; c < classes; c++) {
                for (let i = 0; i < numPoints; i++) {
                    const r = (i / numPoints) * 0.8 + 0.1;
                    const t = c * Math.PI + (i / numPoints) * 2 * Math.PI + Math.random() * 0.2;

                    data.push({
                        input: [
                            r * Math.cos(t),
                            r * Math.sin(t)
                        ],
                        output: c === 0 ? [1, 0] : [0, 1]
                    });
                }
            }

            return data;
        }

        function generateCirclesDataset(numPoints = 100) {
            const data = [];

            for (let i = 0; i < numPoints; i++) {
                const angle = Math.random() * 2 * Math.PI;
                const r = Math.random() < 0.5 ? Math.random() * 0.3 : 0.5 + Math.random() * 0.3;

                data.push({
                    input: [
                        r * Math.cos(angle),
                        r * Math.sin(angle)
                    ],
                    output: r < 0.4 ? [1, 0] : [0, 1]
                });
            }

            return data;
        }

        function generateMoonsDataset(numPoints = 100) {
            const data = [];
            const noise = 0.1;

            for (let i = 0; i < numPoints / 2; i++) {
                const angle = i / (numPoints / 2) * Math.PI;

                // Upper moon
                data.push({
                    input: [
                        Math.cos(angle) + Math.random() * noise,
                        Math.sin(angle) + Math.random() * noise
                    ],
                    output: [1, 0]
                });

                // Lower moon
                data.push({
                    input: [
                        1 - Math.cos(angle) + Math.random() * noise,
                        0.5 - Math.sin(angle) + Math.random() * noise
                    ],
                    output: [0, 1]
                });
            }

            return data;
        }

        function generateGaussianDataset(numPoints = 100) {
            const data = [];

            function gaussianRandom() {
                let u = 0, v = 0;
                while (u === 0) u = Math.random();
                while (v === 0) v = Math.random();
                return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
            }

            // Class 1 - centered at (-0.5, -0.5)
            for (let i = 0; i < numPoints / 2; i++) {
                data.push({
                    input: [
                        -0.5 + gaussianRandom() * 0.3,
                        -0.5 + gaussianRandom() * 0.3
                    ],
                    output: [1, 0]
                });
            }

            // Class 2 - centered at (0.5, 0.5)
            for (let i = 0; i < numPoints / 2; i++) {
                data.push({
                    input: [
                        0.5 + gaussianRandom() * 0.3,
                        0.5 + gaussianRandom() * 0.3
                    ],
                    output: [0, 1]
                });
            }

            return data;
        }

        // Training Functions
        async function train() {
            if (!network || !dataset || dataset.length === 0) return;

            const learningRate = parseFloat(document.getElementById('learningRate').value);
            const batchSize = parseInt(document.getElementById('batchSize').value);

            // Shuffle dataset
            const shuffled = [...dataset].sort(() => Math.random() - 0.5);

            let totalLoss = 0;
            let correct = 0;

            // Train in batches
            for (let i = 0; i < shuffled.length; i += batchSize) {
                if (!isTraining) break;

                const batch = shuffled.slice(i, Math.min(i + batchSize, shuffled.length));

                for (const sample of batch) {
                    const output = network.forward(sample.input);
                    const loss = network.backward(sample.output, learningRate);
                    totalLoss += loss;

                    // Check accuracy
                    const predicted = output.indexOf(Math.max(...output));
                    const actual = sample.output.indexOf(Math.max(...sample.output));
                    if (predicted === actual) correct++;

                    trainingStats.samples++;
                }

                // Update visualization
                visualizer.draw(network);

                // Speed control
                const delay = visualizationSpeed === 'slow' ? 100 : (visualizationSpeed === 'fast' ? 0 : 10);
                if (delay > 0) {
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }

            // Update stats
            trainingStats.epoch++;
            const avgLoss = totalLoss / dataset.length;
            const accuracy = correct / dataset.length;

            trainingStats.lossHistory.push(avgLoss);
            trainingStats.accuracyHistory.push(accuracy);

            updateStats();
            updateGraphs();
            updateDecisionBoundary();

            // Continue training if not stopped
            if (isTraining) {
                requestAnimationFrame(() => train());
            }
        }

        function toggleTraining() {
            isTraining = !isTraining;
            const btn = document.getElementById('trainBtn');

            if (isTraining) {
                btn.textContent = '‚è∏Ô∏è Pause';
                btn.classList.add('active');
                trainingStats.startTime = Date.now();
                train();
            } else {
                btn.textContent = '‚ñ∂Ô∏è Train';
                btn.classList.remove('active');
            }
        }

        async function stepTraining() {
            if (!network || !dataset || dataset.length === 0) return;

            isTraining = false;
            const learningRate = parseFloat(document.getElementById('learningRate').value);

            // Train on one random sample
            const sample = dataset[Math.floor(Math.random() * dataset.length)];
            network.forward(sample.input);
            network.backward(sample.output, learningRate);

            trainingStats.samples++;

            // Update visualization with animation
            visualizer.draw(network);
            updateStats();
        }

        function resetNetwork() {
            isTraining = false;
            document.getElementById('trainBtn').textContent = '‚ñ∂Ô∏è Train';
            document.getElementById('trainBtn').classList.remove('active');

            // Get architecture from UI
            const layers = Array.from(document.querySelectorAll('.layer-input')).map(input => parseInt(input.value));

            // Create new network
            network = new NeuralNetwork(layers);
            visualizer.draw(network);

            // Reset stats
            trainingStats = {
                epoch: 0,
                samples: 0,
                startTime: Date.now(),
                lossHistory: [],
                accuracyHistory: []
            };

            updateStats();
            updateGraphs();
        }

        // UI Functions
        function updateStats() {
            document.getElementById('epochCount').textContent = trainingStats.epoch;
            document.getElementById('sampleCount').textContent = trainingStats.samples;

            const elapsed = (Date.now() - trainingStats.startTime) / 1000;
            document.getElementById('trainingTime').textContent = elapsed.toFixed(1) + 's';

            if (trainingStats.lossHistory.length > 0) {
                const currentLoss = trainingStats.lossHistory[trainingStats.lossHistory.length - 1];
                document.getElementById('currentLoss').textContent = currentLoss.toFixed(4);
            }

            if (trainingStats.accuracyHistory.length > 0) {
                const currentAccuracy = trainingStats.accuracyHistory[trainingStats.accuracyHistory.length - 1];
                document.getElementById('accuracyValue').textContent = (currentAccuracy * 100).toFixed(2) + '%';
            }
        }

        function updateGraphs() {
            // Update loss graph
            const lossCanvas = document.getElementById('lossCanvas');
            const lossCtx = lossCanvas.getContext('2d');
            lossCanvas.width = lossCanvas.clientWidth;
            lossCanvas.height = lossCanvas.clientHeight;

            if (trainingStats.lossHistory.length > 1) {
                lossCtx.strokeStyle = '#00ff88';
                lossCtx.lineWidth = 2;
                lossCtx.beginPath();

                const maxLoss = Math.max(...trainingStats.lossHistory);
                const scale = lossCanvas.height / (maxLoss || 1);

                for (let i = 0; i < trainingStats.lossHistory.length; i++) {
                    const x = (i / (trainingStats.lossHistory.length - 1)) * lossCanvas.width;
                    const y = lossCanvas.height - trainingStats.lossHistory[i] * scale;

                    if (i === 0) {
                        lossCtx.moveTo(x, y);
                    } else {
                        lossCtx.lineTo(x, y);
                    }
                }

                lossCtx.stroke();
            }

            // Update accuracy graph
            const accuracyCanvas = document.getElementById('accuracyCanvas');
            const accuracyCtx = accuracyCanvas.getContext('2d');
            accuracyCanvas.width = accuracyCanvas.clientWidth;
            accuracyCanvas.height = accuracyCanvas.clientHeight;

            if (trainingStats.accuracyHistory.length > 1) {
                accuracyCtx.strokeStyle = '#00ddff';
                accuracyCtx.lineWidth = 2;
                accuracyCtx.beginPath();

                for (let i = 0; i < trainingStats.accuracyHistory.length; i++) {
                    const x = (i / (trainingStats.accuracyHistory.length - 1)) * accuracyCanvas.width;
                    const y = accuracyCanvas.height - trainingStats.accuracyHistory[i] * accuracyCanvas.height;

                    if (i === 0) {
                        accuracyCtx.moveTo(x, y);
                    } else {
                        accuracyCtx.lineTo(x, y);
                    }
                }

                accuracyCtx.stroke();
            }
        }

        function updateDecisionBoundary() {
            if (!network) return;

            const canvas = document.getElementById('boundaryCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;

            const resolution = 30;
            const cellWidth = canvas.width / resolution;
            const cellHeight = canvas.height / resolution;

            // Draw decision boundary
            for (let x = 0; x < resolution; x++) {
                for (let y = 0; y < resolution; y++) {
                    const input = [
                        (x / resolution) * 2 - 1,
                        (y / resolution) * 2 - 1
                    ];

                    const output = network.forward(input);
                    const class0 = output[0];
                    const class1 = output.length > 1 ? output[1] : 1 - class0;

                    const hue = class0 > class1 ? 200 : 0;
                    const alpha = Math.abs(class0 - class1);

                    ctx.fillStyle = `hsla(${hue}, 100%, 50%, ${alpha * 0.3})`;
                    ctx.fillRect(x * cellWidth, y * cellHeight, cellWidth, cellHeight);
                }
            }

            // Draw data points
            if (dataset && dataset.length > 0) {
                for (const point of dataset) {
                    const x = (point.input[0] + 1) * canvas.width / 2;
                    const y = (point.input[1] + 1) * canvas.height / 2;

                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, Math.PI * 2);

                    const isClass0 = point.output[0] > 0.5;
                    ctx.fillStyle = isClass0 ? '#00ddff' : '#ff4444';
                    ctx.fill();
                }
            }
        }

        function addLayer() {
            const architectureLayers = document.getElementById('architectureLayers');
            const layerCount = architectureLayers.children.length - 1; // Exclude output layer

            const newLayer = document.createElement('div');
            newLayer.className = 'layer-config';
            newLayer.innerHTML = `
                <span class="layer-number">Hidden ${layerCount}:</span>
                <input type="number" class="layer-input" value="4" min="1" max="100">
                <span style="color: #666;">neurons</span>
                <button class="layer-remove" onclick="this.parentElement.remove()">√ó</button>
            `;

            architectureLayers.insertBefore(newLayer, architectureLayers.lastElementChild);
        }

        function buildNetwork() {
            const layers = Array.from(document.querySelectorAll('.layer-input')).map(input => parseInt(input.value));
            network = new NeuralNetwork(layers);
            visualizer.draw(network);

            // Reset stats
            trainingStats = {
                epoch: 0,
                samples: 0,
                startTime: Date.now(),
                lossHistory: [],
                accuracyHistory: []
            };

            updateStats();
        }

        // Data Import/Export
        function saveData() {
            if (network) {
                appData = {
                    network: {
                        architecture: network.architecture,
                        weights: network.weights,
                        biases: network.biases
                    },
                    trainingStats: trainingStats,
                    settings: {
                        learningRate: document.getElementById('learningRate').value,
                        batchSize: document.getElementById('batchSize').value,
                        currentExhibit: currentExhibit
                    }
                };

                localStorage.setItem(APP_NAME, JSON.stringify(appData));
            }
        }

        function exportData() {
            saveData();
            const dataStr = JSON.stringify(appData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `${APP_NAME}-model-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);
        }

        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    appData = JSON.parse(e.target.result);

                    // Restore network
                    if (appData.network) {
                        network = new NeuralNetwork(appData.network.architecture);
                        network.weights = appData.network.weights;
                        network.biases = appData.network.biases;
                        visualizer.draw(network);
                    }

                    // Restore stats
                    if (appData.trainingStats) {
                        trainingStats = appData.trainingStats;
                        updateStats();
                        updateGraphs();
                    }

                    // Restore settings
                    if (appData.settings) {
                        document.getElementById('learningRate').value = appData.settings.learningRate;
                        document.getElementById('batchSize').value = appData.settings.batchSize;
                        document.getElementById('learningRateValue').textContent = appData.settings.learningRate;
                        document.getElementById('batchSizeValue').textContent = appData.settings.batchSize;
                    }

                    saveData();
                    alert('Model imported successfully!');
                } catch (error) {
                    alert('Invalid model file');
                    console.error(error);
                }
            };
            reader.readAsText(file);
        }

        // Drawing functions for custom dataset
        let drawingCanvas, drawingCtx;
        let customDataset = [];

        function initDrawing() {
            drawingCanvas = document.getElementById('drawingCanvas');
            drawingCtx = drawingCanvas.getContext('2d');

            drawingCanvas.addEventListener('click', function(e) {
                const rect = drawingCanvas.getBoundingClientRect();
                const x = (e.clientX - rect.left) / rect.width * 2 - 1;
                const y = (e.clientY - rect.top) / rect.height * 2 - 1;

                customDataset.push({
                    input: [x, y],
                    output: drawingClass === 0 ? [1, 0] : [0, 1]
                });

                drawCustomDataset();
                dataset = [...customDataset];
            });

            clearDrawing();
        }

        function drawCustomDataset() {
            drawingCtx.fillStyle = '#000';
            drawingCtx.fillRect(0, 0, drawingCanvas.width, drawingCanvas.height);

            for (const point of customDataset) {
                const x = (point.input[0] + 1) * drawingCanvas.width / 2;
                const y = (point.input[1] + 1) * drawingCanvas.height / 2;

                drawingCtx.beginPath();
                drawingCtx.arc(x, y, 5, 0, Math.PI * 2);
                drawingCtx.fillStyle = point.output[0] > 0.5 ? '#0088ff' : '#ff4444';
                drawingCtx.fill();
            }
        }

        function setDrawClass(classIndex) {
            drawingClass = classIndex;
            document.querySelectorAll('.control-btn').forEach(btn => {
                if (btn.textContent.includes('Class')) {
                    btn.classList.remove('active');
                }
            });
            event.target.classList.add('active');
        }

        function clearDrawing() {
            customDataset = [];
            drawingCtx.fillStyle = '#000';
            drawingCtx.fillRect(0, 0, drawingCanvas.width, drawingCanvas.height);
            dataset = [];
        }

        // Initialize
        let visualizer;

        window.onload = function() {
            // Initialize canvas
            const canvas = document.getElementById('networkCanvas');
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;

            visualizer = new NetworkVisualizer(canvas);

            // Initialize network
            buildNetwork();

            // Initialize dataset
            dataset = generateXORDataset();

            // Initialize drawing
            initDrawing();

            // Event listeners
            document.getElementById('learningRate').addEventListener('input', function() {
                document.getElementById('learningRateValue').textContent = this.value;
            });

            document.getElementById('batchSize').addEventListener('input', function() {
                document.getElementById('batchSizeValue').textContent = this.value;
            });

            // Exhibit selection
            document.querySelectorAll('.exhibit-card').forEach(card => {
                card.addEventListener('click', function() {
                    document.querySelectorAll('.exhibit-card').forEach(c => c.classList.remove('active'));
                    this.classList.add('active');
                    currentExhibit = this.dataset.exhibit;

                    // Update info panel based on exhibit
                    updateExhibitInfo(currentExhibit);
                });
            });

            // Dataset selection
            document.querySelectorAll('.dataset-option').forEach(option => {
                option.addEventListener('click', function() {
                    document.querySelectorAll('.dataset-option').forEach(o => o.classList.remove('active'));
                    this.classList.add('active');

                    const datasetType = this.dataset.dataset;

                    // Show/hide drawing area
                    if (datasetType === 'custom') {
                        document.getElementById('drawingArea').style.display = 'block';
                        dataset = customDataset;
                    } else {
                        document.getElementById('drawingArea').style.display = 'none';

                        switch(datasetType) {
                            case 'xor':
                                dataset = generateXORDataset();
                                break;
                            case 'spiral':
                                dataset = generateSpiralDataset();
                                break;
                            case 'circles':
                                dataset = generateCirclesDataset();
                                break;
                            case 'moons':
                                dataset = generateMoonsDataset();
                                break;
                            case 'gaussian':
                                dataset = generateGaussianDataset();
                                break;
                        }
                    }

                    updateDecisionBoundary();
                });
            });

            // Speed control
            document.querySelectorAll('.speed-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.speed-btn').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    visualizationSpeed = this.dataset.speed;
                });
            });

            // Animation loop
            function animate() {
                if (!isTraining) {
                    visualizer.draw(network);
                }
                requestAnimationFrame(animate);
            }
            animate();

            // Window resize handler
            window.addEventListener('resize', function() {
                canvas.width = canvas.clientWidth;
                canvas.height = canvas.clientHeight;
                visualizer.draw(network);
            });
        };

        function updateExhibitInfo(exhibit) {
            const infoContent = document.getElementById('infoContent');

            const exhibitInfo = {
                feedforward: `
                    <h3>Feedforward Neural Network</h3>
                    <p>The classic artificial neural network architecture. Data flows in one direction from input to output through hidden layers.</p>
                    <p><strong>Best for:</strong> Classification, regression, pattern recognition</p>
                    <p><strong>Try:</strong> Start with the XOR dataset - a classic problem that requires hidden layers to solve!</p>
                `,
                cnn: `
                    <h3>Convolutional Neural Network (CNN)</h3>
                    <p>Specialized for processing grid-like data such as images. Uses convolution operations to detect features.</p>
                    <p><strong>Best for:</strong> Image recognition, computer vision</p>
                    <p><strong>Key concepts:</strong> Filters, pooling, feature maps</p>
                `,
                rnn: `
                    <h3>Recurrent Neural Network (RNN)</h3>
                    <p>Networks with memory! RNNs can process sequences by maintaining internal state.</p>
                    <p><strong>Best for:</strong> Time series, text, speech</p>
                    <p><strong>Key concepts:</strong> Hidden state, sequence processing</p>
                `,
                gan: `
                    <h3>Generative Adversarial Network (GAN)</h3>
                    <p>Two networks competing: a generator creates fake data, while a discriminator tries to detect fakes.</p>
                    <p><strong>Best for:</strong> Image generation, data augmentation</p>
                    <p><strong>Watch:</strong> See the networks compete and improve!</p>
                `,
                autoencoder: `
                    <h3>Autoencoder</h3>
                    <p>Compresses data into a smaller representation, then reconstructs it. Learns efficient encodings.</p>
                    <p><strong>Best for:</strong> Dimensionality reduction, denoising</p>
                    <p><strong>Key concepts:</strong> Encoder, decoder, latent space</p>
                `,
                transformer: `
                    <h3>Transformer</h3>
                    <p>The architecture behind modern AI! Uses attention mechanisms to process data in parallel.</p>
                    <p><strong>Best for:</strong> Language models, translation</p>
                    <p><strong>Key concepts:</strong> Self-attention, positional encoding</p>
                `
            };

            infoContent.innerHTML = exhibitInfo[exhibit] || exhibitInfo.feedforward;
        }
    </script>
</body>
</html>