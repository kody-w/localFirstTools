<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Distributed System Chaos Simulator - Interactive Consensus Learning</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
            color: #ffffff;
            overflow: hidden;
            height: 100vh;
        }

        #canvas {
            display: block;
            cursor: crosshair;
        }

        .controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(26, 26, 46, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(100, 255, 218, 0.2);
            border-radius: 16px;
            padding: 20px;
            min-width: 280px;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }

        .controls h2 {
            margin-bottom: 15px;
            font-size: 1.2em;
            font-weight: 300;
            background: linear-gradient(135deg, #64ffda, #00bfa5);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            color: #a0a0a0;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
            border-radius: 3px;
            appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 18px;
            height: 18px;
            background: linear-gradient(135deg, #64ffda, #00bfa5);
            cursor: pointer;
            border-radius: 50%;
            box-shadow: 0 2px 10px rgba(100, 255, 218, 0.5);
        }

        .value-display {
            text-align: right;
            color: #64ffda;
            font-weight: 600;
            margin-top: 5px;
            font-size: 0.9em;
        }

        .btn {
            width: 100%;
            padding: 12px;
            margin-top: 8px;
            background: linear-gradient(135deg, rgba(100, 255, 218, 0.2), rgba(0, 191, 165, 0.2));
            border: 1.5px solid rgba(100, 255, 218, 0.4);
            border-radius: 10px;
            color: white;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 600;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .btn:hover {
            background: linear-gradient(135deg, rgba(100, 255, 218, 0.3), rgba(0, 191, 165, 0.3));
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(100, 255, 218, 0.3);
        }

        .btn-danger {
            background: linear-gradient(135deg, rgba(255, 64, 129, 0.2), rgba(255, 0, 110, 0.2));
            border-color: rgba(255, 64, 129, 0.4);
        }

        .btn-danger:hover {
            background: linear-gradient(135deg, rgba(255, 64, 129, 0.3), rgba(255, 0, 110, 0.3));
            box-shadow: 0 5px 20px rgba(255, 64, 129, 0.3);
        }

        .metrics {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(26, 26, 46, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(100, 255, 218, 0.2);
            border-radius: 16px;
            padding: 20px;
            min-width: 250px;
        }

        .metrics h3 {
            margin-bottom: 15px;
            font-size: 1.1em;
            font-weight: 300;
            color: #64ffda;
        }

        .metric {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-size: 0.9em;
        }

        .metric-label {
            color: #a0a0a0;
        }

        .metric-value {
            color: #ffffff;
            font-weight: 600;
        }

        .scenarios {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(26, 26, 46, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(100, 255, 218, 0.2);
            border-radius: 16px;
            padding: 20px;
            min-width: 280px;
        }

        .scenarios h3 {
            margin-bottom: 15px;
            font-size: 1.1em;
            font-weight: 300;
            color: #64ffda;
        }

        .scenario-btn {
            padding: 10px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            color: #a0a0a0;
            cursor: pointer;
            font-size: 0.85em;
            transition: all 0.3s ease;
            text-align: left;
        }

        .scenario-btn:hover {
            background: rgba(100, 255, 218, 0.1);
            border-color: #64ffda;
            color: #64ffda;
        }

        .info {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(26, 26, 46, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(100, 255, 218, 0.2);
            border-radius: 16px;
            padding: 15px;
            max-width: 300px;
            font-size: 0.85em;
            color: #a0a0a0;
            line-height: 1.5;
        }

        .legend {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
            font-size: 0.85em;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 10px;
        }

        @media (max-width: 768px) {
            .controls, .metrics, .scenarios, .info {
                position: static;
                margin: 10px;
                max-width: calc(100vw - 20px);
            }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div class="controls">
        <h2>üåê System Controls</h2>

        <div class="control-group">
            <label>Node Count</label>
            <input type="range" id="nodeCount" min="3" max="7" value="5" step="1">
            <div class="value-display" id="nodeCountValue">5 nodes</div>
        </div>

        <div class="control-group">
            <label>Network Latency</label>
            <input type="range" id="latency" min="0" max="500" value="50" step="10">
            <div class="value-display" id="latencyValue">50ms</div>
        </div>

        <div class="control-group">
            <label>Simulation Speed</label>
            <input type="range" id="speed" min="1" max="10" value="3" step="1">
            <div class="value-display" id="speedValue">3x</div>
        </div>

        <button class="btn" onclick="toggleSimulation()">‚è∏Ô∏è Pause/Resume</button>
        <button class="btn" onclick="resetSimulation()">üîÑ Reset</button>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: #ffd700;"></div>
                <span>Leader</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #4444ff;"></div>
                <span>Follower</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #9944ff;"></div>
                <span>Candidate</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #ff4444;"></div>
                <span>Failed</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #888888;"></div>
                <span>Partitioned</span>
            </div>
        </div>
    </div>

    <div class="metrics">
        <h3>üìä Metrics</h3>
        <div class="metric">
            <span class="metric-label">Leader:</span>
            <span class="metric-value" id="leaderNode">None</span>
        </div>
        <div class="metric">
            <span class="metric-label">Current Term:</span>
            <span class="metric-value" id="currentTerm">0</span>
        </div>
        <div class="metric">
            <span class="metric-label">Messages Sent:</span>
            <span class="metric-value" id="messagesSent">0</span>
        </div>
        <div class="metric">
            <span class="metric-label">Elections:</span>
            <span class="metric-value" id="elections">0</span>
        </div>
        <div class="metric">
            <span class="metric-label">Avg Latency:</span>
            <span class="metric-value" id="avgLatency">0ms</span>
        </div>
        <div class="metric">
            <span class="metric-label">Uptime:</span>
            <span class="metric-value" id="uptime">0s</span>
        </div>
    </div>

    <div class="scenarios">
        <h3>üí• Chaos Scenarios</h3>
        <button class="scenario-btn" onclick="killRandomNode()">
            ‚ö° Kill Random Node
        </button>
        <button class="scenario-btn" onclick="networkPartition()">
            üîå Network Partition (Split-Brain)
        </button>
        <button class="scenario-btn" onclick="leaderFailure()">
            üëë Kill Leader
        </button>
        <button class="scenario-btn" onclick="cascadingFailure()">
            üåä Cascading Failure
        </button>
        <button class="scenario-btn" onclick="healAll()">
            ‚úÖ Heal All Nodes
        </button>
    </div>

    <div class="info">
        <strong>How to Use:</strong><br>
        ‚Ä¢ Click nodes to kill/revive them<br>
        ‚Ä¢ Watch leader elections happen automatically<br>
        ‚Ä¢ Adjust latency to see consensus delays<br>
        ‚Ä¢ Try chaos scenarios to test resilience<br>
        ‚Ä¢ Observe how Raft maintains consistency
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        // Raft Node States
        const STATE = {
            FOLLOWER: 'follower',
            CANDIDATE: 'candidate',
            LEADER: 'leader',
            FAILED: 'failed',
            PARTITIONED: 'partitioned'
        };

        // Global simulation state
        let nodes = [];
        let messages = [];
        let currentTerm = 0;
        let electionCount = 0;
        let messageSentCount = 0;
        let simulationTime = 0;
        let isPaused = false;
        let lastFrameTime = Date.now();

        // Raft Node Class
        class RaftNode {
            constructor(id, x, y) {
                this.id = id;
                this.x = x;
                this.y = y;
                this.state = STATE.FOLLOWER;
                this.currentTerm = 0;
                this.votedFor = null;
                this.votes = 0;
                this.electionTimeout = this.randomElectionTimeout();
                this.electionTimer = 0;
                this.heartbeatTimer = 0;
                this.log = [];
                this.commitIndex = 0;
                this.lastApplied = 0;
                this.alive = true;
                this.partitioned = false;
            }

            randomElectionTimeout() {
                return 150 + Math.random() * 150; // 150-300ms
            }

            becomeFollower(term) {
                this.state = STATE.FOLLOWER;
                this.currentTerm = term;
                this.votedFor = null;
                this.votes = 0;
                this.electionTimer = 0;
            }

            becomeCandidate() {
                this.state = STATE.CANDIDATE;
                this.currentTerm++;
                this.votedFor = this.id;
                this.votes = 1; // Vote for self
                this.electionTimer = 0;
                this.electionTimeout = this.randomElectionTimeout();
                electionCount++;

                // Request votes from all other nodes
                nodes.forEach(node => {
                    if (node.id !== this.id && node.alive && !node.partitioned) {
                        sendMessage(this.id, node.id, 'RequestVote', {
                            term: this.currentTerm,
                            candidateId: this.id
                        });
                    }
                });
            }

            becomeLeader() {
                this.state = STATE.LEADER;
                this.heartbeatTimer = 0;

                // Send initial heartbeat
                this.sendHeartbeats();
            }

            sendHeartbeats() {
                nodes.forEach(node => {
                    if (node.id !== this.id && node.alive && !node.partitioned) {
                        sendMessage(this.id, node.id, 'Heartbeat', {
                            term: this.currentTerm,
                            leaderId: this.id
                        });
                    }
                });
            }

            update(deltaTime) {
                if (!this.alive) return;

                const speedFactor = parseInt(document.getElementById('speed').value);
                const adjustedDelta = deltaTime * speedFactor;

                if (this.state === STATE.FOLLOWER || this.state === STATE.CANDIDATE) {
                    this.electionTimer += adjustedDelta;

                    if (this.electionTimer >= this.electionTimeout) {
                        this.becomeCandidate();
                    }
                }

                if (this.state === STATE.LEADER) {
                    this.heartbeatTimer += adjustedDelta;

                    if (this.heartbeatTimer >= 50) { // Heartbeat every 50ms
                        this.sendHeartbeats();
                        this.heartbeatTimer = 0;
                    }
                }
            }

            handleMessage(msg) {
                if (!this.alive || this.partitioned) return;

                if (msg.type === 'RequestVote') {
                    if (msg.data.term > this.currentTerm) {
                        this.becomeFollower(msg.data.term);
                    }

                    const voteGranted = msg.data.term === this.currentTerm &&
                                       (this.votedFor === null || this.votedFor === msg.data.candidateId);

                    sendMessage(this.id, msg.from, 'VoteResponse', {
                        term: this.currentTerm,
                        voteGranted: voteGranted
                    });

                    if (voteGranted) {
                        this.votedFor = msg.data.candidateId;
                    }
                }

                if (msg.type === 'VoteResponse') {
                    if (this.state === STATE.CANDIDATE && msg.data.term === this.currentTerm) {
                        if (msg.data.voteGranted) {
                            this.votes++;

                            const majority = Math.floor(nodes.filter(n => n.alive && !n.partitioned).length / 2) + 1;
                            if (this.votes >= majority) {
                                this.becomeLeader();
                            }
                        }
                    }
                }

                if (msg.type === 'Heartbeat') {
                    if (msg.data.term >= this.currentTerm) {
                        this.becomeFollower(msg.data.term);
                        currentTerm = msg.data.term;
                    }
                }
            }

            draw() {
                const colors = {
                    [STATE.LEADER]: '#ffd700',
                    [STATE.FOLLOWER]: '#4444ff',
                    [STATE.CANDIDATE]: '#9944ff',
                    [STATE.FAILED]: '#ff4444',
                    [STATE.PARTITIONED]: '#888888'
                };

                let displayState = this.state;
                if (!this.alive) displayState = STATE.FAILED;
                if (this.partitioned) displayState = STATE.PARTITIONED;

                // Draw node
                ctx.beginPath();
                ctx.arc(this.x, this.y, 40, 0, Math.PI * 2);
                ctx.fillStyle = colors[displayState];
                ctx.fill();

                if (this.state === STATE.LEADER && this.alive) {
                    ctx.strokeStyle = '#ffd700';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }

                // Draw node ID
                ctx.fillStyle = '#000000';
                ctx.font = 'bold 16px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.id, this.x, this.y);

                // Draw state label
                ctx.fillStyle = '#ffffff';
                ctx.font = '12px sans-serif';
                let stateLabel = displayState.toUpperCase();
                if (!this.alive) stateLabel = 'FAILED';
                if (this.partitioned) stateLabel = 'PARTITIONED';
                ctx.fillText(stateLabel, this.x, this.y + 60);
            }
        }

        // Message Class
        class Message {
            constructor(from, to, type, data) {
                this.from = from;
                this.to = to;
                this.type = type;
                this.data = data;
                this.progress = 0;
                this.delivered = false;

                const fromNode = nodes.find(n => n.id === from);
                const toNode = nodes.find(n => n.id === to);

                if (fromNode && toNode) {
                    this.startX = fromNode.x;
                    this.startY = fromNode.y;
                    this.endX = toNode.x;
                    this.endY = toNode.y;
                }
            }

            update(deltaTime) {
                const baseLatency = parseInt(document.getElementById('latency').value);
                const speed = 1000 / (baseLatency + 100); // Speed based on latency
                this.progress += deltaTime * speed * 0.001;

                if (this.progress >= 1 && !this.delivered) {
                    this.delivered = true;
                    const toNode = nodes.find(n => n.id === this.to);
                    if (toNode) {
                        toNode.handleMessage(this);
                    }
                }
            }

            draw() {
                if (this.delivered) return;

                const currentX = this.startX + (this.endX - this.startX) * this.progress;
                const currentY = this.startY + (this.endY - this.startY) * this.progress;

                const colors = {
                    'RequestVote': '#9944ff',
                    'VoteResponse': '#64ffda',
                    'Heartbeat': '#00ff00'
                };

                ctx.beginPath();
                ctx.arc(currentX, currentY, 5, 0, Math.PI * 2);
                ctx.fillStyle = colors[this.type] || '#ffffff';
                ctx.fill();

                // Draw line from start to current position
                ctx.beginPath();
                ctx.moveTo(this.startX, this.startY);
                ctx.lineTo(currentX, currentY);
                ctx.strokeStyle = colors[this.type] || '#ffffff';
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.5;
                ctx.stroke();
                ctx.globalAlpha = 1;
            }
        }

        function sendMessage(from, to, type, data) {
            messages.push(new Message(from, to, type, data));
            messageSentCount++;
        }

        function initializeNodes() {
            const nodeCount = parseInt(document.getElementById('nodeCount').value);
            nodes = [];

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = Math.min(canvas.width, canvas.height) * 0.3;

            for (let i = 0; i < nodeCount; i++) {
                const angle = (i / nodeCount) * Math.PI * 2 - Math.PI / 2;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                nodes.push(new RaftNode(i, x, y));
            }
        }

        function resetSimulation() {
            initializeNodes();
            messages = [];
            currentTerm = 0;
            electionCount = 0;
            messageSentCount = 0;
            simulationTime = 0;
        }

        function toggleSimulation() {
            isPaused = !isPaused;
        }

        function killRandomNode() {
            const aliveNodes = nodes.filter(n => n.alive);
            if (aliveNodes.length > 0) {
                const node = aliveNodes[Math.floor(Math.random() * aliveNodes.length)];
                node.alive = false;
                node.state = STATE.FAILED;
            }
        }

        function networkPartition() {
            const half = Math.floor(nodes.length / 2);
            nodes.forEach((node, i) => {
                node.partitioned = i < half;
            });
        }

        function leaderFailure() {
            const leader = nodes.find(n => n.state === STATE.LEADER && n.alive);
            if (leader) {
                leader.alive = false;
                leader.state = STATE.FAILED;
            }
        }

        function cascadingFailure() {
            let delay = 0;
            nodes.forEach((node, i) => {
                setTimeout(() => {
                    if (Math.random() < 0.4 && node.alive) {
                        node.alive = false;
                        node.state = STATE.FAILED;
                    }
                }, delay);
                delay += 500;
            });
        }

        function healAll() {
            nodes.forEach(node => {
                node.alive = true;
                node.partitioned = false;
                if (node.state === STATE.FAILED) {
                    node.becomeFollower(currentTerm);
                }
            });
        }

        function updateMetrics() {
            const leader = nodes.find(n => n.state === STATE.LEADER && n.alive);
            document.getElementById('leaderNode').textContent = leader ? `Node ${leader.id}` : 'None';
            document.getElementById('currentTerm').textContent = currentTerm;
            document.getElementById('messagesSent').textContent = messageSentCount;
            document.getElementById('elections').textContent = electionCount;

            const baseLatency = parseInt(document.getElementById('latency').value);
            document.getElementById('avgLatency').textContent = `${baseLatency}ms`;
            document.getElementById('uptime').textContent = `${Math.floor(simulationTime / 1000)}s`;
        }

        function animate() {
            const now = Date.now();
            const deltaTime = now - lastFrameTime;
            lastFrameTime = now;

            if (!isPaused) {
                simulationTime += deltaTime;

                // Update nodes
                nodes.forEach(node => node.update(deltaTime));

                // Update messages
                messages.forEach(msg => msg.update(deltaTime));

                // Remove delivered messages
                messages = messages.filter(msg => !msg.delivered);
            }

            // Clear canvas
            ctx.fillStyle = 'rgba(10, 10, 10, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw connections
            ctx.strokeStyle = 'rgba(100, 255, 218, 0.1)';
            ctx.lineWidth = 1;
            for (let i = 0; i < nodes.length; i++) {
                for (let j = i + 1; j < nodes.length; j++) {
                    ctx.beginPath();
                    ctx.moveTo(nodes[i].x, nodes[i].y);
                    ctx.lineTo(nodes[j].x, nodes[j].y);
                    ctx.stroke();
                }
            }

            // Draw messages
            messages.forEach(msg => msg.draw());

            // Draw nodes
            nodes.forEach(node => node.draw());

            // Update metrics
            updateMetrics();

            requestAnimationFrame(animate);
        }

        // Canvas click handler
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            nodes.forEach(node => {
                const dx = x - node.x;
                const dy = y - node.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < 40) {
                    node.alive = !node.alive;
                    if (!node.alive) {
                        node.state = STATE.FAILED;
                    } else {
                        node.becomeFollower(currentTerm);
                        node.partitioned = false;
                    }
                }
            });
        });

        // Update value displays
        document.getElementById('nodeCount').addEventListener('input', (e) => {
            document.getElementById('nodeCountValue').textContent = `${e.target.value} nodes`;
        });

        document.getElementById('latency').addEventListener('input', (e) => {
            document.getElementById('latencyValue').textContent = `${e.target.value}ms`;
        });

        document.getElementById('speed').addEventListener('input', (e) => {
            document.getElementById('speedValue').textContent = `${e.target.value}x`;
        });

        document.getElementById('nodeCount').addEventListener('change', resetSimulation);

        // Initialize and start
        initializeNodes();
        animate();
    </script>
</body>
</html>
