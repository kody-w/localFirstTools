<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sky Realms - 3D Social Battle Royale</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            overflow: hidden;
            background: #000;
            color: #fff;
        }

        #gameCanvas {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        #ui {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        #ui > * {
            pointer-events: auto;
        }

        /* Main Menu */
        #mainMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: linear-gradient(135deg, rgba(15,15,35,0.95) 0%, rgba(25,25,55,0.95) 100%);
            padding: 50px;
            border-radius: 20px;
            box-shadow: 0 0 50px rgba(100,200,255,0.3);
            backdrop-filter: blur(10px);
        }

        #mainMenu h1 {
            font-size: 4em;
            background: linear-gradient(45deg, #00ffff, #ff00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 20px;
            text-shadow: 0 0 30px rgba(100,200,255,0.5);
        }

        .menuButton {
            display: block;
            width: 300px;
            margin: 15px auto;
            padding: 15px 30px;
            font-size: 1.2em;
            background: linear-gradient(45deg, #1e90ff, #00bfff);
            border: none;
            border-radius: 50px;
            color: white;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 2px;
            box-shadow: 0 5px 20px rgba(30,144,255,0.4);
        }

        .menuButton:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 30px rgba(30,144,255,0.6);
            background: linear-gradient(45deg, #00bfff, #1e90ff);
        }

        /* HUD */
        #hud {
            position: absolute;
            width: 100%;
            height: 100%;
            display: none;
        }

        #healthBar {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 30px;
            background: rgba(0,0,0,0.5);
            border: 2px solid #fff;
            border-radius: 15px;
            overflow: hidden;
        }

        #healthFill {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ff6600);
            transition: width 0.3s;
        }

        #shieldBar {
            position: absolute;
            bottom: 65px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 20px;
            background: rgba(0,0,0,0.5);
            border: 2px solid #00ffff;
            border-radius: 10px;
            overflow: hidden;
        }

        #shieldFill {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #00ffff, #0099ff);
            transition: width 0.3s;
        }

        #ammoDisplay {
            position: absolute;
            bottom: 30px;
            right: 30px;
            font-size: 2em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        #killCount {
            position: absolute;
            top: 30px;
            right: 30px;
            font-size: 1.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        #minimap {
            position: absolute;
            top: 30px;
            left: 30px;
            width: 200px;
            height: 200px;
            background: rgba(0,0,0,0.7);
            border: 2px solid #fff;
            border-radius: 10px;
        }

        #playerCount {
            position: absolute;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.5em;
            background: rgba(0,0,0,0.7);
            padding: 10px 20px;
            border-radius: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        /* Chat */
        #chatContainer {
            position: absolute;
            bottom: 120px;
            left: 30px;
            width: 300px;
            height: 200px;
            background: rgba(0,0,0,0.5);
            border-radius: 10px;
            padding: 10px;
            display: none;
        }

        #chatMessages {
            height: 150px;
            overflow-y: auto;
            margin-bottom: 10px;
        }

        #chatInput {
            width: 100%;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            padding: 5px;
            border-radius: 5px;
        }

        /* Crosshair */
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 40px;
            display: none;
        }

        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: white;
            box-shadow: 0 0 3px rgba(0,0,0,0.8);
        }

        #crosshair::before {
            width: 2px;
            height: 100%;
            left: 50%;
            transform: translateX(-50%);
        }

        #crosshair::after {
            width: 100%;
            height: 2px;
            top: 50%;
            transform: translateY(-50%);
        }

        /* Victory Screen */
        #victoryScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: linear-gradient(135deg, rgba(255,215,0,0.95) 0%, rgba(255,140,0,0.95) 100%);
            padding: 50px;
            border-radius: 20px;
            display: none;
        }

        #victoryScreen h2 {
            font-size: 3em;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        /* Loading Screen */
        #loadingScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        .loader {
            width: 80px;
            height: 80px;
            border: 5px solid rgba(255,255,255,0.1);
            border-top: 5px solid #00ffff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Inventory */
        #inventory {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            margin-bottom: 70px;
        }

        .inventorySlot {
            width: 60px;
            height: 60px;
            background: rgba(0,0,0,0.7);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2em;
            cursor: pointer;
            transition: all 0.2s;
        }

        .inventorySlot.active {
            border-color: #00ffff;
            box-shadow: 0 0 20px rgba(0,255,255,0.5);
        }

        .inventorySlot:hover {
            transform: scale(1.1);
        }

        /* Emote Menu */
        #emoteMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            padding: 30px;
            border-radius: 20px;
            display: none;
            grid-template-columns: repeat(4, 80px);
            gap: 20px;
        }

        .emoteButton {
            width: 80px;
            height: 80px;
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 10px;
            font-size: 2em;
            cursor: pointer;
            transition: all 0.2s;
        }

        #gamepadNotification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 255, 0, 0.9);
            padding: 20px 40px;
            border-radius: 10px;
            font-size: 1.5em;
            display: none;
            z-index: 1000;
        }

        #controlsHelp {
            position: absolute;
            bottom: 30px;
            right: 30px;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 10px;
            font-size: 0.9em;
            max-width: 250px;
        }

        .controlsRow {
            margin: 5px 0;
            display: flex;
            justify-content: space-between;
        }

        .controlKey {
            color: #00ffff;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui">
        <!-- Loading Screen -->
        <div id="loadingScreen">
            <div class="loader"></div>
            <h2 style="margin-top: 30px;">Loading Sky Realms...</h2>
        </div>

        <!-- Main Menu -->
        <div id="mainMenu" style="display: none;">
            <h1>Sky Realms</h1>
            <p style="margin-bottom: 30px; font-size: 1.2em; opacity: 0.8;">Battle Royale in the Clouds</p>
            <button class="menuButton" onclick="startGame('solo')">Solo Battle</button>
            <button class="menuButton" onclick="startGame('duo')">Duo Mode</button>
            <button class="menuButton" onclick="startGame('squad')">Squad Mode</button>
            <button class="menuButton" onclick="showCustomization()">Customize</button>
            <p style="margin-top: 30px; font-size: 0.9em; opacity: 0.6;">🎮 Gamepad supported! Connect a controller to play</p>
        </div>

        <!-- HUD -->
        <div id="hud">
            <div id="minimap"></div>
            <div id="playerCount">Players: 100</div>
            <div id="killCount">Eliminations: 0</div>
            
            <div id="inventory">
                <div class="inventorySlot active">🔫</div>
                <div class="inventorySlot">🛡️</div>
                <div class="inventorySlot">💊</div>
                <div class="inventorySlot">🧱</div>
                <div class="inventorySlot">⚡</div>
            </div>

            <div id="shieldBar">
                <div id="shieldFill"></div>
            </div>
            <div id="healthBar">
                <div id="healthFill"></div>
            </div>
            
            <div id="ammoDisplay">30 / 150</div>
            
            <div id="crosshair"></div>

            <div id="chatContainer">
                <div id="chatMessages"></div>
                <input type="text" id="chatInput" placeholder="Press Enter to chat...">
            </div>
        </div>

        <!-- Emote Menu -->
        <div id="emoteMenu">
            <button class="emoteButton" onclick="playEmote('dance')">💃</button>
            <button class="emoteButton" onclick="playEmote('wave')">👋</button>
            <button class="emoteButton" onclick="playEmote('laugh')">😂</button>
            <button class="emoteButton" onclick="playEmote('cry')">😢</button>
            <button class="emoteButton" onclick="playEmote('angry')">😠</button>
            <button class="emoteButton" onclick="playEmote('love')">❤️</button>
            <button class="emoteButton" onclick="playEmote('gg')">🎮</button>
            <button class="emoteButton" onclick="playEmote('victory')">🏆</button>
        </div>

        <!-- Victory Screen -->
        <div id="victoryScreen">
            <h2>Victory Royale!</h2>
            <p style="font-size: 1.5em;">Eliminations: <span id="finalKills">0</span></p>
            <button class="menuButton" onclick="returnToMenu()">Return to Menu</button>
        </div>

        <!-- Gamepad Notification -->
        <div id="gamepadNotification"></div>

        <!-- Controls Help -->
        <div id="controlsHelp" style="display: none;">
            <h3 style="color: #00ffff; margin-bottom: 10px;">Controls</h3>
            <div class="controlsRow">
                <span>Move:</span>
                <span class="controlKey">Left Stick / WASD</span>
            </div>
            <div class="controlsRow">
                <span>Look:</span>
                <span class="controlKey">Right Stick / Mouse</span>
            </div>
            <div class="controlsRow">
                <span>Jump:</span>
                <span class="controlKey">A / Space</span>
            </div>
            <div class="controlsRow">
                <span>Shoot:</span>
                <span class="controlKey">RT / Click</span>
            </div>
            <div class="controlsRow">
                <span>Build:</span>
                <span class="controlKey">LT</span>
            </div>
            <div class="controlsRow">
                <span>Switch Item:</span>
                <span class="controlKey">D-Pad / 1-5</span>
            </div>
            <div class="controlsRow">
                <span>Emotes:</span>
                <span class="controlKey">Y / B</span>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game State
        let scene, camera, renderer;
        let player, players = [];
        let world, obstacles = [];
        let bullets = [];
        let gameState = 'menu';
        let kills = 0;
        let health = 100;
        let shield = 100;
        let ammo = 30;
        let maxAmmo = 150;
        let playerCount = 100;
        let stormRadius = 500;
        let activeSlot = 0;
        let isBuilding = false;
        let buildPreview = null;

        // Controls
        let keys = {};
        let mouse = { x: 0, y: 0 };
        let isPointerLocked = false;
        let gamepad = null;
        let gamepadIndex = -1;
        let lastShootTime = 0;
        let shootCooldown = 200; // ms between shots

        // Initialize Three.js
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 100, 1000);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, 20);

            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas'), antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;
            directionalLight.shadow.camera.near = 0.1;
            directionalLight.shadow.camera.far = 200;
            scene.add(directionalLight);

            // Create world
            createWorld();
            
            // Create player
            createPlayer();

            // Create AI players
            createAIPlayers();

            // Event listeners
            document.addEventListener('keydown', (e) => keys[e.key.toLowerCase()] = true);
            document.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('click', onClick);
            window.addEventListener('resize', onWindowResize);

            // Gamepad support
            window.addEventListener('gamepadconnected', (e) => {
                console.log('Gamepad connected:', e.gamepad.id);
                gamepadIndex = e.gamepad.index;
                showGamepadNotification('Gamepad Connected!');
            });

            window.addEventListener('gamepaddisconnected', (e) => {
                console.log('Gamepad disconnected');
                gamepadIndex = -1;
                gamepad = null;
            });

            // Hide loading screen
            setTimeout(() => {
                document.getElementById('loadingScreen').style.display = 'none';
                document.getElementById('mainMenu').style.display = 'block';
            }, 2000);
        }

        function createWorld() {
            // Create floating islands
            const islandGeometry = new THREE.CylinderGeometry(50, 40, 10, 8);
            const islandMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
            
            for (let i = 0; i < 5; i++) {
                const island = new THREE.Mesh(islandGeometry, islandMaterial);
                island.position.set(
                    Math.random() * 400 - 200,
                    Math.random() * 50 - 25,
                    Math.random() * 400 - 200
                );
                island.castShadow = true;
                island.receiveShadow = true;
                scene.add(island);
                obstacles.push(island);
            }

            // Create main platform
            const platformGeometry = new THREE.BoxGeometry(200, 5, 200);
            const platformMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const platform = new THREE.Mesh(platformGeometry, platformMaterial);
            platform.position.y = -5;
            platform.castShadow = true;
            platform.receiveShadow = true;
            scene.add(platform);
            obstacles.push(platform);

            // Create buildings
            const buildingMaterial = new THREE.MeshLambertMaterial({ color: 0x696969 });
            for (let i = 0; i < 20; i++) {
                const height = Math.random() * 30 + 10;
                const buildingGeometry = new THREE.BoxGeometry(
                    Math.random() * 20 + 10,
                    height,
                    Math.random() * 20 + 10
                );
                const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
                building.position.set(
                    Math.random() * 180 - 90,
                    height / 2 - 2.5,
                    Math.random() * 180 - 90
                );
                building.castShadow = true;
                building.receiveShadow = true;
                scene.add(building);
                obstacles.push(building);
            }

            // Create storm wall
            const stormGeometry = new THREE.CylinderGeometry(stormRadius, stormRadius, 200, 32, 1, true);
            const stormMaterial = new THREE.MeshBasicMaterial({
                color: 0x8B008B,
                transparent: true,
                opacity: 0.3,
                side: THREE.BackSide
            });
            world = new THREE.Mesh(stormGeometry, stormMaterial);
            world.position.y = 50;
            scene.add(world);
        }

        function createPlayer() {
            // Create player using cylinder geometry (CapsuleGeometry not available in r128)
            const geometry = new THREE.CylinderGeometry(0.5, 0.5, 2, 8);
            const material = new THREE.MeshLambertMaterial({ color: 0x0000ff });
            player = new THREE.Mesh(geometry, material);
            player.position.set(0, 5, 0);
            player.castShadow = true;
            player.velocity = new THREE.Vector3(0, 0, 0);
            player.onGround = false;
            scene.add(player);

            // Add weapon
            const weaponGeometry = new THREE.BoxGeometry(0.3, 0.2, 1.5);
            const weaponMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
            player.weapon = new THREE.Mesh(weaponGeometry, weaponMaterial);
            player.weapon.position.set(0.7, 0.5, -0.5);
            player.add(player.weapon);
        }

        function createAIPlayers() {
            const colors = [0xff0000, 0x00ff00, 0xffff00, 0xff00ff, 0x00ffff];
            
            for (let i = 0; i < 20; i++) {
                const geometry = new THREE.CylinderGeometry(0.5, 0.5, 2, 8);
                const material = new THREE.MeshLambertMaterial({ 
                    color: colors[Math.floor(Math.random() * colors.length)] 
                });
                const aiPlayer = new THREE.Mesh(geometry, material);
                
                aiPlayer.position.set(
                    Math.random() * 200 - 100,
                    5,
                    Math.random() * 200 - 100
                );
                
                aiPlayer.velocity = new THREE.Vector3(0, 0, 0);
                aiPlayer.targetPosition = new THREE.Vector3(
                    Math.random() * 200 - 100,
                    5,
                    Math.random() * 200 - 100
                );
                aiPlayer.health = 100;
                aiPlayer.isAI = true;
                
                aiPlayer.castShadow = true;
                scene.add(aiPlayer);
                players.push(aiPlayer);
            }
        }

        function startGame(mode) {
            gameState = 'playing';
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('hud').style.display = 'block';
            document.getElementById('crosshair').style.display = 'block';
            document.getElementById('chatContainer').style.display = 'block';
            document.getElementById('controlsHelp').style.display = 'block';
            
            // Lock pointer if using mouse
            if (gamepadIndex === -1) {
                document.body.requestPointerLock();
                isPointerLocked = true;
            }
            
            animate();
        }

        function showGamepadNotification(message) {
            const notification = document.getElementById('gamepadNotification');
            notification.textContent = message;
            notification.style.display = 'block';
            setTimeout(() => {
                notification.style.display = 'none';
            }, 2000);
        }

        function updateGamepad() {
            if (gamepadIndex === -1) return;
            
            const gamepads = navigator.getGamepads();
            gamepad = gamepads[gamepadIndex];
            
            if (!gamepad) return;
            
            // Left stick - movement
            const leftX = gamepad.axes[0];
            const leftY = gamepad.axes[1];
            
            // Right stick - camera
            const rightX = gamepad.axes[2];
            const rightY = gamepad.axes[3];
            
            // Apply dead zone
            const deadZone = 0.1;
            
            if (Math.abs(leftX) > deadZone || Math.abs(leftY) > deadZone) {
                // Movement handled in updatePlayer
            }
            
            if (Math.abs(rightX) > deadZone) {
                player.rotation.y -= rightX * 0.05;
            }
            
            if (Math.abs(rightY) > deadZone) {
                camera.rotation.x -= rightY * 0.03;
                camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
            }
            
            // Buttons
            const buttonA = gamepad.buttons[0]; // Jump
            const buttonB = gamepad.buttons[1]; // Back/Cancel
            const buttonX = gamepad.buttons[2]; // Reload
            const buttonY = gamepad.buttons[3]; // Emotes
            const leftBumper = gamepad.buttons[4]; // Previous item
            const rightBumper = gamepad.buttons[5]; // Next item
            const leftTrigger = gamepad.buttons[6]; // Build
            const rightTrigger = gamepad.buttons[7]; // Shoot
            const dpadUp = gamepad.buttons[12];
            const dpadDown = gamepad.buttons[13];
            const dpadLeft = gamepad.buttons[14];
            const dpadRight = gamepad.buttons[15];
            
            // Handle button presses
            if (rightTrigger.pressed && activeSlot === 0 && ammo > 0) {
                const now = Date.now();
                if (now - lastShootTime > shootCooldown) {
                    shoot();
                    lastShootTime = now;
                }
            }
            
            if (leftTrigger.pressed && activeSlot === 3) {
                const now = Date.now();
                if (now - lastShootTime > shootCooldown) {
                    buildStructure();
                    lastShootTime = now;
                }
            }
            
            // D-pad for inventory
            if (dpadLeft.pressed) {
                activeSlot = 0; // Weapon
                updateInventoryUI();
            } else if (dpadUp.pressed) {
                activeSlot = 1; // Shield
                updateInventoryUI();
            } else if (dpadRight.pressed) {
                activeSlot = 2; // Health
                updateInventoryUI();
            } else if (dpadDown.pressed) {
                activeSlot = 3; // Build
                updateInventoryUI();
            }
            
            // Bumpers for cycling items
            if (leftBumper.pressed) {
                activeSlot = (activeSlot - 1 + 5) % 5;
                updateInventoryUI();
            } else if (rightBumper.pressed) {
                activeSlot = (activeSlot + 1) % 5;
                updateInventoryUI();
            }
            
            // Y for emotes
            if (buttonY.pressed) {
                const emoteMenu = document.getElementById('emoteMenu');
                emoteMenu.style.display = emoteMenu.style.display === 'grid' ? 'none' : 'grid';
            }
        }

        function onMouseMove(event) {
            if (!isPointerLocked) return;
            
            const movementX = event.movementX || 0;
            const movementY = event.movementY || 0;
            
            player.rotation.y -= movementX * 0.002;
            camera.rotation.x -= movementY * 0.002;
            camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
        }

        function onClick(event) {
            if (gameState !== 'playing') return;
            
            if (!isPointerLocked) {
                document.body.requestPointerLock();
                isPointerLocked = true;
                return;
            }
            
            if (activeSlot === 0 && ammo > 0) {
                shoot();
            } else if (activeSlot === 3) {
                buildStructure();
            }
        }

        function shoot() {
            if (ammo <= 0) return;
            
            ammo--;
            updateAmmoDisplay();
            
            const bullet = new THREE.Mesh(
                new THREE.SphereGeometry(0.1),
                new THREE.MeshBasicMaterial({ color: 0xffff00 })
            );
            
            bullet.position.copy(player.weapon.getWorldPosition(new THREE.Vector3()));
            
            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyQuaternion(player.quaternion);
            direction.applyQuaternion(camera.quaternion);
            
            bullet.velocity = direction.multiplyScalar(50);
            bullet.damage = 25;
            
            scene.add(bullet);
            bullets.push(bullet);
        }

        function buildStructure() {
            const wallGeometry = new THREE.BoxGeometry(4, 4, 0.5);
            const wallMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x8B4513,
                transparent: true,
                opacity: 0.8
            });
            const wall = new THREE.Mesh(wallGeometry, wallMaterial);
            
            const pos = player.position.clone();
            const dir = new THREE.Vector3(0, 0, -5);
            dir.applyQuaternion(player.quaternion);
            pos.add(dir);
            
            wall.position.copy(pos);
            wall.position.y = 2;
            wall.rotation.y = player.rotation.y;
            wall.castShadow = true;
            wall.receiveShadow = true;
            
            scene.add(wall);
            obstacles.push(wall);
        }

        function updatePlayer(deltaTime) {
            const speed = 10;
            const jumpPower = 15;
            
            // Movement
            const moveVector = new THREE.Vector3();
            
            // Keyboard controls
            if (keys['w']) moveVector.z -= 1;
            if (keys['s']) moveVector.z += 1;
            if (keys['a']) moveVector.x -= 1;
            if (keys['d']) moveVector.x += 1;
            
            // Gamepad controls
            if (gamepad) {
                const leftX = gamepad.axes[0];
                const leftY = gamepad.axes[1];
                const deadZone = 0.1;
                
                if (Math.abs(leftX) > deadZone) {
                    moveVector.x += leftX;
                }
                if (Math.abs(leftY) > deadZone) {
                    moveVector.z += leftY;
                }
                
                // Gamepad jump
                if (gamepad.buttons[0].pressed && player.onGround) {
                    player.velocity.y = jumpPower;
                    player.onGround = false;
                }
            }
            
            moveVector.normalize();
            moveVector.applyQuaternion(player.quaternion);
            moveVector.multiplyScalar(speed * deltaTime);
            
            player.position.add(moveVector);
            
            // Keyboard jumping
            if (keys[' '] && player.onGround) {
                player.velocity.y = jumpPower;
                player.onGround = false;
            }
            
            // Gravity
            player.velocity.y -= 30 * deltaTime;
            player.position.y += player.velocity.y * deltaTime;
            
            // Ground collision
            if (player.position.y <= 3) {
                player.position.y = 3;
                player.velocity.y = 0;
                player.onGround = true;
            }
            
            // Camera follow
            camera.position.copy(player.position);
            camera.position.y += 2;
            camera.position.add(new THREE.Vector3(0, 2, 5).applyQuaternion(player.quaternion));
            camera.lookAt(player.position);
            
            // Inventory switching (keyboard)
            for (let i = 1; i <= 5; i++) {
                if (keys[i.toString()]) {
                    activeSlot = i - 1;
                    updateInventoryUI();
                }
            }
            
            // Emote menu (keyboard)
            if (keys['b']) {
                document.getElementById('emoteMenu').style.display = 
                    document.getElementById('emoteMenu').style.display === 'grid' ? 'none' : 'grid';
            }
        }

        function updateAIPlayers(deltaTime) {
            players.forEach((aiPlayer, index) => {
                if (!aiPlayer.isAI || aiPlayer.health <= 0) return;
                
                // Simple AI movement
                const toTarget = aiPlayer.targetPosition.clone().sub(aiPlayer.position);
                
                if (toTarget.length() < 5) {
                    aiPlayer.targetPosition = new THREE.Vector3(
                        Math.random() * 200 - 100,
                        5,
                        Math.random() * 200 - 100
                    );
                }
                
                toTarget.normalize();
                toTarget.multiplyScalar(5 * deltaTime);
                aiPlayer.position.add(toTarget);
                
                // Gravity
                aiPlayer.velocity.y -= 30 * deltaTime;
                aiPlayer.position.y += aiPlayer.velocity.y * deltaTime;
                
                if (aiPlayer.position.y <= 3) {
                    aiPlayer.position.y = 3;
                    aiPlayer.velocity.y = 0;
                }
                
                // Storm damage
                const distanceFromCenter = aiPlayer.position.distanceTo(new THREE.Vector3(0, 0, 0));
                if (distanceFromCenter > stormRadius) {
                    aiPlayer.health -= 10 * deltaTime;
                    if (aiPlayer.health <= 0) {
                        scene.remove(aiPlayer);
                        players.splice(index, 1);
                        playerCount--;
                        updatePlayerCount();
                    }
                }
            });
        }

        function updateBullets(deltaTime) {
            bullets.forEach((bullet, bulletIndex) => {
                bullet.position.add(bullet.velocity.clone().multiplyScalar(deltaTime));
                
                // Check collision with AI players
                players.forEach((aiPlayer, playerIndex) => {
                    if (bullet.position.distanceTo(aiPlayer.position) < 2) {
                        aiPlayer.health -= bullet.damage;
                        
                        if (aiPlayer.health <= 0) {
                            scene.remove(aiPlayer);
                            players.splice(playerIndex, 1);
                            kills++;
                            playerCount--;
                            updateKillCount();
                            updatePlayerCount();
                        }
                        
                        scene.remove(bullet);
                        bullets.splice(bulletIndex, 1);
                    }
                });
                
                // Remove bullets that are too far
                if (bullet.position.distanceTo(player.position) > 200) {
                    scene.remove(bullet);
                    bullets.splice(bulletIndex, 1);
                }
            });
        }

        function updateStorm(deltaTime) {
            stormRadius -= 2 * deltaTime;
            world.scale.set(stormRadius / 500, 1, stormRadius / 500);
            
            // Check if player is in storm
            const distanceFromCenter = player.position.distanceTo(new THREE.Vector3(0, 0, 0));
            if (distanceFromCenter > stormRadius) {
                takeDamage(5 * deltaTime);
            }
        }

        function takeDamage(amount) {
            if (shield > 0) {
                shield -= amount;
                if (shield < 0) {
                    health += shield;
                    shield = 0;
                }
            } else {
                health -= amount;
            }
            
            updateHealthBar();
            
            if (health <= 0) {
                gameOver();
            }
        }

        function updateHealthBar() {
            document.getElementById('healthFill').style.width = health + '%';
            document.getElementById('shieldFill').style.width = shield + '%';
        }

        function updateAmmoDisplay() {
            document.getElementById('ammoDisplay').textContent = `${ammo} / ${maxAmmo}`;
        }

        function updateKillCount() {
            document.getElementById('killCount').textContent = `Eliminations: ${kills}`;
        }

        function updatePlayerCount() {
            document.getElementById('playerCount').textContent = `Players: ${playerCount}`;
            
            if (playerCount === 1) {
                victory();
            }
        }

        function updateInventoryUI() {
            const slots = document.querySelectorAll('.inventorySlot');
            slots.forEach((slot, index) => {
                slot.classList.toggle('active', index === activeSlot);
            });
        }

        function playEmote(emoteName) {
            document.getElementById('emoteMenu').style.display = 'none';
            // In a real game, this would trigger an animation
            console.log('Playing emote:', emoteName);
        }

        function victory() {
            gameState = 'victory';
            document.getElementById('hud').style.display = 'none';
            document.getElementById('crosshair').style.display = 'none';
            document.getElementById('victoryScreen').style.display = 'block';
            document.getElementById('finalKills').textContent = kills;
            
            document.exitPointerLock();
            isPointerLocked = false;
        }

        function gameOver() {
            gameState = 'gameover';
            alert(`Game Over! You got ${kills} eliminations.`);
            returnToMenu();
        }

        function returnToMenu() {
            location.reload();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Animation loop
        let lastTime = 0;
        function animate(currentTime = 0) {
            if (gameState !== 'playing') return;
            
            requestAnimationFrame(animate);
            
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;
            
            if (deltaTime > 0 && deltaTime < 0.1) {
                updateGamepad(); // Update gamepad input
                updatePlayer(deltaTime);
                updateAIPlayers(deltaTime);
                updateBullets(deltaTime);
                updateStorm(deltaTime);
            }
            
            renderer.render(scene, camera);
        }

        // Chat functionality
        document.getElementById('chatInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const message = e.target.value;
                if (message.trim()) {
                    addChatMessage('You', message);
                    e.target.value = '';
                }
            }
        });

        function addChatMessage(sender, message) {
            const chatMessages = document.getElementById('chatMessages');
            const messageElement = document.createElement('div');
            messageElement.innerHTML = `<strong>${sender}:</strong> ${message}`;
            chatMessages.appendChild(messageElement);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        // Pointer lock change detection
        document.addEventListener('pointerlockchange', () => {
            isPointerLocked = document.pointerLockElement === document.body;
        });

        // Initialize game
        init();
    </script>
</body>
</html>