<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Particle Physics Playground - Experience the Quantum Scale</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
            position: relative;
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            background: radial-gradient(ellipse at center, #0a0a2e 0%, #000 100%);
            cursor: none; /* Hide default cursor - we'll draw our own */
        }

        /* UI Panels */
        .ui-panel {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 10px;
            padding: 15px;
            backdrop-filter: blur(10px);
            animation: glow 2s ease-in-out infinite;
        }

        @keyframes glow {
            0%, 100% { box-shadow: 0 0 10px rgba(0, 255, 255, 0.3); }
            50% { box-shadow: 0 0 20px rgba(0, 255, 255, 0.5); }
        }

        #particleInfo {
            top: 20px;
            left: 20px;
            max-width: 250px;
        }

        #controls {
            bottom: 20px;
            left: 20px;
            max-width: 300px;
        }

        #collisionLog {
            top: 20px;
            right: 20px;
            max-width: 250px;
            max-height: 200px;
            overflow-y: auto;
        }

        #educationPanel {
            bottom: 20px;
            right: 20px;
            max-width: 300px;
            max-height: 250px;
            overflow-y: auto;
        }

        .particle-type {
            display: inline-block;
            padding: 5px 10px;
            margin: 5px;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .particle-type:hover {
            transform: scale(1.1);
        }

        .particle-type.selected {
            border: 2px solid #fff;
        }

        .proton { background: linear-gradient(45deg, #ff4444, #ff6666); }
        .neutron { background: linear-gradient(45deg, #4444ff, #6666ff); }
        .electron { background: linear-gradient(45deg, #44ff44, #66ff66); }
        .photon { background: linear-gradient(45deg, #ffff44, #ffff66); }
        .quark { background: linear-gradient(45deg, #ff44ff, #ff66ff); }

        h3 {
            color: #00ffff;
            margin-bottom: 10px;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        p {
            font-size: 12px;
            line-height: 1.4;
            margin: 5px 0;
            color: #ccc;
        }

        .stat {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 12px;
        }

        .stat-label {
            color: #888;
        }

        .stat-value {
            color: #00ff00;
            font-weight: bold;
        }

        button {
            background: linear-gradient(45deg, #0066cc, #0088ff);
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
            transition: all 0.3s;
            font-size: 12px;
        }

        button:hover {
            transform: scale(1.05);
            background: linear-gradient(45deg, #0088ff, #00aaff);
        }

        .data-controls {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            display: flex;
            gap: 10px;
        }

        input[type="file"] {
            display: none;
        }

        #speedControl {
            width: 100%;
            margin: 10px 0;
        }

        .collision-event {
            padding: 5px;
            margin: 5px 0;
            border-left: 3px solid #00ff00;
            font-size: 11px;
            animation: fadeIn 0.5s;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateX(20px); }
            to { opacity: 1; transform: translateX(0); }
        }

        .help-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            font-size: 18px;
            color: rgba(255, 255, 255, 0.5);
            pointer-events: none;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 0.8; }
        }

        #tunnelIndicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            color: #ff00ff;
            display: none;
            animation: tunnelPulse 1s;
        }

        @keyframes tunnelPulse {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.5); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(2); }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div class="help-text" id="helpText">
        Move Mouse to Navigate Cursor Particle ‚Ä¢ Click to Boost ‚Ä¢ Click Particle Types to Change Cursor
    </div>

    <div class="data-controls">
        <button onclick="exportData()">Export Experiment</button>
        <button onclick="document.getElementById('importFile').click()">Import Experiment</button>
        <input type="file" id="importFile" accept=".json" onchange="importData(event)">
    </div>

    <div class="ui-panel" id="particleInfo">
        <h3>Current Particle</h3>
        <div class="stat">
            <span class="stat-label">Type:</span>
            <span class="stat-value" id="particleType">Proton</span>
        </div>
        <div class="stat">
            <span class="stat-label">Mass:</span>
            <span class="stat-value" id="particleMass">1.673 √ó 10‚Åª¬≤‚Å∑ kg</span>
        </div>
        <div class="stat">
            <span class="stat-label">Charge:</span>
            <span class="stat-value" id="particleCharge">+1</span>
        </div>
        <div class="stat">
            <span class="stat-label">Speed:</span>
            <span class="stat-value" id="particleSpeed">0.00c</span>
        </div>
        <div class="stat">
            <span class="stat-label">Energy:</span>
            <span class="stat-value" id="particleEnergy">0 MeV</span>
        </div>
    </div>

    <div class="ui-panel" id="controls">
        <h3>Select Particle</h3>
        <div>
            <span class="particle-type proton selected" onclick="selectParticle('proton')">Proton</span>
            <span class="particle-type neutron" onclick="selectParticle('neutron')">Neutron</span>
            <span class="particle-type electron" onclick="selectParticle('electron')">Electron</span>
            <span class="particle-type photon" onclick="selectParticle('photon')">Photon</span>
            <span class="particle-type quark" onclick="selectParticle('quark')">Quark</span>
        </div>
        <h3 style="margin-top: 15px;">Speed Control</h3>
        <input type="range" id="speedControl" min="0" max="100" value="10">
        <div style="margin-top: 10px;">
            <button onclick="toggleTunnel()">Quantum Tunnel</button>
            <button onclick="createAtom()">Form Atom</button>
            <button onclick="resetSimulation()">Reset</button>
        </div>
    </div>

    <div class="ui-panel" id="collisionLog">
        <h3>Collision Events</h3>
        <div id="collisionEvents"></div>
    </div>

    <div class="ui-panel" id="educationPanel">
        <h3>Physics Concepts</h3>
        <div id="educationContent">
            <p><strong>Particle Accelerator:</strong> You're inside a circular accelerator where magnetic fields bend charged particles in circular paths. Real accelerators like the LHC can accelerate particles to 99.9999% the speed of light!</p>

            <p><strong>Quantum Tunneling:</strong> In quantum mechanics, particles can pass through energy barriers that classical physics says are impossible to cross. This is how the sun fuses hydrogen!</p>

            <p><strong>Particle Collisions:</strong> When particles collide at high energies, they can create new particles from pure energy (E=mc¬≤). This is how we discover new particles!</p>
        </div>
    </div>

    <div id="tunnelIndicator">QUANTUM TUNNEL!</div>

    <script>
        const APP_NAME = 'particle-physics-playground';
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Resize canvas
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Physics constants
        const c = 299792458; // Speed of light m/s
        const planckLength = 1.616e-35; // Planck length in meters

        // Particle definitions
        const particleTypes = {
            proton: {
                mass: 1.673e-27,
                charge: 1,
                color: '#ff4444',
                radius: 8,
                description: 'Made of 2 up quarks and 1 down quark'
            },
            neutron: {
                mass: 1.675e-27,
                charge: 0,
                color: '#4444ff',
                radius: 8,
                description: 'Made of 1 up quark and 2 down quarks'
            },
            electron: {
                mass: 9.109e-31,
                charge: -1,
                color: '#44ff44',
                radius: 4,
                description: 'Elementary particle, lepton family'
            },
            photon: {
                mass: 0,
                charge: 0,
                color: '#ffff44',
                radius: 3,
                description: 'Massless particle of light'
            },
            quark: {
                mass: 2.3e-30,
                charge: 2/3,
                color: '#ff44ff',
                radius: 5,
                description: 'Elementary particle, builds protons & neutrons'
            }
        };

        // Mouse tracking
        let mouse = {
            x: 0,
            y: 0,
            screenX: 0,
            screenY: 0,
            down: false,
            particle: {
                type: 'proton',
                x: 0,
                y: 0,
                z: 0,
                vx: 0,
                vy: 0,
                vz: 0,
                trail: [],
                mass: 10
            }
        };

        // Game state
        let gameState = {
            player: {
                type: 'proton',
                x: 0,
                y: 0,
                z: 0,
                vx: 0,
                vy: 0,
                vz: 0,
                energy: 0,
                trail: []
            },
            particles: [],
            atoms: [],
            collisions: [],
            collisionFlashes: [], // Visual effects for collisions
            tunneling: false,
            acceleratorAngle: 0,
            cameraAngle: 0,
            zoom: 1,
            experiments: []
        };

        // Initialize particles
        function initParticles() {
            gameState.particles = [];
            // Add random particles in accelerator
            for (let i = 0; i < 20; i++) {
                const types = Object.keys(particleTypes);
                const type = types[Math.floor(Math.random() * types.length)];
                const angle = Math.random() * Math.PI * 2;
                const radius = 150 + Math.random() * 100;

                gameState.particles.push({
                    type: type,
                    x: Math.cos(angle) * radius,
                    y: Math.sin(angle) * radius,
                    z: (Math.random() - 0.5) * 50,
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2,
                    vz: (Math.random() - 0.5) * 0.5,
                    trail: []
                });
            }

            // Hide help text after first interaction
            setTimeout(() => {
                document.getElementById('helpText').style.display = 'none';
            }, 5000);
        }

        // 3D to 2D projection
        function project3D(x, y, z) {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const scale = 200 / (200 + z) * gameState.zoom;

            return {
                x: centerX + x * scale,
                y: centerY + y * scale,
                scale: scale
            };
        }

        // Draw accelerator tube
        function drawAccelerator() {
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.2)';
            ctx.lineWidth = 2;

            // Draw circular accelerator rings
            for (let r = 100; r <= 250; r += 50) {
                ctx.beginPath();
                for (let angle = 0; angle <= Math.PI * 2; angle += 0.1) {
                    const x = Math.cos(angle) * r;
                    const y = Math.sin(angle) * r;
                    const p = project3D(x, y, 0);

                    if (angle === 0) {
                        ctx.moveTo(p.x, p.y);
                    } else {
                        ctx.lineTo(p.x, p.y);
                    }
                }
                ctx.closePath();
                ctx.stroke();
            }

            // Draw magnetic field lines
            ctx.strokeStyle = 'rgba(255, 0, 255, 0.1)';
            ctx.lineWidth = 1;
            const time = Date.now() / 1000;

            for (let i = 0; i < 8; i++) {
                const angle = (Math.PI * 2 / 8) * i + time * 0.5;
                ctx.beginPath();

                const startX = Math.cos(angle) * 100;
                const startY = Math.sin(angle) * 100;
                const endX = Math.cos(angle) * 250;
                const endY = Math.sin(angle) * 250;

                const p1 = project3D(startX, startY, -30);
                const p2 = project3D(endX, endY, 30);

                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();
            }
        }

        // Draw particle with trail
        function drawParticle(particle, isPlayer = false) {
            const type = particleTypes[particle.type];
            const p = project3D(particle.x, particle.y, particle.z);

            // Draw trail
            if (particle.trail.length > 1) {
                ctx.strokeStyle = type.color + '40';
                ctx.lineWidth = 2;
                ctx.beginPath();

                for (let i = 0; i < particle.trail.length; i++) {
                    const t = particle.trail[i];
                    const tp = project3D(t.x, t.y, t.z);

                    if (i === 0) {
                        ctx.moveTo(tp.x, tp.y);
                    } else {
                        ctx.lineTo(tp.x, tp.y);
                    }
                }
                ctx.stroke();
            }

            // Draw particle
            const radius = type.radius * p.scale / 200;

            // Glow effect
            const gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, radius * 3);
            gradient.addColorStop(0, type.color);
            gradient.addColorStop(0.5, type.color + '80');
            gradient.addColorStop(1, type.color + '00');

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(p.x, p.y, radius * 3, 0, Math.PI * 2);
            ctx.fill();

            // Core
            ctx.fillStyle = type.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
            ctx.fill();

            // Player indicator
            if (isPlayer) {
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(p.x, p.y, radius + 5, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Draw quantum probability cloud for electrons
            if (particle.type === 'electron') {
                ctx.fillStyle = 'rgba(68, 255, 68, 0.05)';
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, radius * (4 + i * 2), 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        // Draw mouse cursor particle
        function drawCursorParticle() {
            const particle = mouse.particle;
            const type = particleTypes[particle.type];
            const p = project3D(particle.x, particle.y, particle.z);

            // Draw trail
            if (particle.trail.length > 1) {
                ctx.strokeStyle = type.color + '60';
                ctx.lineWidth = 3;
                ctx.beginPath();

                for (let i = 0; i < particle.trail.length; i++) {
                    const t = particle.trail[i];
                    const tp = project3D(t.x, t.y, t.z);

                    if (i === 0) {
                        ctx.moveTo(tp.x, tp.y);
                    } else {
                        ctx.lineTo(tp.x, tp.y);
                    }
                }
                ctx.stroke();
            }

            // Draw large cursor indicator ring (pulsing)
            const pulseSize = 2 + Math.sin(Date.now() / 200) * 0.5;
            ctx.strokeStyle = type.color;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(p.x, p.y, 30 * pulseSize, 0, Math.PI * 2);
            ctx.stroke();

            // Draw inner ring
            ctx.strokeStyle = type.color + '80';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(p.x, p.y, 20, 0, Math.PI * 2);
            ctx.stroke();

            // Particle radius
            const radius = type.radius * 2; // Make cursor particle bigger

            // Massive glow effect
            const gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, radius * 5);
            gradient.addColorStop(0, type.color + 'ff');
            gradient.addColorStop(0.3, type.color + 'cc');
            gradient.addColorStop(0.6, type.color + '60');
            gradient.addColorStop(1, type.color + '00');

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(p.x, p.y, radius * 5, 0, Math.PI * 2);
            ctx.fill();

            // Core particle
            ctx.fillStyle = type.color;
            ctx.shadowBlur = 20;
            ctx.shadowColor = type.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            // Crosshair
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(p.x - 40, p.y);
            ctx.lineTo(p.x - 25, p.y);
            ctx.moveTo(p.x + 40, p.y);
            ctx.lineTo(p.x + 25, p.y);
            ctx.moveTo(p.x, p.y - 40);
            ctx.lineTo(p.x, p.y - 25);
            ctx.moveTo(p.x, p.y + 40);
            ctx.lineTo(p.x, p.y + 25);
            ctx.stroke();

            // Label
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 12px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('CURSOR', p.x, p.y - 50);
            ctx.font = '10px monospace';
            ctx.fillText(particle.type.toUpperCase(), p.x, p.y - 36);

            // Velocity indicator
            if (Math.abs(particle.vx) > 0.1 || Math.abs(particle.vy) > 0.1) {
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(p.x, p.y);
                const velScale = 20;
                ctx.lineTo(p.x + particle.vx * velScale, p.y + particle.vy * velScale);
                ctx.stroke();

                // Arrowhead
                const angle = Math.atan2(particle.vy, particle.vx);
                const headLen = 8;
                ctx.beginPath();
                ctx.moveTo(p.x + particle.vx * velScale, p.y + particle.vy * velScale);
                ctx.lineTo(
                    p.x + particle.vx * velScale - headLen * Math.cos(angle - Math.PI / 6),
                    p.y + particle.vy * velScale - headLen * Math.sin(angle - Math.PI / 6)
                );
                ctx.moveTo(p.x + particle.vx * velScale, p.y + particle.vy * velScale);
                ctx.lineTo(
                    p.x + particle.vx * velScale - headLen * Math.cos(angle + Math.PI / 6),
                    p.y + particle.vy * velScale - headLen * Math.sin(angle + Math.PI / 6)
                );
                ctx.stroke();
            }
        }

        // Draw collision flash effects
        function drawCollisionFlashes() {
            const now = Date.now();
            gameState.collisionFlashes = gameState.collisionFlashes.filter(flash => {
                const age = now - flash.time;
                if (age > flash.duration) return false;

                const progress = age / flash.duration;
                const opacity = 1 - progress;
                const size = 20 + progress * 40;

                const p = project3D(flash.x, flash.y, flash.z);

                // Draw expanding ring
                ctx.strokeStyle = flash.color + Math.floor(opacity * 255).toString(16).padStart(2, '0');
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(p.x, p.y, size, 0, Math.PI * 2);
                ctx.stroke();

                // Draw glow
                const gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, size);
                gradient.addColorStop(0, flash.color + Math.floor(opacity * 128).toString(16).padStart(2, '0'));
                gradient.addColorStop(1, flash.color + '00');

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(p.x, p.y, size, 0, Math.PI * 2);
                ctx.fill();

                return true;
            });
        }

        // Draw atom formation
        function drawAtom(atom) {
            const p = project3D(atom.x, atom.y, atom.z);

            // Draw nucleus
            ctx.fillStyle = '#ff8800';
            ctx.beginPath();
            ctx.arc(p.x, p.y, 10 * p.scale / 200, 0, Math.PI * 2);
            ctx.fill();

            // Draw electron orbitals
            ctx.strokeStyle = 'rgba(68, 255, 68, 0.3)';
            ctx.lineWidth = 1;

            for (let i = 0; i < atom.electrons; i++) {
                const radius = (20 + i * 15) * p.scale / 200;
                const angle = Date.now() / 1000 * (i + 1) * 0.5;

                ctx.beginPath();
                ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
                ctx.stroke();

                // Draw electron
                const ex = p.x + Math.cos(angle) * radius;
                const ey = p.y + Math.sin(angle) * radius;

                ctx.fillStyle = '#44ff44';
                ctx.beginPath();
                ctx.arc(ex, ey, 3, 0, Math.PI * 2);
                ctx.fill();
            }

            // Label
            ctx.fillStyle = '#ffffff';
            ctx.font = '12px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(atom.name, p.x, p.y - 30);
        }

        // Update physics
        function updatePhysics(dt) {
            // Update player
            const player = gameState.player;
            const speed = Math.sqrt(player.vx ** 2 + player.vy ** 2 + player.vz ** 2);

            // Add to trail
            player.trail.push({ x: player.x, y: player.y, z: player.z });
            if (player.trail.length > 30) player.trail.shift();

            // Apply accelerator magnetic field (bend particles in circle)
            if (Math.abs(player.x) > 50 || Math.abs(player.y) > 50) {
                const angle = Math.atan2(player.y, player.x);
                const centripetal = speed * speed / Math.sqrt(player.x ** 2 + player.y ** 2);
                player.vx -= Math.cos(angle) * centripetal * dt * 0.1;
                player.vy -= Math.sin(angle) * centripetal * dt * 0.1;
            }

            player.x += player.vx * dt;
            player.y += player.vy * dt;
            player.z += player.vz * dt;

            // Keep in bounds
            const maxRadius = 300;
            const dist = Math.sqrt(player.x ** 2 + player.y ** 2);
            if (dist > maxRadius) {
                player.x = (player.x / dist) * maxRadius;
                player.y = (player.y / dist) * maxRadius;
            }

            // Update other particles
            gameState.particles.forEach(particle => {
                particle.trail.push({ x: particle.x, y: particle.y, z: particle.z });
                if (particle.trail.length > 20) particle.trail.shift();

                // Random quantum fluctuations
                particle.vx += (Math.random() - 0.5) * 0.1;
                particle.vy += (Math.random() - 0.5) * 0.1;

                particle.x += particle.vx * dt;
                particle.y += particle.vy * dt;
                particle.z += particle.vz * dt;

                // Accelerator bounds
                const dist = Math.sqrt(particle.x ** 2 + particle.y ** 2);
                if (dist > 250) {
                    const angle = Math.atan2(particle.y, particle.x);
                    particle.vx = -Math.abs(particle.vx) * Math.cos(angle);
                    particle.vy = -Math.abs(particle.vy) * Math.sin(angle);
                }
            });

            // Update mouse particle physics
            mouse.particle.trail.push({
                x: mouse.particle.x,
                y: mouse.particle.y,
                z: mouse.particle.z
            });
            if (mouse.particle.trail.length > 15) mouse.particle.trail.shift();

            // Apply velocity to mouse particle
            mouse.particle.x += mouse.particle.vx * dt;
            mouse.particle.y += mouse.particle.vy * dt;
            mouse.particle.z += mouse.particle.vz * dt;

            // Damping
            mouse.particle.vx *= 0.98;
            mouse.particle.vy *= 0.98;
            mouse.particle.vz *= 0.98;

            // Check collisions with keyboard-controlled player
            gameState.particles.forEach((particle, i) => {
                const dx = player.x - particle.x;
                const dy = player.y - particle.y;
                const dz = player.z - particle.z;
                const dist = Math.sqrt(dx ** 2 + dy ** 2 + dz ** 2);

                if (dist < 20) {
                    handleCollision(player, particle, i);
                }
            });

            // Check collisions with mouse cursor particle
            gameState.particles.forEach((particle, i) => {
                const dx = mouse.particle.x - particle.x;
                const dy = mouse.particle.y - particle.y;
                const dz = mouse.particle.z - particle.z;
                const dist = Math.sqrt(dx ** 2 + dy ** 2 + dz ** 2);

                if (dist < 25) {
                    handleMouseCollision(mouse.particle, particle, i);
                }
            });

            // Update UI
            updateUI();
        }

        // Handle particle collision
        function handleCollision(p1, p2, index) {
            const energy = Math.sqrt(p1.vx ** 2 + p1.vy ** 2) + Math.sqrt(p2.vx ** 2 + p2.vy ** 2);

            // Create collision event
            const event = {
                time: Date.now(),
                particles: [p1.type, p2.type],
                energy: energy.toFixed(2),
                result: ''
            };

            // Determine collision result
            if (p1.type === 'proton' && p2.type === 'electron') {
                event.result = 'Hydrogen atom formed!';
                gameState.atoms.push({
                    name: 'H',
                    x: (p1.x + p2.x) / 2,
                    y: (p1.y + p2.y) / 2,
                    z: (p1.z + p2.z) / 2,
                    electrons: 1
                });
            } else if (energy > 5) {
                event.result = 'New particle created!';
                const types = Object.keys(particleTypes);
                p2.type = types[Math.floor(Math.random() * types.length)];
            } else {
                event.result = 'Elastic scattering';
            }

            // Add to collision log
            gameState.collisions.unshift(event);
            if (gameState.collisions.length > 5) gameState.collisions.pop();

            // Update collision display
            updateCollisionLog();

            // Scatter particles
            const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);
            p2.vx = Math.cos(angle) * energy;
            p2.vy = Math.sin(angle) * energy;

            p1.vx *= -0.5;
            p1.vy *= -0.5;
        }

        // Handle mouse cursor collision
        function handleMouseCollision(mouseP, particle, index) {
            const energy = Math.sqrt(mouseP.vx ** 2 + mouseP.vy ** 2) +
                          Math.sqrt(particle.vx ** 2 + particle.vy ** 2);

            // Create collision event
            const event = {
                time: Date.now(),
                particles: ['CURSOR-' + mouseP.type, particle.type],
                energy: energy.toFixed(2),
                result: ''
            };

            // Determine collision result based on cursor particle type
            if (mouseP.type === 'proton' && particle.type === 'electron') {
                event.result = '‚öõÔ∏è Hydrogen atom formed!';
                gameState.atoms.push({
                    name: 'H',
                    x: (mouseP.x + particle.x) / 2,
                    y: (mouseP.y + particle.y) / 2,
                    z: (mouseP.z + particle.z) / 2,
                    electrons: 1
                });
            } else if (mouseP.type === 'electron' && particle.type === 'proton') {
                event.result = '‚öõÔ∏è Atom formation!';
                gameState.atoms.push({
                    name: 'H',
                    x: (mouseP.x + particle.x) / 2,
                    y: (mouseP.y + particle.y) / 2,
                    z: (mouseP.z + particle.z) / 2,
                    electrons: 1
                });
            } else if (energy > 8) {
                event.result = 'üí• High-energy collision! New particle!';
                const types = Object.keys(particleTypes);
                particle.type = types[Math.floor(Math.random() * types.length)];
            } else if (energy > 4) {
                event.result = '‚ö° Particle transformation!';
                const types = Object.keys(particleTypes);
                particle.type = types[Math.floor(Math.random() * types.length)];
            } else {
                event.result = '‚ÜîÔ∏è Elastic scattering';
            }

            // Add to collision log
            gameState.collisions.unshift(event);
            if (gameState.collisions.length > 5) gameState.collisions.pop();

            // Update collision display
            updateCollisionLog();

            // Scatter particles with momentum transfer
            const angle = Math.atan2(particle.y - mouseP.y, particle.x - mouseP.x);
            const impactForce = energy * 0.5;

            particle.vx = Math.cos(angle) * impactForce;
            particle.vy = Math.sin(angle) * impactForce;

            // Cursor particle recoils
            mouseP.vx = -Math.cos(angle) * impactForce * 0.3;
            mouseP.vy = -Math.sin(angle) * impactForce * 0.3;

            // Create visual collision flash
            gameState.collisionFlashes.push({
                x: (mouseP.x + particle.x) / 2,
                y: (mouseP.y + particle.y) / 2,
                z: (mouseP.z + particle.z) / 2,
                time: Date.now(),
                duration: 500,
                color: particleTypes[mouseP.type].color
            });
        }

        // Update UI elements
        function updateUI() {
            // Use mouse cursor particle for display
            const particle = mouse.particle;
            const type = particleTypes[particle.type];
            const speed = Math.sqrt(particle.vx ** 2 + particle.vy ** 2 + particle.vz ** 2);
            const speedOfLightRatio = (speed / 10).toFixed(2);
            const energy = (0.5 * type.mass * speed ** 2 * 6.242e12).toFixed(2); // Convert to MeV

            document.getElementById('particleType').textContent = 'CURSOR-' + particle.type.charAt(0).toUpperCase() + particle.type.slice(1);
            document.getElementById('particleMass').textContent = type.mass.toExponential(2) + ' kg';
            document.getElementById('particleCharge').textContent = type.charge > 0 ? `+${type.charge}` : type.charge;
            document.getElementById('particleSpeed').textContent = speedOfLightRatio + 'c';
            document.getElementById('particleEnergy').textContent = energy + ' MeV';
        }

        // Update collision log
        function updateCollisionLog() {
            const container = document.getElementById('collisionEvents');
            container.innerHTML = '';

            gameState.collisions.forEach(event => {
                const div = document.createElement('div');
                div.className = 'collision-event';
                div.innerHTML = `
                    <strong>${event.particles[0]} + ${event.particles[1]}</strong><br>
                    Energy: ${event.energy} GeV<br>
                    <span style="color: #00ff00">${event.result}</span>
                `;
                container.appendChild(div);
            });
        }

        // Input handling
        const keys = {};
        window.addEventListener('keydown', e => {
            keys[e.key.toLowerCase()] = true;
            document.getElementById('helpText').style.display = 'none';
        });
        window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

        // Mouse tracking
        canvas.addEventListener('mousemove', e => {
            const rect = canvas.getBoundingClientRect();
            mouse.screenX = e.clientX - rect.left;
            mouse.screenY = e.clientY - rect.top;

            // Convert screen coordinates to 3D world coordinates
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            mouse.particle.x = (mouse.screenX - centerX) / gameState.zoom;
            mouse.particle.y = (mouse.screenY - centerY) / gameState.zoom;

            document.getElementById('helpText').style.display = 'none';
        });

        canvas.addEventListener('mousedown', e => {
            mouse.down = true;
            // Boost cursor particle on click in a radial burst
            const angle = Math.random() * Math.PI * 2;
            const boost = 8;
            mouse.particle.vx += Math.cos(angle) * boost;
            mouse.particle.vy += Math.sin(angle) * boost;

            // Visual feedback
            document.getElementById('helpText').style.display = 'none';

            // Add a quick flash at cursor
            gameState.collisionFlashes.push({
                x: mouse.particle.x,
                y: mouse.particle.y,
                z: mouse.particle.z,
                time: Date.now(),
                duration: 300,
                color: particleTypes[mouse.particle.type].color
            });
        });

        canvas.addEventListener('mouseup', e => {
            mouse.down = false;
        });

        canvas.addEventListener('mouseleave', e => {
            mouse.down = false;
        });

        document.getElementById('speedControl').addEventListener('input', e => {
            const speedMultiplier = e.target.value / 10;
            // Will be applied in processInput
        });

        function processInput() {
            const player = gameState.player;
            const speedMultiplier = document.getElementById('speedControl').value / 10;
            const acceleration = 2 * speedMultiplier;

            if (keys['arrowleft'] || keys['a']) player.vx -= acceleration;
            if (keys['arrowright'] || keys['d']) player.vx += acceleration;
            if (keys['arrowup'] || keys['w']) player.vy -= acceleration;
            if (keys['arrowdown'] || keys['s']) player.vy += acceleration;
            if (keys[' ']) {
                player.vx *= 1.1;
                player.vy *= 1.1;
            }

            // Limit max speed
            const maxSpeed = 30 * speedMultiplier;
            const speed = Math.sqrt(player.vx ** 2 + player.vy ** 2);
            if (speed > maxSpeed) {
                player.vx = (player.vx / speed) * maxSpeed;
                player.vy = (player.vy / speed) * maxSpeed;
            }
        }

        // Particle selection
        function selectParticle(type) {
            gameState.player.type = type;
            mouse.particle.type = type; // Also change cursor particle type

            // Update UI selection
            document.querySelectorAll('.particle-type').forEach(el => {
                el.classList.remove('selected');
            });
            event.target.classList.add('selected');

            // Update education panel
            const particle = particleTypes[type];
            document.getElementById('educationContent').innerHTML = `
                <p><strong>Cursor: ${type.charAt(0).toUpperCase() + type.slice(1)}</strong> ${particle.description}</p>
                <p>Mass: ${particle.mass.toExponential(2)} kg</p>
                <p>Charge: ${particle.charge}</p>
                <p><em>Move your mouse to control this particle!</em></p>
                ${getParticleEducation(type)}
            `;
        }

        function getParticleEducation(type) {
            const education = {
                proton: '<p>Protons define the element. The number of protons determines whether an atom is hydrogen, helium, carbon, etc.</p>',
                neutron: '<p>Neutrons provide nuclear stability and create isotopes. They have no charge but similar mass to protons.</p>',
                electron: '<p>Electrons orbit the nucleus in probability clouds. Their arrangement determines chemical properties.</p>',
                photon: '<p>Photons are the force carriers of electromagnetism. They have no mass and always travel at the speed of light.</p>',
                quark: '<p>Quarks are the building blocks of protons and neutrons. They come in 6 flavors: up, down, charm, strange, top, and bottom.</p>'
            };
            return education[type] || '';
        }

        // Quantum tunneling effect
        function toggleTunnel() {
            gameState.tunneling = !gameState.tunneling;

            if (gameState.tunneling) {
                // Teleport to random location
                gameState.player.x = (Math.random() - 0.5) * 400;
                gameState.player.y = (Math.random() - 0.5) * 400;

                document.getElementById('tunnelIndicator').style.display = 'block';
                setTimeout(() => {
                    document.getElementById('tunnelIndicator').style.display = 'none';
                }, 1000);

                // Add to education
                document.getElementById('educationContent').innerHTML = `
                    <p><strong>Quantum Tunneling Activated!</strong></p>
                    <p>You just demonstrated quantum tunneling - passing through an energy barrier instantaneously!</p>
                    <p>This phenomenon allows particles to appear in locations that would be impossible according to classical physics.</p>
                    <p>Applications include: scanning tunneling microscopes, nuclear fusion in stars, and quantum computers.</p>
                `;
            }
        }

        // Create atom
        function createAtom() {
            const player = gameState.player;

            // Check if we have the right particles nearby
            let protons = 0;
            let neutrons = 0;
            let electrons = 0;

            gameState.particles.forEach(p => {
                const dist = Math.sqrt((p.x - player.x) ** 2 + (p.y - player.y) ** 2);
                if (dist < 50) {
                    if (p.type === 'proton') protons++;
                    if (p.type === 'neutron') neutrons++;
                    if (p.type === 'electron') electrons++;
                }
            });

            let atomName = '';
            if (protons === 1 && electrons >= 1) atomName = 'H';
            else if (protons === 2 && electrons >= 2) atomName = 'He';
            else if (protons === 6 && electrons >= 6) atomName = 'C';
            else if (protons === 8 && electrons >= 8) atomName = 'O';

            if (atomName) {
                gameState.atoms.push({
                    name: atomName,
                    x: player.x,
                    y: player.y,
                    z: player.z,
                    electrons: electrons
                });

                document.getElementById('educationContent').innerHTML = `
                    <p><strong>Atom Created: ${atomName}</strong></p>
                    <p>You've successfully formed an atom with ${protons} protons and ${electrons} electrons!</p>
                    <p>This demonstrates nuclear binding - the strong force holding the nucleus together.</p>
                `;
            }
        }

        // Reset simulation
        function resetSimulation() {
            gameState.player = {
                type: 'proton',
                x: 0,
                y: 0,
                z: 0,
                vx: 0,
                vy: 0,
                vz: 0,
                energy: 0,
                trail: []
            };
            gameState.atoms = [];
            gameState.collisions = [];
            initParticles();
        }

        // Data persistence
        function saveData() {
            localStorage.setItem(APP_NAME, JSON.stringify(gameState));
        }

        function loadData() {
            const saved = localStorage.getItem(APP_NAME);
            if (saved) {
                try {
                    gameState = JSON.parse(saved);
                } catch (e) {
                    console.error('Failed to load saved data');
                }
            }
        }

        function exportData() {
            const experiment = {
                timestamp: new Date().toISOString(),
                player: gameState.player,
                particles: gameState.particles.length,
                atoms: gameState.atoms,
                collisions: gameState.collisions,
                settings: {
                    particleType: gameState.player.type,
                    speed: document.getElementById('speedControl').value
                }
            };

            const dataStr = JSON.stringify(experiment, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `particle-physics-experiment-${Date.now()}.json`;
            link.click();
            URL.revokeObjectURL(url);
        }

        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const experiment = JSON.parse(e.target.result);

                    // Restore experiment state
                    if (experiment.player) gameState.player = experiment.player;
                    if (experiment.atoms) gameState.atoms = experiment.atoms;
                    if (experiment.collisions) gameState.collisions = experiment.collisions;
                    if (experiment.settings) {
                        document.getElementById('speedControl').value = experiment.settings.speed;
                        selectParticle(experiment.settings.particleType);
                    }

                    updateCollisionLog();
                    alert('Experiment loaded successfully!');
                } catch (error) {
                    alert('Invalid experiment file');
                }
            };
            reader.readAsText(file);
        }

        // Animation loop
        let lastTime = 0;
        function animate(time) {
            const dt = Math.min((time - lastTime) / 1000, 0.1); // Cap dt to prevent large jumps
            lastTime = time;

            // Clear canvas
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Process input
            processInput();

            // Update physics
            updatePhysics(dt);

            // Rotate camera slightly
            gameState.cameraAngle += dt * 0.1;

            // Draw scene
            drawAccelerator();

            // Draw atoms
            gameState.atoms.forEach(atom => drawAtom(atom));

            // Draw particles
            gameState.particles.forEach(particle => drawParticle(particle));

            // Draw player
            drawParticle(gameState.player, true);

            // Draw cursor particle (mouse-controlled)
            drawCursorParticle();

            // Draw collision flash effects
            drawCollisionFlashes();

            // Draw energy field effect
            if (gameState.tunneling) {
                ctx.fillStyle = 'rgba(255, 0, 255, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            // Save periodically
            if (Math.floor(time / 5000) !== Math.floor(lastTime / 5000)) {
                saveData();
            }

            requestAnimationFrame(animate);
        }

        // Initialize
        loadData();
        initParticles();
        updateCollisionLog();
        requestAnimationFrame(animate);

        // Welcome message
        console.log('Welcome to Particle Physics Playground!');
        console.log('Experience physics at the quantum scale');
        console.log('Use arrow keys to move, space to boost');
    </script>
</body>
</html>