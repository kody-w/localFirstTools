<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>APEX PROTOCOL - Arena Combat</title>
    <meta name="description" content="AAA first-person arena combat game with full Xbox controller AND mouse/keyboard support">
    <!-- xbox, controller, fps, 3d, webgl, game, arena, shooter, keyboard, mouse -->
    <style>
        .bullet-time canvas {
            filter: sepia(0.5) hue-rotate(180deg) contrast(1.2);
            transition: filter 0.2s ease;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
            font-family: 'Segoe UI', -apple-system, sans-serif;
            color: #fff;
            user-select: none;
            -webkit-user-select: none;
        }

        /* Dynamic cursor based on game state */
        body.playing { cursor: none; }
        body.menu { cursor: default; }

        #game-container {
            width: 100%;
            height: 100%;
            position: relative;
        }

        #game-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* 10-foot UI - Large, readable from couch */
        .hud {
            position: absolute;
            pointer-events: none;
            font-weight: 600;
            text-shadow: 0 2px 8px rgba(0,0,0,0.8), 0 0 20px rgba(0,0,0,0.5);
        }

        /* Health Bar - Bottom Left */
        #health-container {
            bottom: 60px;
            left: 60px;
            display: flex;
            align-items: center;
            gap: 20px;
        }

        #health-icon {
            width: 64px;
            height: 64px;
            background: linear-gradient(135deg, #ff4444, #cc0000);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 36px;
            box-shadow: 0 0 30px rgba(255,68,68,0.5);
        }

        #health-bar-outer {
            width: 350px;
            height: 32px;
            background: rgba(0,0,0,0.7);
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 16px;
            overflow: hidden;
        }

        #health-bar-inner {
            height: 100%;
            background: linear-gradient(90deg, #ff4444, #ff6666);
            border-radius: 14px;
            transition: width 0.2s ease-out;
            box-shadow: 0 0 20px rgba(255,68,68,0.6) inset;
        }

        #health-text {
            font-size: 28px;
            min-width: 100px;
        }

        /* Ammo - Bottom Right */
        #ammo-container {
            bottom: 60px;
            right: 60px;
            text-align: right;
            display: flex;
            align-items: center;
            gap: 20px;
        }

        #ammo-count {
            font-size: 72px;
            font-weight: 700;
            letter-spacing: -2px;
            background: linear-gradient(180deg, #fff, #aaa);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        #ammo-max {
            font-size: 32px;
            color: rgba(255,255,255,0.5);
        }

        #weapon-name {
            font-size: 24px;
            color: #00ffff;
            text-transform: uppercase;
            letter-spacing: 4px;
        }

        /* Score/Wave - Top */
        #top-hud {
            top: 40px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
        }

        #wave-display {
            font-size: 24px;
            color: #ffaa00;
            letter-spacing: 6px;
            text-transform: uppercase;
            margin-bottom: 8px;
        }

        #score-display {
            font-size: 48px;
            font-weight: 700;
            background: linear-gradient(180deg, #00ffff, #0088ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        #enemy-count {
            font-size: 20px;
            color: rgba(255,255,255,0.6);
            margin-top: 8px;
        }

        /* Crosshair */
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        #crosshair svg {
            filter: drop-shadow(0 0 4px rgba(0,255,255,0.8));
        }

        /* Damage Overlay */
        #damage-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: radial-gradient(ellipse at center, transparent 40%, rgba(255,0,0,0.4) 100%);
            opacity: 0;
            transition: opacity 0.1s;
        }

        #streamer-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 250px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #9147ff;
            border-radius: 10px;
            padding: 15px;
            color: white;
            font-family: 'Segoe UI', sans-serif;
            display: none;
            z-index: 20;
        }
        .chat-message {
            font-size: 12px;
            margin-bottom: 4px;
            opacity: 0.8;
        }
        .chat-user { font-weight: bold; color: #bf94ff; }
        .vote-bar-container {
            margin-top: 10px;
            background: rgba(255,255,255,0.1);
            height: 20px;
            border-radius: 4px;
            position: relative;
            overflow: hidden;
        }
        .vote-bar {
            height: 100%;
            background: #9147ff;
            width: 0%;
            transition: width 0.5s;
        }
        .vote-label {
            position: absolute;
            top: 0;
            left: 5px;
            font-size: 12px;
            line-height: 20px;
            text-shadow: 1px 1px 1px black;
        }

        /* Hit Marker */
        #hit-marker {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            opacity: 0;
        }

        /* Kill Feed */
        #kill-feed {
            position: absolute;
            top: 120px;
            right: 60px;
            text-align: right;
        }

        .kill-entry {
            font-size: 22px;
            padding: 8px 16px;
            margin-bottom: 8px;
            background: rgba(0,0,0,0.5);
            border-right: 4px solid #ff4444;
            animation: killFade 3s forwards;
        }

        @keyframes killFade {
            0%, 70% { opacity: 1; transform: translateX(0); }
            100% { opacity: 0; transform: translateX(50px); }
        }

        /* Streamer Mode UI */
        #chat-overlay {
            position: absolute;
            top: 150px;
            left: 20px;
            width: 300px;
            height: 400px;
            overflow: hidden;
            pointer-events: none;
            font-family: 'Segoe UI', sans-serif;
            text-shadow: 1px 1px 2px black;
            display: none;
        }

        .chat-message {
            margin-bottom: 8px;
            font-size: 14px;
            animation: chatFadeIn 0.3s ease-out;
        }

        .chat-user {
            font-weight: bold;
            color: #aaffaa;
        }

        .chat-text {
            color: #ffffff;
        }

        @keyframes chatFadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        #vote-overlay {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #aaffaa;
            text-align: center;
            display: none;
            min-width: 300px;
        }

        #vote-title {
            color: #aaffaa;
            font-size: 24px;
            margin-bottom: 10px;
            text-transform: uppercase;
        }

        .vote-option {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 18px;
            color: white;
        }

        .vote-bar-bg {
            width: 100%;
            height: 10px;
            background: #333;
            margin-top: 5px;
            border-radius: 5px;
        }

        .vote-bar-fill {
            height: 100%;
            background: #aaffaa;
            width: 0%;
            transition: width 0.5s;
            border-radius: 5px;
        }

        /* Controls Hint - Bottom Center */
        #controls-hint {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 30px;
            font-size: 14px;
            color: rgba(255,255,255,0.5);
            pointer-events: none;
        }

        #controls-hint span {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .key-hint {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 28px;
            height: 28px;
            padding: 0 8px;
            background: rgba(255,255,255,0.15);
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 6px;
            font-size: 12px;
            font-weight: 700;
        }

        /* Menu Screens */
        .menu-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a0a2a 50%, #0a1a2a 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .menu-screen.hidden {
            display: none;
        }

        #title-screen h1 {
            font-size: 120px;
            font-weight: 900;
            letter-spacing: -4px;
            background: linear-gradient(180deg, #00ffff, #0066ff, #ff00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: none;
            margin-bottom: 20px;
            animation: titlePulse 3s ease-in-out infinite;
        }

        @keyframes titlePulse {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.3); }
        }

        #title-screen h2 {
            font-size: 32px;
            color: rgba(255,255,255,0.6);
            letter-spacing: 20px;
            text-transform: uppercase;
            margin-bottom: 80px;
        }

        .menu-button {
            padding: 24px 80px;
            font-size: 28px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 6px;
            background: linear-gradient(135deg, rgba(0,255,255,0.2), rgba(0,100,255,0.2));
            border: 3px solid rgba(0,255,255,0.5);
            border-radius: 12px;
            color: #fff;
            cursor: pointer;
            margin: 12px;
            transition: all 0.2s;
            pointer-events: auto;
        }

        .menu-button:hover, .menu-button.selected {
            background: linear-gradient(135deg, rgba(0,255,255,0.4), rgba(0,100,255,0.4));
            border-color: #00ffff;
            transform: scale(1.05);
            box-shadow: 0 0 40px rgba(0,255,255,0.4);
        }

        .menu-button:focus {
            outline: none;
            border-color: #00ffff;
            box-shadow: 0 0 40px rgba(0,255,255,0.4);
        }

        /* Controller Prompt - Dynamic */
        .controller-prompt {
            position: absolute;
            bottom: 60px;
            display: flex;
            gap: 40px;
            font-size: 20px;
            color: rgba(255,255,255,0.6);
        }

        .controller-prompt span {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        /* Keyboard prompts */
        .kb-prompt { display: none; }
        .gp-prompt { display: flex; }
        body.keyboard-active .kb-prompt { display: flex; }
        body.keyboard-active .gp-prompt { display: none; }

        .xbox-button {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            font-weight: 700;
            font-size: 18px;
        }

        .xbox-a { background: #2ecc40; }
        .xbox-b { background: #ff4444; }
        .xbox-x { background: #0074d9; }
        .xbox-y { background: #ffdc00; color: #000; }
        .xbox-lb, .xbox-rb {
            background: #333;
            border-radius: 8px;
            width: auto;
            padding: 8px 16px;
        }

        .kb-key {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 40px;
            height: 40px;
            padding: 0 12px;
            background: rgba(255,255,255,0.15);
            border: 2px solid rgba(255,255,255,0.4);
            border-radius: 8px;
            font-weight: 700;
            font-size: 16px;
        }

        /* Upgrade Screen */
        #upgrade-screen {
            background: rgba(0,0,0,0.95);
        }

        #upgrade-screen h2 {
            font-size: 48px;
            margin-bottom: 60px;
            color: #00ffff;
            text-transform: uppercase;
            letter-spacing: 10px;
        }

        .upgrade-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 30px;
            max-width: 1000px;
        }

        .upgrade-card {
            background: rgba(255,255,255,0.05);
            border: 3px solid rgba(255,255,255,0.1);
            border-radius: 16px;
            padding: 30px;
            text-align: center;
            transition: all 0.2s;
            cursor: pointer;
        }

        .upgrade-card:hover, .upgrade-card.selected {
            background: rgba(0,255,255,0.1);
            border-color: #00ffff;
            transform: scale(1.05);
        }

        .upgrade-icon {
            font-size: 64px;
            margin-bottom: 16px;
        }

        .upgrade-name {
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 12px;
        }

        .upgrade-desc {
            font-size: 16px;
            color: rgba(255,255,255,0.6);
        }

        /* Pause Screen */
        #pause-screen {
            background: rgba(0,0,0,0.9);
            backdrop-filter: blur(10px);
        }

        #pause-screen h2 {
            font-size: 72px;
            margin-bottom: 60px;
            letter-spacing: 20px;
        }

        /* Loading Screen */
        #loading-screen {
            background: #000;
        }

        .loading-bar-outer {
            width: 400px;
            height: 8px;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 40px;
        }

        .loading-bar-inner {
            height: 100%;
            background: linear-gradient(90deg, #00ffff, #ff00ff);
            border-radius: 4px;
            animation: loadingProgress 2s ease-out forwards;
        }

        @keyframes loadingProgress {
            from { width: 0%; }
            to { width: 100%; }
        }

        #loading-text {
            font-size: 24px;
            color: rgba(255,255,255,0.5);
            margin-top: 20px;
            letter-spacing: 4px;
        }

        /* Wave Announcement */
        #wave-announce {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none;
            opacity: 0;
            z-index: 100;
        }

        #wave-announce.show {
            animation: waveAnnounce 3s forwards;
        }

        @keyframes waveAnnounce {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            15% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
            25% { transform: translate(-50%, -50%) scale(1); }
            75% { opacity: 1; }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
        }

        #wave-announce h2 {
            font-size: 36px;
            color: #ffaa00;
            letter-spacing: 10px;
            text-transform: uppercase;
        }

        #wave-announce h1 {
            font-size: 120px;
            font-weight: 900;
            background: linear-gradient(180deg, #fff, #00ffff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        /* Boss Warning */
        #boss-warning {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none;
            opacity: 0;
            z-index: 100;
        }

        #boss-warning.show {
            animation: bossWarn 4s forwards;
        }

        @keyframes bossWarn {
            0%, 10%, 20%, 30%, 40% { opacity: 1; }
            5%, 15%, 25%, 35% { opacity: 0.3; }
            50% { opacity: 1; }
            100% { opacity: 0; }
        }

        #boss-warning h1 {
            font-size: 80px;
            color: #ff4444;
            text-transform: uppercase;
            letter-spacing: 20px;
            text-shadow: 0 0 60px rgba(255,0,0,0.8);
        }

        /* FPS Counter */
        #fps-counter {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 16px;
            color: rgba(255,255,255,0.4);
            font-family: monospace;
        }

        /* Input Mode Indicator */
        #input-mode {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 14px;
            color: rgba(255,255,255,0.3);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #input-mode-icon {
            font-size: 20px;
        }

        /* Combo Counter */
        #combo-display {
            position: absolute;
            right: 60px;
            top: 50%;
            transform: translateY(-50%);
            text-align: right;
            opacity: 0;
            transition: opacity 0.3s;
        }

        #combo-display.active {
            opacity: 1;
        }

        #combo-count {
            font-size: 96px;
            font-weight: 900;
            background: linear-gradient(180deg, #ffaa00, #ff4400);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        #combo-label {
            font-size: 24px;
            color: #ffaa00;
            letter-spacing: 6px;
            text-transform: uppercase;
        }

        #combo-multiplier {
            font-size: 32px;
            color: #ff4400;
        }

        /* Minimap */
        #minimap {
            position: absolute;
            top: 40px;
            right: 60px;
            width: 180px;
            height: 180px;
            background: rgba(0,0,0,0.6);
            border: 3px solid rgba(255,255,255,0.2);
            border-radius: 12px;
            overflow: hidden;
        }

        #minimap-canvas {
            width: 100%;
            height: 100%;
        }

        /* Sensitivity Slider (in pause menu) */
        .sensitivity-control {
            display: flex;
            align-items: center;
            gap: 20px;
            margin: 20px 0;
            font-size: 18px;
        }

        .sensitivity-control input[type="range"] {
            width: 200px;
            height: 8px;
            -webkit-appearance: none;
            background: rgba(255,255,255,0.2);
            border-radius: 4px;
            outline: none;
        }

        .sensitivity-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: #00ffff;
            border-radius: 50%;
            cursor: pointer;
        }

        /* Settings Section */
        .settings-section {
            border-top: 1px solid rgba(255,255,255,0.2);
            margin-top: 20px;
            padding-top: 20px;
        }

        .settings-section h3 {
            font-size: 16px;
            color: #00ffff;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        /* Input Mode Toggle */
        .input-mode-toggle {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin: 15px 0;
        }

        .toggle-option {
            padding: 10px 20px;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
            opacity: 0.6;
        }

        .toggle-option:hover {
            opacity: 0.8;
            border-color: rgba(255,255,255,0.5);
        }

        .toggle-option.active {
            border-color: #00ffff;
            background: rgba(0,255,255,0.1);
            opacity: 1;
        }

        .toggle-option .toggle-icon {
            font-size: 24px;
            display: block;
            margin-bottom: 5px;
        }

        /* Auto-switch toggle */
        .auto-switch-toggle {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin: 10px 0;
            font-size: 14px;
            opacity: 0.8;
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 26px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(255,255,255,0.2);
            transition: 0.3s;
            border-radius: 26px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: #00ffff;
        }

        input:checked + .slider:before {
            transform: translateX(24px);
        }

        /* Controller sensitivity (shown when gamepad selected) */
        .controller-sensitivity {
            display: none;
        }

        body:not(.keyboard-active) .controller-sensitivity {
            display: flex;
        }

        body:not(.keyboard-active) .mouse-sensitivity {
            display: none;
        }

        body.keyboard-active .mouse-sensitivity {
            display: flex;
        }

        /* Click to Play Overlay */
        #click-to-play {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            padding: 30px 60px;
            border-radius: 16px;
            border: 2px solid #00ffff;
            text-align: center;
            z-index: 50;
            display: none;
            cursor: pointer;
        }

        #click-to-play h3 {
            font-size: 28px;
            margin-bottom: 10px;
        }

        #click-to-play p {
            color: rgba(255,255,255,0.6);
            font-size: 16px;
        }
    </style>
</head>
<body class="menu">
    <div id="game-container">
        <div id="streamer-overlay">
            <div style="color: #9147ff; font-weight: bold; margin-bottom: 10px;">üî¥ LIVE CHAT VOTE</div>
            <div id="vote-options"></div>
            <div id="chat-feed" style="height: 100px; overflow: hidden; margin-top: 10px; border-top: 1px solid #444; padding-top: 5px;"></div>
        </div>
        <canvas id="game-canvas"></canvas>

        <!-- HUD Elements -->
        <div id="health-container" class="hud">
            <div id="health-icon">+</div>
            <div id="health-bar-outer">
                <div id="health-bar-inner" style="width: 100%"></div>
            </div>
            <div id="health-text">100</div>
        </div>

        <div id="ammo-container" class="hud">
            <div>
                <div id="weapon-name">PLASMA RIFLE</div>
                <div id="ammo-max">/ 30</div>
            </div>
            <div id="ammo-count">30</div>
        </div>

        <div id="top-hud" class="hud">
            <div id="wave-display">WAVE 1</div>
            <div id="score-display">0</div>
            <div id="enemy-count">ENEMIES: 0</div>
        </div>

        <div id="crosshair">
            <svg width="64" height="64" viewBox="0 0 64 64">
                <circle cx="32" cy="32" r="4" fill="none" stroke="#00ffff" stroke-width="2"/>
                <line x1="32" y1="12" x2="32" y2="24" stroke="#00ffff" stroke-width="2"/>
                <line x1="32" y1="40" x2="32" y2="52" stroke="#00ffff" stroke-width="2"/>
                <line x1="12" y1="32" x2="24" y2="32" stroke="#00ffff" stroke-width="2"/>
                <line x1="40" y1="32" x2="52" y2="32" stroke="#00ffff" stroke-width="2"/>
            </svg>
        </div>

        <div id="damage-overlay"></div>

        <div id="hit-marker">
            <svg width="48" height="48" viewBox="0 0 48 48">
                <line x1="12" y1="12" x2="20" y2="20" stroke="#fff" stroke-width="3"/>
                <line x1="36" y1="12" x2="28" y2="20" stroke="#fff" stroke-width="3"/>
                <line x1="12" y1="36" x2="20" y2="28" stroke="#fff" stroke-width="3"/>
                <line x1="36" y1="36" x2="28" y2="28" stroke="#fff" stroke-width="3"/>
            </svg>
        </div>

        <div id="kill-feed"></div>

        <div id="combo-display">
            <div id="combo-count">0</div>
            <div id="combo-label">COMBO</div>
            <div id="combo-multiplier">x1.0</div>
        </div>

        <div id="minimap">
            <canvas id="minimap-canvas"></canvas>
        </div>

        <div id="chat-overlay"></div>
        <div id="vote-overlay">
            <div id="vote-title">CHAT VOTE</div>
            <div id="vote-options"></div>
            <div id="vote-timer" style="margin-top: 10px; color: #ffff00;">Time left: 10s</div>
        </div>

        <div id="editor-overlay" style="display: none; position: absolute; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); padding: 10px; border: 1px solid #00ff00; color: #00ff00; font-family: monospace;">
            <div>LEVEL EDITOR MODE</div>
            <div>Item: <span id="editor-current-item">Wall</span> ([ / ])</div>
            <div>LMB: Place | RMB: Remove</div>
            <div>WASD: Move | Shift: Down | Space: Up</div>
            <div>K: Save | L: Load</div>
        </div>

        <div id="controls-hint" class="hud">
            <!-- Keyboard hints -->
            <span class="kb-prompt"><span class="key-hint">WASD</span> Move</span>
            <span class="kb-prompt"><span class="key-hint">SPACE</span> Jump</span>
            <span class="kb-prompt"><span class="key-hint">MOUSE</span> Aim</span>
            <span class="kb-prompt"><span class="key-hint">LMB</span> Fire</span>
            <span class="kb-prompt"><span class="key-hint">R</span> Reload</span>
            <span class="kb-prompt"><span class="key-hint">1-4</span> Weapons</span>
            <span class="kb-prompt"><span class="key-hint">ESC</span> Pause</span>

            <!-- Gamepad hints -->
            <span class="gp-prompt">L-STICK Move</span>
            <span class="gp-prompt"><span class="xbox-button xbox-a">A</span> Jump</span>
            <span class="gp-prompt">RT Fire</span>
            <span class="gp-prompt"><span class="xbox-button xbox-x">X</span> Reload</span>
            <span class="gp-prompt"><span class="xbox-button xbox-lb">LB</span>/<span class="xbox-button xbox-rb">RB</span> Weapon</span>
        </div>

        <div id="wave-announce">
            <h2>WAVE</h2>
            <h1 id="wave-number">1</h1>
        </div>

        <div id="boss-warning">
            <h1>WARNING: BOSS INCOMING</h1>
        </div>

        <div id="fps-counter">60 FPS</div>

        <div id="input-mode">
            <span id="input-mode-icon">üéÆ</span>
            <span id="input-mode-text">Controller</span>
        </div>

        <div id="click-to-play" onclick="requestPointerLockAndResume()">
            <h3>CLICK TO CONTINUE</h3>
            <p>Click to capture mouse and resume gameplay</p>
        </div>

        <!-- Menu Screens -->
        <div id="loading-screen" class="menu-screen">
            <h1 style="font-size: 80px; letter-spacing: -2px; background: linear-gradient(180deg, #00ffff, #0066ff); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">APEX PROTOCOL</h1>
            <div class="loading-bar-outer">
                <div class="loading-bar-inner"></div>
            </div>
            <div id="loading-text">INITIALIZING COMBAT SYSTEMS...</div>
        </div>

        <div id="title-screen" class="menu-screen hidden">
            <h1>APEX</h1>
            <h2>PROTOCOL</h2>
            <button class="menu-button selected" id="btn-start" tabindex="1">START GAME</button>
            <button class="menu-button" id="btn-continue" tabindex="2">CONTINUE</button>
            <div class="controller-prompt">
                <!-- Gamepad prompts -->
                <span class="gp-prompt"><span class="xbox-button xbox-a">A</span> SELECT</span>
                <span class="gp-prompt"><span class="xbox-button xbox-b">B</span> BACK</span>
                <span class="gp-prompt">STICK TO NAVIGATE</span>
                <!-- Keyboard prompts -->
                <span class="kb-prompt"><span class="kb-key">ENTER</span> SELECT</span>
                <span class="kb-prompt"><span class="kb-key">ESC</span> BACK</span>
                <span class="kb-prompt"><span class="kb-key">‚Üë‚Üì</span> NAVIGATE</span>
            </div>
        </div>

        <div id="pause-screen" class="menu-screen hidden">
            <h2>PAUSED</h2>
            <button class="menu-button selected" id="btn-resume" tabindex="1">RESUME</button>
            <button class="menu-button" id="btn-restart" tabindex="2">RESTART</button>
            <button class="menu-button" id="btn-quit" tabindex="3">QUIT TO MENU</button>

            <div class="settings-section">
                <h3>Input Settings</h3>
                <div class="input-mode-toggle">
                    <div class="toggle-option" id="toggle-gamepad" data-mode="gamepad">
                        <span class="toggle-icon">üéÆ</span>
                        Controller
                    </div>
                    <div class="toggle-option" id="toggle-keyboard" data-mode="keyboard">
                        <span class="toggle-icon">‚å®Ô∏è</span>
                        Keyboard + Mouse
                    </div>
                </div>
                <div class="auto-switch-toggle">
                    <span>Auto-switch on input:</span>
                    <label class="switch">
                        <input type="checkbox" id="auto-switch-input" checked>
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="auto-switch-toggle">
                    <span>Streamer Mode:</span>
                    <label class="switch">
                        <input type="checkbox" id="streamer-mode-toggle">
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="sensitivity-control mouse-sensitivity">
                    <span>Mouse Sensitivity:</span>
                    <input type="range" id="mouse-sensitivity" min="0.5" max="5" step="0.1" value="2">
                    <span id="mouse-sensitivity-value">2.0</span>
                </div>
                <div class="sensitivity-control controller-sensitivity">
                    <span>Controller Sensitivity:</span>
                    <input type="range" id="controller-sensitivity" min="0.5" max="5" step="0.1" value="2.5">
                    <span id="controller-sensitivity-value">2.5</span>
                </div>
            </div>

            <div class="controller-prompt">
                <span class="gp-prompt"><span class="xbox-button xbox-a">A</span> SELECT</span>
                <span class="gp-prompt"><span class="xbox-button xbox-b">B</span> RESUME</span>
                <span class="kb-prompt"><span class="kb-key">ENTER</span> SELECT</span>
                <span class="kb-prompt"><span class="kb-key">ESC</span> RESUME</span>
            </div>
        </div>

        <div id="upgrade-screen" class="menu-screen hidden">
            <h2>CHOOSE UPGRADE</h2>
            <div class="upgrade-grid" id="upgrade-grid"></div>
            <div class="controller-prompt">
                <span class="gp-prompt"><span class="xbox-button xbox-a">A</span> SELECT</span>
                <span class="gp-prompt">STICK TO CHOOSE</span>
                <span class="kb-prompt"><span class="kb-key">ENTER</span> or <span class="kb-key">1-3</span> SELECT</span>
                <span class="kb-prompt"><span class="kb-key">‚Üê‚Üí</span> CHOOSE</span>
            </div>
        </div>

        <div id="gameover-screen" class="menu-screen hidden">
            <h1 style="font-size: 96px; color: #ff4444; margin-bottom: 20px;">GAME OVER</h1>
            <div style="font-size: 36px; margin-bottom: 20px;">WAVE <span id="final-wave">1</span></div>
            <div style="font-size: 72px; color: #00ffff; margin-bottom: 60px;">SCORE: <span id="final-score">0</span></div>
            <button class="menu-button selected" id="btn-retry" tabindex="1">RETRY</button>
            <button class="menu-button" id="btn-menu" tabindex="2">MAIN MENU</button>
            <div class="controller-prompt">
                <span class="gp-prompt"><span class="xbox-button xbox-a">A</span> SELECT</span>
                <span class="kb-prompt"><span class="kb-key">ENTER</span> SELECT</span>
                <span class="kb-prompt"><span class="kb-key">‚Üë‚Üì</span> NAVIGATE</span>
            </div>
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // ASSET MANIFEST SYSTEM
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        const MANIFEST_PATH = 'https://raw.githubusercontent.com/kody-w/localFirstTools/main/data/games/apex-protocol/manifest.json';
        const ENEMY_BASE_PATH = 'https://raw.githubusercontent.com/kody-w/localFirstTools/main/data/games/apex-protocol/';

        const gameAssets = {
            manifest: null,
            enemies: {},
            loaded: false
        };

        function updateLoadingText(text) {
            const loadingText = document.getElementById('loading-text');
            if (loadingText) loadingText.textContent = text;
        }

        async function loadManifest() {
            try {
                updateLoadingText('LOADING ASSET MANIFEST...');
                const response = await fetch(MANIFEST_PATH);
                if (!response.ok) throw new Error('Failed to load manifest');
                gameAssets.manifest = await response.json();
                console.log('[APEX] Manifest loaded:', gameAssets.manifest.name, 'v' + gameAssets.manifest.version);

                // Load all enemy models
                const enemyKeys = Object.keys(gameAssets.manifest.enemies);
                let loadedCount = 0;

                for (const [key, enemyDef] of Object.entries(gameAssets.manifest.enemies)) {
                    try {
                        updateLoadingText(`LOADING ENEMY: ${key.toUpperCase()}...`);
                        const enemyResponse = await fetch(ENEMY_BASE_PATH + enemyDef.file);
                        if (enemyResponse.ok) {
                            const enemyData = await enemyResponse.json();
                            gameAssets.enemies[key] = {
                                ...enemyDef.stats,
                                modelData: enemyData
                            };
                            loadedCount++;
                            console.log('[APEX] Loaded enemy:', enemyData.name);
                        }
                    } catch (e) {
                        console.warn('[APEX] Failed to load enemy:', key, e);
                    }
                }

                updateLoadingText(`LOADED ${loadedCount}/${enemyKeys.length} ENEMY TYPES`);
                await new Promise(r => setTimeout(r, 300));
                updateLoadingText('INITIALIZING COMBAT SYSTEMS...');

                gameAssets.loaded = true;
                return true;
            } catch (error) {
                console.warn('[APEX] Manifest not found, using fallback enemies:', error.message);
                updateLoadingText('USING DEFAULT ENEMY CONFIGURATION...');
                return false;
            }
        }

        function buildMeshFromBodyPart(part) {
            let geometry;
            const scale = 1;

            switch (part.shape) {
                case 'box':
                    geometry = new THREE.BoxGeometry(
                        (part.width || 1) * scale,
                        (part.height || 1) * scale,
                        (part.depth || 1) * scale
                    );
                    break;
                case 'sphere':
                    geometry = new THREE.SphereGeometry((part.size || 0.5) * scale, 16, 12);
                    break;
                case 'cylinder':
                    geometry = new THREE.CylinderGeometry(
                        (part.radiusTop || 0.5) * scale,
                        (part.radiusBottom || 0.5) * scale,
                        (part.height || 1) * scale,
                        16
                    );
                    break;
                case 'cone':
                    geometry = new THREE.ConeGeometry(
                        (part.size || 0.5) * scale,
                        (part.height || 1) * scale,
                        16
                    );
                    break;
                default:
                    geometry = new THREE.BoxGeometry(1, 1, 1);
            }

            const materialConfig = {
                color: part.color || '#ffffff',
                metalness: part.metalness !== undefined ? part.metalness : 0.5,
                roughness: part.roughness !== undefined ? part.roughness : 0.5
            };

            if (part.emissive) {
                materialConfig.emissive = part.emissive;
                materialConfig.emissiveIntensity = 0.5;
            }

            if (part.transparent) {
                materialConfig.transparent = true;
                materialConfig.opacity = part.opacity !== undefined ? part.opacity : 0.5;
            }

            const material = new THREE.MeshStandardMaterial(materialConfig);
            const mesh = new THREE.Mesh(geometry, material);

            if (part.position) {
                mesh.position.set(part.position[0], part.position[1], part.position[2]);
            }

            if (part.rotation) {
                mesh.rotation.set(
                    THREE.MathUtils.degToRad(part.rotation[0] || 0),
                    THREE.MathUtils.degToRad(part.rotation[1] || 0),
                    THREE.MathUtils.degToRad(part.rotation[2] || 0)
                );
            }

            mesh.castShadow = true;
            mesh.receiveShadow = true;
            mesh.userData.partName = part.name;

            return mesh;
        }

        function buildEnemyFromModelData(modelData, scale = 1) {
            const group = new THREE.Group();
            const parts = {}; // Named references to body parts for animation
            const partOriginals = {}; // Store original positions/rotations for animation

            if (!modelData || !modelData.bodyParts) {
                // Fallback simple mesh
                const geometry = new THREE.BoxGeometry(1, 2, 0.5);
                const material = new THREE.MeshStandardMaterial({ color: 0xff4444 });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.y = 1;
                group.add(mesh);
                group.userData.parts = {};
                group.userData.partOriginals = {};
                return group;
            }

            const modelScale = (modelData.scale || 1) * scale;

            for (const part of modelData.bodyParts) {
                const mesh = buildMeshFromBodyPart(part);
                mesh.position.multiplyScalar(modelScale);
                mesh.scale.multiplyScalar(modelScale);
                group.add(mesh);

                // Store named reference for animation
                if (part.name) {
                    parts[part.name] = mesh;
                    partOriginals[part.name] = {
                        position: mesh.position.clone(),
                        rotation: mesh.rotation.clone(),
                        scale: mesh.scale.clone()
                    };
                }
            }

            group.userData.parts = parts;
            group.userData.partOriginals = partOriginals;
            group.userData.animations = modelData.animations || {};
            return group;
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // ANIMATION SYSTEM
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        const AnimationSystem = {
            update: (enemy, deltaTime) => {
                if (!enemy || !enemy.mesh || !enemy.mesh.userData) return;
                const mesh = enemy.mesh;
                const parts = mesh.userData.parts;
                const originals = mesh.userData.partOriginals;
                const anims = mesh.userData.animations;
                
                if (!parts || !originals || !anims) return;

                // Determine state
                const isMoving = enemy.velocity && enemy.velocity.lengthSq() > 0.1;
                const isAttacking = enemy.attackTimer > 0 && enemy.attackTimer < 0.5; // Simple heuristic
                
                // Reset to originals first (or blend - simple reset for now)
                for (const name in parts) {
                    // parts[name].position.copy(originals[name].position);
                    // parts[name].rotation.copy(originals[name].rotation);
                }

                // IDLE ANIMATION
                if (anims.idle) {
                    const t = state.time * (anims.idle.swaySpeed || 1);
                    
                    if (anims.idle.parts) {
                        for (const [partName, config] of Object.entries(anims.idle.parts)) {
                            const part = parts[partName];
                            const orig = originals[partName];
                            if (!part) continue;

                            if (config.rotateX) {
                                const amp = config.rotateX.amplitude || 0;
                                const speed = config.rotateX.speed || 1;
                                const phase = config.rotateX.phase || 0;
                                const offset = config.rotateX.offset || 0;
                                part.rotation.x = orig.rotation.x + offset + Math.sin(t * speed + phase) * amp;
                            }
                            if (config.rotateY) {
                                const amp = config.rotateY.amplitude || 0;
                                const speed = config.rotateY.speed || 1;
                                const phase = config.rotateY.phase || 0;
                                const offset = config.rotateY.offset || 0;
                                part.rotation.y = orig.rotation.y + offset + Math.sin(t * speed + phase) * amp;
                            }
                            if (config.rotateZ) {
                                const amp = config.rotateZ.amplitude || 0;
                                const speed = config.rotateZ.speed || 1;
                                const phase = config.rotateZ.phase || 0;
                                const offset = config.rotateZ.offset || 0;
                                part.rotation.z = orig.rotation.z + offset + Math.sin(t * speed + phase) * amp;
                            }
                            if (config.emissivePulse || config.glow) {
                                const conf = config.emissivePulse || config.glow;
                                const intensity = conf.min + (Math.sin(t * conf.speed) * 0.5 + 0.5) * (conf.max - conf.min);
                                if (part.material.emissive) part.material.emissiveIntensity = intensity;
                            }
                            if (config.scale || config.pulse) {
                                const conf = config.scale || config.pulse;
                                const min = conf.min !== undefined ? conf.min : 1;
                                const max = conf.max !== undefined ? conf.max : 1;
                                const speed = conf.speed || 1;
                                const s = min + (Math.sin(t * speed) * 0.5 + 0.5) * (max - min);
                                part.scale.set(s, s, s);
                            }
                            if (config.opacity) {
                                const conf = config.opacity;
                                const min = conf.min !== undefined ? conf.min : 0;
                                const max = conf.max !== undefined ? conf.max : 1;
                                const speed = conf.speed || 1;
                                const o = min + (Math.sin(t * speed) * 0.5 + 0.5) * (max - min);
                                if (part.material.transparent) part.material.opacity = o;
                            }
                            if (config.rotate) {
                                const speed = config.rotate.speed || 1;
                                const axis = config.rotate.axis || 'y';
                                if (axis === 'x') part.rotation.x = orig.rotation.x + state.time * speed;
                                if (axis === 'y') part.rotation.y = orig.rotation.y + state.time * speed;
                                if (axis === 'z') part.rotation.z = orig.rotation.z + state.time * speed;
                            }
                        }
                    }
                }

                // CONTINUOUS ROTATION (Global)
                if (anims.rotate) {
                    const speed = anims.rotate.speed || 1;
                    const axis = anims.rotate.axis || 'y';
                    if (anims.rotate.parts) {
                         for (const partName of anims.rotate.parts) {
                            const part = parts[partName];
                            const orig = originals[partName];
                            if (!part) continue;
                            
                            if (axis === 'x') part.rotation.x = orig.rotation.x + state.time * speed;
                            if (axis === 'y') part.rotation.y = orig.rotation.y + state.time * speed;
                            if (axis === 'z') part.rotation.z = orig.rotation.z + state.time * speed;
                         }
                    }
                }

                // WALK ANIMATION
                if (isMoving && anims.walk) {
                    const speed = anims.walk.bobSpeed || 5;
                    const t = state.time * speed;
                    
                    // Bobbing
                    if (anims.walk.bob) {
                        mesh.position.y = (originals.torso ? originals.torso.position.y : 0) + Math.sin(t * 2) * (anims.walk.bobAmount || 0.1);
                    }

                    // Leg Swing
                    if (anims.walk.legSwing) {
                        const amp = anims.walk.legSwingAmount || 0.5;
                        if (parts.leftLeg) parts.leftLeg.rotation.x = originals.leftLeg.rotation.x + Math.sin(t) * amp;
                        if (parts.rightLeg) parts.rightLeg.rotation.x = originals.rightLeg.rotation.x + Math.sin(t + Math.PI) * amp;
                    }

                    // Arm Swing
                    if (anims.walk.armSwing) {
                        const amp = anims.walk.armSwingAmount || 0.3;
                        if (parts.leftArm) parts.leftArm.rotation.x = originals.leftArm.rotation.x + Math.sin(t + Math.PI) * amp;
                        if (parts.rightArm) parts.rightArm.rotation.x = originals.rightArm.rotation.x + Math.sin(t) * amp;
                    }
                }

                // ATTACK ANIMATION (Overlay)
                if (isAttacking && anims.attack) {
                    const progress = 1 - (enemy.attackTimer / (enemy.type.attackRate || 1)); // 0 to 1
                    
                    if (anims.attack.parts) {
                        for (const [partName, config] of Object.entries(anims.attack.parts)) {
                            const part = parts[partName];
                            const orig = originals[partName];
                            if (!part) continue;

                            if (config.kickback) {
                                // Simple recoil: back then forward
                                const recoil = Math.sin(progress * Math.PI) * config.kickback;
                                part.position.z = orig.position.z + recoil; // Local Z is usually forward/back
                            }
                        }
                    }
                }
            }
        };

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // GAME STATE
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        const GameState = {
            LOADING: 'loading',
            MENU: 'menu',
            PLAYING: 'playing',
            PAUSED: 'paused',
            UPGRADE: 'upgrade',
            GAMEOVER: 'gameover'
        };

        const InputMode = {
            KEYBOARD: 'keyboard',
            GAMEPAD: 'gamepad'
        };

        const state = {
            current: GameState.LOADING,
            timeScale: 1.0,
            destructibles: [],
            wave: 1,
            score: 0,
            combo: 0,
            comboTimer: 0,
            highScore: parseInt(localStorage.getItem('apex_highscore') || '0'),

            player: {
                health: 100,
                maxHealth: 100,
                armor: 0,
                speed: 12,
                damage: 1,
                critChance: 0.1,
                critMultiplier: 2,
                position: new THREE.Vector3(0, 1.8, 0),
                velocity: new THREE.Vector3(),
                rotation: { x: 0, y: 0 },
                isGrounded: true
            },

            weapons: [
                {
                    name: 'PLASMA RIFLE',
                    ammo: 30,
                    maxAmmo: 30,
                    damage: 25,
                    fireRate: 0.1,
                    reloadTime: 1.5,
                    spread: 0.02,
                    projectileSpeed: 150,
                    color: 0x00ffff,
                    sound: 'plasma'
                },
                {
                    name: 'SHOTGUN',
                    ammo: 8,
                    maxAmmo: 8,
                    damage: 15,
                    fireRate: 0.6,
                    reloadTime: 2.0,
                    spread: 0.15,
                    pellets: 8,
                    projectileSpeed: 100,
                    color: 0xffaa00,
                    sound: 'shotgun'
                },
                {
                    name: 'RAILGUN',
                    ammo: 5,
                    maxAmmo: 5,
                    damage: 150,
                    fireRate: 1.2,
                    reloadTime: 3.0,
                    spread: 0,
                    piercing: true,
                    projectileSpeed: 500,
                    color: 0xff00ff,
                    sound: 'railgun'
                },
                {
                    name: 'ROCKET LAUNCHER',
                    ammo: 3,
                    maxAmmo: 3,
                    damage: 100,
                    fireRate: 1.0,
                    reloadTime: 2.5,
                    spread: 0,
                    explosive: true,
                    explosionRadius: 8,
                    projectileSpeed: 40,
                    color: 0xff4400,
                    sound: 'rocket'
                },
                {
                    name: 'FRACTAL BLASTER',
                    ammo: 10,
                    maxAmmo: 10,
                    damage: 20,
                    fireRate: 0.5,
                    reloadTime: 2.5,
                    spread: 0.05,
                    projectileSpeed: 80,
                    color: 0x00ffff,
                    sound: 'plasma',
                    isFractal: true,
                    fractalDepth: 3
                }
            ],
            currentWeapon: 0,
            lastFire: 0,
            isReloading: false,
            reloadTimer: 0,

            enemies: [],
            projectiles: [],
            particles: [],
            pickups: [],

            arenaRadius: 50,

            // Input state
            inputMode: InputMode.GAMEPAD,
            preferredInputMode: localStorage.getItem('apex_input_mode') || 'gamepad',
            autoSwitchInput: localStorage.getItem('apex_auto_switch') !== 'false',
            lastInputTime: { keyboard: 0, gamepad: 0 },
            mouseSensitivity: parseFloat(localStorage.getItem('apex_mouse_sensitivity') || '2'),
            controllerSensitivity: parseFloat(localStorage.getItem('apex_controller_sensitivity') || '2.5'),

            input: {
                move: { x: 0, y: 0 },
                look: { x: 0, y: 0 },
                fire: false,
                aim: false,
                reload: false,
                jump: false,
                crouch: false,
                weapon1: false,
                weapon2: false,
                weapon3: false,
                weapon4: false,
                pause: false,
                select: false,
                back: false,
                menuMove: { x: 0, y: 0 }
            },

            gamepadConnected: false,
            lastGamepadInput: 0,
            menuSelection: 0,
            upgradeSelection: 0,

            upgrades: [],
            appliedUpgrades: [],

            screenShake: 0,
            damageFlash: 0,

            time: 0,
            deltaTime: 0,
            fps: 60,
            frameCount: 0,
            lastFpsUpdate: 0,

            pointerLocked: false,
            
            // Cheats
            noclip: false,
            
            // Streamer Mode State
            streamerMode: false,
            chatTimer: 0,
            voteTimer: 0,
            isVoting: false,
            voteOptions: [],
            voteCounts: {},
            activeModifiers: [],

            // Level Editor State
            editorMode: false,
            editorItem: 0,
            editorGridSize: 2,
            customMapData: null
        };

        const EditorItems = [
            { name: 'Wall', type: 'wall', color: 0x888888 },
            { name: 'Pillar', type: 'pillar', color: 0x4a4a7e },
            { name: 'Cover', type: 'cover', color: 0x5a5a8e },
            { name: 'Grunt', type: 'enemy', enemyType: 'GRUNT', color: 0xff4444 },
            { name: 'Tank', type: 'enemy', enemyType: 'TANK', color: 0x8844ff },
            { name: 'Boss', type: 'enemy', enemyType: 'BOSS', color: 0xff00ff }
        ];

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // LEVEL EDITOR SYSTEM
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        const LevelEditor = {
            previewMesh: null,
            placedObjects: [],
            
            init: () => {
                // Create preview cursor
                const geom = new THREE.BoxGeometry(2, 2, 2);
                const mat = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true, transparent: true, opacity: 0.5 });
                LevelEditor.previewMesh = new THREE.Mesh(geom, mat);
                scene.add(LevelEditor.previewMesh);
                LevelEditor.previewMesh.visible = false;
            },

            toggle: () => {
                state.editorMode = !state.editorMode;
                LevelEditor.previewMesh.visible = state.editorMode;
                
                if (state.editorMode) {
                    state.current = GameState.PLAYING; // Keep rendering loop active
                    document.getElementById('editor-overlay').style.display = 'block';
                    state.player.velocity.set(0, 0, 0); // Stop movement
                    addSystemMessage("LEVEL EDITOR ENABLED");
                } else {
                    document.getElementById('editor-overlay').style.display = 'none';
                    addSystemMessage("LEVEL EDITOR DISABLED");
                }
            },

            update: () => {
                if (!state.editorMode) return;

                // Noclip movement
                const speed = 20 * state.deltaTime;
                const dir = new THREE.Vector3();
                camera.getWorldDirection(dir);
                const right = new THREE.Vector3().crossVectors(dir, new THREE.Vector3(0, 1, 0));

                if (state.input.move.y > 0) state.player.position.addScaledVector(dir, speed);
                if (state.input.move.y < 0) state.player.position.addScaledVector(dir, -speed);
                if (state.input.move.x > 0) state.player.position.addScaledVector(right, speed);
                if (state.input.move.x < 0) state.player.position.addScaledVector(right, -speed);
                if (state.input.jump) state.player.position.y += speed;
                if (keys['ShiftLeft']) state.player.position.y -= speed;

                // Raycast for placement position
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
                const intersects = raycaster.intersectObjects(scene.children.filter(o => o.geometry && o.geometry.type === 'CircleGeometry')); // Intersect ground

                if (intersects.length > 0) {
                    const point = intersects[0].point;
                    // Snap to grid
                    const x = Math.round(point.x / state.editorGridSize) * state.editorGridSize;
                    const z = Math.round(point.z / state.editorGridSize) * state.editorGridSize;
                    
                    LevelEditor.previewMesh.position.set(x, 1, z);
                    
                    // Update preview color
                    const item = EditorItems[state.editorItem];
                    LevelEditor.previewMesh.material.color.setHex(item.color);

                    // Place object
                    if (state.input.fire && !state.input.fireHeld) {
                        state.input.fireHeld = true;
                        LevelEditor.placeObject(x, z, item);
                    }
                    if (!state.input.fire) state.input.fireHeld = false;

                    // Remove object (Right click)
                    if (state.input.aim && !state.input.aimHeld) {
                        state.input.aimHeld = true;
                        LevelEditor.removeObjectAt(x, z);
                    }
                    if (!state.input.aim) state.input.aimHeld = false;
                }

                // Cycle items
                if (keys['BracketRight'] && !state.input.nextItemHeld) {
                    state.editorItem = (state.editorItem + 1) % EditorItems.length;
                    state.input.nextItemHeld = true;
                    LevelEditor.updateUI();
                }
                if (!keys['BracketRight']) state.input.nextItemHeld = false;

                if (keys['BracketLeft'] && !state.input.prevItemHeld) {
                    state.editorItem = (state.editorItem - 1 + EditorItems.length) % EditorItems.length;
                    state.input.prevItemHeld = true;
                    LevelEditor.updateUI();
                }
                if (!keys['BracketLeft']) state.input.prevItemHeld = false;
                
                // Save/Load
                if (keys['KeyK']) LevelEditor.saveMap();
                if (keys['KeyL']) LevelEditor.loadMap();
            },

            placeObject: (x, z, item) => {
                // Remove existing at this spot first
                LevelEditor.removeObjectAt(x, z);

                let mesh;
                if (item.type === 'wall') {
                    const geom = new THREE.BoxGeometry(state.editorGridSize, 4, state.editorGridSize);
                    const mat = new THREE.MeshStandardMaterial({ color: item.color });
                    mesh = new THREE.Mesh(geom, mat);
                    mesh.position.set(x, 2, z);
                } else if (item.type === 'pillar') {
                    createPillar(x, z); // Use existing function, but track it
                    // Find the group we just added (last child)
                    mesh = scene.children[scene.children.length - 1];
                } else if (item.type === 'cover') {
                    createCover(x, z);
                    mesh = scene.children[scene.children.length - 1];
                } else if (item.type === 'enemy') {
                    // Just place a marker for now
                    const geom = new THREE.SphereGeometry(1);
                    const mat = new THREE.MeshBasicMaterial({ color: item.color, wireframe: true });
                    mesh = new THREE.Mesh(geom, mat);
                    mesh.position.set(x, 1, z);
                }

                if (mesh) {
                    mesh.userData.isEditorObject = true;
                    mesh.userData.editorType = item.type;
                    mesh.userData.editorData = item;
                    mesh.userData.gridPos = { x, z };
                    LevelEditor.placedObjects.push(mesh);
                    if (item.type !== 'pillar' && item.type !== 'cover') scene.add(mesh);
                }
            },

            removeObjectAt: (x, z) => {
                const idx = LevelEditor.placedObjects.findIndex(o => o.userData.gridPos.x === x && o.userData.gridPos.z === z);
                if (idx !== -1) {
                    const obj = LevelEditor.placedObjects[idx];
                    scene.remove(obj);
                    LevelEditor.placedObjects.splice(idx, 1);
                }
            },

            saveMap: () => {
                const mapData = LevelEditor.placedObjects.map(o => ({
                    type: o.userData.editorType,
                    data: o.userData.editorData,
                    x: o.userData.gridPos.x,
                    z: o.userData.gridPos.z
                }));
                const json = JSON.stringify(mapData);
                localStorage.setItem('apex_custom_map', json);
                addSystemMessage("MAP SAVED!");
                console.log(json);
            },

            loadMap: () => {
                const json = localStorage.getItem('apex_custom_map');
                if (!json) {
                    addSystemMessage("NO SAVED MAP FOUND");
                    return;
                }
                
                // Clear current arena objects
                // (Simplified: just clear editor objects for now)
                LevelEditor.placedObjects.forEach(o => scene.remove(o));
                LevelEditor.placedObjects = [];

                const mapData = JSON.parse(json);
                mapData.forEach(obj => {
                    LevelEditor.placeObject(obj.x, obj.z, obj.data);
                });
                addSystemMessage("MAP LOADED!");
            },

            updateUI: () => {
                const item = EditorItems[state.editorItem];
                document.getElementById('editor-current-item').textContent = item.name;
                document.getElementById('editor-current-item').style.color = '#' + item.color.toString(16).padStart(6, '0');
            }
        };

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // GHOST REPLAY SYSTEM
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        const GhostSystem = {
            maxFrames: 3600, // ~1 minute at 60fps (circular buffer or cap)
            recordRate: 0.05, // Record every 50ms
            timer: 0,
            
            init: () => {
                // Check for saved run
                const savedRun = localStorage.getItem('apex_ghost_run');
                if (savedRun) {
                    try {
                        state.ghostPlayback = JSON.parse(savedRun);
                        console.log('[GHOST] Loaded previous run:', state.ghostPlayback.length, 'frames');
                    } catch (e) {
                        console.error('[GHOST] Failed to load run', e);
                    }
                }
            },

            startRecording: () => {
                state.ghostRecording = [];
                state.isRecording = true;
                GhostSystem.timer = 0;
            },

            stopRecording: () => {
                state.isRecording = false;
                if (state.ghostRecording.length > 100) { // Only save substantial runs
                    localStorage.setItem('apex_ghost_run', JSON.stringify(state.ghostRecording));
                    console.log('[GHOST] Run saved!');
                }
            },

            update: (deltaTime) => {
                // RECORDING
                if (state.isRecording && state.current === GameState.PLAYING) {
                    GhostSystem.timer += deltaTime;
                    if (GhostSystem.timer >= GhostSystem.recordRate) {
                        GhostSystem.timer = 0;
                        
                        // Record frame
                        const frame = {
                            t: Math.round(state.time * 100) / 100,
                            p: [
                                Math.round(state.player.position.x * 100) / 100,
                                Math.round(state.player.position.y * 100) / 100,
                                Math.round(state.player.position.z * 100) / 100
                            ],
                            r: Math.round(state.player.rotation.y * 100) / 100,
                            f: state.input.fire // Is firing?
                        };
                        state.ghostRecording.push(frame);
                    }
                }

                // PLAYBACK
                if (state.ghostPlayback && state.ghostMesh) {
                    const playbackTime = state.time;
                    
                    // Find current frame (simple linear search for now, optimization: keep index)
                    // Since time is monotonic, we can just track the index
                    if (!state.ghostIndex) state.ghostIndex = 0;
                    
                    while (state.ghostIndex < state.ghostPlayback.length - 1 && 
                           state.ghostPlayback[state.ghostIndex + 1].t < playbackTime) {
                        state.ghostIndex++;
                    }

                    const currentFrame = state.ghostPlayback[state.ghostIndex];
                    const nextFrame = state.ghostPlayback[state.ghostIndex + 1];

                    if (currentFrame && nextFrame) {
                        // Interpolate
                        const duration = nextFrame.t - currentFrame.t;
                        const progress = (playbackTime - currentFrame.t) / duration;
                        const clampedProgress = Math.max(0, Math.min(1, progress));

                        state.ghostMesh.position.set(
                            currentFrame.p[0] + (nextFrame.p[0] - currentFrame.p[0]) * clampedProgress,
                            currentFrame.p[1] + (nextFrame.p[1] - currentFrame.p[1]) * clampedProgress,
                            currentFrame.p[2] + (nextFrame.p[2] - currentFrame.p[2]) * clampedProgress
                        );
                        
                        // Rotation interpolation (shortest path)
                        let rotDiff = nextFrame.r - currentFrame.r;
                        if (rotDiff > Math.PI) rotDiff -= Math.PI * 2;
                        if (rotDiff < -Math.PI) rotDiff += Math.PI * 2;
                        state.ghostMesh.rotation.y = currentFrame.r + rotDiff * clampedProgress;

                        // Firing logic
                        if (currentFrame.f && Math.random() < 0.1) { // Chance to fire visual projectile
                            createGhostProjectile(state.ghostMesh.position, state.ghostMesh.rotation.y);
                        }
                    } else {
                        // End of playback
                        state.ghostMesh.visible = false;
                    }
                }
            },

            createMesh: () => {
                const group = new THREE.Group();
                
                // Holographic body
                const bodyGeom = new THREE.CapsuleGeometry(0.4, 1, 4, 8);
                const bodyMat = new THREE.MeshBasicMaterial({ 
                    color: 0x00ffff, 
                    transparent: true, 
                    opacity: 0.3,
                    wireframe: true
                });
                const body = new THREE.Mesh(bodyGeom, bodyMat);
                body.position.y = 0.9;
                group.add(body);

                // Head
                const headGeom = new THREE.BoxGeometry(0.5, 0.3, 0.4);
                const headMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true });
                const head = new THREE.Mesh(headGeom, headMat);
                head.position.y = 1.6;
                group.add(head);

                // Weapon
                const gunGeom = new THREE.BoxGeometry(0.1, 0.1, 0.6);
                const gun = new THREE.Mesh(gunGeom, headMat);
                gun.position.set(0.3, 1.4, -0.4);
                group.add(gun);

                scene.add(group);
                return group;
            }
        };

        function createGhostProjectile(position, rotationY) {
            const direction = new THREE.Vector3(0, 0, -1).applyAxisAngle(new THREE.Vector3(0, 1, 0), rotationY);
            const startPos = position.clone().add(new THREE.Vector3(0, 1.4, 0)).addScaledVector(direction, 0.5);
            
            // Visual only projectile
            const geom = new THREE.SphereGeometry(0.1);
            const mat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
            const mesh = new THREE.Mesh(geom, mat);
            mesh.position.copy(startPos);
            scene.add(mesh);
            
            state.projectiles.push({
                mesh: mesh,
                velocity: direction.multiplyScalar(40),
                damage: 10, // Ghost deals reduced damage
                color: 0x00ffff,
                isPlayer: true, // Hurts enemies
                lifetime: 2,
                origin: startPos
            });
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // STREAMER MODE SYSTEM
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        const ChatUsers = ['xX_Slayer_Xx', 'RetroGamer99', 'NeonNinja', 'PixelQueen', 'CyberPunk2077', 'GlitchMaster', 'SpeedRunner01', 'LootGoblin', 'NoScopeGod', 'CampingCarl'];
        const ChatMessages = ['PogChamp', 'LUL', 'Nice shot!', 'RIP', 'GG', 'HYPE', 'MonkaS', 'Kappa', 'Clip it!', 'What a play!'];
        
        const VoteModifiers = [
            { name: 'Low Gravity', duration: 15, apply: () => { state.gravity = 10; }, remove: () => { state.gravity = 40; } },
            { name: 'Double Damage', duration: 15, apply: () => { state.player.damage *= 2; }, remove: () => { state.player.damage /= 2; } },
            { name: 'Super Speed', duration: 15, apply: () => { state.player.speed *= 2; }, remove: () => { state.player.speed /= 2; } },
            { name: 'Tiny Enemies', duration: 20, apply: () => { state.enemies.forEach(e => e.mesh.scale.multiplyScalar(0.5)); }, remove: () => { state.enemies.forEach(e => e.mesh.scale.multiplyScalar(2)); } },
            { name: 'Spawn Boss', duration: 0, apply: () => { 
                const angle = Math.random() * Math.PI * 2;
                const pos = new THREE.Vector3(Math.cos(angle) * 30, 0, Math.sin(angle) * 30);
                createEnemy(EnemyTypes.BOSS, pos);
            }, remove: () => {} }
        ];

        // Initialize gravity in state
        state.gravity = 40;

        // Old Streamer Mode function removed (replaced by StreamerMode object)
        function updateStreamerMode(deltaTime) {
            // Deprecated
        }

        // Old helper functions removed (replaced by StreamerMode object)
        function addChatMessage() {}
        function addSystemMessage(text) { showToast(text); }
        function startVote() {}
        function updateVoteUI() {}


        // Old endVote removed
        function endVote() {}

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // THREE.JS SETUP
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        let scene, camera, renderer, composer;
        let clock = new THREE.Clock();

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // WEAPON VIEWMODEL SYSTEM (Halo-style)
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        let viewmodelScene, viewmodelCamera;
        let currentViewmodel = null;
        const viewmodelState = {
            bobTime: 0,
            bobAmount: 0,
            recoilOffset: new THREE.Vector3(),
            recoilRotation: new THREE.Euler(),
            recoilRecovery: 0.15,
            swayOffset: new THREE.Vector2(),
            targetSwayOffset: new THREE.Vector2(),
            isReloading: false,
            reloadProgress: 0,
            isSwitching: false,
            switchProgress: 0,
            basePosition: new THREE.Vector3(0.25, -0.2, -0.5),
            baseRotation: new THREE.Euler(0, 0, 0)
        };

        // Weapon viewmodel definitions (Halo-style designs)
        const WeaponViewmodels = {
            'PLASMA RIFLE': {
                build: () => {
                    const group = new THREE.Group();

                    // Main body - angular plasma rifle
                    const bodyGeom = new THREE.BoxGeometry(0.08, 0.12, 0.45);
                    const bodyMat = new THREE.MeshStandardMaterial({
                        color: 0x2244aa, metalness: 0.7, roughness: 0.3
                    });
                    const body = new THREE.Mesh(bodyGeom, bodyMat);
                    group.add(body);

                    // Top housing
                    const topGeom = new THREE.BoxGeometry(0.06, 0.04, 0.35);
                    const topMat = new THREE.MeshStandardMaterial({
                        color: 0x1133aa, metalness: 0.8, roughness: 0.2
                    });
                    const top = new THREE.Mesh(topGeom, topMat);
                    top.position.set(0, 0.08, -0.02);
                    group.add(top);

                    // Barrel shroud
                    const barrelGeom = new THREE.CylinderGeometry(0.025, 0.03, 0.2, 8);
                    const barrelMat = new THREE.MeshStandardMaterial({
                        color: 0x00ffff, metalness: 0.9, roughness: 0.1,
                        emissive: 0x00ffff, emissiveIntensity: 0.3
                    });
                    const barrel = new THREE.Mesh(barrelGeom, barrelMat);
                    barrel.rotation.x = Math.PI / 2;
                    barrel.position.set(0, 0, -0.32);
                    group.add(barrel);

                    // Energy coils (side detail)
                    for (let side of [-1, 1]) {
                        const coilGeom = new THREE.TorusGeometry(0.015, 0.005, 8, 16);
                        const coilMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
                        for (let i = 0; i < 3; i++) {
                            const coil = new THREE.Mesh(coilGeom, coilMat);
                            coil.position.set(side * 0.05, 0, -0.1 - i * 0.08);
                            coil.rotation.y = Math.PI / 2;
                            group.add(coil);
                        }
                    }

                    // Handle/grip
                    const gripGeom = new THREE.BoxGeometry(0.04, 0.1, 0.06);
                    const gripMat = new THREE.MeshStandardMaterial({
                        color: 0x333344, metalness: 0.3, roughness: 0.8
                    });
                    const grip = new THREE.Mesh(gripGeom, gripMat);
                    grip.position.set(0, -0.1, 0.08);
                    grip.rotation.x = -0.2;
                    group.add(grip);

                    // Ammo display
                    const displayGeom = new THREE.PlaneGeometry(0.03, 0.015);
                    const displayMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
                    const display = new THREE.Mesh(displayGeom, displayMat);
                    display.position.set(0, 0.065, 0.1);
                    display.rotation.x = -0.5;
                    display.name = 'ammoDisplay';
                    group.add(display);

                    return group;
                },
                position: new THREE.Vector3(0.35, -0.28, -0.5),
                rotation: new THREE.Euler(0, 0.15, 0),
                scale: 0.8,
                recoilKick: 0.02,
                recoilRotation: 0.03
            },

            'SHOTGUN': {
                build: () => {
                    const group = new THREE.Group();

                    // Receiver
                    const receiverGeom = new THREE.BoxGeometry(0.06, 0.08, 0.25);
                    const metalMat = new THREE.MeshStandardMaterial({
                        color: 0x555555, metalness: 0.8, roughness: 0.3
                    });
                    const receiver = new THREE.Mesh(receiverGeom, metalMat);
                    group.add(receiver);

                    // Barrel
                    const barrelGeom = new THREE.CylinderGeometry(0.025, 0.025, 0.4, 12);
                    const barrel = new THREE.Mesh(barrelGeom, metalMat);
                    barrel.rotation.x = Math.PI / 2;
                    barrel.position.set(0, 0.02, -0.32);
                    group.add(barrel);

                    // Pump grip
                    const pumpGeom = new THREE.BoxGeometry(0.05, 0.05, 0.12);
                    const woodMat = new THREE.MeshStandardMaterial({
                        color: 0x8B4513, metalness: 0.1, roughness: 0.9
                    });
                    const pump = new THREE.Mesh(pumpGeom, woodMat);
                    pump.position.set(0, -0.02, -0.2);
                    pump.name = 'pump';
                    group.add(pump);

                    // Stock
                    const stockGeom = new THREE.BoxGeometry(0.05, 0.06, 0.2);
                    const stock = new THREE.Mesh(stockGeom, woodMat);
                    stock.position.set(0, -0.01, 0.22);
                    group.add(stock);

                    // Grip
                    const gripGeom = new THREE.BoxGeometry(0.04, 0.12, 0.05);
                    const grip = new THREE.Mesh(gripGeom, woodMat);
                    grip.position.set(0, -0.08, 0.05);
                    grip.rotation.x = 0.3;
                    group.add(grip);

                    // Shell ejection port
                    const portGeom = new THREE.BoxGeometry(0.02, 0.03, 0.06);
                    const port = new THREE.Mesh(portGeom, new THREE.MeshBasicMaterial({ color: 0x222222 }));
                    port.position.set(0.04, 0.02, 0);
                    group.add(port);

                    // Muzzle
                    const muzzleGeom = new THREE.RingGeometry(0.015, 0.025, 12);
                    const muzzleMat = new THREE.MeshBasicMaterial({ color: 0xffaa00, side: THREE.DoubleSide });
                    const muzzle = new THREE.Mesh(muzzleGeom, muzzleMat);
                    muzzle.position.set(0, 0.02, -0.52);
                    group.add(muzzle);

                    return group;
                },
                position: new THREE.Vector3(0.38, -0.32, -0.5),
                rotation: new THREE.Euler(0, 0.1, 0),
                scale: 0.85,
                recoilKick: 0.08,
                recoilRotation: 0.12
            },

            'RAILGUN': {
                build: () => {
                    const group = new THREE.Group();

                    // Main chassis
                    const chassisGeom = new THREE.BoxGeometry(0.1, 0.15, 0.6);
                    const chassisMat = new THREE.MeshStandardMaterial({
                        color: 0x333344, metalness: 0.9, roughness: 0.2
                    });
                    const chassis = new THREE.Mesh(chassisGeom, chassisMat);
                    group.add(chassis);

                    // Rail tracks (top and bottom)
                    for (let y of [-1, 1]) {
                        const railGeom = new THREE.BoxGeometry(0.015, 0.02, 0.65);
                        const railMat = new THREE.MeshStandardMaterial({
                            color: 0xff00ff, metalness: 1, roughness: 0,
                            emissive: 0xff00ff, emissiveIntensity: 0.5
                        });
                        const rail = new THREE.Mesh(railGeom, railMat);
                        rail.position.set(0, y * 0.08, -0.02);
                        group.add(rail);
                    }

                    // Capacitor banks (sides)
                    for (let x of [-1, 1]) {
                        const capGeom = new THREE.CylinderGeometry(0.025, 0.025, 0.15, 8);
                        const capMat = new THREE.MeshStandardMaterial({
                            color: 0x9900ff, metalness: 0.7, roughness: 0.3,
                            emissive: 0x9900ff, emissiveIntensity: 0.2
                        });
                        for (let i = 0; i < 2; i++) {
                            const cap = new THREE.Mesh(capGeom, capMat);
                            cap.position.set(x * 0.07, 0, -0.1 + i * 0.2);
                            cap.rotation.x = Math.PI / 2;
                            group.add(cap);
                        }
                    }

                    // Scope
                    const scopeGeom = new THREE.CylinderGeometry(0.02, 0.025, 0.12, 8);
                    const scopeMat = new THREE.MeshStandardMaterial({
                        color: 0x222233, metalness: 0.8, roughness: 0.3
                    });
                    const scope = new THREE.Mesh(scopeGeom, scopeMat);
                    scope.position.set(0, 0.1, 0.05);
                    scope.rotation.x = Math.PI / 2;
                    group.add(scope);

                    // Scope lens
                    const lensGeom = new THREE.CircleGeometry(0.018, 16);
                    const lensMat = new THREE.MeshBasicMaterial({ color: 0xff00ff });
                    const lens = new THREE.Mesh(lensGeom, lensMat);
                    lens.position.set(0, 0.1, -0.01);
                    group.add(lens);

                    // Handle
                    const gripGeom = new THREE.BoxGeometry(0.04, 0.12, 0.06);
                    const gripMat = new THREE.MeshStandardMaterial({
                        color: 0x222222, metalness: 0.3, roughness: 0.8
                    });
                    const grip = new THREE.Mesh(gripGeom, gripMat);
                    grip.position.set(0, -0.12, 0.15);
                    grip.rotation.x = -0.2;
                    group.add(grip);

                    return group;
                },
                position: new THREE.Vector3(0.32, -0.3, -0.55),
                rotation: new THREE.Euler(0, 0.12, 0),
                scale: 0.75,
                recoilKick: 0.1,
                recoilRotation: 0.08
            },

            'ROCKET LAUNCHER': {
                build: () => {
                    const group = new THREE.Group();

                    // Main tube
                    const tubeGeom = new THREE.CylinderGeometry(0.06, 0.06, 0.6, 12);
                    const tubeMat = new THREE.MeshStandardMaterial({
                        color: 0x445544, metalness: 0.6, roughness: 0.4
                    });
                    const tube = new THREE.Mesh(tubeGeom, tubeMat);
                    tube.rotation.x = Math.PI / 2;
                    group.add(tube);

                    // Front sight
                    const sightGeom = new THREE.BoxGeometry(0.01, 0.04, 0.02);
                    const sightMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
                    const frontSight = new THREE.Mesh(sightGeom, sightMat);
                    frontSight.position.set(0, 0.08, -0.25);
                    group.add(frontSight);

                    // Rear sight
                    const rearSightGeom = new THREE.BoxGeometry(0.04, 0.03, 0.02);
                    const rearSight = new THREE.Mesh(rearSightGeom, sightMat);
                    rearSight.position.set(0, 0.08, 0.1);
                    group.add(rearSight);

                    // Handle/grip
                    const gripGeom = new THREE.BoxGeometry(0.04, 0.15, 0.06);
                    const gripMat = new THREE.MeshStandardMaterial({
                        color: 0x333322, metalness: 0.2, roughness: 0.9
                    });
                    const grip = new THREE.Mesh(gripGeom, gripMat);
                    grip.position.set(0, -0.1, 0.05);
                    group.add(grip);

                    // Trigger guard
                    const guardGeom = new THREE.TorusGeometry(0.03, 0.008, 8, 12, Math.PI);
                    const guard = new THREE.Mesh(guardGeom, sightMat);
                    guard.position.set(0, -0.05, 0.02);
                    guard.rotation.x = Math.PI / 2;
                    group.add(guard);

                    // Exhaust vents (back)
                    for (let i = 0; i < 4; i++) {
                        const ventGeom = new THREE.BoxGeometry(0.02, 0.015, 0.01);
                        const vent = new THREE.Mesh(ventGeom, new THREE.MeshBasicMaterial({ color: 0x222222 }));
                        const angle = (i / 4) * Math.PI * 2;
                        vent.position.set(Math.cos(angle) * 0.05, Math.sin(angle) * 0.05, 0.3);
                        group.add(vent);
                    }

                    // Loaded rocket (visible tip)
                    const rocketGeom = new THREE.ConeGeometry(0.04, 0.1, 8);
                    const rocketMat = new THREE.MeshStandardMaterial({
                        color: 0xff4400, metalness: 0.6, roughness: 0.3,
                        emissive: 0xff2200, emissiveIntensity: 0.2
                    });
                    const rocket = new THREE.Mesh(rocketGeom, rocketMat);
                    rocket.position.set(0, 0, -0.35);
                    rocket.rotation.x = -Math.PI / 2;
                    rocket.name = 'rocket';
                    group.add(rocket);

                    return group;
                },
                position: new THREE.Vector3(0.4, -0.35, -0.45),
                rotation: new THREE.Euler(0, 0.15, 0.05),
                scale: 0.7,
                recoilKick: 0.15,
                recoilRotation: 0.1
            },

            'FRACTAL BLASTER': {
                build: () => {
                    const group = new THREE.Group();

                    // Core
                    const coreGeom = new THREE.SphereGeometry(0.08, 16, 16);
                    const coreMat = new THREE.MeshStandardMaterial({
                        color: 0x00ffff, metalness: 0.9, roughness: 0.1,
                        emissive: 0x00ffff, emissiveIntensity: 2.0
                    });
                    const core = new THREE.Mesh(coreGeom, coreMat);
                    group.add(core);

                    // Main Barrel
                    const barrelGeom = new THREE.BoxGeometry(0.05, 0.05, 0.4);
                    const barrelMat = new THREE.MeshStandardMaterial({
                        color: 0x333344, metalness: 0.8, roughness: 0.3
                    });
                    const barrel = new THREE.Mesh(barrelGeom, barrelMat);
                    barrel.position.set(0, 0, -0.25);
                    group.add(barrel);

                    // Split Barrels
                    const splitGeom = new THREE.BoxGeometry(0.03, 0.03, 0.25);
                    const splitMat = new THREE.MeshStandardMaterial({
                        color: 0x444455, metalness: 0.7, roughness: 0.4
                    });
                    
                    const split1 = new THREE.Mesh(splitGeom, splitMat);
                    split1.position.set(0.06, 0.06, -0.2);
                    split1.rotation.z = Math.PI / 4;
                    group.add(split1);

                    const split2 = new THREE.Mesh(splitGeom, splitMat);
                    split2.position.set(-0.06, -0.06, -0.2);
                    split2.rotation.z = Math.PI / 4;
                    group.add(split2);

                    // Grip
                    const gripGeom = new THREE.BoxGeometry(0.04, 0.12, 0.06);
                    const gripMat = new THREE.MeshStandardMaterial({
                        color: 0x222222, metalness: 0.2, roughness: 0.9
                    });
                    const grip = new THREE.Mesh(gripGeom, gripMat);
                    grip.position.set(0, -0.1, 0.05);
                    grip.rotation.x = 0.2;
                    group.add(grip);

                    return group;
                },
                position: new THREE.Vector3(0.35, -0.3, -0.5),
                rotation: new THREE.Euler(0, 0.1, 0),
                scale: 0.8,
                recoilKick: 0.05,
                recoilRotation: 0.05
            }
        };

        function initViewmodelSystem() {
            // Create separate scene for weapon viewmodel (renders on top)
            viewmodelScene = new THREE.Scene();

            // Viewmodel camera with narrower FOV for weapon
            viewmodelCamera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.01, 10);
            viewmodelCamera.position.set(0, 0, 0);

            // Lighting for viewmodel
            const vmAmbient = new THREE.AmbientLight(0xffffff, 0.6);
            viewmodelScene.add(vmAmbient);

            const vmLight = new THREE.DirectionalLight(0xffffff, 0.8);
            vmLight.position.set(1, 1, 1);
            viewmodelScene.add(vmLight);

            const vmRimLight = new THREE.DirectionalLight(0x00ffff, 0.3);
            vmRimLight.position.set(-1, 0.5, -1);
            viewmodelScene.add(vmRimLight);

            // Build initial weapon viewmodel
            switchViewmodel(state.weapons[state.currentWeapon].name);
        }

        function switchViewmodel(weaponName) {
            // Remove current viewmodel
            if (currentViewmodel) {
                viewmodelScene.remove(currentViewmodel);
            }

            // Get viewmodel definition
            const vmDef = WeaponViewmodels[weaponName];
            if (!vmDef) return;

            // Build new viewmodel
            currentViewmodel = vmDef.build();
            viewmodelState.basePosition.copy(vmDef.position);
            viewmodelState.baseRotation.copy(vmDef.rotation);

            // Apply scale if defined
            const scale = vmDef.scale || 1;
            currentViewmodel.scale.set(scale, scale, scale);

            // Position viewmodel
            currentViewmodel.position.copy(vmDef.position);
            currentViewmodel.rotation.copy(vmDef.rotation);

            viewmodelScene.add(currentViewmodel);

            // Start switch animation
            viewmodelState.isSwitching = true;
            viewmodelState.switchProgress = 0;
        }

        function updateViewmodel(deltaTime) {
            if (!currentViewmodel) return;

            const weapon = state.weapons[state.currentWeapon];
            const vmDef = WeaponViewmodels[weapon.name];
            if (!vmDef) return;

            // === WEAPON BOB (walking animation) ===
            const isMoving = state.input.moveForward || state.input.moveBackward ||
                            state.input.moveLeft || state.input.moveRight;

            if (isMoving && state.current === GameState.PLAYING) {
                viewmodelState.bobTime += deltaTime * 10;
                viewmodelState.bobAmount = Math.min(viewmodelState.bobAmount + deltaTime * 5, 1);
            } else {
                viewmodelState.bobAmount = Math.max(viewmodelState.bobAmount - deltaTime * 3, 0);
            }

            const bobX = Math.sin(viewmodelState.bobTime) * 0.008 * viewmodelState.bobAmount;
            const bobY = Math.abs(Math.cos(viewmodelState.bobTime * 2)) * 0.006 * viewmodelState.bobAmount;

            // === WEAPON SWAY (mouse movement) ===
            viewmodelState.targetSwayOffset.x = -mouseMovement.x * 0.0003;
            viewmodelState.targetSwayOffset.y = -mouseMovement.y * 0.0003;
            viewmodelState.swayOffset.x += (viewmodelState.targetSwayOffset.x - viewmodelState.swayOffset.x) * 0.1;
            viewmodelState.swayOffset.y += (viewmodelState.targetSwayOffset.y - viewmodelState.swayOffset.y) * 0.1;
            viewmodelState.swayOffset.x *= 0.95;
            viewmodelState.swayOffset.y *= 0.95;

            // === RECOIL RECOVERY ===
            viewmodelState.recoilOffset.multiplyScalar(1 - viewmodelState.recoilRecovery);
            viewmodelState.recoilRotation.x *= (1 - viewmodelState.recoilRecovery);
            viewmodelState.recoilRotation.y *= (1 - viewmodelState.recoilRecovery);

            // === RELOAD ANIMATION ===
            let reloadOffset = new THREE.Vector3();
            let reloadRotation = new THREE.Euler();

            if (state.isReloading) {
                const reloadPhase = (state.reloadTimer / weapon.reloadTime);
                // Phase 1: Lower weapon
                if (reloadPhase > 0.7) {
                    const t = (reloadPhase - 0.7) / 0.3;
                    reloadOffset.y = -0.15 * t;
                    reloadRotation.x = 0.5 * t;
                }
                // Phase 2: Hold low (mag change)
                else if (reloadPhase > 0.3) {
                    reloadOffset.y = -0.15;
                    reloadRotation.x = 0.5;
                }
                // Phase 3: Raise weapon
                else {
                    const t = reloadPhase / 0.3;
                    reloadOffset.y = -0.15 * t;
                    reloadRotation.x = 0.5 * t;
                }
            }

            // === WEAPON SWITCH ANIMATION ===
            let switchOffset = new THREE.Vector3();

            if (viewmodelState.isSwitching) {
                viewmodelState.switchProgress += deltaTime * 4;
                if (viewmodelState.switchProgress >= 1) {
                    viewmodelState.isSwitching = false;
                    viewmodelState.switchProgress = 1;
                }
                // Smooth ease-out for weapon raise
                const t = 1 - Math.pow(1 - viewmodelState.switchProgress, 3);
                switchOffset.y = -0.3 * (1 - t);
            }

            // === APPLY ALL TRANSFORMS ===
            currentViewmodel.position.copy(viewmodelState.basePosition);
            currentViewmodel.position.x += bobX + viewmodelState.swayOffset.x + viewmodelState.recoilOffset.x;
            currentViewmodel.position.y += bobY + viewmodelState.swayOffset.y + viewmodelState.recoilOffset.y + reloadOffset.y + switchOffset.y;
            currentViewmodel.position.z += viewmodelState.recoilOffset.z;

            currentViewmodel.rotation.set(
                viewmodelState.baseRotation.x + viewmodelState.recoilRotation.x + reloadRotation.x,
                viewmodelState.baseRotation.y + viewmodelState.recoilRotation.y,
                viewmodelState.baseRotation.z
            );
        }

        function applyViewmodelRecoil() {
            const weapon = state.weapons[state.currentWeapon];
            const vmDef = WeaponViewmodels[weapon.name];
            if (!vmDef) return;

            // Apply recoil kick
            viewmodelState.recoilOffset.z = vmDef.recoilKick;
            viewmodelState.recoilOffset.y = vmDef.recoilKick * 0.3;
            viewmodelState.recoilRotation.x = -vmDef.recoilRotation;
            viewmodelState.recoilRotation.y = (Math.random() - 0.5) * vmDef.recoilRotation * 0.3;
        }

        function renderViewmodel() {
            if (!viewmodelScene || !viewmodelCamera) return;

            // Disable auto-clear so we don't wipe the main scene
            renderer.autoClear = false;

            // Clear only depth buffer so viewmodel renders on top
            renderer.clearDepth();

            // Render viewmodel scene on top of main scene
            renderer.render(viewmodelScene, viewmodelCamera);

            // Re-enable auto-clear for next frame
            renderer.autoClear = true;
        }

        const canvas = document.getElementById('game-canvas');
        const minimapCanvas = document.getElementById('minimap-canvas');
        const minimapCtx = minimapCanvas.getContext('2d');

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // TEXTURE GENERATOR
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        const TextureGenerator = {
            createGridTexture: (color1, color2, size = 512, divisions = 8) => {
                const canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;
                const ctx = canvas.getContext('2d');

                // Background
                ctx.fillStyle = color1;
                ctx.fillRect(0, 0, size, size);

                // Grid lines
                ctx.strokeStyle = color2;
                ctx.lineWidth = 2;
                ctx.shadowBlur = 5;
                ctx.shadowColor = color2;

                const step = size / divisions;

                ctx.beginPath();
                for (let i = 0; i <= divisions; i++) {
                    const p = i * step;
                    ctx.moveTo(p, 0);
                    ctx.lineTo(p, size);
                    ctx.moveTo(0, p);
                    ctx.lineTo(size, p);
                }
                ctx.stroke();

                // Add some tech details
                ctx.fillStyle = color2;
                ctx.globalAlpha = 0.2;
                for(let i=0; i<divisions; i++) {
                    for(let j=0; j<divisions; j++) {
                        if (Math.random() > 0.7) {
                            ctx.fillRect(i*step + 5, j*step + 5, step - 10, step - 10);
                        }
                    }
                }

                const texture = new THREE.CanvasTexture(canvas);
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                return texture;
            }
        };

        function initThreeJS() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050510);
            scene.fog = new THREE.FogExp2(0x050510, 0.015);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.copy(state.player.position);

            renderer = new THREE.WebGLRenderer({
                canvas: canvas,
                antialias: true,
                powerPreference: 'high-performance'
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;

            composer = new EffectComposer(renderer);
            composer.addPass(new RenderPass(scene, camera));

            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                0.8, 0.4, 0.85
            );
            composer.addPass(bloomPass);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404060, 0.4);
            scene.add(ambientLight);

            const mainLight = new THREE.DirectionalLight(0xffffff, 1);
            mainLight.position.set(20, 40, 20);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.width = 2048;
            mainLight.shadow.mapSize.height = 2048;
            mainLight.shadow.camera.near = 1;
            mainLight.shadow.camera.far = 100;
            mainLight.shadow.camera.left = -60;
            mainLight.shadow.camera.right = 60;
            mainLight.shadow.camera.top = 60;
            mainLight.shadow.camera.bottom = -60;
            scene.add(mainLight);

            const rimLight1 = new THREE.DirectionalLight(0x00ffff, 0.5);
            rimLight1.position.set(-30, 20, -30);
            scene.add(rimLight1);

            const rimLight2 = new THREE.DirectionalLight(0xff00ff, 0.3);
            rimLight2.position.set(30, 15, -30);
            scene.add(rimLight2);

            createArena();

            minimapCanvas.width = 180;
            minimapCanvas.height = 180;

            window.addEventListener('resize', onResize);
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);

            // Update viewmodel camera
            if (viewmodelCamera) {
                viewmodelCamera.aspect = window.innerWidth / window.innerHeight;
                viewmodelCamera.updateProjectionMatrix();
            }
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // ARENA CREATION
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function createArena() {
            const groundGeometry = new THREE.CircleGeometry(state.arenaRadius, 64);
            const groundMaterial = new THREE.MeshStandardMaterial({
                color: 0x3a3a5e,
                metalness: 0.6,
                roughness: 0.5,
                emissive: 0x101020,
                emissiveIntensity: 0.3
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            const gridHelper = new THREE.GridHelper(state.arenaRadius * 2, 40, 0x00ffff88, 0x00ffff44);
            gridHelper.position.y = 0.01;
            scene.add(gridHelper);

            const wallGeometry = new THREE.CylinderGeometry(
                state.arenaRadius, state.arenaRadius, 20, 64, 1, true
            );
            const wallMaterial = new THREE.MeshStandardMaterial({
                color: 0x2a2a4a,
                metalness: 0.7,
                roughness: 0.3,
                side: THREE.BackSide,
                transparent: true,
                opacity: 0.9,
                emissive: 0x101030,
                emissiveIntensity: 0.2
            });
            const walls = new THREE.Mesh(wallGeometry, wallMaterial);
            walls.position.y = 10;
            walls.userData.isWall = true;
            scene.add(walls);

            const ringGeometry = new THREE.TorusGeometry(state.arenaRadius, 0.3, 8, 64);
            const ringMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.8
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.rotation.x = Math.PI / 2;
            ring.position.y = 0.1;
            scene.add(ring);

            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const x = Math.cos(angle) * (state.arenaRadius - 5);
                const z = Math.sin(angle) * (state.arenaRadius - 5);
                createPillar(x, z);
            }

            const platformGeometry = new THREE.CylinderGeometry(8, 8, 0.5, 32);
            const platformMaterial = new THREE.MeshStandardMaterial({
                color: 0x2a2a4e,
                metalness: 0.9,
                roughness: 0.3,
                emissive: 0x00ffff,
                emissiveIntensity: 0.1
            });
            const platform = new THREE.Mesh(platformGeometry, platformMaterial);
            platform.position.y = 0.25;
            platform.receiveShadow = true;
            scene.add(platform);

            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2 + Math.PI / 6;
                const radius = 20 + Math.random() * 10;
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                createCover(x, z);
            }
        }

        function updateNoclipVisuals() {
            scene.traverse((object) => {
                if (object.isMesh && (object.userData.isCover || object.userData.isPillar || object.userData.isWall)) {
                    if (state.noclip) {
                        if (!object.userData.originalOpacity) object.userData.originalOpacity = object.material.opacity;
                        if (!object.userData.originalTransparent) object.userData.originalTransparent = object.material.transparent;
                        
                        object.material.transparent = true;
                        object.material.opacity = 0.3;
                        object.material.wireframe = true;
                    } else {
                        object.material.opacity = object.userData.originalOpacity !== undefined ? object.userData.originalOpacity : 1;
                        object.material.transparent = object.userData.originalTransparent !== undefined ? object.userData.originalTransparent : false;
                        object.material.wireframe = false;
                    }
                }
            });
        }

        function createPillar(x, z) {
            const pillarGroup = new THREE.Group();

            const pillarGeometry = new THREE.CylinderGeometry(1.5, 2, 15, 8);
            const pillarMaterial = new THREE.MeshStandardMaterial({
                color: 0x4a4a7e,
                metalness: 0.7,
                roughness: 0.3,
                emissive: 0x101030,
                emissiveIntensity: 0.2
            });
            const pillar = new THREE.Mesh(pillarGeometry, pillarMaterial);
            pillar.position.y = 7.5;
            pillar.castShadow = true;
            pillar.userData.isPillar = true;
            pillar.userData.health = 200;
            pillar.userData.maxHealth = 200;
            pillar.userData.parentGroup = pillarGroup;
            state.destructibles.push(pillar);
            pillarGroup.add(pillar);

            const glowRing = new THREE.Mesh(
                new THREE.TorusGeometry(1.8, 0.2, 8, 16),
                new THREE.MeshBasicMaterial({ color: 0x00ffff })
            );
            glowRing.rotation.x = Math.PI / 2;
            glowRing.position.y = 12;
            pillarGroup.add(glowRing);

            const light = new THREE.PointLight(0x00ffff, 3, 25);
            light.position.y = 12;
            pillarGroup.add(light);

            pillarGroup.position.set(x, 0, z);
            scene.add(pillarGroup);
        }

        function createCover(x, z) {
            const coverGeometry = new THREE.BoxGeometry(
                2 + Math.random() * 2,
                2 + Math.random() * 2,
                2 + Math.random() * 2
            );
            const coverMaterial = new THREE.MeshStandardMaterial({
                color: 0x5a5a8e,
                metalness: 0.6,
                roughness: 0.4,
                emissive: 0x151525,
                emissiveIntensity: 0.2
            });
            const cover = new THREE.Mesh(coverGeometry, coverMaterial);
            cover.position.set(x, coverGeometry.parameters.height / 2, z);
            cover.rotation.y = Math.random() * Math.PI;
            cover.castShadow = true;
            cover.receiveShadow = true;
            cover.userData.isCover = true;
            cover.userData.health = 100;
            cover.userData.maxHealth = 100;
            state.destructibles.push(cover);
            scene.add(cover);
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // ENEMY SYSTEM
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        // Fallback enemy types (used if manifest fails to load)
        const FallbackEnemyTypes = {
            GRUNT: { name: 'Grunt', health: 50, damage: 10, speed: 6, score: 100, color: 0xff4444, size: 1, attackRange: 3, attackRate: 1 },
            RUSHER: { name: 'Rusher', health: 30, damage: 15, speed: 12, score: 150, color: 0xff8800, size: 0.8, attackRange: 2, attackRate: 0.5 },
            TANK: { name: 'Tank', health: 200, damage: 25, speed: 3, score: 300, color: 0x8844ff, size: 1.5, attackRange: 4, attackRate: 2 },
            SNIPER: { name: 'Sniper', health: 40, damage: 30, speed: 4, score: 200, color: 0x44ff44, size: 1, attackRange: 40, attackRate: 2.5, ranged: true },
            NINJA: { name: 'Cyber Ninja', health: 80, damage: 35, speed: 12, score: 150, color: 0x111111, size: 0.9, attackRange: 2, attackRate: 0.5 },
            BOSS: { name: 'OVERLORD', health: 1000, damage: 40, speed: 5, score: 2000, color: 0xff00ff, size: 3, attackRange: 6, attackRate: 1.5, isBoss: true },
            CYBER_WORM: { name: 'CYBER-WORM', health: 5000, damage: 40, speed: 8, score: 5000, color: 0xff00ff, size: 2, attackRange: 15, attackRate: 2, isBoss: true, isWorm: true },
            SENTINEL: { name: 'Quantum Sentinel', health: 300, damage: 40, speed: 8, score: 500, color: 0x00ffff, size: 2, attackRange: 20, attackRate: 2, ranged: true, model: 'quantum_sentinel' },
            CHRONOS: {
                name: 'Chronos Weaver',
                health: 300,
                damage: 25,
                speed: 3,
                score: 500,
                color: 0x9900ff,
                size: 2,
                attackRange: 15,
                attackRate: 2.0,
                ranged: true,
                modelData: {
                    scale: 1,
                    bodyParts: [
                        { name: "core", type: "sphere", radius: 0.8, color: 0x330066, position: [0, 2, 0] },
                        { name: "ring1", type: "torus", radius: 1.2, tube: 0.1, color: 0xaa00ff, position: [0, 2, 0], rotation: [1.57, 0, 0] },
                        { name: "ring2", type: "torus", radius: 1.6, tube: 0.1, color: 0xcc00ff, position: [0, 2, 0], rotation: [0, 1.57, 0] },
                        { name: "aura", type: "sphere", radius: 2.0, color: 0xaa00ff, opacity: 0.3, transparent: true, position: [0, 2, 0] }
                    ],
                    animations: {
                        idle: {
                            parts: {
                                core: { scale: { amplitude: 0.2, speed: 2 } },
                                ring1: { continuousRotation: { x: 1, y: 0.5 } },
                                ring2: { continuousRotation: { x: 0.5, y: 1 } },
                                aura: { opacity: { min: 0.1, max: 0.4, speed: 1 } }
                            }
                        }
                    }
                }
            }
        };

        // Maps manifest enemy keys to game enemy types
        const EnemyTypeMapping = {
            grunt: 'GRUNT',
            stalker: 'RUSHER',
            commander: 'SNIPER',
            tank: 'TANK',
            boss_warden: 'BOSS',
            cyber_ninja: 'NINJA',
            quantum_sentinel: 'SENTINEL',
            chronos_weaver: 'CHRONOS'
        };

        // Populated from manifest or fallback
        let EnemyTypes = { ...FallbackEnemyTypes };

        function initEnemyTypesFromManifest() {
            if (!gameAssets.loaded || !gameAssets.enemies) return;

            // Map manifest enemies to game enemy types
            for (const [manifestKey, gameKey] of Object.entries(EnemyTypeMapping)) {
                if (gameAssets.enemies[manifestKey]) {
                    const manifestEnemy = gameAssets.enemies[manifestKey];
                    const attackRange = manifestEnemy.attackRange || FallbackEnemyTypes[gameKey].attackRange;
                    EnemyTypes[gameKey] = {
                        name: manifestEnemy.modelData?.name || gameKey,
                        health: manifestEnemy.health || FallbackEnemyTypes[gameKey].health,
                        damage: manifestEnemy.damage || FallbackEnemyTypes[gameKey].damage,
                        speed: manifestEnemy.speed || FallbackEnemyTypes[gameKey].speed,
                        score: manifestEnemy.points || FallbackEnemyTypes[gameKey].score,
                        attackRange: attackRange,
                        attackRate: manifestEnemy.fireRate || FallbackEnemyTypes[gameKey].attackRate,
                        size: manifestEnemy.modelData?.scale || FallbackEnemyTypes[gameKey].size,
                        color: FallbackEnemyTypes[gameKey].color,
                        modelData: manifestEnemy.modelData,
                        ranged: attackRange >= 8, // Enemies with attackRange >= 8 shoot projectiles
                        isBoss: gameKey === 'BOSS',
                        shield: manifestEnemy.shield || 0
                    };
                    console.log(`[APEX] Configured ${gameKey} from manifest:`, EnemyTypes[gameKey].name);
                }
            }
        }

        function createFallbackEnemyMesh(config) {
            const group = new THREE.Group();
            const s = config.size;

            // Determine enemy archetype based on config properties
            const isRusher = config.speed >= 10;
            const isTank = config.health >= 150 && !config.isBoss;
            const isSniper = config.ranged;
            const isBoss = config.isBoss;

            // === BODY ===
            let bodyGeom, bodyHeight;
            if (isRusher) {
                // Sleek, angular body
                bodyGeom = new THREE.ConeGeometry(s * 0.5, s * 1.8, 6);
                bodyHeight = s * 0.9;
            } else if (isTank) {
                // Bulky, wide body
                bodyGeom = new THREE.BoxGeometry(s * 1.6, s * 1.8, s * 1.2);
                bodyHeight = s * 0.9;
            } else if (isSniper) {
                // Tall, thin body
                bodyGeom = new THREE.BoxGeometry(s * 0.8, s * 2.4, s * 0.5);
                bodyHeight = s * 1.2;
            } else {
                // Standard grunt body
                bodyGeom = new THREE.BoxGeometry(s * 1.2, s * 2, s * 0.8);
                bodyHeight = s;
            }

            const bodyMat = new THREE.MeshStandardMaterial({
                color: config.color,
                metalness: isTank ? 0.8 : 0.6,
                roughness: isTank ? 0.2 : 0.3,
                emissive: config.color,
                emissiveIntensity: 0.2
            });
            const body = new THREE.Mesh(bodyGeom, bodyMat);
            body.position.y = bodyHeight;
            body.castShadow = true;
            group.add(body);

            // Grunt Special: Backpack and Limbs
            if (!isRusher && !isTank && !isSniper && !isBoss) {
                // Backpack (Methane Tank)
                const packGeom = new THREE.ConeGeometry(s * 0.6, s * 1.2, 4);
                const packMat = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.5 });
                const pack = new THREE.Mesh(packGeom, packMat);
                pack.position.set(0, bodyHeight + s * 0.2, -s * 0.5);
                pack.rotation.x = -0.5;
                pack.rotation.y = Math.PI / 4;
                group.add(pack);

                // Limbs for animation
                group.userData.limbs = {};

                // Arms
                const armGeom = new THREE.CapsuleGeometry(s * 0.15, s * 0.6, 4, 8);
                const armMat = new THREE.MeshStandardMaterial({ color: config.color });
                
                const leftArm = new THREE.Mesh(armGeom, armMat);
                leftArm.position.set(-s * 0.7, bodyHeight + s * 0.5, 0);
                group.add(leftArm);
                group.userData.limbs.leftArm = leftArm;

                const rightArm = new THREE.Mesh(armGeom, armMat);
                rightArm.position.set(s * 0.7, bodyHeight + s * 0.5, 0);
                group.add(rightArm);
                group.userData.limbs.rightArm = rightArm;

                // Legs
                const legGeom = new THREE.CapsuleGeometry(s * 0.18, s * 0.7, 4, 8);
                const legMat = new THREE.MeshStandardMaterial({ color: 0x222222 });

                const leftLeg = new THREE.Mesh(legGeom, legMat);
                leftLeg.position.set(-s * 0.3, bodyHeight - s * 0.8, 0);
                group.add(leftLeg);
                group.userData.limbs.leftLeg = leftLeg;

                const rightLeg = new THREE.Mesh(legGeom, legMat);
                rightLeg.position.set(s * 0.3, bodyHeight - s * 0.8, 0);
                group.add(rightLeg);
                group.userData.limbs.rightLeg = rightLeg;
            }

            // === HEAD ===
            let headGeom;
            if (isRusher) {
                headGeom = new THREE.ConeGeometry(s * 0.3, s * 0.6, 4);
            } else if (isTank) {
                headGeom = new THREE.BoxGeometry(s * 0.6, s * 0.5, s * 0.6);
            } else if (isSniper) {
                headGeom = new THREE.CylinderGeometry(s * 0.25, s * 0.3, s * 0.5, 8);
            } else {
                headGeom = new THREE.SphereGeometry(s * 0.4, 16, 12);
            }

            const headMat = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                metalness: 0.9,
                roughness: 0.1,
                emissive: config.color,
                emissiveIntensity: 0.5
            });
            const head = new THREE.Mesh(headGeom, headMat);
            head.position.y = bodyHeight + s * 1.2;
            if (isRusher) head.rotation.x = Math.PI; // Point cone forward
            group.add(head);

            // === EYES ===
            const eyeGeom = new THREE.SphereGeometry(s * 0.12, 8, 6);
            const eyeColor = isSniper ? 0x00ff00 : isRusher ? 0xffaa00 : 0xff0000;
            const eyeMat = new THREE.MeshBasicMaterial({ color: eyeColor });

            if (!isRusher) { // Rushers have single visor
                const leftEye = new THREE.Mesh(eyeGeom, eyeMat);
                leftEye.position.set(-s * 0.15, bodyHeight + s * 1.25, s * 0.3);
                group.add(leftEye);

                const rightEye = new THREE.Mesh(eyeGeom, eyeMat);
                rightEye.position.set(s * 0.15, bodyHeight + s * 1.25, s * 0.3);
                group.add(rightEye);
            } else {
                // Rusher visor
                const visorGeom = new THREE.BoxGeometry(s * 0.4, s * 0.08, s * 0.1);
                const visorMat = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
                const visor = new THREE.Mesh(visorGeom, visorMat);
                visor.position.set(0, bodyHeight + s * 1.1, s * 0.25);
                group.add(visor);
            }

            // === LEGS ===
            const legHeight = isRusher ? s * 1.0 : s * 0.8;
            const legWidth = isTank ? s * 0.4 : s * 0.3;
            const legGeom = new THREE.BoxGeometry(legWidth, legHeight, legWidth);
            const legMat = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.8, roughness: 0.2 });

            const leftLeg = new THREE.Mesh(legGeom, legMat);
            leftLeg.position.set(-s * 0.35, -legHeight * 0.5, 0);
            group.add(leftLeg);

            const rightLeg = new THREE.Mesh(legGeom, legMat);
            rightLeg.position.set(s * 0.35, -legHeight * 0.5, 0);
            group.add(rightLeg);

            // === TYPE-SPECIFIC FEATURES ===

            // RUSHER: Blade arms
            if (isRusher) {
                for (let side of [-1, 1]) {
                    const bladeGeom = new THREE.BoxGeometry(s * 0.1, s * 1.2, s * 0.05);
                    const bladeMat = new THREE.MeshStandardMaterial({
                        color: 0xffaa00, emissive: 0xff6600, emissiveIntensity: 0.5
                    });
                    const blade = new THREE.Mesh(bladeGeom, bladeMat);
                    blade.position.set(side * s * 0.6, bodyHeight * 0.5, s * 0.2);
                    blade.rotation.z = side * 0.3;
                    group.add(blade);
                }
            }

            // TANK: Shoulder armor and cannon
            if (isTank) {
                for (let side of [-1, 1]) {
                    const shoulderGeom = new THREE.BoxGeometry(s * 0.8, s * 0.5, s * 0.6);
                    const shoulderMat = new THREE.MeshStandardMaterial({
                        color: 0x555577, metalness: 0.9, roughness: 0.2
                    });
                    const shoulder = new THREE.Mesh(shoulderGeom, shoulderMat);
                    shoulder.position.set(side * s * 0.9, bodyHeight + s * 0.5, 0);
                    group.add(shoulder);
                }

                // Back cannon
                const cannonGeom = new THREE.CylinderGeometry(s * 0.2, s * 0.25, s * 1.0, 8);
                const cannonMat = new THREE.MeshStandardMaterial({ color: 0x444466, metalness: 0.9, roughness: 0.2 });
                const cannon = new THREE.Mesh(cannonGeom, cannonMat);
                cannon.position.set(0, bodyHeight + s * 0.8, -s * 0.4);
                cannon.rotation.x = Math.PI / 4;
                group.add(cannon);
            }

            // SNIPER: Scope visor and antenna
            if (isSniper) {
                // Scope visor
                const scopeGeom = new THREE.BoxGeometry(s * 0.5, s * 0.15, s * 0.1);
                const scopeMat = new THREE.MeshStandardMaterial({
                    color: 0x00ff44, emissive: 0x00ff44, emissiveIntensity: 0.8
                });
                const scope = new THREE.Mesh(scopeGeom, scopeMat);
                scope.position.set(0, bodyHeight + s * 1.4, s * 0.25);
                group.add(scope);

                // Antenna
                const antennaGeom = new THREE.CylinderGeometry(s * 0.03, s * 0.03, s * 0.6, 6);
                const antennaMat = new THREE.MeshStandardMaterial({ color: 0x44ff44 });
                const antenna = new THREE.Mesh(antennaGeom, antennaMat);
                antenna.position.set(s * 0.2, bodyHeight + s * 1.6, 0);
                group.add(antenna);

                // Rifle
                const rifleGeom = new THREE.BoxGeometry(s * 0.1, s * 0.1, s * 1.5);
                const rifleMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
                const rifle = new THREE.Mesh(rifleGeom, rifleMat);
                rifle.position.set(s * 0.5, bodyHeight * 0.7, s * 0.5);
                group.add(rifle);
            }

            // BOSS: Horns, shoulders, and aura
            if (isBoss && !config.isWorm) {
                for (let i = 0; i < 3; i++) {
                    const hornGeom = new THREE.ConeGeometry(0.3, 1.5, 4);
                    const hornMat = new THREE.MeshStandardMaterial({
                        color: 0xffaa00, emissive: 0xffaa00, emissiveIntensity: 0.5
                    });
                    const horn = new THREE.Mesh(hornGeom, hornMat);
                    horn.position.set((i - 1) * 0.8, bodyHeight + s * 1.6, 0);
                    group.add(horn);
                }

                for (let side of [-1, 1]) {
                    const shoulderGeom = new THREE.BoxGeometry(1.5, 0.8, 1);
                    const shoulderMat = new THREE.MeshStandardMaterial({
                        color: 0x666666, metalness: 0.9, roughness: 0.2
                    });
                    const shoulder = new THREE.Mesh(shoulderGeom, shoulderMat);
                    shoulder.position.set(side * 1.5, bodyHeight + s * 0.8, 0);
                    group.add(shoulder);
                }

                // Energy aura (transparent sphere)
                const auraGeom = new THREE.SphereGeometry(s * 2.5, 16, 12);
                const auraMat = new THREE.MeshStandardMaterial({
                    color: config.color,
                    emissive: config.color,
                    emissiveIntensity: 0.3,
                    transparent: true,
                    opacity: 0.15
                });
                const aura = new THREE.Mesh(auraGeom, auraMat);
                aura.position.y = bodyHeight;
                group.add(aura);
            }

            // CYBER-WORM: Segmented body
            if (config.isWorm) {
                // Clear previous geometry
                group.clear();
                
                // Head segment
                const headGeom = new THREE.SphereGeometry(s * 0.8, 16, 16);
                const headMat = new THREE.MeshStandardMaterial({
                    color: 0xff00ff, metalness: 0.8, roughness: 0.2,
                    emissive: 0xff00ff, emissiveIntensity: 0.5
                });
                const head = new THREE.Mesh(headGeom, headMat);
                group.add(head);

                // Eyes
                const eyeGeom = new THREE.SphereGeometry(s * 0.2, 8, 8);
                const eyeMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
                
                const leftEye = new THREE.Mesh(eyeGeom, eyeMat);
                leftEye.position.set(-s * 0.3, s * 0.3, s * 0.6);
                group.add(leftEye);
                
                const rightEye = new THREE.Mesh(eyeGeom, eyeMat);
                rightEye.position.set(s * 0.3, s * 0.3, s * 0.6);
                group.add(rightEye);

                // Mandibles
                const mandibleGeom = new THREE.ConeGeometry(s * 0.15, s * 0.8, 8);
                const mandibleMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.9 });
                
                const leftMandible = new THREE.Mesh(mandibleGeom, mandibleMat);
                leftMandible.position.set(-s * 0.4, -s * 0.3, s * 0.7);
                leftMandible.rotation.x = Math.PI / 2;
                leftMandible.rotation.z = -0.5;
                group.add(leftMandible);

                const rightMandible = new THREE.Mesh(mandibleGeom, mandibleMat);
                rightMandible.position.set(s * 0.4, -s * 0.3, s * 0.7);
                rightMandible.rotation.x = Math.PI / 2;
                rightMandible.rotation.z = 0.5;
                group.add(rightMandible);

                // Body segments will be handled in update loop
                group.userData.segments = [];
                for(let i=0; i<10; i++) {
                    const segGeom = new THREE.SphereGeometry(s * (0.7 - i*0.04), 12, 12);
                    const segMat = new THREE.MeshStandardMaterial({
                        color: i % 2 === 0 ? 0xaa00aa : 0x440044,
                        metalness: 0.7, roughness: 0.3
                    });
                    const segment = new THREE.Mesh(segGeom, segMat);
                    segment.position.set(0, 0, -s * (i+1));
                    scene.add(segment); // Add to scene, not group, for independent movement
                    group.userData.segments.push(segment);
                }
            }

            group.userData.parts = {};
            group.userData.partOriginals = {};
            group.userData.animations = {};

            return group;
        }

        function createEnemy(type, position) {
            const config = type;
            let group;

            // Use manifest model data if available, otherwise fallback
            if (config.modelData && config.modelData.bodyParts) {
                group = buildEnemyFromModelData(config.modelData, 1);
            } else {
                group = createFallbackEnemyMesh(config);
            }

            group.position.copy(position);
            scene.add(group);

            const enemy = {
                mesh: group,
                type: config,
                health: config.health,
                maxHealth: config.health,
                shield: config.shield || 0,
                maxShield: config.shield || 0,
                lastAttack: 0,
                velocity: new THREE.Vector3(),
                targetPosition: new THREE.Vector3(),
                state: 'chase',
                stateTimer: 0,
                // Animation state
                animState: 'idle',
                animTime: Math.random() * Math.PI * 2, // Randomize start phase
                attackAnimTime: 0,
                isAttacking: false,
                walkCycle: 0,
                // Store animation config from modelData
                animConfig: config.modelData?.animations || {
                    idle: { sway: true, swaySpeed: 2.0, swayAmount: 0.05 },
                    walk: { bob: true, bobSpeed: 4.0, bobAmount: 0.1, legSwing: true },
                    attack: { recoil: true, duration: 0.3 }
                }
            };

            state.enemies.push(enemy);
            return enemy;
        }

        // Squad compositions for diverse gameplay
        const SquadTemplates = {
            // Basic squads (wave 1+)
            grunt_patrol: { enemies: ['GRUNT', 'GRUNT', 'GRUNT'], pattern: 'line' },
            grunt_squad: { enemies: ['GRUNT', 'GRUNT', 'GRUNT', 'GRUNT'], pattern: 'cluster' },

            // Mixed squads (wave 2+)
            assault_team: { enemies: ['GRUNT', 'GRUNT', 'RUSHER'], pattern: 'wedge' },
            flankers: { enemies: ['RUSHER', 'RUSHER'], pattern: 'pincer' },
            hunter_pack: { enemies: ['RUSHER', 'RUSHER', 'RUSHER'], pattern: 'surround' },

            // Tactical squads (wave 3+)
            fire_team: { enemies: ['GRUNT', 'GRUNT', 'SNIPER'], pattern: 'line' },
            sniper_pair: { enemies: ['SNIPER', 'SNIPER'], pattern: 'flanking' },
            heavy_support: { enemies: ['GRUNT', 'GRUNT', 'TANK'], pattern: 'wedge' },

            // Elite squads (wave 5+)
            elite_squad: { enemies: ['SNIPER', 'RUSHER', 'RUSHER'], pattern: 'surround' },
            armored_assault: { enemies: ['TANK', 'GRUNT', 'GRUNT', 'GRUNT'], pattern: 'wedge' },
            death_squad: { enemies: ['TANK', 'SNIPER', 'RUSHER'], pattern: 'triangle' },

            // Heavy squads (wave 7+)
            tank_column: { enemies: ['TANK', 'TANK'], pattern: 'line' },
            combined_arms: { enemies: ['TANK', 'SNIPER', 'RUSHER', 'GRUNT', 'GRUNT'], pattern: 'cluster' },
            shock_troops: { enemies: ['RUSHER', 'RUSHER', 'RUSHER', 'RUSHER'], pattern: 'surround' },

            // Boss support (boss waves)
            boss_guard: { enemies: ['SNIPER', 'SNIPER', 'TANK'], pattern: 'triangle' },
            elite_guard: { enemies: ['RUSHER', 'RUSHER', 'SNIPER', 'SNIPER'], pattern: 'surround' },

            // Ninja squads (wave 6+)
            ninja_squad: { enemies: ['NINJA', 'NINJA', 'NINJA'], pattern: 'triangle' },
            stealth_ops: { enemies: ['NINJA', 'RUSHER', 'NINJA'], pattern: 'pincer' },
            
            // Sentinel squads (wave 8+)
            sentinel_patrol: { enemies: ['SENTINEL', 'GRUNT', 'GRUNT'], pattern: 'wedge' },
            quantum_strike: { enemies: ['SENTINEL', 'SENTINEL'], pattern: 'flanking' },

            // Chronos squads (wave 9+)
            time_weavers: { enemies: ['CHRONOS', 'CHRONOS'], pattern: 'pincer' },
            chronos_guard: { enemies: ['CHRONOS', 'SENTINEL', 'TANK'], pattern: 'triangle' }
        };

        function getAvailableSquads(waveNumber) {
            // Wave 1: Mix of grunts with some rushers for immediate variety
            const squads = ['grunt_patrol', 'grunt_squad', 'assault_team', 'flankers'];

            if (waveNumber >= 2) {
                squads.push('hunter_pack', 'fire_team');
            }
            if (waveNumber >= 3) {
                squads.push('sniper_pair', 'heavy_support');
            }
            if (waveNumber >= 4) {
                squads.push('elite_squad', 'armored_assault');
            }
            if (waveNumber >= 5) {
                squads.push('death_squad', 'tank_column');
            }
            if (waveNumber >= 6) {
                squads.push('ninja_squad', 'stealth_ops');
            }
            if (waveNumber >= 8) {
                squads.push('sentinel_patrol', 'quantum_strike');
            }
            if (waveNumber >= 6) {
                squads.push('combined_arms', 'shock_troops');
            }

            if (waveNumber >= 9) {
                squads.push('time_weavers', 'chronos_guard');
            }

            return squads;
        }

        function spawnSquad(squadName, centerAngle, baseRadius, waveNumber, delay) {
            const squad = SquadTemplates[squadName];
            if (!squad) return;

            const enemies = squad.enemies;
            const pattern = squad.pattern;

            enemies.forEach((enemyKey, index) => {
                setTimeout(() => {
                    let pos;
                    const radius = baseRadius + Math.random() * 8;

                    switch (pattern) {
                        case 'line':
                            // Enemies in a line perpendicular to player
                            const lineOffset = (index - (enemies.length - 1) / 2) * 4;
                            const perpAngle = centerAngle + Math.PI / 2;
                            pos = new THREE.Vector3(
                                Math.cos(centerAngle) * radius + Math.cos(perpAngle) * lineOffset,
                                0,
                                Math.sin(centerAngle) * radius + Math.sin(perpAngle) * lineOffset
                            );
                            break;

                        case 'wedge':
                            // V-formation pointing at player
                            const wedgeAngle = centerAngle + (index - (enemies.length - 1) / 2) * 0.3;
                            const wedgeRadius = radius - index * 2;
                            pos = new THREE.Vector3(
                                Math.cos(wedgeAngle) * wedgeRadius,
                                0,
                                Math.sin(wedgeAngle) * wedgeRadius
                            );
                            break;

                        case 'cluster':
                            // Tight group
                            const clusterOffset = index * 0.15;
                            pos = new THREE.Vector3(
                                Math.cos(centerAngle + clusterOffset) * (radius + Math.random() * 3),
                                0,
                                Math.sin(centerAngle + clusterOffset) * (radius + Math.random() * 3)
                            );
                            break;

                        case 'surround':
                            // Spread around the arena
                            const surroundAngle = centerAngle + (index / enemies.length) * Math.PI * 2;
                            pos = new THREE.Vector3(
                                Math.cos(surroundAngle) * radius,
                                0,
                                Math.sin(surroundAngle) * radius
                            );
                            break;

                        case 'pincer':
                            // Two groups from opposite sides
                            const pincerSide = index % 2 === 0 ? -1 : 1;
                            const pincerAngle = centerAngle + pincerSide * Math.PI / 3;
                            pos = new THREE.Vector3(
                                Math.cos(pincerAngle) * radius,
                                0,
                                Math.sin(pincerAngle) * radius
                            );
                            break;

                        case 'flanking':
                            // Wide flanking positions
                            const flankAngle = centerAngle + (index === 0 ? -1 : 1) * Math.PI / 2;
                            pos = new THREE.Vector3(
                                Math.cos(flankAngle) * radius,
                                0,
                                Math.sin(flankAngle) * radius
                            );
                            break;

                        case 'triangle':
                            // Triangle formation
                            const triAngle = centerAngle + (index / 3) * Math.PI * 2;
                            pos = new THREE.Vector3(
                                Math.cos(triAngle) * radius,
                                0,
                                Math.sin(triAngle) * radius
                            );
                            break;

                        default:
                            pos = new THREE.Vector3(
                                Math.cos(centerAngle) * radius,
                                0,
                                Math.sin(centerAngle) * radius
                            );
                    }

                    const type = EnemyTypes[enemyKey] || EnemyTypes.GRUNT;
                    const scaledType = { ...type };
                    scaledType.health = type.health * (1 + waveNumber * 0.1);
                    scaledType.damage = type.damage * (1 + waveNumber * 0.05);

                    // Preserve modelData for JSON-based enemies
                    if (type.modelData) {
                        scaledType.modelData = type.modelData;
                    }

                    createEnemy(scaledType, pos);
                }, delay + index * 200);
            });
        }

        function spawnWave(waveNumber) {
            const isBossWave = waveNumber % 5 === 0;

            // Determine number of squads based on wave
            const baseSquads = Math.min(2 + Math.floor(waveNumber / 2), 6);
            const numSquads = isBossWave ? Math.ceil(baseSquads / 2) : baseSquads;

            // Get available squad types for this wave
            const availableSquads = getAvailableSquads(waveNumber);

            // Spawn squads at different angles around the arena
            for (let i = 0; i < numSquads; i++) {
                const angle = (i / numSquads) * Math.PI * 2 + Math.random() * 0.5;
                const squadName = availableSquads[Math.floor(Math.random() * availableSquads.length)];
                const delay = i * 800; // Stagger squad spawns

                spawnSquad(squadName, angle, 35, waveNumber, delay);
            }

            // Boss wave - spawn boss after squads with elite guard
            if (isBossWave) {
                showBossWarning();
                setTimeout(() => {
                    const bossAngle = Math.random() * Math.PI * 2;
                    const bossPos = new THREE.Vector3(
                        Math.cos(bossAngle) * 30,
                        0,
                        Math.sin(bossAngle) * 30
                    );

                    let bossType;
                    if (waveNumber === 10) {
                        bossType = { ...EnemyTypes.CYBER_WORM };
                    } else {
                        bossType = { ...EnemyTypes.BOSS };
                        bossType.health = EnemyTypes.BOSS.health * (1 + (waveNumber / 5 - 1) * 0.5);
                        if (EnemyTypes.BOSS.modelData) {
                            bossType.modelData = EnemyTypes.BOSS.modelData;
                        }
                    }

                    createEnemy(bossType, bossPos);

                    // Spawn elite guard around boss
                    setTimeout(() => {
                        spawnSquad('elite_guard', bossAngle + Math.PI, 38, waveNumber, 0);
                    }, 1000);
                }, 2500);
            }

            // Every 3rd wave, add a surprise flanking squad
            if (waveNumber >= 3 && waveNumber % 3 === 0 && !isBossWave) {
                setTimeout(() => {
                    const flankAngle = Math.random() * Math.PI * 2;
                    const flankSquads = ['flankers', 'hunter_pack', 'shock_troops'];
                    const validSquads = flankSquads.filter(s => availableSquads.includes(s));
                    if (validSquads.length > 0) {
                        const squadName = validSquads[Math.floor(Math.random() * validSquads.length)];
                        spawnSquad(squadName, flankAngle, 40, waveNumber, 0);
                    }
                }, 5000); // Surprise reinforcements mid-wave
            }

            showWaveAnnouncement(waveNumber);
            updateEnemyCount();
        }

        function updateEnemies(deltaTime) {
            for (let i = state.enemies.length - 1; i >= 0; i--) {
                const enemy = state.enemies[i];

                const dirToPlayer = new THREE.Vector3()
                    .subVectors(state.player.position, enemy.mesh.position)
                    .setY(0).normalize();

                const distToPlayer = enemy.mesh.position.distanceTo(state.player.position);

                if (enemy.type.ranged) {
                    if (distToPlayer < 15) {
                        enemy.velocity.copy(dirToPlayer).multiplyScalar(-enemy.type.speed);
                    } else if (distToPlayer > 25) {
                        enemy.velocity.copy(dirToPlayer).multiplyScalar(enemy.type.speed);
                    } else {
                        const strafeDir = new THREE.Vector3(-dirToPlayer.z, 0, dirToPlayer.x);
                        enemy.velocity.copy(strafeDir).multiplyScalar(enemy.type.speed * 0.5);
                    }
                } else {
                    if (distToPlayer > enemy.type.attackRange) {
                        enemy.velocity.copy(dirToPlayer).multiplyScalar(enemy.type.speed);
                    } else {
                        enemy.velocity.multiplyScalar(0.9);
                    }
                }

                enemy.mesh.position.addScaledVector(enemy.velocity, deltaTime);

                if (!state.noclip) {
                    const distFromCenter = Math.sqrt(enemy.mesh.position.x ** 2 + enemy.mesh.position.z ** 2);
                    if (distFromCenter > state.arenaRadius - 3) {
                        const pushBack = enemy.mesh.position.clone().normalize().multiplyScalar(-1);
                        enemy.mesh.position.addScaledVector(pushBack, deltaTime * 10);
                    }
                }

                enemy.mesh.lookAt(state.player.position.x, enemy.mesh.position.y, state.player.position.z);

                // Animation Logic
                if (enemy.mesh.userData.limbs) {
                    const limbs = enemy.mesh.userData.limbs;
                    const isMoving = enemy.velocity.lengthSq() > 0.1;
                    
                    if (isMoving) {
                        // Waddle animation
                        const speed = 10;
                        const time = state.time * speed;
                        
                        // Leg swing
                        const legSwing = Math.sin(time) * 0.6;
                        if (limbs.leftLeg) limbs.leftLeg.rotation.x = legSwing;
                        if (limbs.rightLeg) limbs.rightLeg.rotation.x = -legSwing;
                        
                        // Arm swing
                        const armSwing = Math.cos(time) * 0.5;
                        if (limbs.leftArm) limbs.leftArm.rotation.x = armSwing;
                        if (limbs.rightArm) limbs.rightArm.rotation.x = -armSwing;
                        
                        // Body bob and tilt
                        const bobAmount = 0.15;
                        enemy.mesh.position.y = bobAmount + Math.abs(Math.sin(time * 2)) * bobAmount;
                        enemy.mesh.rotation.z = Math.sin(time) * 0.1;
                    } else {
                        // Reset limbs
                        const lerpFactor = deltaTime * 10;
                        if (limbs.leftLeg) limbs.leftLeg.rotation.x *= (1 - lerpFactor * 0.1);
                        if (limbs.rightLeg) limbs.rightLeg.rotation.x *= (1 - lerpFactor * 0.1);
                        if (limbs.leftArm) limbs.leftArm.rotation.x *= (1 - lerpFactor * 0.1);
                        if (limbs.rightArm) limbs.rightArm.rotation.x *= (1 - lerpFactor * 0.1);
                        enemy.mesh.rotation.z *= (1 - lerpFactor * 0.1);
                    }
                } else {
                    // Fallback bobbing for non-animated enemies
                    const bobAmount = Math.sin(state.time * 5 + i) * 0.1;
                    enemy.mesh.position.y = bobAmount;
                }

                if (distToPlayer <= enemy.type.attackRange) {
                    if (state.time - enemy.lastAttack > enemy.type.attackRate) {
                        attackPlayer(enemy);
                        enemy.lastAttack = state.time;
                    }
                }
            }
        }

        function attackPlayer(enemy) {
            if (enemy.type.ranged) {
                const dir = new THREE.Vector3().subVectors(state.player.position, enemy.mesh.position).normalize();
                createEnemyProjectile(enemy.mesh.position.clone().add(new THREE.Vector3(0, 1.5, 0)), dir, enemy.type.damage, enemy.type.color);
            } else {
                damagePlayer(enemy.type.damage);
            }
        }

        function damageEnemy(enemy, damage, isCrit = false) {
            enemy.health -= damage;

            enemy.mesh.children.forEach(child => {
                if (child.material) {
                    child.material.emissiveIntensity = 1;
                    setTimeout(() => { if (child.material) child.material.emissiveIntensity = 0.2; }, 100);
                }
            });

            createDamageNumber(enemy.mesh.position.clone().add(new THREE.Vector3(0, 2, 0)), damage, isCrit);

            if (isCrit) state.screenShake = 0.3;

            if (enemy.health <= 0) killEnemy(enemy);
        }

        function killEnemy(enemy) {
            const comboMultiplier = 1 + state.combo * 0.1;
            const score = Math.floor(enemy.type.score * comboMultiplier);
            state.score += score;
            state.combo++;
            state.comboTimer = 3;

            // Health on kill - scales with enemy difficulty
            const healAmount = Math.ceil(enemy.type.score / 25);
            const actualHeal = Math.min(healAmount, state.player.maxHealth - state.player.health);
            if (actualHeal > 0) {
                state.player.health += actualHeal;
                updateHealth();
                const healPos = state.player.position.clone().add(new THREE.Vector3(0, 2.5, 0));
                createHealNumber(healPos, actualHeal);
            }

            updateScore();
            updateCombo();
            addKillFeed(enemy.type.name, score);
            createExplosion(enemy.mesh.position.clone(), enemy.type.color, enemy.type.size);

            // Weapon Drop Logic
            if (enemy.type.isBoss || (enemy.type.name === 'Cyber Ninja' && Math.random() < 0.3)) {
                const dropType = Math.random() < 0.5 ? 'FRACTAL BLASTER' : 'PLASMA SWORD';
                // Check if player already has it
                const hasWeapon = state.weapons.some(w => w.name === dropType);
                if (!hasWeapon) {
                    createPickup(enemy.mesh.position.clone(), 'weapon', dropType);
                } else {
                    createPickup(enemy.mesh.position.clone());
                }
            } else {
                if (Math.random() < 0.3) createPickup(enemy.mesh.position.clone());
            }

            scene.remove(enemy.mesh);
            const idx = state.enemies.indexOf(enemy);
            if (idx > -1) state.enemies.splice(idx, 1);

            updateEnemyCount();

            if (state.enemies.length === 0) {
                setTimeout(() => { if (state.current === GameState.PLAYING) showUpgradeScreen(); }, 1500);
            }

            vibrateController(0.5, 0.5, 150);
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // WEAPON & PROJECTILE SYSTEM
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function fireWeapon() {
            const weapon = state.weapons[state.currentWeapon];

            if (state.isReloading) return;
            if (weapon.ammo <= 0) { startReload(); return; }
            if (state.time - state.lastFire < weapon.fireRate) return;

            weapon.ammo--;
            state.lastFire = state.time;
            updateAmmo();

            const forward = new THREE.Vector3(0, 0, -1);
            forward.applyQuaternion(camera.quaternion);

            const pelletCount = weapon.pellets || 1;

            for (let i = 0; i < pelletCount; i++) {
                const spread = weapon.spread;
                const spreadDir = forward.clone();
                spreadDir.x += (Math.random() - 0.5) * spread;
                spreadDir.y += (Math.random() - 0.5) * spread;
                spreadDir.z += (Math.random() - 0.5) * spread;
                spreadDir.normalize();

                createProjectile(camera.position.clone().add(spreadDir.clone().multiplyScalar(1)), spreadDir, weapon);
            }

            createMuzzleFlash();
            applyViewmodelRecoil();
            playSound(weapon.sound);

            state.screenShake = 0.1 * (weapon.damage / 25);

            const vibIntensity = Math.min(weapon.damage / 100, 1);
            vibrateController(vibIntensity, vibIntensity * 0.5, 100);

            if (weapon.ammo <= 0) startReload();
        }

        function createProjectile(position, direction, weapon) {
            const projectileGeometry = new THREE.SphereGeometry(0.15, 8, 6);
            const projectileMaterial = new THREE.MeshBasicMaterial({ color: weapon.color });
            const projectile = new THREE.Mesh(projectileGeometry, projectileMaterial);
            projectile.position.copy(position);
            scene.add(projectile);

            const trailGeometry = new THREE.CylinderGeometry(0.05, 0.15, 1, 8);
            const trailMaterial = new THREE.MeshBasicMaterial({ color: weapon.color, transparent: true, opacity: 0.5 });
            const trail = new THREE.Mesh(trailGeometry, trailMaterial);
            trail.rotation.x = Math.PI / 2;
            projectile.add(trail);

            const glowLight = new THREE.PointLight(weapon.color, 1, 5);
            projectile.add(glowLight);

            state.projectiles.push({
                mesh: projectile,
                velocity: direction.clone().multiplyScalar(weapon.projectileSpeed),
                damage: weapon.damage * state.player.damage,
                piercing: weapon.piercing || false,
                explosive: weapon.explosive || false,
                explosionRadius: weapon.explosionRadius || 0,
                color: weapon.color,
                isPlayer: true,
                lifetime: 3
            });
        }

        function createEnemyProjectile(position, direction, damage, color) {
            // Larger, more visible projectile core
            const projectileGeometry = new THREE.SphereGeometry(0.4, 12, 8);
            const projectileMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff }); // White hot core
            const projectile = new THREE.Mesh(projectileGeometry, projectileMaterial);
            projectile.position.copy(position);
            scene.add(projectile);

            // Colored outer shell
            const shellGeometry = new THREE.SphereGeometry(0.55, 12, 8);
            const shellMaterial = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.7
            });
            const shell = new THREE.Mesh(shellGeometry, shellMaterial);
            projectile.add(shell);

            // Long glowing trail behind projectile
            const trailGeometry = new THREE.CylinderGeometry(0.15, 0.4, 3.0, 8);
            const trailMaterial = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.8
            });
            const trail = new THREE.Mesh(trailGeometry, trailMaterial);
            trail.rotation.x = Math.PI / 2;
            trail.position.z = 1.5;
            projectile.add(trail);

            // Bright point light for dramatic glow
            const glowLight = new THREE.PointLight(color, 5, 15);
            projectile.add(glowLight);

            // Large outer glow sphere
            const glowGeometry = new THREE.SphereGeometry(0.9, 12, 8);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.4
            });
            const glowSphere = new THREE.Mesh(glowGeometry, glowMaterial);
            projectile.add(glowSphere);

            // Create tracer line from shooter position
            createTracerLine(position, direction, color, 25);

            // Enemy muzzle flash at origin
            createEnemyMuzzleFlash(position, color);

            state.projectiles.push({
                mesh: projectile,
                velocity: direction.clone().multiplyScalar(40), // Slightly faster for visibility
                damage: damage,
                color: color,
                isPlayer: false,
                lifetime: 5,
                origin: position.clone() // Track origin for tracer updates
            });
        }

        function createTracerLine(startPos, direction, color, length) {
            // Create a thick, visible beam showing the shot path
            const endPos = startPos.clone().addScaledVector(direction, length);

            // Calculate beam orientation
            const beamDir = new THREE.Vector3().subVectors(endPos, startPos);
            const beamLength = beamDir.length();
            const beamCenter = startPos.clone().add(endPos).multiplyScalar(0.5);

            // Create cylinder for thick beam
            const beamGeometry = new THREE.CylinderGeometry(0.08, 0.15, beamLength, 8);
            const beamMaterial = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.9
            });
            const beam = new THREE.Mesh(beamGeometry, beamMaterial);

            // Orient beam along direction
            beam.position.copy(beamCenter);
            beam.quaternion.setFromUnitVectors(
                new THREE.Vector3(0, 1, 0),
                beamDir.normalize()
            );
            scene.add(beam);

            // Outer glow cylinder
            const glowGeometry = new THREE.CylinderGeometry(0.2, 0.35, beamLength, 8);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.4
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.position.copy(beamCenter);
            glow.quaternion.copy(beam.quaternion);
            scene.add(glow);

            // Fade out and remove tracer
            let opacity = 0.9;
            const fadeInterval = setInterval(() => {
                opacity -= 0.08;
                beamMaterial.opacity = opacity;
                glowMaterial.opacity = opacity * 0.4;
                if (opacity <= 0) {
                    clearInterval(fadeInterval);
                    scene.remove(beam);
                    scene.remove(glow);
                    beamGeometry.dispose();
                    beamMaterial.dispose();
                    glowGeometry.dispose();
                    glowMaterial.dispose();
                }
            }, 25);
        }

        function createEnemyMuzzleFlash(position, color) {
            // Bright flash at enemy position when they shoot
            const flash = new THREE.PointLight(color, 8, 15);
            flash.position.copy(position);
            scene.add(flash);

            // Flash particles
            for (let i = 0; i < 5; i++) {
                const sparkGeom = new THREE.SphereGeometry(0.1);
                const sparkMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                const spark = new THREE.Mesh(sparkGeom, sparkMat);
                spark.position.copy(position);
                scene.add(spark);

                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 8,
                    Math.random() * 4,
                    (Math.random() - 0.5) * 8
                );
                state.particles.push({ mesh: spark, velocity, lifetime: 0.15, gravity: false });
            }

            setTimeout(() => scene.remove(flash), 80);
        }

        function createImpactEffect(position, color, isOnPlayer = false) {
            // Spark burst at impact point
            const particleCount = isOnPlayer ? 20 : 12;

            for (let i = 0; i < particleCount; i++) {
                const sparkGeom = new THREE.SphereGeometry(0.08 + Math.random() * 0.1);
                const sparkMat = new THREE.MeshBasicMaterial({
                    color: i % 3 === 0 ? 0xffffff : color,
                    transparent: true
                });
                const spark = new THREE.Mesh(sparkGeom, sparkMat);
                spark.position.copy(position);
                scene.add(spark);

                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 15,
                    Math.random() * 10,
                    (Math.random() - 0.5) * 15
                );
                state.particles.push({ mesh: spark, velocity, lifetime: 0.3 + Math.random() * 0.2, gravity: true });
            }

            // Impact flash
            const impactFlash = new THREE.PointLight(color, 5, 10);
            impactFlash.position.copy(position);
            scene.add(impactFlash);
            setTimeout(() => scene.remove(impactFlash), 60);
        }

        function updateProjectiles(deltaTime) {
            for (let i = state.projectiles.length - 1; i >= 0; i--) {
                const proj = state.projectiles[i];

                proj.mesh.position.addScaledVector(proj.velocity, deltaTime);
                proj.lifetime -= deltaTime;

                const distFromCenter = Math.sqrt(proj.mesh.position.x ** 2 + proj.mesh.position.z ** 2);

                if (proj.lifetime <= 0 || distFromCenter > state.arenaRadius + 10 ||
                    proj.mesh.position.y < -5 || proj.mesh.position.y > 50) {
                    scene.remove(proj.mesh);
                    state.projectiles.splice(i, 1);
                    continue;
                }

                if (proj.isPlayer) {
                    // Check destructibles
                    let hitDestructible = false;
                    if (state.destructibles) {
                        for (let j = state.destructibles.length - 1; j >= 0; j--) {
                            const dest = state.destructibles[j];
                            if (!dest) continue;
                            
                            const destPos = (dest.userData && dest.userData.parentGroup) ? dest.userData.parentGroup.position : dest.position;
                            const distXZ = Math.sqrt((proj.mesh.position.x - destPos.x)**2 + (proj.mesh.position.z - destPos.z)**2);
                            
                            let hit = false;
                            if (dest.userData.isPillar) {
                                if (distXZ < 2.5 && proj.mesh.position.y > 0 && proj.mesh.position.y < 15) hit = true;
                            } else if (dest.userData.isCover) {
                                 if (distXZ < 2.5 && proj.mesh.position.y > 0 && proj.mesh.position.y < 3) hit = true;
                            }
                            
                            if (hit) {
                            createImpactEffect(proj.mesh.position.clone(), proj.color, false);
                            dest.userData.health -= proj.damage;
                            
                            // Visual feedback
                            const scale = Math.max(0.1, dest.userData.health / dest.userData.maxHealth);
                            if (dest.userData.isPillar) {
                                dest.scale.set(scale, 1, scale);
                            } else {
                                dest.scale.setScalar(scale);
                            }
                            
                            if (dest.userData.health <= 0) {
                                createExplosion(dest.position.clone(), 0xaaaaaa, 3);
                                if (dest.userData.parentGroup) {
                                    scene.remove(dest.userData.parentGroup);
                                } else {
                                    scene.remove(dest);
                                }
                                state.destructibles.splice(j, 1);
                            }
                            
                            scene.remove(proj.mesh);
                            state.projectiles.splice(i, 1);
                            hitDestructible = true;
                            break;
                        }
                    }
                    }
                    if (hitDestructible) continue;

                    for (const enemy of state.enemies) {
                        const dist = proj.mesh.position.distanceTo(enemy.mesh.position);
                        if (dist < enemy.type.size * 1.5) {
                            const isCrit = Math.random() < state.player.critChance;
                            const damage = isCrit ? proj.damage * state.player.critMultiplier : proj.damage;

                            damageEnemy(enemy, damage, isCrit);
                            showHitMarker();

                            // Create impact effect on enemy
                            createImpactEffect(proj.mesh.position.clone(), proj.color, false);

                            if (proj.explosive) {
                                createExplosion(proj.mesh.position.clone(), proj.color, 2);
                                for (const nearEnemy of state.enemies) {
                                    const blastDist = proj.mesh.position.distanceTo(nearEnemy.mesh.position);
                                    if (blastDist < proj.explosionRadius) {
                                        const falloff = 1 - (blastDist / proj.explosionRadius);
                                        damageEnemy(nearEnemy, proj.damage * falloff * 0.5, false);
                                    }
                                }
                            }

                            if (!proj.piercing) {
                                scene.remove(proj.mesh);
                                state.projectiles.splice(i, 1);
                                break;
                            }
                        }
                    }
                } else {
                    // Enemy projectile hitting player
                    const dist = proj.mesh.position.distanceTo(state.player.position);
                    if (dist < 1.2) {
                        // Create impact effect at hit location
                        createImpactEffect(proj.mesh.position.clone(), proj.color, true);

                        // Pass projectile position for directional damage indicator
                        damagePlayer(proj.damage, proj.mesh.position.clone());

                        scene.remove(proj.mesh);
                        state.projectiles.splice(i, 1);
                    }
                }
            }
        }

        function startReload() {
            if (state.isReloading) return;
            const weapon = state.weapons[state.currentWeapon];
            if (weapon.ammo === weapon.maxAmmo) return;

            state.isReloading = true;
            state.reloadTimer = weapon.reloadTime;

            playSound('reload');
            document.getElementById('weapon-name').textContent = 'RELOADING...';
        }

        function updateReload(deltaTime) {
            if (!state.isReloading) return;

            state.reloadTimer -= deltaTime;
            if (state.reloadTimer <= 0) {
                const weapon = state.weapons[state.currentWeapon];
                weapon.ammo = weapon.maxAmmo;
                state.isReloading = false;
                updateAmmo();
            }
        }

        function switchWeapon(index) {
            if (index === state.currentWeapon) return;
            if (index < 0 || index >= state.weapons.length) return;

            state.currentWeapon = index;
            state.isReloading = false;
            updateAmmo();
            playSound('switch');

            // Switch viewmodel
            switchViewmodel(state.weapons[index].name);
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // VISUAL EFFECTS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function createExplosion(position, color, size = 1) {
            const particleCount = 30 * size;

            for (let i = 0; i < particleCount; i++) {
                const geometry = new THREE.SphereGeometry(0.1 + Math.random() * 0.2);
                const material = new THREE.MeshBasicMaterial({ color: i % 2 === 0 ? color : 0xffffff, transparent: true });
                const particle = new THREE.Mesh(geometry, material);
                particle.position.copy(position);
                scene.add(particle);

                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 20 * size,
                    Math.random() * 15 * size,
                    (Math.random() - 0.5) * 20 * size
                );

                state.particles.push({ mesh: particle, velocity: velocity, lifetime: 0.5 + Math.random() * 0.5, gravity: true });
            }

            const flash = new THREE.PointLight(color, 5, 20);
            flash.position.copy(position);
            scene.add(flash);
            setTimeout(() => scene.remove(flash), 100);

            playSound('explosion');
        }

        function createMuzzleFlash() {
            const flash = new THREE.PointLight(0xffff00, 3, 10);
            flash.position.copy(camera.position);
            const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
            flash.position.addScaledVector(forward, 1);
            scene.add(flash);
            setTimeout(() => scene.remove(flash), 50);
        }

        function createDamageNumber(position, damage, isCrit) {
            const geometry = new THREE.PlaneGeometry(1, 0.5);
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = isCrit ? '#ffff00' : '#ffffff';
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(Math.floor(damage).toString(), 64, 48);

            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide });
            const number = new THREE.Mesh(geometry, material);
            number.position.copy(position);
            number.lookAt(camera.position);
            scene.add(number);

            state.particles.push({ mesh: number, velocity: new THREE.Vector3(0, 3, 0), lifetime: 1, gravity: false, fadeOut: true, billboard: true });
        }

        function createHealNumber(position, amount) {
            const geometry = new THREE.PlaneGeometry(1, 0.5);
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#44ff44';
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('+' + Math.floor(amount).toString(), 64, 48);

            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide });
            const number = new THREE.Mesh(geometry, material);
            number.position.copy(position);
            number.lookAt(camera.position);
            scene.add(number);

            state.particles.push({ mesh: number, velocity: new THREE.Vector3(0, 4, 0), lifetime: 1.2, gravity: false, fadeOut: true, billboard: true });
        }

        function updateParticles(deltaTime) {
            for (let i = state.particles.length - 1; i >= 0; i--) {
                const particle = state.particles[i];

                particle.mesh.position.addScaledVector(particle.velocity, deltaTime);
                if (particle.gravity) particle.velocity.y -= 30 * deltaTime;
                particle.lifetime -= deltaTime;
                if (particle.fadeOut && particle.mesh.material) particle.mesh.material.opacity = particle.lifetime;
                if (particle.billboard) particle.mesh.lookAt(camera.position);

                if (particle.lifetime <= 0) {
                    scene.remove(particle.mesh);
                    state.particles.splice(i, 1);
                }
            }
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // PICKUPS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function createPickup(position, typeOverride = null, weaponName = null) {
            const types = ['health', 'ammo', 'damage'];
            const type = typeOverride || types[Math.floor(Math.random() * types.length)];
            const colors = { health: 0x44ff44, ammo: 0x4444ff, damage: 0xff4444, weapon: 0xffd700 };

            let geometry;
            if (type === 'weapon') {
                geometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
            } else {
                geometry = new THREE.OctahedronGeometry(0.5);
            }

            const material = new THREE.MeshStandardMaterial({
                color: colors[type], emissive: colors[type], emissiveIntensity: 0.5, metalness: 0.8, roughness: 0.2
            });
            const pickup = new THREE.Mesh(geometry, material);
            pickup.position.copy(position);
            pickup.position.y = 1;
            scene.add(pickup);

            state.pickups.push({ mesh: pickup, type: type, weaponName: weaponName, lifetime: 20 });
        }

        function updatePickups(deltaTime) {
            for (let i = state.pickups.length - 1; i >= 0; i--) {
                const pickup = state.pickups[i];

                pickup.mesh.rotation.y += deltaTime * 2;
                pickup.mesh.position.y = 1 + Math.sin(state.time * 3) * 0.3;
                pickup.lifetime -= deltaTime;

                const dist = pickup.mesh.position.distanceTo(state.player.position);
                if (dist < 2) {
                    collectPickup(pickup);
                    scene.remove(pickup.mesh);
                    state.pickups.splice(i, 1);
                    continue;
                }

                if (pickup.lifetime <= 0) {
                    scene.remove(pickup.mesh);
                    state.pickups.splice(i, 1);
                }
            }
        }

        function collectPickup(pickup) {
            switch (pickup.type) {
                case 'health':
                    state.player.health = Math.min(state.player.maxHealth, state.player.health + 25);
                    updateHealth();
                    createHealNumber(state.player.position.clone().add(new THREE.Vector3(0, 2, 0)), 25);
                    break;
                case 'ammo':
                    state.weapons.forEach(w => w.ammo = w.maxAmmo);
                    updateAmmo();
                    break;
                case 'damage':
                    state.player.damage *= 1.1;
                    break;
                case 'weapon':
                    // Unlock weapon
                    const weaponIdx = state.weapons.findIndex(w => w.name === pickup.weaponName);
                    if (weaponIdx !== -1) {
                        state.weapons[weaponIdx].ammo = state.weapons[weaponIdx].maxAmmo;
                        switchWeapon(weaponIdx);
                    } else {
                        // Add new weapon if not in list (should be in list but locked in full game)
                        // For now, assume it's in the list
                        const existing = state.weapons.find(w => w.name === pickup.weaponName);
                        if (existing) {
                            existing.ammo = existing.maxAmmo;
                            switchWeapon(state.weapons.indexOf(existing));
                        }
                    }
                    addSystemMessage(`ACQUIRED: ${pickup.weaponName}`);
                    break;
            }
            playSound('pickup');
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // PLAYER CONTROLLER
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function updatePlayer(deltaTime, unscaledDeltaTime) {
            const moveSpeed = state.player.speed;
            const forward = new THREE.Vector3(0, 0, -1).applyAxisAngle(new THREE.Vector3(0, 1, 0), state.player.rotation.y);
            const right = new THREE.Vector3(1, 0, 0).applyAxisAngle(new THREE.Vector3(0, 1, 0), state.player.rotation.y);

            const moveVec = new THREE.Vector3();
            moveVec.addScaledVector(forward, state.input.move.y);
            moveVec.addScaledVector(right, state.input.move.x);

            if (moveVec.length() > 0) moveVec.normalize().multiplyScalar(moveSpeed);

            state.player.velocity.x = moveVec.x;
            state.player.velocity.z = moveVec.z;

            // Jump & Gravity
            if (state.noclip) {
                // Noclip Movement (Fly)
                if (state.input.jump) state.player.position.y += moveSpeed * deltaTime;
                if (state.input.crouch) state.player.position.y -= moveSpeed * deltaTime;
                state.player.velocity.set(0, 0, 0); // No physics velocity in noclip
            } else {
                // Normal Physics
                if (state.input.jump && state.player.isGrounded) {
                    state.player.velocity.y = 15;
                    state.player.isGrounded = false;
                }

                if (!state.player.isGrounded) {
                    state.player.velocity.y -= state.gravity * deltaTime;
                }

                state.player.position.addScaledVector(state.player.velocity, deltaTime);

                // Ground collision
                if (state.player.position.y <= 1.8) {
                    state.player.position.y = 1.8;
                    state.player.velocity.y = 0;
                    state.player.isGrounded = true;
                }

                // Arena Boundary Collision
                const distFromCenter = Math.sqrt(state.player.position.x ** 2 + state.player.position.z ** 2);
                if (distFromCenter > state.arenaRadius - 2) {
                    const pushBack = new THREE.Vector3(state.player.position.x, 0, state.player.position.z).normalize();
                    state.player.position.x = pushBack.x * (state.arenaRadius - 2);
                    state.player.position.z = pushBack.z * (state.arenaRadius - 2);
                }
            }

            // Look - different sensitivity for controller vs mouse
            // Use unscaledDeltaTime for aim to keep it responsive during bullet time
            const dtAim = unscaledDeltaTime || deltaTime;
            const lookSensitivity = state.inputMode === InputMode.GAMEPAD ? 2.5 : 1;
            state.player.rotation.y -= state.input.look.x * lookSensitivity * dtAim;
            state.player.rotation.x -= state.input.look.y * lookSensitivity * dtAim;
            state.player.rotation.x = Math.max(-Math.PI / 2.5, Math.min(Math.PI / 2.5, state.player.rotation.x));

            camera.position.copy(state.player.position);
            camera.rotation.order = 'YXZ';
            camera.rotation.y = state.player.rotation.y;
            camera.rotation.x = state.player.rotation.x;

            if (state.screenShake > 0) {
                camera.position.x += (Math.random() - 0.5) * state.screenShake;
                camera.position.y += (Math.random() - 0.5) * state.screenShake;
                state.screenShake *= 0.9;
                if (state.screenShake < 0.01) state.screenShake = 0;
            }

            if (state.input.fire) fireWeapon();
            if (state.input.reload) startReload();

            if (state.input.weapon1) switchWeapon(0);
            if (state.input.weapon2) switchWeapon(1);
            if (state.input.weapon3) switchWeapon(2);
            if (state.input.weapon4) switchWeapon(3);
        }

        function damagePlayer(damage, hitPosition = null) {
            const effectiveDamage = Math.max(1, damage - state.player.armor);
            state.player.health -= effectiveDamage;
            state.damageFlash = 0.5;

            updateHealth();

            // Show directional damage indicator if hit position provided
            if (hitPosition) {
                showDamageDirection(hitPosition);
            }

            document.getElementById('damage-overlay').style.opacity = '0.6';
            setTimeout(() => { document.getElementById('damage-overlay').style.opacity = '0'; }, 200);

            vibrateController(0.8, 0.4, 200);
            state.screenShake = 0.5;

            playSound('playerHit');

            if (state.player.health <= 0) gameOver();
        }

        function showDamageDirection(hitPosition) {
            // Calculate direction from player to hit source
            const dir = new THREE.Vector3()
                .subVectors(hitPosition, state.player.position)
                .setY(0)
                .normalize();

            // Get camera forward direction
            const cameraForward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
            cameraForward.y = 0;
            cameraForward.normalize();

            // Get camera right direction
            const cameraRight = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
            cameraRight.y = 0;
            cameraRight.normalize();

            // Calculate angle relative to camera
            const dotForward = dir.dot(cameraForward);
            const dotRight = dir.dot(cameraRight);
            const angle = Math.atan2(dotRight, dotForward) * (180 / Math.PI);

            // Create directional damage indicator
            const indicator = document.createElement('div');
            indicator.className = 'damage-direction';
            indicator.style.cssText = `
                position: absolute;
                width: 100px;
                height: 100px;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%) rotate(${angle + 180}deg);
                pointer-events: none;
                z-index: 1000;
            `;
            indicator.innerHTML = `
                <svg viewBox="0 0 100 100" style="width:100%;height:100%;">
                    <polygon points="50,10 35,40 65,40" fill="rgba(255,0,0,0.8)" />
                    <polygon points="50,10 40,35 60,35" fill="rgba(255,100,100,0.9)" />
                </svg>
            `;
            document.getElementById('game-container').appendChild(indicator);

            // Fade out and remove
            setTimeout(() => {
                indicator.style.transition = 'opacity 0.3s';
                indicator.style.opacity = '0';
                setTimeout(() => indicator.remove(), 300);
            }, 200);
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // INPUT HANDLING - DUAL SUPPORT (Controller + Keyboard/Mouse)
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        const keys = {};
        let mouseMovement = { x: 0, y: 0 };
        let lastKeyboardTime = 0;
        let lastGamepadTime = 0;

        function setInputMode(mode, savePreference = false) {
            if (state.inputMode !== mode) {
                state.inputMode = mode;
                document.body.classList.toggle('keyboard-active', mode === InputMode.KEYBOARD);

                const icon = document.getElementById('input-mode-icon');
                const text = document.getElementById('input-mode-text');
                if (mode === InputMode.KEYBOARD) {
                    icon.textContent = '‚å®Ô∏è';
                    text.textContent = 'Keyboard + Mouse';
                } else {
                    icon.textContent = 'üéÆ';
                    text.textContent = 'Controller';
                }

                // Update toggle UI
                updateInputModeToggleUI(mode);
            }

            if (savePreference) {
                state.preferredInputMode = mode;
                localStorage.setItem('apex_input_mode', mode);
            }
        }

        function updateInputModeToggleUI(mode) {
            const gamepadToggle = document.getElementById('toggle-gamepad');
            const keyboardToggle = document.getElementById('toggle-keyboard');
            if (gamepadToggle && keyboardToggle) {
                gamepadToggle.classList.toggle('active', mode === InputMode.GAMEPAD);
                keyboardToggle.classList.toggle('active', mode === InputMode.KEYBOARD);
            }
        }

        function updateInput() {
            const gamepads = navigator.getGamepads();
            let gamepadActive = false;

            for (const gamepad of gamepads) {
                if (!gamepad) continue;

                state.gamepadConnected = true;

                const deadzone = 0.15;
                const applyDeadzone = (val) => Math.abs(val) < deadzone ? 0 : val;

                const leftX = applyDeadzone(gamepad.axes[0]);
                const leftY = applyDeadzone(gamepad.axes[1]);
                const rightX = applyDeadzone(gamepad.axes[2]);
                const rightY = applyDeadzone(gamepad.axes[3]);

                // Detect if gamepad is being used
                if (Math.abs(leftX) > 0.1 || Math.abs(leftY) > 0.1 ||
                    Math.abs(rightX) > 0.1 || Math.abs(rightY) > 0.1 ||
                    gamepad.buttons.some(b => b.pressed)) {
                    lastGamepadTime = performance.now();
                    gamepadActive = true;
                }

                // Only apply gamepad input if it was used more recently (or if auto-switch is disabled and gamepad is preferred)
                const useGamepad = state.autoSwitchInput
                    ? lastGamepadTime > lastKeyboardTime
                    : state.preferredInputMode === 'gamepad';

                if (useGamepad) {
                    if (state.autoSwitchInput) setInputMode(InputMode.GAMEPAD);

                    state.input.move.x = leftX;
                    state.input.move.y = -leftY;
                    state.input.look.x = rightX * state.controllerSensitivity;
                    state.input.look.y = rightY * state.controllerSensitivity;

                    state.input.fire = gamepad.buttons[7]?.pressed || false;
                    state.input.aim = gamepad.buttons[6]?.pressed || false;
                    state.input.reload = gamepad.buttons[2]?.pressed || false;
                    state.input.jump = gamepad.buttons[0]?.pressed || false;

                    // Weapon switching with bumpers
                    if (gamepad.buttons[4]?.pressed) {
                        const prev = (state.currentWeapon - 1 + state.weapons.length) % state.weapons.length;
                        if (!state.input.prevWeaponHeld) switchWeapon(prev);
                        state.input.prevWeaponHeld = true;
                    } else {
                        state.input.prevWeaponHeld = false;
                    }

                    if (gamepad.buttons[5]?.pressed) {
                        const next = (state.currentWeapon + 1) % state.weapons.length;
                        if (!state.input.nextWeaponHeld) switchWeapon(next);
                        state.input.nextWeaponHeld = true;
                    } else {
                        state.input.nextWeaponHeld = false;
                    }

                    // D-pad for quick weapon select
                    state.input.weapon1 = gamepad.buttons[12]?.pressed || false;
                    state.input.weapon2 = gamepad.buttons[13]?.pressed || false;
                    state.input.weapon3 = gamepad.buttons[14]?.pressed || false;
                    state.input.weapon4 = gamepad.buttons[15]?.pressed || false;

                    // Pause
                    if (gamepad.buttons[9]?.pressed) {
                        if (!state.input.pauseHeld) state.input.pause = true;
                        state.input.pauseHeld = true;
                    } else {
                        state.input.pauseHeld = false;
                        state.input.pause = false;
                    }

                    // Menu navigation
                    state.input.select = gamepad.buttons[0]?.pressed || false;
                    state.input.back = gamepad.buttons[1]?.pressed || false;

                    const now = performance.now();
                    if (now - state.lastGamepadInput > 200) {
                        if (Math.abs(gamepad.axes[1]) > 0.5) {
                            state.input.menuMove.y = gamepad.axes[1] > 0 ? 1 : -1;
                            state.lastGamepadInput = now;
                        } else if (Math.abs(gamepad.axes[0]) > 0.5) {
                            state.input.menuMove.x = gamepad.axes[0] > 0 ? 1 : -1;
                            state.lastGamepadInput = now;
                        } else if (gamepad.buttons[12]?.pressed) {
                            state.input.menuMove.y = -1;
                            state.lastGamepadInput = now;
                        } else if (gamepad.buttons[13]?.pressed) {
                            state.input.menuMove.y = 1;
                            state.lastGamepadInput = now;
                        } else if (gamepad.buttons[14]?.pressed) {
                            state.input.menuMove.x = -1;
                            state.lastGamepadInput = now;
                        } else if (gamepad.buttons[15]?.pressed) {
                            state.input.menuMove.x = 1;
                            state.lastGamepadInput = now;
                        } else {
                            state.input.menuMove.x = 0;
                            state.input.menuMove.y = 0;
                        }
                    }
                }

                break;
            }

            // Apply keyboard/mouse input if it was used more recently (or if auto-switch is disabled and keyboard is preferred)
            const useKeyboard = state.autoSwitchInput
                ? lastKeyboardTime >= lastGamepadTime
                : state.preferredInputMode === 'keyboard';

            if (useKeyboard) {
                if (state.autoSwitchInput) setInputMode(InputMode.KEYBOARD);
                applyKeyboardInput();
            }
        }

        function applyKeyboardInput() {
            // Movement
            state.input.move.x = (keys['KeyD'] ? 1 : 0) - (keys['KeyA'] ? 1 : 0);
            state.input.move.y = (keys['KeyW'] ? 1 : 0) - (keys['KeyS'] ? 1 : 0);

            // Jump
            state.input.jump = keys['Space'] || false;

            // Look - apply mouse movement with sensitivity
            state.input.look.x = mouseMovement.x * state.mouseSensitivity * 50;
            state.input.look.y = mouseMovement.y * state.mouseSensitivity * 50;
            mouseMovement.x = 0;
            mouseMovement.y = 0;
        }

        function vibrateController(leftIntensity, rightIntensity, duration) {
            const gamepads = navigator.getGamepads();
            for (const gamepad of gamepads) {
                if (gamepad?.vibrationActuator) {
                    gamepad.vibrationActuator.playEffect('dual-rumble', {
                        startDelay: 0, duration: duration,
                        weakMagnitude: leftIntensity, strongMagnitude: rightIntensity
                    }).catch(() => {});
                }
            }
        }

        // Keyboard events
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            lastKeyboardTime = performance.now();

            // Weapon switching
            if (e.code === 'Digit1') { switchWeapon(0); state.input.weapon1 = true; }
            if (e.code === 'Digit2') { switchWeapon(1); state.input.weapon2 = true; }
            if (e.code === 'Digit3') { switchWeapon(2); state.input.weapon3 = true; }
            if (e.code === 'Digit4') { switchWeapon(3); state.input.weapon4 = true; }

            if (e.code === 'Escape') {
                e.preventDefault();
                state.input.pause = true;
                state.input.back = true;
            }
            if (e.code === 'KeyR') state.input.reload = true;
            if (e.code === 'ControlLeft' || e.code === 'KeyC') state.input.crouch = true;
            if (e.code === 'ShiftLeft') {
                state.timeScale = 0.5;
                document.body.classList.add('bullet-time');
            }
            if (e.code === 'KeyN') {
                state.noclip = !state.noclip;
                showToast(state.noclip ? "NOCLIP ENABLED" : "NOCLIP DISABLED");
                updateNoclipVisuals();
            }
            if (e.code === 'Enter' || e.code === 'Space') state.input.select = true;
            if (e.code === 'F1') { e.preventDefault(); LevelEditor.toggle(); }

            // Menu navigation
            if (e.code === 'ArrowUp' || e.code === 'KeyW') {
                state.input.menuMove.y = -1;
            }
            if (e.code === 'ArrowDown' || e.code === 'KeyS') {
                state.input.menuMove.y = 1;
            }
            if (e.code === 'ArrowLeft' || e.code === 'KeyA') {
                state.input.menuMove.x = -1;
            }
            if (e.code === 'ArrowRight' || e.code === 'KeyD') {
                state.input.menuMove.x = 1;
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;

            if (e.code === 'KeyR') state.input.reload = false;
            if (e.code === 'ControlLeft' || e.code === 'KeyC') state.input.crouch = false;
            if (e.code === 'ShiftLeft') {
                state.timeScale = 1.0;
                document.body.classList.remove('bullet-time');
            }
            if (e.code === 'Digit1') state.input.weapon1 = false;
            if (e.code === 'Digit2') state.input.weapon2 = false;
            if (e.code === 'Digit3') state.input.weapon3 = false;
            if (e.code === 'Digit4') state.input.weapon4 = false;
            if (e.code === 'Enter' || e.code === 'Space') state.input.select = false;
            if (e.code === 'Escape') state.input.back = false;

            state.input.menuMove.x = 0;
            state.input.menuMove.y = 0;
        });

        // Mouse events
        document.addEventListener('mousemove', (e) => {
            lastKeyboardTime = performance.now();
            if (document.pointerLockElement === canvas) {
                mouseMovement.x += e.movementX * 0.002;
                mouseMovement.y += e.movementY * 0.002;
            }
        });

        document.addEventListener('mousedown', (e) => {
            lastKeyboardTime = performance.now();

            if (e.button === 0) {
                state.input.fire = true;
                state.input.select = true;
            }
            if (e.button === 2) state.input.aim = true;

            // Request pointer lock when clicking in game
            if (state.current === GameState.PLAYING && !document.pointerLockElement) {
                canvas.requestPointerLock();
            }
        });

        document.addEventListener('mouseup', (e) => {
            if (e.button === 0) {
                state.input.fire = false;
                state.input.select = false;
            }
            if (e.button === 2) state.input.aim = false;
        });

        // Mouse wheel for weapon switching
        document.addEventListener('wheel', (e) => {
            lastKeyboardTime = performance.now();
            if (state.current === GameState.PLAYING) {
                if (e.deltaY > 0) {
                    const next = (state.currentWeapon + 1) % state.weapons.length;
                    switchWeapon(next);
                } else {
                    const prev = (state.currentWeapon - 1 + state.weapons.length) % state.weapons.length;
                    switchWeapon(prev);
                }
            }
        });

        // Pointer lock change
        document.addEventListener('pointerlockchange', () => {
            state.pointerLocked = document.pointerLockElement === canvas;

            if (state.current === GameState.PLAYING) {
                if (!state.pointerLocked && state.inputMode === InputMode.KEYBOARD) {
                    document.getElementById('click-to-play').style.display = 'block';
                } else {
                    document.getElementById('click-to-play').style.display = 'none';
                }
            }
        });

        // Global function for click-to-play overlay
        window.requestPointerLockAndResume = function() {
            canvas.requestPointerLock();
            document.getElementById('click-to-play').style.display = 'none';
        };

        // Input mode toggle buttons
        document.getElementById('toggle-gamepad').addEventListener('click', () => {
            setInputMode(InputMode.GAMEPAD, true);
        });

        document.getElementById('toggle-keyboard').addEventListener('click', () => {
            setInputMode(InputMode.KEYBOARD, true);
        });

        // Auto-switch toggle
        document.getElementById('auto-switch-input').addEventListener('change', (e) => {
            state.autoSwitchInput = e.target.checked;
            localStorage.setItem('apex_auto_switch', state.autoSwitchInput.toString());
        });

        // Streamer Mode toggle
        document.getElementById('streamer-mode-toggle').addEventListener('change', (e) => {
            state.streamerMode = e.target.checked;
            StreamerMode.init();
            if (state.streamerMode) {
                showToast("Streamer Mode ENABLED");
            }
        });


        // Mouse sensitivity slider
        document.getElementById('mouse-sensitivity').addEventListener('input', (e) => {
            state.mouseSensitivity = parseFloat(e.target.value);
            document.getElementById('mouse-sensitivity-value').textContent = state.mouseSensitivity.toFixed(1);
            localStorage.setItem('apex_mouse_sensitivity', state.mouseSensitivity.toString());
        });

        // Controller sensitivity slider
        document.getElementById('controller-sensitivity').addEventListener('input', (e) => {
            state.controllerSensitivity = parseFloat(e.target.value);
            document.getElementById('controller-sensitivity-value').textContent = state.controllerSensitivity.toFixed(1);
            localStorage.setItem('apex_controller_sensitivity', state.controllerSensitivity.toString());
        });

        // Initialize all settings UI from saved state
        function initializeSettingsUI() {
            // Input mode toggles
            updateInputModeToggleUI(state.inputMode);

            // Auto-switch checkbox
            document.getElementById('auto-switch-input').checked = state.autoSwitchInput;

            // Mouse sensitivity
            document.getElementById('mouse-sensitivity').value = state.mouseSensitivity;
            document.getElementById('mouse-sensitivity-value').textContent = state.mouseSensitivity.toFixed(1);

            // Controller sensitivity
            document.getElementById('controller-sensitivity').value = state.controllerSensitivity;
            document.getElementById('controller-sensitivity-value').textContent = state.controllerSensitivity.toFixed(1);
        }

        initializeSettingsUI();

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // AUDIO SYSTEM (Procedural)
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        let audioContext;

        function initAudio() {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }

        function playSound(type) {
            if (!audioContext) initAudio();
            if (audioContext.state === 'suspended') audioContext.resume();

            switch (type) {
                case 'plasma': playSynth([440, 880, 1760], 0.1, 'square', 0.15); break;
                case 'shotgun': playNoise(0.15, 0.3); playSynth([100, 80, 60], 0.1, 'sawtooth', 0.2); break;
                case 'railgun': playSynth([2000, 1000, 500, 250], 0.15, 'sine', 0.4); break;
                case 'rocket': playSynth([80, 60, 40], 0.2, 'sawtooth', 0.3); playNoise(0.1, 0.2); break;
                case 'explosion': playNoise(0.3, 0.5); playSynth([60, 40, 30, 20], 0.3, 'sine', 0.4); break;
                case 'pickup': playSynth([440, 660, 880], 0.05, 'sine', 0.2); break;
                case 'reload': playSynth([300, 400, 300], 0.1, 'square', 0.1); break;
                case 'switch': playSynth([600, 800], 0.05, 'sine', 0.1); break;
                case 'hit': playSynth([200, 100], 0.05, 'square', 0.1); break;
            }
        }

        function playSynth(frequencies, duration, type, volume) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.type = type;
            oscillator.frequency.setValueAtTime(frequencies[0], audioContext.currentTime);

            frequencies.forEach((freq, i) => {
                oscillator.frequency.setValueAtTime(freq, audioContext.currentTime + (i * duration / frequencies.length));
            });

            gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.start();
            oscillator.stop(audioContext.currentTime + duration);
        }

        function playNoise(duration, volume) {
            const bufferSize = audioContext.sampleRate * duration;
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const data = buffer.getChannelData(0);

            for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;

            const source = audioContext.createBufferSource();
            const gainNode = audioContext.createGain();

            source.buffer = buffer;
            gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);

            source.connect(gainNode);
            gainNode.connect(audioContext.destination);

            source.start();
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // UI UPDATES
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function updateHealth() {
            const percent = (state.player.health / state.player.maxHealth) * 100;
            document.getElementById('health-bar-inner').style.width = `${percent}%`;
            document.getElementById('health-text').textContent = Math.ceil(state.player.health);
        }

        function updateAmmo() {
            const weapon = state.weapons[state.currentWeapon];
            document.getElementById('ammo-count').textContent = weapon.ammo;
            document.getElementById('ammo-max').textContent = `/ ${weapon.maxAmmo}`;
            document.getElementById('weapon-name').textContent = weapon.name;
        }

        function updateScore() {
            document.getElementById('score-display').textContent = state.score.toLocaleString();
        }

        function updateCombo() {
            const comboDisplay = document.getElementById('combo-display');
            const comboCount = document.getElementById('combo-count');
            const comboMultiplier = document.getElementById('combo-multiplier');

            if (state.combo > 1) {
                comboDisplay.classList.add('active');
                comboCount.textContent = state.combo;
                comboMultiplier.textContent = `x${(1 + state.combo * 0.1).toFixed(1)}`;
            } else {
                comboDisplay.classList.remove('active');
            }
        }

        function updateEnemyCount() {
            document.getElementById('enemy-count').textContent = `ENEMIES: ${state.enemies.length}`;
        }

        function showHitMarker() {
            const hitMarker = document.getElementById('hit-marker');
            hitMarker.style.opacity = '1';
            playSound('hit');
            setTimeout(() => { hitMarker.style.opacity = '0'; }, 100);
        }

        function showWaveAnnouncement(waveNum) {
            const announce = document.getElementById('wave-announce');
            document.getElementById('wave-number').textContent = waveNum;
            document.getElementById('wave-display').textContent = `WAVE ${waveNum}`;
            announce.classList.remove('show');
            void announce.offsetWidth;
            announce.classList.add('show');
        }

        function showBossWarning() {
            const warning = document.getElementById('boss-warning');
            warning.classList.remove('show');
            void warning.offsetWidth;
            warning.classList.add('show');
            vibrateController(1, 1, 2000);
        }

        function addKillFeed(enemyName, score) {
            const feed = document.getElementById('kill-feed');
            const entry = document.createElement('div');
            entry.className = 'kill-entry';
            entry.textContent = `${enemyName} +${score}`;
            feed.appendChild(entry);
            setTimeout(() => { if (entry.parentNode) entry.parentNode.removeChild(entry); }, 3000);
        }

        function updateMinimap() {
            minimapCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            minimapCtx.fillRect(0, 0, 180, 180);

            const scale = 180 / (state.arenaRadius * 2);
            const centerX = 90;
            const centerY = 90;

            minimapCtx.strokeStyle = '#00ffff44';
            minimapCtx.lineWidth = 2;
            minimapCtx.beginPath();
            minimapCtx.arc(centerX, centerY, state.arenaRadius * scale, 0, Math.PI * 2);
            minimapCtx.stroke();

            minimapCtx.fillStyle = '#ff4444';
            for (const enemy of state.enemies) {
                const x = centerX + enemy.mesh.position.x * scale;
                const y = centerY + enemy.mesh.position.z * scale;
                minimapCtx.beginPath();
                minimapCtx.arc(x, y, enemy.type.isBoss ? 6 : 3, 0, Math.PI * 2);
                minimapCtx.fill();
            }

            minimapCtx.fillStyle = '#00ffff';
            const px = centerX + state.player.position.x * scale;
            const py = centerY + state.player.position.z * scale;
            minimapCtx.beginPath();
            minimapCtx.arc(px, py, 4, 0, Math.PI * 2);
            minimapCtx.fill();

            const dirX = Math.sin(state.player.rotation.y) * 10;
            const dirY = -Math.cos(state.player.rotation.y) * 10;
            minimapCtx.strokeStyle = '#00ffff';
            minimapCtx.lineWidth = 2;
            minimapCtx.beginPath();
            minimapCtx.moveTo(px, py);
            minimapCtx.lineTo(px + dirX, py + dirY);
            minimapCtx.stroke();
        }

        function setCursorMode(isPlaying) {
            document.body.classList.toggle('playing', isPlaying);
            document.body.classList.toggle('menu', !isPlaying);
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // UPGRADE SYSTEM
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        const UpgradePool = [
            { name: 'Health Boost', icon: '‚ù§Ô∏è', desc: '+25 Max Health', apply: () => { state.player.maxHealth += 25; state.player.health += 25; updateHealth(); }},
            { name: 'Damage Up', icon: '‚öîÔ∏è', desc: '+15% Damage', apply: () => { state.player.damage *= 1.15; }},
            { name: 'Speed Boost', icon: '‚ö°', desc: '+10% Move Speed', apply: () => { state.player.speed *= 1.1; }},
            { name: 'Critical Hit', icon: 'üí•', desc: '+5% Crit Chance', apply: () => { state.player.critChance += 0.05; }},
            { name: 'Armor', icon: 'üõ°Ô∏è', desc: '+5 Armor', apply: () => { state.player.armor += 5; }},
            { name: 'Rapid Fire', icon: 'üî•', desc: 'Faster Fire Rate', apply: () => { state.weapons.forEach(w => w.fireRate *= 0.9); }},
            { name: 'Extended Mag', icon: 'üì¶', desc: '+50% Ammo Capacity', apply: () => { state.weapons.forEach(w => { w.maxAmmo = Math.floor(w.maxAmmo * 1.5); w.ammo = w.maxAmmo; }); updateAmmo(); }},
            { name: 'Quick Reload', icon: 'üîÑ', desc: '-25% Reload Time', apply: () => { state.weapons.forEach(w => w.reloadTime *= 0.75); }}
        ];

        function showUpgradeScreen() {
            state.current = GameState.UPGRADE;
            document.getElementById('upgrade-screen').classList.remove('hidden');
            setCursorMode(false);

            const available = [...UpgradePool];
            state.upgrades = [];
            for (let i = 0; i < 3 && available.length > 0; i++) {
                const idx = Math.floor(Math.random() * available.length);
                state.upgrades.push(available.splice(idx, 1)[0]);
            }

            const grid = document.getElementById('upgrade-grid');
            grid.innerHTML = '';
            state.upgrades.forEach((upgrade, i) => {
                const card = document.createElement('div');
                card.className = `upgrade-card ${i === 0 ? 'selected' : ''}`;
                card.innerHTML = `
                    <div class="upgrade-icon">${upgrade.icon}</div>
                    <div class="upgrade-name">${upgrade.name}</div>
                    <div class="upgrade-desc">${upgrade.desc}</div>
                `;
                card.onclick = () => selectUpgrade(i);
                grid.appendChild(card);
            });

            state.upgradeSelection = 0;
        }

        function selectUpgrade(index) {
            const upgrade = state.upgrades[index];
            upgrade.apply();
            state.appliedUpgrades.push(upgrade);

            document.getElementById('upgrade-screen').classList.add('hidden');

            state.wave++;
            state.current = GameState.PLAYING;
            setCursorMode(true);
            spawnWave(state.wave);

            if (state.inputMode === InputMode.KEYBOARD) {
                canvas.requestPointerLock();
            }
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // MENU SYSTEM
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        let lastMenuInput = 0;

        function updateMenu(deltaTime) {
            const now = performance.now();
            const menuDebounce = 150;

            if (state.current === GameState.MENU) {
                const buttons = document.querySelectorAll('#title-screen .menu-button');

                if (state.input.menuMove.y !== 0 && now - lastMenuInput > menuDebounce) {
                    state.menuSelection += state.input.menuMove.y > 0 ? 1 : -1;
                    state.menuSelection = Math.max(0, Math.min(buttons.length - 1, state.menuSelection));
                    buttons.forEach((btn, i) => btn.classList.toggle('selected', i === state.menuSelection));
                    lastMenuInput = now;
                }

                if (state.input.select && !state.input.selectHeld) {
                    state.input.selectHeld = true;
                    if (state.menuSelection === 0) startGame();
                    else if (state.menuSelection === 1) loadGame();
                }
                if (!state.input.select) state.input.selectHeld = false;
            }

            if (state.current === GameState.PAUSED) {
                const buttons = document.querySelectorAll('#pause-screen .menu-button');

                if (state.input.menuMove.y !== 0 && now - lastMenuInput > menuDebounce) {
                    state.menuSelection += state.input.menuMove.y > 0 ? 1 : -1;
                    state.menuSelection = Math.max(0, Math.min(buttons.length - 1, state.menuSelection));
                    buttons.forEach((btn, i) => btn.classList.toggle('selected', i === state.menuSelection));
                    lastMenuInput = now;
                }

                if (state.input.select && !state.input.selectHeld) {
                    state.input.selectHeld = true;
                    if (state.menuSelection === 0) resumeGame();
                    else if (state.menuSelection === 1) restartGame();
                    else if (state.menuSelection === 2) quitToMenu();
                }
                if (!state.input.select) state.input.selectHeld = false;

                if (state.input.back && !state.input.backHeld) {
                    state.input.backHeld = true;
                    resumeGame();
                }
                if (!state.input.back) state.input.backHeld = false;
            }

            if (state.current === GameState.UPGRADE) {
                const cards = document.querySelectorAll('.upgrade-card');

                if (state.input.menuMove.x !== 0 && now - lastMenuInput > menuDebounce) {
                    state.upgradeSelection += state.input.menuMove.x > 0 ? 1 : -1;
                    state.upgradeSelection = Math.max(0, Math.min(cards.length - 1, state.upgradeSelection));
                    cards.forEach((card, i) => card.classList.toggle('selected', i === state.upgradeSelection));
                    lastMenuInput = now;
                }

                if (state.input.select && !state.input.selectHeld) {
                    state.input.selectHeld = true;
                    selectUpgrade(state.upgradeSelection);
                }
                if (!state.input.select) state.input.selectHeld = false;

                // Number keys for quick select
                if (state.input.weapon1) selectUpgrade(0);
                if (state.input.weapon2) selectUpgrade(1);
                if (state.input.weapon3) selectUpgrade(2);
            }

            if (state.current === GameState.GAMEOVER) {
                const buttons = document.querySelectorAll('#gameover-screen .menu-button');

                if (state.input.menuMove.y !== 0 && now - lastMenuInput > menuDebounce) {
                    state.menuSelection += state.input.menuMove.y > 0 ? 1 : -1;
                    state.menuSelection = Math.max(0, Math.min(buttons.length - 1, state.menuSelection));
                    buttons.forEach((btn, i) => btn.classList.toggle('selected', i === state.menuSelection));
                    lastMenuInput = now;
                }

                if (state.input.select && !state.input.selectHeld) {
                    state.input.selectHeld = true;
                    if (state.menuSelection === 0) restartGame();
                    else if (state.menuSelection === 1) quitToMenu();
                }
                if (!state.input.select) state.input.selectHeld = false;
            }

            // Pause toggle
            if (state.current === GameState.PLAYING && state.input.pause && !state.input.pauseHeld) {
                state.input.pauseHeld = true;
                pauseGame();
            }
            if (!state.input.pause) state.input.pauseHeld = false;
        }

        function showMenu() {
            state.current = GameState.MENU;
            document.getElementById('title-screen').classList.remove('hidden');
            document.getElementById('loading-screen').classList.add('hidden');
            state.menuSelection = 0;
            setCursorMode(false);
        }

        function startGame() {
            state.current = GameState.PLAYING;
            document.getElementById('title-screen').classList.add('hidden');
            setCursorMode(true);

            state.wave = 1;
            state.score = 0;
            state.combo = 0;
            state.player.health = state.player.maxHealth = 100;
            state.player.armor = 0;
            state.player.speed = 12;
            state.player.damage = 1;
            state.player.critChance = 0.1;
            state.player.position.set(0, 1.8, 0);
            state.player.rotation = { x: 0, y: 0 };
            state.appliedUpgrades = [];

            state.weapons.forEach(w => w.ammo = w.maxAmmo);
            state.currentWeapon = 0;

            state.enemies.forEach(e => scene.remove(e.mesh));
            state.enemies = [];
            state.projectiles.forEach(p => scene.remove(p.mesh));
            state.projectiles = [];
            state.particles.forEach(p => scene.remove(p.mesh));
            state.particles = [];
            state.pickups.forEach(p => scene.remove(p.mesh));
            state.pickups = [];

            updateHealth();
            updateAmmo();
            updateScore();
            updateEnemyCount();

            spawnWave(1);

            // Ghost System
            GhostSystem.startRecording();
            if (state.ghostPlayback) {
                if (state.ghostMesh) scene.remove(state.ghostMesh);
                state.ghostMesh = GhostSystem.createMesh();
                state.ghostIndex = 0;
            }

            // Request pointer lock for keyboard/mouse users
            if (state.inputMode === InputMode.KEYBOARD) {
                canvas.requestPointerLock();
            }
        }

        function loadGame() {
            const save = localStorage.getItem('apex_save');
            if (save) {
                const data = JSON.parse(save);
                state.wave = data.wave;
                state.score = data.score;
            }
            startGame();
        }

        function pauseGame() {
            state.current = GameState.PAUSED;
            document.getElementById('pause-screen').classList.remove('hidden');
            state.menuSelection = 0;
            setCursorMode(false);
            document.exitPointerLock();
        }

        function resumeGame() {
            state.current = GameState.PLAYING;
            document.getElementById('pause-screen').classList.add('hidden');
            setCursorMode(true);

            if (state.inputMode === InputMode.KEYBOARD) {
                canvas.requestPointerLock();
            }
        }

        function restartGame() {
            document.getElementById('pause-screen').classList.add('hidden');
            document.getElementById('gameover-screen').classList.add('hidden');
            startGame();
        }

        function quitToMenu() {
            document.getElementById('pause-screen').classList.add('hidden');
            document.getElementById('gameover-screen').classList.add('hidden');

            state.enemies.forEach(e => scene.remove(e.mesh));
            state.enemies = [];
            state.projectiles.forEach(p => scene.remove(p.mesh));
            state.projectiles = [];

            showMenu();
        }

        function gameOver() {
            state.current = GameState.GAMEOVER;
            setCursorMode(false);
            GhostSystem.stopRecording();

            if (state.score > state.highScore) {
                state.highScore = state.score;
                localStorage.setItem('apex_highscore', state.score.toString());
            }

            document.getElementById('final-wave').textContent = state.wave;
            document.getElementById('final-score').textContent = state.score.toLocaleString();
            document.getElementById('gameover-screen').classList.remove('hidden');

            state.menuSelection = 0;

            document.exitPointerLock();
            vibrateController(1, 1, 500);
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // STREAMER MODE SYSTEM
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        const StreamerMode = {
            modifiers: [
                { name: 'Low Gravity', duration: 15, apply: () => state.gravity = 10, reset: () => state.gravity = 30 },
                { name: 'Double Damage', duration: 15, apply: () => state.player.damage *= 2, reset: () => state.player.damage /= 2 },
                { name: 'Tiny Enemies', duration: 15, apply: () => state.enemies.forEach(e => e.mesh.scale.multiplyScalar(0.5)), reset: () => state.enemies.forEach(e => e.mesh.scale.multiplyScalar(2)) },
                { name: 'Giant Enemies', duration: 15, apply: () => state.enemies.forEach(e => e.mesh.scale.multiplyScalar(2)), reset: () => state.enemies.forEach(e => e.mesh.scale.multiplyScalar(0.5)) },
                { name: 'Spawn Boss', duration: 0, apply: () => spawnEnemy('BOSS'), reset: () => {} },
                { name: 'Free Ammo', duration: 10, apply: () => state.weapons.forEach(w => w.ammo = 999), reset: () => state.weapons.forEach(w => w.ammo = w.maxAmmo) }
            ],
            
            init: () => {
                state.chatTimer = 0;
                state.voteTimer = 0;
                state.isVoting = false;
                state.activeModifiers = [];
                document.getElementById('streamer-overlay').style.display = state.streamerMode ? 'block' : 'none';
            },

            update: (deltaTime) => {
                if (!state.streamerMode) return;

                // Chat Simulation
                state.chatTimer -= deltaTime;
                if (state.chatTimer <= 0) {
                    StreamerMode.addChatMessage();
                    state.chatTimer = Math.random() * 2 + 0.5;
                }

                // Voting Logic
                if (!state.isVoting) {
                    state.voteTimer -= deltaTime;
                    if (state.voteTimer <= 0) {
                        StreamerMode.startVote();
                    }
                } else {
                    state.voteTimer -= deltaTime;
                    StreamerMode.updateVoteUI();
                    
                    // Simulate votes
                    if (Math.random() < 0.1) {
                        const choice = Math.floor(Math.random() * state.voteOptions.length);
                        state.voteCounts[choice]++;
                    }

                    if (state.voteTimer <= 0) {
                        StreamerMode.endVote();
                    }
                }

                // Update Active Modifiers
                for (let i = state.activeModifiers.length - 1; i >= 0; i--) {
                    const mod = state.activeModifiers[i];
                    mod.timeLeft -= deltaTime;
                    if (mod.timeLeft <= 0) {
                        if (mod.reset) mod.reset();
                        showToast(`Modifier Ended: ${mod.name}`);
                        state.activeModifiers.splice(i, 1);
                    }
                }
            },

            startVote: () => {
                state.isVoting = true;
                state.voteTimer = 15; // 15 seconds to vote
                
                // Pick 3 random modifiers
                const options = [];
                const pool = [...StreamerMode.modifiers];
                for (let i = 0; i < 3; i++) {
                    if (pool.length === 0) break;
                    const idx = Math.floor(Math.random() * pool.length);
                    options.push(pool[idx]);
                    pool.splice(idx, 1);
                }
                state.voteOptions = options;
                state.voteCounts = { 0: 0, 1: 0, 2: 0 };
                
                showToast("CHAT VOTE STARTED!");
                StreamerMode.updateVoteUI();
            },

            endVote: () => {
                state.isVoting = false;
                state.voteTimer = 30; // 30 seconds between votes
                
                // Determine winner
                let winner = 0;
                let maxVotes = -1;
                for (let i = 0; i < state.voteOptions.length; i++) {
                    if (state.voteCounts[i] > maxVotes) {
                        maxVotes = state.voteCounts[i];
                        winner = i;
                    }
                }
                
                const selectedMod = state.voteOptions[winner];
                showToast(`Chat chose: ${selectedMod.name}!`);
                
                // Apply modifier
                if (selectedMod.apply) selectedMod.apply();
                
                if (selectedMod.duration > 0) {
                    state.activeModifiers.push({
                        name: selectedMod.name,
                        timeLeft: selectedMod.duration,
                        reset: selectedMod.reset
                    });
                }
                
                document.getElementById('vote-options').innerHTML = '<div style="text-align:center; color:#00ffff">Vote Ended!</div>';
            },

            updateVoteUI: () => {
                const container = document.getElementById('vote-options');
                let html = '';
                const totalVotes = Object.values(state.voteCounts).reduce((a, b) => a + b, 0) || 1;
                
                state.voteOptions.forEach((opt, idx) => {
                    const count = state.voteCounts[idx] || 0;
                    const percent = (count / totalVotes) * 100;
                    html += `
                        <div class="vote-bar-container">
                            <div class="vote-bar" style="width: ${percent}%"></div>
                            <div class="vote-label">${idx + 1}. ${opt.name} (${count})</div>
                        </div>
                    `;
                });
                html += `<div style="text-align:right; font-size:10px; margin-top:5px">${Math.ceil(state.voteTimer)}s remaining</div>`;
                container.innerHTML = html;
            },

            addChatMessage: () => {
                const users = ['NinjaFan99', 'ApexPredator', 'GlitchGamer', 'RetroWave', 'CyberPunk', 'NoobMaster', 'ProPlayer'];
                const messages = ['Pog!', 'LUL', 'Run!', 'Behind you!', 'Use the blaster!', 'GG', 'Hype!', 'Vote 1', 'Vote 2', 'Vote 3'];
                
                const user = users[Math.floor(Math.random() * users.length)];
                const msg = messages[Math.floor(Math.random() * messages.length)];
                
                const feed = document.getElementById('chat-feed');
                const div = document.createElement('div');
                div.className = 'chat-message';
                div.innerHTML = `<span class="chat-user">${user}:</span> ${msg}`;
                feed.appendChild(div);
                feed.scrollTop = feed.scrollHeight;
                
                if (feed.children.length > 10) feed.removeChild(feed.firstChild);
            }
        };

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // MAIN GAME LOOP
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function gameLoop() {
            requestAnimationFrame(gameLoop);

            const rawDeltaTime = Math.min(clock.getDelta(), 0.1);
            const timeScale = state.timeScale || 1.0;
            const deltaTime = rawDeltaTime * timeScale;
            
            state.time += deltaTime;
            state.deltaTime = deltaTime;

            state.frameCount++;
            if (state.time - state.lastFpsUpdate > 0.5) {
                state.fps = Math.round(state.frameCount / (state.time - state.lastFpsUpdate));
                document.getElementById('fps-counter').textContent = `${state.fps} FPS`;
                state.frameCount = 0;
                state.lastFpsUpdate = state.time;
            }

            updateInput();

            if (state.current === GameState.PLAYING) {
                updatePlayer(deltaTime, rawDeltaTime);
                updateEnemies(deltaTime);
                updateProjectiles(deltaTime);
                updateParticles(deltaTime);
                updatePickups(deltaTime);
                updateReload(deltaTime);
                updateViewmodel(deltaTime);
                updateMinimap();
                
                // Update Systems
                AnimationSystem.update(state.player, deltaTime); // Player animation (if visible)
                state.enemies.forEach(enemy => AnimationSystem.update(enemy, deltaTime));
                
                StreamerMode.update(deltaTime);
                GhostSystem.update(deltaTime);
                LevelEditor.update();

                if (state.combo > 0) {
                    state.comboTimer -= deltaTime;
                    if (state.comboTimer <= 0) {
                        state.combo = 0;
                        updateCombo();
                    }
                }
            }

            updateMenu(deltaTime);

            // Render main scene with post-processing
            composer.render();

            // Render weapon viewmodel on top (only during gameplay)
            if (state.current === GameState.PLAYING) {
                renderViewmodel();
            }
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // INITIALIZATION
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        async function init() {
            initThreeJS();
            initAudio();
            initViewmodelSystem();
            GhostSystem.init();
            LevelEditor.init();

            // Set initial input mode based on saved preference (defaults to gamepad)
            const preferredMode = state.preferredInputMode === 'keyboard' ? InputMode.KEYBOARD : InputMode.GAMEPAD;
            setInputMode(preferredMode);

            // Load game assets from manifest
            console.log('[APEX] Loading game assets...');
            const manifestLoaded = await loadManifest();
            if (manifestLoaded) {
                initEnemyTypesFromManifest();
                console.log('[APEX] Game assets loaded successfully');
            } else {
                console.log('[APEX] Using fallback enemy types');
            }

            await new Promise(resolve => setTimeout(resolve, 2000));

            showMenu();
            gameLoop();
        }

        // Button click handlers
        document.getElementById('btn-start').onclick = startGame;
        document.getElementById('btn-continue').onclick = loadGame;
        document.getElementById('btn-resume').onclick = resumeGame;
        document.getElementById('btn-restart').onclick = restartGame;
        document.getElementById('btn-quit').onclick = quitToMenu;
        document.getElementById('btn-retry').onclick = restartGame;
        document.getElementById('btn-menu').onclick = quitToMenu;

        document.addEventListener('contextmenu', e => e.preventDefault());

        document.addEventListener('visibilitychange', () => {
            if (document.hidden && state.current === GameState.PLAYING) pauseGame();
        });

        init();
    </script>
</body>
</html>
