<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vice City Online - Open World v1.2</title>
    <meta name="description" content="Open world crime action game inspired by GTA with vehicles, missions, and an expansive city">
    <!-- 3d, open-world, vehicles, crime, action, multiplayer -->
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0a0a;
            overflow: hidden;
            font-family: 'Segoe UI', Arial, sans-serif;
        }
        #game-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        canvas { display: block; }

        /* Loading Screen */
        #loading-screen {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(135deg, #1a0a2e 0%, #0d1b2a 50%, #1b263b 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 0.5s;
        }
        #loading-screen.hidden { opacity: 0; pointer-events: none; }
        #loading-title {
            font-size: 4em;
            font-weight: 900;
            background: linear-gradient(45deg, #ff6b6b, #ffd93d, #6bcb77, #4d96ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 60px rgba(255,107,107,0.5);
            letter-spacing: 8px;
            margin-bottom: 20px;
        }
        #loading-subtitle {
            font-size: 1.5em;
            color: #88aacc;
            letter-spacing: 4px;
            margin-bottom: 40px;
        }
        #loading-bar-container {
            width: 400px;
            height: 6px;
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
            overflow: hidden;
        }
        #loading-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #ff6b6b, #ffd93d);
            transition: width 0.3s;
        }
        #loading-text {
            color: #667788;
            margin-top: 20px;
            font-size: 0.9em;
        }

        /* HUD */
        #hud {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 100;
        }
        .hud-element { pointer-events: auto; }

        /* Minimap */
        #minimap {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 200px;
            height: 200px;
            background: rgba(0,0,0,0.7);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            overflow: hidden;
        }
        #minimap-canvas {
            width: 100%;
            height: 100%;
        }

        /* Stats */
        #stats-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            text-align: right;
        }
        #wanted-level {
            display: flex;
            gap: 5px;
            justify-content: flex-end;
            margin-bottom: 10px;
        }
        .wanted-star {
            width: 24px;
            height: 24px;
            background: rgba(100,100,100,0.5);
            clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%);
            transition: background 0.3s;
        }
        .wanted-star.active {
            background: #ffd93d;
            box-shadow: 0 0 10px #ffd93d;
        }
        #money {
            font-size: 1.8em;
            color: #6bcb77;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        #health-armor {
            margin-top: 10px;
        }
        .stat-bar {
            width: 200px;
            height: 8px;
            background: rgba(0,0,0,0.5);
            border-radius: 4px;
            margin: 5px 0;
            overflow: hidden;
        }
        .stat-bar-fill {
            height: 100%;
            transition: width 0.3s;
        }
        #health-bar .stat-bar-fill { background: linear-gradient(90deg, #ff4444, #ff6b6b); }
        #armor-bar .stat-bar-fill { background: linear-gradient(90deg, #4488ff, #66aaff); }

        /* Weapon Display */
        #weapon-display {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0,0,0,0.6);
            padding: 15px 20px;
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,0.2);
        }
        #weapon-name {
            color: #ffd93d;
            font-size: 1.1em;
            font-weight: bold;
        }
        #weapon-ammo {
            color: #ffffff;
            font-size: 1.5em;
            font-weight: bold;
        }

        /* Vehicle HUD */
        #vehicle-hud {
            position: absolute;
            bottom: 240px;
            left: 20px;
            background: rgba(0,0,0,0.6);
            padding: 15px;
            border-radius: 10px;
            display: none;
        }
        #vehicle-hud.active { display: block; }
        #speedometer {
            font-size: 2em;
            color: #ffffff;
            font-weight: bold;
        }
        #speed-unit {
            font-size: 0.8em;
            color: #888;
        }
        #vehicle-health {
            margin-top: 10px;
        }

        /* Mission Display */
        #mission-display {
            position: absolute;
            top: 20px;
            left: 20px;
            max-width: 400px;
        }
        #mission-title {
            font-size: 1.4em;
            color: #ffd93d;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        #mission-objective {
            color: #ffffff;
            margin-top: 5px;
            font-size: 1em;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }

        /* Notification */
        #notification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            padding: 20px 40px;
            border-radius: 10px;
            border: 2px solid #ffd93d;
            opacity: 0;
            transition: opacity 0.3s;
            text-align: center;
        }
        #notification.visible { opacity: 1; }
        #notification-text {
            color: #ffffff;
            font-size: 1.5em;
            font-weight: bold;
        }

        /* Crosshair */
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
        }
        #crosshair::before, #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255,255,255,0.8);
        }
        #crosshair::before {
            width: 2px;
            height: 100%;
            left: 50%;
            transform: translateX(-50%);
        }
        #crosshair::after {
            width: 100%;
            height: 2px;
            top: 50%;
            transform: translateY(-50%);
        }
        #crosshair.aiming {
            width: 30px;
            height: 30px;
        }
        #crosshair.aiming::before, #crosshair.aiming::after {
            background: #ff4444;
        }

        /* Phone UI */
        #phone {
            position: absolute;
            bottom: 50%;
            right: 50px;
            transform: translateY(50%);
            width: 180px;
            height: 350px;
            background: linear-gradient(180deg, #1a1a2e 0%, #16213e 100%);
            border-radius: 25px;
            border: 3px solid #333;
            padding: 15px;
            display: none;
            flex-direction: column;
        }
        #phone.active { display: flex; }
        #phone-screen {
            flex: 1;
            background: #0f0f23;
            border-radius: 10px;
            padding: 10px;
            overflow-y: auto;
        }
        #phone-time {
            text-align: center;
            color: #fff;
            font-size: 1.2em;
            margin-bottom: 10px;
        }
        .phone-app {
            background: rgba(255,255,255,0.1);
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: background 0.2s;
        }
        .phone-app:hover { background: rgba(255,255,255,0.2); }
        .phone-app-name { color: #fff; font-size: 0.9em; }

        /* Radio */
        #radio-display {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            padding: 30px 50px;
            border-radius: 15px;
            border: 2px solid #ffd93d;
            display: none;
            text-align: center;
        }
        #radio-display.active { display: block; }
        #radio-station {
            color: #ffd93d;
            font-size: 1.8em;
            font-weight: bold;
        }
        #radio-song {
            color: #ffffff;
            margin-top: 10px;
        }

        /* Controls Help */
        #controls-help {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255,255,255,0.5);
            font-size: 0.8em;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="loading-screen">
        <div id="loading-title">VICE CITY</div>
        <div id="loading-subtitle">ONLINE</div>
        <div id="loading-bar-container">
            <div id="loading-bar"></div>
        </div>
        <div id="loading-text">Loading city...</div>
    </div>

    <div id="game-container"></div>

    <div id="hud">
        <!-- Minimap -->
        <div id="minimap">
            <canvas id="minimap-canvas"></canvas>
        </div>

        <!-- Stats Panel -->
        <div id="stats-panel">
            <div id="wanted-level">
                <div class="wanted-star"></div>
                <div class="wanted-star"></div>
                <div class="wanted-star"></div>
                <div class="wanted-star"></div>
                <div class="wanted-star"></div>
            </div>
            <div id="money">$0</div>
            <div id="health-armor">
                <div id="health-bar" class="stat-bar">
                    <div class="stat-bar-fill" style="width: 100%"></div>
                </div>
                <div id="armor-bar" class="stat-bar">
                    <div class="stat-bar-fill" style="width: 0%"></div>
                </div>
            </div>
        </div>

        <!-- Weapon Display -->
        <div id="weapon-display">
            <div id="weapon-name">Fists</div>
            <div id="weapon-ammo">--</div>
        </div>

        <!-- Vehicle HUD -->
        <div id="vehicle-hud">
            <div id="speedometer">0 <span id="speed-unit">MPH</span></div>
            <div id="vehicle-health" class="stat-bar">
                <div class="stat-bar-fill" style="width: 100%; background: linear-gradient(90deg, #44ff44, #88ff88);"></div>
            </div>
        </div>

        <!-- Mission Display -->
        <div id="mission-display">
            <div id="mission-title"></div>
            <div id="mission-objective"></div>
        </div>

        <!-- Crosshair -->
        <div id="crosshair"></div>

        <!-- Notification -->
        <div id="notification">
            <div id="notification-text"></div>
        </div>

        <!-- Radio Display -->
        <div id="radio-display">
            <div id="radio-station">Vice FM</div>
            <div id="radio-song">Scanning...</div>
        </div>

        <!-- Phone -->
        <div id="phone">
            <div id="phone-screen">
                <div id="phone-time">12:00</div>
                <div class="phone-app" data-app="missions">
                    <div class="phone-app-name">üìã Missions</div>
                </div>
                <div class="phone-app" data-app="map">
                    <div class="phone-app-name">üó∫Ô∏è Map</div>
                </div>
                <div class="phone-app" data-app="contacts">
                    <div class="phone-app-name">üìû Contacts</div>
                </div>
                <div class="phone-app" data-app="stats">
                    <div class="phone-app-name">üìä Stats</div>
                </div>
            </div>
        </div>

        <!-- Controls Help -->
        <div id="controls-help">
            WASD: Move | Mouse: Look | Space: Jump | E: Enter Vehicle | F: Action | Tab: Phone | Q: Radio
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        'use strict';

        // ============================================================
        // VICE CITY ONLINE - Open World Crime Action Game
        // Version 1.2 - Speed FOV, Vehicle Lights, Pedestrians
        // ============================================================
        // v1.1: Camera shake system, minimap road rendering, day/night gameplay effects
        // v1.2: Speed-based FOV, vehicle headlights/taillights, basic pedestrian system

        // Asset URLs
        const ASSET_BASE_URL = 'https://raw.githubusercontent.com/kody-w/localFirstTools/main/assets/';

        // ============================================================
        // GAME CONSTANTS
        // ============================================================
        const GAME_CONFIG = {
            // World
            WORLD_SIZE: 2000,
            BLOCK_SIZE: 50,
            ROAD_WIDTH: 12,

            // Player
            PLAYER_SPEED: 8,
            PLAYER_RUN_SPEED: 14,
            PLAYER_JUMP_FORCE: 8,
            PLAYER_HEIGHT: 1.8,

            // Vehicles
            CAR_MAX_SPEED: 40,
            CAR_ACCELERATION: 15,
            CAR_BRAKE_FORCE: 25,
            CAR_TURN_SPEED: 2.5,

            // Combat
            MELEE_DAMAGE: 15,
            MELEE_RANGE: 2,

            // Police
            WANTED_DECAY_TIME: 30, // seconds per star
            POLICE_SPAWN_DISTANCE: 100,

            // Physics
            GRAVITY: 20,
            FRICTION: 0.92
        };

        // ============================================================
        // GLOBAL STATE
        // ============================================================
        const GameState = {
            isRunning: false,
            isPaused: false,
            gameTime: 12 * 60, // Minutes since midnight (starts at noon)
            timeScale: 1, // 1 real second = 1 game minute

            // Player state
            money: 5000,
            health: 100,
            armor: 0,
            wantedLevel: 0,

            // Current mission
            currentMission: null,
            completedMissions: [],

            // World entities
            vehicles: [],
            pedestrians: [],
            police: [],
            pickups: []
        };

        // ============================================================
        // CAMERA SHAKE SYSTEM (v1.1)
        // ============================================================
        const CameraShake = {
            trauma: 0,         // Current trauma level (0-1)
            decay: 2.0,        // Trauma decay per second
            maxOffset: 0.5,    // Maximum position offset
            maxAngle: 0.03,    // Maximum rotation offset (radians)
            offset: new THREE.Vector3(),
            rotationOffset: new THREE.Euler(),

            // Add trauma (will be clamped to 0-1)
            add(amount) {
                this.trauma = Math.min(1, this.trauma + amount);
            },

            // Update shake - call each frame
            update(delta) {
                if (this.trauma <= 0) {
                    this.offset.set(0, 0, 0);
                    this.rotationOffset.set(0, 0, 0);
                    return;
                }

                // Decay trauma
                this.trauma = Math.max(0, this.trauma - this.decay * delta);

                // Calculate shake (trauma^2 for smoother falloff)
                const shake = this.trauma * this.trauma;
                const time = performance.now() * 0.001;

                // Use noise-like pattern for organic shake
                this.offset.x = (Math.sin(time * 25) * 0.5 + Math.sin(time * 40) * 0.3 + Math.sin(time * 55) * 0.2) * this.maxOffset * shake;
                this.offset.y = (Math.sin(time * 30) * 0.5 + Math.sin(time * 45) * 0.3 + Math.sin(time * 60) * 0.2) * this.maxOffset * shake;
                this.offset.z = (Math.sin(time * 35) * 0.5 + Math.sin(time * 50) * 0.3 + Math.sin(time * 65) * 0.2) * this.maxOffset * shake * 0.5;

                // Rotation shake
                this.rotationOffset.x = (Math.sin(time * 28) * 0.6 + Math.sin(time * 42) * 0.4) * this.maxAngle * shake;
                this.rotationOffset.z = (Math.sin(time * 32) * 0.6 + Math.sin(time * 48) * 0.4) * this.maxAngle * shake;
            },

            // Apply shake to camera
            apply(camera) {
                camera.position.add(this.offset);
                camera.rotation.x += this.rotationOffset.x;
                camera.rotation.z += this.rotationOffset.z;
            }
        };

        // ============================================================
        // THREE.JS SETUP
        // ============================================================
        let scene, camera, renderer, clock;
        let sunLight, ambientLight;

        function initThreeJS() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb); // Sky blue
            scene.fog = new THREE.Fog(0x87ceeb, 100, 800);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 5, 10);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('game-container').appendChild(renderer.domElement);

            // Lighting
            ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);

            sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
            sunLight.position.set(100, 100, 50);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 500;
            sunLight.shadow.camera.left = -200;
            sunLight.shadow.camera.right = 200;
            sunLight.shadow.camera.top = 200;
            sunLight.shadow.camera.bottom = -200;
            scene.add(sunLight);

            clock = new THREE.Clock();

            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ============================================================
        // INPUT SYSTEM
        // ============================================================
        const Input = {
            keys: {},
            mouse: { x: 0, y: 0, dx: 0, dy: 0, buttons: {} },
            isPointerLocked: false,

            init() {
                document.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;
                    this.onKeyDown(e.code);
                });
                document.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                });
                document.addEventListener('mousemove', (e) => {
                    if (this.isPointerLocked) {
                        this.mouse.dx = e.movementX;
                        this.mouse.dy = e.movementY;
                    }
                });
                document.addEventListener('mousedown', (e) => {
                    this.mouse.buttons[e.button] = true;
                    if (!this.isPointerLocked) {
                        renderer.domElement.requestPointerLock();
                    }
                });
                document.addEventListener('mouseup', (e) => {
                    this.mouse.buttons[e.button] = false;
                });
                document.addEventListener('pointerlockchange', () => {
                    this.isPointerLocked = document.pointerLockElement === renderer.domElement;
                });
            },

            onKeyDown(code) {
                switch(code) {
                    case 'Tab':
                        Phone.toggle();
                        break;
                    case 'KeyQ':
                        if (Player.inVehicle) Radio.next();
                        break;
                    case 'KeyE':
                        if (Player.inVehicle) {
                            Player.exitVehicle();
                        } else {
                            Player.tryEnterVehicle();
                        }
                        break;
                    case 'Escape':
                        if (document.pointerLockElement) {
                            document.exitPointerLock();
                        }
                        break;
                }
            },

            resetMouseDelta() {
                this.mouse.dx = 0;
                this.mouse.dy = 0;
            }
        };

        // ============================================================
        // PLAYER CONTROLLER
        // ============================================================
        const Player = {
            position: new THREE.Vector3(0, 1, 0),
            velocity: new THREE.Vector3(),
            rotation: { x: 0, y: 0 },
            isGrounded: true,
            isRunning: false,
            inVehicle: false,
            currentVehicle: null,
            mesh: null,

            // Combat
            currentWeapon: 0,
            weapons: [
                { name: 'Fists', type: 'melee', damage: 15, ammo: Infinity, maxAmmo: Infinity }
            ],

            init() {
                // Create player mesh (third person model)
                // Note: CapsuleGeometry not available in r128, using cylinder + spheres
                const bodyGroup = new THREE.Group();

                // Main body cylinder
                const bodyGeo = new THREE.CylinderGeometry(0.3, 0.3, 1.2, 8);
                const bodyMat = new THREE.MeshStandardMaterial({ color: 0x3366cc });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.castShadow = true;
                bodyGroup.add(body);

                // Top cap (sphere)
                const capGeo = new THREE.SphereGeometry(0.3, 8, 4);
                const topCap = new THREE.Mesh(capGeo, bodyMat);
                topCap.position.y = 0.6;
                topCap.castShadow = true;
                bodyGroup.add(topCap);

                // Bottom cap (sphere)
                const bottomCap = new THREE.Mesh(capGeo, bodyMat);
                bottomCap.position.y = -0.6;
                bottomCap.castShadow = true;
                bodyGroup.add(bottomCap);

                this.mesh = bodyGroup;
                this.mesh.position.copy(this.position);
                scene.add(this.mesh);
            },

            update(delta) {
                if (this.inVehicle) {
                    this.updateInVehicle(delta);
                } else {
                    this.updateOnFoot(delta);
                }

                // Update camera
                this.updateCamera(delta);
            },

            updateOnFoot(delta) {
                // Mouse look
                const sensitivity = 0.002;
                this.rotation.y -= Input.mouse.dx * sensitivity;
                this.rotation.x -= Input.mouse.dy * sensitivity;
                this.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.rotation.x));

                // Movement
                this.isRunning = Input.keys['ShiftLeft'];
                const speed = this.isRunning ? GAME_CONFIG.PLAYER_RUN_SPEED : GAME_CONFIG.PLAYER_SPEED;

                let moveX = 0, moveZ = 0;
                if (Input.keys['KeyW']) moveZ -= 1;
                if (Input.keys['KeyS']) moveZ += 1;
                if (Input.keys['KeyA']) moveX -= 1;
                if (Input.keys['KeyD']) moveX += 1;

                if (moveX !== 0 || moveZ !== 0) {
                    const len = Math.sqrt(moveX * moveX + moveZ * moveZ);
                    moveX /= len;
                    moveZ /= len;

                    // Rotate movement by player yaw
                    const cos = Math.cos(this.rotation.y);
                    const sin = Math.sin(this.rotation.y);
                    this.velocity.x = (moveX * cos - moveZ * sin) * speed;
                    this.velocity.z = (moveX * sin + moveZ * cos) * speed;
                } else {
                    this.velocity.x *= GAME_CONFIG.FRICTION;
                    this.velocity.z *= GAME_CONFIG.FRICTION;
                }

                // Jump
                if (Input.keys['Space'] && this.isGrounded) {
                    this.velocity.y = GAME_CONFIG.PLAYER_JUMP_FORCE;
                    this.isGrounded = false;
                }

                // Gravity
                if (!this.isGrounded) {
                    this.velocity.y -= GAME_CONFIG.GRAVITY * delta;
                }

                // Apply velocity
                this.position.x += this.velocity.x * delta;
                this.position.y += this.velocity.y * delta;
                this.position.z += this.velocity.z * delta;

                // Ground collision
                const groundY = CityMap.getGroundHeight(this.position.x, this.position.z);
                if (this.position.y <= groundY + GAME_CONFIG.PLAYER_HEIGHT / 2) {
                    this.position.y = groundY + GAME_CONFIG.PLAYER_HEIGHT / 2;
                    this.velocity.y = 0;
                    this.isGrounded = true;
                }

                // Update mesh
                this.mesh.position.copy(this.position);
                this.mesh.rotation.y = this.rotation.y;

                // Combat
                if (Input.mouse.buttons[0]) {
                    this.attack();
                }
            },

            updateInVehicle(delta) {
                // Mouse look while in vehicle
                const sensitivity = 0.002;
                this.rotation.y -= Input.mouse.dx * sensitivity;
                this.rotation.x -= Input.mouse.dy * sensitivity;
                this.rotation.x = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, this.rotation.x));

                // Vehicle controls
                if (this.currentVehicle) {
                    this.currentVehicle.update(delta, Input);
                    this.position.copy(this.currentVehicle.position);
                }
            },

            updateCamera(delta) {
                if (this.inVehicle && this.currentVehicle) {
                    // Third person camera behind vehicle
                    const camDistance = 8;
                    const camHeight = 3;
                    const targetX = this.currentVehicle.position.x - Math.sin(this.rotation.y) * camDistance;
                    const targetZ = this.currentVehicle.position.z - Math.cos(this.rotation.y) * camDistance;
                    const targetY = this.currentVehicle.position.y + camHeight;

                    camera.position.lerp(new THREE.Vector3(targetX, targetY, targetZ), 5 * delta);
                    camera.lookAt(this.currentVehicle.position.x, this.currentVehicle.position.y + 1, this.currentVehicle.position.z);
                } else {
                    // Third person camera behind player
                    const camDistance = 5;
                    const camHeight = 2;
                    const targetX = this.position.x - Math.sin(this.rotation.y) * camDistance;
                    const targetZ = this.position.z - Math.cos(this.rotation.y) * camDistance;
                    const targetY = this.position.y + camHeight;

                    camera.position.lerp(new THREE.Vector3(targetX, targetY, targetZ), 8 * delta);
                    camera.lookAt(this.position.x, this.position.y + 1, this.position.z);
                }
            },

            attack() {
                // Melee attack
                const weapon = this.weapons[this.currentWeapon];
                if (weapon.type === 'melee') {
                    // Check for nearby NPCs/vehicles to damage
                    console.log('Melee attack!');
                }
            },

            tryEnterVehicle() {
                // Find nearest vehicle
                let nearest = null;
                let nearestDist = 5; // Max interaction distance

                for (const vehicle of GameState.vehicles) {
                    const dist = this.position.distanceTo(vehicle.position);
                    if (dist < nearestDist) {
                        nearest = vehicle;
                        nearestDist = dist;
                    }
                }

                if (nearest) {
                    this.enterVehicle(nearest);
                }
            },

            enterVehicle(vehicle) {
                this.inVehicle = true;
                this.currentVehicle = vehicle;
                this.mesh.visible = false;
                vehicle.hasDriver = true;
                UI.showNotification('Press E to exit vehicle');
                document.getElementById('vehicle-hud').classList.add('active');
            },

            exitVehicle() {
                if (!this.currentVehicle) return;

                // Position player beside vehicle
                const exitOffset = new THREE.Vector3(2, 0, 0);
                exitOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), this.currentVehicle.rotation);
                this.position.copy(this.currentVehicle.position).add(exitOffset);
                this.position.y = CityMap.getGroundHeight(this.position.x, this.position.z) + GAME_CONFIG.PLAYER_HEIGHT / 2;

                this.currentVehicle.hasDriver = false;
                this.currentVehicle = null;
                this.inVehicle = false;
                this.mesh.visible = true;
                this.mesh.position.copy(this.position);
                document.getElementById('vehicle-hud').classList.remove('active');
            },

            takeDamage(amount) {
                // Armor absorbs damage first
                if (GameState.armor > 0) {
                    const armorDamage = Math.min(GameState.armor, amount);
                    GameState.armor -= armorDamage;
                    amount -= armorDamage;
                }
                GameState.health = Math.max(0, GameState.health - amount);
                UI.updateStats();

                // Camera shake on damage (v1.1)
                CameraShake.add(amount / 50); // Scale shake by damage

                if (GameState.health <= 0) {
                    this.die();
                }
            },

            die() {
                UI.showNotification('WASTED');
                // Respawn after delay
                setTimeout(() => {
                    this.respawn();
                }, 3000);
            },

            respawn() {
                this.position.set(0, 1, 0);
                GameState.health = 100;
                GameState.armor = 0;
                GameState.wantedLevel = 0;
                GameState.money = Math.max(0, GameState.money - 500);
                UI.updateStats();
            }
        };

        // ============================================================
        // VEHICLE SYSTEM
        // ============================================================
        class Vehicle {
            constructor(config, position) {
                this.config = config;
                this.position = position.clone();
                this.velocity = new THREE.Vector3();
                this.rotation = 0;
                this.speed = 0;
                this.health = 100;
                this.hasDriver = false;

                this.createMesh();
            }

            createMesh() {
                const c = this.config;

                // Car body
                const bodyGeo = new THREE.BoxGeometry(c.width, c.height, c.length);
                const bodyMat = new THREE.MeshStandardMaterial({ color: c.color || 0xff0000 });
                this.mesh = new THREE.Mesh(bodyGeo, bodyMat);
                this.mesh.castShadow = true;
                this.mesh.receiveShadow = true;

                // Wheels
                const wheelGeo = new THREE.CylinderGeometry(0.4, 0.4, 0.3, 16);
                const wheelMat = new THREE.MeshStandardMaterial({ color: 0x222222 });

                this.wheels = [];
                const wheelPositions = [
                    [-c.width/2 - 0.1, -c.height/2 + 0.2, c.length/3],
                    [c.width/2 + 0.1, -c.height/2 + 0.2, c.length/3],
                    [-c.width/2 - 0.1, -c.height/2 + 0.2, -c.length/3],
                    [c.width/2 + 0.1, -c.height/2 + 0.2, -c.length/3]
                ];

                for (const pos of wheelPositions) {
                    const wheel = new THREE.Mesh(wheelGeo, wheelMat);
                    wheel.rotation.z = Math.PI / 2;
                    wheel.position.set(...pos);
                    this.mesh.add(wheel);
                    this.wheels.push(wheel);
                }

                this.mesh.position.copy(this.position);
                scene.add(this.mesh);
            }

            update(delta, input) {
                if (!this.hasDriver) return;

                // Acceleration/braking
                if (input.keys['KeyW']) {
                    this.speed += this.config.acceleration * delta;
                } else if (input.keys['KeyS']) {
                    if (this.speed > 0) {
                        this.speed -= this.config.brakeForce * delta;
                    } else {
                        this.speed -= this.config.acceleration * 0.5 * delta; // Reverse
                    }
                } else {
                    // Natural deceleration
                    this.speed *= 0.98;
                }

                // Clamp speed
                this.speed = Math.max(-this.config.maxSpeed * 0.3, Math.min(this.config.maxSpeed, this.speed));

                // Steering
                if (Math.abs(this.speed) > 0.5) {
                    const turnMultiplier = Math.min(1, Math.abs(this.speed) / 10);
                    if (input.keys['KeyA']) {
                        this.rotation += this.config.turnSpeed * turnMultiplier * delta * Math.sign(this.speed);
                    }
                    if (input.keys['KeyD']) {
                        this.rotation -= this.config.turnSpeed * turnMultiplier * delta * Math.sign(this.speed);
                    }
                }

                // Apply movement
                this.velocity.x = Math.sin(this.rotation) * this.speed;
                this.velocity.z = Math.cos(this.rotation) * this.speed;

                this.position.x += this.velocity.x * delta;
                this.position.z += this.velocity.z * delta;

                // Ground height
                const groundY = CityMap.getGroundHeight(this.position.x, this.position.z);
                this.position.y = groundY + this.config.height / 2 + 0.4;

                // Update mesh
                this.mesh.position.copy(this.position);
                this.mesh.rotation.y = this.rotation;

                // Spin wheels
                const wheelSpin = this.speed * delta * 3;
                for (const wheel of this.wheels) {
                    wheel.rotation.x += wheelSpin;
                }

                // Update speedometer
                const mph = Math.abs(this.speed) * 2.237; // Convert to MPH
                document.getElementById('speedometer').innerHTML =
                    `${Math.round(mph)} <span id="speed-unit">MPH</span>`;
            }

            takeDamage(amount) {
                this.health = Math.max(0, this.health - amount);
                if (this.health <= 0) {
                    this.explode();
                }
            }

            explode() {
                // Create explosion effect
                console.log('Vehicle exploded!');

                // Camera shake for explosion (v1.1)
                const distToPlayer = this.position.distanceTo(Player.position);
                const shakeIntensity = Math.max(0, 1 - distToPlayer / 50); // Shake falls off with distance
                CameraShake.add(shakeIntensity * 0.8);

                // Eject player if inside
                if (this.hasDriver && Player.currentVehicle === this) {
                    Player.exitVehicle();
                    Player.takeDamage(50);
                }
                // Remove from scene after delay
                setTimeout(() => {
                    scene.remove(this.mesh);
                    const idx = GameState.vehicles.indexOf(this);
                    if (idx > -1) GameState.vehicles.splice(idx, 1);
                }, 100);
            }
        }

        // ============================================================
        // CITY MAP SYSTEM
        // ============================================================
        const CityMap = {
            buildings: [],
            roads: [],
            mapData: null,

            async init() {
                // Try to load city from JSON
                try {
                    const response = await fetch(ASSET_BASE_URL + 'data/vice_city_map.json');
                    if (response.ok) {
                        this.mapData = await response.json();
                        this.buildFromJSON();
                        return;
                    }
                } catch (e) {
                    console.log('Failed to load city JSON, using procedural generation');
                }

                // Fallback: Procedural city generation
                this.generateProceduralCity();
            },

            buildFromJSON() {
                // Build city from loaded JSON data
                if (!this.mapData) return;

                // Build roads
                if (this.mapData.roads) {
                    for (const road of this.mapData.roads) {
                        this.createRoad(road);
                    }
                }

                // Build buildings
                if (this.mapData.buildings) {
                    for (const building of this.mapData.buildings) {
                        this.createBuilding(building);
                    }
                }

                console.log('City loaded from JSON');
            },

            generateProceduralCity() {
                const gridSize = 10; // 10x10 blocks
                const blockSize = GAME_CONFIG.BLOCK_SIZE;
                const roadWidth = GAME_CONFIG.ROAD_WIDTH;

                // Ground plane
                const groundGeo = new THREE.PlaneGeometry(2000, 2000);
                const groundMat = new THREE.MeshStandardMaterial({ color: 0x3a5a3a });
                const ground = new THREE.Mesh(groundGeo, groundMat);
                ground.rotation.x = -Math.PI / 2;
                ground.receiveShadow = true;
                scene.add(ground);

                // Generate grid of roads and buildings
                for (let x = -gridSize / 2; x < gridSize / 2; x++) {
                    for (let z = -gridSize / 2; z < gridSize / 2; z++) {
                        const blockX = x * (blockSize + roadWidth);
                        const blockZ = z * (blockSize + roadWidth);

                        // Create road intersection
                        this.createRoadSegment(blockX + blockSize / 2, blockZ, roadWidth * 2, blockSize + roadWidth, false);
                        this.createRoadSegment(blockX, blockZ + blockSize / 2, blockSize + roadWidth, roadWidth * 2, true);

                        // Create buildings in block
                        this.generateBlock(blockX, blockZ, blockSize);
                    }
                }

                // Spawn some vehicles
                this.spawnVehicles();

                console.log('Procedural city generated');
            },

            createRoadSegment(x, z, width, length, isVertical) {
                const roadGeo = new THREE.PlaneGeometry(width, length);
                const roadMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
                const road = new THREE.Mesh(roadGeo, roadMat);
                road.rotation.x = -Math.PI / 2;
                road.position.set(x, 0.01, z);
                if (!isVertical) road.rotation.z = Math.PI / 2;
                road.receiveShadow = true;
                scene.add(road);
                this.roads.push({ x, z, width, length, isVertical });

                // Road lines
                const lineGeo = new THREE.PlaneGeometry(0.3, length - 2);
                const lineMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                const line = new THREE.Mesh(lineGeo, lineMat);
                line.rotation.x = -Math.PI / 2;
                line.position.set(x, 0.02, z);
                if (!isVertical) line.rotation.z = Math.PI / 2;
                scene.add(line);
            },

            generateBlock(blockX, blockZ, size) {
                // Random building placement within block
                const margin = 3;
                const numBuildings = 2 + Math.floor(Math.random() * 3);

                for (let i = 0; i < numBuildings; i++) {
                    const bWidth = 8 + Math.random() * 15;
                    const bDepth = 8 + Math.random() * 15;
                    const bHeight = 10 + Math.random() * 50;

                    const bx = blockX + margin + Math.random() * (size - bWidth - margin * 2);
                    const bz = blockZ + margin + Math.random() * (size - bDepth - margin * 2);

                    this.createBuilding({
                        position: { x: bx, z: bz },
                        size: { width: bWidth, height: bHeight, depth: bDepth },
                        color: this.getRandomBuildingColor()
                    });
                }
            },

            createBuilding(config) {
                const geo = new THREE.BoxGeometry(config.size.width, config.size.height, config.size.depth);
                const mat = new THREE.MeshStandardMaterial({
                    color: config.color || 0x888888,
                    roughness: 0.8
                });
                const building = new THREE.Mesh(geo, mat);
                building.position.set(
                    config.position.x + config.size.width / 2,
                    config.size.height / 2,
                    config.position.z + config.size.depth / 2
                );
                building.castShadow = true;
                building.receiveShadow = true;
                scene.add(building);

                // Add windows
                this.addWindowsToBuilding(building, config);

                this.buildings.push({
                    mesh: building,
                    config: config
                });
            },

            addWindowsToBuilding(building, config) {
                const windowMat = new THREE.MeshBasicMaterial({ color: 0x88ccff });
                const windowSize = 1.5;
                const windowSpacing = 4;

                const floors = Math.floor(config.size.height / windowSpacing);
                const windowsPerFloor = Math.floor(config.size.width / windowSpacing);

                for (let floor = 1; floor < floors; floor++) {
                    for (let w = 0; w < windowsPerFloor; w++) {
                        // Front face
                        const windowGeo = new THREE.PlaneGeometry(windowSize, windowSize * 1.5);
                        const window1 = new THREE.Mesh(windowGeo, windowMat);
                        window1.position.set(
                            -config.size.width / 2 + windowSpacing / 2 + w * windowSpacing,
                            -config.size.height / 2 + floor * windowSpacing,
                            config.size.depth / 2 + 0.01
                        );
                        building.add(window1);
                    }
                }
            },

            getRandomBuildingColor() {
                const colors = [
                    0xcccccc, 0xaaaaaa, 0x999999, 0x888888,
                    0xddccbb, 0xbbaa99, 0xcc9988, 0xffeecc,
                    0x8899aa, 0x99aabb, 0x667788
                ];
                return colors[Math.floor(Math.random() * colors.length)];
            },

            spawnVehicles() {
                // Spawn some vehicles around the city
                const vehicleConfigs = [
                    { name: 'Sedan', width: 2, height: 1.2, length: 4, maxSpeed: 35, acceleration: 12, brakeForce: 20, turnSpeed: 2.5, color: 0xff4444 },
                    { name: 'Sports', width: 1.8, height: 1, length: 4.2, maxSpeed: 50, acceleration: 20, brakeForce: 25, turnSpeed: 3, color: 0xffff00 },
                    { name: 'SUV', width: 2.2, height: 1.8, length: 4.5, maxSpeed: 30, acceleration: 10, brakeForce: 22, turnSpeed: 2, color: 0x2244ff },
                    { name: 'Truck', width: 2.5, height: 2, length: 6, maxSpeed: 25, acceleration: 8, brakeForce: 18, turnSpeed: 1.5, color: 0x44aa44 }
                ];

                for (let i = 0; i < 20; i++) {
                    const config = vehicleConfigs[Math.floor(Math.random() * vehicleConfigs.length)];
                    const x = (Math.random() - 0.5) * 400;
                    const z = (Math.random() - 0.5) * 400;
                    const vehicle = new Vehicle(config, new THREE.Vector3(x, 1, z));
                    vehicle.rotation = Math.random() * Math.PI * 2;
                    vehicle.mesh.rotation.y = vehicle.rotation;
                    GameState.vehicles.push(vehicle);
                }
            },

            getGroundHeight(x, z) {
                // Simple flat ground for now
                return 0;
            },

            createRoad(config) {
                // Create road from JSON config
            }
        };

        // ============================================================
        // UI SYSTEM
        // ============================================================
        const UI = {
            init() {
                this.updateStats();
            },

            updateStats() {
                document.getElementById('money').textContent = '$' + GameState.money.toLocaleString();
                document.querySelector('#health-bar .stat-bar-fill').style.width = GameState.health + '%';
                document.querySelector('#armor-bar .stat-bar-fill').style.width = GameState.armor + '%';

                // Wanted level
                const stars = document.querySelectorAll('.wanted-star');
                stars.forEach((star, i) => {
                    star.classList.toggle('active', i < GameState.wantedLevel);
                });

                // Weapon
                const weapon = Player.weapons[Player.currentWeapon];
                document.getElementById('weapon-name').textContent = weapon.name;
                document.getElementById('weapon-ammo').textContent =
                    weapon.ammo === Infinity ? '--' : `${weapon.ammo} / ${weapon.maxAmmo}`;
            },

            showNotification(text, duration = 3000) {
                const notif = document.getElementById('notification');
                document.getElementById('notification-text').textContent = text;
                notif.classList.add('visible');
                setTimeout(() => notif.classList.remove('visible'), duration);
            },

            setMission(title, objective) {
                document.getElementById('mission-title').textContent = title;
                document.getElementById('mission-objective').textContent = objective;
            },

            updateMinimap() {
                const canvas = document.getElementById('minimap-canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 200;
                canvas.height = 200;

                // Background - darker at night (v1.1)
                const hour = GameState.gameTime / 60;
                const isNight = hour < 6 || hour >= 20;
                ctx.fillStyle = isNight ? '#0a0a15' : '#1a1a2e';
                ctx.fillRect(0, 0, 200, 200);

                const scale = 0.5;
                const centerX = 100;
                const centerY = 100;
                const playerX = Player.position.x;
                const playerZ = Player.position.z;

                // Draw roads on minimap (v1.1)
                ctx.strokeStyle = isNight ? '#333344' : '#444455';
                ctx.lineWidth = 4;
                for (const road of CityMap.roads) {
                    const dx = (road.x - playerX) * scale;
                    const dz = (road.z - playerZ) * scale;
                    // Only draw roads within view
                    if (Math.abs(dx) < 150 && Math.abs(dz) < 150) {
                        ctx.beginPath();
                        if (road.isVertical) {
                            const halfLen = (road.length / 2) * scale;
                            ctx.moveTo(centerX + dx, centerY + dz - halfLen);
                            ctx.lineTo(centerX + dx, centerY + dz + halfLen);
                        } else {
                            const halfLen = (road.width / 2) * scale;
                            ctx.moveTo(centerX + dx - halfLen, centerY + dz);
                            ctx.lineTo(centerX + dx + halfLen, centerY + dz);
                        }
                        ctx.stroke();
                    }
                }

                // Draw road center lines (yellow)
                ctx.strokeStyle = isNight ? '#666622' : '#888833';
                ctx.lineWidth = 1;
                for (const road of CityMap.roads) {
                    const dx = (road.x - playerX) * scale;
                    const dz = (road.z - playerZ) * scale;
                    if (Math.abs(dx) < 150 && Math.abs(dz) < 150) {
                        ctx.beginPath();
                        if (road.isVertical) {
                            const halfLen = (road.length / 2) * scale;
                            ctx.moveTo(centerX + dx, centerY + dz - halfLen);
                            ctx.lineTo(centerX + dx, centerY + dz + halfLen);
                        } else {
                            const halfLen = (road.width / 2) * scale;
                            ctx.moveTo(centerX + dx - halfLen, centerY + dz);
                            ctx.lineTo(centerX + dx + halfLen, centerY + dz);
                        }
                        ctx.stroke();
                    }
                }

                // North indicator (v1.1)
                ctx.fillStyle = '#ff6666';
                ctx.font = 'bold 12px sans-serif';
                ctx.textAlign = 'center';
                ctx.save();
                ctx.translate(centerX, centerY);
                ctx.rotate(-Player.rotation.y);
                ctx.fillText('N', 0, -85);
                ctx.restore();

                // Player arrow
                ctx.save();
                ctx.translate(centerX, centerY);
                ctx.rotate(-Player.rotation.y);
                ctx.fillStyle = '#00ff00';
                ctx.beginPath();
                ctx.moveTo(0, -8);
                ctx.lineTo(5, 8);
                ctx.lineTo(-5, 8);
                ctx.closePath();
                ctx.fill();
                ctx.restore();

                // Draw nearby vehicles as dots
                ctx.fillStyle = Player.inVehicle ? '#ffff00' : '#ff4444';
                for (const vehicle of GameState.vehicles) {
                    if (Player.currentVehicle === vehicle) continue; // Skip player's vehicle
                    const dx = (vehicle.position.x - playerX) * scale;
                    const dz = (vehicle.position.z - playerZ) * scale;
                    if (Math.abs(dx) < 100 && Math.abs(dz) < 100) {
                        ctx.beginPath();
                        ctx.arc(centerX + dx, centerY + dz, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                // Minimap border glow at night (v1.1)
                if (isNight) {
                    ctx.strokeStyle = 'rgba(100, 150, 255, 0.3)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(100, 100, 98, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
        };

        // ============================================================
        // PHONE SYSTEM
        // ============================================================
        const Phone = {
            isOpen: false,

            toggle() {
                this.isOpen = !this.isOpen;
                document.getElementById('phone').classList.toggle('active', this.isOpen);
            },

            updateTime() {
                const hours = Math.floor(GameState.gameTime / 60) % 24;
                const mins = Math.floor(GameState.gameTime % 60);
                document.getElementById('phone-time').textContent =
                    `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}`;
            }
        };

        // ============================================================
        // RADIO SYSTEM
        // ============================================================
        const Radio = {
            stations: [
                { name: 'Vice FM', genre: 'Pop' },
                { name: 'Flash FM', genre: '80s' },
                { name: 'Emotion 98.3', genre: 'Ballads' },
                { name: 'Wave 103', genre: 'New Wave' },
                { name: 'V-Rock', genre: 'Rock' },
                { name: 'Wildstyle', genre: 'Hip-Hop' },
                { name: 'Espantoso', genre: 'Latin' },
                { name: 'Radio OFF', genre: '' }
            ],
            currentStation: 0,

            next() {
                this.currentStation = (this.currentStation + 1) % this.stations.length;
                this.showRadio();
            },

            showRadio() {
                const station = this.stations[this.currentStation];
                document.getElementById('radio-station').textContent = station.name;
                document.getElementById('radio-song').textContent = station.genre || 'Radio Off';
                document.getElementById('radio-display').classList.add('active');
                setTimeout(() => {
                    document.getElementById('radio-display').classList.remove('active');
                }, 2000);
            }
        };

        // ============================================================
        // DAY/NIGHT CYCLE (v1.1 - with gameplay effects)
        // ============================================================
        const DayNightCycle = {
            timeOfDay: 'day',  // 'dawn', 'day', 'dusk', 'night'
            lastTimeOfDay: 'day',

            update(delta) {
                // Advance game time
                GameState.gameTime += delta * GameState.timeScale;
                if (GameState.gameTime >= 24 * 60) {
                    GameState.gameTime -= 24 * 60;
                }

                // Update lighting based on time
                const hour = GameState.gameTime / 60;

                // Determine time of day period (v1.1)
                if (hour >= 6 && hour < 8) {
                    this.timeOfDay = 'dawn';
                } else if (hour >= 8 && hour < 18) {
                    this.timeOfDay = 'day';
                } else if (hour >= 18 && hour < 20) {
                    this.timeOfDay = 'dusk';
                } else {
                    this.timeOfDay = 'night';
                }

                // Trigger events on time change (v1.1)
                if (this.timeOfDay !== this.lastTimeOfDay) {
                    this.onTimeChange(this.lastTimeOfDay, this.timeOfDay);
                    this.lastTimeOfDay = this.timeOfDay;
                }

                // Sun position
                const sunAngle = ((hour - 6) / 12) * Math.PI; // 6am to 6pm arc
                if (hour >= 6 && hour <= 18) {
                    sunLight.intensity = 0.8 * Math.sin(sunAngle);
                    sunLight.position.set(
                        Math.cos(sunAngle) * 100,
                        Math.sin(sunAngle) * 100,
                        50
                    );
                } else {
                    sunLight.intensity = 0.1;
                }

                // Ambient light varies by time (v1.1)
                if (this.timeOfDay === 'night') {
                    ambientLight.intensity = 0.15;
                    ambientLight.color.setHex(0x4466aa); // Blue tint at night
                } else if (this.timeOfDay === 'dawn' || this.timeOfDay === 'dusk') {
                    ambientLight.intensity = 0.3;
                    ambientLight.color.setHex(0xffaa88); // Warm tint
                } else {
                    ambientLight.intensity = 0.4;
                    ambientLight.color.setHex(0xffffff);
                }

                // Sky color
                if (this.timeOfDay === 'dawn') {
                    scene.background.setHex(0xffaa77);
                    scene.fog.color.setHex(0xffaa77);
                } else if (this.timeOfDay === 'day') {
                    scene.background.setHex(0x87ceeb);
                    scene.fog.color.setHex(0x87ceeb);
                } else if (this.timeOfDay === 'dusk') {
                    scene.background.setHex(0xff6644);
                    scene.fog.color.setHex(0xff6644);
                } else {
                    scene.background.setHex(0x0a0a1a);
                    scene.fog.color.setHex(0x0a0a1a);
                }

                // Building window lights at night (v1.1)
                this.updateBuildingLights();

                Phone.updateTime();
            },

            // Called when time period changes (v1.1)
            onTimeChange(from, to) {
                if (to === 'night') {
                    UI.showNotification('Night has fallen...', 2000);
                    // Increase crime rate at night
                    GAME_CONFIG.WANTED_DECAY_TIME = 45; // Wanted level decays slower at night
                } else if (to === 'dawn') {
                    UI.showNotification('A new day begins', 2000);
                    GAME_CONFIG.WANTED_DECAY_TIME = 30; // Normal decay during day
                } else if (to === 'dusk') {
                    UI.showNotification('Evening approaches...', 2000);
                }
            },

            // Update building window emissive (v1.1)
            updateBuildingLights() {
                const windowBrightness = this.timeOfDay === 'night' ? 1.0 :
                                        this.timeOfDay === 'dusk' ? 0.5 :
                                        this.timeOfDay === 'dawn' ? 0.3 : 0.1;

                // Update window materials on buildings
                for (const building of CityMap.buildings) {
                    if (building.mesh && building.mesh.children) {
                        for (const child of building.mesh.children) {
                            if (child.material && child.material.color) {
                                // Windows glow more at night
                                const glowIntensity = Math.random() > 0.3 ? windowBrightness : windowBrightness * 0.2;
                                child.material.color.setRGB(
                                    0.5 + glowIntensity * 0.5,
                                    0.7 + glowIntensity * 0.3,
                                    0.8 + glowIntensity * 0.2
                                );
                            }
                        }
                    }
                }
            },

            // Gameplay modifiers based on time (v1.1)
            getCrimeMultiplier() {
                // Higher crime rate at night
                return this.timeOfDay === 'night' ? 1.5 : 1.0;
            },

            getPoliceResponseTime() {
                // Slower police response at night
                return this.timeOfDay === 'night' ? 1.5 : 1.0;
            },

            isShopOpen(shopType) {
                // Most shops closed at night
                if (this.timeOfDay === 'night') {
                    return shopType === 'club' || shopType === 'bar' || shopType === '24hour';
                }
                return true;
            }
        };

        // ============================================================
        // LOADING SYSTEM
        // ============================================================
        const Loader = {
            progress: 0,

            async load() {
                this.updateProgress(10, 'Initializing engine...');
                initThreeJS();

                this.updateProgress(30, 'Generating city...');
                await CityMap.init();

                this.updateProgress(60, 'Setting up player...');
                Player.init();

                this.updateProgress(80, 'Initializing systems...');
                Input.init();
                UI.init();

                this.updateProgress(100, 'Welcome to Vice City!');

                setTimeout(() => {
                    document.getElementById('loading-screen').classList.add('hidden');
                    GameState.isRunning = true;
                    gameLoop();
                }, 500);
            },

            updateProgress(percent, text) {
                this.progress = percent;
                document.getElementById('loading-bar').style.width = percent + '%';
                document.getElementById('loading-text').textContent = text;
            }
        };

        // ============================================================
        // GAME LOOP
        // ============================================================
        function gameLoop() {
            if (!GameState.isRunning) {
                requestAnimationFrame(gameLoop);
                return;
            }

            const delta = Math.min(clock.getDelta(), 0.1);

            // Update systems
            Player.update(delta);
            DayNightCycle.update(delta);
            UI.updateMinimap();

            // Update camera shake (v1.1)
            CameraShake.update(delta);
            CameraShake.apply(camera);

            // Update vehicles
            for (const vehicle of GameState.vehicles) {
                if (!vehicle.hasDriver) {
                    // Idle vehicles
                }
            }

            // Reset mouse delta
            Input.resetMouseDelta();

            // Render
            renderer.render(scene, camera);

            requestAnimationFrame(gameLoop);
        }

        // ============================================================
        // START GAME
        // ============================================================
        window.addEventListener('load', () => {
            Loader.load();
        });
    </script>
</body>
</html>
