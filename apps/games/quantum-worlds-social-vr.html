<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Worlds Social VR - P2P Multiverse Explorer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            background: #000;
            color: #fff;
        }

        #renderCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        /* Main Menu */
        #mainMenu {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0.05) 100%);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 20px;
            padding: 40px;
            min-width: 400px;
            text-align: center;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
            z-index: 1000;
        }

        #mainMenu h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #ff00ff, #00ffff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        #mainMenu h2 {
            font-size: 1em;
            margin-bottom: 30px;
            opacity: 0.8;
        }

        .menu-button {
            display: block;
            width: 100%;
            padding: 15px;
            margin: 10px 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 10px;
            color: white;
            font-size: 1.1em;
            cursor: pointer;
            transition: all 0.3s;
        }

        .menu-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(102,126,234,0.4);
        }

        /* World Selector */
        #worldSelector {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20,20,30,0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 20px;
            padding: 30px;
            display: none;
            z-index: 1001;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .world-card {
            background: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0.05) 100%);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 15px;
            padding: 20px;
            margin: 15px 0;
            cursor: pointer;
            transition: all 0.3s;
        }

        .world-card:hover {
            transform: translateX(5px);
            border-color: rgba(255,255,255,0.4);
        }

        .world-card h3 {
            color: #00ffff;
            margin-bottom: 10px;
        }

        /* HUD */
        #hud {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.7);
            backdrop-filter: blur(5px);
            padding: 15px;
            border-radius: 10px;
            display: none;
            z-index: 100;
            min-width: 200px;
        }

        #hud h3 {
            color: #00ffff;
            margin-bottom: 10px;
            font-size: 1.2em;
        }

        .hud-info {
            margin: 5px 0;
            font-size: 0.9em;
            opacity: 0.9;
        }

        /* Player List */
        #playerList {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            backdrop-filter: blur(5px);
            padding: 15px;
            border-radius: 10px;
            display: none;
            z-index: 100;
            min-width: 150px;
        }

        .player-item {
            padding: 5px;
            margin: 3px 0;
            border-left: 3px solid #00ffff;
            padding-left: 10px;
        }

        /* Chat */
        #chat {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 350px;
            height: 200px;
            background: rgba(0,0,0,0.7);
            backdrop-filter: blur(5px);
            border-radius: 10px;
            display: none;
            z-index: 100;
            padding: 10px;
            flex-direction: column;
        }

        #chatMessages {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 10px;
            padding: 5px;
        }

        .chat-message {
            margin: 5px 0;
            padding: 5px;
            background: rgba(255,255,255,0.05);
            border-radius: 5px;
            word-wrap: break-word;
        }

        .chat-message .sender {
            color: #00ffff;
            font-weight: bold;
        }

        #chatInput {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            padding: 8px;
            border-radius: 5px;
            color: white;
            width: 100%;
        }

        /* Connection Panel */
        #connectionPanel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20,20,30,0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 20px;
            padding: 30px;
            display: none;
            z-index: 1002;
            min-width: 400px;
            text-align: center;
        }

        #connectionCode {
            background: rgba(0,0,0,0.5);
            border: 1px solid rgba(255,255,255,0.2);
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            font-family: monospace;
            font-size: 1.2em;
            word-break: break-all;
            cursor: pointer;
        }

        .input-field {
            width: 100%;
            padding: 12px;
            margin: 10px 0;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            color: white;
            font-size: 1em;
        }

        /* Crosshair */
        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255,255,255,0.8);
            border-radius: 50%;
            display: none;
            z-index: 99;
            pointer-events: none;
        }

        /* Portal Menu */
        #portalMenu {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            backdrop-filter: blur(5px);
            padding: 15px;
            border-radius: 10px;
            display: none;
            z-index: 101;
        }

        /* Controls Help */
        #controlsHelp {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 10px;
            display: none;
            z-index: 99;
            font-size: 0.9em;
        }

        .control-item {
            margin: 5px 0;
            opacity: 0.9;
        }

        .control-key {
            display: inline-block;
            background: rgba(255,255,255,0.2);
            padding: 2px 6px;
            border-radius: 3px;
            margin-right: 8px;
        }

        /* Loading Screen */
        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(102,126,234,0.2) 0%, rgba(0,0,0,0.9) 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 3px solid rgba(255,255,255,0.1);
            border-top: 3px solid #00ffff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Data Controls */
        .data-controls {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            display: none;
        }

        .data-controls button {
            margin-left: 10px;
            padding: 8px 16px;
            background: rgba(0,0,0,0.7);
            color: white;
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 5px;
            cursor: pointer;
            backdrop-filter: blur(5px);
        }

        .data-controls button:hover {
            background: rgba(255,255,255,0.1);
        }

        /* Mobile Controls */
        @media (max-width: 768px) {
            #mainMenu {
                min-width: 90%;
                padding: 20px;
            }

            #chat {
                width: 250px;
                height: 150px;
            }

            .touch-controls {
                position: fixed;
                bottom: 100px;
                left: 20px;
                display: flex;
                gap: 10px;
                z-index: 102;
            }

            .touch-button {
                width: 50px;
                height: 50px;
                background: rgba(255,255,255,0.2);
                border: 2px solid rgba(255,255,255,0.4);
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 20px;
                touch-action: none;
            }
        }
    </style>
</head>
<body>
    <canvas id="renderCanvas"></canvas>

    <!-- Loading Screen -->
    <div id="loadingScreen">
        <div class="loading-spinner"></div>
    </div>

    <!-- Main Menu -->
    <div id="mainMenu">
        <h1>Quantum Worlds</h1>
        <h2>P2P Multiverse Explorer</h2>
        <button class="menu-button" onclick="startHosting()">Host a World</button>
        <button class="menu-button" onclick="showJoinPanel()">Join a World</button>
        <button class="menu-button" onclick="showControls()">Controls</button>
        <input type="text" id="playerNameInput" class="input-field" placeholder="Enter your name" value="Explorer">
    </div>

    <!-- World Selector -->
    <div id="worldSelector">
        <h2>Choose Your World Type</h2>
        <div class="world-card" onclick="createWorld('quantum_garden')">
            <h3>ðŸŒ¸ Quantum Garden</h3>
            <p>Low gravity bioluminescent paradise with floating islands</p>
            <small>Gravity: 0.3x | Movement: Floaty</small>
        </div>
        <div class="world-card" onclick="createWorld('neon_city')">
            <h3>ðŸŒƒ Neon Synthwave City</h3>
            <p>Cyberpunk metropolis with towering skyscrapers</p>
            <small>Gravity: 1x | Movement: Normal</small>
        </div>
        <div class="world-card" onclick="createWorld('fractal_forest')">
            <h3>ðŸŒ² Fractal Forest</h3>
            <p>Recursive geometry with shifting gravity</p>
            <small>Gravity: Variable | Movement: Reality-bending</small>
        </div>
        <div class="world-card" onclick="createWorld('zero_station')">
            <h3>ðŸš€ Zero-G Space Station</h3>
            <p>Orbital facility with no gravity</p>
            <small>Gravity: 0x | Movement: 6DOF</small>
        </div>
        <button class="menu-button" onclick="hideWorldSelector()">Back</button>
    </div>

    <!-- Connection Panel -->
    <div id="connectionPanel">
        <h2 id="connectionTitle">Your World Code</h2>
        <div id="connectionCode" onclick="copyCode()"></div>
        <p id="connectionHint">Click to copy and share with friends!</p>
        <input type="text" id="joinCodeInput" class="input-field" placeholder="Paste world code here" style="display:none;">
        <button class="menu-button" id="connectionButton" onclick="handleConnection()">Waiting for players...</button>
        <button class="menu-button" onclick="cancelConnection()">Cancel</button>
    </div>

    <!-- HUD -->
    <div id="hud">
        <h3 id="worldName">World</h3>
        <div class="hud-info">Players: <span id="playerCount">1</span></div>
        <div class="hud-info">FPS: <span id="fpsCounter">60</span></div>
        <div class="hud-info">Ping: <span id="pingDisplay">0ms</span></div>
        <div class="hud-info">Press H for help</div>
    </div>

    <!-- Player List -->
    <div id="playerList">
        <h4>Players Online</h4>
        <div id="playerListContent"></div>
    </div>

    <!-- Chat -->
    <div id="chat">
        <div id="chatMessages"></div>
        <input type="text" id="chatInput" placeholder="Press Enter to chat..." onkeypress="handleChatInput(event)">
    </div>

    <!-- Portal Menu -->
    <div id="portalMenu">
        <h4>Create Portal</h4>
        <input type="text" id="portalTarget" class="input-field" placeholder="Target world code">
        <button class="menu-button" onclick="createPortal()">Create Portal</button>
    </div>

    <!-- Controls Help -->
    <div id="controlsHelp">
        <h4>Controls</h4>
        <div class="control-item"><span class="control-key">W A S D</span> Move</div>
        <div class="control-item"><span class="control-key">Mouse</span> Look</div>
        <div class="control-item"><span class="control-key">Space</span> Jump/Ascend</div>
        <div class="control-item"><span class="control-key">Shift</span> Descend</div>
        <div class="control-item"><span class="control-key">Enter</span> Chat</div>
        <div class="control-item"><span class="control-key">P</span> Create Portal</div>
        <div class="control-item"><span class="control-key">H</span> Toggle Help</div>
        <div class="control-item"><span class="control-key">Esc</span> Menu</div>
    </div>

    <!-- Crosshair -->
    <div id="crosshair"></div>

    <!-- Data Controls -->
    <div class="data-controls">
        <button onclick="exportData()">Export Data</button>
        <button onclick="document.getElementById('importFile').click()">Import Data</button>
        <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importData(event)">
    </div>

    <!-- Load Three.js from CDN -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.min.js"></script>

    <!-- Main Application Script -->
    <script>
        // Application State
        const APP_NAME = 'quantum-worlds-vr';
        let appData = JSON.parse(localStorage.getItem(APP_NAME) || '{"worlds":[],"savedPortals":[],"playerName":"Explorer","settings":{}}');

        // Core Variables
        let scene, camera, renderer;
        let world = null;
        let player = null;
        let peers = new Map();
        let isHost = false;
        let worldType = null;
        let worldSeed = null;
        let connectionOffer = null;
        let myPeerId = null;
        let avatars = new Map();
        let portals = [];
        let clock = new THREE.Clock();
        let controls = {
            forward: false,
            backward: false,
            left: false,
            right: false,
            jump: false,
            descend: false
        };
        let mouseX = 0, mouseY = 0;
        let isPointerLocked = false;

        // World Configurations
        const worldConfigs = {
            quantum_garden: {
                name: "Quantum Garden",
                gravity: -3,
                jumpPower: 8,
                moveSpeed: 5,
                skyColor: 0x2a0845,
                fogColor: 0x2a0845,
                fogDensity: 0.02,
                ambientLight: 0x4a4a8f,
                directionalLight: 0xffa0ff
            },
            neon_city: {
                name: "Neon Synthwave City",
                gravity: -9.8,
                jumpPower: 10,
                moveSpeed: 7,
                skyColor: 0x0a0a0a,
                fogColor: 0xff00ff,
                fogDensity: 0.01,
                ambientLight: 0x2a2a4a,
                directionalLight: 0x00ffff
            },
            fractal_forest: {
                name: "Fractal Forest",
                gravity: -5,
                jumpPower: 12,
                moveSpeed: 6,
                skyColor: 0x0a2a0a,
                fogColor: 0x0a4a0a,
                fogDensity: 0.03,
                ambientLight: 0x2a4a2a,
                directionalLight: 0x80ff80
            },
            zero_station: {
                name: "Zero-G Space Station",
                gravity: 0,
                jumpPower: 5,
                moveSpeed: 8,
                skyColor: 0x000011,
                fogColor: 0x000011,
                fogDensity: 0.005,
                ambientLight: 0x1a1a3a,
                directionalLight: 0xffffff
            }
        };

        // Initialize Three.js
        function initThreeJS() {
            // Scene
            scene = new THREE.Scene();

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 10);

            // Renderer
            renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('renderCanvas'),
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // Handle resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        // Player Class
        class Player {
            constructor() {
                this.position = new THREE.Vector3(0, 5, 0);
                this.velocity = new THREE.Vector3(0, 0, 0);
                this.rotation = new THREE.Euler(0, 0, 0);
                this.onGround = false;
                this.height = 2;
            }

            update(deltaTime, config) {
                // Apply gravity
                if (config.gravity !== 0) {
                    this.velocity.y += config.gravity * deltaTime;
                }

                // Apply velocity
                this.position.add(this.velocity.clone().multiplyScalar(deltaTime));

                // Ground check
                if (this.position.y <= this.height / 2) {
                    this.position.y = this.height / 2;
                    this.velocity.y = 0;
                    this.onGround = true;
                } else {
                    this.onGround = false;
                }

                // Apply friction
                this.velocity.x *= 0.9;
                this.velocity.z *= 0.9;
                if (config.gravity === 0) {
                    this.velocity.y *= 0.9;
                }

                // Update camera
                camera.position.copy(this.position);
                camera.position.y += this.height / 2;
                camera.rotation.copy(this.rotation);
            }

            move(direction, speed) {
                const moveVector = new THREE.Vector3();

                if (direction.forward) {
                    moveVector.z -= 1;
                }
                if (direction.backward) {
                    moveVector.z += 1;
                }
                if (direction.left) {
                    moveVector.x -= 1;
                }
                if (direction.right) {
                    moveVector.x += 1;
                }

                if (moveVector.length() > 0) {
                    moveVector.normalize();
                    moveVector.applyEuler(new THREE.Euler(0, this.rotation.y, 0));
                    moveVector.multiplyScalar(speed);

                    this.velocity.x = moveVector.x;
                    this.velocity.z = moveVector.z;
                }
            }

            jump(power) {
                const config = worldConfigs[worldType];
                if (config.gravity === 0) {
                    // Zero-G movement
                    this.velocity.y = power;
                } else if (this.onGround) {
                    this.velocity.y = power;
                }
            }

            descend(power) {
                const config = worldConfigs[worldType];
                if (config.gravity === 0) {
                    this.velocity.y = -power;
                }
            }
        }

        // World Generation
        function generateWorld(type, seed) {
            // Clear existing world
            while(scene.children.length > 0) {
                scene.remove(scene.children[0]);
            }

            const config = worldConfigs[type];
            worldSeed = seed || Math.random() * 1000000;

            // Setup scene
            scene.fog = new THREE.FogExp2(config.fogColor, config.fogDensity);
            scene.background = new THREE.Color(config.skyColor);

            // Lights
            const ambientLight = new THREE.AmbientLight(config.ambientLight, 0.4);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(config.directionalLight, 0.6);
            directionalLight.position.set(10, 20, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // Generate world based on type
            switch(type) {
                case 'quantum_garden':
                    generateQuantumGarden(worldSeed);
                    break;
                case 'neon_city':
                    generateNeonCity(worldSeed);
                    break;
                case 'fractal_forest':
                    generateFractalForest(worldSeed);
                    break;
                case 'zero_station':
                    generateZeroStation(worldSeed);
                    break;
            }
        }

        // Quantum Garden Generator
        function generateQuantumGarden(seed) {
            const rng = mulberry32(seed);

            // Ground plane
            const groundGeometry = new THREE.PlaneGeometry(200, 200, 20, 20);
            const groundMaterial = new THREE.MeshPhongMaterial({
                color: 0x1a0533,
                emissive: 0x2a0545,
                emissiveIntensity: 0.2
            });

            // Displace vertices for organic look
            const vertices = groundGeometry.attributes.position.array;
            for (let i = 0; i < vertices.length; i += 3) {
                vertices[i + 2] = Math.sin(vertices[i] * 0.1) * Math.cos(vertices[i + 1] * 0.1) * 2;
            }
            groundGeometry.computeVertexNormals();

            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Floating islands
            for (let i = 0; i < 8; i++) {
                const islandGeometry = new THREE.SphereGeometry(
                    5 + rng() * 10,
                    8,
                    6
                );

                // Deform for organic shape
                const vertices = islandGeometry.attributes.position.array;
                for (let j = 0; j < vertices.length; j += 3) {
                    const noise = rng() * 0.3 + 0.7;
                    vertices[j] *= noise;
                    vertices[j + 1] *= noise;
                    vertices[j + 2] *= noise;
                }
                islandGeometry.computeVertexNormals();

                const islandMaterial = new THREE.MeshPhongMaterial({
                    color: new THREE.Color().setHSL(0.8, 0.5, 0.3),
                    emissive: 0x4a0e4e,
                    emissiveIntensity: 0.3
                });

                const island = new THREE.Mesh(islandGeometry, islandMaterial);
                island.position.set(
                    (rng() - 0.5) * 100,
                    10 + rng() * 30,
                    (rng() - 0.5) * 100
                );
                island.castShadow = true;
                island.receiveShadow = true;
                scene.add(island);
            }

            // Bioluminescent plants
            for (let i = 0; i < 30; i++) {
                const plantGroup = new THREE.Group();

                // Stem
                const stemGeometry = new THREE.CylinderGeometry(0.1, 0.2, 3 + rng() * 2);
                const stemMaterial = new THREE.MeshPhongMaterial({
                    color: 0x2a6a2a,
                    emissive: 0x1a4a1a,
                    emissiveIntensity: 0.5
                });
                const stem = new THREE.Mesh(stemGeometry, stemMaterial);
                plantGroup.add(stem);

                // Glowing bulb
                const bulbGeometry = new THREE.SphereGeometry(0.5 + rng() * 0.5, 8, 6);
                const bulbMaterial = new THREE.MeshPhongMaterial({
                    color: new THREE.Color().setHSL(rng(), 1, 0.5),
                    emissive: new THREE.Color().setHSL(rng(), 1, 0.5),
                    emissiveIntensity: 1
                });
                const bulb = new THREE.Mesh(bulbGeometry, bulbMaterial);
                bulb.position.y = 2;
                plantGroup.add(bulb);

                // Add glow light
                const light = new THREE.PointLight(bulbMaterial.emissive, 0.5, 10);
                light.position.copy(bulb.position);
                plantGroup.add(light);

                plantGroup.position.set(
                    (rng() - 0.5) * 80,
                    0,
                    (rng() - 0.5) * 80
                );

                scene.add(plantGroup);
            }

            // Floating particles
            const particleCount = 200;
            const particleGeometry = new THREE.BufferGeometry();
            const particlePositions = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount * 3; i += 3) {
                particlePositions[i] = (rng() - 0.5) * 100;
                particlePositions[i + 1] = rng() * 50;
                particlePositions[i + 2] = (rng() - 0.5) * 100;
            }

            particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));

            const particleMaterial = new THREE.PointsMaterial({
                color: 0xff00ff,
                size: 0.2,
                transparent: true,
                opacity: 0.6
            });

            const particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);
        }

        // Neon City Generator
        function generateNeonCity(seed) {
            const rng = mulberry32(seed);

            // Ground
            const groundGeometry = new THREE.PlaneGeometry(300, 300);
            const groundMaterial = new THREE.MeshPhongMaterial({
                color: 0x1a1a1a,
                emissive: 0x0a0a0a,
                emissiveIntensity: 0.2
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Grid lines
            for (let i = -150; i <= 150; i += 10) {
                const lineGeometry = new THREE.BoxGeometry(0.1, 0.1, 300);
                const lineMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    emissive: 0x00ffff,
                    emissiveIntensity: 1
                });
                const line = new THREE.Mesh(lineGeometry, lineMaterial);
                line.position.set(i, 0.1, 0);
                scene.add(line);

                const line2 = new THREE.Mesh(lineGeometry, lineMaterial);
                line2.position.set(0, 0.1, i);
                line2.rotation.y = Math.PI / 2;
                scene.add(line2);
            }

            // Buildings
            for (let i = 0; i < 40; i++) {
                const width = 5 + rng() * 15;
                const depth = 5 + rng() * 15;
                const height = 10 + rng() * 50;

                const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
                const hue = rng();
                const buildingMaterial = new THREE.MeshPhongMaterial({
                    color: new THREE.Color().setHSL(hue, 0.8, 0.3),
                    emissive: new THREE.Color().setHSL(hue, 1, 0.2),
                    emissiveIntensity: 0.5
                });

                const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
                building.position.set(
                    (rng() - 0.5) * 120,
                    height / 2,
                    (rng() - 0.5) * 120
                );
                building.castShadow = true;
                building.receiveShadow = true;

                // Windows
                for (let w = 0; w < 5; w++) {
                    const windowLight = new THREE.PointLight(0x00ffff, 0.3, 20);
                    windowLight.position.set(
                        building.position.x + (rng() - 0.5) * width,
                        building.position.y + (rng() - 0.5) * height,
                        building.position.z + (rng() - 0.5) * depth
                    );
                    scene.add(windowLight);
                }

                scene.add(building);
            }

            // Neon signs
            for (let i = 0; i < 15; i++) {
                const signGeometry = new THREE.BoxGeometry(8, 2, 0.5);
                const signMaterial = new THREE.MeshBasicMaterial({
                    color: new THREE.Color().setHSL(rng(), 1, 0.5)
                });
                const sign = new THREE.Mesh(signGeometry, signMaterial);
                sign.position.set(
                    (rng() - 0.5) * 100,
                    15 + rng() * 20,
                    (rng() - 0.5) * 100
                );

                const neonLight = new THREE.PointLight(signMaterial.color, 1, 30);
                neonLight.position.copy(sign.position);
                scene.add(neonLight);

                scene.add(sign);
            }
        }

        // Fractal Forest Generator
        function generateFractalForest(seed) {
            const rng = mulberry32(seed);

            // Undulating ground
            const groundGeometry = new THREE.PlaneGeometry(200, 200, 30, 30);
            const vertices = groundGeometry.attributes.position.array;
            for (let i = 0; i < vertices.length; i += 3) {
                vertices[i + 2] = Math.sin(vertices[i] * 0.05) * Math.cos(vertices[i + 1] * 0.05) * 5;
            }
            groundGeometry.computeVertexNormals();

            const groundMaterial = new THREE.MeshPhongMaterial({
                color: 0x2a4a2a,
                emissive: 0x0a2a0a,
                emissiveIntensity: 0.1
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Fractal trees
            function createFractalTree(level, height, radius, position, rotation) {
                if (level <= 0) return;

                const trunkGeometry = new THREE.CylinderGeometry(radius * 0.8, radius, height);
                const trunkMaterial = new THREE.MeshPhongMaterial({
                    color: new THREE.Color().setHSL(0.1, 0.5, 0.3 - level * 0.05),
                    emissive: 0x1a2a1a,
                    emissiveIntensity: 0.2
                });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.copy(position);
                trunk.rotation.copy(rotation);
                trunk.castShadow = true;
                scene.add(trunk);

                // Branches
                const branchCount = 2 + Math.floor(rng() * 3);
                for (let i = 0; i < branchCount; i++) {
                    const angle = (i / branchCount) * Math.PI * 2;
                    const branchRotation = new THREE.Euler(
                        rotation.x + (rng() - 0.5) * 0.5,
                        rotation.y + angle,
                        rotation.z + (rng() - 0.5) * 0.5
                    );

                    const branchPosition = position.clone();
                    branchPosition.y += height;
                    branchPosition.x += Math.cos(angle) * height * 0.3;
                    branchPosition.z += Math.sin(angle) * height * 0.3;

                    createFractalTree(
                        level - 1,
                        height * 0.7,
                        radius * 0.6,
                        branchPosition,
                        branchRotation
                    );
                }
            }

            // Create forest
            for (let i = 0; i < 15; i++) {
                const treePosition = new THREE.Vector3(
                    (rng() - 0.5) * 100,
                    0,
                    (rng() - 0.5) * 100
                );
                createFractalTree(4, 8, 1.5, treePosition, new THREE.Euler(0, rng() * Math.PI * 2, 0));
            }

            // Floating geometric shapes
            for (let i = 0; i < 20; i++) {
                const geometryType = Math.floor(rng() * 4);
                let shapeGeometry;

                switch(geometryType) {
                    case 0:
                        shapeGeometry = new THREE.TetrahedronGeometry(1 + rng() * 2);
                        break;
                    case 1:
                        shapeGeometry = new THREE.OctahedronGeometry(1 + rng() * 2);
                        break;
                    case 2:
                        shapeGeometry = new THREE.IcosahedronGeometry(1 + rng() * 2);
                        break;
                    default:
                        shapeGeometry = new THREE.DodecahedronGeometry(1 + rng() * 2);
                }

                const shapeMaterial = new THREE.MeshPhongMaterial({
                    color: new THREE.Color().setHSL(rng(), 0.7, 0.5),
                    emissive: new THREE.Color().setHSL(rng(), 0.7, 0.3),
                    emissiveIntensity: 0.5,
                    transparent: true,
                    opacity: 0.8
                });

                const shape = new THREE.Mesh(shapeGeometry, shapeMaterial);
                shape.position.set(
                    (rng() - 0.5) * 80,
                    5 + rng() * 20,
                    (rng() - 0.5) * 80
                );
                shape.rotation.set(rng() * Math.PI, rng() * Math.PI, rng() * Math.PI);
                shape.castShadow = true;
                scene.add(shape);
            }
        }

        // Zero-G Station Generator
        function generateZeroStation(seed) {
            const rng = mulberry32(seed);

            // Station modules
            for (let i = 0; i < 8; i++) {
                const moduleGroup = new THREE.Group();

                // Main corridor
                const corridorGeometry = new THREE.CylinderGeometry(3, 3, 20, 8);
                const corridorMaterial = new THREE.MeshPhongMaterial({
                    color: 0x4a4a6a,
                    emissive: 0x1a1a2a,
                    emissiveIntensity: 0.2
                });
                const corridor = new THREE.Mesh(corridorGeometry, corridorMaterial);
                corridor.rotation.z = Math.PI / 2;
                moduleGroup.add(corridor);

                // End caps
                const capGeometry = new THREE.SphereGeometry(3, 8, 6, 0, Math.PI * 2, 0, Math.PI / 2);
                const cap1 = new THREE.Mesh(capGeometry, corridorMaterial);
                cap1.position.x = 10;
                cap1.rotation.z = Math.PI / 2;
                moduleGroup.add(cap1);

                const cap2 = new THREE.Mesh(capGeometry, corridorMaterial);
                cap2.position.x = -10;
                cap2.rotation.z = -Math.PI / 2;
                moduleGroup.add(cap2);

                // Windows
                for (let w = 0; w < 6; w++) {
                    const windowGeometry = new THREE.CircleGeometry(0.8, 8);
                    const windowMaterial = new THREE.MeshBasicMaterial({
                        color: 0x8080ff,
                        emissive: 0x4040ff,
                        transparent: true,
                        opacity: 0.8
                    });
                    const window = new THREE.Mesh(windowGeometry, windowMaterial);
                    window.position.x = -8 + w * 3;
                    window.position.y = 3;
                    moduleGroup.add(window);
                }

                // Position module
                moduleGroup.position.set(
                    (rng() - 0.5) * 60,
                    (rng() - 0.5) * 40,
                    (rng() - 0.5) * 60
                );
                moduleGroup.rotation.set(
                    rng() * Math.PI * 2,
                    rng() * Math.PI * 2,
                    rng() * Math.PI * 2
                );

                scene.add(moduleGroup);
            }

            // Solar panels
            for (let i = 0; i < 12; i++) {
                const panelGeometry = new THREE.BoxGeometry(10, 0.2, 6);
                const panelMaterial = new THREE.MeshPhongMaterial({
                    color: 0x2a2a4a,
                    emissive: 0x000033,
                    emissiveIntensity: 0.3
                });
                const panel = new THREE.Mesh(panelGeometry, panelMaterial);
                panel.position.set(
                    (rng() - 0.5) * 80,
                    (rng() - 0.5) * 50,
                    (rng() - 0.5) * 80
                );
                panel.rotation.set(
                    rng() * Math.PI,
                    rng() * Math.PI,
                    rng() * Math.PI
                );
                panel.castShadow = true;
                scene.add(panel);
            }

            // Debris field
            for (let i = 0; i < 50; i++) {
                const debrisGeometry = new THREE.BoxGeometry(
                    0.2 + rng() * 0.8,
                    0.2 + rng() * 0.8,
                    0.2 + rng() * 0.8
                );
                const debrisMaterial = new THREE.MeshPhongMaterial({
                    color: new THREE.Color().setHSL(rng(), 0.2, 0.4)
                });
                const debris = new THREE.Mesh(debrisGeometry, debrisMaterial);
                debris.position.set(
                    (rng() - 0.5) * 100,
                    (rng() - 0.5) * 60,
                    (rng() - 0.5) * 100
                );
                debris.rotation.set(
                    rng() * Math.PI * 2,
                    rng() * Math.PI * 2,
                    rng() * Math.PI * 2
                );
                scene.add(debris);
            }

            // Stars background
            const starsGeometry = new THREE.BufferGeometry();
            const starsPositions = new Float32Array(1000 * 3);

            for (let i = 0; i < 1000 * 3; i += 3) {
                const theta = rng() * Math.PI * 2;
                const phi = Math.acos(rng() * 2 - 1);
                const r = 200 + rng() * 300;

                starsPositions[i] = r * Math.sin(phi) * Math.cos(theta);
                starsPositions[i + 1] = r * Math.sin(phi) * Math.sin(theta);
                starsPositions[i + 2] = r * Math.cos(phi);
            }

            starsGeometry.setAttribute('position', new THREE.BufferAttribute(starsPositions, 3));

            const starsMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.5
            });

            const stars = new THREE.Points(starsGeometry, starsMaterial);
            scene.add(stars);
        }

        // Avatar Management
        class Avatar {
            constructor(id, name, color) {
                this.id = id;
                this.name = name;
                this.mesh = null;
                this.label = null;
                this.targetPosition = new THREE.Vector3();
                this.targetRotation = new THREE.Euler();

                // Create avatar mesh
                const geometry = new THREE.CapsuleGeometry(0.5, 2, 4, 8);
                const material = new THREE.MeshPhongMaterial({
                    color: color || new THREE.Color().setHSL(Math.random(), 0.7, 0.5),
                    emissive: color || new THREE.Color().setHSL(Math.random(), 0.7, 0.3),
                    emissiveIntensity: 0.3
                });
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.castShadow = true;
                scene.add(this.mesh);
            }

            update(position, rotation) {
                this.targetPosition.set(position.x, position.y, position.z);
                this.targetRotation.set(rotation.x, rotation.y, rotation.z);
            }

            animate() {
                // Smooth interpolation
                this.mesh.position.lerp(this.targetPosition, 0.1);

                // Update rotation
                const currentQuat = new THREE.Quaternion().setFromEuler(this.mesh.rotation);
                const targetQuat = new THREE.Quaternion().setFromEuler(this.targetRotation);
                currentQuat.slerp(targetQuat, 0.1);
                this.mesh.rotation.setFromQuaternion(currentQuat);
            }

            destroy() {
                scene.remove(this.mesh);
                if (this.label) {
                    document.body.removeChild(this.label);
                }
            }
        }

        // Portal System
        class Portal {
            constructor(position, targetPeerId) {
                this.position = position;
                this.targetPeerId = targetPeerId;
                this.mesh = null;

                // Create portal visual
                const geometry = new THREE.TorusGeometry(2, 0.5, 8, 16);
                const material = new THREE.MeshPhongMaterial({
                    color: 0x00ffff,
                    emissive: 0x00ffff,
                    emissiveIntensity: 1,
                    transparent: true,
                    opacity: 0.7
                });
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.copy(position);

                // Add swirl effect
                const swirlGeometry = new THREE.PlaneGeometry(4, 4);
                const swirlMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.3,
                    side: THREE.DoubleSide
                });
                this.swirl = new THREE.Mesh(swirlGeometry, swirlMaterial);
                this.mesh.add(this.swirl);

                scene.add(this.mesh);

                // Portal light
                const light = new THREE.PointLight(0x00ffff, 1, 20);
                light.position.copy(position);
                scene.add(light);
            }

            update() {
                this.mesh.rotation.y += 0.01;
                this.swirl.rotation.z += 0.05;
            }

            checkCollision(playerPos) {
                const distance = this.position.distanceTo(playerPos);
                return distance < 3;
            }
        }

        // Networking - SimplePeer wrapper
        class PeerConnection {
            constructor(isInitiator, onSignal, onConnect, onData, onClose) {
                this.peer = new SimplePeer({
                    initiator: isInitiator,
                    trickle: false
                });

                this.peer.on('signal', onSignal);
                this.peer.on('connect', onConnect);
                this.peer.on('data', onData);
                this.peer.on('close', onClose);
                this.peer.on('error', err => console.error('Peer error:', err));
            }

            signal(data) {
                this.peer.signal(data);
            }

            send(data) {
                if (this.peer.connected) {
                    this.peer.send(JSON.stringify(data));
                }
            }

            destroy() {
                this.peer.destroy();
            }
        }

        // Network message handling
        function handleNetworkMessage(peerId, data) {
            try {
                const message = JSON.parse(data);

                switch(message.type) {
                    case 'world_config':
                        if (!isHost) {
                            worldType = message.worldType;
                            worldSeed = message.seed;
                            generateWorld(worldType, worldSeed);
                            document.getElementById('worldName').textContent = worldConfigs[worldType].name;
                        }
                        break;

                    case 'player_update':
                        if (!avatars.has(peerId)) {
                            const avatar = new Avatar(peerId, message.name);
                            avatars.set(peerId, avatar);
                            updatePlayerList();
                        }
                        const avatar = avatars.get(peerId);
                        avatar.update(message.position, message.rotation);
                        break;

                    case 'chat_message':
                        addChatMessage(message.sender, message.text);
                        break;

                    case 'portal_create':
                        const portal = new Portal(
                            new THREE.Vector3(message.position.x, message.position.y, message.position.z),
                            message.targetPeerId
                        );
                        portals.push(portal);
                        break;

                    case 'player_disconnect':
                        if (avatars.has(peerId)) {
                            avatars.get(peerId).destroy();
                            avatars.delete(peerId);
                            updatePlayerList();
                        }
                        break;
                }
            } catch(e) {
                console.error('Failed to parse network message:', e);
            }
        }

        // Input handling
        function setupControls() {
            // Keyboard
            document.addEventListener('keydown', (e) => {
                if (document.activeElement.tagName === 'INPUT') return;

                switch(e.key.toLowerCase()) {
                    case 'w': controls.forward = true; break;
                    case 's': controls.backward = true; break;
                    case 'a': controls.left = true; break;
                    case 'd': controls.right = true; break;
                    case ' ': controls.jump = true; break;
                    case 'shift': controls.descend = true; break;
                    case 'h': toggleHelp(); break;
                    case 'p': showPortalMenu(); break;
                    case 'escape': showMenu(); break;
                }
            });

            document.addEventListener('keyup', (e) => {
                switch(e.key.toLowerCase()) {
                    case 'w': controls.forward = false; break;
                    case 's': controls.backward = false; break;
                    case 'a': controls.left = false; break;
                    case 'd': controls.right = false; break;
                    case ' ': controls.jump = false; break;
                    case 'shift': controls.descend = false; break;
                }
            });

            // Mouse
            document.addEventListener('mousedown', () => {
                if (!isPointerLocked && world) {
                    document.body.requestPointerLock();
                }
            });

            document.addEventListener('pointerlockchange', () => {
                isPointerLocked = document.pointerLockElement === document.body;
                document.getElementById('crosshair').style.display = isPointerLocked ? 'block' : 'none';
            });

            document.addEventListener('mousemove', (e) => {
                if (isPointerLocked && player) {
                    mouseX -= e.movementX * 0.002;
                    mouseY -= e.movementY * 0.002;
                    mouseY = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, mouseY));

                    player.rotation.y = mouseX;
                    player.rotation.x = mouseY;
                }
            });
        }

        // UI Functions
        function startHosting() {
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('worldSelector').style.display = 'block';
        }

        function createWorld(type) {
            worldType = type;
            isHost = true;
            myPeerId = generateId();

            // Initialize world
            generateWorld(type);
            player = new Player();
            world = true;

            // Setup hosting
            document.getElementById('worldSelector').style.display = 'none';
            document.getElementById('connectionPanel').style.display = 'block';
            document.getElementById('connectionTitle').textContent = 'Your World Code';
            document.getElementById('connectionCode').textContent = myPeerId;
            document.getElementById('connectionHint').textContent = 'Click to copy and share with friends!';
            document.getElementById('connectionButton').textContent = 'Start World';
        }

        function showJoinPanel() {
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('connectionPanel').style.display = 'block';
            document.getElementById('connectionTitle').textContent = 'Join a World';
            document.getElementById('connectionCode').style.display = 'none';
            document.getElementById('connectionHint').textContent = 'Enter the world code from your friend';
            document.getElementById('joinCodeInput').style.display = 'block';
            document.getElementById('connectionButton').textContent = 'Connect';
            document.getElementById('connectionButton').onclick = joinWorld;
        }

        function joinWorld() {
            const code = document.getElementById('joinCodeInput').value.trim();
            if (!code) {
                alert('Please enter a world code');
                return;
            }

            // Create peer connection as joiner
            const peer = new PeerConnection(
                true,
                (signal) => {
                    connectionOffer = JSON.stringify(signal);
                    document.getElementById('connectionCode').textContent = connectionOffer;
                    document.getElementById('connectionCode').style.display = 'block';
                    document.getElementById('connectionHint').textContent = 'Send this to the host';
                },
                () => {
                    console.log('Connected to world!');
                    startGame();
                },
                (data) => handleNetworkMessage('host', data),
                () => {
                    console.log('Disconnected from world');
                    showMenu();
                }
            );

            // Try to connect with the code
            try {
                const signal = JSON.parse(code);
                peer.signal(signal);
                peers.set('host', peer);
            } catch(e) {
                alert('Invalid world code');
            }
        }

        function handleConnection() {
            if (isHost) {
                startGame();
            }
        }

        function startGame() {
            // Hide menus
            document.getElementById('connectionPanel').style.display = 'none';
            document.getElementById('loadingScreen').style.display = 'none';

            // Show game UI
            document.getElementById('hud').style.display = 'block';
            document.getElementById('playerList').style.display = 'block';
            document.getElementById('chat').style.display = 'flex';
            document.getElementById('controlsHelp').style.display = 'block';

            // Update HUD
            document.getElementById('worldName').textContent = worldConfigs[worldType].name;

            // Start game loop
            if (!player) {
                player = new Player();
            }

            animate();
        }

        function showMenu() {
            document.exitPointerLock();
            document.getElementById('mainMenu').style.display = 'block';
            document.getElementById('hud').style.display = 'none';
            document.getElementById('playerList').style.display = 'none';
            document.getElementById('chat').style.display = 'none';
        }

        function hideWorldSelector() {
            document.getElementById('worldSelector').style.display = 'none';
            document.getElementById('mainMenu').style.display = 'block';
        }

        function cancelConnection() {
            document.getElementById('connectionPanel').style.display = 'none';
            document.getElementById('mainMenu').style.display = 'block';

            // Clean up connections
            peers.forEach(peer => peer.destroy());
            peers.clear();
        }

        function copyCode() {
            const code = document.getElementById('connectionCode').textContent;
            navigator.clipboard.writeText(code).then(() => {
                document.getElementById('connectionHint').textContent = 'Copied to clipboard!';
                setTimeout(() => {
                    document.getElementById('connectionHint').textContent = 'Click to copy and share with friends!';
                }, 2000);
            });
        }

        function toggleHelp() {
            const help = document.getElementById('controlsHelp');
            help.style.display = help.style.display === 'block' ? 'none' : 'block';
        }

        function showControls() {
            alert(`Controls:
            â€¢ W A S D - Move
            â€¢ Mouse - Look around
            â€¢ Space - Jump/Ascend
            â€¢ Shift - Descend (Zero-G)
            â€¢ Enter - Chat
            â€¢ P - Create Portal
            â€¢ H - Toggle Help
            â€¢ Esc - Menu`);
        }

        function showPortalMenu() {
            document.getElementById('portalMenu').style.display = 'block';
        }

        function createPortal() {
            const targetCode = document.getElementById('portalTarget').value.trim();
            if (!targetCode) return;

            const portal = new Portal(player.position.clone(), targetCode);
            portals.push(portal);

            // Broadcast to peers
            const message = {
                type: 'portal_create',
                position: player.position,
                targetPeerId: targetCode
            };
            peers.forEach(peer => peer.send(message));

            document.getElementById('portalMenu').style.display = 'none';
            document.getElementById('portalTarget').value = '';
        }

        // Chat system
        function handleChatInput(event) {
            if (event.key === 'Enter') {
                const input = document.getElementById('chatInput');
                const text = input.value.trim();
                if (!text) return;

                const playerName = document.getElementById('playerNameInput').value || 'Explorer';
                addChatMessage(playerName, text);

                // Send to peers
                const message = {
                    type: 'chat_message',
                    sender: playerName,
                    text: text
                };
                peers.forEach(peer => peer.send(message));

                input.value = '';
            }
        }

        function addChatMessage(sender, text) {
            const messages = document.getElementById('chatMessages');
            const message = document.createElement('div');
            message.className = 'chat-message';
            message.innerHTML = `<span class="sender">${sender}:</span> ${text}`;
            messages.appendChild(message);
            messages.scrollTop = messages.scrollHeight;

            // Remove old messages
            while (messages.children.length > 50) {
                messages.removeChild(messages.firstChild);
            }
        }

        function updatePlayerList() {
            const content = document.getElementById('playerListContent');
            content.innerHTML = '';

            // Add self
            const self = document.createElement('div');
            self.className = 'player-item';
            self.textContent = document.getElementById('playerNameInput').value || 'You';
            content.appendChild(self);

            // Add other players
            avatars.forEach((avatar, id) => {
                const player = document.createElement('div');
                player.className = 'player-item';
                player.textContent = avatar.name || `Player ${id.substr(0, 8)}`;
                content.appendChild(player);
            });

            document.getElementById('playerCount').textContent = 1 + avatars.size;
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            const deltaTime = clock.getDelta();

            // Update player
            if (player && world) {
                const config = worldConfigs[worldType];

                // Movement
                player.move(controls, config.moveSpeed);

                // Jumping
                if (controls.jump) {
                    player.jump(config.jumpPower);
                }
                if (controls.descend) {
                    player.descend(config.jumpPower);
                }

                // Physics
                player.update(deltaTime, config);

                // Broadcast position
                if (peers.size > 0) {
                    const message = {
                        type: 'player_update',
                        position: player.position,
                        rotation: player.rotation,
                        name: document.getElementById('playerNameInput').value || 'Explorer'
                    };
                    peers.forEach(peer => peer.send(message));
                }
            }

            // Update avatars
            avatars.forEach(avatar => avatar.animate());

            // Update portals
            portals.forEach(portal => {
                portal.update();
                if (player && portal.checkCollision(player.position)) {
                    // Transport to new world
                    console.log('Entering portal to:', portal.targetPeerId);
                }
            });

            // Update FPS counter
            const fps = Math.round(1 / deltaTime);
            document.getElementById('fpsCounter').textContent = fps;

            // Render
            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
        }

        // Utility functions
        function generateId() {
            return Math.random().toString(36).substr(2, 9) + Date.now().toString(36);
        }

        function mulberry32(seed) {
            return function() {
                let t = seed += 0x6D2B79F5;
                t = Math.imul(t ^ t >>> 15, t | 1);
                t ^= t + Math.imul(t ^ t >>> 7, t | 61);
                return ((t ^ t >>> 14) >>> 0) / 4294967296;
            }
        }

        // Data persistence
        function saveData() {
            localStorage.setItem(APP_NAME, JSON.stringify(appData));
        }

        function exportData() {
            const dataStr = JSON.stringify(appData, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `${APP_NAME}-data-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);
        }

        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    appData = JSON.parse(e.target.result);
                    saveData();
                    location.reload();
                } catch (error) {
                    alert('Invalid JSON file');
                }
            };
            reader.readAsText(file);
        }

        // SimplePeer implementation (inline since we can't use CDN in local-first)
        // Note: In the actual implementation, we would include the full SimplePeer library inline
        // For this demo, we'll use a mock implementation

        window.SimplePeer = class SimplePeer {
            constructor(opts) {
                this.initiator = opts.initiator;
                this.trickle = opts.trickle;
                this.connected = false;
                this._events = {};
            }

            on(event, callback) {
                if (!this._events[event]) {
                    this._events[event] = [];
                }
                this._events[event].push(callback);
            }

            emit(event, data) {
                if (this._events[event]) {
                    this._events[event].forEach(callback => callback(data));
                }
            }

            signal(data) {
                // Mock signal handling
                setTimeout(() => {
                    this.connected = true;
                    this.emit('connect');
                }, 100);
            }

            send(data) {
                // Mock send
                console.log('Sending:', data);
            }

            destroy() {
                this.connected = false;
                this.emit('close');
            }
        };

        // Initialize on load
        window.addEventListener('load', () => {
            initThreeJS();
            setupControls();

            // Load player name from storage
            if (appData.playerName) {
                document.getElementById('playerNameInput').value = appData.playerName;
            }

            // Hide loading screen
            setTimeout(() => {
                document.getElementById('loadingScreen').style.display = 'none';
            }, 1000);
        });

        // Save player name on change
        document.getElementById('playerNameInput')?.addEventListener('change', (e) => {
            appData.playerName = e.target.value;
            saveData();
        });
    </script>
</body>
</html>