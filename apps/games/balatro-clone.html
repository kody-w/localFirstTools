<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Balatro Clone - Full Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: radial-gradient(ellipse at center, #1e3c72 0%, #2a5298 50%, #0f1e3d 100%);
            color: #fff;
            min-height: 100vh;
            overflow: hidden;
            position: relative;
        }

        body::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: 
                repeating-linear-gradient(
                    45deg,
                    transparent,
                    transparent 35px,
                    rgba(255, 255, 255, 0.02) 35px,
                    rgba(255, 255, 255, 0.02) 70px
                );
            pointer-events: none;
        }

        .game-container {
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
            position: relative;
            z-index: 1;
        }

        .header {
            background: linear-gradient(180deg, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0.6) 100%);
            padding: 15px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 3px solid rgba(255, 215, 0, 0.3);
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }

        .score-section {
            display: flex;
            gap: 40px;
            align-items: center;
        }

        .score-item {
            text-align: center;
        }

        .score-label {
            font-size: 12px;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 5px;
        }

        .score-value {
            font-size: 28px;
            font-weight: bold;
            color: #ffd700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        .chips-value {
            color: #4ecdc4;
        }

        .money-value {
            color: #85bb65;
        }

        .blind-info {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            padding: 12px 25px;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            box-shadow: 0 4px 15px rgba(231, 76, 60, 0.4);
        }

        .blind-name {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .blind-requirement {
            font-size: 20px;
            color: #fff;
        }

        .round-info {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: rgba(0,0,0,0.4);
            padding: 10px 20px;
            border-radius: 8px;
        }

        .ante-display {
            font-size: 14px;
            color: #aaa;
            margin-bottom: 3px;
        }

        .round-display {
            font-size: 18px;
            font-weight: bold;
            color: #fff;
        }

        .hands-remaining {
            background: rgba(102, 126, 234, 0.3);
            padding: 8px 15px;
            border-radius: 6px;
            font-size: 16px;
        }

        .discards-remaining {
            background: rgba(245, 87, 108, 0.3);
            padding: 8px 15px;
            border-radius: 6px;
            font-size: 16px;
        }

        .main-content {
            flex: 1;
            display: flex;
            padding: 20px;
            gap: 20px;
            overflow: hidden;
        }

        .left-panel {
            width: 250px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .jokers-container {
            background: rgba(0,0,0,0.5);
            border-radius: 12px;
            padding: 15px;
            border: 2px solid rgba(255, 215, 0, 0.3);
        }

        .section-title {
            font-size: 14px;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .joker-slots {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .joker-slot {
            aspect-ratio: 2/3;
            background: rgba(255, 255, 255, 0.05);
            border: 2px dashed rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            transition: all 0.3s ease;
        }

        .joker-slot.filled {
            background: linear-gradient(135deg, #667eea, #764ba2);
            border: 2px solid #ffd700;
            cursor: pointer;
        }

        .joker-slot.filled:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.5);
        }

        .joker-card {
            width: 100%;
            height: 100%;
            padding: 5px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
        }

        .joker-icon {
            font-size: 24px;
            margin-bottom: 5px;
        }

        .joker-name {
            font-size: 10px;
            font-weight: bold;
            margin-bottom: 3px;
        }

        .joker-desc {
            font-size: 8px;
            color: #ddd;
            line-height: 1.2;
        }

        .mult-chips-display {
            background: rgba(0,0,0,0.5);
            border-radius: 12px;
            padding: 15px;
            border: 2px solid rgba(78, 205, 196, 0.3);
        }

        .mult-chips-values {
            display: flex;
            justify-content: space-around;
            margin-top: 10px;
        }

        .mult-display, .chips-display {
            text-align: center;
        }

        .mult-label, .chips-label {
            font-size: 12px;
            color: #aaa;
            margin-bottom: 5px;
        }

        .mult-value {
            font-size: 32px;
            font-weight: bold;
            color: #e74c3c;
        }

        .chips-value-large {
            font-size: 32px;
            font-weight: bold;
            color: #3498db;
        }

        .center-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .played-cards-area {
            background: rgba(0,0,0,0.4);
            border-radius: 15px;
            padding: 20px;
            min-height: 200px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .played-cards {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
            min-height: 140px;
            margin-bottom: 15px;
        }

        .hand-evaluation {
            text-align: center;
            padding: 10px;
        }

        .hand-name {
            font-size: 28px;
            font-weight: bold;
            color: #ffd700;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        .hand-score-preview {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            font-size: 20px;
        }

        .score-mult {
            color: #e74c3c;
        }

        .score-chips {
            color: #3498db;
        }

        .score-total {
            color: #ffd700;
            font-weight: bold;
            font-size: 24px;
        }

        .hand-area {
            background: rgba(0,0,0,0.4);
            border-radius: 15px;
            padding: 20px;
            border: 2px solid rgba(255, 255, 255, 0.1);
        }

        .hand-cards {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
            min-height: 160px;
            margin-bottom: 20px;
        }

        .card {
            width: 110px;
            height: 160px;
            background: linear-gradient(135deg, #ffffff, #f0f0f0);
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            border: 3px solid #333;
            user-select: none;
        }

        .card:hover {
            transform: translateY(-10px);
            box-shadow: 0 8px 16px rgba(0,0,0,0.4);
        }

        .card.selected {
            transform: translateY(-25px);
            box-shadow: 0 12px 24px rgba(0,0,0,0.5), 0 0 30px rgba(78, 205, 196, 0.6);
            border-color: #4ecdc4;
            background: linear-gradient(135deg, #fffef0, #fff9e0);
        }

        .card.enhanced {
            background: linear-gradient(135deg, #f0f0ff, #e0e0ff);
        }

        .card.enhanced.gold {
            background: linear-gradient(135deg, #fff9e0, #ffed4e);
            border-color: #ffd700;
        }

        .card.enhanced.steel {
            background: linear-gradient(135deg, #e0e0e0, #c0c0c0);
            border-color: #808080;
        }

        .card.enhanced.glass {
            background: linear-gradient(135deg, #e0f0ff, #c0e0ff);
            border-color: #00bfff;
        }

        .card-face {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .card-rank {
            font-size: 42px;
            font-weight: bold;
            line-height: 1;
        }

        .card-suit {
            font-size: 36px;
            margin-top: 5px;
        }

        .card.red .card-rank, .card.red .card-suit {
            color: #e74c3c;
        }

        .card.black .card-rank, .card.black .card-suit {
            color: #2c3e50;
        }

        .card-enhancement {
            position: absolute;
            top: 5px;
            right: 5px;
            font-size: 12px;
            padding: 2px 5px;
            border-radius: 3px;
            background: rgba(0,0,0,0.5);
            color: #fff;
            font-weight: bold;
        }

        .card-seal {
            position: absolute;
            top: 5px;
            left: 5px;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
        }

        .seal-gold {
            background: #ffd700;
            color: #333;
        }

        .seal-red {
            background: #e74c3c;
            color: #fff;
        }

        .seal-blue {
            background: #3498db;
            color: #fff;
        }

        .seal-purple {
            background: #9b59b6;
            color: #fff;
        }

        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .btn {
            padding: 12px 30px;
            font-size: 16px;
            font-weight: bold;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-play {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }

        .btn-play:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5);
        }

        .btn-discard {
            background: linear-gradient(135deg, #f093fb, #f5576c);
            color: white;
        }

        .btn-discard:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(245, 87, 108, 0.5);
        }

        .btn-sort {
            background: linear-gradient(135deg, #4facfe, #00f2fe);
            color: white;
        }

        .btn-sort:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(79, 172, 254, 0.5);
        }

        .btn-end-round {
            background: linear-gradient(135deg, #fa709a, #fee140);
            color: #333;
        }

        .btn-end-round:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(250, 112, 154, 0.5);
        }

        .right-panel {
            width: 250px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .hand-levels {
            background: rgba(0,0,0,0.5);
            border-radius: 12px;
            padding: 15px;
            border: 2px solid rgba(255, 215, 0, 0.3);
            max-height: 400px;
            overflow-y: auto;
        }

        .hand-level-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            margin-bottom: 5px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            transition: all 0.3s ease;
        }

        .hand-level-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .hand-level-name {
            font-size: 12px;
            font-weight: bold;
        }

        .hand-level-stats {
            display: flex;
            gap: 10px;
            font-size: 11px;
        }

        .hand-level-mult {
            color: #e74c3c;
        }

        .hand-level-chips {
            color: #3498db;
        }

        .hand-level-level {
            color: #ffd700;
            font-weight: bold;
        }

        .planet-cards {
            background: rgba(0,0,0,0.5);
            border-radius: 12px;
            padding: 15px;
            border: 2px solid rgba(155, 89, 182, 0.3);
        }

        .planet-card-list {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 10px;
        }

        .planet-card {
            background: linear-gradient(135deg, #9b59b6, #8e44ad);
            border-radius: 6px;
            padding: 8px;
            text-align: center;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid #ffd700;
        }

        .planet-card:hover {
            transform: scale(1.05);
            box-shadow: 0 3px 10px rgba(155, 89, 182, 0.5);
        }

        .planet-card.usable {
            cursor: pointer;
            position: relative;
        }

        .planet-card.usable:hover::after {
            content: 'Click to use';
            position: absolute;
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 8px;
            color: #ffd700;
            white-space: nowrap;
        }

        .shop-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .shop-modal.active {
            display: flex;
        }

        .shop-content {
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            border-radius: 20px;
            padding: 30px;
            max-width: 1000px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            border: 3px solid #ffd700;
            box-shadow: 0 10px 40px rgba(0,0,0,0.8);
        }

        .shop-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 15px;
            border-bottom: 2px solid rgba(255, 215, 0, 0.3);
        }

        .shop-title {
            font-size: 32px;
            font-weight: bold;
            color: #ffd700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        .shop-money {
            font-size: 24px;
            color: #85bb65;
            font-weight: bold;
        }

        .close-shop {
            font-size: 30px;
            cursor: pointer;
            color: #fff;
            background: none;
            border: none;
            transition: transform 0.3s ease;
        }

        .close-shop:hover {
            transform: rotate(90deg);
        }

        .shop-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .shop-tab {
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .shop-tab.active {
            background: rgba(255, 215, 0, 0.2);
            border-color: #ffd700;
        }

        .shop-items {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 15px;
        }

        .shop-item {
            background: rgba(0,0,0,0.4);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
            position: relative;
        }

        .shop-item:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: #4ecdc4;
            transform: translateY(-5px);
            box-shadow: 0 5px 20px rgba(78, 205, 196, 0.3);
        }

        .shop-item.purchased {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .shop-item-icon {
            font-size: 36px;
            margin-bottom: 10px;
        }

        .shop-item-name {
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 8px;
            color: #4ecdc4;
        }

        .shop-item-desc {
            font-size: 11px;
            color: #aaa;
            margin-bottom: 10px;
            line-height: 1.3;
        }

        .shop-item-price {
            font-size: 16px;
            font-weight: bold;
            color: #85bb65;
        }

        .reroll-btn {
            margin-top: 20px;
            width: 100%;
            padding: 10px;
            background: linear-gradient(135deg, #f39c12, #e67e22);
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .reroll-btn:hover {
            transform: scale(1.02);
            box-shadow: 0 5px 20px rgba(243, 156, 18, 0.4);
        }

        .game-over-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }

        .game-over-modal.active {
            display: flex;
        }

        .game-over-content {
            background: linear-gradient(135deg, #2c3e50, #34495e);
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            border: 3px solid #e74c3c;
            box-shadow: 0 10px 40px rgba(0,0,0,0.8);
        }

        .game-over-title {
            font-size: 48px;
            font-weight: bold;
            color: #e74c3c;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        .game-over-stats {
            font-size: 20px;
            margin-bottom: 30px;
            color: #fff;
        }

        .restart-btn {
            padding: 15px 40px;
            font-size: 20px;
            font-weight: bold;
            background: linear-gradient(135deg, #27ae60, #2ecc71);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .restart-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 20px rgba(46, 204, 113, 0.5);
        }

        .notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px 40px;
            background: rgba(0,0,0,0.9);
            border: 2px solid #ffd700;
            border-radius: 10px;
            font-size: 24px;
            font-weight: bold;
            color: #ffd700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 3000;
            animation: notificationPulse 0.5s ease-out;
        }

        @keyframes notificationPulse {
            0% {
                transform: translate(-50%, -50%) scale(0.8);
                opacity: 0;
            }
            50% {
                transform: translate(-50%, -50%) scale(1.1);
            }
            100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
        }

        .tarot-cards {
            background: rgba(0,0,0,0.5);
            border-radius: 12px;
            padding: 15px;
            border: 2px solid rgba(233, 30, 99, 0.3);
        }

        .tarot-card-list {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 10px;
        }

        .tarot-card {
            background: linear-gradient(135deg, #e91e63, #c2185b);
            border-radius: 6px;
            padding: 8px;
            text-align: center;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid #ffd700;
        }

        .tarot-card:hover {
            transform: scale(1.05);
            box-shadow: 0 3px 10px rgba(233, 30, 99, 0.5);
        }

        .tarot-card.usable {
            cursor: pointer;
            position: relative;
        }

        .tarot-card.usable:hover::after {
            content: 'Click to use';
            position: absolute;
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 8px;
            color: #ffd700;
            white-space: nowrap;
        }

        .voucher-display {
            background: rgba(0,0,0,0.5);
            border-radius: 12px;
            padding: 15px;
            border: 2px solid rgba(76, 175, 80, 0.3);
            margin-bottom: 15px;
        }

        .voucher-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 10px;
        }

        .voucher-item {
            background: linear-gradient(135deg, #4caf50, #388e3c);
            border-radius: 6px;
            padding: 8px;
            font-size: 11px;
            border: 1px solid #ffd700;
        }

        .deck-info {
            background: rgba(0,0,0,0.5);
            border-radius: 12px;
            padding: 15px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            margin-bottom: 15px;
        }

        .deck-stats {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
            font-size: 14px;
        }

        .data-controls {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 10000;
            display: flex;
            gap: 10px;
        }

        .data-controls button {
            padding: 8px 16px;
            background: rgba(0,0,0,0.8);
            color: white;
            border: 2px solid #ffd700;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .data-controls button:hover {
            background: rgba(255, 215, 0, 0.2);
            transform: translateY(-2px);
        }

        .data-controls input[type="file"] {
            display: none;
        }

        .progress-bar-container {
            position: relative;
            width: 300px;
            height: 30px;
            background: rgba(0,0,0,0.5);
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 15px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #4ecdc4, #44a3a3);
            transition: width 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 14px;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }

        .progress-bar.winning {
            background: linear-gradient(90deg, #27ae60, #2ecc71);
        }

        .progress-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 14px;
            font-weight: bold;
            color: #fff;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            pointer-events: none;
        }

        .tooltip {
            position: fixed;
            background: rgba(0,0,0,0.95);
            border: 2px solid #ffd700;
            border-radius: 8px;
            padding: 12px;
            font-size: 13px;
            z-index: 10000;
            pointer-events: none;
            max-width: 300px;
            display: none;
            line-height: 1.5;
            box-shadow: 0 5px 20px rgba(0,0,0,0.8);
        }

        .tooltip.active {
            display: block;
        }

        .tooltip-title {
            font-weight: bold;
            color: #ffd700;
            margin-bottom: 5px;
            font-size: 14px;
        }

        .tooltip-desc {
            color: #ddd;
            margin-bottom: 5px;
        }

        .tooltip-effect {
            color: #4ecdc4;
            font-style: italic;
        }

        .combo-text {
            position: fixed;
            font-size: 36px;
            font-weight: bold;
            color: #ffd700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 5000;
            animation: comboFloat 2s ease-out forwards;
            pointer-events: none;
        }

        @keyframes comboFloat {
            0% {
                transform: translate(-50%, -50%) scale(0.5);
                opacity: 0;
            }
            50% {
                transform: translate(-50%, -60%) scale(1.2);
                opacity: 1;
            }
            100% {
                transform: translate(-50%, -80%) scale(1);
                opacity: 0;
            }
        }

        .multiplier-animation {
            position: fixed;
            font-size: 28px;
            font-weight: bold;
            color: #e74c3c;
            z-index: 5000;
            animation: multFloat 1.5s ease-out forwards;
            pointer-events: none;
        }

        @keyframes multFloat {
            0% {
                transform: translateY(0);
                opacity: 1;
            }
            100% {
                transform: translateY(-50px);
                opacity: 0;
            }
        }

        @media (max-width: 1400px) {
            .left-panel, .right-panel {
                width: 200px;
            }
            .card {
                width: 90px;
                height: 130px;
            }
            .card-rank {
                font-size: 32px;
            }
            .card-suit {
                font-size: 28px;
            }
        }

        @media (max-width: 1024px) {
            .main-content {
                flex-direction: column;
            }

            .left-panel, .right-panel {
                width: 100%;
                flex-direction: row;
                overflow-x: auto;
            }

            .jokers-container, .mult-chips-display, .hand-levels,
            .planet-cards, .tarot-cards, .deck-info, .voucher-display {
                flex: 1;
                min-width: 200px;
            }

            .left-panel, .right-panel {
                display: flex;
                gap: 10px;
            }

            .score-section {
                gap: 20px;
            }

            .progress-bar-container {
                width: 200px;
            }
        }

        @media (max-width: 768px) {
            .header {
                flex-wrap: wrap;
                padding: 10px 15px;
            }

            .score-section {
                gap: 15px;
                flex-wrap: wrap;
            }

            .score-value {
                font-size: 20px;
            }

            .blind-info {
                margin: 10px 0;
            }

            .card {
                width: 70px;
                height: 100px;
            }

            .card-rank {
                font-size: 28px;
            }

            .card-suit {
                font-size: 24px;
            }

            .btn {
                padding: 10px 20px;
                font-size: 14px;
            }

            .controls {
                flex-wrap: wrap;
            }

            .shop-content {
                width: 95%;
                padding: 20px;
            }

            .shop-items {
                grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            }

            .data-controls {
                top: 5px;
                right: 5px;
                gap: 5px;
            }

            .data-controls button {
                padding: 6px 12px;
                font-size: 10px;
            }

            .progress-bar-container {
                width: 150px;
            }

            .hand-level-item {
                font-size: 10px;
            }
        }

        @media (max-width: 480px) {
            .header {
                flex-direction: column;
                align-items: stretch;
            }

            .score-section {
                justify-content: space-around;
            }

            .card {
                width: 60px;
                height: 85px;
            }

            .card-rank {
                font-size: 24px;
            }

            .card-suit {
                font-size: 20px;
            }

            .btn {
                padding: 8px 15px;
                font-size: 12px;
            }

            .shop-items {
                grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            }

            .joker-slots {
                grid-template-columns: 1fr;
            }

            .game-over-content {
                padding: 20px;
            }

            .game-over-title {
                font-size: 32px;
            }
        }

        .boss-blind-indicator {
            position: absolute;
            top: -10px;
            right: -10px;
            background: linear-gradient(135deg, #ff6b6b, #ff0000);
            color: white;
            padding: 3px 8px;
            border-radius: 5px;
            font-size: 10px;
            font-weight: bold;
            text-transform: uppercase;
            animation: bossPulse 2s infinite;
        }

        @keyframes bossPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .spectral-card {
            background: linear-gradient(135deg, #b366ff, #7f39fb);
            animation: spectralGlow 3s infinite;
        }

        @keyframes spectralGlow {
            0%, 100% { box-shadow: 0 0 10px rgba(179, 102, 255, 0.5); }
            50% { box-shadow: 0 0 20px rgba(179, 102, 255, 0.8); }
        }

        /* ===== NEW VISUAL EFFECTS ===== */

        /* Card Deal Animation */
        @keyframes cardDeal {
            from {
                transform: translateX(200px) translateY(200px) rotateZ(-15deg) scale(0.8);
                opacity: 0;
            }
            to {
                transform: translateX(0) translateY(0) rotateZ(0) scale(1);
                opacity: 1;
            }
        }

        .card.dealing {
            animation: cardDeal 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
        }

        /* Card Selection Glow */
        @keyframes selectedGlow {
            0%, 100% {
                box-shadow: 0 0 20px rgba(78, 205, 196, 0.5), inset 0 0 10px rgba(78, 205, 196, 0.2);
            }
            50% {
                box-shadow: 0 0 35px rgba(78, 205, 196, 0.8), inset 0 0 15px rgba(78, 205, 196, 0.4);
            }
        }

        .card.selected {
            animation: selectedGlow 1.5s ease-in-out infinite;
        }

        /* Card Discard Animation */
        @keyframes cardDiscard {
            0% {
                transform: translateY(0) rotateZ(0) scale(1);
                opacity: 1;
            }
            100% {
                transform: translateY(300px) rotateZ(45deg) scale(0.6);
                opacity: 0;
            }
        }

        .card.discarding {
            animation: cardDiscard 0.5s ease-in forwards;
        }

        /* Enhancement Glimmer */
        @keyframes glimmer {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.3); }
        }

        .card.enhanced.gold {
            animation: glimmer 2s ease-in-out infinite;
        }

        /* Joker Pulse */
        @keyframes jokerPulse {
            0%, 100% {
                box-shadow: 0 0 20px rgba(102, 126, 234, 0.5), inset 0 0 10px rgba(102, 126, 234, 0.2);
            }
            50% {
                box-shadow: 0 0 40px rgba(102, 126, 234, 0.8), inset 0 0 20px rgba(102, 126, 234, 0.4);
            }
        }

        .joker-slot.filled {
            animation: jokerPulse 3s ease-in-out infinite;
        }

        /* Screen Shake */
        @keyframes screenShake {
            0%, 100% { transform: translate(0, 0); }
            10%, 30%, 50%, 70%, 90% { transform: translate(-3px, -3px); }
            20%, 40%, 60%, 80% { transform: translate(3px, 3px); }
        }

        .game-container.shaking {
            animation: screenShake 0.4s ease-in-out;
        }

        /* Score Burst */
        @keyframes scoreBurst {
            0% {
                transform: translate(-50%, -50%) scale(0.5);
                opacity: 0;
            }
            30% {
                transform: translate(-50%, -50%) scale(1.3);
                opacity: 1;
            }
            100% {
                transform: translate(-50%, -80%) scale(1);
                opacity: 0;
            }
        }

        .score-burst {
            position: fixed;
            font-size: 48px;
            font-weight: bold;
            color: #ffd700;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.8), 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 5000;
            animation: scoreBurst 1.5s ease-out forwards;
            pointer-events: none;
        }

        /* Particle System */
        @keyframes particleFloat {
            0% {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
            100% {
                transform: translateY(-100px) scale(0.5);
                opacity: 0;
            }
        }

        .particle {
            position: fixed;
            pointer-events: none;
            z-index: 4999;
            animation: particleFloat 1s ease-out forwards;
        }

        /* Blind Pulse */
        @keyframes blindPulse {
            0%, 100% { transform: scale(1); box-shadow: 0 4px 15px rgba(231, 76, 60, 0.4); }
            50% { transform: scale(1.02); box-shadow: 0 4px 25px rgba(231, 76, 60, 0.7); }
        }

        .blind-info.pulsing {
            animation: blindPulse 1s ease-in-out infinite;
        }

        /* Win Flash */
        @keyframes winFlash {
            0% { background-color: rgba(46, 204, 113, 0.6); }
            100% { background-color: transparent; }
        }

        .win-flash {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 4000;
            animation: winFlash 0.5s ease-out forwards;
            pointer-events: none;
        }

        /* Consumable Glow */
        @keyframes consumableGlow {
            0%, 100% { box-shadow: 0 0 10px rgba(155, 89, 182, 0.3); }
            50% { box-shadow: 0 0 25px rgba(155, 89, 182, 0.7); }
        }

        .planet-card.usable, .tarot-card.usable {
            animation: consumableGlow 2s ease-in-out infinite;
        }

        /* Hand Name Bounce */
        @keyframes handNameBounce {
            0% { transform: scale(0.5); opacity: 0; }
            60% { transform: scale(1.15); }
            100% { transform: scale(1); opacity: 1; }
        }

        .hand-name.animating {
            animation: handNameBounce 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
        }

        /* Progress Bar Shimmer */
        @keyframes progressShimmer {
            0% { background-position: -200px 0; }
            100% { background-position: 200px 0; }
        }

        .progress-bar {
            background-image: linear-gradient(
                90deg,
                transparent,
                rgba(255, 255, 255, 0.3),
                transparent
            );
            background-size: 200px 100%;
            animation: progressShimmer 2s infinite linear;
        }

        /* Combo Display */
        .combo-display {
            position: fixed;
            top: 120px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(255, 107, 107, 0.9), rgba(255, 193, 7, 0.9));
            padding: 10px 25px;
            border-radius: 25px;
            font-size: 18px;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            z-index: 3000;
            transition: all 0.3s ease;
            border: 2px solid rgba(255, 255, 255, 0.5);
            box-shadow: 0 5px 20px rgba(255, 107, 107, 0.5);
        }

        .combo-display.hidden {
            opacity: 0;
            transform: translateX(-50%) translateY(-20px);
        }

        /* Achievement Notification */
        .achievement-notification {
            position: fixed;
            top: 80px;
            right: 20px;
            background: linear-gradient(135deg, #2c3e50, #34495e);
            border: 3px solid #ffd700;
            border-radius: 15px;
            padding: 20px;
            max-width: 320px;
            z-index: 10001;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            animation: achievementSlideIn 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
        }

        @keyframes achievementSlideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .achievement-notification.fade-out {
            animation: achievementSlideOut 0.5s ease-in forwards;
        }

        @keyframes achievementSlideOut {
            to {
                transform: translateX(400px);
                opacity: 0;
            }
        }

        .achievement-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .achievement-icon {
            font-size: 32px;
        }

        .achievement-title {
            font-size: 14px;
            color: #ffd700;
            font-weight: bold;
        }

        .achievement-name {
            font-size: 18px;
            color: white;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .achievement-desc {
            font-size: 12px;
            color: #aaa;
            margin-bottom: 10px;
        }

        .achievement-points {
            font-size: 14px;
            color: #4ecdc4;
            font-weight: bold;
        }

        .achievement-rarity {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 10px;
            font-weight: bold;
            margin-left: 10px;
        }

        .achievement-rarity.common { background: #95a5a6; color: white; }
        .achievement-rarity.uncommon { background: #27ae60; color: white; }
        .achievement-rarity.rare { background: #3498db; color: white; }
        .achievement-rarity.epic { background: #9b59b6; color: white; }
        .achievement-rarity.legendary { background: linear-gradient(135deg, #f1c40f, #e67e22); color: #2c3e50; }

        /* Achievement Button */
        .achievement-btn {
            padding: 8px 16px;
            background: rgba(0,0,0,0.8);
            color: #ffd700;
            border: 2px solid #ffd700;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .achievement-btn:hover {
            background: rgba(255, 215, 0, 0.2);
            transform: translateY(-2px);
        }

        /* Achievement Modal */
        .achievement-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 10002;
            justify-content: center;
            align-items: center;
        }

        .achievement-modal.active {
            display: flex;
        }

        .achievement-modal-content {
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            border-radius: 20px;
            padding: 30px;
            max-width: 800px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            border: 3px solid #ffd700;
        }

        .achievement-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .achievement-card {
            background: rgba(0,0,0,0.4);
            border-radius: 10px;
            padding: 15px;
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }

        .achievement-card.unlocked {
            border-color: #ffd700;
            background: rgba(255, 215, 0, 0.1);
        }

        .achievement-card.locked {
            opacity: 0.5;
            filter: grayscale(0.5);
        }

        .achievement-card-icon {
            font-size: 36px;
            text-align: center;
            margin-bottom: 10px;
        }

        .achievement-card-name {
            font-size: 14px;
            font-weight: bold;
            color: #4ecdc4;
            text-align: center;
            margin-bottom: 5px;
        }

        .achievement-card-desc {
            font-size: 11px;
            color: #aaa;
            text-align: center;
        }

        .achievement-progress-bar {
            width: 100%;
            height: 6px;
            background: rgba(255,255,255,0.2);
            border-radius: 3px;
            margin-top: 10px;
            overflow: hidden;
        }

        .achievement-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4ecdc4, #44a3a3);
            transition: width 0.3s ease;
        }

        /* Streak Fire Effect */
        @keyframes fireGlow {
            0%, 100% { text-shadow: 0 0 10px #ff6b6b, 0 0 20px #ff6b6b; }
            50% { text-shadow: 0 0 20px #ff6b6b, 0 0 40px #ff6b6b, 0 0 60px #e74c3c; }
        }

        .streak-fire {
            animation: fireGlow 0.5s ease-in-out infinite;
        }

        /* Settings Modal */
        .settings-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 10003;
            justify-content: center;
            align-items: center;
        }

        .settings-modal.active {
            display: flex;
        }

        .settings-content {
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            border-radius: 20px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            border: 3px solid #ffd700;
        }

        .settings-section {
            margin-bottom: 25px;
        }

        .settings-section-title {
            font-size: 16px;
            font-weight: bold;
            color: #ffd700;
            margin-bottom: 15px;
            padding-bottom: 5px;
            border-bottom: 1px solid rgba(255,215,0,0.3);
        }

        .settings-option {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding: 10px;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
        }

        .settings-label {
            font-size: 14px;
            color: #fff;
        }

        .settings-label small {
            display: block;
            font-size: 11px;
            color: #aaa;
            margin-top: 3px;
        }

        .settings-select, .settings-input {
            padding: 8px 15px;
            border-radius: 5px;
            border: 2px solid rgba(255,215,0,0.5);
            background: rgba(0,0,0,0.5);
            color: white;
            font-size: 14px;
            cursor: pointer;
        }

        .settings-select:focus, .settings-input:focus {
            outline: none;
            border-color: #ffd700;
        }

        .settings-toggle {
            position: relative;
            width: 50px;
            height: 26px;
            background: rgba(255,255,255,0.2);
            border-radius: 13px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .settings-toggle.active {
            background: #4ecdc4;
        }

        .settings-toggle::after {
            content: '';
            position: absolute;
            top: 3px;
            left: 3px;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s;
        }

        .settings-toggle.active::after {
            transform: translateX(24px);
        }

        .keyboard-shortcuts {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .shortcut-item {
            display: flex;
            justify-content: space-between;
            padding: 8px;
            background: rgba(0,0,0,0.3);
            border-radius: 5px;
            font-size: 12px;
        }

        .shortcut-key {
            background: rgba(255,215,0,0.3);
            padding: 2px 8px;
            border-radius: 3px;
            font-weight: bold;
            color: #ffd700;
        }

        .seed-display {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .seed-input {
            flex: 1;
            padding: 8px;
            border-radius: 5px;
            border: 2px solid rgba(255,215,0,0.5);
            background: rgba(0,0,0,0.5);
            color: white;
            font-family: monospace;
        }

        .seed-btn {
            padding: 8px 15px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }

        .seed-btn:hover {
            transform: scale(1.05);
        }

        .difficulty-badge {
            display: inline-block;
            padding: 3px 10px;
            border-radius: 15px;
            font-size: 11px;
            font-weight: bold;
            margin-left: 10px;
        }

        .difficulty-badge.easy { background: #27ae60; }
        .difficulty-badge.normal { background: #3498db; }
        .difficulty-badge.hard { background: #e74c3c; }
        .difficulty-badge.nightmare { background: linear-gradient(135deg, #8e44ad, #c0392b); }

        /* ===== TUTORIAL SYSTEM ===== */
        .tutorial-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            z-index: 20000;
            justify-content: center;
            align-items: center;
        }

        .tutorial-overlay.active {
            display: flex;
        }

        .tutorial-content {
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            border-radius: 20px;
            padding: 40px;
            max-width: 600px;
            width: 90%;
            border: 3px solid #ffd700;
            box-shadow: 0 10px 60px rgba(255, 215, 0, 0.3);
            position: relative;
            animation: tutorialFadeIn 0.5s ease-out;
        }

        @keyframes tutorialFadeIn {
            from {
                opacity: 0;
                transform: scale(0.9) translateY(20px);
            }
            to {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        .tutorial-header {
            text-align: center;
            margin-bottom: 25px;
        }

        .tutorial-title {
            font-size: 32px;
            font-weight: bold;
            color: #ffd700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            margin-bottom: 5px;
        }

        .tutorial-step-indicator {
            font-size: 14px;
            color: #aaa;
        }

        .tutorial-body {
            margin-bottom: 30px;
        }

        .tutorial-icon {
            font-size: 64px;
            text-align: center;
            margin-bottom: 20px;
        }

        .tutorial-text {
            font-size: 16px;
            line-height: 1.8;
            color: #fff;
            text-align: center;
        }

        .tutorial-text strong {
            color: #ffd700;
        }

        .tutorial-highlight {
            background: rgba(255, 215, 0, 0.2);
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            border-left: 4px solid #ffd700;
        }

        .tutorial-list {
            text-align: left;
            margin: 15px auto;
            max-width: 400px;
        }

        .tutorial-list li {
            margin-bottom: 10px;
            padding-left: 10px;
        }

        .tutorial-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .tutorial-btn {
            padding: 12px 30px;
            font-size: 16px;
            font-weight: bold;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .tutorial-btn-skip {
            background: transparent;
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: #aaa;
        }

        .tutorial-btn-skip:hover {
            border-color: #fff;
            color: #fff;
        }

        .tutorial-btn-next {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .tutorial-btn-next:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        .tutorial-btn-start {
            background: linear-gradient(135deg, #27ae60, #2ecc71);
            color: white;
            padding: 15px 40px;
            font-size: 18px;
        }

        .tutorial-btn-start:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(46, 204, 113, 0.5);
        }

        .tutorial-progress {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-top: 20px;
        }

        .tutorial-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transition: all 0.3s ease;
        }

        .tutorial-dot.active {
            background: #ffd700;
            transform: scale(1.2);
        }

        .tutorial-dot.completed {
            background: #4ecdc4;
        }

        /* Daily Challenge Banner */
        .daily-challenge-banner {
            position: fixed;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, #9b59b6, #8e44ad);
            padding: 10px 25px;
            border-radius: 25px;
            font-size: 14px;
            font-weight: bold;
            color: white;
            z-index: 2500;
            border: 2px solid #ffd700;
            cursor: pointer;
            transition: all 0.3s ease;
            display: none;
        }

        .daily-challenge-banner.active {
            display: block;
            animation: bannerBounce 2s ease-in-out infinite;
        }

        @keyframes bannerBounce {
            0%, 100% { transform: translateX(-50%) translateY(0); }
            50% { transform: translateX(-50%) translateY(-5px); }
        }

        .daily-challenge-banner:hover {
            transform: translateX(-50%) scale(1.05);
        }

        /* Leaderboard Modal */
        .leaderboard-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 10004;
            justify-content: center;
            align-items: center;
        }

        .leaderboard-modal.active {
            display: flex;
        }

        .leaderboard-content {
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            border-radius: 20px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            border: 3px solid #ffd700;
        }

        .leaderboard-entry {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            margin-bottom: 8px;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            transition: all 0.3s ease;
        }

        .leaderboard-entry:hover {
            background: rgba(255,255,255,0.1);
        }

        .leaderboard-entry.gold {
            background: rgba(255, 215, 0, 0.2);
            border: 1px solid #ffd700;
        }

        .leaderboard-entry.silver {
            background: rgba(192, 192, 192, 0.2);
            border: 1px solid #c0c0c0;
        }

        .leaderboard-entry.bronze {
            background: rgba(205, 127, 50, 0.2);
            border: 1px solid #cd7f32;
        }

        .leaderboard-rank {
            font-size: 20px;
            font-weight: bold;
            width: 40px;
            text-align: center;
        }

        .leaderboard-info {
            flex: 1;
            margin-left: 15px;
        }

        .leaderboard-score {
            font-size: 18px;
            font-weight: bold;
            color: #ffd700;
        }

        .leaderboard-details {
            font-size: 12px;
            color: #aaa;
        }

        .leaderboard-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .leaderboard-tab {
            padding: 8px 16px;
            background: rgba(255,255,255,0.1);
            border: 2px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            color: white;
        }

        .leaderboard-tab.active {
            background: rgba(255, 215, 0, 0.2);
            border-color: #ffd700;
        }

        /* Deck Selection */
        .deck-select-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.95);
            z-index: 10005;
            justify-content: center;
            align-items: center;
        }

        .deck-select-modal.active {
            display: flex;
        }

        .deck-select-content {
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            border-radius: 20px;
            padding: 30px;
            max-width: 900px;
            width: 95%;
            max-height: 85vh;
            overflow-y: auto;
            border: 3px solid #ffd700;
        }

        .deck-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .deck-card {
            background: rgba(0,0,0,0.4);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 3px solid transparent;
            position: relative;
        }

        .deck-card:hover {
            transform: translateY(-5px);
            border-color: #4ecdc4;
            box-shadow: 0 10px 30px rgba(78, 205, 196, 0.3);
        }

        .deck-card.selected {
            border-color: #ffd700;
            background: rgba(255, 215, 0, 0.15);
        }

        .deck-card.locked {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .deck-card.locked::after {
            content: '';
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 24px;
        }

        .deck-icon {
            font-size: 48px;
            margin-bottom: 15px;
        }

        .deck-name {
            font-size: 18px;
            font-weight: bold;
            color: #4ecdc4;
            margin-bottom: 10px;
        }

        .deck-desc {
            font-size: 12px;
            color: #aaa;
            line-height: 1.4;
            margin-bottom: 15px;
        }

        .deck-bonus {
            font-size: 11px;
            color: #ffd700;
            padding: 5px 10px;
            background: rgba(255, 215, 0, 0.2);
            border-radius: 10px;
        }

        .deck-unlock-req {
            font-size: 10px;
            color: #e74c3c;
            margin-top: 10px;
        }

        /* Run History */
        .run-history-list {
            max-height: 300px;
            overflow-y: auto;
        }

        .run-entry {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            margin-bottom: 8px;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            border-left: 4px solid #4ecdc4;
        }

        .run-entry.won {
            border-left-color: #27ae60;
        }

        .run-entry.lost {
            border-left-color: #e74c3c;
        }

        .run-score {
            font-size: 16px;
            font-weight: bold;
            color: #ffd700;
        }

        .run-details {
            font-size: 11px;
            color: #aaa;
        }

        /* Codex Modal */
        .codex-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.95);
            z-index: 10006;
            justify-content: center;
            align-items: center;
        }

        .codex-modal.active {
            display: flex;
        }

        .codex-content {
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            border-radius: 20px;
            padding: 30px;
            max-width: 900px;
            width: 95%;
            max-height: 85vh;
            overflow-y: auto;
            border: 3px solid #ffd700;
        }

        .codex-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .codex-tab {
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            color: white;
        }

        .codex-tab.active {
            background: rgba(255, 215, 0, 0.2);
            border-color: #ffd700;
        }

        .codex-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 12px;
        }

        .codex-item {
            background: rgba(0,0,0,0.4);
            border-radius: 10px;
            padding: 12px;
            text-align: center;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }

        .codex-item.discovered {
            border-color: rgba(78, 205, 196, 0.5);
        }

        .codex-item.undiscovered {
            opacity: 0.4;
            filter: grayscale(1);
        }

        .codex-item-icon {
            font-size: 32px;
            margin-bottom: 8px;
        }

        .codex-item-name {
            font-size: 11px;
            font-weight: bold;
            color: #4ecdc4;
        }

        .codex-item.undiscovered .codex-item-name {
            color: #666;
        }

        .codex-item.undiscovered .codex-item-icon {
            filter: blur(3px);
        }

        .codex-progress {
            text-align: center;
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
        }

        .codex-progress-bar {
            width: 100%;
            height: 10px;
            background: rgba(255,255,255,0.1);
            border-radius: 5px;
            margin-top: 10px;
            overflow: hidden;
        }

        .codex-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4ecdc4, #27ae60);
            transition: width 0.5s ease;
        }

        /* Challenge Mode */
        .challenge-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.95);
            z-index: 10007;
            justify-content: center;
            align-items: center;
        }

        .challenge-modal.active {
            display: flex;
        }

        .challenge-content {
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            border-radius: 20px;
            padding: 30px;
            max-width: 700px;
            width: 95%;
            max-height: 85vh;
            overflow-y: auto;
            border: 3px solid #9b59b6;
        }

        .challenge-list {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .challenge-card {
            background: rgba(0,0,0,0.4);
            border-radius: 15px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .challenge-card:hover {
            border-color: #9b59b6;
            transform: translateX(5px);
        }

        .challenge-card.completed {
            border-color: #27ae60;
        }

        .challenge-icon {
            font-size: 40px;
            flex-shrink: 0;
        }

        .challenge-info {
            flex: 1;
        }

        .challenge-name {
            font-size: 18px;
            font-weight: bold;
            color: #9b59b6;
            margin-bottom: 5px;
        }

        .challenge-desc {
            font-size: 12px;
            color: #aaa;
            margin-bottom: 8px;
        }

        .challenge-rules {
            font-size: 11px;
            color: #ffd700;
            padding: 5px 10px;
            background: rgba(255, 215, 0, 0.1);
            border-radius: 5px;
            display: inline-block;
        }

        .challenge-reward {
            font-size: 12px;
            color: #27ae60;
            font-weight: bold;
        }

        /* Spectral Cards */
        .spectral-card {
            background: linear-gradient(135deg, #2c3e50, #4a5568, #2c3e50);
            border: 2px solid #9b59b6;
            color: white;
            padding: 8px;
            border-radius: 8px;
            font-size: 12px;
            position: relative;
            overflow: hidden;
            animation: spectralShimmer 3s ease-in-out infinite;
        }

        .spectral-card::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(155, 89, 182, 0.2), transparent);
            transform: rotate(45deg);
            animation: spectralGlow 2s linear infinite;
        }

        @keyframes spectralShimmer {
            0%, 100% { border-color: #9b59b6; }
            50% { border-color: #8e44ad; box-shadow: 0 0 15px rgba(155, 89, 182, 0.5); }
        }

        @keyframes spectralGlow {
            0% { transform: translateX(-100%) rotate(45deg); }
            100% { transform: translateX(100%) rotate(45deg); }
        }

        .spectral-card.usable {
            cursor: pointer;
        }

        .spectral-card.usable:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 20px rgba(155, 89, 182, 0.5);
        }

        /* Card Seal Styles */
        .card-seal {
            position: absolute;
            top: 5px;
            right: 5px;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 0 8px currentColor;
        }

        .card-seal.gold { background: #ffd700; color: #ffd700; }
        .card-seal.red { background: #e74c3c; color: #e74c3c; }
        .card-seal.blue { background: #3498db; color: #3498db; }
        .card-seal.purple { background: #9b59b6; color: #9b59b6; }

        /* Card Enhancement Visuals */
        .card.enhanced-gold {
            background: linear-gradient(135deg, #ffd700, #f39c12, #ffd700) !important;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
        }

        .card.enhanced-steel {
            background: linear-gradient(135deg, #bdc3c7, #95a5a6, #7f8c8d) !important;
            box-shadow: 0 0 15px rgba(149, 165, 166, 0.5);
        }

        .card.enhanced-glass {
            background: linear-gradient(135deg, rgba(255,255,255,0.9), rgba(200,220,255,0.9), rgba(255,255,255,0.9)) !important;
            box-shadow: 0 0 15px rgba(52, 152, 219, 0.5);
        }

        .card.enhanced-stone {
            background: linear-gradient(135deg, #7f8c8d, #95a5a6, #7f8c8d) !important;
            box-shadow: 0 0 15px rgba(127, 140, 141, 0.5);
        }

        .card.enhanced-wild {
            background: linear-gradient(135deg, #e74c3c, #f39c12, #2ecc71, #3498db, #9b59b6) !important;
            box-shadow: 0 0 15px rgba(155, 89, 182, 0.5);
        }

        /* Foil, Holo, and Polychrome effects */
        .card.foil::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, transparent 40%, rgba(255,255,255,0.4) 50%, transparent 60%);
            animation: foilShine 3s linear infinite;
            pointer-events: none;
        }

        @keyframes foilShine {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .card.holo::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg,
                rgba(255,0,0,0.1),
                rgba(255,127,0,0.1),
                rgba(255,255,0,0.1),
                rgba(0,255,0,0.1),
                rgba(0,0,255,0.1),
                rgba(75,0,130,0.1),
                rgba(148,0,211,0.1)
            );
            animation: holoShift 2s linear infinite;
            pointer-events: none;
        }

        @keyframes holoShift {
            0% { filter: hue-rotate(0deg); }
            100% { filter: hue-rotate(360deg); }
        }

        .card.poly {
            background: linear-gradient(135deg,
                #ff6b6b, #f06595, #cc5de8, #845ef7, #5c7cfa,
                #339af0, #22b8cf, #20c997, #51cf66, #94d82d
            ) !important;
            background-size: 200% 200%;
            animation: polyGradient 3s ease infinite;
        }

        @keyframes polyGradient {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        /* Win Celebration Screen */
        .win-screen {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.95);
            z-index: 20001;
            justify-content: center;
            align-items: center;
        }

        .win-screen.active {
            display: flex;
        }

        .win-content {
            text-align: center;
            animation: winBounce 1s ease-out;
        }

        @keyframes winBounce {
            0% { transform: scale(0); opacity: 0; }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); opacity: 1; }
        }

        .win-title {
            font-size: 64px;
            font-weight: bold;
            color: #ffd700;
            text-shadow: 0 0 30px rgba(255, 215, 0, 0.8);
            margin-bottom: 20px;
            animation: winGlow 1.5s ease-in-out infinite;
        }

        @keyframes winGlow {
            0%, 100% { text-shadow: 0 0 30px rgba(255, 215, 0, 0.8); }
            50% { text-shadow: 0 0 60px rgba(255, 215, 0, 1), 0 0 100px rgba(255, 215, 0, 0.5); }
        }

        .win-score {
            font-size: 32px;
            color: #4ecdc4;
            margin-bottom: 30px;
        }

        .win-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-bottom: 30px;
        }

        .win-stat {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
        }

        .win-stat-label {
            font-size: 12px;
            color: #aaa;
        }

        .win-stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #ffd700;
        }

        .confetti {
            position: fixed;
            width: 10px;
            height: 10px;
            animation: confettiFall 3s ease-in-out forwards;
            pointer-events: none;
            z-index: 20002;
        }

        @keyframes confettiFall {
            0% { transform: translateY(-100vh) rotate(0deg); opacity: 1; }
            100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
        }
    </style>
</head>
<body>
    <!-- Data Import/Export Controls -->
    <div class="data-controls">
        <button onclick="exportData()">Export</button>
        <button onclick="document.getElementById('importFile').click()">Import</button>
        <button class="achievement-btn" onclick="openAchievementModal()"></button>
        <button class="achievement-btn" onclick="openLeaderboardModal()"></button>
        <button class="achievement-btn" onclick="openCodexModal()"></button>
        <button class="achievement-btn" onclick="openChallengeModal()"></button>
        <button class="achievement-btn" onclick="openSettingsModal()"></button>
        <button onclick="openDeckSelectModal()">New Game</button>
        <button class="achievement-btn" onclick="showTutorial()"></button>
        <input type="file" id="importFile" accept=".json" onchange="importData(event)">
    </div>

    <!-- Combo Display -->
    <div class="combo-display hidden" id="combo-display">
         <span id="combo-text">Combo x1</span>
    </div>

    <div class="game-container">
        <div class="header">
            <div class="score-section">
                <div class="score-item">
                    <div class="score-label">Score</div>
                    <div class="score-value" id="score">0</div>
                </div>
                <div class="score-item">
                    <div class="score-label">Chips</div>
                    <div class="score-value chips-value" id="current-chips">0</div>
                </div>
                <div class="score-item">
                    <div class="score-label">Money</div>
                    <div class="score-value money-value" id="money">$4</div>
                </div>
            </div>
            
            <div class="blind-info" id="blind-info">
                <div class="blind-name" id="blind-name">Small Blind</div>
                <div class="blind-requirement" id="blind-requirement">300</div>
                <div class="progress-bar-container">
                    <div class="progress-bar" id="progress-bar" style="width: 0%"></div>
                    <div class="progress-text" id="progress-text">0 / 300</div>
                </div>
            </div>
            
            <div class="round-info">
                <div class="ante-display" id="ante">Ante 1</div>
                <div class="round-display" id="round">Round 1/3</div>
            </div>
            
            <div class="score-section">
                <div class="hands-remaining" id="hands-remaining">Hands: 4</div>
                <div class="discards-remaining" id="discards-remaining">Discards: 3</div>
            </div>
        </div>

        <div class="main-content">
            <div class="left-panel">
                <div class="jokers-container">
                    <div class="section-title">
                        Jokers
                        <span id="joker-count">0/5</span>
                    </div>
                    <div class="joker-slots" id="joker-slots">
                        <div class="joker-slot"></div>
                        <div class="joker-slot"></div>
                        <div class="joker-slot"></div>
                        <div class="joker-slot"></div>
                        <div class="joker-slot"></div>
                    </div>
                </div>
                
                <div class="mult-chips-display">
                    <div class="section-title">Base Score</div>
                    <div class="mult-chips-values">
                        <div class="mult-display">
                            <div class="mult-label">Mult</div>
                            <div class="mult-value" id="base-mult">0</div>
                        </div>
                        <div class="chips-display">
                            <div class="chips-label">Chips</div>
                            <div class="chips-value-large" id="base-chips">0</div>
                        </div>
                    </div>
                </div>

                <div class="deck-info">
                    <div class="section-title">Deck</div>
                    <div class="deck-stats">
                        <span>Cards: <span id="deck-count">52</span></span>
                        <span>Draw: <span id="deck-draw">52</span></span>
                    </div>
                </div>

                <div class="voucher-display">
                    <div class="section-title">Vouchers</div>
                    <div class="voucher-list" id="voucher-list"></div>
                </div>
            </div>

            <div class="center-area">
                <div class="played-cards-area">
                    <div class="played-cards" id="played-cards"></div>
                    <div class="hand-evaluation">
                        <div class="hand-name" id="hand-name"></div>
                        <div class="hand-score-preview" id="score-preview"></div>
                    </div>
                </div>

                <div class="hand-area">
                    <div class="hand-cards" id="hand-cards"></div>
                    <div class="controls">
                        <button class="btn btn-play" id="play-btn">Play Hand</button>
                        <button class="btn btn-discard" id="discard-btn">Discard</button>
                        <button class="btn btn-sort" id="sort-btn">Sort Hand</button>
                        <button class="btn btn-end-round" id="shop-btn">Shop ($5)</button>
                    </div>
                </div>
            </div>

            <div class="right-panel">
                <div class="hand-levels">
                    <div class="section-title">Hand Levels</div>
                    <div id="hand-levels-list"></div>
                </div>

                <div class="planet-cards">
                    <div class="section-title">Planet Cards</div>
                    <div class="planet-card-list" id="planet-cards"></div>
                </div>

                <div class="tarot-cards">
                    <div class="section-title">Tarot Cards</div>
                    <div class="tarot-card-list" id="tarot-cards"></div>
                </div>

                <div class="spectral-cards" style="margin-top: 15px;">
                    <div class="section-title"> Spectral Cards</div>
                    <div class="spectral-card-list" id="spectral-cards" style="display: flex; gap: 8px; flex-wrap: wrap;"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="shop-modal" id="shop-modal">
        <div class="shop-content">
            <div class="shop-header">
                <div class="shop-title">Shop</div>
                <div class="shop-money" id="shop-money">$4</div>
                <button class="close-shop" id="close-shop">&times;</button>
            </div>
            <div class="shop-tabs">
                <div class="shop-tab active" data-tab="jokers">Jokers</div>
                <div class="shop-tab" data-tab="tarots">Tarot Cards</div>
                <div class="shop-tab" data-tab="planets">Planet Cards</div>
                <div class="shop-tab" data-tab="spectrals">Spectrals</div>
                <div class="shop-tab" data-tab="vouchers">Vouchers</div>
                <div class="shop-tab" data-tab="packs">Card Packs</div>
            </div>
            <div class="shop-items" id="shop-items"></div>
            <button class="reroll-btn" id="reroll-btn">Reroll ($5)</button>
        </div>
    </div>

    <div class="game-over-modal" id="game-over-modal">
        <div class="game-over-content">
            <div class="game-over-title">Game Over!</div>
            <div class="game-over-stats" id="game-over-stats"></div>
            <button class="restart-btn" id="restart-btn">New Game</button>
        </div>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <!-- Achievement Modal -->
    <div class="achievement-modal" id="achievement-modal">
        <div class="achievement-modal-content">
            <div class="shop-header">
                <div class="shop-title"> Achievements</div>
                <div id="achievement-stats">0/20 Unlocked  0 Points</div>
                <button class="close-shop" onclick="closeAchievementModal()">&times;</button>
            </div>
            <div class="achievement-grid" id="achievement-grid"></div>
        </div>
    </div>

    <!-- Tutorial Overlay -->
    <div class="tutorial-overlay" id="tutorial-overlay">
        <div class="tutorial-content">
            <div class="tutorial-header">
                <div class="tutorial-title" id="tutorial-title">Welcome to Balatro Clone!</div>
                <div class="tutorial-step-indicator" id="tutorial-step">Step 1 of 6</div>
            </div>
            <div class="tutorial-body" id="tutorial-body">
                <!-- Content dynamically generated -->
            </div>
            <div class="tutorial-controls">
                <button class="tutorial-btn tutorial-btn-skip" onclick="skipTutorial()">Skip Tutorial</button>
                <button class="tutorial-btn tutorial-btn-next" id="tutorial-next-btn" onclick="nextTutorialStep()">Next</button>
            </div>
            <div class="tutorial-progress" id="tutorial-progress">
                <!-- Dots dynamically generated -->
            </div>
        </div>
    </div>

    <!-- Daily Challenge Banner -->
    <div class="daily-challenge-banner" id="daily-challenge-banner" onclick="startDailyChallenge()">
         Daily Challenge Available!
    </div>

    <!-- Leaderboard Modal -->
    <div class="leaderboard-modal" id="leaderboard-modal">
        <div class="leaderboard-content">
            <div class="shop-header">
                <div class="shop-title"> Leaderboard</div>
                <button class="close-shop" onclick="closeLeaderboardModal()">&times;</button>
            </div>
            <div class="leaderboard-tabs">
                <div class="leaderboard-tab active" data-lb-tab="highscore" onclick="switchLeaderboardTab('highscore')">High Scores</div>
                <div class="leaderboard-tab" data-lb-tab="ante" onclick="switchLeaderboardTab('ante')">Highest Ante</div>
                <div class="leaderboard-tab" data-lb-tab="daily" onclick="switchLeaderboardTab('daily')">Daily</div>
            </div>
            <div id="leaderboard-entries"></div>
        </div>
    </div>

    <!-- Deck Selection Modal -->
    <div class="deck-select-modal" id="deck-select-modal">
        <div class="deck-select-content">
            <div class="shop-header">
                <div class="shop-title"> Select Your Deck</div>
                <button class="close-shop" onclick="closeDeckSelectModal()">&times;</button>
            </div>
            <div class="deck-grid" id="deck-grid">
                <!-- Decks dynamically generated -->
            </div>
            <div style="text-align: center; margin-top: 20px;">
                <button class="btn btn-play" id="start-with-deck-btn" onclick="startWithSelectedDeck()">Start Game</button>
            </div>
        </div>
    </div>

    <!-- Codex Modal -->
    <div class="codex-modal" id="codex-modal">
        <div class="codex-content">
            <div class="shop-header">
                <div class="shop-title"> Collection Codex</div>
                <button class="close-shop" onclick="closeCodexModal()">&times;</button>
            </div>
            <div class="codex-progress" id="codex-progress">
                <!-- Progress dynamically generated -->
            </div>
            <div class="codex-tabs">
                <div class="codex-tab active" data-codex-tab="jokers" onclick="switchCodexTab('jokers')"> Jokers</div>
                <div class="codex-tab" data-codex-tab="planets" onclick="switchCodexTab('planets')"> Planets</div>
                <div class="codex-tab" data-codex-tab="tarots" onclick="switchCodexTab('tarots')"> Tarots</div>
                <div class="codex-tab" data-codex-tab="spectrals" onclick="switchCodexTab('spectrals')"> Spectrals</div>
                <div class="codex-tab" data-codex-tab="vouchers" onclick="switchCodexTab('vouchers')"> Vouchers</div>
                <div class="codex-tab" data-codex-tab="hands" onclick="switchCodexTab('hands')"> Hands</div>
            </div>
            <div class="codex-grid" id="codex-grid">
                <!-- Codex items dynamically generated -->
            </div>
        </div>
    </div>

    <!-- Challenge Modal -->
    <div class="challenge-modal" id="challenge-modal">
        <div class="challenge-content">
            <div class="shop-header">
                <div class="shop-title"> Challenge Runs</div>
                <button class="close-shop" onclick="closeChallengeModal()">&times;</button>
            </div>
            <p style="text-align: center; color: #aaa; margin-bottom: 20px;">
                Special runs with unique rules and restrictions. Complete them for rewards!
            </p>
            <div class="challenge-list" id="challenge-list">
                <!-- Challenges dynamically generated -->
            </div>
        </div>
    </div>

    <!-- Win Celebration Screen -->
    <div class="win-screen" id="win-screen">
        <div class="win-content">
            <div class="win-title">VICTORY!</div>
            <div class="win-score" id="win-final-score">Final Score: 0</div>
            <div class="win-stats">
                <div class="win-stat">
                    <div class="win-stat-label">Ante Reached</div>
                    <div class="win-stat-value" id="win-ante">8</div>
                </div>
                <div class="win-stat">
                    <div class="win-stat-label">Hands Played</div>
                    <div class="win-stat-value" id="win-hands">0</div>
                </div>
                <div class="win-stat">
                    <div class="win-stat-label">Money Earned</div>
                    <div class="win-stat-value" id="win-money">$0</div>
                </div>
            </div>
            <button class="btn btn-play" onclick="closeWinScreen()" style="margin-top: 20px;">Play Again</button>
        </div>
    </div>

    <!-- Settings Modal -->
    <div class="settings-modal" id="settings-modal">
        <div class="settings-content">
            <div class="shop-header">
                <div class="shop-title"> Settings</div>
                <button class="close-shop" onclick="closeSettingsModal()">&times;</button>
            </div>

            <div class="settings-section">
                <div class="settings-section-title"> Gameplay</div>
                <div class="settings-option">
                    <div class="settings-label">
                        Difficulty
                        <small>Affects blind scaling and starting resources</small>
                    </div>
                    <select class="settings-select" id="difficulty-select" onchange="changeDifficulty(this.value)">
                        <option value="easy">Easy</option>
                        <option value="normal" selected>Normal</option>
                        <option value="hard">Hard</option>
                        <option value="nightmare">Nightmare</option>
                    </select>
                </div>
                <div class="settings-option">
                    <div class="settings-label">
                        Animations
                        <small>Toggle visual effects</small>
                    </div>
                    <div class="settings-toggle active" id="animations-toggle" onclick="toggleSetting('animations')"></div>
                </div>
                <div class="settings-option">
                    <div class="settings-label">
                        Screen Shake
                        <small>On big scores</small>
                    </div>
                    <div class="settings-toggle active" id="shake-toggle" onclick="toggleSetting('shake')"></div>
                </div>
            </div>

            <div class="settings-section">
                <div class="settings-section-title"> Run Seed</div>
                <div class="settings-option">
                    <div class="settings-label">
                        Current Seed
                        <small>Share to replay exact run</small>
                    </div>
                </div>
                <div class="seed-display">
                    <input type="text" class="seed-input" id="seed-input" readonly>
                    <button class="seed-btn" onclick="copySeed()">Copy</button>
                    <button class="seed-btn" onclick="newSeed()">New</button>
                </div>
            </div>

            <div class="settings-section">
                <div class="settings-section-title"> Keyboard Shortcuts</div>
                <div class="keyboard-shortcuts">
                    <div class="shortcut-item"><span>Play Hand</span><span class="shortcut-key">Space</span></div>
                    <div class="shortcut-item"><span>Discard</span><span class="shortcut-key">D</span></div>
                    <div class="shortcut-item"><span>Sort Hand</span><span class="shortcut-key">S</span></div>
                    <div class="shortcut-item"><span>Close Modal</span><span class="shortcut-key">Esc</span></div>
                    <div class="shortcut-item"><span>Navigate</span><span class="shortcut-key"> </span></div>
                    <div class="shortcut-item"><span>Select Card</span><span class="shortcut-key">Enter</span></div>
                </div>
            </div>

            <div class="settings-section">
                <div class="settings-section-title"> Statistics</div>
                <div class="settings-option">
                    <span>Games Played</span>
                    <span id="stat-games">0</span>
                </div>
                <div class="settings-option">
                    <span>Hands Played</span>
                    <span id="stat-hands">0</span>
                </div>
                <div class="settings-option">
                    <span>Highest Score</span>
                    <span id="stat-highscore">0</span>
                </div>
                <div class="settings-option">
                    <span>Highest Ante</span>
                    <span id="stat-ante">1</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Constants
        const SAVE_KEY = 'balatro-clone-save';
        const STATS_KEY = 'balatro-clone-stats';

        // Game State
        const gameState = {
            score: 0,
            money: 4,
            ante: 1,
            round: 1,
            maxRounds: 3,
            handsRemaining: 4,
            discardsRemaining: 3,
            currentBlind: null,
            deck: [],
            hand: [],
            playedCards: [],
            selectedCards: [],
            jokers: [],
            maxJokers: 5,
            vouchers: [],
            handLevels: {},
            planetCards: [],
            tarotCards: [],
            shopItems: {},
            baseMult: 0,
            baseChips: 0,
            deckSize: 52,
            handSize: 8,
            playRequirement: 5,
            discardRequirement: 5,
            rerollCost: 5,
            isPlaying: false
        };

        // Statistics tracking
        const gameStats = {
            totalGamesPlayed: 0,
            totalHandsPlayed: 0,
            highestScore: 0,
            highestAnte: 1,
            totalMoneyEarned: 0,
            favoriteHand: 'High Card',
            handCounts: {},
            lastPlayed: null
        };

        // Card definitions
        const suits = ['', '', '', ''];
        const ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
        const suitColors = {
            '': 'black',
            '': 'black',
            '': 'red',
            '': 'red'
        };

        // Hand types with base scores (balanced for better progression)
        const handTypes = {
            'Royal Flush': { mult: 9, chips: 120, level: 1 },   // 1080 base - premium tier
            'Straight Flush': { mult: 8, chips: 100, level: 1 }, // 800 base - top tier
            'Four of a Kind': { mult: 7, chips: 75, level: 1 },  // 525 base - high tier
            'Full House': { mult: 5, chips: 55, level: 1 },      // 275 base - solid mid
            'Flush': { mult: 4, chips: 45, level: 1 },           // 180 base - achievable
            'Straight': { mult: 4, chips: 40, level: 1 },        // 160 base - achievable
            'Three of a Kind': { mult: 3, chips: 35, level: 1 }, // 105 base - common
            'Two Pair': { mult: 3, chips: 25, level: 1 },        // 75 base - buffed!
            'Pair': { mult: 2, chips: 15, level: 1 },            // 30 base - baseline
            'High Card': { mult: 1, chips: 8, level: 1 }         // 8 base - fallback
        };

        // Blind types
        const blindTypes = {
            small: { name: 'Small Blind', multiplier: 1 },
            big: { name: 'Big Blind', multiplier: 1.5 },
            boss: {
                name: 'Boss Blind',
                multiplier: 2,
                effects: [
                    { name: 'The Hook', desc: 'Discard 2 random cards each hand', difficulty: 'medium' },
                    { name: 'The Wall', desc: 'No extra chips from cards', difficulty: 'hard' },
                    { name: 'The Wheel', desc: '1 in 7 cards get debuffed', difficulty: 'medium' },
                    { name: 'The House', desc: 'First hand is blind', difficulty: 'medium' },
                    { name: 'The Mark', desc: 'All face cards are debuffed', difficulty: 'easy' },
                    { name: 'The Fish', desc: 'Cards drawn face down', difficulty: 'hard' },
                    { name: 'The Psychic', desc: 'Must play 5 cards', difficulty: 'medium' },
                    { name: 'The Goad', desc: 'All Spades are debuffed', difficulty: 'easy' },
                    { name: 'The Water', desc: 'Start with 0 discards', difficulty: 'hard' },
                    { name: 'The Window', desc: 'All Diamonds are debuffed', difficulty: 'easy' },
                    // === NEW BOSS BLINDS ===
                    { name: 'The Cipher', desc: 'All numbers = their digit sum', difficulty: 'hard' },
                    { name: 'The Mirror', desc: 'Card values are inverted', difficulty: 'nightmare' },
                    { name: 'The Silence', desc: 'First hand: no Joker mult', difficulty: 'hard' },
                    { name: 'The Debt', desc: 'Jokers lose $1 value/hand', difficulty: 'medium' },
                    { name: 'The Mirage', desc: 'One card is invisible', difficulty: 'hard' },
                    { name: 'The Void', desc: 'Jokers 50% effect every other hand', difficulty: 'nightmare' },
                    { name: 'The Collector', desc: 'Only face cards dealt', difficulty: 'easy' },
                    { name: 'The Fracture', desc: 'Cards worth 50% chips', difficulty: 'hard' },
                    { name: 'The Threshold', desc: 'Requirement +10%/hand', difficulty: 'medium' },
                    { name: 'The Recursion', desc: 'Must include rank from last hand', difficulty: 'hard' }
                ]
            }
        };

        // Joker definitions
        const jokerTypes = [
            { name: 'Joker', icon: '', desc: '+4 Mult', price: 5, effect: { mult: 4 } },
            { name: 'Greedy Joker', icon: '', desc: '+3 Mult per Diamond', price: 6, effect: { multPerDiamond: 3 } },
            { name: 'Lusty Joker', icon: '', desc: '+3 Mult per Heart', price: 6, effect: { multPerHeart: 3 } },
            { name: 'Wrathful Joker', icon: '', desc: '+3 Mult per Spade', price: 6, effect: { multPerSpade: 3 } },
            { name: 'Gluttonous Joker', icon: '', desc: '+3 Mult per Club', price: 6, effect: { multPerClub: 3 } },
            { name: 'Jolly Joker', icon: '', desc: '+8 Mult if Pair', price: 8, effect: { multIfPair: 8 } },
            { name: 'Zany Joker', icon: '', desc: '+12 Mult if Three of a Kind', price: 10, effect: { multIfThreeKind: 12 } },
            { name: 'Mad Joker', icon: '', desc: '+20 Mult if Four of a Kind', price: 12, effect: { multIfFourKind: 20 } },
            { name: 'Crazy Joker', icon: '', desc: '+12 Mult if Straight', price: 10, effect: { multIfStraight: 12 } },
            { name: 'Droll Joker', icon: '', desc: '+10 Mult if Flush', price: 9, effect: { multIfFlush: 10 } },
            { name: 'Half Joker', icon: '', desc: '+20 Mult if 3 cards', price: 11, effect: { multIfThreeOrLess: 20 } },
            { name: 'Stencil Joker', icon: '', desc: 'X1 Mult per empty slot', price: 13, effect: { xMultPerEmpty: 1 } },
            { name: 'Stone Joker', icon: '', desc: '+25 Chips per Stone card', price: 8, effect: { chipsPerStone: 25 } },
            { name: 'Ice Cream', icon: '', desc: '+100 Chips, -5 per hand', price: 7, effect: { chips: 100, chipsDecay: 5 } },
            { name: 'Seltzer', icon: '', desc: 'Retrigger all cards', price: 15, effect: { retrigger: true } },
            { name: 'Hack', icon: '', desc: 'Retrigger 2,3,4,5', price: 12, effect: { retriggerLow: true } },
            { name: 'Pareidolia', icon: '', desc: 'All cards count as faces', price: 14, effect: { allFaces: true } },
            { name: 'Gros Michel', icon: '', desc: '+15 Mult, 1 in 4 chance gone', price: 10, effect: { mult: 15, fragile: 0.25 } },
            { name: 'Even Steven', icon: '2', desc: '+4 Mult per even rank', price: 9, effect: { multPerEven: 4 } },
            { name: 'Odd Todd', icon: '1', desc: '+3 Chips per odd rank', price: 8, effect: { chipsPerOdd: 31 } },
            { name: 'Scholar', icon: '', desc: '+4 Chips, +1 Mult per Ace', price: 7, effect: { chipsPerAce: 4, multPerAce: 1 } },
            { name: 'Business Card', icon: '', desc: 'Face cards give $2', price: 10, effect: { moneyPerFace: 2 } },
            { name: 'Supernova', icon: '', desc: '+1 Mult per $1', price: 11, effect: { multPerDollar: 1 } },
            { name: 'Ride the Bus', icon: '', desc: '+1 Mult per hand without face', price: 8, effect: { multNoFace: 1 } },
            { name: 'Space Joker', icon: '', desc: '1 in 4 to level up hand', price: 13, effect: { levelUpChance: 0.25 } },
            // === NEW JOKERS ===
            { name: 'Probability Joker', icon: '', desc: '+2 Mult per 2+ rank match', price: 7, effect: { multPerMatch: 2 } },
            { name: 'Combo Tracker', icon: '', desc: '+3 Mult per streak', price: 8, effect: { multPerStreak: 3 } },
            { name: 'Ecosystem Joker', icon: '', desc: '+2 Mult per Joker', price: 11, effect: { multPerJoker: 2 } },
            { name: 'Scale Joker', icon: '', desc: '+1 Mult per $3 (max 15)', price: 10, effect: { multPerMoney: 3, maxMultMoney: 15 } },
            { name: 'Ritual Joker', icon: '', desc: '+1 Mult per hand type play', price: 12, effect: { multPerHandPlayed: 1 } },
            { name: 'Volatile Joker', icon: '', desc: '50% x2 Mult, 50% x0.5', price: 9, effect: { volatile: true } },
            { name: 'Nemesis Joker', icon: '', desc: '+15 Mult on boss blinds', price: 13, effect: { multOnBoss: 15 } },
            { name: 'Mirror Joker', icon: '', desc: 'Copy left joker effect', price: 15, effect: { mirrorLeft: true } },
            { name: 'Lucky Seven', icon: '7', desc: '+7 Mult per 7 in hand', price: 7, effect: { multPerSeven: 7 } },
            { name: 'Royal Guard', icon: '', desc: '+5 Mult per face card', price: 9, effect: { multPerFace: 5 } }
        ];

        // Achievement definitions
        const ACHIEVEMENTS_KEY = 'balatro-clone-achievements';
        const achievementDefinitions = [
            // Gameplay achievements
            { id: 'first_win', name: 'First Victory', desc: 'Win your first game (Ante 4+)', icon: '', points: 10, rarity: 'common', category: 'gameplay' },
            { id: 'flush_master', name: 'Flush Master', desc: 'Play 50 Flush hands', icon: '', points: 15, rarity: 'uncommon', category: 'gameplay', target: 50 },
            { id: 'straight_shooter', name: 'Straight Shooter', desc: 'Play 50 Straight hands', icon: '', points: 15, rarity: 'uncommon', category: 'gameplay', target: 50 },
            { id: 'royal_reverence', name: 'Royal Reverence', desc: 'Play a Royal Flush', icon: '', points: 25, rarity: 'rare', category: 'gameplay' },
            { id: 'high_roller', name: 'High Roller', desc: 'Score 100,000+ in one game', icon: '', points: 30, rarity: 'rare', category: 'gameplay' },
            { id: 'million_dollar', name: 'Million Dollar Hands', desc: 'Score 1,000,000+', icon: '', points: 50, rarity: 'legendary', category: 'gameplay' },
            { id: 'combo_king', name: 'Combo King', desc: 'Get a 5x combo streak', icon: '', points: 20, rarity: 'uncommon', category: 'gameplay' },
            // Progression achievements
            { id: 'ante_5', name: 'Rank Ascension I', desc: 'Reach Ante 5', icon: '', points: 15, rarity: 'uncommon', category: 'progression' },
            { id: 'ante_8', name: 'Rank Ascension II', desc: 'Reach Ante 8', icon: '', points: 35, rarity: 'rare', category: 'progression' },
            { id: 'ante_10', name: 'The Pinnacle', desc: 'Reach Ante 10', icon: '', points: 75, rarity: 'legendary', category: 'progression' },
            { id: 'boss_slayer', name: 'Boss Slayer', desc: 'Defeat 10 boss blinds', icon: '', points: 25, rarity: 'uncommon', category: 'progression', target: 10 },
            // Collection achievements
            { id: 'joker_collector', name: 'Joker Collector', desc: 'Have 5 jokers at once', icon: '', points: 20, rarity: 'uncommon', category: 'collection' },
            { id: 'planet_set', name: 'Celestial Collector', desc: 'Collect all 9 planet cards', icon: '', points: 40, rarity: 'rare', category: 'collection' },
            { id: 'enhancement_master', name: 'Enhancement Master', desc: 'Have 3 enhanced cards', icon: '', points: 15, rarity: 'uncommon', category: 'collection' },
            { id: 'wealthy', name: 'Money Bags', desc: 'Have $50 at once', icon: '', points: 20, rarity: 'uncommon', category: 'collection' },
            // Challenge achievements
            { id: 'no_discard', name: 'No Waste', desc: 'Win a blind without discarding', icon: '', points: 25, rarity: 'rare', category: 'challenge' },
            { id: 'one_hand_wonder', name: 'One Hand Wonder', desc: 'Win a blind in one hand', icon: '', points: 35, rarity: 'epic', category: 'challenge' },
            { id: 'survivor', name: 'Survivor', desc: 'Win with 1 hand remaining', icon: '', points: 20, rarity: 'uncommon', category: 'challenge' },
            { id: 'speed_demon', name: 'Speed Demon', desc: 'Play 100 hands total', icon: '', points: 15, rarity: 'common', category: 'challenge', target: 100 },
            { id: 'veteran', name: 'Veteran Player', desc: 'Play 50 games', icon: '', points: 30, rarity: 'rare', category: 'challenge', target: 50 },
            // New System achievements
            { id: 'daily_winner', name: 'Daily Champion', desc: 'Complete a Daily Challenge', icon: '', points: 25, rarity: 'uncommon', category: 'challenge' },
            { id: 'deck_master', name: 'Deck Master', desc: 'Unlock all 8 decks', icon: '', points: 50, rarity: 'rare', category: 'collection' },
            { id: 'codex_10', name: 'Collector I', desc: 'Discover 10 items in Codex', icon: '', points: 10, rarity: 'common', category: 'collection', target: 10 },
            { id: 'codex_50', name: 'Collector II', desc: 'Discover 50 items in Codex', icon: '', points: 30, rarity: 'uncommon', category: 'collection', target: 50 },
            { id: 'codex_100', name: 'Completionist', desc: 'Discover all items in Codex', icon: '', points: 100, rarity: 'legendary', category: 'collection' },
            { id: 'spectral_user', name: 'Spectral User', desc: 'Use 10 Spectral cards', icon: '', points: 20, rarity: 'uncommon', category: 'collection', target: 10 },
            { id: 'seal_collector', name: 'Seal Collector', desc: 'Have all 4 seal types', icon: '', points: 35, rarity: 'rare', category: 'collection' },
            { id: 'challenge_3', name: 'Challenger I', desc: 'Complete 3 Challenges', icon: '', points: 25, rarity: 'uncommon', category: 'challenge', target: 3 },
            { id: 'challenge_all', name: 'Challenge Master', desc: 'Complete all Challenges', icon: '', points: 100, rarity: 'legendary', category: 'challenge' },
            { id: 'leaderboard_top', name: 'Top Scorer', desc: 'Get #1 on Leaderboard', icon: '', points: 20, rarity: 'uncommon', category: 'gameplay' },
            { id: 'win_streak', name: 'Hot Streak', desc: 'Win 3 games in a row', icon: '', points: 40, rarity: 'rare', category: 'gameplay', target: 3 }
        ];

        // Achievement state
        let achievementsState = {
            unlocked: {},
            progress: {},
            totalPoints: 0
        };

        // Combo/Streak system
        const comboState = {
            lastHandType: null,
            streakCount: 0,
            maxStreak: 0,
            handsWithoutDiscard: 0,
            bossDefeated: 0
        };

        // Settings state
        const SETTINGS_KEY = 'balatro-clone-settings';
        let gameSettings = {
            difficulty: 'normal',
            animations: true,
            shake: true,
            seed: null
        };

        // Difficulty modifiers
        const difficultyModifiers = {
            easy: {
                blindScaling: 0.8,
                startingMoney: 6,
                startingHands: 5,
                startingDiscards: 4
            },
            normal: {
                blindScaling: 1.0,
                startingMoney: 4,
                startingHands: 4,
                startingDiscards: 3
            },
            hard: {
                blindScaling: 1.3,
                startingMoney: 3,
                startingHands: 3,
                startingDiscards: 2
            },
            nightmare: {
                blindScaling: 1.6,
                startingMoney: 2,
                startingHands: 3,
                startingDiscards: 2
            }
        };

        // Seeded RNG (Mulberry32)
        let rngState = 0;
        function seededRandom() {
            rngState |= 0;
            rngState = rngState + 0x6D2B79F5 | 0;
            let t = Math.imul(rngState ^ rngState >>> 15, 1 | rngState);
            t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
            return ((t ^ t >>> 14) >>> 0) / 4294967296;
        }

        function initRNG(seed) {
            if (typeof seed === 'string') {
                // Convert string seed to number
                let hash = 0;
                for (let i = 0; i < seed.length; i++) {
                    hash = ((hash << 5) - hash) + seed.charCodeAt(i);
                    hash |= 0;
                }
                rngState = hash;
            } else {
                rngState = seed || Date.now();
            }
            gameSettings.seed = getSeedString();
        }

        function getSeedString() {
            return Math.abs(rngState).toString(36).toUpperCase().padStart(8, '0').slice(0, 8);
        }

        function generateNewSeed() {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            let seed = '';
            for (let i = 0; i < 8; i++) {
                seed += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return seed;
        }

        // Planet card definitions
        const planetCardTypes = [
            { name: 'Mercury', hand: 'Pair', icon: '' },
            { name: 'Venus', hand: 'Two Pair', icon: '' },
            { name: 'Earth', hand: 'Three of a Kind', icon: '' },
            { name: 'Mars', hand: 'Straight', icon: '' },
            { name: 'Jupiter', hand: 'Flush', icon: '' },
            { name: 'Saturn', hand: 'Full House', icon: '' },
            { name: 'Uranus', hand: 'Four of a Kind', icon: '' },
            { name: 'Neptune', hand: 'Straight Flush', icon: '' },
            { name: 'Pluto', hand: 'Royal Flush', icon: '' }
        ];

        // Tarot card definitions
        const tarotCardTypes = [
            { name: 'The Fool', icon: '', desc: 'Create last Tarot or Planet', price: 4 },
            { name: 'The Magician', icon: '', desc: 'Enhance 2 cards', price: 4 },
            { name: 'The High Priestess', icon: '', desc: 'Create 2 random cards', price: 4 },
            { name: 'The Empress', icon: '', desc: 'Enhance 2 cards to Steel', price: 5 },
            { name: 'The Emperor', icon: '', desc: 'Create 2 random Tarots', price: 5 },
            { name: 'The Hierophant', icon: '', desc: 'Enhance 2 cards to Bonus', price: 5 },
            { name: 'The Lovers', icon: '', desc: 'Enhance 1 card to Wild', price: 6 },
            { name: 'The Chariot', icon: '', desc: 'Enhance 1 card to Steel', price: 4 },
            { name: 'Strength', icon: '', desc: 'Increase rank of 2 cards', price: 5 },
            { name: 'The Hermit', icon: '', desc: 'Double money', price: 7 },
            { name: 'Wheel of Fortune', icon: '', desc: '1 in 4 to add Foil, Holo, or Poly', price: 6 },
            { name: 'Justice', icon: '', desc: 'Enhance 1 card to Glass', price: 4 },
            { name: 'The Hanged Man', icon: '', desc: 'Destroy up to 2 cards', price: 3 },
            { name: 'Death', icon: '', desc: 'Select 2 cards, turn to same', price: 5 },
            { name: 'Temperance', icon: '', desc: 'Give Joker +$10 sell value', price: 6 },
            { name: 'The Devil', icon: '', desc: 'Enhance 1 card to Gold', price: 5 },
            { name: 'The Tower', icon: '', desc: 'Enhance 1 card to Stone', price: 5 },
            { name: 'The Star', icon: '', desc: 'Turn 3 cards to Diamonds', price: 4 },
            { name: 'The Moon', icon: '', desc: 'Turn 3 cards to Clubs', price: 4 },
            { name: 'The Sun', icon: '', desc: 'Turn 3 cards to Hearts', price: 4 },
            { name: 'Judgement', icon: '', desc: 'Create random Joker', price: 8 },
            { name: 'The World', icon: '', desc: 'Turn 3 cards to Spades', price: 4 }
        ];

        // Spectral card definitions (rare and powerful)
        const spectralCardTypes = [
            { name: 'Familiar', icon: '', desc: 'Destroy 1 card, create 3 copies', price: 6, rarity: 'rare' },
            { name: 'Grim', icon: '', desc: 'Destroy 2 cards, gain $10', price: 5, rarity: 'uncommon' },
            { name: 'Incantation', icon: '', desc: 'Add 4 copies of a card', price: 7, rarity: 'rare' },
            { name: 'Talisman', icon: '', desc: 'Add Gold Seal to 1 card', price: 6, rarity: 'uncommon' },
            { name: 'Aura', icon: '', desc: 'Add Foil, Holo, or Poly to hand', price: 8, rarity: 'rare' },
            { name: 'Wraith', icon: '', desc: 'Create random Rare Joker, lose $5', price: 4, rarity: 'rare' },
            { name: 'Sigil', icon: '', desc: 'Convert hand to 1 suit', price: 5, rarity: 'uncommon' },
            { name: 'Ouija', icon: '', desc: '-1 hand size, +1 Mult to all hands', price: 6, rarity: 'uncommon' },
            { name: 'Ectoplasm', icon: '', desc: '-1 Joker slot, +1 Mult to all Jokers', price: 5, rarity: 'rare' },
            { name: 'Immolate', icon: '', desc: 'Destroy 5 cards, gain $20', price: 4, rarity: 'uncommon' },
            { name: 'Ankh', icon: '', desc: 'Copy a random Joker, destroy others', price: 8, rarity: 'legendary' },
            { name: 'Deja Vu', icon: '', desc: 'Add Red Seal to 1 card', price: 5, rarity: 'uncommon' },
            { name: 'Hex', icon: '', desc: 'Add Poly to a random Joker', price: 7, rarity: 'rare' },
            { name: 'Trance', icon: '', desc: 'Add Blue Seal to 1 card', price: 5, rarity: 'uncommon' },
            { name: 'Medium', icon: '', desc: 'Add Purple Seal to 1 card', price: 6, rarity: 'uncommon' },
            { name: 'Cryptid', icon: '', desc: 'Create 2 copies of 1 card', price: 6, rarity: 'rare' },
            { name: 'The Soul', icon: '', desc: 'Create Legendary Joker', price: 12, rarity: 'legendary' },
            { name: 'Black Hole', icon: '', desc: 'Level up ALL hands', price: 10, rarity: 'legendary' }
        ];

        // Card seal definitions
        const sealTypes = {
            gold: { name: 'Gold Seal', color: '#ffd700', effect: 'Earn $3 when played' },
            red: { name: 'Red Seal', color: '#e74c3c', effect: 'Retrigger this card' },
            blue: { name: 'Blue Seal', color: '#3498db', effect: 'Create Planet if held at end' },
            purple: { name: 'Purple Seal', color: '#9b59b6', effect: 'Create Tarot when discarded' }
        };

        // Voucher definitions
        const voucherTypes = [
            { name: 'Overstock', desc: '+1 card slot in shop', price: 10, effect: { shopSlots: 1 } },
            { name: 'Clearance Sale', desc: 'All items 25% off', price: 10, effect: { discount: 0.25 } },
            { name: 'Hone', desc: 'Foil, Holo, and Poly are 2X', price: 10, effect: { enhancementBonus: 2 } },
            { name: 'Reroll Surplus', desc: 'Rerolls cost $2 less', price: 8, effect: { rerollDiscount: 2 } },
            { name: 'Crystal Ball', desc: '+1 consumable slot', price: 10, effect: { consumableSlots: 1 } },
            { name: 'Telescope', desc: 'Planet cards always in shop', price: 12, effect: { planetsInShop: true } },
            { name: 'Grabber', desc: '+1 hand per round', price: 10, effect: { extraHands: 1 } },
            { name: 'Wasteful', desc: '+1 discard per round', price: 8, effect: { extraDiscards: 1 } },
            { name: 'Blank', desc: 'Does nothing?', price: 5, effect: {} },
            { name: 'Antimatter', desc: '+1 Joker slot', price: 15, effect: { jokerSlots: 1 } },
            { name: 'Magic Trick', desc: 'Cards can be purchased', price: 8, effect: { buyCards: true } },
            { name: 'Illusion', desc: 'Cards in shop cost $1 less', price: 10, effect: { cardDiscount: 1 } },
            { name: 'Hieroglyph', desc: '-1 Ante, -1 hand', price: 12, effect: { anteReduction: 1, handReduction: 1 } },
            { name: 'Petroglyph', desc: '-1 Ante, -1 discard', price: 10, effect: { anteReduction: 1, discardReduction: 1 } },
            { name: 'Director\'s Cut', desc: 'Reroll Boss Blind 1 time', price: 12, effect: { rerollBoss: 1 } },
            { name: 'Paint Brush', desc: '+1 hand size', price: 10, effect: { handSize: 1 } },
            { name: 'Seed Money', desc: 'Earn $1 per $5', price: 8, effect: { interest: 0.2 } }
        ];

        // Save game state
        function saveGame() {
            try {
                const saveData = {
                    version: '1.0',
                    timestamp: Date.now(),
                    gameState: {
                        ...gameState,
                        deck: gameState.deck,
                        hand: gameState.hand,
                        jokers: gameState.jokers,
                        vouchers: gameState.vouchers,
                        handLevels: gameState.handLevels,
                        planetCards: gameState.planetCards,
                        tarotCards: gameState.tarotCards
                    }
                };
                localStorage.setItem(SAVE_KEY, JSON.stringify(saveData));
                return true;
            } catch (e) {
                console.error('Failed to save game:', e);
                return false;
            }
        }

        // Load game state
        function loadGame() {
            try {
                const savedData = localStorage.getItem(SAVE_KEY);
                if (!savedData) return false;

                const saveData = JSON.parse(savedData);
                if (saveData.version !== '1.0') return false;

                // Restore game state
                Object.assign(gameState, saveData.gameState);

                renderHand();
                renderJokers();
                renderPlayedCards();
                renderHandLevels();
                renderPlanetCards();
                renderTarotCards();
                updateBlind();
                updateDisplay();

                return true;
            } catch (e) {
                console.error('Failed to load game:', e);
                return false;
            }
        }

        // Save statistics
        function saveStats() {
            try {
                localStorage.setItem(STATS_KEY, JSON.stringify(gameStats));
            } catch (e) {
                console.error('Failed to save stats:', e);
            }
        }

        // Load statistics
        function loadStats() {
            try {
                const savedStats = localStorage.getItem(STATS_KEY);
                if (savedStats) {
                    Object.assign(gameStats, JSON.parse(savedStats));
                }
            } catch (e) {
                console.error('Failed to load stats:', e);
            }
        }

        // Export game data as JSON
        function exportData() {
            const exportData = {
                version: '1.0',
                exportDate: new Date().toISOString(),
                gameState: gameState,
                statistics: gameStats
            };

            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `balatro-clone-save-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);
            showNotification('Game exported!');
        }

        // Import game data from JSON
        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importData = JSON.parse(e.target.result);

                    if (importData.version !== '1.0') {
                        showNotification('Invalid save file version!');
                        return;
                    }

                    // Restore game state
                    if (importData.gameState) {
                        Object.assign(gameState, importData.gameState);
                    }

                    // Restore statistics
                    if (importData.statistics) {
                        Object.assign(gameStats, importData.statistics);
                    }

                    saveGame();
                    saveStats();

                    renderHand();
                    renderJokers();
                    renderPlayedCards();
                    renderHandLevels();
                    renderPlanetCards();
                    renderTarotCards();
                    updateBlind();
                    updateDisplay();

                    showNotification('Game imported successfully!');
                } catch (error) {
                    console.error('Import error:', error);
                    showNotification('Invalid save file!');
                }
            };
            reader.readAsText(file);
        }

        // Initialize game
        function initGame(loadSave = true) {
            // Try to load saved game first
            if (loadSave && loadGame()) {
                loadStats();
                showNotification('Game loaded!');
                return;
            }

            // Start new game with difficulty modifiers
            const mods = difficultyModifiers[gameSettings.difficulty] || difficultyModifiers.normal;
            gameState.score = 0;
            gameState.money = mods.startingMoney;
            gameState.ante = 1;
            gameState.round = 1;
            gameState.handsRemaining = mods.startingHands;
            gameState.discardsRemaining = mods.startingDiscards;

            // Generate new seed for new game
            initRNG(generateNewSeed());
            saveSettings();
            gameState.jokers = [];
            gameState.vouchers = [];
            gameState.planetCards = [];
            gameState.tarotCards = [];

            // Initialize hand levels
            Object.keys(handTypes).forEach(hand => {
                gameState.handLevels[hand] = { ...handTypes[hand] };
            });

            // Load stats even for new game
            loadStats();
            gameStats.totalGamesPlayed++;
            gameStats.lastPlayed = new Date().toISOString();
            saveStats();

            createDeck();
            dealHand();
            updateBlind();
            updateDisplay();
            renderHandLevels();
        }

        // Create deck
        function createDeck() {
            gameState.deck = [];
            for (let suit of suits) {
                for (let rank of ranks) {
                    gameState.deck.push({
                        suit: suit,
                        rank: rank,
                        value: getRankValue(rank),
                        color: suitColors[suit],
                        enhancement: null,
                        seal: null,
                        id: `${rank}${suit}`
                    });
                }
            }
            shuffleDeck();
        }

        // Shuffle deck using seeded RNG
        function shuffleDeck() {
            for (let i = gameState.deck.length - 1; i > 0; i--) {
                const j = Math.floor(seededRandom() * (i + 1));
                [gameState.deck[i], gameState.deck[j]] = [gameState.deck[j], gameState.deck[i]];
            }
        }

        // Get rank value
        function getRankValue(rank) {
            if (rank === 'A') return 14;
            if (rank === 'K') return 13;
            if (rank === 'Q') return 12;
            if (rank === 'J') return 11;
            return parseInt(rank);
        }

        // Deal hand
        function dealHand() {
            gameState.hand = [];
            const drawCount = Math.min(gameState.handSize, gameState.deck.length);
            for (let i = 0; i < drawCount; i++) {
                gameState.hand.push(gameState.deck.pop());
            }
            renderHand(true); // Enable dealing animation
        }

        // Render hand with dealing animations
        function renderHand(animate = false) {
            const handContainer = document.getElementById('hand-cards');
            handContainer.innerHTML = '';

            gameState.hand.forEach((card, index) => {
                const cardEl = createCardElement(card);
                cardEl.addEventListener('click', () => selectCard(index));

                // Add dealing animation with stagger
                if (animate) {
                    cardEl.classList.add('dealing');
                    cardEl.style.animationDelay = `${index * 0.08}s`;
                    // Remove animation class after it completes
                    setTimeout(() => {
                        cardEl.classList.remove('dealing');
                        cardEl.style.animationDelay = '';
                    }, 500 + index * 80);
                }

                handContainer.appendChild(cardEl);
            });
        }

        // Create card element
        function createCardElement(card) {
            const cardEl = document.createElement('div');
            cardEl.className = `card ${card.color}`;
            if (card.enhancement) {
                cardEl.classList.add('enhanced', card.enhancement);
            }
            
            const cardFace = document.createElement('div');
            cardFace.className = 'card-face';
            
            const rankEl = document.createElement('div');
            rankEl.className = 'card-rank';
            rankEl.textContent = card.rank;
            
            const suitEl = document.createElement('div');
            suitEl.className = 'card-suit';
            suitEl.textContent = card.suit;
            
            cardFace.appendChild(rankEl);
            cardFace.appendChild(suitEl);
            
            if (card.enhancement) {
                const enhanceEl = document.createElement('div');
                enhanceEl.className = 'card-enhancement';
                enhanceEl.textContent = card.enhancement.toUpperCase();
                cardFace.appendChild(enhanceEl);
            }
            
            if (card.seal) {
                const sealEl = document.createElement('div');
                sealEl.className = `card-seal seal-${card.seal}`;
                sealEl.textContent = card.seal[0].toUpperCase();
                cardFace.appendChild(sealEl);
            }
            
            cardEl.appendChild(cardFace);
            return cardEl;
        }

        // Select card
        function selectCard(index) {
            const card = gameState.hand[index];
            const cardIndex = gameState.selectedCards.indexOf(index);
            
            if (cardIndex > -1) {
                gameState.selectedCards.splice(cardIndex, 1);
            } else {
                if (gameState.selectedCards.length < 5) {
                    gameState.selectedCards.push(index);
                }
            }
            
            updateCardSelection();
            evaluateSelectedCards();
        }

        // Update card selection visual
        function updateCardSelection() {
            const cards = document.querySelectorAll('#hand-cards .card');
            cards.forEach((card, index) => {
                if (gameState.selectedCards.includes(index)) {
                    card.classList.add('selected');
                } else {
                    card.classList.remove('selected');
                }
            });
            
            // Update button states
            const playBtn = document.getElementById('play-btn');
            const discardBtn = document.getElementById('discard-btn');
            
            playBtn.disabled = gameState.selectedCards.length === 0 || gameState.handsRemaining <= 0;
            discardBtn.disabled = gameState.selectedCards.length === 0 || gameState.discardsRemaining <= 0;
        }

        // Evaluate selected cards
        function evaluateSelectedCards() {
            if (gameState.selectedCards.length === 0) {
                document.getElementById('hand-name').textContent = '';
                document.getElementById('score-preview').innerHTML = '';
                gameState.baseMult = 0;
                gameState.baseChips = 0;
                updateDisplay();
                return;
            }
            
            const selectedCardObjects = gameState.selectedCards.map(i => gameState.hand[i]);
            const handResult = evaluateHand(selectedCardObjects);
            
            if (handResult) {
                const handLevel = gameState.handLevels[handResult.type];
                gameState.baseMult = handLevel.mult;
                gameState.baseChips = handLevel.chips;
                
                // Apply joker effects
                let totalMult = gameState.baseMult;
                let totalChips = gameState.baseChips;
                
                gameState.jokers.forEach(joker => {
                    if (joker.effect.mult) totalMult += joker.effect.mult;
                    if (joker.effect.chips) totalChips += joker.effect.chips;
                    
                    // Suit-based multipliers
                    selectedCardObjects.forEach(card => {
                        if (joker.effect.multPerDiamond && card.suit === '') totalMult += joker.effect.multPerDiamond;
                        if (joker.effect.multPerHeart && card.suit === '') totalMult += joker.effect.multPerHeart;
                        if (joker.effect.multPerSpade && card.suit === '') totalMult += joker.effect.multPerSpade;
                        if (joker.effect.multPerClub && card.suit === '') totalMult += joker.effect.multPerClub;
                    });
                    
                    // Hand type bonuses
                    if (joker.effect.multIfPair && handResult.type === 'Pair') totalMult += joker.effect.multIfPair;
                    if (joker.effect.multIfThreeKind && handResult.type === 'Three of a Kind') totalMult += joker.effect.multIfThreeKind;
                    if (joker.effect.multIfFourKind && handResult.type === 'Four of a Kind') totalMult += joker.effect.multIfFourKind;
                    if (joker.effect.multIfStraight && handResult.type === 'Straight') totalMult += joker.effect.multIfStraight;
                    if (joker.effect.multIfFlush && handResult.type === 'Flush') totalMult += joker.effect.multIfFlush;
                });
                
                // Card enhancements
                selectedCardObjects.forEach(card => {
                    if (card.enhancement === 'gold') totalChips += 30;
                    if (card.enhancement === 'steel') totalMult *= 1.5;
                    if (card.enhancement === 'glass') totalMult *= 2;
                    if (card.enhancement === 'stone') totalChips += 50;
                });
                
                const total = Math.floor(totalMult * totalChips);
                
                document.getElementById('hand-name').textContent = handResult.type;
                document.getElementById('score-preview').innerHTML = `
                    <span class="score-mult">${totalMult}x</span>  
                    <span class="score-chips">${totalChips}</span> = 
                    <span class="score-total">${total}</span>
                `;
                
                gameState.baseMult = totalMult;
                gameState.baseChips = totalChips;
            } else {
                document.getElementById('hand-name').textContent = 'No Hand';
                document.getElementById('score-preview').innerHTML = '';
                gameState.baseMult = 0;
                gameState.baseChips = 0;
            }
            
            updateDisplay();
        }

        // Evaluate hand
        function evaluateHand(cards) {
            if (cards.length === 0) return null;
            
            // Sort cards by value
            const sortedCards = [...cards].sort((a, b) => b.value - a.value);
            
            // Count ranks and suits
            const rankCounts = {};
            const suitCounts = {};
            
            sortedCards.forEach(card => {
                rankCounts[card.rank] = (rankCounts[card.rank] || 0) + 1;
                suitCounts[card.suit] = (suitCounts[card.suit] || 0) + 1;
            });
            
            // Get counts
            const counts = Object.values(rankCounts).sort((a, b) => b - a);
            const isFlush = Object.values(suitCounts).some(count => count >= 5);
            
            // Check for straight
            let isStraight = false;
            if (cards.length >= 5) {
                const values = sortedCards.map(c => c.value);
                let consecutiveCount = 1;
                
                for (let i = 1; i < values.length; i++) {
                    if (values[i] === values[i-1] - 1) {
                        consecutiveCount++;
                        if (consecutiveCount >= 5) isStraight = true;
                    } else if (values[i] !== values[i-1]) {
                        consecutiveCount = 1;
                    }
                }
                
                // Check for Ace-low straight (A-2-3-4-5)
                if (values.includes(14) && values.includes(2) && values.includes(3) && values.includes(4) && values.includes(5)) {
                    isStraight = true;
                }
            }
            
            // Check for Royal Flush
            if (isFlush && isStraight) {
                const hasRoyalCards = sortedCards.some(c => c.value === 14) &&
                                     sortedCards.some(c => c.value === 13) &&
                                     sortedCards.some(c => c.value === 12) &&
                                     sortedCards.some(c => c.value === 11) &&
                                     sortedCards.some(c => c.value === 10);
                if (hasRoyalCards) return { type: 'Royal Flush', cards: sortedCards };
            }
            
            // Check other hands
            if (isFlush && isStraight) return { type: 'Straight Flush', cards: sortedCards };
            if (counts[0] === 4) return { type: 'Four of a Kind', cards: sortedCards };
            if (counts[0] === 3 && counts[1] === 2) return { type: 'Full House', cards: sortedCards };
            if (isFlush) return { type: 'Flush', cards: sortedCards };
            if (isStraight) return { type: 'Straight', cards: sortedCards };
            if (counts[0] === 3) return { type: 'Three of a Kind', cards: sortedCards };
            if (counts[0] === 2 && counts[1] === 2) return { type: 'Two Pair', cards: sortedCards };
            if (counts[0] === 2) return { type: 'Pair', cards: sortedCards };
            
            return { type: 'High Card', cards: sortedCards };
        }

        // Play hand
        function playHand() {
            if (gameState.selectedCards.length === 0 || gameState.handsRemaining <= 0) return;
            
            const selectedCardObjects = gameState.selectedCards.map(i => gameState.hand[i]);
            const handResult = evaluateHand(selectedCardObjects);
            
            if (handResult) {
                // Move cards to played area
                gameState.playedCards = selectedCardObjects;
                renderPlayedCards();
                
                // Calculate score
                const handLevel = gameState.handLevels[handResult.type];
                let totalMult = handLevel.mult;
                let totalChips = handLevel.chips;
                
                // Apply all joker effects
                gameState.jokers.forEach(joker => {
                    // Base effects
                    if (joker.effect.mult) totalMult += joker.effect.mult;
                    if (joker.effect.chips) totalChips += joker.effect.chips;
                    
                    // Suit multipliers
                    selectedCardObjects.forEach(card => {
                        if (joker.effect.multPerDiamond && card.suit === '') totalMult += joker.effect.multPerDiamond;
                        if (joker.effect.multPerHeart && card.suit === '') totalMult += joker.effect.multPerHeart;
                        if (joker.effect.multPerSpade && card.suit === '') totalMult += joker.effect.multPerSpade;
                        if (joker.effect.multPerClub && card.suit === '') totalMult += joker.effect.multPerClub;
                        
                        // Even/Odd effects
                        if (joker.effect.multPerEven && card.value % 2 === 0) totalMult += joker.effect.multPerEven;
                        if (joker.effect.chipsPerOdd && card.value % 2 === 1) totalChips += joker.effect.chipsPerOdd;
                        
                        // Ace effects
                        if (joker.effect.multPerAce && card.rank === 'A') totalMult += joker.effect.multPerAce;
                        if (joker.effect.chipsPerAce && card.rank === 'A') totalChips += joker.effect.chipsPerAce;
                        
                        // Face card money
                        if (joker.effect.moneyPerFace && ['J', 'Q', 'K'].includes(card.rank)) {
                            gameState.money += joker.effect.moneyPerFace;
                        }
                    });
                    
                    // Hand type bonuses
                    if (joker.effect.multIfPair && handResult.type === 'Pair') totalMult += joker.effect.multIfPair;
                    if (joker.effect.multIfThreeKind && handResult.type === 'Three of a Kind') totalMult += joker.effect.multIfThreeKind;
                    if (joker.effect.multIfFourKind && handResult.type === 'Four of a Kind') totalMult += joker.effect.multIfFourKind;
                    if (joker.effect.multIfStraight && handResult.type === 'Straight') totalMult += joker.effect.multIfStraight;
                    if (joker.effect.multIfFlush && handResult.type === 'Flush') totalMult += joker.effect.multIfFlush;
                    
                    // Card count effects
                    if (joker.effect.multIfThreeOrLess && selectedCardObjects.length <= 3) totalMult += joker.effect.multIfThreeOrLess;
                    
                    // Money multiplier
                    if (joker.effect.multPerDollar) totalMult += joker.effect.multPerDollar * gameState.money;
                    
                    // Empty slot multiplier
                    if (joker.effect.xMultPerEmpty) {
                        const emptySlots = gameState.maxJokers - gameState.jokers.length;
                        totalMult *= (1 + joker.effect.xMultPerEmpty * emptySlots);
                    }
                    
                    // Level up chance
                    if (joker.effect.levelUpChance && Math.random() < joker.effect.levelUpChance) {
                        gameState.handLevels[handResult.type].level++;
                        gameState.handLevels[handResult.type].mult += 1;
                        gameState.handLevels[handResult.type].chips += 5;
                        showNotification(`${handResult.type} leveled up!`);
                    }
                });
                
                // Apply card enhancements
                selectedCardObjects.forEach(card => {
                    if (card.enhancement === 'gold') totalChips += 30;
                    if (card.enhancement === 'steel') totalMult *= 1.5;
                    if (card.enhancement === 'glass') totalMult *= 2;
                    if (card.enhancement === 'stone') totalChips += 50;
                    
                    // Seal effects
                    if (card.seal === 'gold') gameState.money += 3;
                    if (card.seal === 'red') {
                        // Retrigger this card
                        totalChips += 11; // Base chip value
                    }
                    if (card.seal === 'blue') {
                        // Add planet card for this hand type
                        const planetCard = planetCardTypes.find(p => p.hand === handResult.type);
                        if (planetCard && gameState.planetCards.length < 10) {
                            gameState.planetCards.push({...planetCard});
                        }
                    }
                    if (card.seal === 'purple') {
                        // Create a tarot card
                        if (gameState.tarotCards.length < 10) {
                            const randomTarot = tarotCardTypes[Math.floor(Math.random() * tarotCardTypes.length)];
                            gameState.tarotCards.push({...randomTarot});
                        }
                    }
                });
                
                const handScore = Math.floor(totalMult * totalChips);
                gameState.score += handScore;

                // Update statistics
                gameStats.totalHandsPlayed++;
                gameStats.handCounts[handResult.type] = (gameStats.handCounts[handResult.type] || 0) + 1;
                if (gameState.score > gameStats.highestScore) {
                    gameStats.highestScore = gameState.score;
                }
                if (gameState.ante > gameStats.highestAnte) {
                    gameStats.highestAnte = gameState.ante;
                }
                saveStats();

                // Update combo system
                updateCombo(handResult.type);

                // Apply combo bonus
                const comboBonus = getComboBonus();
                if (comboBonus > 0) {
                    totalMult += comboBonus;
                }

                // Apply new joker effects
                const newEffects = applyNewJokerEffects(selectedCardObjects, handResult.type, totalMult, totalChips);
                totalMult = newEffects.mult;
                totalChips = newEffects.chips;

                // Recalculate with all bonuses
                const finalHandScore = Math.floor(totalMult * totalChips);
                gameState.score += finalHandScore - handScore + handScore; // Keep original addition logic

                // Show enhanced score animations
                const rect = document.getElementById('played-cards').getBoundingClientRect();
                showScoreBurst(finalHandScore, rect.left + rect.width / 2, rect.top);

                // Trigger screen shake on big scores
                if (finalHandScore >= 5000) {
                    triggerScreenShake(Math.min(finalHandScore / 10000, 2));
                }

                // Hand name animation
                const handNameEl = document.getElementById('hand-name');
                handNameEl.classList.remove('animating');
                void handNameEl.offsetWidth; // Trigger reflow
                handNameEl.classList.add('animating');

                // Update blind pulse
                updateBlindPulse();

                // Show legacy score animation
                showScoreAnimation(finalHandScore);

                // Track achievements
                updateAchievementProgress('speed_demon', 1);
                if (handResult.type === 'Flush') updateAchievementProgress('flush_master', 1);
                if (handResult.type === 'Straight') updateAchievementProgress('straight_shooter', 1);
                if (handResult.type === 'Royal Flush') unlockAchievement('royal_reverence');
                checkAchievements();

                // Track hands without discard
                comboState.handsWithoutDiscard++;

                // Remove selected cards from hand
                const newHand = gameState.hand.filter((_, index) => !gameState.selectedCards.includes(index));
                gameState.hand = newHand;
                
                // Draw new cards
                while (gameState.hand.length < gameState.handSize && gameState.deck.length > 0) {
                    gameState.hand.push(gameState.deck.pop());
                }
                
                // Update game state
                gameState.handsRemaining--;
                gameState.selectedCards = [];
                
                // Check if blind is beaten
                if (gameState.score >= gameState.currentBlind.requirement) {
                    // Win flash effect
                    triggerWinFlash();

                    // Check challenge achievements
                    if (comboState.handsWithoutDiscard === 1) unlockAchievement('one_hand_wonder');
                    if (comboState.handsWithoutDiscard > 0 && gameState.discardsRemaining === 3) unlockAchievement('no_discard');
                    if (gameState.handsRemaining === 1) unlockAchievement('survivor');

                    // Track boss blind defeats
                    if (gameState.round === 3) {
                        comboState.bossDefeated++;
                        updateAchievementProgress('boss_slayer', 1);
                    }

                    setTimeout(() => {
                        showNotification('Blind Defeated!');
                        // Reset hands without discard for next blind
                        comboState.handsWithoutDiscard = 0;
                        nextRound();
                    }, 1500);
                }
                
                // Check if out of hands
                if (gameState.handsRemaining === 0 && gameState.score < gameState.currentBlind.requirement) {
                    gameOver();
                }
                
                renderHand();
                updateDisplay();
            }
        }

        // Discard cards
        function discardCards() {
            if (gameState.selectedCards.length === 0 || gameState.discardsRemaining <= 0) return;

            // Reset hands without discard counter (discard was used)
            comboState.handsWithoutDiscard = 0;

            // Remove selected cards
            const newHand = gameState.hand.filter((_, index) => !gameState.selectedCards.includes(index));
            gameState.hand = newHand;
            
            // Draw new cards
            while (gameState.hand.length < gameState.handSize && gameState.deck.length > 0) {
                gameState.hand.push(gameState.deck.pop());
            }
            
            gameState.discardsRemaining--;
            gameState.selectedCards = [];
            gameState.playedCards = [];
            
            renderHand();
            renderPlayedCards();
            updateDisplay();
            updateCardSelection();
            evaluateSelectedCards();
        }

        // Sort hand
        function sortHand() {
            gameState.hand.sort((a, b) => {
                // Sort by rank first
                if (a.value !== b.value) return b.value - a.value;
                // Then by suit
                return suits.indexOf(a.suit) - suits.indexOf(b.suit);
            });
            renderHand();
        }

        // Render played cards
        function renderPlayedCards() {
            const playedContainer = document.getElementById('played-cards');
            playedContainer.innerHTML = '';
            
            gameState.playedCards.forEach(card => {
                const cardEl = createCardElement(card);
                playedContainer.appendChild(cardEl);
            });
        }

        // Update blind
        function updateBlind() {
            let blindType;
            if (gameState.round === 1) blindType = blindTypes.small;
            else if (gameState.round === 2) blindType = blindTypes.big;
            else blindType = blindTypes.boss;
            
            const baseRequirement = 300 * Math.pow(1.5, gameState.ante - 1);
            gameState.currentBlind = {
                ...blindType,
                requirement: Math.floor(baseRequirement * blindType.multiplier)
            };
            
            // Add boss effect if boss blind
            if (blindType === blindTypes.boss) {
                const randomEffect = blindType.effects[Math.floor(Math.random() * blindType.effects.length)];
                gameState.currentBlind.effect = randomEffect;
                gameState.currentBlind.name = randomEffect.name;
            }
            
            document.getElementById('blind-name').textContent = gameState.currentBlind.name;
            document.getElementById('blind-requirement').textContent = gameState.currentBlind.requirement;
            
            // Add boss indicator
            const blindInfo = document.getElementById('blind-info');
            blindInfo.querySelectorAll('.boss-blind-indicator').forEach(el => el.remove());
            if (gameState.round === 3) {
                const bossIndicator = document.createElement('div');
                bossIndicator.className = 'boss-blind-indicator';
                bossIndicator.textContent = 'BOSS';
                blindInfo.appendChild(bossIndicator);
            }
        }

        // Next round
        function nextRound() {
            gameState.round++;
            
            if (gameState.round > gameState.maxRounds) {
                // Next ante
                gameState.ante++;
                gameState.round = 1;
                gameState.money += 4; // Ante bonus
                showNotification(`Ante ${gameState.ante}!`);
            }
            
            // Reset for new round
            gameState.handsRemaining = 4;
            gameState.discardsRemaining = 3;
            gameState.score = 0;
            gameState.selectedCards = [];
            gameState.playedCards = [];
            
            // Apply voucher effects
            gameState.vouchers.forEach(voucher => {
                if (voucher.effect.extraHands) gameState.handsRemaining += voucher.effect.extraHands;
                if (voucher.effect.extraDiscards) gameState.discardsRemaining += voucher.effect.extraDiscards;
            });
            
            // Rebuild deck
            createDeck();
            dealHand();
            updateBlind();
            updateDisplay();
            
            // Open shop
            openShop();
        }

        // Update display
        function updateDisplay() {
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('current-chips').textContent = gameState.score;
            document.getElementById('money').textContent = `$${gameState.money}`;
            document.getElementById('ante').textContent = `Ante ${gameState.ante}`;
            document.getElementById('round').textContent = `Round ${gameState.round}/${gameState.maxRounds}`;
            document.getElementById('hands-remaining').textContent = `Hands: ${gameState.handsRemaining}`;
            document.getElementById('discards-remaining').textContent = `Discards: ${gameState.discardsRemaining}`;
            document.getElementById('base-mult').textContent = gameState.baseMult;
            document.getElementById('base-chips').textContent = gameState.baseChips;
            document.getElementById('deck-count').textContent = gameState.deck.length + gameState.hand.length;
            document.getElementById('deck-draw').textContent = gameState.deck.length;
            document.getElementById('joker-count').textContent = `${gameState.jokers.length}/${gameState.maxJokers}`;

            // Update progress bar
            if (gameState.currentBlind) {
                const percentage = Math.min((gameState.score / gameState.currentBlind.requirement) * 100, 100);
                const progressBar = document.getElementById('progress-bar');
                const progressText = document.getElementById('progress-text');

                progressBar.style.width = `${percentage}%`;
                progressText.textContent = `${gameState.score} / ${gameState.currentBlind.requirement}`;

                if (gameState.score >= gameState.currentBlind.requirement) {
                    progressBar.classList.add('winning');
                } else {
                    progressBar.classList.remove('winning');
                }
            }

            // Update vouchers display
            const voucherList = document.getElementById('voucher-list');
            voucherList.innerHTML = '';
            gameState.vouchers.forEach(voucher => {
                const voucherEl = document.createElement('div');
                voucherEl.className = 'voucher-item';
                voucherEl.textContent = voucher.name;
                voucherList.appendChild(voucherEl);
            });

            // Autosave
            saveGame();
        }

        // Render hand levels
        function renderHandLevels() {
            const container = document.getElementById('hand-levels-list');
            container.innerHTML = '';
            
            Object.entries(gameState.handLevels).forEach(([name, stats]) => {
                const item = document.createElement('div');
                item.className = 'hand-level-item';
                item.innerHTML = `
                    <span class="hand-level-name">${name}</span>
                    <div class="hand-level-stats">
                        <span class="hand-level-mult">${stats.mult}</span>
                        <span class="hand-level-chips">+${stats.chips}</span>
                        <span class="hand-level-level">Lv${stats.level}</span>
                    </div>
                `;
                container.appendChild(item);
            });
        }

        // Render jokers
        function renderJokers() {
            const slots = document.querySelectorAll('.joker-slot');
            slots.forEach((slot, index) => {
                slot.innerHTML = '';
                slot.classList.remove('filled');

                if (gameState.jokers[index]) {
                    const joker = gameState.jokers[index];
                    slot.classList.add('filled');

                    const jokerCard = document.createElement('div');
                    jokerCard.className = 'joker-card';
                    jokerCard.innerHTML = `
                        <div class="joker-icon">${joker.icon}</div>
                        <div class="joker-name">${joker.name}</div>
                        <div class="joker-desc">${joker.desc}</div>
                    `;
                    slot.appendChild(jokerCard);
                }
            });

            // Re-add tooltips after rendering
            if (typeof addJokerTooltips === 'function') {
                addJokerTooltips();
            }
        }

        // Open shop
        function openShop() {
            const modal = document.getElementById('shop-modal');
            modal.classList.add('active');
            
            generateShopItems();
            renderShopItems('jokers');
            updateShopMoney();
        }

        // Close shop
        function closeShop() {
            const modal = document.getElementById('shop-modal');
            modal.classList.remove('active');
        }

        // Generate shop items
        function generateShopItems() {
            gameState.shopItems = {
                jokers: [],
                tarots: [],
                planets: [],
                spectrals: [],
                vouchers: [],
                packs: []
            };

            // Generate jokers
            for (let i = 0; i < 2; i++) {
                const randomJoker = jokerTypes[Math.floor(Math.random() * jokerTypes.length)];
                gameState.shopItems.jokers.push({...randomJoker, id: `joker-${i}`});
            }

            // Generate tarot cards
            for (let i = 0; i < 2; i++) {
                const randomTarot = tarotCardTypes[Math.floor(Math.random() * tarotCardTypes.length)];
                gameState.shopItems.tarots.push({...randomTarot, id: `tarot-${i}`});
            }

            // Generate planet cards
            for (let i = 0; i < 2; i++) {
                const randomPlanet = planetCardTypes[Math.floor(Math.random() * planetCardTypes.length)];
                gameState.shopItems.planets.push({...randomPlanet, id: `planet-${i}`, price: 3});
            }

            // Generate spectral cards (rare - only 1 at a time, 30% chance to appear)
            if (Math.random() < 0.3) {
                const availableSpectrals = spectralCardTypes.filter(s => s.rarity !== 'legendary' || Math.random() < 0.1);
                if (availableSpectrals.length > 0) {
                    const randomSpectral = availableSpectrals[Math.floor(Math.random() * availableSpectrals.length)];
                    gameState.shopItems.spectrals.push({...randomSpectral, id: `spectral-0`});
                }
            }

            // Generate vouchers
            const randomVoucher = voucherTypes[Math.floor(Math.random() * voucherTypes.length)];
            gameState.shopItems.vouchers.push({...randomVoucher, id: `voucher-0`});

            // Generate card packs
            gameState.shopItems.packs = [
                { name: 'Arcana Pack', desc: '3 Tarot cards', price: 4, id: 'pack-0', icon: '' },
                { name: 'Celestial Pack', desc: '3 Planet cards', price: 4, id: 'pack-1', icon: '' },
                { name: 'Buffoon Pack', desc: '2 Jokers', price: 4, id: 'pack-2', icon: '' },
                { name: 'Standard Pack', desc: '3 Playing cards', price: 4, id: 'pack-3', icon: '' },
                { name: 'Spectral Pack', desc: '2 Spectral cards', price: 6, id: 'pack-4', icon: '' }
            ];
        }

        // Render shop items
        function renderShopItems(category) {
            const container = document.getElementById('shop-items');
            container.innerHTML = '';
            
            const items = gameState.shopItems[category] || [];
            
            items.forEach(item => {
                if (item.purchased) return;
                
                const itemEl = document.createElement('div');
                itemEl.className = 'shop-item';
                itemEl.innerHTML = `
                    <div class="shop-item-icon">${item.icon || ''}</div>
                    <div class="shop-item-name">${item.name}</div>
                    <div class="shop-item-desc">${item.desc || ''}</div>
                    <div class="shop-item-price">$${item.price}</div>
                `;
                
                itemEl.addEventListener('click', () => purchaseItem(category, item));
                container.appendChild(itemEl);
            });
        }

        // Purchase item
        function purchaseItem(category, item) {
            if (gameState.money < item.price) {
                showNotification('Not enough money!');
                return;
            }
            
            gameState.money -= item.price;
            item.purchased = true;
            
            switch(category) {
                case 'jokers':
                    if (gameState.jokers.length < gameState.maxJokers) {
                        gameState.jokers.push(item);
                        renderJokers();
                        showNotification(`Bought ${item.name}!`);
                    } else {
                        showNotification('Joker slots full!');
                        gameState.money += item.price;
                        item.purchased = false;
                    }
                    break;
                    
                case 'tarots':
                    if (gameState.tarotCards.length < 10) {
                        gameState.tarotCards.push(item);
                        renderTarotCards();
                        showNotification(`Bought ${item.name}!`);
                    } else {
                        showNotification('Tarot card limit reached!');
                        gameState.money += item.price;
                        item.purchased = false;
                    }
                    break;
                    
                case 'planets':
                    if (gameState.planetCards.length < 10) {
                        gameState.planetCards.push(item);
                        // Level up the corresponding hand
                        const handType = item.hand;
                        if (gameState.handLevels[handType]) {
                            gameState.handLevels[handType].level++;
                            gameState.handLevels[handType].mult += 1;
                            gameState.handLevels[handType].chips += 5;
                        }
                        renderPlanetCards();
                        renderHandLevels();
                        showNotification(`${item.hand} leveled up!`);
                    } else {
                        showNotification('Planet card limit reached!');
                        gameState.money += item.price;
                        item.purchased = false;
                    }
                    break;
                    
                case 'spectrals':
                    if (gameState.spectralCards.length < 4) {
                        gameState.spectralCards.push(item);
                        renderSpectralCards();
                        showNotification(`Bought ${item.name}!`);
                        // Discover in codex
                        discoverItem('spectrals', item.name);
                    } else {
                        showNotification('Spectral card limit reached!');
                        gameState.money += item.price;
                        item.purchased = false;
                    }
                    break;

                case 'vouchers':
                    gameState.vouchers.push(item);
                    applyVoucherEffect(item);
                    showNotification(`Bought ${item.name}!`);
                    break;
                    
                case 'packs':
                    openPack(item);
                    showNotification(`Opened ${item.name}!`);
                    break;
            }
            
            updateShopMoney();
            updateDisplay();
            renderShopItems(category);
        }

        // Apply voucher effect
        function applyVoucherEffect(voucher) {
            if (voucher.effect.jokerSlots) {
                gameState.maxJokers += voucher.effect.jokerSlots;
                renderJokers();
            }
            if (voucher.effect.handSize) {
                gameState.handSize += voucher.effect.handSize;
            }
            if (voucher.effect.rerollDiscount) {
                gameState.rerollCost = Math.max(1, gameState.rerollCost - voucher.effect.rerollDiscount);
                document.getElementById('reroll-btn').textContent = `Reroll ($${gameState.rerollCost})`;
            }
        }

        // Open pack
        function openPack(pack) {
            // Implementation for opening packs
            showNotification(`Opened ${pack.name}!`);
        }

        // Use planet card
        function usePlanetCard(index) {
            if (index >= gameState.planetCards.length) return;

            const card = gameState.planetCards[index];
            const handType = card.hand;

            if (gameState.handLevels[handType]) {
                gameState.handLevels[handType].level++;
                gameState.handLevels[handType].mult += 1;
                gameState.handLevels[handType].chips += 5;

                showNotification(`${handType} leveled up to Lv${gameState.handLevels[handType].level}!`);

                // Remove the used card
                gameState.planetCards.splice(index, 1);

                renderPlanetCards();
                renderHandLevels();
                updateDisplay();
            }
        }

        // Render planet cards
        function renderPlanetCards() {
            const container = document.getElementById('planet-cards');
            container.innerHTML = '';

            gameState.planetCards.slice(0, 4).forEach((card, index) => {
                const cardEl = document.createElement('div');
                cardEl.className = 'planet-card usable';
                cardEl.innerHTML = `${card.icon} ${card.name}`;
                cardEl.title = `Level up ${card.hand}`;
                cardEl.addEventListener('click', () => usePlanetCard(index));
                container.appendChild(cardEl);
            });
        }

        // Use tarot card
        function useTarotCard(index) {
            if (index >= gameState.tarotCards.length) return;

            const card = gameState.tarotCards[index];
            let message = '';

            // Implement tarot card effects
            switch(card.name) {
                case 'The Hermit':
                    gameState.money *= 2;
                    message = 'Money doubled!';
                    break;

                case 'The Magician':
                case 'The Empress':
                case 'The Chariot':
                case 'The Devil':
                case 'The Tower':
                case 'Justice':
                    // Random enhancement to 2 cards in hand
                    const enhancements = ['gold', 'steel', 'glass', 'stone'];
                    const randomEnhancement = enhancements[Math.floor(Math.random() * enhancements.length)];
                    let enhanced = 0;
                    for (let i = 0; i < gameState.hand.length && enhanced < 2; i++) {
                        if (!gameState.hand[i].enhancement) {
                            gameState.hand[i].enhancement = randomEnhancement;
                            enhanced++;
                        }
                    }
                    message = `Enhanced ${enhanced} cards with ${randomEnhancement}!`;
                    renderHand();
                    break;

                case 'Strength':
                    // Increase rank of 2 random cards
                    for (let i = 0; i < Math.min(2, gameState.hand.length); i++) {
                        const card = gameState.hand[i];
                        const rankIndex = ranks.indexOf(card.rank);
                        if (rankIndex < ranks.length - 1) {
                            card.rank = ranks[rankIndex + 1];
                            card.value = getRankValue(card.rank);
                        }
                    }
                    message = 'Upgraded 2 cards!';
                    renderHand();
                    break;

                case 'Judgement':
                    // Create random joker
                    if (gameState.jokers.length < gameState.maxJokers) {
                        const randomJoker = jokerTypes[Math.floor(Math.random() * jokerTypes.length)];
                        gameState.jokers.push({...randomJoker});
                        renderJokers();
                        message = `Created ${randomJoker.name}!`;
                    } else {
                        message = 'Joker slots full!';
                    }
                    break;

                case 'The Star':
                case 'The Moon':
                case 'The Sun':
                case 'The World':
                    // Change suit of 3 random cards
                    const suitMap = {
                        'The Star': '',
                        'The Moon': '',
                        'The Sun': '',
                        'The World': ''
                    };
                    const targetSuit = suitMap[card.name];
                    for (let i = 0; i < Math.min(3, gameState.hand.length); i++) {
                        gameState.hand[i].suit = targetSuit;
                        gameState.hand[i].color = suitColors[targetSuit];
                    }
                    message = `Changed 3 cards to ${targetSuit}!`;
                    renderHand();
                    break;

                default:
                    message = `Used ${card.name}!`;
            }

            // Remove the used card
            gameState.tarotCards.splice(index, 1);

            showNotification(message);
            renderTarotCards();
            updateDisplay();
        }

        // Render tarot cards
        function renderTarotCards() {
            const container = document.getElementById('tarot-cards');
            container.innerHTML = '';

            gameState.tarotCards.slice(0, 4).forEach((card, index) => {
                const cardEl = document.createElement('div');
                cardEl.className = 'tarot-card usable';
                cardEl.innerHTML = `${card.icon} ${card.name}`;
                cardEl.title = card.desc;
                cardEl.addEventListener('click', () => useTarotCard(index));
                container.appendChild(cardEl);
            });
        }

        // Update shop money
        function updateShopMoney() {
            document.getElementById('shop-money').textContent = `$${gameState.money}`;
        }

        // Reroll shop
        function rerollShop() {
            if (gameState.money < gameState.rerollCost) {
                showNotification('Not enough money!');
                return;
            }
            
            gameState.money -= gameState.rerollCost;
            generateShopItems();
            
            // Get active tab
            const activeTab = document.querySelector('.shop-tab.active');
            if (activeTab) {
                renderShopItems(activeTab.dataset.tab);
            }
            
            updateShopMoney();
            updateDisplay();
            showNotification('Shop rerolled!');
        }

        // Show notification
        function showNotification(message) {
            const notification = document.createElement('div');
            notification.className = 'notification';
            notification.textContent = message;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.remove();
            }, 2000);
        }

        // Show score animation
        function showScoreAnimation(score) {
            const animation = document.createElement('div');
            animation.className = 'combo-text';
            animation.textContent = `+${score}`;
            animation.style.left = '50%';
            animation.style.top = '40%';
            document.body.appendChild(animation);
            
            setTimeout(() => {
                animation.remove();
            }, 2000);
        }

        // Game over
        function gameOver() {
            const modal = document.getElementById('game-over-modal');
            modal.classList.add('active');

            // Calculate favorite hand
            let favoriteHand = 'High Card';
            let maxCount = 0;
            Object.entries(gameStats.handCounts).forEach(([hand, count]) => {
                if (count > maxCount) {
                    maxCount = count;
                    favoriteHand = hand;
                }
            });
            gameStats.favoriteHand = favoriteHand;
            saveStats();

            const stats = document.getElementById('game-over-stats');
            stats.innerHTML = `
                <div style="margin-bottom: 20px;">
                    <div style="font-size: 28px; color: #e74c3c; margin-bottom: 10px;">Final Score: ${gameState.score}</div>
                    <div>Ante Reached: ${gameState.ante} - Round ${gameState.round}</div>
                </div>
                <div style="border-top: 2px solid rgba(255,255,255,0.2); padding-top: 15px; margin-top: 15px;">
                    <div style="font-size: 18px; margin-bottom: 10px;">Career Statistics</div>
                    <div>Games Played: ${gameStats.totalGamesPlayed}</div>
                    <div>Hands Played: ${gameStats.totalHandsPlayed}</div>
                    <div>Highest Score: ${gameStats.highestScore}</div>
                    <div>Highest Ante: ${gameStats.highestAnte}</div>
                    <div>Favorite Hand: ${gameStats.favoriteHand}</div>
                </div>
            `;
        }

        // Restart game
        function restartGame() {
            document.getElementById('game-over-modal').classList.remove('active');
            // Reset combo state
            comboState.lastHandType = null;
            comboState.streakCount = 0;
            comboState.handsWithoutDiscard = 0;
            initGame(false);
        }

        // ===== ACHIEVEMENT SYSTEM =====

        // Load achievements from localStorage
        function loadAchievements() {
            try {
                const saved = localStorage.getItem(ACHIEVEMENTS_KEY);
                if (saved) {
                    achievementsState = JSON.parse(saved);
                }
            } catch (e) {
                console.error('Failed to load achievements:', e);
            }
        }

        // Save achievements to localStorage
        function saveAchievements() {
            try {
                localStorage.setItem(ACHIEVEMENTS_KEY, JSON.stringify(achievementsState));
            } catch (e) {
                console.error('Failed to save achievements:', e);
            }
        }

        // Check if achievement is unlocked
        function isAchievementUnlocked(id) {
            return achievementsState.unlocked[id] === true;
        }

        // Unlock an achievement
        function unlockAchievement(id) {
            if (isAchievementUnlocked(id)) return;

            const achievement = achievementDefinitions.find(a => a.id === id);
            if (!achievement) return;

            achievementsState.unlocked[id] = true;
            achievementsState.totalPoints += achievement.points;
            saveAchievements();

            showAchievementNotification(achievement);
        }

        // Update achievement progress
        function updateAchievementProgress(id, value) {
            const achievement = achievementDefinitions.find(a => a.id === id);
            if (!achievement || !achievement.target) return;

            achievementsState.progress[id] = (achievementsState.progress[id] || 0) + value;
            saveAchievements();

            if (achievementsState.progress[id] >= achievement.target) {
                unlockAchievement(id);
            }
        }

        // Show achievement notification
        function showAchievementNotification(achievement) {
            const notification = document.createElement('div');
            notification.className = 'achievement-notification';
            notification.innerHTML = `
                <div class="achievement-header">
                    <div class="achievement-icon">${achievement.icon}</div>
                    <div class="achievement-title">ACHIEVEMENT UNLOCKED!</div>
                </div>
                <div class="achievement-name">${achievement.name}</div>
                <div class="achievement-desc">${achievement.desc}</div>
                <div>
                    <span class="achievement-points">+${achievement.points} Points</span>
                    <span class="achievement-rarity ${achievement.rarity}">${achievement.rarity.toUpperCase()}</span>
                </div>
            `;
            document.body.appendChild(notification);

            setTimeout(() => {
                notification.classList.add('fade-out');
                setTimeout(() => notification.remove(), 500);
            }, 4000);
        }

        // Check all achievement conditions
        function checkAchievements() {
            // Score achievements
            if (gameState.score >= 100000) unlockAchievement('high_roller');
            if (gameState.score >= 1000000) unlockAchievement('million_dollar');

            // Ante achievements
            if (gameState.ante >= 4) unlockAchievement('first_win');
            if (gameState.ante >= 5) unlockAchievement('ante_5');
            if (gameState.ante >= 8) unlockAchievement('ante_8');
            if (gameState.ante >= 10) unlockAchievement('ante_10');

            // Combo achievements
            if (comboState.streakCount >= 5) unlockAchievement('combo_king');

            // Collection achievements
            if (gameState.jokers.length >= 5) unlockAchievement('joker_collector');
            if (gameState.money >= 50) unlockAchievement('wealthy');

            // Enhanced cards
            const enhancedCount = gameState.hand.filter(c => c.enhancement).length;
            if (enhancedCount >= 3) unlockAchievement('enhancement_master');

            // Planet cards (check unique hands)
            const uniquePlanets = new Set(gameState.planetCards.map(p => p.hand));
            if (uniquePlanets.size >= 9) unlockAchievement('planet_set');

            // Hands played
            updateAchievementProgress('speed_demon', 0); // Just check current
            if ((achievementsState.progress['speed_demon'] || 0) >= 100) {
                unlockAchievement('speed_demon');
            }

            // Games played
            if (gameStats.totalGamesPlayed >= 50) unlockAchievement('veteran');
        }

        // Open achievement modal
        function openAchievementModal() {
            const modal = document.getElementById('achievement-modal');
            modal.classList.add('active');
            renderAchievements();
        }

        // Close achievement modal
        function closeAchievementModal() {
            document.getElementById('achievement-modal').classList.remove('active');
        }

        // Render achievements in modal
        function renderAchievements() {
            const grid = document.getElementById('achievement-grid');
            const stats = document.getElementById('achievement-stats');

            const unlockedCount = Object.keys(achievementsState.unlocked).length;
            stats.textContent = `${unlockedCount}/${achievementDefinitions.length} Unlocked  ${achievementsState.totalPoints} Points`;

            grid.innerHTML = '';
            achievementDefinitions.forEach(achievement => {
                const isUnlocked = isAchievementUnlocked(achievement.id);
                const progress = achievementsState.progress[achievement.id] || 0;
                const target = achievement.target || 1;

                const card = document.createElement('div');
                card.className = `achievement-card ${isUnlocked ? 'unlocked' : 'locked'}`;
                card.innerHTML = `
                    <div class="achievement-card-icon">${achievement.icon}</div>
                    <div class="achievement-card-name">${achievement.name}</div>
                    <div class="achievement-card-desc">${achievement.desc}</div>
                    ${achievement.target ? `
                        <div class="achievement-progress-bar">
                            <div class="achievement-progress-fill" style="width: ${Math.min((progress / target) * 100, 100)}%"></div>
                        </div>
                        <div style="font-size: 10px; color: #aaa; text-align: center; margin-top: 5px;">${progress}/${target}</div>
                    ` : ''}
                    <div style="text-align: center; margin-top: 5px;">
                        <span class="achievement-rarity ${achievement.rarity}">${achievement.rarity}</span>
                        <span style="color: #4ecdc4; font-size: 11px;">+${achievement.points}</span>
                    </div>
                `;
                grid.appendChild(card);
            });
        }

        // ===== SETTINGS SYSTEM =====

        // Load settings
        function loadSettings() {
            try {
                const saved = localStorage.getItem(SETTINGS_KEY);
                if (saved) {
                    Object.assign(gameSettings, JSON.parse(saved));
                }
            } catch (e) {
                console.error('Failed to load settings:', e);
            }
        }

        // Save settings
        function saveSettings() {
            try {
                localStorage.setItem(SETTINGS_KEY, JSON.stringify(gameSettings));
            } catch (e) {
                console.error('Failed to save settings:', e);
            }
        }

        // Open settings modal
        function openSettingsModal() {
            const modal = document.getElementById('settings-modal');
            modal.classList.add('active');
            updateSettingsUI();
        }

        // Close settings modal
        function closeSettingsModal() {
            document.getElementById('settings-modal').classList.remove('active');
        }

        // Update settings UI
        function updateSettingsUI() {
            // Update difficulty select
            document.getElementById('difficulty-select').value = gameSettings.difficulty;

            // Update toggles
            document.getElementById('animations-toggle').classList.toggle('active', gameSettings.animations);
            document.getElementById('shake-toggle').classList.toggle('active', gameSettings.shake);

            // Update seed
            document.getElementById('seed-input').value = gameSettings.seed || 'N/A';

            // Update statistics
            document.getElementById('stat-games').textContent = gameStats.totalGamesPlayed;
            document.getElementById('stat-hands').textContent = gameStats.totalHandsPlayed;
            document.getElementById('stat-highscore').textContent = gameStats.highestScore.toLocaleString();
            document.getElementById('stat-ante').textContent = gameStats.highestAnte;
        }

        // Change difficulty
        function changeDifficulty(value) {
            gameSettings.difficulty = value;
            saveSettings();
            showNotification(`Difficulty set to ${value.charAt(0).toUpperCase() + value.slice(1)}`);
        }

        // Toggle setting
        function toggleSetting(setting) {
            gameSettings[setting] = !gameSettings[setting];
            saveSettings();
            updateSettingsUI();
        }

        // Copy seed
        function copySeed() {
            const seed = document.getElementById('seed-input').value;
            navigator.clipboard.writeText(seed).then(() => {
                showNotification('Seed copied!');
            }).catch(() => {
                showNotification('Copy failed');
            });
        }

        // New seed
        function newSeed() {
            const newSeedStr = generateNewSeed();
            initRNG(newSeedStr);
            saveSettings();
            updateSettingsUI();
            showNotification('New seed generated!');
        }

        // Apply difficulty modifiers to game initialization
        function applyDifficultyModifiers() {
            const mods = difficultyModifiers[gameSettings.difficulty] || difficultyModifiers.normal;
            gameState.money = mods.startingMoney;
            gameState.handsRemaining = mods.startingHands;
            gameState.discardsRemaining = mods.startingDiscards;
        }

        // ===== VISUAL EFFECTS SYSTEM =====

        // Create particle effect
        function createParticle(x, y, text, color = '#ffd700') {
            const particle = document.createElement('div');
            particle.className = 'particle';
            particle.textContent = text;
            particle.style.left = `${x + (Math.random() - 0.5) * 50}px`;
            particle.style.top = `${y}px`;
            particle.style.color = color;
            particle.style.fontSize = `${14 + Math.random() * 10}px`;
            particle.style.fontWeight = 'bold';
            document.body.appendChild(particle);

            setTimeout(() => particle.remove(), 1000);
        }

        // Create multiple particles
        function createParticleBurst(x, y, count = 5) {
            const particles = ['', '', '', '+', ''];
            const colors = ['#ffd700', '#4ecdc4', '#ff6b6b', '#f1c40f', '#9b59b6'];
            for (let i = 0; i < count; i++) {
                setTimeout(() => {
                    createParticle(
                        x,
                        y,
                        particles[Math.floor(Math.random() * particles.length)],
                        colors[Math.floor(Math.random() * colors.length)]
                    );
                }, i * 50);
            }
        }

        // Screen shake effect
        function triggerScreenShake(intensity = 1) {
            const container = document.querySelector('.game-container');
            container.classList.add('shaking');
            setTimeout(() => container.classList.remove('shaking'), 400 * intensity);
        }

        // Score burst effect
        function showScoreBurst(score, x, y) {
            const burst = document.createElement('div');
            burst.className = 'score-burst';
            burst.textContent = `+${score.toLocaleString()}`;
            burst.style.left = `${x}px`;
            burst.style.top = `${y}px`;
            document.body.appendChild(burst);

            if (score >= 1000) {
                createParticleBurst(x, y, Math.min(score / 500, 15));
            }

            setTimeout(() => burst.remove(), 1500);
        }

        // Win flash effect
        function triggerWinFlash() {
            const flash = document.createElement('div');
            flash.className = 'win-flash';
            document.body.appendChild(flash);
            setTimeout(() => flash.remove(), 500);
        }

        // Blind pulse effect
        function updateBlindPulse() {
            const blindInfo = document.getElementById('blind-info');
            if (gameState.currentBlind) {
                const progress = gameState.score / gameState.currentBlind.requirement;
                if (progress >= 0.75 && progress < 1) {
                    blindInfo.classList.add('pulsing');
                } else {
                    blindInfo.classList.remove('pulsing');
                }
            }
        }

        // ===== COMBO SYSTEM =====

        // Update combo display
        function updateComboDisplay() {
            const display = document.getElementById('combo-display');
            const text = document.getElementById('combo-text');

            if (comboState.streakCount > 1) {
                display.classList.remove('hidden');
                text.textContent = `Combo x${comboState.streakCount}`;
                if (comboState.streakCount >= 3) {
                    text.classList.add('streak-fire');
                } else {
                    text.classList.remove('streak-fire');
                }
            } else {
                display.classList.add('hidden');
            }
        }

        // Update combo on hand play
        function updateCombo(handType) {
            if (handType === comboState.lastHandType) {
                comboState.streakCount++;
                if (comboState.streakCount > comboState.maxStreak) {
                    comboState.maxStreak = comboState.streakCount;
                }
            } else {
                comboState.streakCount = 1;
            }
            comboState.lastHandType = handType;
            updateComboDisplay();
        }

        // Calculate combo bonus
        function getComboBonus() {
            return Math.max(0, (comboState.streakCount - 1) * 2);
        }

        // Apply new joker effects
        function applyNewJokerEffects(selectedCards, handType, totalMult, totalChips) {
            let mult = totalMult;
            let chips = totalChips;

            gameState.jokers.forEach((joker, index) => {
                // Combo Tracker
                if (joker.effect.multPerStreak) {
                    mult += joker.effect.multPerStreak * Math.max(0, comboState.streakCount - 1);
                }

                // Ecosystem Joker
                if (joker.effect.multPerJoker) {
                    mult += joker.effect.multPerJoker * gameState.jokers.length;
                }

                // Scale Joker
                if (joker.effect.multPerMoney) {
                    const moneyMult = Math.min(Math.floor(gameState.money / joker.effect.multPerMoney), joker.effect.maxMultMoney || 999);
                    mult += moneyMult;
                }

                // Ritual Joker
                if (joker.effect.multPerHandPlayed) {
                    const handCount = gameStats.handCounts[handType] || 0;
                    mult += Math.min(handCount, 20); // Cap at 20
                }

                // Volatile Joker
                if (joker.effect.volatile) {
                    if (Math.random() < 0.5) {
                        mult *= 2;
                        showNotification(' Volatile x2!');
                    } else {
                        mult *= 0.5;
                        showNotification(' Volatile x0.5');
                    }
                }

                // Nemesis Joker
                if (joker.effect.multOnBoss && gameState.round === 3) {
                    mult += joker.effect.multOnBoss;
                }

                // Mirror Joker
                if (joker.effect.mirrorLeft && index > 0) {
                    const leftJoker = gameState.jokers[index - 1];
                    if (leftJoker.effect.mult) mult += leftJoker.effect.mult;
                    if (leftJoker.effect.chips) chips += leftJoker.effect.chips;
                }

                // Lucky Seven
                if (joker.effect.multPerSeven) {
                    const sevens = selectedCards.filter(c => c.rank === '7').length;
                    mult += joker.effect.multPerSeven * sevens;
                }

                // Royal Guard
                if (joker.effect.multPerFace) {
                    const faces = selectedCards.filter(c => ['J', 'Q', 'K'].includes(c.rank)).length;
                    mult += joker.effect.multPerFace * faces;
                }

                // Probability Joker
                if (joker.effect.multPerMatch) {
                    const rankCounts = {};
                    selectedCards.forEach(c => rankCounts[c.rank] = (rankCounts[c.rank] || 0) + 1);
                    const matches = Object.values(rankCounts).filter(c => c >= 2).length;
                    mult += joker.effect.multPerMatch * matches;
                }
            });

            return { mult, chips };
        }

        // Tooltip system
        const tooltip = document.getElementById('tooltip');
        let tooltipTimeout;

        function showTooltip(event, title, description, effect) {
            clearTimeout(tooltipTimeout);

            tooltip.innerHTML = `
                <div class="tooltip-title">${title}</div>
                ${description ? `<div class="tooltip-desc">${description}</div>` : ''}
                ${effect ? `<div class="tooltip-effect">${effect}</div>` : ''}
            `;

            tooltip.classList.add('active');
            updateTooltipPosition(event);
        }

        function updateTooltipPosition(event) {
            const x = event.clientX;
            const y = event.clientY;
            const tooltipRect = tooltip.getBoundingClientRect();

            let left = x + 10;
            let top = y + 10;

            // Keep tooltip on screen
            if (left + tooltipRect.width > window.innerWidth) {
                left = x - tooltipRect.width - 10;
            }
            if (top + tooltipRect.height > window.innerHeight) {
                top = y - tooltipRect.height - 10;
            }

            tooltip.style.left = `${left}px`;
            tooltip.style.top = `${top}px`;
        }

        function hideTooltip() {
            tooltipTimeout = setTimeout(() => {
                tooltip.classList.remove('active');
            }, 100);
        }

        // Add tooltips to jokers
        function addJokerTooltips() {
            document.querySelectorAll('.joker-slot.filled').forEach((slot, index) => {
                const joker = gameState.jokers[index];
                if (joker) {
                    slot.addEventListener('mouseenter', (e) => {
                        showTooltip(e, joker.name, joker.desc, `Price: $${joker.price}`);
                    });
                    slot.addEventListener('mouseleave', hideTooltip);
                    slot.addEventListener('mousemove', updateTooltipPosition);
                }
            });
        }

        // Keyboard navigation
        let selectedCardIndex = -1;

        function handleKeyboard(event) {
            // Prevent default for game controls
            if (['ArrowLeft', 'ArrowRight', 'Space', 'Enter', 'd', 'D', 's', 'S'].includes(event.key)) {
                event.preventDefault();
            }

            // Card selection with arrow keys
            if (event.key === 'ArrowLeft') {
                if (selectedCardIndex > 0) {
                    selectedCardIndex--;
                    selectCard(selectedCardIndex);
                }
            } else if (event.key === 'ArrowRight') {
                if (selectedCardIndex < gameState.hand.length - 1) {
                    selectedCardIndex++;
                    selectCard(selectedCardIndex);
                } else if (selectedCardIndex === -1 && gameState.hand.length > 0) {
                    selectedCardIndex = 0;
                    selectCard(selectedCardIndex);
                }
            } else if (event.key === ' ' || event.key === 'Enter') {
                // Play hand with space or enter
                if (!document.getElementById('play-btn').disabled) {
                    playHand();
                }
            } else if (event.key === 'd' || event.key === 'D') {
                // Discard with 'd'
                if (!document.getElementById('discard-btn').disabled) {
                    discardCards();
                }
            } else if (event.key === 's' || event.key === 'S') {
                // Sort with 's'
                sortHand();
            } else if (event.key === 'Escape') {
                // Close modals
                const shopModal = document.getElementById('shop-modal');
                if (shopModal.classList.contains('active')) {
                    closeShop();
                }
            }
        }

        // Event listeners
        document.getElementById('play-btn').addEventListener('click', playHand);
        document.getElementById('discard-btn').addEventListener('click', discardCards);
        document.getElementById('sort-btn').addEventListener('click', sortHand);
        document.getElementById('shop-btn').addEventListener('click', openShop);
        document.getElementById('close-shop').addEventListener('click', closeShop);
        document.getElementById('reroll-btn').addEventListener('click', rerollShop);
        document.getElementById('restart-btn').addEventListener('click', restartGame);

        // Keyboard controls
        document.addEventListener('keydown', handleKeyboard);

        // Shop tab switching
        document.querySelectorAll('.shop-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.shop-tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                renderShopItems(tab.dataset.tab);
            });
        });

        // ===== TUTORIAL SYSTEM =====
        const TUTORIAL_KEY = 'balatro-clone-tutorial';
        let tutorialStep = 0;

        const tutorialSteps = [
            {
                title: 'Welcome to Balatro Clone!',
                icon: '',
                content: `
                    <div class="tutorial-text">
                        A roguelike deck-building poker game where you create
                        <strong>powerful hand combinations</strong> to beat increasingly difficult blinds!
                    </div>
                    <div class="tutorial-highlight">
                        Your goal: Score enough points to beat each blind before running out of hands.
                    </div>
                `
            },
            {
                title: 'Playing Cards',
                icon: '',
                content: `
                    <div class="tutorial-text">
                        <strong>Click cards</strong> to select them (up to 5), then:
                    </div>
                    <ul class="tutorial-list">
                        <li><strong>Play Hand</strong> - Score points based on poker hand type</li>
                        <li><strong>Discard</strong> - Draw new cards (limited uses)</li>
                        <li><strong>Sort</strong> - Organize your cards by rank</li>
                    </ul>
                    <div class="tutorial-highlight">
                        Tip: Higher poker hands = More points! Royal Flush > Full House > Pair
                    </div>
                `
            },
            {
                title: 'Scoring System',
                icon: '',
                content: `
                    <div class="tutorial-text">
                        Your score is calculated as: <strong>Chips  Multiplier</strong>
                    </div>
                    <div class="tutorial-highlight">
                        Each hand type has base Chips and Mult values.<br>
                        <strong>Level up hands</strong> with Planet cards to increase their power!
                    </div>
                    <div class="tutorial-text">
                        <strong>Enhanced cards</strong> (Gold, Steel, Glass) provide bonus effects.
                    </div>
                `
            },
            {
                title: 'Jokers - Your Power-Ups',
                icon: '',
                content: `
                    <div class="tutorial-text">
                        <strong>Jokers</strong> are permanent upgrades that modify your scoring!
                    </div>
                    <ul class="tutorial-list">
                        <li>Buy them from the <strong>Shop</strong> between rounds</li>
                        <li>Hold up to <strong>5 Jokers</strong> at once</li>
                        <li>Each has unique effects - hover to see details</li>
                    </ul>
                    <div class="tutorial-highlight">
                        Synergize Jokers for massive multipliers!
                    </div>
                `
            },
            {
                title: 'Blinds & Progression',
                icon: '',
                content: `
                    <div class="tutorial-text">
                        Each Ante has <strong>3 Blinds</strong>:
                    </div>
                    <ul class="tutorial-list">
                        <li><strong>Small Blind</strong> - Low requirement</li>
                        <li><strong>Big Blind</strong> - Higher requirement</li>
                        <li><strong>Boss Blind</strong> - Special effects that challenge you!</li>
                    </ul>
                    <div class="tutorial-highlight">
                        Boss Blinds have unique rules like debuffing suits or cards!
                    </div>
                `
            },
            {
                title: 'Ready to Play!',
                icon: '',
                content: `
                    <div class="tutorial-text">
                        You're all set! Here are some <strong>keyboard shortcuts</strong>:
                    </div>
                    <ul class="tutorial-list">
                        <li><strong>Space</strong> - Play selected hand</li>
                        <li><strong>D</strong> - Discard selected cards</li>
                        <li><strong>S</strong> - Sort hand</li>
                        <li><strong> </strong> - Navigate cards</li>
                    </ul>
                    <div class="tutorial-highlight">
                        Check the <strong>Settings </strong> for more options!<br>
                        Try the <strong>Daily Challenge </strong> for special rewards!
                    </div>
                `,
                isLast: true
            }
        ];

        function showTutorial() {
            tutorialStep = 0;
            renderTutorialStep();
            document.getElementById('tutorial-overlay').classList.add('active');
        }

        function renderTutorialStep() {
            const step = tutorialSteps[tutorialStep];
            document.getElementById('tutorial-title').textContent = step.title;
            document.getElementById('tutorial-step').textContent = `Step ${tutorialStep + 1} of ${tutorialSteps.length}`;
            document.getElementById('tutorial-body').innerHTML = `
                <div class="tutorial-icon">${step.icon}</div>
                ${step.content}
            `;

            // Update button
            const nextBtn = document.getElementById('tutorial-next-btn');
            if (step.isLast) {
                nextBtn.textContent = 'Start Playing!';
                nextBtn.className = 'tutorial-btn tutorial-btn-start';
            } else {
                nextBtn.textContent = 'Next';
                nextBtn.className = 'tutorial-btn tutorial-btn-next';
            }

            // Update progress dots
            const progressContainer = document.getElementById('tutorial-progress');
            progressContainer.innerHTML = '';
            tutorialSteps.forEach((_, index) => {
                const dot = document.createElement('div');
                dot.className = 'tutorial-dot';
                if (index < tutorialStep) dot.classList.add('completed');
                if (index === tutorialStep) dot.classList.add('active');
                progressContainer.appendChild(dot);
            });
        }

        function nextTutorialStep() {
            if (tutorialStep >= tutorialSteps.length - 1) {
                completeTutorial();
            } else {
                tutorialStep++;
                renderTutorialStep();
            }
        }

        function skipTutorial() {
            completeTutorial();
        }

        function completeTutorial() {
            document.getElementById('tutorial-overlay').classList.remove('active');
            localStorage.setItem(TUTORIAL_KEY, 'completed');
        }

        function shouldShowTutorial() {
            return !localStorage.getItem(TUTORIAL_KEY);
        }

        // ===== DAILY CHALLENGE SYSTEM =====
        const DAILY_KEY = 'balatro-clone-daily';

        const dailyChallengeRules = [
            { name: 'No Discard Day', desc: 'Start with 0 discards', modifier: { discards: 0 } },
            { name: 'Speed Run', desc: 'Only 2 hands per blind', modifier: { hands: 2 } },
            { name: 'Golden Touch', desc: 'All cards enhanced Gold', modifier: { enhancement: 'gold' } },
            { name: 'Flush Fever', desc: 'Only Flush hands count 2x', modifier: { bonusHand: 'Flush', bonus: 2 } },
            { name: 'Pair Paradise', desc: 'Pairs give +10 mult', modifier: { pairBonus: 10 } },
            { name: 'High Stakes', desc: 'Blinds require 50% more', modifier: { blindScale: 1.5 } },
            { name: 'Lucky Day', desc: 'Start with a random Joker', modifier: { startJoker: true } }
        ];

        let dailyChallenge = null;
        let isDailyChallenge = false;

        function getDailyChallenge() {
            const today = new Date().toISOString().split('T')[0];
            const saved = localStorage.getItem(DAILY_KEY);
            const dailyData = saved ? JSON.parse(saved) : {};

            if (dailyData.date !== today) {
                // Generate new daily challenge
                const seed = hashString(today);
                const ruleIndex = seed % dailyChallengeRules.length;
                dailyChallenge = {
                    date: today,
                    rule: dailyChallengeRules[ruleIndex],
                    completed: false,
                    highScore: 0
                };
                localStorage.setItem(DAILY_KEY, JSON.stringify(dailyChallenge));
            } else {
                dailyChallenge = dailyData;
            }

            return dailyChallenge;
        }

        function hashString(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                hash = ((hash << 5) - hash) + str.charCodeAt(i);
                hash |= 0;
            }
            return Math.abs(hash);
        }

        function startDailyChallenge() {
            getDailyChallenge();
            isDailyChallenge = true;

            // Apply daily challenge modifiers
            const mods = difficultyModifiers[gameSettings.difficulty] || difficultyModifiers.normal;
            gameState.score = 0;
            gameState.money = mods.startingMoney;
            gameState.ante = 1;
            gameState.round = 1;
            gameState.handsRemaining = dailyChallenge.rule.modifier.hands || mods.startingHands;
            gameState.discardsRemaining = dailyChallenge.rule.modifier.discards !== undefined ?
                dailyChallenge.rule.modifier.discards : mods.startingDiscards;

            // Use the date as seed for reproducibility
            initRNG(dailyChallenge.date);

            gameState.jokers = [];
            gameState.vouchers = [];
            gameState.planetCards = [];
            gameState.tarotCards = [];

            // Apply start joker if applicable
            if (dailyChallenge.rule.modifier.startJoker) {
                const randomJoker = jokerTypes[Math.floor(seededRandom() * jokerTypes.length)];
                gameState.jokers.push({...randomJoker});
            }

            // Initialize hand levels
            Object.keys(handTypes).forEach(hand => {
                gameState.handLevels[hand] = { ...handTypes[hand] };
            });

            createDeck();

            // Apply golden enhancement if applicable
            if (dailyChallenge.rule.modifier.enhancement) {
                gameState.deck.forEach(card => {
                    card.enhancement = dailyChallenge.rule.modifier.enhancement;
                });
            }

            dealHand();
            updateBlind();
            updateDisplay();
            renderHandLevels();
            renderJokers();

            showNotification(` Daily Challenge: ${dailyChallenge.rule.name}`);
            document.getElementById('daily-challenge-banner').classList.remove('active');
        }

        function checkDailyChallenge() {
            const challenge = getDailyChallenge();
            if (!challenge.completed) {
                document.getElementById('daily-challenge-banner').classList.add('active');
                document.getElementById('daily-challenge-banner').innerHTML =
                    ` Daily: ${challenge.rule.name} - ${challenge.rule.desc}`;
            }
        }

        // ===== LEADERBOARD SYSTEM =====
        const LEADERBOARD_KEY = 'balatro-clone-leaderboard';

        let leaderboardData = {
            highscores: [],
            antescores: [],
            dailyscores: []
        };

        function loadLeaderboard() {
            try {
                const saved = localStorage.getItem(LEADERBOARD_KEY);
                if (saved) {
                    leaderboardData = JSON.parse(saved);
                }
            } catch (e) {
                console.error('Failed to load leaderboard:', e);
            }
        }

        function saveLeaderboard() {
            try {
                localStorage.setItem(LEADERBOARD_KEY, JSON.stringify(leaderboardData));
            } catch (e) {
                console.error('Failed to save leaderboard:', e);
            }
        }

        function addToLeaderboard(score, ante, seed, isDaily = false) {
            const entry = {
                score: score,
                ante: ante,
                seed: seed,
                date: new Date().toISOString(),
                difficulty: gameSettings.difficulty
            };

            // Add to high scores
            leaderboardData.highscores.push(entry);
            leaderboardData.highscores.sort((a, b) => b.score - a.score);
            leaderboardData.highscores = leaderboardData.highscores.slice(0, 10);

            // Add to ante scores
            leaderboardData.antescores.push(entry);
            leaderboardData.antescores.sort((a, b) => b.ante - a.ante || b.score - a.score);
            leaderboardData.antescores = leaderboardData.antescores.slice(0, 10);

            // Add to daily scores if applicable
            if (isDaily) {
                leaderboardData.dailyscores.push(entry);
                leaderboardData.dailyscores.sort((a, b) => b.score - a.score);
                leaderboardData.dailyscores = leaderboardData.dailyscores.slice(0, 10);
            }

            saveLeaderboard();
        }

        function openLeaderboardModal() {
            document.getElementById('leaderboard-modal').classList.add('active');
            renderLeaderboard('highscore');
        }

        function closeLeaderboardModal() {
            document.getElementById('leaderboard-modal').classList.remove('active');
        }

        function switchLeaderboardTab(tab) {
            document.querySelectorAll('.leaderboard-tab').forEach(t => t.classList.remove('active'));
            document.querySelector(`[data-lb-tab="${tab}"]`).classList.add('active');
            renderLeaderboard(tab);
        }

        function renderLeaderboard(type) {
            const container = document.getElementById('leaderboard-entries');
            let entries = [];

            if (type === 'highscore') entries = leaderboardData.highscores;
            else if (type === 'ante') entries = leaderboardData.antescores;
            else if (type === 'daily') entries = leaderboardData.dailyscores;

            if (entries.length === 0) {
                container.innerHTML = '<div style="text-align: center; padding: 40px; color: #aaa;">No entries yet. Play some games!</div>';
                return;
            }

            container.innerHTML = '';
            entries.forEach((entry, index) => {
                const rankClass = index === 0 ? 'gold' : index === 1 ? 'silver' : index === 2 ? 'bronze' : '';
                const rankIcon = index === 0 ? '' : index === 1 ? '' : index === 2 ? '' : `#${index + 1}`;

                const entryEl = document.createElement('div');
                entryEl.className = `leaderboard-entry ${rankClass}`;
                entryEl.innerHTML = `
                    <div class="leaderboard-rank">${rankIcon}</div>
                    <div class="leaderboard-info">
                        <div class="leaderboard-score">${entry.score.toLocaleString()}</div>
                        <div class="leaderboard-details">
                            Ante ${entry.ante}  ${entry.difficulty}  Seed: ${entry.seed}
                        </div>
                    </div>
                `;
                container.appendChild(entryEl);
            });
        }

        // ===== DECK SELECTION SYSTEM =====
        const DECKS_KEY = 'balatro-clone-decks';

        const deckTypes = [
            {
                id: 'standard',
                name: 'Standard Deck',
                icon: '',
                desc: 'The classic 52-card deck. No special modifiers.',
                bonus: 'Balanced gameplay',
                unlocked: true
            },
            {
                id: 'red',
                name: 'Red Deck',
                icon: '',
                desc: 'All hearts and diamonds. Better for flushes!',
                bonus: '+1 Discard',
                unlocked: true,
                modifier: { suitFilter: ['', ''], extraDiscards: 1 }
            },
            {
                id: 'blue',
                name: 'Blue Deck',
                icon: '',
                desc: 'All spades and clubs. Dark and powerful!',
                bonus: '+1 Hand',
                unlocked: true,
                modifier: { suitFilter: ['', ''], extraHands: 1 }
            },
            {
                id: 'golden',
                name: 'Golden Deck',
                icon: '',
                desc: 'Start with extra money but fewer cards.',
                bonus: '+$10 starting',
                unlockReq: 'Reach Ante 5',
                unlockCheck: () => gameStats.highestAnte >= 5,
                modifier: { extraMoney: 10, deckSize: 40 }
            },
            {
                id: 'glass',
                name: 'Glass Deck',
                icon: '',
                desc: 'High risk, high reward. Glass cards are fragile!',
                bonus: 'All cards Glass (x2 mult)',
                unlockReq: 'Score 100,000+',
                unlockCheck: () => gameStats.highestScore >= 100000,
                modifier: { enhancement: 'glass' }
            },
            {
                id: 'abandoned',
                name: 'Abandoned Deck',
                icon: '',
                desc: 'No face cards. Only numbers remain.',
                bonus: 'Smaller deck = better draws',
                unlockReq: 'Win with High Card',
                unlockCheck: () => isAchievementUnlocked('first_win'),
                modifier: { noFaceCards: true }
            },
            {
                id: 'painted',
                name: 'Painted Deck',
                icon: '',
                desc: '+2 Hand size. More cards, more combos!',
                bonus: '+2 Hand size',
                unlockReq: 'Reach Ante 8',
                unlockCheck: () => gameStats.highestAnte >= 8,
                modifier: { handSizeBonus: 2 }
            },
            {
                id: 'erratic',
                name: 'Erratic Deck',
                icon: '',
                desc: 'Every card is randomly enhanced!',
                bonus: 'Chaotic fun',
                unlockReq: 'Play 50 games',
                unlockCheck: () => gameStats.totalGamesPlayed >= 50,
                modifier: { randomEnhancements: true }
            }
        ];

        let selectedDeck = 'standard';

        function openDeckSelectModal() {
            document.getElementById('deck-select-modal').classList.add('active');
            renderDeckSelection();
        }

        function closeDeckSelectModal() {
            document.getElementById('deck-select-modal').classList.remove('active');
        }

        function renderDeckSelection() {
            const grid = document.getElementById('deck-grid');
            grid.innerHTML = '';

            deckTypes.forEach(deck => {
                const isUnlocked = deck.unlocked || (deck.unlockCheck && deck.unlockCheck());
                const isSelected = selectedDeck === deck.id;

                const deckEl = document.createElement('div');
                deckEl.className = `deck-card ${isSelected ? 'selected' : ''} ${!isUnlocked ? 'locked' : ''}`;
                deckEl.innerHTML = `
                    <div class="deck-icon">${deck.icon}</div>
                    <div class="deck-name">${deck.name}</div>
                    <div class="deck-desc">${deck.desc}</div>
                    <div class="deck-bonus">${deck.bonus}</div>
                    ${!isUnlocked ? `<div class="deck-unlock-req"> ${deck.unlockReq}</div>` : ''}
                `;

                if (isUnlocked) {
                    deckEl.addEventListener('click', () => {
                        selectedDeck = deck.id;
                        renderDeckSelection();
                    });
                }

                grid.appendChild(deckEl);
            });
        }

        function startWithSelectedDeck() {
            closeDeckSelectModal();

            const deck = deckTypes.find(d => d.id === selectedDeck);
            isDailyChallenge = false;

            // Apply difficulty modifiers
            const mods = difficultyModifiers[gameSettings.difficulty] || difficultyModifiers.normal;
            gameState.score = 0;
            gameState.money = mods.startingMoney;
            gameState.ante = 1;
            gameState.round = 1;
            gameState.handsRemaining = mods.startingHands;
            gameState.discardsRemaining = mods.startingDiscards;
            gameState.handSize = 8;

            // Apply deck modifiers
            if (deck && deck.modifier) {
                if (deck.modifier.extraMoney) gameState.money += deck.modifier.extraMoney;
                if (deck.modifier.extraHands) gameState.handsRemaining += deck.modifier.extraHands;
                if (deck.modifier.extraDiscards) gameState.discardsRemaining += deck.modifier.extraDiscards;
                if (deck.modifier.handSizeBonus) gameState.handSize += deck.modifier.handSizeBonus;
            }

            // Generate new seed
            initRNG(generateNewSeed());
            saveSettings();

            gameState.jokers = [];
            gameState.vouchers = [];
            gameState.planetCards = [];
            gameState.tarotCards = [];

            // Initialize hand levels
            Object.keys(handTypes).forEach(hand => {
                gameState.handLevels[hand] = { ...handTypes[hand] };
            });

            // Create deck with modifiers
            createDeckWithModifiers(deck);

            // Update stats
            gameStats.totalGamesPlayed++;
            gameStats.lastPlayed = new Date().toISOString();
            saveStats();

            dealHand();
            updateBlind();
            updateDisplay();
            renderHandLevels();
            renderJokers();
            renderPlanetCards();
            renderTarotCards();

            showNotification(`Starting with ${deck.name}!`);
        }

        function createDeckWithModifiers(deck) {
            gameState.deck = [];
            const enhancements = ['gold', 'steel', 'glass', 'stone'];

            let allowedSuits = suits;
            let allowedRanks = ranks;

            if (deck && deck.modifier) {
                if (deck.modifier.suitFilter) {
                    allowedSuits = deck.modifier.suitFilter;
                }
                if (deck.modifier.noFaceCards) {
                    allowedRanks = ranks.filter(r => !['J', 'Q', 'K'].includes(r));
                }
            }

            for (let suit of allowedSuits) {
                for (let rank of allowedRanks) {
                    const card = {
                        suit: suit,
                        rank: rank,
                        value: getRankValue(rank),
                        color: suitColors[suit],
                        enhancement: null,
                        seal: null,
                        id: `${rank}${suit}`
                    };

                    // Apply enhancement modifiers
                    if (deck && deck.modifier) {
                        if (deck.modifier.enhancement) {
                            card.enhancement = deck.modifier.enhancement;
                        }
                        if (deck.modifier.randomEnhancements) {
                            if (seededRandom() < 0.3) {
                                card.enhancement = enhancements[Math.floor(seededRandom() * enhancements.length)];
                            }
                        }
                    }

                    gameState.deck.push(card);
                }
            }

            // Limit deck size if specified
            if (deck && deck.modifier && deck.modifier.deckSize) {
                while (gameState.deck.length > deck.modifier.deckSize) {
                    const removeIndex = Math.floor(seededRandom() * gameState.deck.length);
                    gameState.deck.splice(removeIndex, 1);
                }
            }

            shuffleDeck();
        }

        // ===== CODEX SYSTEM =====
        const CODEX_KEY = 'balatro-clone-codex';

        let codexData = {
            jokers: [],
            planets: [],
            tarots: [],
            spectrals: [],
            vouchers: [],
            hands: []
        };

        function loadCodex() {
            try {
                const saved = localStorage.getItem(CODEX_KEY);
                if (saved) {
                    codexData = JSON.parse(saved);
                }
            } catch (e) {
                console.error('Failed to load codex:', e);
            }
        }

        function saveCodex() {
            try {
                localStorage.setItem(CODEX_KEY, JSON.stringify(codexData));
            } catch (e) {
                console.error('Failed to save codex:', e);
            }
        }

        function discoverItem(type, name) {
            if (!codexData[type].includes(name)) {
                codexData[type].push(name);
                saveCodex();
            }
        }

        function openCodexModal() {
            document.getElementById('codex-modal').classList.add('active');
            updateCodexProgress();
            renderCodex('jokers');
        }

        function closeCodexModal() {
            document.getElementById('codex-modal').classList.remove('active');
        }

        function switchCodexTab(tab) {
            document.querySelectorAll('.codex-tab').forEach(t => t.classList.remove('active'));
            document.querySelector(`[data-codex-tab="${tab}"]`).classList.add('active');
            renderCodex(tab);
        }

        function updateCodexProgress() {
            const totalJokers = jokerTypes.length;
            const totalPlanets = planetCardTypes.length;
            const totalTarots = tarotCardTypes.length;
            const totalSpectrals = spectralCardTypes.length;
            const totalVouchers = voucherTypes.length;
            const totalHands = Object.keys(handTypes).length;

            const discovered = codexData.jokers.length + codexData.planets.length +
                              codexData.tarots.length + codexData.spectrals.length +
                              codexData.vouchers.length + codexData.hands.length;
            const total = totalJokers + totalPlanets + totalTarots + totalSpectrals + totalVouchers + totalHands;
            const percentage = Math.round((discovered / total) * 100);

            document.getElementById('codex-progress').innerHTML = `
                <div style="font-size: 24px; font-weight: bold; color: #ffd700;">
                    ${discovered} / ${total} Discovered (${percentage}%)
                </div>
                <div class="codex-progress-bar">
                    <div class="codex-progress-fill" style="width: ${percentage}%"></div>
                </div>
            `;
        }

        function renderCodex(type) {
            const grid = document.getElementById('codex-grid');
            grid.innerHTML = '';

            let items = [];
            let discovered = codexData[type] || [];

            if (type === 'jokers') {
                items = jokerTypes.map(j => ({ name: j.name, icon: j.icon, desc: j.desc }));
            } else if (type === 'planets') {
                items = planetCardTypes.map(p => ({ name: p.name, icon: p.icon, desc: `Level up ${p.hand}` }));
            } else if (type === 'tarots') {
                items = tarotCardTypes.map(t => ({ name: t.name, icon: t.icon, desc: t.desc }));
            } else if (type === 'spectrals') {
                items = spectralCardTypes.map(s => ({ name: s.name, icon: s.icon, desc: s.desc, rarity: s.rarity }));
            } else if (type === 'vouchers') {
                items = voucherTypes.map(v => ({ name: v.name, icon: '', desc: v.desc }));
            } else if (type === 'hands') {
                items = Object.entries(handTypes).map(([name, data]) => ({
                    name: name,
                    icon: '',
                    desc: `${data.mult}x mult, +${data.chips} chips`
                }));
            }

            items.forEach(item => {
                const isDiscovered = discovered.includes(item.name);
                const itemEl = document.createElement('div');
                itemEl.className = `codex-item ${isDiscovered ? 'discovered' : 'undiscovered'}`;
                itemEl.innerHTML = `
                    <div class="codex-item-icon">${item.icon}</div>
                    <div class="codex-item-name">${isDiscovered ? item.name : '???'}</div>
                `;
                if (isDiscovered) {
                    itemEl.title = item.desc;
                }
                grid.appendChild(itemEl);
            });
        }

        // ===== CHALLENGE SYSTEM =====
        const CHALLENGES_KEY = 'balatro-clone-challenges';

        const challengeDefinitions = [
            {
                id: 'overkill',
                name: 'Overkill',
                icon: '',
                desc: 'Beat blinds with 200% of the requirement',
                rules: 'No Jokers allowed',
                modifier: { noJokers: true, overkillReq: 2.0 },
                reward: 'Unlocks Golden Deck modifier'
            },
            {
                id: 'minimalist',
                name: 'Minimalist',
                icon: '',
                desc: 'Complete Ante 4 with only High Card hands',
                rules: 'Only High Card counts',
                modifier: { onlyHighCard: true },
                reward: '+50 Achievement Points'
            },
            {
                id: 'speedster',
                name: 'Speedster',
                icon: '',
                desc: 'Beat each blind in 2 hands or less',
                rules: '2 hands per blind',
                modifier: { maxHands: 2 },
                reward: 'Unlocks Speed Demon title'
            },
            {
                id: 'rich_man',
                name: 'Rich Man\'s Game',
                icon: '',
                desc: 'End the run with $100 or more',
                rules: 'Money is everything',
                modifier: { moneyGoal: 100 },
                reward: 'Unlocks Money Multiplier'
            },
            {
                id: 'one_joker',
                name: 'Solo Act',
                icon: '',
                desc: 'Complete Ante 5 with only 1 Joker slot',
                rules: 'Max 1 Joker',
                modifier: { maxJokers: 1 },
                reward: 'Unlocks Enhanced Joker effects'
            },
            {
                id: 'glass_cannon',
                name: 'Glass Cannon',
                icon: '',
                desc: 'All cards are Glass. Win Ante 3.',
                rules: 'Cards may shatter!',
                modifier: { allGlass: true, glassShatter: true },
                reward: 'Unlocks Diamond Deck'
            },
            {
                id: 'blind_faith',
                name: 'Blind Faith',
                icon: '',
                desc: 'Cards are face-down until played',
                rules: 'Cannot see card values',
                modifier: { blindCards: true },
                reward: '+100 Achievement Points'
            },
            {
                id: 'poverty',
                name: 'Poverty Run',
                icon: '',
                desc: 'Complete Ante 4 without using the shop',
                rules: 'No shopping allowed',
                modifier: { noShop: true },
                reward: 'Unlocks Frugal achievement'
            }
        ];

        let challengeProgress = {};

        function loadChallengeProgress() {
            try {
                const saved = localStorage.getItem(CHALLENGES_KEY);
                if (saved) {
                    challengeProgress = JSON.parse(saved);
                }
            } catch (e) {
                console.error('Failed to load challenges:', e);
            }
        }

        function saveChallengeProgress() {
            try {
                localStorage.setItem(CHALLENGES_KEY, JSON.stringify(challengeProgress));
            } catch (e) {
                console.error('Failed to save challenges:', e);
            }
        }

        function openChallengeModal() {
            document.getElementById('challenge-modal').classList.add('active');
            renderChallenges();
        }

        function closeChallengeModal() {
            document.getElementById('challenge-modal').classList.remove('active');
        }

        function renderChallenges() {
            const list = document.getElementById('challenge-list');
            list.innerHTML = '';

            challengeDefinitions.forEach(challenge => {
                const isCompleted = challengeProgress[challenge.id];
                const card = document.createElement('div');
                card.className = `challenge-card ${isCompleted ? 'completed' : ''}`;
                card.innerHTML = `
                    <div class="challenge-icon">${challenge.icon}</div>
                    <div class="challenge-info">
                        <div class="challenge-name">${challenge.name} ${isCompleted ? '' : ''}</div>
                        <div class="challenge-desc">${challenge.desc}</div>
                        <div class="challenge-rules">${challenge.rules}</div>
                    </div>
                    <div class="challenge-reward">${challenge.reward}</div>
                `;
                card.addEventListener('click', () => startChallenge(challenge));
                list.appendChild(card);
            });
        }

        let currentChallenge = null;

        function startChallenge(challenge) {
            closeChallengeModal();
            currentChallenge = challenge;
            isDailyChallenge = false;

            // Apply difficulty modifiers
            const mods = difficultyModifiers[gameSettings.difficulty] || difficultyModifiers.normal;
            gameState.score = 0;
            gameState.money = mods.startingMoney;
            gameState.ante = 1;
            gameState.round = 1;
            gameState.handsRemaining = challenge.modifier.maxHands || mods.startingHands;
            gameState.discardsRemaining = mods.startingDiscards;
            gameState.maxJokers = challenge.modifier.maxJokers !== undefined ? challenge.modifier.maxJokers : 5;
            gameState.handSize = 8;

            // Generate seed
            initRNG(generateNewSeed());
            saveSettings();

            gameState.jokers = [];
            gameState.vouchers = [];
            gameState.planetCards = [];
            gameState.tarotCards = [];

            // Initialize hand levels
            Object.keys(handTypes).forEach(hand => {
                gameState.handLevels[hand] = { ...handTypes[hand] };
            });

            createDeck();

            // Apply challenge modifiers
            if (challenge.modifier.allGlass) {
                gameState.deck.forEach(card => {
                    card.enhancement = 'glass';
                });
            }

            dealHand();
            updateBlind();
            updateDisplay();
            renderHandLevels();
            renderJokers();

            showNotification(` Challenge: ${challenge.name}`);
        }

        function completeChallenge(challengeId) {
            if (!challengeProgress[challengeId]) {
                challengeProgress[challengeId] = true;
                saveChallengeProgress();
                showNotification(` Challenge Complete: ${challengeDefinitions.find(c => c.id === challengeId)?.name}`);
            }
        }

        // ===== RUN HISTORY SYSTEM =====
        const RUN_HISTORY_KEY = 'balatro-clone-runhistory';

        let runHistory = [];

        function loadRunHistory() {
            try {
                const saved = localStorage.getItem(RUN_HISTORY_KEY);
                if (saved) {
                    runHistory = JSON.parse(saved);
                }
            } catch (e) {
                console.error('Failed to load run history:', e);
            }
        }

        function saveRunHistory() {
            try {
                localStorage.setItem(RUN_HISTORY_KEY, JSON.stringify(runHistory));
            } catch (e) {
                console.error('Failed to save run history:', e);
            }
        }

        function addToRunHistory(score, ante, won, deckUsed, seed) {
            runHistory.unshift({
                score: score,
                ante: ante,
                won: won,
                deck: deckUsed,
                seed: seed,
                date: new Date().toISOString(),
                difficulty: gameSettings.difficulty
            });
            // Keep only last 50 runs
            runHistory = runHistory.slice(0, 50);
            saveRunHistory();
        }

        // Override gameOver to save to leaderboard and history
        const originalGameOver = gameOver;
        gameOver = function() {
            // Add to leaderboard before showing game over
            addToLeaderboard(
                gameState.score,
                gameState.ante,
                gameSettings.seed,
                isDailyChallenge
            );

            // Add to run history
            addToRunHistory(
                gameState.score,
                gameState.ante,
                gameState.ante >= 4, // Won if reached Ante 4+
                selectedDeck,
                gameSettings.seed
            );

            // Mark daily challenge as completed if applicable
            if (isDailyChallenge && dailyChallenge) {
                if (gameState.score > dailyChallenge.highScore) {
                    dailyChallenge.highScore = gameState.score;
                }
                dailyChallenge.completed = true;
                localStorage.setItem(DAILY_KEY, JSON.stringify(dailyChallenge));
                isDailyChallenge = false;
            }

            // Check challenge completion
            if (currentChallenge) {
                // Check challenge-specific win conditions
                if (currentChallenge.id === 'overkill' && gameState.ante >= 4) {
                    completeChallenge('overkill');
                }
                if (currentChallenge.id === 'minimalist' && gameState.ante >= 4) {
                    completeChallenge('minimalist');
                }
                if (currentChallenge.id === 'speedster' && gameState.ante >= 4) {
                    completeChallenge('speedster');
                }
                if (currentChallenge.id === 'rich_man' && gameState.money >= 100) {
                    completeChallenge('rich_man');
                }
                if (currentChallenge.id === 'one_joker' && gameState.ante >= 5) {
                    completeChallenge('one_joker');
                }
                if (currentChallenge.id === 'glass_cannon' && gameState.ante >= 3) {
                    completeChallenge('glass_cannon');
                }
                if (currentChallenge.id === 'poverty' && gameState.ante >= 4) {
                    completeChallenge('poverty');
                }
                currentChallenge = null;
            }

            // Call original function
            originalGameOver();
        };

        // Track codex discoveries when purchasing items
        const originalPurchaseItem = purchaseItem;
        purchaseItem = function(category, item) {
            originalPurchaseItem(category, item);

            // Discover items in codex
            if (category === 'jokers') discoverItem('jokers', item.name);
            if (category === 'tarots') discoverItem('tarots', item.name);
            if (category === 'planets') discoverItem('planets', item.name);
            if (category === 'vouchers') discoverItem('vouchers', item.name);
        };

        // Track hand types played for codex
        const originalPlayHand = playHand;
        playHand = function() {
            const selectedCardObjects = gameState.selectedCards.map(i => gameState.hand[i]);
            const handResult = evaluateHand(selectedCardObjects);

            if (handResult) {
                discoverItem('hands', handResult.type);
            }

            originalPlayHand();
        };

        // ===== WIN SCREEN SYSTEM =====

        function showWinScreen() {
            document.getElementById('win-screen').classList.add('active');
            document.getElementById('win-final-score').textContent = `Final Score: ${gameState.score.toLocaleString()}`;
            document.getElementById('win-ante').textContent = gameState.ante;
            document.getElementById('win-hands').textContent = gameStats.totalHandsPlayed;
            document.getElementById('win-money').textContent = `$${gameState.money}`;

            // Create confetti
            createConfetti();

            // Unlock achievement if applicable
            if (gameState.ante >= 8) {
                unlockAchievement('ante_8');
            }
            if (gameState.ante >= 10) {
                unlockAchievement('ante_10');
            }
        }

        function closeWinScreen() {
            document.getElementById('win-screen').classList.remove('active');
            openDeckSelectModal();
        }

        function createConfetti() {
            const colors = ['#ffd700', '#ff6b6b', '#4ecdc4', '#45b7d1', '#96e6a1', '#f9ca24', '#9b59b6'];
            for (let i = 0; i < 100; i++) {
                setTimeout(() => {
                    const confetti = document.createElement('div');
                    confetti.className = 'confetti';
                    confetti.style.left = `${Math.random() * 100}vw`;
                    confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                    confetti.style.animationDuration = `${2 + Math.random() * 2}s`;
                    confetti.style.animationDelay = `${Math.random() * 0.5}s`;
                    document.body.appendChild(confetti);

                    setTimeout(() => confetti.remove(), 4000);
                }, i * 30);
            }
        }

        // Check for win condition
        function checkWinCondition() {
            // Win if reached Ante 8 (configurable)
            if (gameState.ante >= 8 && gameState.round === 1) {
                showWinScreen();
                addToLeaderboard(gameState.score, gameState.ante, gameSettings.seed, isDailyChallenge);
                addToRunHistory(gameState.score, gameState.ante, true, selectedDeck, gameSettings.seed);
                return true;
            }
            return false;
        }

        // ===== SPECTRAL CARD SYSTEM =====

        // Add spectral cards to game state
        gameState.spectralCards = [];

        function useSpectralCard(index) {
            if (index >= gameState.spectralCards.length) return;

            const card = gameState.spectralCards[index];
            let message = '';

            // Discover in codex
            discoverItem('spectrals', card.name);

            switch(card.name) {
                case 'Black Hole':
                    // Level up all hands
                    Object.keys(gameState.handLevels).forEach(hand => {
                        gameState.handLevels[hand].level++;
                        gameState.handLevels[hand].mult += 1;
                        gameState.handLevels[hand].chips += 5;
                    });
                    message = 'All hands leveled up!';
                    renderHandLevels();
                    break;

                case 'Grim':
                    // Destroy 2 cards, gain $10
                    if (gameState.hand.length >= 2) {
                        gameState.hand.splice(0, 2);
                        gameState.money += 10;
                        message = 'Destroyed 2 cards, +$10';
                        renderHand();
                    }
                    break;

                case 'Immolate':
                    // Destroy 5 cards, gain $20
                    if (gameState.hand.length >= 5) {
                        gameState.hand.splice(0, 5);
                        gameState.money += 20;
                        message = 'Destroyed 5 cards, +$20';
                        renderHand();
                    }
                    break;

                case 'Talisman':
                    // Add Gold Seal to first card
                    if (gameState.hand.length > 0) {
                        gameState.hand[0].seal = 'gold';
                        message = 'Added Gold Seal!';
                        renderHand();
                    }
                    break;

                case 'Deja Vu':
                    // Add Red Seal
                    if (gameState.hand.length > 0) {
                        gameState.hand[0].seal = 'red';
                        message = 'Added Red Seal!';
                        renderHand();
                    }
                    break;

                case 'Trance':
                    // Add Blue Seal
                    if (gameState.hand.length > 0) {
                        gameState.hand[0].seal = 'blue';
                        message = 'Added Blue Seal!';
                        renderHand();
                    }
                    break;

                case 'Medium':
                    // Add Purple Seal
                    if (gameState.hand.length > 0) {
                        gameState.hand[0].seal = 'purple';
                        message = 'Added Purple Seal!';
                        renderHand();
                    }
                    break;

                case 'Sigil':
                    // Convert hand to 1 suit
                    const targetSuit = suits[Math.floor(Math.random() * suits.length)];
                    gameState.hand.forEach(c => {
                        c.suit = targetSuit;
                        c.color = suitColors[targetSuit];
                    });
                    message = `All cards to ${targetSuit}!`;
                    renderHand();
                    break;

                case 'Ouija':
                    // -1 hand size, +1 Mult to all hands
                    gameState.handSize = Math.max(5, gameState.handSize - 1);
                    Object.keys(gameState.handLevels).forEach(hand => {
                        gameState.handLevels[hand].mult += 1;
                    });
                    message = '-1 Hand Size, +1 Mult all hands!';
                    renderHandLevels();
                    break;

                case 'Aura':
                    // Add Foil, Holo, or Poly to random card
                    const effects = ['foil', 'holo', 'poly'];
                    const effect = effects[Math.floor(Math.random() * effects.length)];
                    if (gameState.hand.length > 0) {
                        gameState.hand[0].specialEffect = effect;
                        message = `Added ${effect} effect!`;
                        renderHand();
                    }
                    break;

                case 'Wraith':
                    // Create random Rare Joker, lose $5
                    if (gameState.jokers.length < gameState.maxJokers) {
                        const rareJokers = jokerTypes.filter(j => j.price >= 8);
                        const randomJoker = rareJokers[Math.floor(Math.random() * rareJokers.length)];
                        gameState.jokers.push({...randomJoker});
                        gameState.money = Math.max(0, gameState.money - 5);
                        message = `Created ${randomJoker.name}, -$5`;
                        renderJokers();
                    } else {
                        message = 'Joker slots full!';
                    }
                    break;

                case 'The Soul':
                    // Create Legendary Joker (use most expensive as legendary)
                    if (gameState.jokers.length < gameState.maxJokers) {
                        const legendaryJokers = jokerTypes.filter(j => j.price >= 10);
                        const randomJoker = legendaryJokers[Math.floor(Math.random() * legendaryJokers.length)];
                        gameState.jokers.push({...randomJoker});
                        message = `Created legendary ${randomJoker.name}!`;
                        renderJokers();
                    }
                    break;

                default:
                    message = `Used ${card.name}!`;
            }

            // Remove the used card
            gameState.spectralCards.splice(index, 1);
            showNotification(message);
            renderSpectralCards();
            updateDisplay();
        }

        function renderSpectralCards() {
            const container = document.getElementById('spectral-cards');
            if (!container) return;

            container.innerHTML = '';
            gameState.spectralCards.slice(0, 2).forEach((card, index) => {
                const cardEl = document.createElement('div');
                cardEl.className = 'spectral-card usable';
                cardEl.innerHTML = `${card.icon} ${card.name}`;
                cardEl.title = card.desc;
                cardEl.addEventListener('click', () => useSpectralCard(index));
                container.appendChild(cardEl);
            });
        }

        // ===== ENHANCED CARD RENDERING =====

        // Override renderHand to include enhancement visuals and seals
        const originalRenderHand = renderHand;
        renderHand = function() {
            originalRenderHand();

            // Add enhancement classes to cards
            document.querySelectorAll('.card').forEach((cardEl, index) => {
                if (index < gameState.hand.length) {
                    const card = gameState.hand[index];

                    // Add enhancement class
                    if (card.enhancement) {
                        cardEl.classList.add(`enhanced-${card.enhancement}`);
                    }

                    // Add special effect class
                    if (card.specialEffect) {
                        cardEl.classList.add(card.specialEffect);
                    }

                    // Add seal indicator
                    if (card.seal) {
                        const sealEl = document.createElement('div');
                        sealEl.className = `card-seal ${card.seal}`;
                        sealEl.title = sealTypes[card.seal]?.effect || '';
                        cardEl.appendChild(sealEl);
                    }
                }
            });
        };

        // Initialize game on load
        window.addEventListener('load', () => {
            loadSettings();
            loadAchievements();
            loadLeaderboard();
            loadCodex();
            loadChallengeProgress();
            loadRunHistory();

            // Initialize seed if not set
            if (!gameSettings.seed) {
                initRNG(generateNewSeed());
                saveSettings();
            } else {
                initRNG(gameSettings.seed);
            }

            initGame();
            addJokerTooltips();
            updateComboDisplay();

            // Check for daily challenge
            checkDailyChallenge();

            // Show tutorial for first-time users
            if (shouldShowTutorial()) {
                setTimeout(() => showTutorial(), 500);
            }
        });
    </script>
</body>
</html>