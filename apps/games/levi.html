<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>LEVIATHAN: OMNIVERSE</title>
    <style>
        /* System fonts - local-first compliant, no external dependencies */
        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; }

        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, system-ui, Roboto, sans-serif;
            background: #000;
            color: #fff;
            touch-action: none;
        }

        #container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }

        /* UI OVERLAY */
        .ui-layer {
            position: fixed;
            pointer-events: none;
            width: 100%;
            height: 100%;
            z-index: 10;
        }

        /* GALAXY HUD */
        .hud-top {
            position: absolute;
            top: 0; left: 0; right: 0;
            background: linear-gradient(to bottom, rgba(0,10,20,0.95), transparent);
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            border-bottom: 1px solid rgba(0, 255, 255, 0.1);
            pointer-events: auto;
            flex-wrap: wrap;
            gap: 10px;
        }

        .game-title {
            font-family: Georgia, 'Times New Roman', serif;
            font-size: clamp(20px, 4vw, 32px);
            color: #00ffff;
            text-shadow: 0 0 10px rgba(0,255,255,0.5);
            letter-spacing: 4px;
            font-weight: bold;
        }

        .subtitle {
            color: #666;
            font-size: clamp(10px, 2vw, 12px);
        }

        .stats-box {
            display: flex;
            gap: 15px;
            text-align: right;
            flex-wrap: wrap;
        }

        .stat-entry {
            display: flex;
            flex-direction: column;
        }
        .stat-val { font-size: clamp(14px, 3vw, 20px); color: #00ff00; font-weight: bold; }
        .stat-lbl { font-size: clamp(8px, 1.5vw, 10px); color: #666; text-transform: uppercase; }

        /* Data Controls - Import/Export */
        .data-controls {
            position: fixed;
            top: 8px;
            left: 220px;
            right: 180px;
            z-index: 1000;
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            pointer-events: auto;
            justify-content: center;
            align-items: flex-start;
        }

        .data-controls button {
            background: rgba(0, 255, 255, 0.15);
            border: 1px solid #0ff;
            color: #0ff;
            padding: 5px 10px;
            font-size: 11px;
            cursor: pointer;
            border-radius: 4px;
            font-family: inherit;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .data-controls button:hover {
            background: rgba(0, 255, 255, 0.3);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            transform: translateY(-1px);
        }

        /* v5.7: Menu toggle for dropdown */
        .data-controls .menu-toggle {
            background: rgba(255, 255, 255, 0.15) !important;
            border: 1px solid #fff !important;
            color: #fff !important;
        }

        .data-controls .menu-toggle:hover {
            background: rgba(255, 255, 255, 0.3) !important;
        }

        .data-controls .menu-secondary {
            display: none;
            position: fixed;
            top: 40px;
            right: 180px;
            background: rgba(10, 10, 30, 0.98);
            border: 1px solid #0ff;
            border-radius: 8px;
            padding: 8px;
            flex-direction: column;
            gap: 5px;
            min-width: 130px;
            box-shadow: 0 4px 20px rgba(0, 255, 255, 0.3);
            z-index: 1001;
        }

        .data-controls .menu-secondary.show {
            display: flex;
        }

        .data-controls .menu-secondary button {
            width: 100%;
            text-align: left;
            padding: 8px 12px;
        }

        /* v5.7: AI Companion Settings Modal - Tabbed Interface */
        .ai-settings-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 10000;
            justify-content: center;
            align-items: center;
        }
        .ai-settings-modal.active { display: flex; }
        .ai-settings-content {
            background: linear-gradient(135deg, #1a1a2e 0%, #0d0d1a 100%);
            border: 2px solid #7b2cbf;
            border-radius: 20px;
            width: 94%;
            max-width: 580px;
            max-height: 90vh;
            overflow: hidden;
            box-shadow: 0 0 60px rgba(123, 44, 191, 0.5), inset 0 0 100px rgba(123, 44, 191, 0.1);
            position: relative;
        }
        .ai-settings-content::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(123, 44, 191, 0.1) 0%, transparent 50%);
            animation: ai-glow-rotate 20s linear infinite;
            pointer-events: none;
        }
        @keyframes ai-glow-rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        .ai-settings-header {
            padding: 25px 25px 20px;
            text-align: center;
            position: relative;
            z-index: 1;
        }
        .ai-settings-header h2 {
            margin: 0;
            font-size: 28px;
            font-weight: bold;
            font-style: italic;
            background: linear-gradient(135deg, #06ffa5, #7b2cbf);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .ai-settings-close {
            position: absolute;
            top: 20px;
            right: 20px;
            background: none;
            border: none;
            color: #fff;
            font-size: 28px;
            cursor: pointer;
            opacity: 0.7;
            transition: all 0.2s;
            z-index: 2;
        }
        .ai-settings-close:hover { opacity: 1; transform: scale(1.1); }

        /* Tabs */
        .ai-settings-tabs {
            display: flex;
            justify-content: center;
            gap: 8px;
            padding: 0 20px 20px;
            position: relative;
            z-index: 1;
        }
        .ai-settings-tab {
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            color: #888;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .ai-settings-tab:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
        }
        .ai-settings-tab.active {
            background: linear-gradient(135deg, #06ffa5, #00cc88);
            border-color: #06ffa5;
            color: #000;
            font-weight: bold;
        }

        /* Tab Content */
        .ai-settings-body {
            padding: 0 25px 20px;
            max-height: calc(90vh - 250px);
            overflow-y: auto;
            position: relative;
            z-index: 1;
        }
        .ai-tab-content {
            display: none;
        }
        .ai-tab-content.active {
            display: block;
            animation: fadeIn 0.3s ease;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Sections */
        .ai-section {
            margin-bottom: 20px;
            padding: 20px;
            background: rgba(30, 30, 50, 0.6);
            border-radius: 12px;
            border: 1px solid rgba(123, 44, 191, 0.2);
        }
        .ai-section h3 {
            margin: 0 0 15px 0;
            font-size: 16px;
            font-weight: bold;
            color: #06ffa5;
        }

        /* Form Elements */
        .ai-form-group {
            margin-bottom: 15px;
        }
        .ai-form-group label {
            display: block;
            font-size: 12px;
            color: #aaa;
            margin-bottom: 6px;
        }
        .ai-input {
            width: 100%;
            padding: 12px 15px;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            color: #fff;
            font-size: 14px;
            font-family: inherit;
            transition: all 0.2s;
            box-sizing: border-box;
        }
        .ai-input:focus {
            outline: none;
            border-color: #06ffa5;
            box-shadow: 0 0 10px rgba(6, 255, 165, 0.2);
        }
        .ai-input::placeholder {
            color: #555;
        }
        .ai-select {
            width: 100%;
            padding: 12px 15px;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            color: #fff;
            font-size: 14px;
            font-family: inherit;
            cursor: pointer;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='%23888' viewBox='0 0 16 16'%3E%3Cpath d='M8 11L3 6h10l-5 5z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 15px center;
        }
        .ai-select:focus {
            outline: none;
            border-color: #06ffa5;
        }

        /* Toggle Switch */
        .ai-toggle-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
        }
        .ai-toggle-label {
            font-size: 14px;
            color: #ddd;
        }
        .ai-toggle {
            position: relative;
            width: 50px;
            height: 26px;
        }
        .ai-toggle input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .ai-toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 26px;
            transition: 0.3s;
        }
        .ai-toggle-slider::before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 3px;
            bottom: 3px;
            background: #fff;
            border-radius: 50%;
            transition: 0.3s;
        }
        .ai-toggle input:checked + .ai-toggle-slider {
            background: linear-gradient(135deg, #06ffa5, #00cc88);
        }
        .ai-toggle input:checked + .ai-toggle-slider::before {
            transform: translateX(24px);
        }

        /* Endpoint Cards */
        .ai-endpoint-card {
            padding: 15px;
            background: rgba(6, 255, 165, 0.05);
            border: 1px solid rgba(6, 255, 165, 0.2);
            border-radius: 10px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .ai-endpoint-card:hover {
            background: rgba(6, 255, 165, 0.1);
            border-color: rgba(6, 255, 165, 0.4);
        }
        .ai-endpoint-card.active {
            background: rgba(6, 255, 165, 0.15);
            border-color: #06ffa5;
            box-shadow: 0 0 20px rgba(6, 255, 165, 0.2);
        }
        .ai-endpoint-name {
            font-weight: bold;
            color: #06ffa5;
            font-size: 14px;
            margin-bottom: 4px;
        }
        .ai-endpoint-url {
            font-size: 11px;
            color: #666;
            word-break: break-all;
        }
        .ai-endpoint-badge {
            display: inline-block;
            padding: 3px 10px;
            border-radius: 12px;
            font-size: 10px;
            margin-top: 8px;
            font-weight: bold;
        }
        .ai-endpoint-badge.active {
            background: rgba(6, 255, 165, 0.2);
            color: #06ffa5;
        }
        .ai-endpoint-badge.inactive {
            background: rgba(255, 255, 255, 0.1);
            color: #888;
        }

        /* Color Picker Row */
        .ai-color-row {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .ai-color-preview {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }
        .ai-color-input {
            flex: 1;
        }

        /* Actions Footer */
        .ai-settings-footer {
            display: flex;
            gap: 15px;
            padding: 20px 25px;
            border-top: 1px solid rgba(123, 44, 191, 0.3);
            position: relative;
            z-index: 1;
        }
        .ai-btn {
            flex: 1;
            padding: 14px 20px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.2s;
            font-family: inherit;
        }
        .ai-btn-save {
            background: linear-gradient(135deg, #06ffa5, #00cc88);
            color: #000;
        }
        .ai-btn-save:hover {
            box-shadow: 0 0 25px rgba(6, 255, 165, 0.5);
            transform: translateY(-2px);
        }
        .ai-btn-cancel {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #aaa;
        }
        .ai-btn-cancel:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
        }
        .ai-btn-import {
            background: linear-gradient(135deg, #7b2cbf, #3a0ca3);
            color: #fff;
        }
        .ai-btn-import:hover {
            box-shadow: 0 0 20px rgba(123, 44, 191, 0.5);
        }

        /* Status Message */
        .ai-status-msg {
            text-align: center;
            padding: 10px;
            font-size: 12px;
            color: #888;
            margin-top: 10px;
        }
        .ai-status-msg.success { color: #06ffa5; }
        .ai-status-msg.error { color: #f44; }

        /* Player Health Bar - v5.15.2: Updated for PROBE INTEGRITY design */
        /* v5.16.3: Moved below button row to fix UI overlap */
        .player-health-bar {
            position: fixed;
            top: 45px;
            left: 50%;
            transform: translateX(-50%);
            width: clamp(200px, 35vw, 320px);
            background: rgba(10, 20, 30, 0.9);
            border: 2px solid #0ff;
            border-radius: 12px;
            padding: 8px 12px;
            display: none;
            pointer-events: none;
            backdrop-filter: blur(5px);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
            z-index: 99;
        }

        .player-health-bar.critical {
            border-color: #f44;
            box-shadow: 0 0 20px rgba(255, 68, 68, 0.4);
            animation: critical-pulse 0.5s infinite;
        }

        @keyframes critical-pulse {
            0%, 100% { box-shadow: 0 0 20px rgba(255, 68, 68, 0.4); }
            50% { box-shadow: 0 0 30px rgba(255, 68, 68, 0.7); }
        }

        .player-health-fill {
            height: 8px;
            background: linear-gradient(to right, #0ff, #06ffa5);
            width: 100%;
            transition: width 0.3s, background 0.3s;
            border-radius: 4px;
        }

        .player-health-fill.low {
            background: linear-gradient(to right, #ff8800, #ffaa00);
        }

        .player-health-fill.critical {
            background: linear-gradient(to right, #f44, #ff6666);
        }

        .player-health-text {
            text-align: right;
            font-size: 11px;
            font-weight: bold;
            color: #fff;
            text-shadow: 1px 1px 2px #000;
        }

        /* v5.11: RTS-Style RPG INTERFACE - Edge Docked Panels */
        .rpg-ui {
            position: absolute;
            bottom: 0; left: 0; right: 0;
            display: none;
            padding: 0;
            pointer-events: none;
        }

        /* RTS Panel Toggle Buttons - Bottom Left Corner */
        .rts-panel-toggles {
            position: fixed;
            bottom: 10px;
            left: 10px;
            display: flex;
            gap: 4px;
            z-index: 1003;
            pointer-events: auto;
        }
        .rts-toggle-btn {
            width: 36px;
            height: 36px;
            background: rgba(10, 15, 20, 0.95);
            border: 2px solid #445;
            border-radius: 6px;
            color: #fb0;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s;
        }
        .rts-toggle-btn:hover { border-color: #fb0; background: rgba(30, 35, 40, 0.95); }
        .rts-toggle-btn.active { border-color: #0ff; background: rgba(0, 60, 80, 0.5); }
        .rts-toggle-btn .toggle-key {
            position: absolute;
            bottom: -1px;
            right: 2px;
            font-size: 8px;
            color: #666;
        }

        /* Skills Panel - Left Edge Dock */
        .player-stats {
            position: fixed;
            bottom: 55px;
            left: 0;
            pointer-events: auto;
            background: rgba(10, 15, 20, 0.95);
            border: 2px solid #445;
            border-left: none;
            border-radius: 0 8px 8px 0;
            padding: 8px 10px;
            width: 160px;
            max-height: 240px;
            overflow-y: auto;
            z-index: 1001;
            transform: translateX(-100%);
            transition: transform 0.2s ease;
        }
        .player-stats.visible { transform: translateX(0); }

        /* Crafting Panel - Left Edge Dock (Below Skills) */
        .crafting-panel {
            position: fixed;
            bottom: 55px;
            left: 170px;
            background: rgba(10, 15, 20, 0.95);
            border: 2px solid #445;
            border-radius: 8px;
            padding: 8px;
            pointer-events: auto;
            width: 150px;
            max-height: 280px;
            overflow-y: auto;
            z-index: 1001;
            transform: translateX(-300px);
            opacity: 0;
            transition: transform 0.2s ease, opacity 0.2s ease;
        }
        .crafting-panel.visible { transform: translateX(0); opacity: 1; }

        /* Inventory Panel - Bottom Center Dock */
        .inventory-panel {
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%) translateY(100%);
            background: rgba(10, 15, 20, 0.95);
            border: 2px solid #445;
            border-radius: 8px;
            padding: 8px;
            pointer-events: auto;
            width: 200px;
            z-index: 1001;
            box-shadow: 0 0 15px rgba(0,0,0,0.8);
            transition: transform 0.2s ease;
        }
        .inventory-panel.visible { transform: translateX(-50%) translateY(0); }

        /* Equipment Panel - Right of Inventory */
        .equipment-panel {
            position: fixed;
            bottom: 10px;
            right: 80px;
            background: rgba(10, 15, 20, 0.95);
            border: 2px solid #445;
            border-radius: 8px;
            padding: 8px;
            pointer-events: auto;
            width: 160px;
            z-index: 1001;
            box-shadow: 0 0 15px rgba(0,0,0,0.8);
            transform: translateY(100%);
            transition: transform 0.2s ease;
        }
        .equipment-panel.visible { transform: translateY(0); }

        .panel-title {
            color: #fb0;
            font-family: Georgia, serif;
            border-bottom: 1px solid #445;
            margin-bottom: 6px;
            padding-bottom: 4px;
            font-size: 11px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .panel-title .close-panel {
            cursor: pointer;
            color: #666;
            font-size: 14px;
            line-height: 1;
        }
        .panel-title .close-panel:hover { color: #f44; }

        .inv-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 4px;
        }

        .inv-slot {
            background: #1a1a1a;
            border: 1px solid #333;
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            position: relative;
            cursor: pointer;
            transition: all 0.1s;
            min-width: 32px;
            min-height: 32px;
            border-radius: 3px;
        }

        .inv-slot:hover { border-color: #fb0; background: #2a2a2a; }
        .inv-count {
            position: absolute;
            bottom: 1px; right: 2px;
            font-size: 9px;
            color: #fff;
            font-weight: bold;
            text-shadow: 1px 1px 1px #000;
        }

        /* v5.1: Equipment Slots - Compact */
        .equip-slot {
            background: #1a1a2a;
            border: 1px solid #334;
            border-radius: 4px;
            padding: 4px;
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            transition: all 0.2s;
        }
        .equip-slot:hover { border-color: #fb0; background: #2a2a3a; }
        .equip-slot.equipped { border-color: #4a4; background: rgba(68, 170, 68, 0.15); }
        .equip-icon { font-size: 16px; margin-bottom: 2px; }
        .equip-name { font-size: 8px; color: #aaa; text-align: center; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 60px; }
        .equip-slot.equipped .equip-name { color: #4f4; }

        .xp-bar-container {
            margin-bottom: 4px;
        }
        .xp-label { font-size: 9px; color: #aaa; display: flex; justify-content: space-between; }
        .xp-bar-bg { height: 4px; background: #222; border-radius: 2px; overflow: hidden; margin-top: 2px; }
        .xp-bar-fill { height: 100%; width: 0%; transition: width 0.3s; }

        .craft-btn {
            display: block;
            width: 100%;
            background: #333;
            border: 1px solid #555;
            color: #fff;
            padding: 5px 6px;
            margin-bottom: 3px;
            cursor: pointer;
            border-radius: 3px;
            font-size: 9px;
            transition: all 0.2s;
        }

        .craft-btn:hover:not(:disabled) { background: #555; border-color: #fb0; }
        .craft-btn:disabled { opacity: 0.4; cursor: not-allowed; }

        /* Action Buttons */
        .action-btn {
            background: #fb0;
            color: #000;
            border: none;
            padding: 8px 16px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 4px;
            font-family: Georgia, serif;
            pointer-events: auto;
            font-size: clamp(11px, 2vw, 14px);
        }
        .action-btn:hover { background: #fff; box-shadow: 0 0 15px #fb0; }

        /* Floating Text */
        .floater {
            position: absolute;
            font-weight: bold;
            text-shadow: 0 0 4px #000;
            pointer-events: none;
            animation: floatUp 1.5s forwards;
            font-size: clamp(12px, 2vw, 16px);
        }

        @keyframes floatUp {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-50px) scale(1.2); opacity: 0; }
        }

        /* Tooltip context menu */
        .context-tooltip {
            position: absolute;
            background: rgba(0,0,0,0.9);
            border: 1px solid #0ff;
            padding: 8px 12px;
            color: #0ff;
            font-size: clamp(10px, 1.5vw, 12px);
            pointer-events: none;
            display: none;
            z-index: 100;
            border-radius: 4px;
            max-width: 200px;
        }

        .loading {
            position: fixed; top:0; left:0; right:0; bottom:0;
            background: #000; color: #0f0;
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            z-index: 999;
            font-family: Georgia, serif;
        }

        .loading-text {
            font-size: clamp(18px, 4vw, 24px);
            margin-bottom: 20px;
        }

        .loading-bar {
            width: clamp(200px, 50vw, 300px);
            height: 4px;
            background: #222;
            border-radius: 2px;
            overflow: hidden;
        }

        .loading-progress {
            height: 100%;
            background: #0f0;
            animation: loadPulse 1s ease-in-out infinite;
        }

        @keyframes loadPulse {
            0%, 100% { width: 20%; margin-left: 0; }
            50% { width: 40%; margin-left: 60%; }
        }

        /* Minimap */
        .minimap {
            position: fixed;
            bottom: 200px;
            right: 10px;
            width: clamp(80px, 15vw, 120px);
            height: clamp(80px, 15vw, 120px);
            background: rgba(0,0,0,0.7);
            border: 2px solid #445;
            border-radius: 8px;
            display: none;
            pointer-events: auto;
            overflow: hidden;
        }

        .minimap-canvas {
            width: 100%;
            height: 100%;
        }

        /* v4.8: Combat Abilities (v4.9: Enhanced styling) */
        @keyframes ability-ready-pulse {
            0%, 100% { box-shadow: 0 0 5px rgba(0, 255, 255, 0.3); }
            50% { box-shadow: 0 0 15px rgba(0, 255, 255, 0.6); }
        }
        @keyframes berserk-pulse {
            0%, 100% { box-shadow: 0 0 10px rgba(255, 68, 0, 0.5); }
            50% { box-shadow: 0 0 25px rgba(255, 68, 0, 0.9); }
        }
        .ability-slot {
            width: 50px;
            height: 50px;
            background: rgba(40, 40, 60, 0.9);
            border: 2px solid #555;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            transition: all 0.2s;
        }
        .ability-slot:hover:not(.locked):not(.on-cooldown) {
            border-color: #0ff;
            transform: scale(1.1);
        }
        .ability-slot.locked {
            opacity: 0.35;
            cursor: not-allowed;
            filter: grayscale(0.8);
        }
        .ability-slot.locked::after {
            content: 'ðŸ”’';
            position: absolute;
            font-size: 12px;
            top: 2px;
            right: 2px;
        }
        .ability-slot.on-cooldown {
            border-color: #444;
            opacity: 0.7;
        }
        .ability-slot:not(.locked):not(.on-cooldown) {
            animation: ability-ready-pulse 2s infinite;
            border-color: #0aa;
        }
        .ability-slot.active-buff {
            border-color: #ff8800;
            box-shadow: 0 0 10px #ff8800;
            animation: none;
        }
        .ability-slot.active-buff[id="ability-c"] {
            animation: berserk-pulse 0.5s infinite;
        }
        .ability-icon {
            font-size: 20px;
        }
        .ability-key {
            font-size: 10px;
            color: #888;
            margin-top: 2px;
        }
        .ability-cooldown {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 0;
            background: rgba(0, 0, 0, 0.7);
            transition: height 0.1s linear;
            border-radius: 0 0 6px 6px;
        }

        /* Touch Controls */
        .touch-controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            display: none;
            pointer-events: auto;
            gap: 10px;
        }

        .touch-btn {
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            color: #fff;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }

        .touch-btn:active {
            background: rgba(255, 255, 255, 0.4);
        }

        /* v4.3: Virtual Joystick */
        .virtual-joystick {
            position: fixed;
            bottom: 30px;
            left: 30px;
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: none;
            touch-action: none;
        }

        .joystick-knob {
            position: absolute;
            width: 50px;
            height: 50px;
            background: rgba(0, 255, 255, 0.5);
            border: 2px solid rgba(0, 255, 255, 0.8);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        .touch-action-btn {
            position: fixed;
            bottom: 50px;
            right: 30px;
            width: 70px;
            height: 70px;
            background: rgba(255, 100, 0, 0.4);
            border: 3px solid rgba(255, 150, 0, 0.7);
            border-radius: 50%;
            color: #fff;
            font-size: 24px;
            font-weight: bold;
            display: none;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }

        .touch-action-btn:active {
            background: rgba(255, 150, 0, 0.7);
        }

        /* v4.5: Mobile Dodge Button */
        .touch-dodge-btn {
            position: fixed;
            bottom: 140px;
            right: 30px;
            width: 60px;
            height: 60px;
            background: rgba(100, 200, 255, 0.4);
            border: 3px solid rgba(150, 220, 255, 0.7);
            border-radius: 50%;
            color: #fff;
            font-size: 18px;
            font-weight: bold;
            display: none;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }

        .touch-dodge-btn:active {
            background: rgba(150, 220, 255, 0.7);
        }

        /* Notification Toast */
        .notification {
            position: fixed;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 100, 0, 0.9);
            border: 1px solid #0f0;
            padding: 10px 20px;
            border-radius: 4px;
            color: #0f0;
            font-size: 14px;
            z-index: 500;
            animation: notifySlide 3s forwards;
            pointer-events: none;
        }

        @keyframes notifySlide {
            0% { opacity: 0; transform: translateX(-50%) translateY(-20px); }
            10% { opacity: 1; transform: translateX(-50%) translateY(0); }
            80% { opacity: 1; }
            100% { opacity: 0; }
        }

        /* Achievement Popup */
        .achievement-popup {
            position: fixed;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(30, 30, 50, 0.95), rgba(50, 40, 80, 0.95));
            border: 2px solid #ffd700;
            border-radius: 12px;
            padding: 15px 25px;
            display: flex;
            align-items: center;
            gap: 15px;
            z-index: 600;
            animation: achievementSlide 4s forwards;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.4);
        }

        .achievement-popup .ach-icon { font-size: 36px; }
        .achievement-popup .ach-title { color: #ffd700; font-size: 11px; text-transform: uppercase; letter-spacing: 2px; }
        .achievement-popup .ach-name { color: #fff; font-size: 16px; font-weight: bold; margin: 3px 0; }
        .achievement-popup .ach-desc { color: #aaa; font-size: 12px; }

        @keyframes achievementSlide {
            0% { opacity: 0; transform: translateX(-50%) translateY(-30px); }
            10% { opacity: 1; transform: translateX(-50%) translateY(0); }
            85% { opacity: 1; transform: translateX(-50%) translateY(0); }
            100% { opacity: 0; transform: translateX(-50%) translateY(-20px); }
        }

        /* Daily Challenge Box */
        .daily-challenge-box {
            position: fixed;
            top: 120px;
            right: 10px;
            background: rgba(20, 20, 40, 0.9);
            border: 1px solid #ffd700;
            border-radius: 8px;
            padding: 12px 15px;
            width: 180px;
            z-index: 100;
        }

        .daily-challenge-box.completed {
            border-color: #44ff44;
            background: rgba(20, 40, 20, 0.9);
        }

        .daily-title { color: #ffd700; font-size: 11px; text-transform: uppercase; margin-bottom: 8px; }
        .daily-desc { color: #fff; font-size: 12px; margin-bottom: 8px; }
        .daily-progress-bar { background: #333; border-radius: 4px; height: 8px; overflow: hidden; }
        .daily-progress-fill { background: linear-gradient(90deg, #ffd700, #ffaa00); height: 100%; transition: width 0.3s; }
        .daily-progress-text { color: #aaa; font-size: 10px; margin-top: 5px; }
        .daily-streak { color: #ff8800; font-size: 10px; margin-top: 3px; }

        /* Stats Modal */
        .stats-section { margin-bottom: 20px; }
        .stat-row { display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px solid rgba(255,255,255,0.1); color: #ccc; font-size: 13px; }
        .stat-row span:last-child { color: #0ff; font-weight: bold; }

        .achievements-grid { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 10px; }
        .ach-item {
            display: flex; align-items: center; gap: 6px;
            background: rgba(40,40,60,0.8);
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 11px;
            color: #666;
        }
        .ach-item.unlocked { color: #fff; background: rgba(50, 50, 80, 0.9); border: 1px solid #ffd700; }
        .ach-item.locked .ach-badge { filter: grayscale(1); opacity: 0.4; }
        .ach-badge { font-size: 16px; }

        /* Settings Modal */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            pointer-events: auto;
        }

        .modal-content {
            background: #1a1a2e;
            border: 2px solid #0ff;
            border-radius: 12px;
            padding: 25px;
            max-width: 400px;
            width: 90%;
        }

        .modal-title {
            color: #0ff;
            font-size: 20px;
            margin-bottom: 20px;
            font-family: Georgia, serif;
        }

        .modal-close {
            float: right;
            background: none;
            border: none;
            color: #fff;
            font-size: 24px;
            cursor: pointer;
        }

        /* v4.9: Collection Codex Styles */
        .codex-tab {
            background: rgba(40, 40, 60, 0.8);
            border: 1px solid #444;
            color: #aaa;
            padding: 8px 14px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }
        .codex-tab:hover { border-color: #0ff; color: #fff; }
        .codex-tab.active {
            background: linear-gradient(135deg, #0aa, #088);
            border-color: #0ff;
            color: #fff;
        }
        .codex-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 10px;
        }
        .codex-entry {
            background: rgba(30, 30, 50, 0.9);
            border: 1px solid #333;
            border-radius: 8px;
            padding: 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }
        .codex-entry:hover { border-color: #0ff; transform: translateY(-2px); }
        .codex-entry.discovered { border-color: #4a4; }
        .codex-entry.undiscovered {
            filter: grayscale(1);
            opacity: 0.5;
        }
        .codex-entry .entry-icon {
            font-size: 28px;
            margin-bottom: 5px;
            display: block;
        }
        .codex-entry .entry-name {
            font-size: 11px;
            color: #ccc;
            display: block;
        }
        .codex-entry.undiscovered .entry-name { color: #666; }
        .codex-entry .entry-count {
            font-size: 10px;
            color: #888;
            margin-top: 3px;
        }

        /* v5.0: Quest System Styles */
        .quest-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .quest-item {
            background: rgba(30, 30, 50, 0.9);
            border: 1px solid #444;
            border-radius: 8px;
            padding: 12px;
            transition: all 0.2s;
        }
        .quest-item:hover { border-color: #ff8c00; }
        .quest-item.completed {
            border-color: #4a4;
            background: rgba(40, 80, 40, 0.3);
        }
        .quest-item.claimed {
            opacity: 0.5;
            border-color: #333;
        }
        .quest-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        .quest-title {
            font-size: 14px;
            color: #fff;
            font-weight: bold;
        }
        .quest-reward {
            font-size: 12px;
            color: #ffd700;
        }
        .quest-desc {
            font-size: 12px;
            color: #aaa;
            margin-bottom: 8px;
        }
        .quest-progress-bar {
            height: 6px;
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
            overflow: hidden;
        }
        .quest-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff8c00, #ffd700);
            transition: width 0.3s;
        }
        .quest-progress-text {
            font-size: 11px;
            color: #888;
            margin-top: 4px;
            text-align: right;
        }
        .quest-claim-btn {
            margin-top: 8px;
            padding: 6px 12px;
            background: linear-gradient(135deg, #4a4, #2a2);
            border: none;
            border-radius: 4px;
            color: #fff;
            cursor: pointer;
            font-size: 12px;
            width: 100%;
        }
        .quest-claim-btn:hover { background: linear-gradient(135deg, #5b5, #3b3); }
        .quest-claim-btn:disabled {
            background: #333;
            cursor: not-allowed;
            opacity: 0.5;
        }

        /* v4.6: Settings Panel Styles */
        .settings-section {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .settings-section:last-child { border-bottom: none; }
        .settings-section h4 {
            margin: 0 0 12px 0;
            font-size: 14px;
        }
        .setting-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            font-size: 13px;
            color: #ccc;
        }
        .setting-row input[type="range"] {
            width: 100px;
            margin: 0 10px;
            accent-color: #0ff;
        }
        .setting-row select {
            background: #222;
            border: 1px solid #445;
            color: #fff;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
        }
        .toggle-btn {
            background: rgba(0,100,0,0.5);
            border: 1px solid #0f0;
            color: #0f0;
            padding: 4px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            min-width: 50px;
        }
        .toggle-btn.off {
            background: rgba(100,0,0,0.5);
            border-color: #f44;
            color: #f44;
        }

        /* v5.3: Mastery System Styles */
        .mastery-card {
            background: rgba(30, 30, 50, 0.9);
            border: 1px solid #444;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
            transition: all 0.2s;
        }
        .mastery-card:hover { border-color: #ffd700; }
        .mastery-card.mastered { border-color: #ffd700; background: rgba(50, 45, 30, 0.9); }
        .mastery-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
        .mastery-skill { font-size: 16px; font-weight: bold; }
        .mastery-level { color: #ffd700; font-size: 14px; }
        .mastery-progress-bar { height: 8px; background: rgba(255,255,255,0.1); border-radius: 4px; overflow: hidden; margin-bottom: 8px; }
        .mastery-progress-fill { height: 100%; background: linear-gradient(90deg, #8844ff, #ff44ff); transition: width 0.3s; }
        .mastery-milestones { display: flex; gap: 8px; flex-wrap: wrap; }
        .milestone { padding: 4px 8px; border-radius: 4px; font-size: 11px; background: rgba(0,0,0,0.3); border: 1px solid #333; }
        .milestone.achieved { background: rgba(255, 215, 0, 0.2); border-color: #ffd700; color: #ffd700; }
        .milestone.next { background: rgba(136, 68, 255, 0.2); border-color: #8844ff; color: #aaf; }

        /* v5.3: Realm Portal Styles */
        .portal-card {
            background: linear-gradient(135deg, rgba(40, 20, 60, 0.95), rgba(20, 40, 60, 0.95));
            border: 2px solid #8844ff;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 12px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .portal-card:hover { transform: translateY(-2px); box-shadow: 0 5px 20px rgba(136, 68, 255, 0.4); }
        .portal-card.locked { opacity: 0.5; cursor: not-allowed; filter: grayscale(0.5); }
        .portal-card.active { border-color: #ff4400; animation: portal-pulse 1.5s infinite; }
        @keyframes portal-pulse {
            0%, 100% { box-shadow: 0 0 10px rgba(255, 68, 0, 0.3); }
            50% { box-shadow: 0 0 25px rgba(255, 68, 0, 0.6); }
        }
        .portal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .portal-name { font-size: 18px; font-weight: bold; color: #fff; }
        .portal-tier { padding: 4px 10px; border-radius: 12px; font-size: 11px; background: linear-gradient(135deg, #8844ff, #4488ff); }
        .portal-desc { color: #aaa; font-size: 12px; margin-bottom: 10px; }
        .portal-rewards { display: flex; gap: 10px; flex-wrap: wrap; }
        .portal-reward { padding: 4px 8px; background: rgba(0,0,0,0.3); border-radius: 4px; font-size: 11px; color: #adf; }
        .portal-requirement { color: #888; font-size: 11px; margin-top: 8px; }

        /* v5.3: Loot Rarity Styles */
        .rarity-common { color: #aaaaaa; }
        .rarity-uncommon { color: #44ff44; }
        .rarity-rare { color: #4488ff; }
        .rarity-epic { color: #aa44ff; }
        .rarity-legendary { color: #ff8800; text-shadow: 0 0 5px rgba(255, 136, 0, 0.5); }
        .rarity-mythic { color: #ff4488; text-shadow: 0 0 8px rgba(255, 68, 136, 0.6); animation: mythic-glow 2s infinite; }
        @keyframes mythic-glow {
            0%, 100% { text-shadow: 0 0 5px rgba(255, 68, 136, 0.4); }
            50% { text-shadow: 0 0 15px rgba(255, 68, 136, 0.8); }
        }
        .item-modifiers { font-size: 10px; color: #88ff88; margin-top: 4px; }
        .loot-drop-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 20, 40, 0.95);
            border: 2px solid #ffd700;
            border-radius: 12px;
            padding: 20px;
            z-index: 1000;
            min-width: 250px;
            text-align: center;
            animation: loot-appear 0.3s ease-out;
        }
        @keyframes loot-appear {
            0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        /* v5.4: Companion Evolution Styles */
        .evolution-card {
            background: linear-gradient(135deg, rgba(40, 30, 60, 0.95), rgba(60, 40, 80, 0.95));
            border: 2px solid #aa44ff;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 12px;
            transition: all 0.3s;
        }
        .evolution-card:hover { box-shadow: 0 0 20px rgba(170, 68, 255, 0.4); }
        .evolution-card.can-evolve { border-color: #ffd700; animation: evolve-pulse 1.5s infinite; }
        @keyframes evolve-pulse {
            0%, 100% { box-shadow: 0 0 10px rgba(255, 215, 0, 0.3); }
            50% { box-shadow: 0 0 25px rgba(255, 215, 0, 0.6); }
        }
        .evolution-header { display: flex; align-items: center; gap: 12px; margin-bottom: 10px; }
        .evolution-icon { font-size: 40px; }
        .evolution-info { flex: 1; }
        .evolution-name { font-size: 16px; font-weight: bold; color: #fff; }
        .evolution-stage { font-size: 12px; color: #aa88ff; }
        .evolution-bond { margin: 10px 0; }
        .bond-bar { height: 8px; background: rgba(255,255,255,0.1); border-radius: 4px; overflow: hidden; }
        .bond-fill { height: 100%; background: linear-gradient(90deg, #ff44aa, #aa44ff); transition: width 0.3s; }
        .evolution-abilities { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 8px; }
        .evolution-ability { padding: 4px 8px; background: rgba(0,0,0,0.3); border-radius: 4px; font-size: 11px; color: #adf; }
        .evolution-ability.locked { opacity: 0.4; }
        .evolve-btn {
            display: block; width: 100%; margin-top: 10px; padding: 10px;
            background: linear-gradient(135deg, #ffd700, #ff8800);
            border: none; border-radius: 6px; color: #000; font-weight: bold;
            cursor: pointer; font-size: 14px; transition: all 0.2s;
        }
        .evolve-btn:hover { transform: scale(1.02); box-shadow: 0 0 15px rgba(255, 215, 0, 0.5); }
        .evolve-btn:disabled { opacity: 0.4; cursor: not-allowed; transform: none; box-shadow: none; }

        /* v5.4: World Events Styles */
        .event-notification {
            position: fixed; top: 100px; left: 50%; transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(255, 100, 0, 0.95), rgba(200, 50, 0, 0.95));
            border: 2px solid #ffd700; border-radius: 12px; padding: 15px 25px;
            z-index: 1500; text-align: center; animation: event-slide 0.5s ease-out;
            box-shadow: 0 0 30px rgba(255, 136, 0, 0.5);
        }
        @keyframes event-slide {
            0% { transform: translateX(-50%) translateY(-50px); opacity: 0; }
            100% { transform: translateX(-50%) translateY(0); opacity: 1; }
        }
        .event-title { font-size: 18px; font-weight: bold; color: #fff; margin-bottom: 5px; }
        .event-desc { font-size: 12px; color: #ffd700; }
        .event-timer { font-size: 14px; color: #fff; margin-top: 8px; }
        .world-event-marker {
            position: absolute; pointer-events: none;
            animation: event-marker-pulse 1s infinite;
        }
        @keyframes event-marker-pulse {
            0%, 100% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.2); opacity: 1; }
        }
        .event-indicator {
            position: fixed; top: 130px; right: 10px;
            background: rgba(0,0,0,0.8); border: 2px solid #ff8800;
            border-radius: 8px; padding: 10px; z-index: 100;
            display: none; min-width: 150px;
        }
        .event-indicator.active { display: block; animation: event-pulse 2s infinite; }
        @keyframes event-pulse {
            0%, 100% { border-color: #ff8800; }
            50% { border-color: #ffd700; box-shadow: 0 0 15px rgba(255, 136, 0, 0.5); }
        }
        .event-indicator-icon { font-size: 24px; text-align: center; margin-bottom: 5px; }
        .event-indicator-name { font-size: 12px; color: #ffd700; text-align: center; }
        .event-indicator-time { font-size: 11px; color: #fff; text-align: center; margin-top: 4px; }
        .event-indicator-progress { height: 4px; background: rgba(255,255,255,0.2); border-radius: 2px; margin-top: 6px; overflow: hidden; }
        .event-indicator-fill { height: 100%; background: #ff8800; transition: width 0.5s; }

        /* v5.4: Achievement Showcase Styles */
        .showcase-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 10px; margin-top: 15px; }
        .showcase-badge {
            background: rgba(30, 30, 50, 0.9); border: 2px solid #333;
            border-radius: 8px; padding: 10px; text-align: center;
            cursor: pointer; transition: all 0.2s;
        }
        .showcase-badge:hover { border-color: #ffd700; transform: translateY(-2px); }
        .showcase-badge.earned { border-color: #4a4; background: rgba(68, 170, 68, 0.15); }
        .showcase-badge.rare { border-color: #4488ff; background: rgba(68, 136, 255, 0.15); }
        .showcase-badge.legendary { border-color: #ff8800; background: rgba(255, 136, 0, 0.15); animation: legendary-badge 2s infinite; }
        @keyframes legendary-badge {
            0%, 100% { box-shadow: 0 0 5px rgba(255, 136, 0, 0.3); }
            50% { box-shadow: 0 0 15px rgba(255, 136, 0, 0.6); }
        }
        .showcase-badge-icon { font-size: 28px; margin-bottom: 5px; }
        .showcase-badge-name { font-size: 10px; color: #aaa; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .showcase-badge.earned .showcase-badge-name { color: #4f4; }
        .achievement-points-display {
            text-align: center; padding: 15px; margin-bottom: 15px;
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.1), rgba(255, 136, 0, 0.1));
            border: 1px solid #ffd700; border-radius: 8px;
        }
        .ap-value { font-size: 32px; font-weight: bold; color: #ffd700; }
        .ap-label { font-size: 12px; color: #aaa; }
        .ap-milestone { margin-top: 10px; padding: 8px; background: rgba(0,0,0,0.3); border-radius: 4px; }
        .ap-milestone-progress { height: 6px; background: rgba(255,255,255,0.1); border-radius: 3px; overflow: hidden; margin-top: 5px; }
        .ap-milestone-fill { height: 100%; background: linear-gradient(90deg, #ffd700, #ff8800); }
        .cosmetic-effect { position: absolute; pointer-events: none; z-index: 5; }
        .cosmetic-aura { animation: aura-rotate 3s linear infinite; }
        @keyframes aura-rotate { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Mobile responsiveness */
        @media (max-width: 768px) {
            .hud-top {
                padding: 10px;
            }

            .rpg-ui {
                flex-direction: column;
                align-items: center;
                max-height: 50vh;
                overflow-y: auto;
            }

            .inventory-panel, .player-stats, .crafting-panel {
                width: 95%;
                max-width: none;
            }

            .touch-controls {
                display: flex;
            }

            .data-controls {
                top: auto;
                bottom: 60px;
                right: 10px;
                left: 10px;
                justify-content: center;
            }

            .data-controls button {
                padding: 4px 8px;
                font-size: 9px;
            }

            .data-controls .menu-secondary {
                top: auto;
                bottom: 40px;
                right: 10px;
                left: auto;
                transform: none;
            }

            .minimap {
                bottom: auto;
                top: 70px;
                right: 10px;
            }
        }

        @media (max-width: 480px) {
            .game-title {
                font-size: 18px;
                letter-spacing: 2px;
            }

            .inv-grid {
                grid-template-columns: repeat(4, 1fr);
            }

            .rpg-ui {
                padding: 5px;
            }

            .data-controls button {
                padding: 3px 6px;
                font-size: 8px;
            }
        }

        /* v5.10: RTS-Style Command Bar - Compact Bottom-Right Toolbar */
        .rts-command-bar {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 1002;
            pointer-events: auto;
        }

        /* v5.6: Copilot Companion System Styles - RTS Compact */
        .copilot-button {
            width: 44px;
            height: 44px;
            background: rgba(138, 43, 226, 0.4);
            backdrop-filter: blur(8px);
            border: 2px solid rgba(138, 43, 226, 0.7);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 2px 10px rgba(138, 43, 226, 0.3);
        }

        .copilot-button:hover {
            background: rgba(138, 43, 226, 0.6);
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(138, 43, 226, 0.5);
        }

        .copilot-button.active {
            background: rgba(6, 255, 165, 0.5);
            border-color: rgba(6, 255, 165, 0.9);
            box-shadow: 0 2px 15px rgba(6, 255, 165, 0.4);
        }

        .copilot-button svg {
            width: 22px;
            height: 22px;
            color: white;
        }

        .copilot-chat-interface {
            position: fixed;
            bottom: 80px;
            right: 20px;
            width: 320px;
            height: 380px;
            background: rgba(8, 12, 20, 0.96);
            border: 1px solid rgba(138, 43, 226, 0.5);
            border-radius: 12px;
            display: none;
            flex-direction: column;
            z-index: 1003;
            pointer-events: auto;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
        }

        .copilot-chat-interface.active {
            display: flex;
            animation: slide-up 0.2s ease;
        }

        @keyframes slide-up {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .copilot-chat-header {
            padding: 14px 16px;
            border-bottom: 1px solid rgba(138, 43, 226, 0.3);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.2), rgba(6, 255, 165, 0.1));
            border-radius: 14px 14px 0 0;
        }

        .copilot-chat-title {
            font-weight: bold;
            color: #06ffa5;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .copilot-chat-title::before {
            content: 'ðŸŒŸ';
        }

        .copilot-close-btn {
            background: none;
            border: none;
            color: #fff;
            font-size: 22px;
            cursor: pointer;
            opacity: 0.7;
            transition: all 0.2s;
            padding: 0 5px;
        }

        .copilot-close-btn:hover {
            opacity: 1;
            color: #ff6a88;
            transform: rotate(90deg);
        }

        .copilot-chat-messages {
            flex: 1;
            padding: 14px;
            overflow-y: auto;
            scroll-behavior: smooth;
        }

        .copilot-message {
            margin: 8px 0;
            padding: 10px 12px;
            border-radius: 12px;
            max-width: 90%;
            word-wrap: break-word;
            font-size: 13px;
            line-height: 1.5;
            animation: message-slide 0.3s ease;
        }

        @keyframes message-slide {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .copilot-message.user {
            background: rgba(138, 43, 226, 0.3);
            margin-left: auto;
            text-align: right;
            border: 1px solid rgba(138, 43, 226, 0.4);
        }

        .copilot-message.ai {
            background: rgba(6, 255, 165, 0.15);
            margin-right: auto;
            border: 1px solid rgba(6, 255, 165, 0.3);
            text-align: left;
        }

        /* v5.9: Markdown formatting in chat messages */
        .copilot-message.ai a {
            color: #06ffa5;
            text-decoration: underline;
            cursor: pointer;
            word-break: break-word;
        }

        .copilot-message.ai a:hover {
            color: #4fffbc;
            text-decoration: none;
        }

        .copilot-message.ai strong, .copilot-message.ai b {
            color: #fff;
            font-weight: 600;
        }

        .copilot-message.ai em, .copilot-message.ai i {
            font-style: italic;
            color: #ccc;
        }

        .copilot-message.ai code {
            background: rgba(0, 0, 0, 0.4);
            padding: 2px 5px;
            border-radius: 4px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 12px;
            color: #ff9500;
        }

        .copilot-message.ai pre {
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 10px;
            border-radius: 6px;
            overflow-x: auto;
            margin: 6px 0;
            font-size: 11px;
        }

        .copilot-message.ai pre code {
            background: none;
            padding: 0;
        }

        .copilot-message.ai ul, .copilot-message.ai ol {
            margin: 6px 0;
            padding-left: 18px;
        }

        .copilot-message.ai li {
            margin: 3px 0;
        }

        .copilot-message.ai h1, .copilot-message.ai h2, .copilot-message.ai h3 {
            margin: 8px 0 4px 0;
            color: #06ffa5;
            font-size: 14px;
        }

        .copilot-message.ai h1 { font-size: 15px; }
        .copilot-message.ai h2 { font-size: 14px; }
        .copilot-message.ai h3 { font-size: 13px; }

        .copilot-message.ai hr {
            border: none;
            border-top: 1px solid rgba(6, 255, 165, 0.3);
            margin: 8px 0;
        }

        .copilot-message.ai blockquote {
            border-left: 3px solid #06ffa5;
            padding-left: 10px;
            margin: 6px 0;
            color: #aaa;
            font-style: italic;
        }

        .copilot-message.ai p {
            margin: 4px 0;
        }

        .copilot-message.ai p:first-child {
            margin-top: 0;
        }

        .copilot-message.ai p:last-child {
            margin-bottom: 0;
        }

        .copilot-typing {
            padding: 10px 14px;
            border-radius: 12px;
            background: rgba(6, 255, 165, 0.15);
            display: flex;
            align-items: center;
            gap: 5px;
            width: fit-content;
            margin: 10px 0;
        }

        .copilot-typing-dot {
            width: 7px;
            height: 7px;
            background: rgba(6, 255, 165, 0.7);
            border-radius: 50%;
            animation: typing-pulse 1.4s infinite ease-in-out;
        }

        .copilot-typing-dot:nth-child(1) { animation-delay: -0.32s; }
        .copilot-typing-dot:nth-child(2) { animation-delay: -0.16s; }

        @keyframes typing-pulse {
            0%, 80%, 100% { transform: scale(0.7); opacity: 0.4; }
            40% { transform: scale(1); opacity: 1; }
        }

        .copilot-chat-input-container {
            padding: 12px;
            border-top: 1px solid rgba(138, 43, 226, 0.3);
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .copilot-chat-input {
            flex: 1;
            padding: 10px 14px;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(138, 43, 226, 0.4);
            border-radius: 20px;
            color: white;
            font-size: 13px;
            outline: none;
            transition: all 0.2s;
        }

        .copilot-chat-input:focus {
            border-color: #06ffa5;
            box-shadow: 0 0 10px rgba(6, 255, 165, 0.2);
        }

        .copilot-chat-send {
            background: linear-gradient(135deg, #8a2be2, #06ffa5);
            color: white;
            border: none;
            padding: 10px 18px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            font-size: 12px;
            transition: all 0.2s;
        }

        .copilot-chat-send:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(6, 255, 165, 0.4);
        }

        /* v5.9: Hotkey hint */
        .copilot-hotkey-hint {
            font-size: 10px;
            color: #666;
            text-align: center;
            padding: 6px 12px 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.05);
        }

        .copilot-hotkey-hint kbd {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            padding: 2px 6px;
            font-family: monospace;
            font-size: 10px;
            color: #06ffa5;
        }

        /* v5.9: Copilot Task System UI - RTS Compact Style */
        .copilot-task-panel {
            position: fixed;
            top: 80px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            border: 1px solid rgba(138, 43, 226, 0.6);
            border-radius: 8px;
            padding: 10px 14px;
            min-width: 180px;
            max-width: 220px;
            z-index: 1000;
            display: none;
            box-shadow: 0 2px 15px rgba(0, 0, 0, 0.4);
        }

        .copilot-task-panel.active {
            display: block;
            animation: task-slide-in 0.2s ease;
        }

        @keyframes task-slide-in {
            from { opacity: 0; transform: translateX(-10px); }
            to { opacity: 1; transform: translateX(0); }
        }

        .copilot-task-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .copilot-task-title {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            color: #06ffa5;
            font-weight: 600;
        }

        .copilot-task-title .task-icon {
            font-size: 18px;
        }

        .copilot-task-recall {
            background: rgba(255, 68, 68, 0.3);
            border: 1px solid #ff4444;
            color: #ff4444;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .copilot-task-recall:hover {
            background: rgba(255, 68, 68, 0.5);
            color: #fff;
        }

        .copilot-task-status {
            font-size: 12px;
            color: #aaa;
            margin-bottom: 8px;
        }

        .copilot-task-progress {
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
            margin-bottom: 8px;
        }

        .copilot-task-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #8a2be2, #06ffa5);
            border-radius: 3px;
            transition: width 0.3s ease;
            box-shadow: 0 0 10px rgba(6, 255, 165, 0.5);
        }

        .copilot-task-progress-bar.hunting {
            background: linear-gradient(90deg, #ff4444, #ff8800);
        }

        .copilot-task-progress-bar.scouting {
            background: linear-gradient(90deg, #4488ff, #44ffff);
        }

        .copilot-task-progress-bar.protecting {
            background: linear-gradient(90deg, #ffcc00, #ff8800);
            animation: protect-pulse 1.5s infinite;
        }

        @keyframes protect-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .copilot-task-results {
            font-size: 11px;
            color: #888;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding-top: 8px;
            margin-top: 4px;
        }

        .copilot-task-results .result-item {
            display: flex;
            align-items: center;
            gap: 6px;
            margin: 3px 0;
        }

        .copilot-task-results .result-item.positive {
            color: #06ffa5;
        }

        /* Task indicator on copilot button */
        .copilot-button.has-task::after {
            content: '';
            position: absolute;
            top: -2px;
            right: -2px;
            width: 12px;
            height: 12px;
            background: #06ffa5;
            border-radius: 50%;
            animation: task-indicator-pulse 1s infinite;
        }

        @keyframes task-indicator-pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.3); opacity: 0.7; }
        }

        /* Copilot visual state when on task */
        .copilot-on-task {
            filter: hue-rotate(60deg);
        }

        /* v5.10: Multi-Agent Fleet System - RTS Style */
        .agent-fleet-panel {
            position: fixed;
            top: 60px;
            right: 0;
            background: rgba(5, 8, 15, 0.95);
            border-left: 2px solid rgba(138, 43, 226, 0.6);
            border-radius: 0;
            width: 280px;
            max-height: calc(100vh - 120px);
            z-index: 1001;
            display: none;
            box-shadow: -4px 0 20px rgba(0, 0, 0, 0.5);
            overflow: hidden;
        }

        .agent-fleet-panel.active {
            display: flex;
            flex-direction: column;
            animation: fleet-slide-in 0.25s ease;
        }

        @keyframes fleet-slide-in {
            from { opacity: 0; transform: translateX(100%); }
            to { opacity: 1; transform: translateX(0); }
        }

        .agent-fleet-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 12px;
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.2), rgba(6, 255, 165, 0.05));
            border-bottom: 1px solid rgba(138, 43, 226, 0.4);
        }

        .agent-fleet-title {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            font-weight: 600;
            color: #fff;
        }

        .agent-fleet-title span.icon {
            font-size: 16px;
        }

        .agent-fleet-count {
            font-size: 10px;
            color: #06ffa5;
            background: rgba(6, 255, 165, 0.12);
            padding: 2px 6px;
            border-radius: 8px;
        }

        .agent-fleet-close {
            background: none;
            border: none;
            color: #666;
            font-size: 16px;
            cursor: pointer;
            padding: 2px;
        }

        .agent-fleet-close:hover {
            color: #ff4444;
        }

        .agent-fleet-spawn {
            padding: 10px 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .agent-spawn-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 6px;
        }

        .agent-spawn-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
            padding: 8px 2px;
            background: rgba(138, 43, 226, 0.15);
            border: 1px solid rgba(138, 43, 226, 0.3);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.15s;
        }

        .agent-spawn-btn:hover:not(:disabled) {
            background: rgba(138, 43, 226, 0.35);
            border-color: #06ffa5;
        }

        .agent-spawn-btn:disabled {
            opacity: 0.35;
            cursor: not-allowed;
        }

        .agent-spawn-btn .icon {
            font-size: 18px;
        }

        .agent-spawn-btn .label {
            font-size: 8px;
            color: #888;
            text-align: center;
        }

        .agent-fleet-list {
            flex: 1;
            overflow-y: auto;
            padding: 6px;
        }

        .agent-card {
            background: rgba(15, 18, 25, 0.9);
            border: 1px solid rgba(138, 43, 226, 0.25);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 6px;
            transition: all 0.15s;
        }

        .agent-card:hover {
            border-color: rgba(6, 255, 165, 0.5);
        }

        .agent-card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 6px;
        }

        .agent-identity {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .agent-avatar {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            position: relative;
        }

        .agent-info {
            display: flex;
            flex-direction: column;
        }

        .agent-name {
            font-size: 11px;
            font-weight: 600;
            color: #fff;
        }

        .agent-role {
            font-size: 9px;
            color: #666;
        }

        .agent-actions {
            display: flex;
            gap: 4px;
        }

        .agent-action-btn {
            width: 22px;
            height: 22px;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            background: rgba(255, 255, 255, 0.05);
            color: #666;
            font-size: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s;
        }

        .agent-action-btn:hover {
            background: rgba(255, 255, 255, 0.12);
            color: #aaa;
        }

        .agent-action-btn.recall {
            border-color: rgba(255, 68, 68, 0.3);
        }

        .agent-action-btn.recall:hover {
            background: rgba(255, 68, 68, 0.25);
            border-color: #ff4444;
            color: #ff4444;
        }

        .agent-card-status {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 6px;
            font-size: 10px;
            color: #888;
        }

        .agent-status-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #06ffa5;
            animation: pulse 1.5s infinite;
        }

        .agent-status-dot.thinking {
            background: #ffaa00;
        }

        .agent-status-dot.idle {
            background: #666;
            animation: none;
        }

        .agent-card-progress {
            height: 3px;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 2px;
            overflow: hidden;
            margin-bottom: 6px;
        }

        .agent-progress-bar {
            height: 100%;
            border-radius: 2px;
            transition: width 0.3s ease;
        }

        .agent-last-msg {
            font-size: 11px;
            color: #666;
            font-style: italic;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .agent-results-mini {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-top: 6px;
        }

        .agent-result-tag {
            font-size: 10px;
            background: rgba(6, 255, 165, 0.15);
            color: #06ffa5;
            padding: 2px 6px;
            border-radius: 8px;
        }

        /* v5.15: Real-time Agent Transcript Viewer */
        .agent-transcript-toggle {
            margin-top: 6px;
            display: flex;
            align-items: center;
            gap: 4px;
            cursor: pointer;
            color: #668;
            font-size: 10px;
            transition: color 0.2s;
        }

        .agent-transcript-toggle:hover {
            color: #0af;
        }

        .agent-transcript-toggle .expand-icon {
            transition: transform 0.2s;
        }

        .agent-transcript-toggle.expanded .expand-icon {
            transform: rotate(90deg);
        }

        .agent-transcript-viewer {
            display: none;
            margin-top: 8px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 6px;
            border: 1px solid rgba(0, 170, 255, 0.2);
            max-height: 300px;
            overflow-y: auto;
        }

        .agent-transcript-viewer.expanded {
            display: block;
        }

        .transcript-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 8px;
            background: rgba(0, 170, 255, 0.1);
            border-bottom: 1px solid rgba(0, 170, 255, 0.2);
            position: sticky;
            top: 0;
            z-index: 1;
        }

        .transcript-header-title {
            font-size: 10px;
            color: #0af;
            font-weight: bold;
        }

        .transcript-message-count {
            font-size: 9px;
            color: #666;
            background: rgba(0, 0, 0, 0.3);
            padding: 2px 6px;
            border-radius: 8px;
        }

        .transcript-messages {
            padding: 6px;
        }

        .transcript-msg {
            padding: 6px 8px;
            margin-bottom: 4px;
            border-radius: 6px;
            font-size: 10px;
            line-height: 1.4;
            word-wrap: break-word;
        }

        .transcript-msg.system {
            background: rgba(128, 128, 128, 0.2);
            border-left: 2px solid #888;
            color: #999;
        }

        .transcript-msg.user {
            background: rgba(0, 170, 255, 0.15);
            border-left: 2px solid #0af;
            color: #8cf;
        }

        .transcript-msg.assistant {
            background: rgba(6, 255, 165, 0.15);
            border-left: 2px solid #06ffa5;
            color: #8fc;
        }

        .transcript-msg-role {
            font-size: 9px;
            font-weight: bold;
            text-transform: uppercase;
            margin-bottom: 2px;
            opacity: 0.7;
        }

        .transcript-msg-content {
            white-space: pre-wrap;
            max-height: 100px;
            overflow-y: auto;
        }

        .transcript-msg-content.truncated {
            max-height: 60px;
        }

        .transcript-empty {
            text-align: center;
            color: #555;
            padding: 20px;
            font-style: italic;
        }

        .transcript-live-indicator {
            display: inline-block;
            width: 6px;
            height: 6px;
            background: #0f0;
            border-radius: 50%;
            margin-left: 4px;
            animation: pulse 1s infinite;
        }

        /* v5.15.2: Try Again Replay System */
        .try-again-btn {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 3px 8px;
            background: rgba(255, 170, 0, 0.2);
            border: 1px solid #ffaa00;
            border-radius: 4px;
            color: #ffaa00;
            font-size: 9px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .try-again-btn:hover {
            background: rgba(255, 170, 0, 0.35);
            box-shadow: 0 0 8px rgba(255, 170, 0, 0.3);
        }

        .try-again-btn.replaying {
            background: rgba(0, 170, 255, 0.2);
            border-color: #0af;
            color: #0af;
            animation: pulse 1s infinite;
        }

        .replay-comparison {
            margin-top: 8px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 6px;
            border: 1px solid rgba(255, 170, 0, 0.3);
        }

        .replay-comparison-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            padding-bottom: 6px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .replay-comparison-title {
            font-size: 10px;
            color: #ffaa00;
            font-weight: bold;
        }

        .replay-branch-indicator {
            font-size: 9px;
            padding: 2px 6px;
            border-radius: 8px;
            background: rgba(255, 68, 68, 0.2);
            color: #f88;
        }

        .replay-branch-indicator.same {
            background: rgba(6, 255, 165, 0.2);
            color: #06ffa5;
        }

        .replay-side-by-side {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .replay-column {
            padding: 6px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }

        .replay-column-label {
            font-size: 9px;
            font-weight: bold;
            margin-bottom: 4px;
            padding-bottom: 4px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .replay-column.original .replay-column-label {
            color: #888;
        }

        .replay-column.retry .replay-column-label {
            color: #0af;
        }

        .replay-content {
            font-size: 9px;
            color: #aaa;
            max-height: 80px;
            overflow-y: auto;
            white-space: pre-wrap;
        }

        .replay-diff {
            background: rgba(255, 255, 0, 0.1);
            border-left: 2px solid #ff0;
        }

        .replay-actions {
            display: flex;
            gap: 6px;
            margin-top: 6px;
        }

        .replay-action-btn {
            flex: 1;
            padding: 4px 8px;
            font-size: 9px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .replay-action-btn.use-original {
            background: rgba(128, 128, 128, 0.2);
            border: 1px solid #888;
            color: #888;
        }

        .replay-action-btn.use-retry {
            background: rgba(0, 170, 255, 0.2);
            border: 1px solid #0af;
            color: #0af;
        }

        .replay-action-btn:hover {
            filter: brightness(1.2);
        }

        /* v5.16.1: Agent Body Cam Preview */
        /* v5.16.2: Agent Takeover / Remote Control System */
        .agent-bodycam-container {
            margin: 8px 0;
            border-radius: 8px;
            overflow: hidden;
            border: 2px solid rgba(0, 170, 255, 0.3);
            background: #000;
            position: relative;
            cursor: pointer;
            transition: all 0.2s;
        }

        .agent-bodycam-container:hover {
            border-color: #0af;
            box-shadow: 0 0 15px rgba(0, 170, 255, 0.3);
        }

        .agent-bodycam-container.expanded-view {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80vw;
            max-width: 900px;
            height: 60vh;
            max-height: 600px;
            z-index: 2000;
            border: 3px solid #0af;
            box-shadow: 0 0 50px rgba(0, 170, 255, 0.5);
            margin: 0;
        }

        .agent-bodycam-canvas {
            width: 100%;
            height: 150px;
            display: block;
            object-fit: cover;
        }

        .agent-bodycam-container.expanded-view .agent-bodycam-canvas {
            height: 100%;
        }

        .agent-bodycam-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 6px 10px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
            display: flex;
            justify-content: space-between;
            align-items: center;
            pointer-events: none;
        }

        .agent-bodycam-label {
            font-size: 10px;
            color: #0af;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .agent-bodycam-label .rec-dot {
            width: 8px;
            height: 8px;
            background: #f00;
            border-radius: 50%;
            animation: pulse 1s infinite;
            box-shadow: 0 0 8px #f00;
        }

        .agent-bodycam-status {
            font-size: 9px;
            color: #888;
            background: rgba(0,0,0,0.5);
            padding: 2px 8px;
            border-radius: 4px;
        }

        /* v5.16.2: Agent HUD overlay */
        .agent-pov-hud {
            position: absolute;
            top: 30px;
            left: 8px;
            right: 8px;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
        }

        .agent-pov-stats {
            background: rgba(0, 0, 0, 0.6);
            padding: 6px 10px;
            border-radius: 6px;
            border: 1px solid rgba(0, 170, 255, 0.3);
        }

        .agent-pov-hp-bar {
            width: 80px;
            height: 8px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 4px;
        }

        .agent-pov-hp-fill {
            height: 100%;
            background: linear-gradient(to right, #0f0, #8f0);
            transition: width 0.3s;
        }

        .agent-pov-hp-fill.low { background: linear-gradient(to right, #ff0, #f80); }
        .agent-pov-hp-fill.critical { background: linear-gradient(to right, #f44, #f00); }

        .agent-pov-hp-text {
            font-size: 8px;
            color: #aaa;
            text-align: center;
        }

        .agent-pov-target {
            background: rgba(255, 68, 68, 0.2);
            border: 1px solid rgba(255, 68, 68, 0.5);
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 9px;
            color: #f88;
        }

        .agent-pov-target.resource {
            background: rgba(255, 200, 0, 0.2);
            border-color: rgba(255, 200, 0, 0.5);
            color: #fc8;
        }

        /* Crosshair */
        .agent-pov-crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
        }

        .agent-pov-crosshair::before,
        .agent-pov-crosshair::after {
            content: '';
            position: absolute;
            background: rgba(0, 255, 255, 0.5);
        }

        .agent-pov-crosshair::before {
            width: 2px;
            height: 100%;
            left: 50%;
            transform: translateX(-50%);
        }

        .agent-pov-crosshair::after {
            width: 100%;
            height: 2px;
            top: 50%;
            transform: translateY(-50%);
        }

        .agent-bodycam-bottom {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 6px 10px;
            background: linear-gradient(to top, rgba(0,0,0,0.8), transparent);
            display: flex;
            justify-content: space-between;
            align-items: center;
            pointer-events: none;
        }

        .agent-bodycam-coords {
            font-size: 10px;
            color: #0f0;
            font-family: monospace;
        }

        .agent-bodycam-action {
            font-size: 10px;
            color: #ff0;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .agent-bodycam-controls {
            position: absolute;
            bottom: 35px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            pointer-events: auto;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .agent-bodycam-container:hover .agent-bodycam-controls {
            opacity: 1;
        }

        .agent-pov-btn {
            padding: 6px 12px;
            font-size: 10px;
            border-radius: 4px;
            border: 1px solid;
            cursor: pointer;
            transition: all 0.2s;
            background: rgba(0, 0, 0, 0.7);
        }

        .agent-pov-btn.locate {
            border-color: #0af;
            color: #0af;
        }

        .agent-pov-btn.takeover {
            border-color: #f80;
            color: #f80;
        }

        .agent-pov-btn.close {
            border-color: #888;
            color: #888;
        }

        /* v5.17.1: Pop-out button style */
        .agent-pov-btn.popout {
            border-color: #a855f7;
            color: #a855f7;
        }

        .agent-pov-btn:hover {
            filter: brightness(1.3);
            transform: scale(1.05);
        }

        .agent-bodycam-click-hint {
            position: absolute;
            bottom: 50%;
            left: 50%;
            transform: translate(-50%, 50%);
            font-size: 10px;
            color: #fff;
            background: rgba(0, 170, 255, 0.8);
            padding: 4px 10px;
            border-radius: 12px;
            opacity: 0;
            transition: opacity 0.2s;
            pointer-events: none;
        }

        .agent-bodycam-container:hover:not(.expanded-view) .agent-bodycam-click-hint {
            opacity: 1;
        }

        /* Fullscreen backdrop */
        .agent-pov-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1999;
        }

        /* v5.16.2: Agent Takeover Flyout Window */
        .agent-takeover-flyout {
            position: fixed;
            top: 60px;
            right: 20px;
            width: 400px;
            height: calc(100vh - 100px);
            max-height: 600px;
            background: linear-gradient(135deg, rgba(10, 20, 40, 0.98), rgba(5, 15, 30, 0.98));
            border: 2px solid #f80;
            border-radius: 12px;
            z-index: 2500;
            display: flex;
            flex-direction: column;
            box-shadow: 0 0 40px rgba(255, 136, 0, 0.4), inset 0 0 60px rgba(255, 136, 0, 0.05);
            overflow: hidden;
            animation: flyoutSlideIn 0.3s ease-out;
        }

        @keyframes flyoutSlideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .takeover-header {
            background: linear-gradient(to bottom, rgba(255, 136, 0, 0.2), rgba(255, 136, 0, 0.05));
            border-bottom: 1px solid rgba(255, 136, 0, 0.3);
            padding: 12px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .takeover-title {
            font-size: 14px;
            font-weight: bold;
            color: #f80;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .takeover-title .agent-icon {
            font-size: 18px;
        }

        .takeover-close-btn {
            background: rgba(255, 68, 68, 0.2);
            border: 1px solid rgba(255, 68, 68, 0.5);
            color: #f88;
            padding: 4px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
        }

        .takeover-close-btn:hover {
            background: rgba(255, 68, 68, 0.4);
            border-color: #f44;
        }

        .takeover-viewport {
            flex: 1;
            position: relative;
            background: #000;
            min-height: 200px;
        }

        .takeover-viewport canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* Takeover HUD Overlay */
        .takeover-hud {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
        }

        .takeover-hud-top {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        .takeover-agent-stats {
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid rgba(255, 136, 0, 0.3);
        }

        .takeover-hp-bar {
            width: 100px;
            height: 10px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .takeover-hp-fill {
            height: 100%;
            background: linear-gradient(to right, #0f0, #8f0);
            transition: width 0.3s;
        }

        .takeover-hp-fill.low { background: linear-gradient(to right, #ff0, #f80); }
        .takeover-hp-fill.critical { background: linear-gradient(to right, #f44, #f00); animation: pulse 0.5s infinite; }

        .takeover-hp-text {
            font-size: 10px;
            color: #0f0;
            text-align: center;
            margin-top: 2px;
        }

        .takeover-agent-info {
            font-size: 10px;
            color: #aaa;
            margin-top: 4px;
        }

        .takeover-target-info {
            background: rgba(255, 68, 68, 0.2);
            border: 1px solid rgba(255, 68, 68, 0.4);
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 10px;
            color: #f88;
        }

        .takeover-target-info.resource {
            background: rgba(0, 255, 0, 0.1);
            border-color: rgba(0, 255, 0, 0.3);
            color: #8f8;
        }

        .takeover-crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 30px;
            height: 30px;
        }

        .takeover-crosshair::before,
        .takeover-crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 136, 0, 0.6);
        }

        .takeover-crosshair::before {
            width: 2px;
            height: 100%;
            left: 50%;
            transform: translateX(-50%);
        }

        .takeover-crosshair::after {
            width: 100%;
            height: 2px;
            top: 50%;
            transform: translateY(-50%);
        }

        .takeover-status-badge {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 136, 0, 0.9);
            color: #000;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: bold;
            text-transform: uppercase;
        }

        /* Takeover Controls Panel */
        .takeover-controls {
            background: rgba(0, 0, 0, 0.6);
            border-top: 1px solid rgba(255, 136, 0, 0.3);
            padding: 10px;
        }

        .takeover-controls-row {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
        }

        .takeover-controls-row:last-child {
            margin-bottom: 0;
        }

        .takeover-control-btn {
            flex: 1;
            padding: 8px 10px;
            font-size: 10px;
            border-radius: 4px;
            border: 1px solid;
            cursor: pointer;
            transition: all 0.2s;
            background: rgba(0, 0, 0, 0.5);
            text-align: center;
        }

        .takeover-control-btn.primary {
            border-color: #f80;
            color: #f80;
        }

        .takeover-control-btn.primary:hover {
            background: rgba(255, 136, 0, 0.2);
        }

        .takeover-control-btn.secondary {
            border-color: #0af;
            color: #0af;
        }

        .takeover-control-btn.secondary:hover {
            background: rgba(0, 170, 255, 0.2);
        }

        .takeover-control-btn.danger {
            border-color: #f44;
            color: #f44;
        }

        .takeover-control-btn.danger:hover {
            background: rgba(255, 68, 68, 0.2);
        }

        .takeover-control-btn.action {
            border-color: #0f0;
            color: #0f0;
        }

        .takeover-control-btn.action:hover {
            background: rgba(0, 255, 0, 0.2);
        }

        .takeover-control-btn:active {
            transform: scale(0.95);
        }

        .takeover-keybind {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            padding: 1px 5px;
            border-radius: 3px;
            font-size: 9px;
            margin-left: 4px;
        }

        /* WASD Indicator */
        .takeover-wasd {
            display: flex;
            justify-content: center;
            gap: 4px;
            flex-wrap: wrap;
            max-width: 90px;
            margin: 0 auto;
        }

        .takeover-wasd-key {
            width: 24px;
            height: 24px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            color: #888;
            transition: all 0.1s;
        }

        .takeover-wasd-key.active {
            background: rgba(255, 136, 0, 0.5);
            border-color: #f80;
            color: #fff;
            box-shadow: 0 0 10px rgba(255, 136, 0, 0.3);
        }

        .takeover-wasd-spacer {
            width: 24px;
            height: 24px;
        }

        /* Active control indicator */
        .takeover-active-indicator {
            position: fixed;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 136, 0, 0.9);
            color: #000;
            padding: 6px 16px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
            z-index: 2600;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 2px 20px rgba(255, 136, 0, 0.5);
        }

        .takeover-active-indicator .pulse {
            width: 8px;
            height: 8px;
            background: #f00;
            border-radius: 50%;
            animation: pulse 1s infinite;
        }

        /* Fleet button - RTS Compact Style */
        .fleet-button {
            width: 44px;
            height: 44px;
            border-radius: 10px;
            background: rgba(20, 30, 50, 0.8);
            border: 2px solid rgba(68, 170, 255, 0.5);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            transition: all 0.2s;
            box-shadow: 0 2px 10px rgba(68, 170, 255, 0.2);
            position: relative;
        }

        .fleet-button:hover {
            transform: scale(1.05);
            border-color: #06ffa5;
            background: rgba(30, 45, 70, 0.9);
        }

        .fleet-button.has-agents {
            border-color: #06ffa5;
            box-shadow: 0 2px 15px rgba(6, 255, 165, 0.3);
        }

        .fleet-button.has-agents::after {
            content: attr(data-count);
            position: absolute;
            top: -6px;
            right: -6px;
            min-width: 16px;
            height: 16px;
            background: #06ffa5;
            color: #000;
            font-size: 10px;
            font-weight: 700;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Agent colors */
        .agent-color-gatherer { color: #44ff88; }
        .agent-color-hunter { color: #ff4444; }
        .agent-color-scout { color: #44aaff; }
        .agent-color-protector { color: #ffcc00; }
        .agent-color-healer { color: #ff88ff; }
        .agent-color-fisher { color: #44ffff; }
        .agent-color-miner { color: #ffaa44; }
        .agent-color-explorer { color: #aa88ff; }
        /* v5.18: Construction agents */
        .agent-color-terraformer { color: #8b4513; }
        .agent-color-builder { color: #00bfff; }

        /* Agent transcript export */
        .agent-action-btn.export {
            border-color: rgba(68, 170, 255, 0.4);
        }

        .agent-action-btn.export:hover {
            background: rgba(68, 170, 255, 0.3);
            border-color: #44aaff;
            color: #44aaff;
        }

        .fleet-export-btn {
            background: rgba(68, 170, 255, 0.2);
            border: 1px solid rgba(68, 170, 255, 0.4);
            color: #44aaff;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
            margin-right: 8px;
        }

        .fleet-export-btn:hover {
            background: rgba(68, 170, 255, 0.4);
            color: #fff;
        }

        .fleet-import-btn {
            background: rgba(106, 255, 165, 0.2);
            border: 1px solid rgba(106, 255, 165, 0.4);
            color: #06ffa5;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .fleet-import-btn:hover {
            background: rgba(106, 255, 165, 0.4);
            color: #fff;
        }

        /* Transcript viewer modal - RTS Style */
        .transcript-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 2000;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .transcript-modal.active {
            display: flex;
            animation: fade-in 0.15s ease;
        }

        .transcript-modal-content {
            background: rgba(10, 12, 20, 0.98);
            border: 1px solid rgba(138, 43, 226, 0.5);
            border-radius: 8px;
            width: 90%;
            max-width: 700px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: 0 8px 40px rgba(0, 0, 0, 0.6);
        }

        .transcript-modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 20px;
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.3), rgba(68, 170, 255, 0.1));
            border-bottom: 1px solid rgba(138, 43, 226, 0.5);
        }

        .transcript-modal-title {
            font-size: 16px;
            font-weight: 600;
            color: #fff;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .transcript-modal-actions {
            display: flex;
            gap: 8px;
        }

        .transcript-action-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #aaa;
            padding: 6px 14px;
            border-radius: 8px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .transcript-action-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
        }

        .transcript-action-btn.primary {
            background: rgba(68, 170, 255, 0.3);
            border-color: #44aaff;
            color: #44aaff;
        }

        .transcript-action-btn.primary:hover {
            background: rgba(68, 170, 255, 0.5);
            color: #fff;
        }

        .transcript-modal-body {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }

        .transcript-json {
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 12px;
            line-height: 1.5;
            background: #0d0d1a;
            border-radius: 8px;
            padding: 16px;
            color: #aaa;
            white-space: pre-wrap;
            word-break: break-word;
            max-height: 60vh;
            overflow-y: auto;
        }

        .transcript-json .key { color: #ff88ff; }
        .transcript-json .string { color: #06ffa5; }
        .transcript-json .number { color: #44aaff; }
        .transcript-json .boolean { color: #ffcc00; }
        .transcript-json .null { color: #888; }

        .transcript-tabs {
            display: flex;
            gap: 4px;
            padding: 12px 16px;
            background: rgba(0, 0, 0, 0.3);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            overflow-x: auto;
        }

        .transcript-tab {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #888;
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 11px;
            cursor: pointer;
            white-space: nowrap;
            transition: all 0.2s;
        }

        .transcript-tab:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #aaa;
        }

        .transcript-tab.active {
            background: rgba(138, 43, 226, 0.3);
            border-color: #8a2be2;
            color: #fff;
        }

        .transcript-agent-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 12px;
            padding: 16px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            margin-bottom: 16px;
        }

        .transcript-info-item {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .transcript-info-label {
            font-size: 10px;
            color: #666;
            text-transform: uppercase;
        }

        .transcript-info-value {
            font-size: 13px;
            color: #fff;
        }

        .copilot-quick-actions {
            display: flex;
            gap: 6px;
            padding: 0 12px 10px;
            flex-wrap: wrap;
        }

        .copilot-quick-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 14px;
            padding: 5px 10px;
            font-size: 11px;
            color: #aaa;
            cursor: pointer;
            transition: all 0.2s;
        }

        .copilot-quick-btn:hover {
            background: rgba(138, 43, 226, 0.3);
            border-color: rgba(138, 43, 226, 0.5);
            color: #fff;
        }

        .copilot-voice-btn {
            background: linear-gradient(135deg, #ff006e, #ff4488);
            border: none;
            width: 38px;
            height: 38px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .copilot-voice-btn:hover {
            transform: scale(1.1);
        }

        .copilot-voice-btn.recording {
            background: linear-gradient(135deg, #ff0000, #ff4444);
            animation: voice-record-pulse 1.5s infinite;
        }

        @keyframes voice-record-pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0.6); }
            70% { box-shadow: 0 0 0 12px rgba(255, 0, 0, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0); }
        }

        .copilot-voice-btn svg {
            width: 18px;
            height: 18px;
            color: white;
        }

        /* v5.9: Real-time transcription overlay */
        .stt-transcription-overlay {
            position: fixed;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #ff006e;
            border-radius: 16px;
            padding: 16px 24px;
            min-width: 300px;
            max-width: 500px;
            z-index: 10001;
            display: none;
            flex-direction: column;
            gap: 12px;
            box-shadow: 0 8px 32px rgba(255, 0, 110, 0.3);
        }

        .stt-transcription-overlay.active {
            display: flex;
        }

        .stt-header {
            display: flex;
            align-items: center;
            gap: 10px;
            color: #ff006e;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stt-header .recording-dot {
            width: 10px;
            height: 10px;
            background: #ff0000;
            border-radius: 50%;
            animation: stt-pulse 1s infinite;
        }

        @keyframes stt-pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(0.8); }
        }

        .stt-waveform {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 3px;
            height: 30px;
        }

        .stt-waveform .bar {
            width: 4px;
            background: linear-gradient(to top, #ff006e, #ff4488);
            border-radius: 2px;
            animation: stt-wave 0.5s ease-in-out infinite;
        }

        .stt-waveform .bar:nth-child(1) { animation-delay: 0s; }
        .stt-waveform .bar:nth-child(2) { animation-delay: 0.1s; }
        .stt-waveform .bar:nth-child(3) { animation-delay: 0.2s; }
        .stt-waveform .bar:nth-child(4) { animation-delay: 0.3s; }
        .stt-waveform .bar:nth-child(5) { animation-delay: 0.4s; }
        .stt-waveform .bar:nth-child(6) { animation-delay: 0.3s; }
        .stt-waveform .bar:nth-child(7) { animation-delay: 0.2s; }

        @keyframes stt-wave {
            0%, 100% { height: 8px; }
            50% { height: 25px; }
        }

        .stt-transcript-text {
            color: #fff;
            font-size: 16px;
            line-height: 1.5;
            min-height: 24px;
            text-align: center;
        }

        .stt-transcript-text.interim {
            color: #aaa;
            font-style: italic;
        }

        .stt-transcript-text.final {
            color: #06ffa5;
        }

        .stt-actions {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .stt-actions button {
            padding: 8px 20px;
            border-radius: 20px;
            border: none;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.2s;
        }

        .stt-actions .stt-send {
            background: linear-gradient(135deg, #06ffa5, #00cc88);
            color: #000;
        }

        .stt-actions .stt-send:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(6, 255, 165, 0.4);
        }

        .stt-actions .stt-cancel {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .stt-actions .stt-cancel:hover {
            background: rgba(255, 0, 0, 0.3);
            border-color: #ff4444;
        }

        .stt-actions .stt-retry {
            background: rgba(255, 0, 110, 0.3);
            color: #ff006e;
            border: 1px solid #ff006e;
        }

        .stt-actions .stt-retry:hover {
            background: rgba(255, 0, 110, 0.5);
        }

        /* v5.9: Auto-send toggle */
        .stt-auto-send {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-top: 4px;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stt-auto-send label {
            font-size: 12px;
            color: #888;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .stt-auto-send input[type="checkbox"] {
            display: none;
        }

        .stt-toggle {
            width: 36px;
            height: 20px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            position: relative;
            transition: all 0.3s;
            cursor: pointer;
        }

        .stt-toggle::after {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            background: #fff;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: all 0.3s;
        }

        .stt-auto-send input[type="checkbox"]:checked + .stt-toggle {
            background: linear-gradient(135deg, #06ffa5, #00cc88);
        }

        .stt-auto-send input[type="checkbox"]:checked + .stt-toggle::after {
            left: 18px;
        }

        .stt-auto-send .auto-label {
            color: #aaa;
            transition: color 0.3s;
        }

        .stt-auto-send input[type="checkbox"]:checked ~ .auto-label {
            color: #06ffa5;
        }

        /* Copilot Companion 3D Indicator */
        .copilot-3d-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.85);
            color: #06ffa5;
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 11px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            white-space: nowrap;
            z-index: 1010;
            border: 1px solid rgba(6, 255, 165, 0.4);
        }

        .copilot-3d-tooltip.visible {
            opacity: 1;
        }

        /* Voice Status Indicator */
        .copilot-voice-indicator {
            position: fixed;
            top: 80px;
            right: 20px;
            background: rgba(138, 43, 226, 0.9);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            display: none;
            align-items: center;
            gap: 8px;
            z-index: 1004;
            font-size: 12px;
            animation: fade-in 0.3s ease;
        }

        .copilot-voice-indicator.active {
            display: flex;
        }

        .copilot-voice-indicator svg {
            width: 16px;
            height: 16px;
            animation: voice-wave 1s infinite;
        }

        @keyframes voice-wave {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        @keyframes fade-in {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @media (max-width: 768px) {
            .copilot-chat-interface {
                width: calc(100% - 40px);
                right: 20px;
                left: 20px;
                height: 350px;
                bottom: 170px;
            }

            .copilot-button {
                width: 55px;
                height: 55px;
                bottom: 95px;
            }
        }
    </style>
</head>
<body>

    <div id="loading" class="loading">
        <div class="loading-text">INITIALIZING OMNIVERSE ENGINE...</div>
        <div class="loading-bar"><div class="loading-progress"></div></div>
    </div>

    <div id="container"></div>

    <div class="ui-layer">
        <!-- Data Controls - Two rows for better organization -->
        <div class="data-controls">
            <!-- Row 1: Game Features -->
            <button onclick="showStatsPanel()">Stats</button>
            <button onclick="openCodexModal()" style="background: linear-gradient(135deg, #ffd700, #ff8c00);">Codex</button>
            <button onclick="openQuestModal()" style="background: linear-gradient(135deg, #ff8c00, #ff4400);">Quests</button>
            <button onclick="openMasteryModal()" style="background: linear-gradient(135deg, #ff44ff, #8844ff);">Mastery</button>
            <button onclick="openPortalModal()" style="background: linear-gradient(135deg, #8844ff, #4488ff);">Portals</button>
            <button onclick="openEvolutionModal()" style="background: linear-gradient(135deg, #aa44ff, #ff44aa);">Evolve</button>
            <button onclick="showSettingsModal()">Settings</button>
            <!-- RAPPID prominently visible -->
            <button onclick="openRappidModal()" style="background: linear-gradient(135deg, #7b2cbf, #3a0ca3); border-color: #7b2cbf; color: #fff;">RAPPID</button>
            <!-- More menu for less used features -->
            <button class="menu-toggle" onclick="toggleSecondaryMenu()" style="background: rgba(255,255,255,0.1); border-color: #fff; color: #fff;">More â–¾</button>
            <!-- Secondary dropdown menu -->
            <div class="menu-secondary" id="menu-secondary">
                <button onclick="openShowcaseModal()" style="background: linear-gradient(135deg, #ffd700, #ffaa00);">Showcase</button>
                <button onclick="quickSave()">Save</button>
                <button onclick="exportData()">Export Game</button>
                <button onclick="document.getElementById('importFile').click()">Import Game</button>
            </div>
            <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importData(event)">
            <input type="file" id="rappidImportFile" accept=".json" style="display: none;" onchange="importRappidSettings(event)">
        </div>

        <div class="hud-top">
            <div>
                <div class="game-title">LEVIATHAN</div>
                <div class="subtitle">GALAXY SIMULATION v5.14</div>
            </div>

            <div id="galaxy-controls" class="stats-box">
                <div class="stat-entry">
                    <span class="stat-val" id="civ-count">0</span>
                    <span class="stat-lbl">Civilizations</span>
                </div>
                <div class="stat-entry">
                    <span class="stat-val" id="cycle-count">0</span>
                    <span class="stat-lbl">Cycle</span>
                </div>
                <div class="stat-entry">
                    <span class="stat-val" id="total-playtime">0:00</span>
                    <span class="stat-lbl">Playtime</span>
                </div>
            </div>

            <div id="world-controls" class="stats-box" style="display:none;">
                <div class="stat-entry">
                    <span class="stat-val" id="world-name">Terra</span>
                    <span class="stat-lbl">Planet</span>
                </div>
                <button class="action-btn" onclick="returnToGalaxy()">LEAVE PLANET</button>
                <!-- v5.5: Autopilot Toggle -->
                <button id="auto-explore-btn" class="action-btn" onclick="toggleAutoExplore()" style="background: #00ff88; color: #000; margin-top: 5px;">Take Manual Control</button>
                <div id="auto-explore-indicator" style="text-align: center; margin-top: 5px; font-size: 12px; color: #00ff88;">ðŸ¤– AUTOPILOT</div>
            </div>
        </div>

        <!-- v5.14: Explorer Robot Integrity Bar (v5.15.2: Improved styling) -->
        <div id="player-health-bar" class="player-health-bar">
            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 6px;">
                <div style="display: flex; align-items: center; gap: 8px;">
                    <span style="font-size: 16px;">ðŸ¤–</span>
                    <span style="font-size: 11px; color: #0ff; letter-spacing: 1px; font-weight: bold;">PROBE INTEGRITY</span>
                </div>
                <span id="health-text" class="player-health-text">100 / 100</span>
            </div>
            <div style="height: 8px; background: rgba(0,0,0,0.5); border-radius: 4px; overflow: hidden;">
                <div id="player-health-fill" class="player-health-fill"></div>
            </div>
            <!-- v5.18: Robot Energy Bar -->
            <div style="display: flex; align-items: center; justify-content: space-between; margin-top: 8px; margin-bottom: 4px;">
                <div style="display: flex; align-items: center; gap: 6px;">
                    <span style="font-size: 12px;">âš¡</span>
                    <span style="font-size: 10px; color: #ffaa00; letter-spacing: 1px; font-weight: bold;">ENERGY</span>
                </div>
                <span id="robot-energy-text" style="font-size: 11px; color: #aaa;">100/100</span>
            </div>
            <div style="height: 6px; background: rgba(0,0,0,0.5); border-radius: 3px; overflow: hidden;">
                <div id="robot-energy-bar" style="width: 100%; height: 100%; background: linear-gradient(90deg, #0088ff, #00aaff); transition: width 0.3s, background 0.3s;"></div>
            </div>
        </div>

        <!-- v5.13: Ship Status Panel (v5.15: Defense Log Added) -->
        <div id="ship-status" style="display: none; position: fixed; top: 80px; left: 10px; z-index: 100;
            background: rgba(10, 20, 30, 0.9); padding: 12px; border-radius: 10px; border: 1px solid #0ff;
            min-width: 200px; max-width: 280px; backdrop-filter: blur(5px);">
            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
                <div style="display: flex; align-items: center; gap: 8px;">
                    <span style="font-size: 20px;">ðŸš€</span>
                    <span style="color: #0ff; font-weight: bold; font-size: 14px;">SHIP STATUS</span>
                </div>
                <button onclick="toggleDefenseLog()" style="background: transparent; border: none; color: #888; cursor: pointer; font-size: 12px;" title="Toggle Defense Log">ðŸ“Š</button>
            </div>
            <div style="margin-bottom: 8px;">
                <div style="display: flex; justify-content: space-between; font-size: 11px; color: #888; margin-bottom: 3px;">
                    <span>Hull Integrity</span>
                    <span id="ship-hp-text">100/100</span>
                </div>
                <div style="height: 8px; background: rgba(0,0,0,0.5); border-radius: 4px; overflow: hidden;">
                    <div id="ship-hp-fill" style="width: 100%; height: 100%; background: #00ff88; transition: width 0.3s, background 0.3s;"></div>
                </div>
            </div>
            <div style="display: flex; gap: 5px;">
                <button id="ship-defense-btn" onclick="toggleShipAutoDefend()" style="flex: 1; padding: 6px 8px; background: rgba(0, 255, 136, 0.2); border: 1px solid #00ff88; color: #00ff88; border-radius: 5px; cursor: pointer; font-size: 11px;">ðŸ›¡ï¸ Defense: ON</button>
                <button onclick="repairShip()" style="padding: 6px 8px; background: rgba(255, 170, 0, 0.2); border: 1px solid #ffaa00; color: #ffaa00; border-radius: 5px; cursor: pointer; font-size: 11px;">ðŸ”§ Repair</button>
            </div>
            <div style="margin-top: 6px; font-size: 10px; color: #666; text-align: center;">
                Laser Range: 35m | DMG: 15
            </div>
            <!-- v5.15: Defense Statistics (collapsible) -->
            <div id="defense-stats" style="display: none; margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(0,255,255,0.2);">
                <div style="font-size: 11px; color: #0ff; margin-bottom: 6px;">ðŸ“Š Defense Statistics</div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px; font-size: 10px;">
                    <div style="color: #888;">Engagements:</div><div id="stat-engagements" style="color: #fff; text-align: right;">0</div>
                    <div style="color: #888;">Kills:</div><div id="stat-kills" style="color: #ff4444; text-align: right;">0</div>
                    <div style="color: #888;">Damage Dealt:</div><div id="stat-damage-dealt" style="color: #ffaa00; text-align: right;">0</div>
                    <div style="color: #888;">Deterred:</div><div id="stat-deterred" style="color: #88ff88; text-align: right;">0</div>
                    <div style="color: #888;">Times Attacked:</div><div id="stat-attacked" style="color: #ff8888; text-align: right;">0</div>
                    <div style="color: #888;">Damage Taken:</div><div id="stat-damage-taken" style="color: #ff6666; text-align: right;">0</div>
                    <div style="color: #888;">Kill Rate:</div><div id="stat-kill-rate" style="color: #88ffff; text-align: right;">0%</div>
                    <div style="color: #888;">Repairs:</div><div id="stat-repairs" style="color: #ffff88; text-align: right;">0</div>
                </div>
                <!-- v5.15: Recent Events Log -->
                <div style="margin-top: 8px;">
                    <div style="font-size: 11px; color: #0ff; margin-bottom: 4px;">ðŸ“œ Recent Events</div>
                    <div id="defense-events-log" style="max-height: 120px; overflow-y: auto; font-size: 9px; background: rgba(0,0,0,0.3); border-radius: 4px; padding: 4px;">
                        <div style="color: #666; text-align: center; padding: 10px;">No events yet</div>
                    </div>
                </div>
            </div>
        </div>

        <div id="tooltip" class="context-tooltip">Target</div>

        <!-- Minimap with Show Mode button -->
        <div id="minimap-container" class="minimap" style="cursor: pointer;">
            <canvas id="minimap-canvas" class="minimap-canvas"></canvas>
            <!-- v5.19: Show Mode button overlay -->
            <div style="position: absolute; top: 4px; right: 4px; z-index: 10;">
                <button onclick="openShowModeModal()" style="background: rgba(0,255,255,0.2); border: 1px solid #0ff; color: #0ff; padding: 3px 6px; border-radius: 4px; font-size: 8px; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.background='rgba(0,255,255,0.4)'" onmouseout="this.style.background='rgba(0,255,255,0.2)'">ðŸ“¡</button>
            </div>
            <!-- P2P Status -->
            <div style="position: absolute; bottom: 2px; left: 0; right: 0; text-align: center; display: flex; justify-content: center; gap: 6px; align-items: center;">
                <span id="p2p-status" style="font-size: 9px; color: #888; text-shadow: 0 0 3px #000;">ðŸ”’ PRIVATE</span>
                <span id="spectator-count" style="font-size: 9px; color: #00ff88; text-shadow: 0 0 3px #000;"></span>
            </div>
        </div>

        <!-- v5.19: Show Mode Modal -->
        <div id="show-mode-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 10001; align-items: center; justify-content: center; backdrop-filter: blur(5px); pointer-events: auto;">
            <div style="background: rgba(20,20,40,0.95); border: 2px solid rgba(0,255,255,0.3); border-radius: 20px; padding: 30px; max-width: 400px; width: 90%; text-align: center; position: relative; box-shadow: 0 0 50px rgba(0,255,255,0.3); pointer-events: auto;">
                <button id="close-show-mode-btn" style="position: absolute; top: 15px; right: 15px; background: none; border: none; font-size: 30px; cursor: pointer; color: #fff; transition: all 0.3s; pointer-events: auto; z-index: 10002;">&times;</button>
                <h3 style="margin: 0 0 20px 0; font-size: 24px; background: linear-gradient(45deg, #00ffff, #0088ff, #06ffa5); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent;">Show Mode</h3>
                <p style="color: rgba(255,255,255,0.7); margin-bottom: 20px;">Share your perspective in real-time. Others can scan the QR code to follow your view.</p>
                <div id="show-mode-info" style="background: rgba(0,255,255,0.1); border: 1px solid rgba(0,255,255,0.3); border-radius: 10px; padding: 10px; margin: 15px 0; font-size: 0.9em; color: #06ffa5;">ðŸŒ Show Mode Active - Viewers will see what you see in real-time!</div>
                <div id="qr-code-container" style="margin: 20px auto; display: flex; justify-content: center; align-items: center; padding: 20px; background: white; border-radius: 15px; min-height: 220px; min-width: 220px;">
                    <!-- QR code canvas/img generated dynamically by generateSpectatorQRCode() -->
                </div>
                <p id="qr-url" style="font-size: 12px; color: rgba(255,255,255,0.7); word-break: break-all; margin: 20px 0; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 8px; font-family: monospace;"></p>
                <button id="copy-url-btn" style="background: linear-gradient(45deg, #00ffff, #0088ff); color: white; border: none; padding: 12px 24px; border-radius: 25px; font-weight: bold; cursor: pointer; transition: all 0.3s ease; text-transform: uppercase; letter-spacing: 1px; pointer-events: auto;">COPY URL</button>
            </div>
        </div>

        <!-- v5.19: Enhanced Spectator Mode Overlay -->
        <div id="spectator-mode" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(135deg, rgba(0,10,30,0.98) 0%, rgba(0,5,15,0.99) 100%); z-index: 9999; overflow-y: auto;">

            <!-- Animated Background Grid -->
            <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-image:
                linear-gradient(rgba(0,255,255,0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0,255,255,0.03) 1px, transparent 1px);
                background-size: 50px 50px; pointer-events: none;"></div>

            <!-- Header Bar -->
            <div style="position: sticky; top: 0; background: linear-gradient(180deg, rgba(0,20,40,0.95) 0%, rgba(0,10,20,0.9) 100%);
                border-bottom: 1px solid rgba(0,255,255,0.2); padding: 12px 20px; display: flex; justify-content: space-between; align-items: center; z-index: 10;">
                <div style="display: flex; align-items: center; gap: 15px;">
                    <div style="width: 12px; height: 12px; background: #f44; border-radius: 50%; animation: pulse-red 1.5s infinite;"></div>
                    <span style="color: #f44; font-size: 12px; font-weight: bold; letter-spacing: 2px;">â— LIVE</span>
                    <span style="color: #0ff; font-size: 14px; font-weight: bold;">SPECTATOR MODE</span>
                </div>
                <div style="display: flex; align-items: center; gap: 20px;">
                    <div style="text-align: right;">
                        <div style="color: #888; font-size: 10px;">WATCHING</div>
                        <div id="spectator-civ" style="color: #fff; font-size: 14px; font-weight: bold;">Unknown</div>
                    </div>
                    <button id="exit-spectator-btn" style="padding: 8px 16px; background: linear-gradient(135deg, #f44, #c00);
                        border: none; color: #fff; font-weight: bold; border-radius: 20px; cursor: pointer; font-size: 12px;
                        transition: all 0.3s; box-shadow: 0 2px 10px rgba(255,68,68,0.3);">EXIT</button>
                </div>
            </div>

            <!-- Main Content Grid -->
            <div style="display: grid; grid-template-columns: 1fr 320px; gap: 20px; padding: 20px; max-width: 1200px; margin: 0 auto;">

                <!-- Left Column: Main View -->
                <div style="display: flex; flex-direction: column; gap: 15px;">

                    <!-- Large Minimap Display -->
                    <div style="background: rgba(0,20,40,0.6); border: 1px solid rgba(0,255,255,0.3); border-radius: 15px; padding: 20px; position: relative;">
                        <div style="position: absolute; top: 15px; left: 20px; display: flex; align-items: center; gap: 8px;">
                            <span style="color: #0ff; font-size: 12px; font-weight: bold;">ðŸ—ºï¸ LIVE MAP</span>
                            <span id="spectator-biome" style="background: rgba(0,255,255,0.2); color: #0ff; padding: 2px 8px; border-radius: 10px; font-size: 10px;">Terra</span>
                        </div>
                        <div style="display: flex; justify-content: center; padding-top: 30px;">
                            <div style="position: relative;">
                                <img id="spectator-minimap" style="width: 280px; height: 280px; border: 2px solid rgba(0,255,255,0.3);
                                    border-radius: 10px; box-shadow: 0 0 30px rgba(0,255,255,0.2);"
                                    src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=" alt="Minimap">
                                <!-- Coordinate Overlay -->
                                <div style="position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%);
                                    background: rgba(0,0,0,0.8); padding: 5px 15px; border-radius: 15px; border: 1px solid #0ff;">
                                    <span id="spectator-coords" style="font-size: 14px; color: #0ff; font-family: monospace; font-weight: bold;">X: 0 Z: 0</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Activity Feed -->
                    <div style="background: rgba(0,20,40,0.6); border: 1px solid rgba(0,255,255,0.3); border-radius: 15px; padding: 15px; flex: 1;">
                        <div style="color: #0ff; font-size: 12px; font-weight: bold; margin-bottom: 10px;">ðŸ“¡ ACTIVITY FEED</div>
                        <div id="spectator-activity" style="font-size: 11px; color: #aaa; max-height: 150px; overflow-y: auto; display: flex; flex-direction: column; gap: 6px;">
                            <div style="color: #666; font-style: italic;">Waiting for activity...</div>
                        </div>
                    </div>
                </div>

                <!-- Right Column: Stats Panel -->
                <div style="display: flex; flex-direction: column; gap: 15px;">

                    <!-- Connection Status -->
                    <div style="background: linear-gradient(135deg, rgba(0,40,60,0.8), rgba(0,20,40,0.8)); border: 1px solid rgba(0,255,255,0.3);
                        border-radius: 15px; padding: 15px; text-align: center;">
                        <div style="display: flex; justify-content: center; align-items: center; gap: 10px; margin-bottom: 8px;">
                            <div id="connection-indicator" style="width: 10px; height: 10px; background: #4f4; border-radius: 50%;
                                box-shadow: 0 0 10px #4f4; animation: pulse-green 2s infinite;"></div>
                            <span style="color: #4f4; font-size: 12px; font-weight: bold;">CONNECTED</span>
                        </div>
                        <div style="color: #666; font-size: 10px;">Stream latency: <span id="spectator-latency" style="color: #0ff;">--</span>ms</div>
                        <div style="color: #666; font-size: 10px; margin-top: 2px;">Version: <span id="spectator-version" style="color: #888;">-</span></div>
                    </div>

                    <!-- Probe Status -->
                    <div style="background: rgba(0,20,40,0.6); border: 1px solid rgba(0,255,255,0.3); border-radius: 15px; padding: 15px;">
                        <div style="color: #0ff; font-size: 12px; font-weight: bold; margin-bottom: 12px;">ðŸ¤– PROBE STATUS</div>

                        <!-- HP -->
                        <div style="margin-bottom: 12px;">
                            <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                                <span style="color: #888; font-size: 10px;">INTEGRITY</span>
                                <span id="spectator-hp-text" style="color: #fff; font-size: 12px; font-weight: bold;">100/100</span>
                            </div>
                            <div style="background: rgba(0,0,0,0.5); border-radius: 6px; overflow: hidden; height: 8px;">
                                <div id="spectator-hp-fill" style="width: 100%; height: 100%; background: linear-gradient(90deg, #f44, #ff8800, #4f4);
                                    transition: width 0.3s ease; box-shadow: 0 0 10px rgba(0,255,0,0.3);"></div>
                            </div>
                        </div>

                        <!-- Energy -->
                        <div>
                            <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                                <span style="color: #888; font-size: 10px;">âš¡ ENERGY</span>
                                <span id="spectator-energy-text" style="color: #0af; font-size: 12px; font-weight: bold;">100/100</span>
                            </div>
                            <div style="background: rgba(0,0,0,0.5); border-radius: 6px; overflow: hidden; height: 8px;">
                                <div id="spectator-energy-fill" style="width: 100%; height: 100%; background: linear-gradient(90deg, #0066cc, #00aaff);
                                    transition: width 0.3s ease; box-shadow: 0 0 10px rgba(0,170,255,0.3);"></div>
                            </div>
                        </div>
                    </div>

                    <!-- Agent Fleet -->
                    <div style="background: rgba(0,20,40,0.6); border: 1px solid rgba(0,255,255,0.3); border-radius: 15px; padding: 15px; flex: 1;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                            <span style="color: #0ff; font-size: 12px; font-weight: bold;">ðŸ›¸ AGENT FLEET</span>
                            <span id="spectator-agent-count" style="background: rgba(0,255,255,0.2); color: #0ff; padding: 2px 8px; border-radius: 10px; font-size: 10px;">0</span>
                        </div>
                        <div id="spectator-agents" style="display: flex; flex-direction: column; gap: 8px; max-height: 200px; overflow-y: auto;">
                            <div style="color: #666; font-size: 11px; font-style: italic; text-align: center; padding: 20px 0;">No agents deployed</div>
                        </div>
                    </div>

                    <!-- Structures -->
                    <div style="background: rgba(0,20,40,0.6); border: 1px solid rgba(0,255,255,0.3); border-radius: 15px; padding: 15px;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <span style="color: #0ff; font-size: 12px; font-weight: bold;">ðŸ—ï¸ STRUCTURES</span>
                            <span id="spectator-structures" style="color: #fff; font-size: 14px; font-weight: bold;">0</span>
                        </div>
                        <div id="spectator-structure-types" style="display: flex; gap: 10px; margin-top: 10px; flex-wrap: wrap;">
                            <!-- Structure type badges will be inserted here -->
                        </div>
                    </div>
                </div>
            </div>

            <!-- Pulse animation keyframes in style -->
            <style>
                @keyframes pulse-red { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
                @keyframes pulse-green { 0%, 100% { box-shadow: 0 0 10px #4f4; } 50% { box-shadow: 0 0 20px #4f4; } }
                #spectator-agents::-webkit-scrollbar { width: 4px; }
                #spectator-agents::-webkit-scrollbar-track { background: rgba(0,0,0,0.3); border-radius: 2px; }
                #spectator-agents::-webkit-scrollbar-thumb { background: #0ff; border-radius: 2px; }
                #spectator-activity::-webkit-scrollbar { width: 4px; }
                #spectator-activity::-webkit-scrollbar-track { background: rgba(0,0,0,0.3); border-radius: 2px; }
                #spectator-activity::-webkit-scrollbar-thumb { background: #0ff; border-radius: 2px; }
                .spectator-agent-card { background: rgba(0,40,60,0.5); border: 1px solid rgba(0,255,255,0.2); border-radius: 8px; padding: 8px 10px; display: flex; align-items: center; gap: 10px; transition: all 0.2s; }
                .spectator-agent-card:hover { background: rgba(0,60,80,0.5); border-color: rgba(0,255,255,0.4); }
                .activity-item { background: rgba(0,0,0,0.3); border-left: 2px solid #0ff; padding: 6px 10px; border-radius: 0 4px 4px 0; }
                .activity-item.warning { border-left-color: #fa0; }
                .activity-item.danger { border-left-color: #f44; }
                .activity-item.success { border-left-color: #4f4; }
                /* Mobile responsive */
                @media (max-width: 900px) {
                    #spectator-mode > div:nth-child(3) { grid-template-columns: 1fr !important; }
                    #spectator-minimap { width: 200px !important; height: 200px !important; }
                }
            </style>
        </div>

        <!-- v5.0: Weather Indicator -->
        <div id="weather-indicator" style="position: fixed; bottom: 325px; right: 10px; display: none; z-index: 100;
            background: rgba(0,0,0,0.7); padding: 8px 12px; border-radius: 8px; border: 1px solid #445;
            font-size: 14px; min-width: 100px; text-align: center;">
            <div style="font-size: 24px; margin-bottom: 4px;" id="weather-icon">â˜€ï¸</div>
            <div id="weather-name" style="color: #aaa; font-size: 12px;">Clear</div>
            <div id="weather-effect" style="color: #666; font-size: 10px; margin-top: 4px;"></div>
        </div>

        <!-- v4.8: Combat Abilities Bar (v4.9: Extended with Tier 2) -->
        <div id="ability-bar" style="position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); display: none; z-index: 100;">
            <div style="display: flex; gap: 8px; background: rgba(0,0,0,0.7); padding: 8px 12px; border-radius: 8px; border: 1px solid #333;">
                <!-- Tier 1 Abilities -->
                <div id="ability-q" class="ability-slot" onclick="useAbility('powerStrike')" title="Power Strike (Q) - 3x damage">
                    <span class="ability-icon">âš”ï¸</span>
                    <span class="ability-key">Q</span>
                    <div class="ability-cooldown" id="cooldown-q"></div>
                </div>
                <div id="ability-e" class="ability-slot" onclick="useAbility('whirlwind')" title="Whirlwind (E) - AoE damage">
                    <span class="ability-icon">ðŸŒ€</span>
                    <span class="ability-key">E</span>
                    <div class="ability-cooldown" id="cooldown-e"></div>
                </div>
                <div id="ability-r" class="ability-slot" onclick="useAbility('warcry')" title="War Cry (R) - +50% damage">
                    <span class="ability-icon">ðŸ“¢</span>
                    <span class="ability-key">R</span>
                    <div class="ability-cooldown" id="cooldown-r"></div>
                </div>
                <!-- v4.9: Tier 2 Abilities -->
                <div style="width: 1px; background: #444; margin: 0 4px;"></div>
                <div id="ability-t" class="ability-slot" onclick="useAbility('heal')" title="Battle Heal (T) - Restore 30% HP">
                    <span class="ability-icon">ðŸ’š</span>
                    <span class="ability-key">T</span>
                    <div class="ability-cooldown" id="cooldown-t"></div>
                </div>
                <div id="ability-f" class="ability-slot" onclick="useAbility('dash')" title="Combat Dash (F) - Dash forward">
                    <span class="ability-icon">ðŸ’¨</span>
                    <span class="ability-key">F</span>
                    <div class="ability-cooldown" id="cooldown-f"></div>
                </div>
                <div id="ability-z" class="ability-slot" onclick="useAbility('shieldWall')" title="Shield Wall (Z) - 70% damage reduction">
                    <span class="ability-icon">ðŸ›¡ï¸</span>
                    <span class="ability-key">Z</span>
                    <div class="ability-cooldown" id="cooldown-z"></div>
                </div>
                <div id="ability-x" class="ability-slot" onclick="useAbility('execute')" title="Execute (X) - 5x damage to low HP">
                    <span class="ability-icon">ðŸ’€</span>
                    <span class="ability-key">X</span>
                    <div class="ability-cooldown" id="cooldown-x"></div>
                </div>
                <div id="ability-c" class="ability-slot" onclick="useAbility('berserk')" title="Berserker Rage (C) - ULTIMATE">
                    <span class="ability-icon">ðŸ”¥</span>
                    <span class="ability-key">C</span>
                    <div class="ability-cooldown" id="cooldown-c"></div>
                </div>
            </div>
        </div>

        <!-- v5.11: RTS-Style Panel System -->
        <div id="rpg-ui" class="rpg-ui">
            <!-- RTS Toggle Buttons - Bottom Left -->
            <div class="rts-panel-toggles" id="rts-panel-toggles">
                <div class="rts-toggle-btn" id="toggle-skills" onclick="toggleRTSPanel('skills')" title="Skills (K)">ðŸ“Š</div>
                <div class="rts-toggle-btn" id="toggle-crafting" onclick="toggleRTSPanel('crafting')" title="Crafting (C)">ðŸ”¨</div>
                <div class="rts-toggle-btn" id="toggle-inventory" onclick="toggleRTSPanel('inventory')" title="Backpack (I)">ðŸŽ’</div>
                <div class="rts-toggle-btn" id="toggle-equipment" onclick="toggleRTSPanel('equipment')" title="Equipment (E)">âš”ï¸</div>
            </div>

            <!-- Skills Panel - Left Edge Dock -->
            <div id="skills-panel" class="player-stats">
                <div class="panel-title"><span>Skills</span><span class="close-panel" onclick="toggleRTSPanel('skills')">Ã—</span></div>
                <div class="xp-bar-container">
                    <div class="xp-label"><span>Mining</span> <span id="lvl-mining">1</span></div>
                    <div class="xp-bar-bg"><div id="bar-mining" class="xp-bar-fill" style="background:#888"></div></div>
                </div>
                <div class="xp-bar-container">
                    <div class="xp-label"><span>Woodcutting</span> <span id="lvl-wood">1</span></div>
                    <div class="xp-bar-bg"><div id="bar-wood" class="xp-bar-fill" style="background:#da5"></div></div>
                </div>
                <div class="xp-bar-container">
                    <div class="xp-label"><span>Combat</span> <span id="lvl-combat">1</span></div>
                    <div class="xp-bar-bg"><div id="bar-combat" class="xp-bar-fill" style="background:#d00"></div></div>
                </div>
                <div class="xp-bar-container">
                    <div class="xp-label"><span>Fishing</span> <span id="lvl-fishing">1</span></div>
                    <div class="xp-bar-bg"><div id="bar-fishing" class="xp-bar-fill" style="background:#44f"></div></div>
                </div>
                <div class="xp-bar-container">
                    <div class="xp-label"><span>Cooking</span> <span id="lvl-cooking">1</span></div>
                    <div class="xp-bar-bg"><div id="bar-cooking" class="xp-bar-fill" style="background:#f80"></div></div>
                </div>
                <div class="xp-bar-container">
                    <div class="xp-label"><span>Crafting</span> <span id="lvl-crafting">1</span></div>
                    <div class="xp-bar-bg"><div id="bar-crafting" class="xp-bar-fill" style="background:#a0f"></div></div>
                </div>
                <button onclick="showTalentModal()" style="width: 100%; margin-top: 6px; padding: 5px; cursor: pointer;
                    background: linear-gradient(135deg, #664, #442); border: 1px solid #ffd700; border-radius: 3px; color: #ffd700; font-size: 9px;">
                    ðŸŒŸ Talents (<span id="talent-points-btn">0</span>)
                </button>
            </div>

            <!-- Crafting Panel - Left Edge Dock -->
            <div id="crafting-panel" class="crafting-panel">
                <div class="panel-title"><span>Crafting</span><span class="close-panel" onclick="toggleRTSPanel('crafting')">Ã—</span></div>
                <button class="craft-btn" id="craft-pickaxe" onclick="craft('pickaxe')">â›ï¸ Pickaxe</button>
                <button class="craft-btn" id="craft-sword" onclick="craft('sword')">âš”ï¸ Sword</button>
                <button class="craft-btn" id="craft-rod" onclick="craft('rod')">ðŸŽ£ Rod</button>
                <button class="craft-btn" id="craft-cookedFish" onclick="craft('cookedFish')">ðŸ³ Cook Fish</button>
                <button class="craft-btn" id="craft-potion" onclick="craft('potion')">ðŸ§ª Potion</button>
                <div style="border-top: 1px solid #333; margin: 4px 0; padding-top: 4px;">
                    <small style="color: #888; font-size: 8px;">Advanced</small>
                </div>
                <button class="craft-btn" id="craft-chitinArmor" onclick="craft('chitinArmor')">Chitin Armor</button>
                <button class="craft-btn" id="craft-frostBlade" onclick="craft('frostBlade')">Frost Blade</button>
                <button class="craft-btn" id="craft-crystalPickaxe" onclick="craft('crystalPickaxe')">Crystal Pick</button>
                <button class="craft-btn" id="craft-magmaSword" onclick="craft('magmaSword')">Magma Sword</button>
                <button class="craft-btn" id="craft-superPotion" onclick="craft('superPotion')">Super Potion</button>
                <button class="craft-btn" id="craft-voidDagger" onclick="craft('voidDagger')">Void Dagger</button>
                <div style="border-top: 1px solid #664400; margin: 4px 0; padding-top: 4px;">
                    <small style="color: #ffd700; font-size: 8px;">âš”ï¸ Legendary</small>
                </div>
                <button class="craft-btn" id="craft-guardianArmor" onclick="craft('guardianArmor')" style="border-color: #664400;">Guardian Armor</button>
                <button class="craft-btn" id="craft-legendaryBlade" onclick="craft('legendaryBlade')" style="border-color: #ffd700;">Legendary Blade</button>
                <div style="border-top: 1px solid #448844; margin: 4px 0; padding-top: 4px;">
                    <small style="color: #88ff88; font-size: 8px;">ðŸ›¡ï¸ Equipment</small>
                </div>
                <button class="craft-btn" id="craft-ironArmor" onclick="craft('ironArmor')" style="border-color: #448844;">Iron Armor</button>
                <button class="craft-btn" id="craft-swiftBoots" onclick="craft('swiftBoots')" style="border-color: #448844;">Swift Boots</button>
                <button class="craft-btn" id="craft-luckyCharm" onclick="craft('luckyCharm')" style="border-color: #448844;">Lucky Charm</button>
                <button class="craft-btn" id="craft-powerRing" onclick="craft('powerRing')" style="border-color: #448844;">Power Ring</button>
                <button class="craft-btn" id="craft-steelArmor" onclick="craft('steelArmor')" style="border-color: #448844;">Steel Armor</button>
                <button class="craft-btn" id="craft-masterRod" onclick="craft('masterRod')" style="border-color: #448844;">Master Rod</button>
            </div>

            <!-- Inventory Panel - Bottom Center -->
            <div id="inventory-panel" class="inventory-panel">
                <div class="panel-title"><span>ðŸŽ’ (<span id="inv-count">0</span>/20)</span><span class="close-panel" onclick="toggleRTSPanel('inventory')">Ã—</span></div>
                <div class="inv-grid" id="inventory-grid"></div>
            </div>

            <!-- Equipment Panel - Bottom Right -->
            <div id="equipment-panel" class="equipment-panel">
                <div class="panel-title"><span>âš”ï¸ Gear</span><span class="close-panel" onclick="toggleRTSPanel('equipment')">Ã—</span></div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px; margin-bottom: 6px;">
                    <div id="equip-slot-weapon" class="equip-slot" onclick="unequipItem('weapon')" title="Weapon">
                        <span class="equip-icon">âš”ï¸</span>
                        <span class="equip-name">Empty</span>
                    </div>
                    <div id="equip-slot-armor" class="equip-slot" onclick="unequipItem('armor')" title="Armor">
                        <span class="equip-icon">ðŸ›¡ï¸</span>
                        <span class="equip-name">Empty</span>
                    </div>
                    <div id="equip-slot-accessory" class="equip-slot" onclick="unequipItem('accessory')" title="Accessory">
                        <span class="equip-icon">ðŸ’</span>
                        <span class="equip-name">Empty</span>
                    </div>
                    <div id="equip-slot-tool" class="equip-slot" onclick="unequipItem('tool')" title="Tool">
                        <span class="equip-icon">ðŸ”§</span>
                        <span class="equip-name">Empty</span>
                    </div>
                </div>
                <div id="equipment-stats" style="font-size: 9px; padding: 4px; background: rgba(0,0,0,0.3); border-radius: 3px;">
                    <div style="color: #f44;">âš”ï¸ +0</div>
                    <div style="color: #4af;">ðŸ›¡ï¸ +0</div>
                </div>
                <button onclick="showEnchantModal()" style="width: 100%; margin-top: 4px; padding: 4px; cursor: pointer;
                    background: linear-gradient(135deg, #448, #226); border: 1px solid #66a; border-radius: 3px; color: #adf; font-size: 8px;">
                    âœ¨ Enchant
                </button>
            </div>
        </div>

        <!-- Touch Controls -->
        <div id="touch-controls" class="touch-controls">
            <div class="touch-btn" id="touch-action">A</div>
        </div>

        <!-- v4.3: Virtual Joystick for Mobile -->
        <div id="virtual-joystick" class="virtual-joystick">
            <div id="joystick-knob" class="joystick-knob"></div>
        </div>
        <div id="touch-action-btn" class="touch-action-btn">ACT</div>
        <div id="touch-dodge-btn" class="touch-dodge-btn">DODGE</div>

    </div>

    <!-- Damage Overlay -->
    <div id="damage-overlay" style="
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        pointer-events: none; z-index: 50;
        background: radial-gradient(transparent 30%, rgba(255,0,0,0.6));
        opacity: 0; transition: opacity 0.1s;
    "></div>

    <!-- v4.9: Berserk Rage Overlay -->
    <div id="berserk-overlay" style="
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        pointer-events: none; z-index: 49;
        background: radial-gradient(transparent 40%, rgba(255,68,0,0.25));
        border: 4px solid rgba(255,68,0,0.5);
        box-shadow: inset 0 0 50px rgba(255,68,0,0.3);
        opacity: 0; transition: opacity 0.3s;
    "></div>

    <!-- v4.9: Shield Wall Overlay -->
    <div id="shield-overlay" style="
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        pointer-events: none; z-index: 49;
        background: radial-gradient(transparent 50%, rgba(68,136,255,0.2));
        border: 4px solid rgba(68,136,255,0.6);
        box-shadow: inset 0 0 40px rgba(68,136,255,0.2);
        opacity: 0; transition: opacity 0.3s;
    "></div>

    <!-- Tutorial Overlay -->
    <div id="tutorial-overlay" class="modal-overlay" style="display: none;">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-title">Welcome to LEVIATHAN</div>
            <div style="color: #aaa; line-height: 1.8; margin-bottom: 20px;">
                <p style="margin-bottom: 15px;"><strong style="color: #0ff;">Galaxy Mode:</strong></p>
                <ul style="margin-left: 20px; margin-bottom: 15px;">
                    <li>Click on star systems to explore planets</li>
                    <li>Visited planets show a green ring</li>
                </ul>
                <p style="margin-bottom: 15px;"><strong style="color: #fb0;">Planet Mode:</strong></p>
                <ul style="margin-left: 20px; margin-bottom: 15px;">
                    <li><strong>Click</strong> to move or interact with objects</li>
                    <li><strong>WASD</strong> keys for movement</li>
                    <li><strong>E</strong> to eat food and heal</li>
                    <li><strong>1-9</strong> to use inventory items</li>
                </ul>
                <p style="margin-bottom: 15px;"><strong style="color: #0f0;">Tips:</strong></p>
                <ul style="margin-left: 20px;">
                    <li>Gather logs and ore to craft tools</li>
                    <li>Tools increase resource yield</li>
                    <li>Green slimes are aggressive!</li>
                    <li>Fish for food, cook it to heal more</li>
                </ul>
            </div>
            <button class="action-btn" onclick="closeTutorial()" style="width: 100%;">START EXPLORING</button>
        </div>
    </div>

    <!-- v5.10: RTS-Style Command Bar (Bottom-Right) -->
    <div class="rts-command-bar">
        <!-- v5.6: Copilot Button -->
        <div id="copilot-button" class="copilot-button" onclick="toggleCopilotChat()" title="AI Companion (V)">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"></path>
            </svg>
        </div>
        <!-- v5.10: Agent Fleet Button -->
        <div id="fleet-button" class="fleet-button" onclick="toggleAgentFleetPanel()" title="Agent Fleet">ðŸ¤–</div>
    </div>

    <!-- Copilot Voice Indicator -->
    <div id="copilot-voice-indicator" class="copilot-voice-indicator">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path>
            <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
        </svg>
        <span>Speaking...</span>
    </div>

    <!-- v5.9: Real-time STT Transcription Overlay -->
    <div id="stt-transcription-overlay" class="stt-transcription-overlay">
        <div class="stt-header">
            <div class="recording-dot"></div>
            <span id="stt-status">Listening...</span>
        </div>
        <div class="stt-waveform" id="stt-waveform">
            <div class="bar"></div>
            <div class="bar"></div>
            <div class="bar"></div>
            <div class="bar"></div>
            <div class="bar"></div>
            <div class="bar"></div>
            <div class="bar"></div>
        </div>
        <div id="stt-transcript-text" class="stt-transcript-text interim">Speak now...</div>
        <div class="stt-actions" id="stt-actions" style="display: none;">
            <button class="stt-cancel" onclick="cancelSTTMessage()">Cancel</button>
            <button class="stt-retry" onclick="retrySTT()">ðŸŽ¤ Retry</button>
            <button class="stt-send" onclick="sendSTTMessage()">Send âœ“</button>
        </div>
        <div class="stt-auto-send">
            <label>
                <input type="checkbox" id="stt-auto-send-toggle" onchange="toggleAutoSend(this.checked)">
                <span class="stt-toggle"></span>
                <span class="auto-label">Auto-send messages</span>
            </label>
        </div>
    </div>

    <!-- Copilot 3D Tooltip -->
    <div id="copilot-3d-tooltip" class="copilot-3d-tooltip">Click to chat</div>

    <!-- Copilot Chat Interface -->
    <div id="copilot-chat-interface" class="copilot-chat-interface">
        <div class="copilot-chat-header">
            <div class="copilot-chat-title">Copilot Companion</div>
            <button class="copilot-close-btn" onclick="toggleCopilotChat()">Ã—</button>
        </div>
        <div class="copilot-quick-actions">
            <button class="copilot-quick-btn" onclick="sendCopilotQuickMessage('What should I do next?')">What next?</button>
            <button class="copilot-quick-btn" onclick="sendCopilotQuickMessage('Give me a tip')">Tips</button>
            <button class="copilot-quick-btn" onclick="sendCopilotQuickMessage('Where are the enemies?')">Enemies</button>
            <button class="copilot-quick-btn" onclick="sendCopilotQuickMessage('How do I get stronger?')">Get Stronger</button>
        </div>
        <div id="copilot-chat-messages" class="copilot-chat-messages">
            <div class="copilot-message ai">Hello, Explorer! I'm your Copilot Companion. I'll follow you on your journey and help with advice. What would you like to know?</div>
        </div>
        <div class="copilot-chat-input-container">
            <input type="text" id="copilot-chat-input" class="copilot-chat-input" placeholder="Ask your Copilot... (Press V for voice)" onkeypress="if(event.key==='Enter') sendCopilotMessage()">
            <button id="copilot-voice-btn" class="copilot-voice-btn" onclick="toggleCopilotVoice()" title="Voice input (Spacebar)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path>
                    <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
                </svg>
            </button>
            <button class="copilot-chat-send" onclick="sendCopilotMessage()">Send</button>
        </div>
        <div class="copilot-hotkey-hint">Press <kbd>V</kbd> to voice chat â€¢ <kbd>Space</kbd> while open to speak â€¢ <kbd>Esc</kbd> to close</div>
    </div>

    <!-- v5.9: Copilot Task Panel -->
    <div id="copilot-task-panel" class="copilot-task-panel">
        <div class="copilot-task-header">
            <div class="copilot-task-title">
                <span class="task-icon" id="task-icon">ðŸ”§</span>
                <span id="task-name">Working...</span>
            </div>
            <button class="copilot-task-recall" onclick="recallCopilot()">Recall</button>
        </div>
        <div class="copilot-task-status" id="task-status">Preparing...</div>
        <div class="copilot-task-progress">
            <div class="copilot-task-progress-bar" id="task-progress-bar" style="width: 0%"></div>
        </div>
        <div class="copilot-task-results" id="task-results" style="display: none;"></div>
    </div>

    <!-- v5.10: Agent Fleet Management Panel -->
    <div id="agent-fleet-panel" class="agent-fleet-panel">
        <div class="agent-fleet-header">
            <div class="agent-fleet-title">
                <span class="icon">ðŸš€</span>
                Agent Fleet
                <span class="agent-fleet-count" id="fleet-count">0/10</span>
            </div>
            <div style="display: flex; align-items: center;">
                <button class="fleet-export-btn" onclick="openTranscriptViewer()" title="View/Export Transcripts">ðŸ“‹ Transcripts</button>
                <button class="agent-fleet-close" onclick="toggleAgentFleetPanel()">Ã—</button>
            </div>
        </div>
        <div class="agent-fleet-spawn">
            <!-- v5.14: Profile selector for spawning agents -->
            <div style="display: flex; gap: 8px; margin-bottom: 10px; align-items: center;">
                <span style="font-size: 11px; color: #888;">Endpoint:</span>
                <select id="agent-spawn-profile" class="ai-select" style="flex: 1; padding: 6px 10px; font-size: 11px; background: rgba(0,0,0,0.4); border: 1px solid rgba(255,255,255,0.2); border-radius: 6px; color: #fff;">
                    <option value="">Default</option>
                    <!-- Options populated dynamically -->
                </select>
            </div>
            <div class="agent-spawn-grid">
                <button class="agent-spawn-btn" onclick="spawnAgentWithProfile('gatherer')" title="Gather resources">
                    <span class="icon">ðŸªµ</span>
                    <span class="label">Gatherer</span>
                </button>
                <button class="agent-spawn-btn" onclick="spawnAgentWithProfile('hunter')" title="Hunt enemies">
                    <span class="icon">âš”ï¸</span>
                    <span class="label">Hunter</span>
                </button>
                <button class="agent-spawn-btn" onclick="spawnAgentWithProfile('scout')" title="Scout area">
                    <span class="icon">ðŸ”</span>
                    <span class="label">Scout</span>
                </button>
                <button class="agent-spawn-btn" onclick="spawnAgentWithProfile('protector')" title="Protect player">
                    <span class="icon">ðŸ›¡ï¸</span>
                    <span class="label">Protector</span>
                </button>
                <button class="agent-spawn-btn" onclick="spawnAgentWithProfile('healer')" title="Heal support">
                    <span class="icon">ðŸ’š</span>
                    <span class="label">Healer</span>
                </button>
                <button class="agent-spawn-btn" onclick="spawnAgentWithProfile('fisher')" title="Fish for food">
                    <span class="icon">ðŸŽ£</span>
                    <span class="label">Fisher</span>
                </button>
                <button class="agent-spawn-btn" onclick="spawnAgentWithProfile('miner')" title="Mine ore">
                    <span class="icon">â›ï¸</span>
                    <span class="label">Miner</span>
                </button>
                <button class="agent-spawn-btn" onclick="spawnAgentWithProfile('explorer')" title="Explore unknown areas">
                    <span class="icon">ðŸ§­</span>
                    <span class="label">Explorer</span>
                </button>
                <!-- v5.18: Construction Agents -->
                <button class="agent-spawn-btn" onclick="spawnAgentWithProfile('terraformer')" title="Flatten terrain for construction">
                    <span class="icon">ðŸšœ</span>
                    <span class="label">Terraformer</span>
                </button>
                <button class="agent-spawn-btn" onclick="spawnAgentWithProfile('builder')" title="Build battery chargers and structures">
                    <span class="icon">ðŸ”§</span>
                    <span class="label">Builder</span>
                </button>
            </div>
        </div>
        <div class="agent-fleet-list" id="agent-fleet-list">
            <div style="color: #666; text-align: center; padding: 20px; font-size: 12px;">
                No agents deployed yet.<br>Click an agent type above to spawn.
            </div>
        </div>
    </div>

    <!-- v5.10: Agent Transcript Viewer Modal -->
    <div id="transcript-modal" class="transcript-modal">
        <div class="transcript-modal-content">
            <div class="transcript-modal-header">
                <div class="transcript-modal-title">
                    <span>ðŸ“‹</span>
                    Agent Transcripts
                </div>
                <div class="transcript-modal-actions">
                    <button class="transcript-action-btn" onclick="copyTranscriptToClipboard()">ðŸ“‹ Copy</button>
                    <button class="transcript-action-btn primary" onclick="downloadCurrentTranscript()">ðŸ’¾ Download</button>
                    <button class="transcript-action-btn" onclick="downloadAllTranscripts()">ðŸ“¦ Export All</button>
                    <button class="transcript-action-btn" onclick="closeTranscriptViewer()">âœ•</button>
                </div>
            </div>
            <div class="transcript-tabs" id="transcript-tabs">
                <!-- Tabs populated dynamically -->
            </div>
            <div class="transcript-modal-body">
                <div class="transcript-agent-info" id="transcript-agent-info">
                    <!-- Agent info populated dynamically -->
                </div>
                <div class="transcript-json" id="transcript-json-view">
                    <!-- JSON content -->
                </div>
            </div>
        </div>
    </div>

    <!-- Hidden file input for import -->
    <input type="file" id="transcript-import-input" accept=".json" style="display: none;" onchange="importTranscriptFile(event)">

    <!-- v5.7: AI Companion Settings Modal - Tabbed Interface -->
    <div id="ai-settings-modal" class="ai-settings-modal">
        <div class="ai-settings-content">
            <div class="ai-settings-header">
                <h2>AI Companion Settings</h2>
                <button class="ai-settings-close" onclick="closeAISettingsModal()">&times;</button>
            </div>

            <!-- Tabs -->
            <div class="ai-settings-tabs">
                <button class="ai-settings-tab active" onclick="switchAITab('general')">General</button>
                <button class="ai-settings-tab" onclick="switchAITab('endpoints')">Endpoints</button>
                <button class="ai-settings-tab" onclick="switchAITab('voice')">Voice</button>
                <button class="ai-settings-tab" onclick="switchAITab('3dview')">3D View</button>
                <button class="ai-settings-tab" onclick="switchAITab('import')">Import/Export</button>
            </div>

            <div class="ai-settings-body">
                <!-- General Tab -->
                <div id="ai-tab-general" class="ai-tab-content active">
                    <div class="ai-section">
                        <h3>API Configuration</h3>
                        <div class="ai-form-group">
                            <label>API Key</label>
                            <input type="password" id="ai-api-key" class="ai-input" placeholder="Enter your API key">
                        </div>
                        <div class="ai-form-group">
                            <label>API Endpoint</label>
                            <input type="text" id="ai-api-endpoint" class="ai-input" placeholder="http://localhost:7071/api/businessinsightbot_function">
                        </div>
                        <div id="ai-endpoints-list"></div>
                    </div>
                    <div class="ai-section">
                        <h3>World Settings</h3>
                        <div class="ai-form-group">
                            <label>Companion Name</label>
                            <input type="text" id="ai-companion-name" class="ai-input" value="Copilot" placeholder="AI Companion">
                        </div>
                        <div class="ai-form-group">
                            <label>Companion Personality</label>
                            <select id="ai-companion-personality" class="ai-select">
                                <option value="helpful">Helpful & Friendly</option>
                                <option value="adventurous">Adventurous Explorer</option>
                                <option value="wise">Wise Sage</option>
                                <option value="playful">Playful Companion</option>
                            </select>
                        </div>
                    </div>
                </div>

                <!-- v5.14: Endpoints Tab - Configure API endpoint profiles for agents -->
                <div id="ai-tab-endpoints" class="ai-tab-content">
                    <div class="ai-section">
                        <h3>Endpoint Profiles</h3>
                        <p style="color: #888; font-size: 12px; margin-bottom: 15px;">
                            Create different endpoint profiles to assign to your agent fleet. Each agent can use a different AI provider.
                        </p>
                        <div id="endpoint-profiles-list" style="max-height: 200px; overflow-y: auto; margin-bottom: 15px;">
                            <!-- Profiles populated dynamically -->
                        </div>
                        <button class="ai-btn ai-btn-save" onclick="showAddProfileForm()" style="width: 100%;">
                            + Add New Endpoint Profile
                        </button>
                    </div>

                    <!-- Add/Edit Profile Form -->
                    <div id="endpoint-profile-form" class="ai-section" style="display: none;">
                        <h3 id="profile-form-title">Add Endpoint Profile</h3>
                        <input type="hidden" id="profile-edit-id">
                        <div class="ai-form-group">
                            <label>Profile Name</label>
                            <input type="text" id="profile-name" class="ai-input" placeholder="e.g., My GPT-4 Endpoint">
                        </div>
                        <div class="ai-form-group">
                            <label>Provider Type</label>
                            <select id="profile-type" class="ai-select" onchange="updateProfileFormFields()">
                                <option value="rappid">RAPPID</option>
                                <option value="openai">OpenAI</option>
                                <option value="anthropic">Anthropic</option>
                                <option value="azure">Azure OpenAI</option>
                                <option value="local">Local LLM (Ollama/LM Studio)</option>
                                <option value="custom">Custom Endpoint</option>
                            </select>
                        </div>
                        <div class="ai-form-group">
                            <label>API Endpoint URL</label>
                            <input type="text" id="profile-url" class="ai-input" placeholder="https://api.openai.com/v1/chat/completions">
                        </div>
                        <div class="ai-form-group">
                            <label>API Key</label>
                            <input type="password" id="profile-api-key" class="ai-input" placeholder="sk-...">
                        </div>
                        <div class="ai-form-group" id="profile-model-group">
                            <label>Model</label>
                            <input type="text" id="profile-model" class="ai-input" placeholder="gpt-4o-mini">
                        </div>
                        <div class="ai-form-group" id="profile-header-group" style="display: none;">
                            <label>Custom Header Name</label>
                            <input type="text" id="profile-header-name" class="ai-input" placeholder="Authorization">
                        </div>
                        <div style="display: flex; gap: 10px; margin-top: 15px;">
                            <button class="ai-btn ai-btn-save" onclick="saveEndpointProfile()" style="flex: 1;">Save Profile</button>
                            <button class="ai-btn ai-btn-cancel" onclick="hideProfileForm()" style="flex: 1;">Cancel</button>
                        </div>
                    </div>

                    <div class="ai-section">
                        <h3>Default Agent Endpoint</h3>
                        <p style="color: #888; font-size: 12px; margin-bottom: 10px;">
                            Select which profile to use for new agents by default.
                        </p>
                        <select id="default-agent-profile" class="ai-select" onchange="setDefaultAgentProfile(this.value)">
                            <option value="">Use Global RAPPID Settings</option>
                            <!-- Options populated dynamically -->
                        </select>
                    </div>

                    <div class="ai-section">
                        <h3>Quick Test</h3>
                        <div style="display: flex; gap: 10px;">
                            <select id="test-profile-select" class="ai-select" style="flex: 1;">
                                <option value="">Select a profile to test...</option>
                            </select>
                            <button class="ai-btn ai-btn-cancel" onclick="testEndpointProfile()" style="width: 80px;">Test</button>
                        </div>
                        <div id="profile-test-result" style="margin-top: 10px; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 8px; font-size: 12px; display: none;"></div>
                    </div>
                </div>

                <!-- Voice Tab -->
                <div id="ai-tab-voice" class="ai-tab-content">
                    <div class="ai-section">
                        <h3>Voice Output</h3>
                        <div class="ai-toggle-row">
                            <span class="ai-toggle-label">Enable Voice Response</span>
                            <label class="ai-toggle">
                                <input type="checkbox" id="ai-voice-enabled" checked>
                                <span class="ai-toggle-slider"></span>
                            </label>
                        </div>
                        <div class="ai-toggle-row">
                            <span class="ai-toggle-label">Auto-speak Responses</span>
                            <label class="ai-toggle">
                                <input type="checkbox" id="ai-auto-speak">
                                <span class="ai-toggle-slider"></span>
                            </label>
                        </div>
                        <div class="ai-form-group">
                            <label>Azure TTS API Key</label>
                            <input type="password" id="ai-tts-key" class="ai-input" placeholder="Enter Azure TTS key for premium voices">
                        </div>
                        <div class="ai-form-group">
                            <label>Azure Region</label>
                            <input type="text" id="ai-tts-region" class="ai-input" placeholder="eastus2">
                        </div>
                        <div class="ai-form-group">
                            <label>TTS Voice</label>
                            <select id="ai-tts-voice" class="ai-select">
                                <option value="en-US-JennyNeural">Jenny (Female)</option>
                                <option value="en-US-GuyNeural">Guy (Male)</option>
                                <option value="en-US-AriaNeural">Aria (Female)</option>
                                <option value="en-US-DavisNeural">Davis (Male)</option>
                                <option value="en-US-AmberNeural">Amber (Female)</option>
                                <option value="en-US-AnaNeural">Ana (Female - Child)</option>
                                <option value="en-US-BrandonNeural">Brandon (Male)</option>
                                <option value="en-US-ChristopherNeural">Christopher (Male)</option>
                                <option value="en-US-CoraNeural">Cora (Female)</option>
                                <option value="en-US-ElizabethNeural">Elizabeth (Female)</option>
                            </select>
                        </div>
                    </div>
                    <div class="ai-section">
                        <h3>Voice Input</h3>
                        <div class="ai-toggle-row">
                            <span class="ai-toggle-label">Enable Voice Input</span>
                            <label class="ai-toggle">
                                <input type="checkbox" id="ai-voice-input-enabled" checked>
                                <span class="ai-toggle-slider"></span>
                            </label>
                        </div>
                        <div class="ai-toggle-row">
                            <span class="ai-toggle-label">Continuous Conversation Mode</span>
                            <label class="ai-toggle">
                                <input type="checkbox" id="ai-continuous-mode">
                                <span class="ai-toggle-slider"></span>
                            </label>
                        </div>
                        <div class="ai-form-group">
                            <label>Push-to-Talk Key</label>
                            <select id="ai-ptt-key" class="ai-select">
                                <option value="Space">Space</option>
                                <option value="KeyV">V</option>
                                <option value="KeyT">T</option>
                                <option value="KeyC">C</option>
                            </select>
                        </div>
                    </div>
                </div>

                <!-- 3D View Tab -->
                <div id="ai-tab-3dview" class="ai-tab-content">
                    <div class="ai-section">
                        <h3>Companion Appearance</h3>
                        <div class="ai-form-group">
                            <label>Primary Color</label>
                            <div class="ai-color-row">
                                <input type="color" id="ai-primary-color" class="ai-color-preview" value="#8a2be2">
                                <input type="text" id="ai-primary-color-hex" class="ai-input ai-color-input" value="#8a2be2">
                            </div>
                        </div>
                        <div class="ai-form-group">
                            <label>Glow Color</label>
                            <div class="ai-color-row">
                                <input type="color" id="ai-glow-color" class="ai-color-preview" value="#06ffa5">
                                <input type="text" id="ai-glow-color-hex" class="ai-input ai-color-input" value="#06ffa5">
                            </div>
                        </div>
                        <div class="ai-form-group">
                            <label>Companion Size</label>
                            <select id="ai-companion-size" class="ai-select">
                                <option value="small">Small</option>
                                <option value="medium" selected>Medium</option>
                                <option value="large">Large</option>
                            </select>
                        </div>
                        <div class="ai-toggle-row">
                            <span class="ai-toggle-label">Show Particles</span>
                            <label class="ai-toggle">
                                <input type="checkbox" id="ai-show-particles" checked>
                                <span class="ai-toggle-slider"></span>
                            </label>
                        </div>
                        <div class="ai-toggle-row">
                            <span class="ai-toggle-label">Enable Glow Effect</span>
                            <label class="ai-toggle">
                                <input type="checkbox" id="ai-enable-glow" checked>
                                <span class="ai-toggle-slider"></span>
                            </label>
                        </div>
                    </div>
                    <div class="ai-section">
                        <h3>Behavior</h3>
                        <div class="ai-form-group">
                            <label>Follow Distance</label>
                            <select id="ai-follow-distance" class="ai-select">
                                <option value="2">Close (2m)</option>
                                <option value="3" selected>Normal (3m)</option>
                                <option value="5">Far (5m)</option>
                            </select>
                        </div>
                        <div class="ai-form-group">
                            <label>Float Height</label>
                            <select id="ai-float-height" class="ai-select">
                                <option value="1.5">Low (1.5m)</option>
                                <option value="2.5" selected>Normal (2.5m)</option>
                                <option value="3.5">High (3.5m)</option>
                            </select>
                        </div>
                    </div>
                </div>

                <!-- Import/Export Tab -->
                <div id="ai-tab-import" class="ai-tab-content">
                    <div class="ai-section">
                        <h3>RAPPID Settings</h3>
                        <p style="color: #888; font-size: 13px; margin-bottom: 15px;">
                            Import your RAPPID configuration file to automatically configure API endpoints and Azure TTS settings.
                        </p>
                        <div id="ai-endpoints-preview"></div>
                        <div style="display: flex; gap: 10px; margin-top: 15px;">
                            <button class="ai-btn ai-btn-import" onclick="document.getElementById('rappidImportFile').click()" style="flex: 1;">
                                Import RAPPID Config
                            </button>
                            <button class="ai-btn ai-btn-cancel" onclick="exportRappidSettings()" style="flex: 1;">
                                Export Settings
                            </button>
                        </div>
                    </div>
                    <div class="ai-section">
                        <h3>Connection Status</h3>
                        <div id="ai-connection-status" style="padding: 15px; background: rgba(0,0,0,0.3); border-radius: 8px; text-align: center;">
                            <span style="color: #888;">No endpoint configured</span>
                        </div>
                        <button class="ai-btn ai-btn-cancel" onclick="testRappidConnection()" style="width: 100%; margin-top: 15px;">
                            Test Connection
                        </button>
                    </div>
                    <div class="ai-section">
                        <h3>Reset</h3>
                        <button class="ai-btn" onclick="clearRappidSettings()" style="width: 100%; background: rgba(255,68,68,0.1); border: 1px solid #f44; color: #f44;">
                            Clear All Settings
                        </button>
                    </div>
                    <div id="ai-status-message" class="ai-status-msg"></div>
                </div>
            </div>

            <div class="ai-settings-footer">
                <button class="ai-btn ai-btn-save" onclick="saveAISettings()">Save Changes</button>
                <button class="ai-btn ai-btn-cancel" onclick="closeAISettingsModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Daily Challenge Box -->
    <div id="daily-challenge" class="daily-challenge-box" style="display: none;">
        <div class="daily-title">Daily Challenge</div>
        <div id="daily-desc" class="daily-desc">Loading...</div>
        <div class="daily-progress-bar">
            <div id="daily-progress-fill" class="daily-progress-fill" style="width: 0%"></div>
        </div>
        <div id="daily-progress-text" class="daily-progress-text">0/0</div>
        <div id="daily-streak" class="daily-streak">Streak: 0 days</div>
    </div>

    <!-- v4.6: Full Settings Panel -->
    <div id="settings-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 380px;">
            <button class="modal-close" onclick="closeSettingsModal()">&times;</button>
            <div class="modal-title">Settings</div>

            <!-- Audio Section -->
            <div class="settings-section">
                <h4 style="color: #0ff;">Audio</h4>
                <div class="setting-row">
                    <span>Master Volume</span>
                    <input type="range" id="volume-slider" min="0" max="100" value="30" oninput="setMasterVolume(this.value)">
                    <span id="volume-display" style="width: 35px; text-align: right;">30%</span>
                </div>
                <div class="setting-row">
                    <span>Sound Effects</span>
                    <button id="sfx-toggle" class="toggle-btn" onclick="toggleSFX()">ON</button>
                </div>
                <div class="setting-row">
                    <span>Ambient Audio</span>
                    <button id="ambient-toggle" class="toggle-btn" onclick="toggleAmbient()">ON</button>
                </div>
            </div>

            <!-- Graphics Section -->
            <div class="settings-section">
                <h4 style="color: #fb0;">Graphics</h4>
                <div class="setting-row">
                    <span>Particle Quality</span>
                    <select id="particle-quality" onchange="setParticleQuality(this.value)">
                        <option value="high">High</option>
                        <option value="medium">Medium</option>
                        <option value="low">Low</option>
                    </select>
                </div>
                <div class="setting-row">
                    <span>Shadows</span>
                    <button id="shadow-toggle" class="toggle-btn" onclick="toggleShadows()">ON</button>
                </div>
                <div class="setting-row">
                    <span>Screen Shake</span>
                    <button id="shake-toggle" class="toggle-btn" onclick="toggleScreenShake()">ON</button>
                </div>
            </div>

            <!-- Game Section -->
            <div class="settings-section">
                <h4 style="color: #0f0;">Game</h4>
                <div class="setting-row">
                    <span>Show Hints</span>
                    <button id="hints-toggle" class="toggle-btn" onclick="toggleHints()">ON</button>
                </div>
                <button class="action-btn" onclick="showTutorial(); closeSettingsModal();" style="width: 100%; margin-top: 10px;">Show Tutorial</button>
            </div>

            <!-- Save Info -->
            <p style="color: #666; font-size: 11px; margin-top: 10px; text-align: center;">
                Last saved: <span id="last-save-time">Never</span>
            </p>
        </div>
    </div>

    <!-- v4.7: Welcome Back Modal -->
    <div id="welcome-back-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 400px; text-align: center;">
            <div class="modal-title" style="color: #ffd700;">Welcome Back!</div>
            <p id="welcome-back-message" style="color: #0ff; font-size: 16px; margin: 15px 0;"></p>
            <p id="welcome-back-time" style="color: #888; font-size: 12px; margin-bottom: 20px;"></p>

            <div id="welcome-back-rewards" style="background: rgba(0,255,255,0.1); border: 1px solid #0ff; border-radius: 8px; padding: 15px; margin-bottom: 20px;">
                <h4 style="color: #0ff; margin: 0 0 10px;">Your Rewards:</h4>
                <div id="welcome-back-rewards-list" style="text-align: left;"></div>
            </div>

            <button class="action-btn" onclick="claimWelcomeBackRewards()" style="width: 100%; padding: 12px; font-size: 16px; background: linear-gradient(135deg, #ffd700, #ff8800);">
                Claim Rewards!
            </button>
        </div>
    </div>

    <!-- Stats Modal -->
    <div id="stats-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 450px; max-height: 80vh; overflow-y: auto;">
            <button class="modal-close" onclick="closeStatsModal()">&times;</button>
            <div class="modal-title">Player Statistics</div>

            <!-- v4.2: Player Rank Section -->
            <div class="stats-section" style="background: linear-gradient(135deg, rgba(255,215,0,0.1), rgba(0,255,255,0.1)); border: 1px solid #ffd700; border-radius: 8px; padding: 12px; margin-bottom: 15px;">
                <h3 style="color: #ffd700; margin: 0 0 10px; font-size: 16px;">Player Rank</h3>
                <div class="stat-row"><span>Current Rank</span><span id="stat-rank" style="font-weight: bold;">Novice Explorer</span></div>
                <div class="stat-row"><span>Total Points</span><span id="stat-points">0</span></div>
                <div style="margin-top: 10px; font-size: 11px; color: #888;">
                    <span style="color: #aaa;">Special Titles: </span><span id="special-titles">None yet</span>
                </div>
            </div>

            <div class="stats-section">
                <h3 style="color: #0ff; margin: 15px 0 10px; font-size: 14px;">Exploration</h3>
                <div class="stat-row"><span>Planets Visited</span><span id="stat-planets">0 / 60</span></div>
                <div class="stat-row"><span>POIs Discovered</span><span id="stat-pois">0</span></div>
                <div class="stat-row"><span>Total Playtime</span><span id="stat-playtime">0h 0m</span></div>
            </div>

            <div class="stats-section">
                <h3 style="color: #fb0; margin: 15px 0 10px; font-size: 14px;">Gathering</h3>
                <div class="stat-row"><span>Trees Chopped</span><span id="stat-trees">0</span></div>
                <div class="stat-row"><span>Ore Mined</span><span id="stat-ore">0</span></div>
                <div class="stat-row"><span>Fish Caught</span><span id="stat-fish">0</span></div>
            </div>

            <div class="stats-section">
                <h3 style="color: #f44; margin: 15px 0 10px; font-size: 14px;">Combat</h3>
                <div class="stat-row"><span>Enemies Defeated</span><span id="stat-mobs">0</span></div>
            </div>

            <div class="stats-section">
                <h3 style="color: #a0f; margin: 15px 0 10px; font-size: 14px;">Crafting</h3>
                <div class="stat-row"><span>Items Crafted</span><span id="stat-crafted">0</span></div>
            </div>

            <div class="stats-section">
                <h3 style="color: #ffd700; margin: 15px 0 10px; font-size: 14px;">Achievements</h3>
                <div id="achievements-list" class="achievements-grid"></div>
            </div>

            <!-- v4.4: Leaderboard Section -->
            <div class="stats-section" style="background: linear-gradient(135deg, rgba(255,100,0,0.1), rgba(255,200,0,0.1)); border: 1px solid #ff8800; border-radius: 8px; padding: 12px; margin-top: 15px;">
                <h3 style="color: #ff8800; margin: 0 0 10px; font-size: 14px;">Leaderboard</h3>
                <div id="leaderboard-list" style="font-size: 12px;"></div>
            </div>

            <!-- v4.4: Prestige Section -->
            <div class="stats-section" style="background: linear-gradient(135deg, rgba(150,0,255,0.1), rgba(0,200,255,0.1)); border: 1px solid #aa44ff; border-radius: 8px; padding: 12px; margin-top: 15px;">
                <h3 style="color: #aa44ff; margin: 0 0 10px; font-size: 14px;">Prestige System</h3>
                <div class="stat-row"><span>Prestige Level</span><span id="prestige-level" style="color: #aa44ff; font-weight: bold;">0</span></div>
                <div class="stat-row"><span>XP Multiplier</span><span id="prestige-xp">x1.0</span></div>
                <div class="stat-row"><span>Lifetime Points</span><span id="prestige-lifetime">0</span></div>
                <div id="prestige-progress" style="margin-top: 10px; font-size: 11px; color: #888;"></div>
                <button id="prestige-btn" onclick="performPrestige()" style="display: none; margin-top: 10px; padding: 8px 16px; background: linear-gradient(135deg, #aa44ff, #6644ff); border: none; border-radius: 4px; color: #fff; cursor: pointer; width: 100%;">PRESTIGE NOW</button>
            </div>
        </div>
    </div>

    <!-- v4.9: Collection Codex Modal -->
    <div id="codex-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 600px; max-height: 85vh; overflow-y: auto;">
            <button class="modal-close" onclick="closeCodexModal()">&times;</button>
            <div class="modal-title" style="color: #ffd700;">Collection Codex</div>

            <!-- Codex Tabs -->
            <div style="display: flex; gap: 5px; margin-bottom: 15px; flex-wrap: wrap;">
                <button class="codex-tab active" data-tab="creatures" onclick="switchCodexTab('creatures')">Creatures</button>
                <button class="codex-tab" data-tab="items" onclick="switchCodexTab('items')">Items</button>
                <button class="codex-tab" data-tab="biomes" onclick="switchCodexTab('biomes')">Biomes</button>
                <button class="codex-tab" data-tab="abilities" onclick="switchCodexTab('abilities')">Abilities</button>
                <button class="codex-tab" data-tab="pets" onclick="switchCodexTab('pets')" style="background: linear-gradient(135deg, rgba(255,136,0,0.3), rgba(255,68,0,0.3));">Pets</button>
            </div>

            <!-- Creatures Tab -->
            <div id="codex-creatures" class="codex-content">
                <div style="color: #aaa; margin-bottom: 10px; font-size: 12px;">
                    Discovered: <span id="codex-creatures-count">0</span> / <span id="codex-creatures-total">0</span>
                </div>
                <div id="codex-creatures-grid" class="codex-grid"></div>
            </div>

            <!-- Items Tab -->
            <div id="codex-items" class="codex-content" style="display: none;">
                <div style="color: #aaa; margin-bottom: 10px; font-size: 12px;">
                    Discovered: <span id="codex-items-count">0</span> / <span id="codex-items-total">0</span>
                </div>
                <div id="codex-items-grid" class="codex-grid"></div>
            </div>

            <!-- Biomes Tab -->
            <div id="codex-biomes" class="codex-content" style="display: none;">
                <div style="color: #aaa; margin-bottom: 10px; font-size: 12px;">
                    Explored: <span id="codex-biomes-count">0</span> / <span id="codex-biomes-total">0</span>
                </div>
                <div id="codex-biomes-grid" class="codex-grid"></div>
            </div>

            <!-- Abilities Tab -->
            <div id="codex-abilities" class="codex-content" style="display: none;">
                <div style="color: #aaa; margin-bottom: 10px; font-size: 12px;">
                    Unlocked: <span id="codex-abilities-count">0</span> / <span id="codex-abilities-total">0</span>
                </div>
                <div id="codex-abilities-grid" class="codex-grid"></div>
            </div>

            <!-- v5.0: Pets Tab -->
            <div id="codex-pets" class="codex-content" style="display: none;">
                <div style="color: #aaa; margin-bottom: 10px; font-size: 12px;">
                    Collected: <span id="codex-pets-count">0</span> / <span id="codex-pets-total">0</span>
                    <span style="margin-left: 15px;">Active: <span id="active-pet-name" style="color: #ff8c00;">None</span></span>
                </div>
                <div id="codex-pets-grid" class="codex-grid"></div>
            </div>
        </div>
    </div>

    <!-- v5.0: Quest System Modal -->
    <div id="quest-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 550px; max-height: 85vh; overflow-y: auto;">
            <button class="modal-close" onclick="closeQuestModal()">&times;</button>
            <div class="modal-title" style="color: #ff8c00;">Quest Board</div>

            <!-- Quest Tabs -->
            <div style="display: flex; gap: 5px; margin-bottom: 15px;">
                <button class="codex-tab active" data-tab="daily" onclick="switchQuestTab('daily')">Daily</button>
                <button class="codex-tab" data-tab="weekly" onclick="switchQuestTab('weekly')">Weekly</button>
                <button class="codex-tab" data-tab="story" onclick="switchQuestTab('story')">Story</button>
            </div>

            <!-- Daily Quests -->
            <div id="quest-daily" class="quest-content">
                <div style="color: #aaa; margin-bottom: 10px; font-size: 12px;">
                    Resets in: <span id="daily-reset-timer" style="color: #ff8c00;">--:--:--</span>
                </div>
                <div id="daily-quests-list" class="quest-list"></div>
            </div>

            <!-- Weekly Quests -->
            <div id="quest-weekly" class="quest-content" style="display: none;">
                <div style="color: #aaa; margin-bottom: 10px; font-size: 12px;">
                    Resets in: <span id="weekly-reset-timer" style="color: #ff8c00;">--:--:--</span>
                </div>
                <div id="weekly-quests-list" class="quest-list"></div>
            </div>

            <!-- Story Quests -->
            <div id="quest-story" class="quest-content" style="display: none;">
                <div style="color: #aaa; margin-bottom: 10px; font-size: 12px;">
                    Progress through the story to unlock rewards!
                </div>
                <div id="story-quests-list" class="quest-list"></div>
            </div>
        </div>
    </div>

    <!-- v5.1: Enchantment Modal -->
    <div id="enchant-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 500px; max-height: 80vh; overflow-y: auto;">
            <button class="modal-close" onclick="closeEnchantModal()">&times;</button>
            <div class="modal-title" style="color: #8af;">âœ¨ Enchanting Table</div>
            <div style="color: #aaa; font-size: 12px; margin-bottom: 15px;">
                Add magical enhancements to your equipped gear!
            </div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                <div>
                    <div style="font-weight: bold; margin-bottom: 8px; color: #fb0;">Your Gear:</div>
                    <div id="enchant-items"></div>
                </div>
                <div>
                    <div style="font-weight: bold; margin-bottom: 8px; color: #fb0;">Enchantments:</div>
                    <div id="enchant-options"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- v5.2: Talent Tree Modal -->
    <div id="talent-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 700px; max-height: 85vh; overflow-y: auto;">
            <button class="modal-close" onclick="closeTalentModal()">&times;</button>
            <div class="modal-title" style="color: #ffd700;">ðŸŒŸ Talent Trees</div>
            <div id="talent-points-display" style="color: #aaa; font-size: 14px; margin-bottom: 15px; text-align: center;">
                Talent Points: 0/0
            </div>
            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px;">
                <div>
                    <div style="text-align: center; font-weight: bold; color: #ff4444; margin-bottom: 10px;">âš”ï¸ Combat</div>
                    <div id="talent-tree-combat"></div>
                </div>
                <div>
                    <div style="text-align: center; font-weight: bold; color: #44aaff; margin-bottom: 10px;">ðŸ›¡ï¸ Survival</div>
                    <div id="talent-tree-survival"></div>
                </div>
                <div>
                    <div style="text-align: center; font-weight: bold; color: #44ff44; margin-bottom: 10px;">ðŸ€ Fortune</div>
                    <div id="talent-tree-fortune"></div>
                </div>
            </div>
            <div style="text-align: center; margin-top: 15px; font-size: 11px; color: #666;">
                Earn 1 talent point per 5 combined skill levels
            </div>
        </div>
    </div>

    <!-- v5.3: Mastery System Modal -->
    <div id="mastery-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 600px; max-height: 85vh; overflow-y: auto;">
            <button class="modal-close" onclick="closeMasteryModal()">&times;</button>
            <div class="modal-title" style="color: #ff44ff;">Skill Mastery</div>
            <div style="color: #aaa; font-size: 12px; margin-bottom: 15px; text-align: center;">
                Reach skill milestones to unlock permanent bonuses!
            </div>
            <div id="mastery-list"></div>
        </div>
    </div>

    <!-- v5.3: Realm Portal Modal -->
    <div id="portal-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 550px; max-height: 85vh; overflow-y: auto;">
            <button class="modal-close" onclick="closePortalModal()">&times;</button>
            <div class="modal-title" style="color: #8844ff;">Realm Portals</div>
            <div style="color: #aaa; font-size: 12px; margin-bottom: 15px; text-align: center;">
                Enter challenging realms for exclusive rewards!
            </div>
            <div id="portal-status" style="text-align: center; margin-bottom: 15px; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 8px;">
                <span style="color: #888;">Current Realm:</span>
                <span id="current-realm" style="color: #ff8844; font-weight: bold; margin-left: 8px;">None</span>
            </div>
            <div id="portal-list"></div>
        </div>
    </div>

    <!-- v5.4: Companion Evolution Modal -->
    <div id="evolution-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 550px; max-height: 85vh; overflow-y: auto;">
            <button class="modal-close" onclick="closeEvolutionModal()">&times;</button>
            <div class="modal-title" style="color: #aa44ff;">Companion Evolution</div>
            <div style="color: #aaa; font-size: 12px; margin-bottom: 15px; text-align: center;">
                Bond with your companions to unlock powerful evolutions!
            </div>
            <div id="evolution-list"></div>
        </div>
    </div>

    <!-- v5.4: Achievement Showcase Modal -->
    <div id="showcase-modal" class="modal-overlay">
        <div class="modal-content" style="max-width: 600px; max-height: 85vh; overflow-y: auto;">
            <button class="modal-close" onclick="closeShowcaseModal()">&times;</button>
            <div class="modal-title" style="color: #ffd700;">Achievement Showcase</div>
            <div class="achievement-points-display">
                <div class="ap-value" id="total-ap">0</div>
                <div class="ap-label">Achievement Points</div>
                <div class="ap-milestone">
                    <div style="display: flex; justify-content: space-between; font-size: 11px;">
                        <span style="color: #aaa;">Next Milestone:</span>
                        <span id="next-milestone-name" style="color: #ffd700;">---</span>
                    </div>
                    <div class="ap-milestone-progress">
                        <div class="ap-milestone-fill" id="milestone-progress" style="width: 0%;"></div>
                    </div>
                </div>
            </div>
            <div style="margin-bottom: 10px; font-size: 12px; color: #888;">
                Active Cosmetic: <span id="active-cosmetic" style="color: #aa44ff;">None</span>
            </div>
            <div id="showcase-badges" class="showcase-grid"></div>
        </div>
    </div>

    <!-- v5.4: World Event Indicator -->
    <div id="event-indicator" class="event-indicator">
        <div class="event-indicator-icon" id="event-ind-icon"></div>
        <div class="event-indicator-name" id="event-ind-name">No Event</div>
        <div class="event-indicator-time" id="event-ind-time">--:--</div>
        <div class="event-indicator-progress">
            <div class="event-indicator-fill" id="event-ind-fill" style="width: 100%;"></div>
        </div>
    </div>

    <!-- v5.5: 3D Ship Landing Mini-Game Overlay -->
    <div id="landing-overlay" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; z-index: 1000;">
        <div id="landing-scene-container" style="width: 100%; height: 100%;"></div>

        <!-- Landing HUD -->
        <div id="landing-info" style="position: absolute; top: 20px; left: 20px; color: white; background: rgba(0,0,0,0.7); padding: 15px; border-radius: 10px; backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.1);">
            <div style="font-size: 18px; font-weight: bold; color: #00ff88; margin-bottom: 10px;" id="landing-planet-name">Landing Sequence</div>
            <div style="margin: 5px 0; font-size: 14px;"><span style="color: #00ff88; font-weight: bold;">Altitude:</span> <span id="landing-altitude">0</span>m</div>
            <div style="margin: 5px 0; font-size: 14px;"><span style="color: #00ff88; font-weight: bold;">Speed:</span> <span id="landing-speed">0</span>m/s</div>
            <div style="margin: 5px 0; font-size: 14px;"><span style="color: #00ff88; font-weight: bold;">Fuel:</span> <span id="landing-fuel">100</span>%</div>
            <div style="margin: 5px 0; font-size: 14px;"><span style="color: #00ff88; font-weight: bold;">Mode:</span> <span id="landing-mode">Autonomous</span></div>
            <div style="margin: 5px 0; font-size: 14px;"><span style="color: #00ff88; font-weight: bold;">Distance:</span> <span id="landing-distance">0</span>m</div>
        </div>

        <!-- Landing Controls -->
        <div id="landing-controls" style="position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); padding: 15px 25px; border-radius: 10px; color: white; display: flex; gap: 20px; align-items: center; backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.1);">
            <button onclick="toggleLandingMode()" id="landing-mode-btn" style="background: #00ff88; border: none; padding: 8px 16px; border-radius: 5px; cursor: pointer; font-weight: bold; color: #000;">Switch to Manual</button>
            <button onclick="abortLanding()" style="background: #ff4444; border: none; padding: 8px 16px; border-radius: 5px; cursor: pointer; font-weight: bold; color: #fff;">Abort Landing</button>
            <div style="color: #888; font-size: 12px;">Manual: Arrow Keys + Space/Shift</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- v5.18: PeerJS for P2P spectator streaming -->
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script>
        // === LEVIATHAN: OMNIVERSE v4.9 ===
        // Enhanced with local-first principles: localStorage persistence & JSON import/export
        // v4.0: Performance optimizations, audio system, particle effects, improved UX
        // v4.1: Achievement system, daily challenges, statistics panel, visual enhancements
        // v4.2: Enemy variety, skill bonuses, POI system, player ranks, combat improvements
        // v4.3: Boss encounters, mobile touch controls, ambient audio, notification queue
        // v4.4: Hit-stop combat, environmental particles, local leaderboard, prestige system, fog of war
        // v4.5: Attack telegraphing, player dodge, recipe discovery, settings panel, boss spawn gates
        // v4.6: Settings persistence, elemental status effects, parry/counter system
        // v4.7: Elite enemy system with affixes, elite gear crafting, session rewards, adaptive performance
        // v4.8: Combo attack system, combat abilities (Q/E/R), ability cooldown UI, item tooltips
        // v4.9: Tier 2 combat abilities (T/F/Z/X/C), visual buff overlays, Collection Codex system
        // v5.0: Quest System (daily/weekly/story), Pet Companions, Weather System
        // v5.1: Equipment System (4 slots), enhanced crafting, enchantment system with 8 enchants
        // v5.2: Talent Tree System (3 trees: Combat/Survival/Fortune, 15 talents)
        // v5.3: Mastery System (skill milestones), Realm Portals (endgame dungeons), Loot Rarity System (item modifiers)
        // v5.4: Companion Evolution System (pets evolve at bond levels), World Events (random spawning events), Achievement Showcase (badges & points)
        // v5.5: Ship Landing Mini-Game (physics-based landing sequence with biome-specific terrain when visiting planets)
        // v5.6: Copilot Companion System (3D AI companion that follows player and provides contextual help)
        // v5.7: RAPPID Integration (AI endpoints, Azure TTS, settings import/export)
        // v5.8: Fixed keyboard input capture when typing in chat, improved API request format
        // v5.9: Updated Azure TTS to use Microsoft Speech SDK for proper voice output
        //       Added Azure STT for microphone input, uses voice_response for TTS
        //       Real-time transcription overlay with auto-send option
        //       Markdown rendering for chat messages with clickable links
        //       Voice hotkeys: V to open chat+voice, Space to speak while chat open, Esc to close
        // v5.10: Multi-Agent Fleet System (spawn up to 10 AI-driven autonomous agents)
        //        Transcript export system for debugging agent conversations
        //        Star Wars-style 3D text crawl for voice responses
        // v5.13: Visible Ship on World Map with Defensive Laser System
        //        Ship HP and damage mechanics - protect your landing zone!
        // v5.14: Endpoint Profiles System for Agent Fleet
        //        Configure multiple API endpoints in RAPPID settings
        //        Assign different endpoint profiles to different agents
        // v5.15: Full Robot Animation System
        //        Hierarchical bone structure for proper joint animations
        //        Idle: breathing, blinking, curious head tilts, antenna sway
        //        Walking/Running: arm swing, leg movement, body bob, forward lean
        //        Action animations: attack, damage, jump/dodge, wave, celebrate
        //        Dynamic eyebrow expressions based on state
        //        Fixed: Agent endpoint key detection and fallback to global RAPPID
        //        Fixed: Better error messages when API key missing or auth fails
        //
        // v5.15.1: Ship Defense Tracking + Real-Time Agent Transcript Viewer
        //        Defense log system tracking engagements, kills, damage dealt
        //        Track incoming attacks, damage taken, entities deterred
        //        Toggleable defense statistics panel in ship status UI
        //        Defense stats included in transcript exports
        //        Real-time expandable transcript viewer in agent cards
        //        Live indicator when agent is thinking/making API calls
        //        Auto-scrolling transcript with message count display
        //
        // v5.15.2: Try Again Replay System + PROBE INTEGRITY UI Fix
        //        Fixed PROBE INTEGRITY health bar styling (cyan border, proper layout)
        //        Health bar now shows critical state animation when HP <= 25%
        //        Try Again button on each assistant response in transcript
        //        Full interaction history stored (request/response/context)
        //        Replay interactions with current game state
        //        Side-by-side comparison of original vs retry responses
        //        Branch off with new response when results differ
        //        Tracks branched interactions for debugging
        //
        // v5.16: Autonomous Agent World Presence System
        //        Distinct mini-robot meshes for each agent type with tools
        //        Gatherers have pickaxe, Hunters have sword, Miners have drill
        //        Healers have medical cross, Scouts have antenna, etc.
        //        Agents physically move on the map doing real tasks
        //        Gatherer/Miner: Find and harvest trees/rocks autonomously
        //        Hunter/Protector: Patrol and attack enemies, avoid bosses
        //        Scout/Explorer: Wide-range exploration, report discoveries
        //        Healer: Follow player/agents and provide healing
        //        Fisher: Find fishing spots and catch fish
        //        Agent alert system with pulsing red indicator
        //        Alerts for: low HP, found boss, agent down, stuck
        //        Troubleshooting UI when player approaches alerted agent
        //        View recent task logs, heal agent, reset task
        //        Agents face movement direction, tools animate when working
        //
        // v5.16.1: Agent Body Cam Preview System
        //        Live body cam view when expanding agent transcript
        //        Camera renders from agent's POV with scan line effect
        //        Vignette overlay for cinematic feel
        //        Shows agent coordinates and current action
        //        Click body cam to locate agent on map
        //        Creates beacon beam at agent location
        //        Sets navigation target to walk to agent
        //        Agents shown on minimap with type-specific colors
        //        Highlighted agents get pulsing ring on minimap
        //        Alerted agents shown in red on minimap
        //
        // v5.16.2: AGENT TAKEOVER / REMOTE CONTROL SYSTEM
        //        Full real-time remote control of any agent
        //        Flyout window with first-person POV rendering
        //        WASD movement controls with visual key indicators
        //        HUD overlay showing HP, target info, status
        //        Crosshair and status badge in viewport
        //        Action button (E) to interact with nearby objects
        //        Attack mobs or harvest resources as agent
        //        Locate button (L) to focus main camera on agent
        //        Auto Mode toggle (M) to switch between manual/autonomous
        //        Return to Robot (ESC) to exit takeover mode
        //
        // v5.16.3: AGENT AUTONOMOUS MODE FIX
        //        Fixed agents not spawning if created before scene was ready
        //        Body cam now shows actual agent POV (was showing black)
        //        Click to Locate now teleports player directly to agent
        //        Agent status shows actual task state from autonomous system
        //        Status displays: Moving, Working, Combat, Idle with coordinates
        //        Agents properly run deterministic tasks based on their type
        //        Active control indicator at top of screen
        //        Agent pauses autonomous behavior during manual control
        //        Smooth restoration of autonomous state on exit
        //
        // v5.17.0: AGENT EXPERIENCE & EFFICIENCY SYSTEM
        //        Complete agent progression system with XP and levels (1-10)
        //        Agents gain XP from successful actions (+5-8 base)
        //        Level up increases efficiency: +10% per level (max 200%)
        //        Efficiency affects action success rate (40% base â†’ up to 95%)
        //        Higher level agents find better resources and deal more damage
        //        COMBO SYSTEM for consecutive successful actions:
        //          - Each success increases combo counter
        //          - Combo adds +1 XP per level (max +10 bonus)
        //          - Combo adds +2% success rate per level (max +20%)
        //          - Milestone effects at 5x, 10x, 25x, 50x combos
        //          - Failure resets combo (warns if lost significant combo)
        //        PARTICLE EFFECTS for agent actions:
        //          - Gold particles on level up (20 particles, 1.5s)
        //          - Orange particles on combo milestones (12 particles)
        //          - Type-colored particles on successful actions
        //          - Green particles on healing (agent regen)
        //        AGENT HEALTH REGENERATION:
        //          - Passive regen every 5 seconds
        //          - Base: 2 HP + 1 HP per agent level
        //          - Heal particles when significant regen occurs
        //        ENHANCED MINIMAP INDICATORS:
        //          - Agent size scales with level (2-4px)
        //          - Combo aura ring when combo >= 5
        //          - Pulsing glow when working
        //          - Red flash when in combat
        //        AGENT CARD UI IMPROVEMENTS:
        //          - Shows agent level with color coding
        //          - Shows XP progress percentage
        //          - Shows current combo with fire emoji
        //          - Shows efficiency percentage
        //        SCALING REWARDS BY LEVEL:
        //          - Gatherers: +1 item per 3 levels
        //          - Hunters: +2 XP and +1 gold per level
        //          - Healers: +2 HP healed per level
        //          - Protectors: +2 damage per level
        //          - Miners: unlock Silver/Gold/Crystal at levels 3/5/7
        //          - Fishers: unlock Large/Golden Fish at levels 3/5
        //        AGENT SYNERGY SYSTEM:
        //          - Agents near each other (within 15 units) get synergy bonus
        //          - +5% success rate per nearby agent (max +15%)
        //          - Encourages strategic agent positioning
        //        BODY CAM HUD OVERLAY:
        //          - Shows agent level badge (top-left)
        //          - Shows combo counter when active (top-right)
        //          - Efficiency progress bar (bottom-left)
        //        RECALL SUMMARY IMPROVEMENTS:
        //          - Shows agent's final level
        //          - Shows best combo achieved
        //          - Shows success rate percentage
        //          - Shows total actions performed
        //
        // v5.17.1: POP-OUT AGENT CONTROL WINDOWS
        //        Independent agent control in separate browser windows
        //        Main game continues uninterrupted while controlling agents
        //        Each pop-out window features:
        //          - Live first-person POV rendering from agent's perspective
        //          - Real-time HUD with HP, Level, Combo, Efficiency stats
        //          - WASD movement controls with visual key feedback
        //          - Action button (E) to interact with nearby objects/enemies
        //          - Locate button (L) to focus main camera on agent
        //          - Auto/Manual mode toggle (M key or click switch)
        //          - Scan line effect for cinematic body cam feel
        //          - Automatic manual mode activation on key press
        //          - Graceful handling when agent is recalled or main window closes
        //        Multiple agents can have pop-out windows simultaneously
        //        Window positions cascade to avoid overlap
        //        Purple "POP OUT" button added to body cam controls
        //
        // v5.18.0: RTS CONSTRUCTION & ENERGY SYSTEM
        //        Preparing for human colonization - build infrastructure!
        //        NEW AGENT TYPES:
        //          - Terraformer ðŸšœ: Flattens terrain for optimal construction
        //          - Builder ðŸ”§: Constructs battery chargers and structures
        //        TERRAFORMING SYSTEM:
        //          - Agents analyze 3x3 terrain patches for height variance
        //          - Flatten uneven terrain to average height
        //          - Terraformed areas tracked for construction bonuses
        //          - Agents auto-relocate when area is already flat
        //        BATTERY CHARGER STRUCTURES:
        //          - Builders construct charging stations for robots
        //          - Efficiency based on terrain: 100% on flat, 60-80% on uneven
        //          - Visual design: base platform, pillar, energy ring, beacon
        //          - Color-coded by efficiency (green/yellow/red)
        //          - Animated rings and pulsing beacons
        //          - Point lights for atmospheric glow
        //        ROBOT ENERGY SYSTEM:
        //          - Energy bar added to PROBE INTEGRITY display
        //          - Energy drains slowly when moving
        //          - Stand near battery chargers to recharge
        //          - Charge rate scales with charger efficiency
        //          - Visual feedback: bar color and âš¡ indicator
        //        STRUCTURE SYSTEM:
        //          - worldState.structures array for all built objects
        //          - worldState.terraformedAreas tracks flattened zones
        //          - Structures animate in game loop (rings spin, beacons pulse)
        //        P2P SPECTATOR STREAMING via PeerJS:
        //          - Click minimap to toggle QR code view
        //          - QR code contains spectator URL with peer ID
        //          - Others scan QR to watch your exploration live
        //          - Real-time streaming: HP, energy, position, agents, structures
        //          - Minimap image streamed at 10 FPS
        //          - Multiple spectators supported simultaneously
        //          - Spectator mode UI shows all game stats
        //          - Auto-detect spectate param in URL
        //          - Host/spectator connection management
        //
        // v5.19.0: SHOW MODE - SCANNABLE QR CODE SHARING
        //        Beautiful modal matching index_slim_cloud_tools.html pattern
        //        UI DESIGN:
        //          - Fullscreen modal with backdrop blur
        //          - Gradient "Show Mode" title (cyan â†’ blue â†’ green)
        //          - Status info banner with glow effect
        //          - Large scannable QR code (200x200) on white background
        //          - Full URL display in monospace font
        //          - Gradient "COPY URL" button with hover effects
        //          - Animated Ã— close button (rotates on hover)
        //        QR CODE GENERATOR:
        //          - Primary: QRious library (cdnjs.cloudflare.com)
        //          - Fallback: QR Server API (api.qrserver.com)
        //          - High error correction (Level H) for reliable scanning
        //          - Phone camera scans QR â†’ opens browser â†’ auto-joins spectator
        //        MINIMAP INTEGRATION:
        //          - Small ðŸ“¡ button in top-right corner of minimap
        //          - Opens Show Mode modal on click
        //
        // v5.20.0: SIMPLIFIED SPECTATOR STREAMING
        //        Clean real-time camera sync like index_slim_cloud_tools.html
        //        CAMERA SYNC:
        //          - Spectators see host's exact 3D view with smooth lerp interpolation
        //          - Camera position and rotation synced at 10 FPS
        //          - Game state broadcast every frame with camera, player, stats
        //        STREAM CONTROLS:
        //          - â¸ï¸ PAUSE / â–¶ï¸ RESUME button to freeze/unfreeze camera sync
        //          - EXIT button to leave spectator mode
        //          - Live latency display in banner
        //        SPECTATOR BANNER:
        //          - Red banner at top: "ðŸ‘ï¸ SPECTATOR MODE - Following: Host"
        //          - Shows connection latency
        //          - Pause/Resume and Exit buttons

        const APP_NAME = 'leviathan-omniverse';
        const VERSION = '5.20.0';

        // ============================================
        // THREE.js Extensions: FontLoader & TextGeometry
        // Required for 3D text rendering
        // ============================================
        THREE.FontLoader = class FontLoader extends THREE.Loader {
            constructor(manager) {
                super(manager);
            }

            load(url, onLoad, onProgress, onError) {
                const scope = this;
                const loader = new THREE.FileLoader(this.manager);
                loader.setPath(this.path);
                loader.setRequestHeader(this.requestHeader);
                loader.setWithCredentials(this.withCredentials);
                loader.load(url, function(text) {
                    try {
                        const json = JSON.parse(text);
                        const font = scope.parse(json);
                        if (onLoad) onLoad(font);
                    } catch (e) {
                        if (onError) onError(e);
                    }
                }, onProgress, onError);
            }

            parse(json) {
                return new THREE.Font(json);
            }
        };

        THREE.Font = class Font {
            constructor(data) {
                this.type = 'Font';
                this.data = data;
            }

            generateShapes(text, size = 100) {
                const shapes = [];
                const paths = createFontPaths(text, size, this.data);
                for (let p = 0, pl = paths.length; p < pl; p++) {
                    Array.prototype.push.apply(shapes, paths[p].toShapes());
                }
                return shapes;
            }
        };

        THREE.TextGeometry = class TextGeometry extends THREE.ExtrudeGeometry {
            constructor(text, parameters = {}) {
                const font = parameters.font;
                if (!font || !font.data) {
                    console.error('THREE.TextGeometry: font parameter is not an instance of THREE.Font.');
                    super();
                    return;
                }
                const shapes = font.generateShapes(text, parameters.size);
                parameters.depth = parameters.height !== undefined ? parameters.height : 50;
                if (parameters.bevelThickness === undefined) parameters.bevelThickness = 10;
                if (parameters.bevelSize === undefined) parameters.bevelSize = 8;
                if (parameters.bevelEnabled === undefined) parameters.bevelEnabled = false;
                super(shapes, parameters);
                this.type = 'TextGeometry';
            }
        };

        function createFontPaths(text, size, data) {
            const chars = Array.from(text);
            const scale = size / data.resolution;
            const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;
            const paths = [];
            let offsetX = 0, offsetY = 0;

            for (let i = 0; i < chars.length; i++) {
                const char = chars[i];
                if (char === '\n') {
                    offsetX = 0;
                    offsetY -= line_height;
                } else {
                    const ret = createFontPath(char, scale, offsetX, offsetY, data);
                    if (ret) {
                        offsetX += ret.offsetX;
                        paths.push(ret.path);
                    }
                }
            }
            return paths;
        }

        function createFontPath(char, scale, offsetX, offsetY, data) {
            const glyph = data.glyphs[char] || data.glyphs['?'];
            if (!glyph) {
                console.error('THREE.Font: character "' + char + '" does not exist in font.');
                return;
            }
            const path = new THREE.ShapePath();
            let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;

            if (glyph.o) {
                const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '));
                for (let i = 0, l = outline.length; i < l;) {
                    const action = outline[i++];
                    switch (action) {
                        case 'm':
                            x = outline[i++] * scale + offsetX;
                            y = outline[i++] * scale + offsetY;
                            path.moveTo(x, y);
                            break;
                        case 'l':
                            x = outline[i++] * scale + offsetX;
                            y = outline[i++] * scale + offsetY;
                            path.lineTo(x, y);
                            break;
                        case 'q':
                            cpx = outline[i++] * scale + offsetX;
                            cpy = outline[i++] * scale + offsetY;
                            cpx1 = outline[i++] * scale + offsetX;
                            cpy1 = outline[i++] * scale + offsetY;
                            path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
                            break;
                        case 'b':
                            cpx = outline[i++] * scale + offsetX;
                            cpy = outline[i++] * scale + offsetY;
                            cpx1 = outline[i++] * scale + offsetX;
                            cpy1 = outline[i++] * scale + offsetY;
                            cpx2 = outline[i++] * scale + offsetX;
                            cpy2 = outline[i++] * scale + offsetY;
                            path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
                            break;
                    }
                }
            }
            return { offsetX: glyph.ha * scale, path: path };
        }

        // --- AUDIO SYSTEM (Web Audio API - No external dependencies) ---
        const AudioSystem = {
            ctx: null,
            enabled: true,
            masterVolume: 0.3,

            init() {
                try {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.warn('Web Audio API not supported');
                    this.enabled = false;
                }
            },

            resume() {
                if (this.ctx && this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
            },

            playTone(freq, duration, type = 'sine', volume = 1) {
                if (!this.enabled || !this.ctx) return;
                this.resume();

                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.value = freq;
                gain.gain.setValueAtTime(this.masterVolume * volume, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                osc.connect(gain).connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            },

            hit() { this.playTone(200, 0.08, 'square', 0.5); },
            collect() { this.playTone(600, 0.12, 'sine', 0.6); },
            damage() { this.playTone(80, 0.15, 'sawtooth', 0.7); },
            kill() {
                this.playTone(150, 0.1, 'square', 0.5);
                setTimeout(() => this.playTone(100, 0.15, 'square', 0.4), 50);
            },
            // v4.7: Explosion sound for explosive elite death
            explosion() {
                this.playTone(80, 0.3, 'sawtooth', 0.6);
                setTimeout(() => this.playTone(60, 0.2, 'sawtooth', 0.4), 50);
                setTimeout(() => this.playTone(40, 0.15, 'square', 0.3), 100);
            },
            levelUp() {
                [400, 500, 600, 800].forEach((f, i) => {
                    setTimeout(() => this.playTone(f, 0.15, 'sine', 0.5), i * 80);
                });
            },
            craft() { this.playTone(440, 0.1, 'triangle', 0.4); },
            click() { this.playTone(800, 0.03, 'sine', 0.2); },
            error() { this.playTone(100, 0.2, 'sawtooth', 0.3); },
            heal() { this.playTone(520, 0.2, 'sine', 0.4); },
            // v4.5: Dodge and telegraph sounds
            dodge() { this.playTone(300, 0.08, 'sine', 0.4); this.playTone(450, 0.06, 'sine', 0.3); },
            telegraph() { this.playTone(150, 0.1, 'square', 0.25); },

            // v4.3: Ambient Audio System
            ambientNode: null,
            ambientGain: null,
            currentBiome: null,

            // Biome-specific ambient audio configurations
            biomeAmbient: {
                Terra: { baseFreq: 80, modFreq: 0.3, type: 'sine', volume: 0.08 },
                Desert: { baseFreq: 120, modFreq: 0.1, type: 'sine', volume: 0.06 },
                Ice: { baseFreq: 200, modFreq: 0.5, type: 'sine', volume: 0.07 },
                Volcanic: { baseFreq: 60, modFreq: 0.2, type: 'triangle', volume: 0.09 },
                Alien: { baseFreq: 150, modFreq: 0.8, type: 'sawtooth', volume: 0.05 }
            },

            startAmbient(biome) {
                if (!this.enabled || !this.ctx || this.currentBiome === biome) return;
                this.stopAmbient();
                this.currentBiome = biome;
                this.resume();

                const config = this.biomeAmbient[biome] || this.biomeAmbient.Terra;

                // Create ambient drone
                this.ambientNode = this.ctx.createOscillator();
                this.ambientGain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();

                // LFO for subtle modulation
                const lfo = this.ctx.createOscillator();
                const lfoGain = this.ctx.createGain();
                lfo.frequency.value = config.modFreq;
                lfoGain.gain.value = config.baseFreq * 0.1;
                lfo.connect(lfoGain);
                lfoGain.connect(this.ambientNode.frequency);
                lfo.start();

                this.ambientNode.type = config.type;
                this.ambientNode.frequency.value = config.baseFreq;

                filter.type = 'lowpass';
                filter.frequency.value = 300;
                filter.Q.value = 1;

                this.ambientGain.gain.value = config.volume * this.masterVolume;

                this.ambientNode.connect(filter);
                filter.connect(this.ambientGain);
                this.ambientGain.connect(this.ctx.destination);
                this.ambientNode.start();

                // Store LFO for cleanup
                this.ambientLfo = lfo;
                this.ambientLfoGain = lfoGain;
            },

            stopAmbient() {
                if (this.ambientNode) {
                    try {
                        this.ambientNode.stop();
                        this.ambientNode.disconnect();
                        if (this.ambientLfo) {
                            this.ambientLfo.stop();
                            this.ambientLfo.disconnect();
                        }
                    } catch (e) {}
                    this.ambientNode = null;
                    this.ambientLfo = null;
                    this.currentBiome = null;
                }
            },

            bossSpawn() {
                // Dramatic boss spawn sound
                [100, 80, 60, 40].forEach((f, i) => {
                    setTimeout(() => this.playTone(f, 0.3, 'sawtooth', 0.6), i * 100);
                });
            },

            // v4.5: Dodge and telegraph sounds
            dodge() {
                this.playTone(400, 0.08, 'sine', 0.3);
                this.playTone(600, 0.06, 'sine', 0.2);
            },
            telegraph() {
                this.playTone(200, 0.15, 'square', 0.2);
            },
            recipeDiscovered() {
                [600, 800, 1000].forEach((f, i) => {
                    setTimeout(() => this.playTone(f, 0.12, 'triangle', 0.4), i * 60);
                });
            }
        };

        // --- PARTICLE SYSTEM ---
        class ParticleSystem {
            constructor() {
                this.particles = [];
                this.maxParticles = 200;
            }

            emit(position, count, color, options = {}) {
                const spread = options.spread || 3;
                const lifetime = options.lifetime || 1000;
                const size = options.size || 0.2;
                const gravity = options.gravity !== undefined ? options.gravity : 10;

                for (let i = 0; i < count && this.particles.length < this.maxParticles; i++) {
                    const particle = {
                        mesh: new THREE.Mesh(
                            new THREE.SphereGeometry(size, 4, 4),
                            new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 1 })
                        ),
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * spread,
                            Math.random() * spread * 0.8 + spread * 0.2,
                            (Math.random() - 0.5) * spread
                        ),
                        lifetime,
                        startTime: performance.now(),
                        gravity
                    };
                    particle.mesh.position.copy(position);
                    particle.mesh.position.y += 1;
                    scene.add(particle.mesh);
                    this.particles.push(particle);
                }
            }

            update(dt) {
                const now = performance.now();
                this.particles = this.particles.filter(p => {
                    const elapsed = now - p.startTime;
                    const progress = elapsed / p.lifetime;

                    if (progress >= 1) {
                        scene.remove(p.mesh);
                        p.mesh.geometry.dispose();
                        p.mesh.material.dispose();
                        return false;
                    }

                    // Physics
                    p.velocity.y -= p.gravity * dt;
                    p.mesh.position.add(p.velocity.clone().multiplyScalar(dt));
                    p.mesh.material.opacity = 1 - progress;
                    p.mesh.scale.setScalar(1 - progress * 0.5);

                    return true;
                });
            }
        }

        let particles;

        // v4.4: Hit-Stop System - Freezes game briefly on impacts for satisfying combat
        let hitStopUntil = 0;
        const HIT_STOP_LIGHT = 30;   // Normal hits (ms)
        const HIT_STOP_HEAVY = 80;   // Kills (ms)
        const HIT_STOP_BOSS = 150;   // Boss impacts (ms)

        function triggerHitStop(duration) {
            hitStopUntil = performance.now() + duration;
        }

        // v4.4: Enhanced Hit Flash
        function flashTargetHit(target, flashColor = 0xffffff) {
            const originalMaterials = [];
            target.traverse(child => {
                if (child.material && child.material.color) {
                    originalMaterials.push({
                        mesh: child,
                        color: child.material.color.getHex(),
                        emissive: child.material.emissive?.getHex() || 0,
                        emissiveIntensity: child.material.emissiveIntensity || 0
                    });
                    child.material.color.setHex(flashColor);
                    if (child.material.emissive) {
                        child.material.emissive.setHex(flashColor);
                        child.material.emissiveIntensity = 1;
                    }
                }
            });

            setTimeout(() => {
                originalMaterials.forEach(data => {
                    if (data.mesh.material) {
                        data.mesh.material.color.setHex(data.color);
                        if (data.mesh.material.emissive) {
                            data.mesh.material.emissive.setHex(data.emissive);
                            data.mesh.material.emissiveIntensity = data.emissiveIntensity;
                        }
                    }
                });
            }, 50);
        }

        // v4.4: Environmental Particle System
        class EnvironmentParticles {
            constructor() {
                this.particles = [];
                this.maxParticles = 60;
                this.currentBiome = null;
                this.biomeConfigs = {
                    Terra: { color: 0x88aa44, count: 20, speed: 1.5, type: 'leaves', gravity: 2 },
                    Desert: { color: 0xddcc99, count: 30, speed: 3, type: 'dust', gravity: 0.5 },
                    Ice: { color: 0xeeffff, count: 40, speed: 0.8, type: 'snow', gravity: 1 },
                    Volcanic: { color: 0xff4400, count: 25, speed: 4, type: 'embers', gravity: -3 },
                    Alien: { color: 0xff00ff, count: 20, speed: 1, type: 'spores', gravity: -0.5 }
                };
            }

            startBiome(biome) {
                if (this.currentBiome === biome) return;
                this.stop();
                this.currentBiome = biome;
            }

            stop() {
                this.particles.forEach(p => {
                    scene.remove(p.mesh);
                    p.mesh.geometry.dispose();
                    p.mesh.material.dispose();
                });
                this.particles = [];
                this.currentBiome = null;
            }

            update(dt, playerPos) {
                if (!this.currentBiome) return;
                const config = this.biomeConfigs[this.currentBiome];
                if (!config) return;

                // Spawn new particles near player
                while (this.particles.length < config.count) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = 5 + Math.random() * 20;
                    const particle = {
                        mesh: new THREE.Mesh(
                            new THREE.SphereGeometry(0.08, 4, 4),
                            new THREE.MeshBasicMaterial({ color: config.color, transparent: true, opacity: 0.6 })
                        ),
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * config.speed,
                            config.gravity > 0 ? -Math.abs(config.gravity) : config.gravity,
                            (Math.random() - 0.5) * config.speed
                        ),
                        life: 5 + Math.random() * 5
                    };
                    particle.mesh.position.set(
                        playerPos.x + Math.cos(angle) * dist,
                        playerPos.y + 5 + Math.random() * 10,
                        playerPos.z + Math.sin(angle) * dist
                    );
                    scene.add(particle.mesh);
                    this.particles.push(particle);
                }

                // Update particles
                this.particles = this.particles.filter(p => {
                    p.life -= dt;
                    if (p.life <= 0 || p.mesh.position.y < 0) {
                        scene.remove(p.mesh);
                        p.mesh.geometry.dispose();
                        p.mesh.material.dispose();
                        return false;
                    }

                    p.mesh.position.add(p.velocity.clone().multiplyScalar(dt));

                    // Sway for leaves/snow
                    if (config.type === 'leaves' || config.type === 'snow') {
                        p.mesh.position.x += Math.sin(performance.now() * 0.002 + p.life) * 0.02;
                    }

                    // Pulse for spores
                    if (config.type === 'spores') {
                        p.mesh.material.opacity = 0.3 + Math.sin(performance.now() * 0.005) * 0.3;
                    }

                    return true;
                });
            }
        }

        let envParticles;

        // v4.5: Player Dodge System
        const DODGE_CONFIG = {
            DISTANCE: 6,
            DURATION: 180,       // ms
            COOLDOWN: 600,       // ms
            IFRAMES: 150         // invincibility duration in ms
        };

        let dodgeState = {
            active: false,
            direction: new THREE.Vector3(),
            startTime: 0,
            cooldownEnd: 0,
            iframesEnd: 0
        };

        // v4.6: Parry/Counter System
        const PARRY_CONFIG = {
            WINDOW: 250,          // ms before attack lands to trigger parry
            STUN_DURATION: 1500,  // ms enemy is stunned
            CRIT_MULTIPLIER: 2.5, // damage multiplier during crit window
            CRIT_WINDOW: 2000     // ms player has to land crits
        };

        let parryState = {
            critWindowEnd: 0,
            lastParryTime: 0
        };

        // v4.8: Combo Attack System
        const COMBO_CONFIG = {
            WINDOW: 1200,           // ms to chain next hit
            MAX_HITS: 5,            // maximum combo length
            DAMAGE_MULT: [1.0, 1.15, 1.35, 1.6, 2.0],  // damage multiplier per hit
            FINISHER_BONUS: 1.5,    // extra multiplier on max combo hit
            BREAK_ON_DAMAGE: true   // combo breaks if player takes damage
        };

        let comboState = {
            count: 0,
            lastHitTime: 0,
            active: false
        };

        function updateCombo(hitTime) {
            const timeSinceLastHit = hitTime - comboState.lastHitTime;

            if (comboState.active && timeSinceLastHit <= COMBO_CONFIG.WINDOW) {
                // Continue combo
                comboState.count = Math.min(comboState.count + 1, COMBO_CONFIG.MAX_HITS - 1);
            } else {
                // Start new combo
                comboState.count = 0;
                comboState.active = true;
            }
            comboState.lastHitTime = hitTime;

            return comboState.count;
        }

        function getComboMultiplier() {
            if (!comboState.active) return 1.0;
            let mult = COMBO_CONFIG.DAMAGE_MULT[comboState.count] || COMBO_CONFIG.DAMAGE_MULT[COMBO_CONFIG.MAX_HITS - 1];
            // Finisher bonus at max combo
            if (comboState.count >= COMBO_CONFIG.MAX_HITS - 1) {
                mult *= COMBO_CONFIG.FINISHER_BONUS;
            }
            return mult;
        }

        function breakCombo() {
            if (comboState.active) {
                comboState.active = false;
                comboState.count = 0;
            }
        }

        // v4.8: Combat Abilities System
        const COMBAT_ABILITIES = {
            powerStrike: {
                name: 'Power Strike',
                key: 'Q',
                icon: 'âš”ï¸',
                cooldown: 8000,       // 8 seconds
                unlockLevel: 3,       // Combat level 3
                damageMultiplier: 3,
                description: '3x damage attack'
            },
            whirlwind: {
                name: 'Whirlwind',
                key: 'E',
                icon: 'ðŸŒ€',
                cooldown: 12000,      // 12 seconds
                unlockLevel: 5,       // Combat level 5
                radius: 8,
                damageMultiplier: 1.5,
                description: 'AoE damage to all nearby enemies'
            },
            warcry: {
                name: 'War Cry',
                key: 'R',
                icon: 'ðŸ“¢',
                cooldown: 20000,      // 20 seconds
                unlockLevel: 7,       // Combat level 7
                duration: 5000,       // 5 second buff
                damageBoost: 1.5,
                description: '+50% damage for 5 seconds'
            },
            // v4.9: Tier 2 Abilities
            heal: {
                name: 'Battle Heal',
                key: 'T',
                icon: 'ðŸ’š',
                cooldown: 15000,      // 15 seconds
                unlockLevel: 9,       // Combat level 9
                healAmount: 0.3,      // 30% of max HP
                description: 'Restore 30% of max HP'
            },
            dash: {
                name: 'Combat Dash',
                key: 'F',
                icon: 'ðŸ’¨',
                cooldown: 6000,       // 6 seconds
                unlockLevel: 10,      // Combat level 10
                distance: 8,
                damageMultiplier: 1.2,
                description: 'Dash forward, damaging enemies in path'
            },
            shieldWall: {
                name: 'Shield Wall',
                key: 'Z',
                icon: 'ðŸ›¡ï¸',
                cooldown: 25000,      // 25 seconds
                unlockLevel: 12,      // Combat level 12
                duration: 4000,       // 4 seconds
                damageReduction: 0.7, // 70% damage reduction
                description: '70% damage reduction for 4 seconds'
            },
            execute: {
                name: 'Execute',
                key: 'X',
                icon: 'ðŸ’€',
                cooldown: 10000,      // 10 seconds
                unlockLevel: 15,      // Combat level 15
                threshold: 0.3,       // Below 30% HP
                damageMultiplier: 5,  // 5x damage to low HP targets
                description: '5x damage to enemies below 30% HP'
            },
            berserk: {
                name: 'Berserker Rage',
                key: 'C',
                icon: 'ðŸ”¥',
                cooldown: 45000,      // 45 seconds (ultimate)
                unlockLevel: 20,      // Combat level 20
                duration: 8000,       // 8 seconds
                damageBoost: 2.0,     // 100% more damage
                attackSpeedBoost: 1.5,// 50% faster attacks
                description: 'ULTIMATE: +100% damage, +50% attack speed for 8s'
            }
        };

        let abilityState = {
            powerStrike: { lastUsed: 0 },
            whirlwind: { lastUsed: 0 },
            warcry: { lastUsed: 0, activeUntil: 0 },
            // v4.9: Tier 2 ability states
            heal: { lastUsed: 0 },
            dash: { lastUsed: 0 },
            shieldWall: { lastUsed: 0, activeUntil: 0 },
            execute: { lastUsed: 0 },
            berserk: { lastUsed: 0, activeUntil: 0 }
        };

        function isAbilityUnlocked(abilityKey) {
            const ability = COMBAT_ABILITIES[abilityKey];
            return gameData.skills.combat.level >= ability.unlockLevel;
        }

        function isAbilityReady(abilityKey) {
            const ability = COMBAT_ABILITIES[abilityKey];
            return performance.now() - abilityState[abilityKey].lastUsed >= ability.cooldown;
        }

        function getAbilityCooldownRemaining(abilityKey) {
            const ability = COMBAT_ABILITIES[abilityKey];
            const elapsed = performance.now() - abilityState[abilityKey].lastUsed;
            return Math.max(0, ability.cooldown - elapsed);
        }

        function useAbility(abilityKey) {
            if (!isAbilityUnlocked(abilityKey)) {
                showNotification(`${COMBAT_ABILITIES[abilityKey].name} unlocks at Combat Lv ${COMBAT_ABILITIES[abilityKey].unlockLevel}`, 'warning');
                return false;
            }
            if (!isAbilityReady(abilityKey)) {
                return false;
            }
            if (mode !== 'world' || !worldState.player) return false;

            const ability = COMBAT_ABILITIES[abilityKey];
            const p = worldState.player;
            const now = performance.now();

            abilityState[abilityKey].lastUsed = now;
            // v5.0: Track ability usage for quests
            trackAbilityUsage();

            if (abilityKey === 'powerStrike') {
                // Find nearest mob and deal massive damage
                let nearestMob = null;
                let nearestDist = 5; // Range limit
                worldState.mobs.forEach(mob => {
                    const dist = mob.position.distanceTo(p.position);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearestMob = mob;
                    }
                });
                if (nearestMob) {
                    const damage = Math.floor(getPlayerDamage() * ability.damageMultiplier);
                    nearestMob.userData.hp -= damage;
                    spawnFloater(nearestMob.position, `${ability.icon} POWER STRIKE! -${damage}`, '#ff4400');
                    triggerHitStop(HIT_STOP_BOSS);
                    screenShake(1.0);
                    if (particles) particles.emit(nearestMob.position, 25, 0xff4400, { spread: 4, lifetime: 800 });
                    AudioSystem.hit();
                    // Check kill
                    if (nearestMob.userData.hp <= 0) {
                        performAction(nearestMob);
                    }
                } else {
                    showNotification('No enemy in range!', 'warning');
                    abilityState[abilityKey].lastUsed = 0; // Refund cooldown
                    return false;
                }
            } else if (abilityKey === 'whirlwind') {
                // AoE damage to all nearby mobs
                let hitCount = 0;
                worldState.mobs.forEach(mob => {
                    const dist = mob.position.distanceTo(p.position);
                    if (dist < ability.radius) {
                        const damage = Math.floor(getPlayerDamage() * ability.damageMultiplier);
                        mob.userData.hp -= damage;
                        spawnFloater(mob.position, `${ability.icon} -${damage}`, '#00ffff');
                        hitCount++;
                        if (mob.userData.hp <= 0) {
                            // Queue for death handling
                            setTimeout(() => {
                                if (mob.userData.hp <= 0) performAction(mob);
                            }, 100);
                        }
                    }
                });
                if (hitCount > 0) {
                    spawnFloater(p.position, `${ability.icon} WHIRLWIND! x${hitCount}`, '#00ffff');
                    triggerHitStop(HIT_STOP_HEAVY);
                    screenShake(0.8);
                    if (particles) particles.emit(p.position, 40, 0x00ffff, { spread: ability.radius, lifetime: 600 });
                    AudioSystem.hit();
                } else {
                    showNotification('No enemies nearby!', 'warning');
                    abilityState[abilityKey].lastUsed = 0;
                    return false;
                }
            } else if (abilityKey === 'warcry') {
                // Activate damage buff
                abilityState.warcry.activeUntil = now + ability.duration;
                spawnFloater(p.position, `${ability.icon} WAR CRY!`, '#ff8800');
                showNotification(`+${Math.floor((ability.damageBoost - 1) * 100)}% damage for ${ability.duration / 1000}s!`, 'success');
                if (particles) particles.emit(p.position, 30, 0xff8800, { spread: 6, lifetime: 1000 });
                AudioSystem.levelUp();
            }
            // v4.9: Tier 2 Abilities
            else if (abilityKey === 'heal') {
                // Self heal
                const healAmt = Math.floor(gameData.player.maxHp * ability.healAmount);
                gameData.player.hp = Math.min(gameData.player.maxHp, gameData.player.hp + healAmt);
                spawnFloater(p.position, `${ability.icon} +${healAmt} HP`, '#00ff88');
                showNotification(`Healed ${healAmt} HP!`, 'success');
                if (particles) particles.emit(p.position, 20, 0x00ff88, { spread: 3, lifetime: 800 });
                updateHealthUI();
                AudioSystem.levelUp();
            } else if (abilityKey === 'dash') {
                // Combat dash - move forward and damage enemies in path
                const dir = new THREE.Vector3(0, 0, -1);
                dir.applyQuaternion(p.quaternion);
                const startPos = p.position.clone();
                const endPos = p.position.clone().add(dir.multiplyScalar(ability.distance));

                // Damage enemies in path
                let dashHits = 0;
                worldState.mobs.forEach(mob => {
                    const mobPos = mob.position.clone();
                    // Check if mob is roughly between start and end
                    const toMob = mobPos.sub(startPos);
                    const projection = toMob.dot(dir.clone().normalize());
                    if (projection > 0 && projection < ability.distance) {
                        const perpDist = toMob.clone().sub(dir.clone().normalize().multiplyScalar(projection)).length();
                        if (perpDist < 2) {
                            const damage = Math.floor(getPlayerDamage() * ability.damageMultiplier);
                            mob.userData.hp -= damage;
                            spawnFloater(mob.position, `${ability.icon} -${damage}`, '#88ffff');
                            dashHits++;
                            if (mob.userData.hp <= 0) {
                                setTimeout(() => { if (mob.userData.hp <= 0) performAction(mob); }, 100);
                            }
                        }
                    }
                });

                // Move player
                p.position.copy(endPos);
                spawnFloater(p.position, `${ability.icon} DASH!`, '#88ffff');
                if (dashHits > 0) {
                    showNotification(`Dash hit ${dashHits} enemies!`, 'success');
                    triggerHitStop(HIT_STOP_LIGHT);
                }
                if (particles) particles.emit(startPos, 15, 0x88ffff, { spread: 2, lifetime: 400 });
                AudioSystem.hit();
            } else if (abilityKey === 'shieldWall') {
                // Activate damage reduction buff
                abilityState.shieldWall.activeUntil = now + ability.duration;
                spawnFloater(p.position, `${ability.icon} SHIELD WALL!`, '#4488ff');
                showNotification(`${Math.floor(ability.damageReduction * 100)}% damage reduction for ${ability.duration / 1000}s!`, 'success');
                if (particles) particles.emit(p.position, 25, 0x4488ff, { spread: 4, lifetime: 1000 });
                AudioSystem.levelUp();
            } else if (abilityKey === 'execute') {
                // High damage to low HP enemies
                let target = null;
                let nearestDist = 6;
                worldState.mobs.forEach(mob => {
                    const dist = mob.position.distanceTo(p.position);
                    const hpPercent = mob.userData.hp / mob.userData.maxHp;
                    if (dist < nearestDist && hpPercent <= ability.threshold) {
                        nearestDist = dist;
                        target = mob;
                    }
                });
                if (target) {
                    const damage = Math.floor(getPlayerDamage() * ability.damageMultiplier);
                    target.userData.hp -= damage;
                    spawnFloater(target.position, `${ability.icon} EXECUTE! -${damage}`, '#ff0044');
                    triggerHitStop(HIT_STOP_BOSS);
                    screenShake(1.2);
                    if (particles) particles.emit(target.position, 35, 0xff0044, { spread: 5, lifetime: 1000 });
                    AudioSystem.hit();
                    if (target.userData.hp <= 0) {
                        performAction(target);
                    }
                } else {
                    showNotification('No low HP enemies in range!', 'warning');
                    abilityState[abilityKey].lastUsed = 0;
                    return false;
                }
            } else if (abilityKey === 'berserk') {
                // ULTIMATE: Massive damage and attack speed buff
                abilityState.berserk.activeUntil = now + ability.duration;
                spawnFloater(p.position, `${ability.icon} BERSERKER RAGE!`, '#ff4400');
                showNotification(`BERSERK! +100% DMG, +50% Attack Speed for ${ability.duration / 1000}s!`, 'success');
                screenShake(1.5);
                if (particles) particles.emit(p.position, 50, 0xff4400, { spread: 8, lifetime: 1500 });
                AudioSystem.levelUp();
            }

            updateAbilityUI();
            return true;
        }

        function isWarcryActive() {
            return performance.now() < abilityState.warcry.activeUntil;
        }

        // v4.9: Check if Shield Wall is active
        function isShieldWallActive() {
            return performance.now() < abilityState.shieldWall.activeUntil;
        }

        // v4.9: Check if Berserk is active
        function isBerserkActive() {
            return performance.now() < abilityState.berserk.activeUntil;
        }

        function startDodge() {
            if (dodgeState.active || performance.now() < dodgeState.cooldownEnd) return false;
            if (mode !== 'world' || !worldState.player) return false;

            const p = worldState.player;
            dodgeState.active = true;
            dodgeState.startTime = performance.now();
            dodgeState.cooldownEnd = performance.now() + DODGE_CONFIG.COOLDOWN;
            dodgeState.iframesEnd = performance.now() + DODGE_CONFIG.IFRAMES;

            // Direction based on current input or facing
            dodgeState.direction.set(0, 0, 0);
            if (keys.w) dodgeState.direction.z -= 1;
            if (keys.s) dodgeState.direction.z += 1;
            if (keys.a) dodgeState.direction.x -= 1;
            if (keys.d) dodgeState.direction.x += 1;

            // Also check joystick
            if (dodgeState.direction.length() < 0.1 && joystickActive) {
                dodgeState.direction.set(joystickInput.x, 0, joystickInput.y);
            }

            // Default to backward if no input
            if (dodgeState.direction.length() < 0.1) {
                dodgeState.direction.set(-Math.sin(p.rotation.y), 0, -Math.cos(p.rotation.y));
            }
            dodgeState.direction.normalize();

            AudioSystem.dodge();
            if (particles) particles.emit(p.position, 10, 0x88ffff, { spread: 2, lifetime: 300, gravity: 0 });

            // v5.15: Trigger robot jump animation on dodge
            triggerRobotAnimation('jump');

            // v4.6: Check for parry opportunity
            checkParryTiming();

            return true;
        }

        function updateDodge(dt) {
            if (!dodgeState.active) return;

            const elapsed = performance.now() - dodgeState.startTime;
            const progress = elapsed / DODGE_CONFIG.DURATION;

            if (progress < 1) {
                const eased = 1 - Math.pow(1 - progress, 3);
                const moveAmount = (1 - eased) * DODGE_CONFIG.DISTANCE * dt * 10;
                worldState.player.position.add(dodgeState.direction.clone().multiplyScalar(moveAmount));
            } else {
                dodgeState.active = false;
            }
        }

        function isInvincible() {
            return performance.now() < dodgeState.iframesEnd;
        }

        // v4.6: Check if dodge was timed for a parry
        function checkParryTiming() {
            if (!worldState || !worldState.mobs) return;

            const now = performance.now();
            let parried = false;

            worldState.mobs.forEach(mob => {
                if (mob.userData.telegraphing && !mob.userData.stunned) {
                    const timeToAttack = mob.userData.telegraphEnd - now;
                    // Check if dodge was in the parry window (last PARRY_CONFIG.WINDOW ms before attack)
                    if (timeToAttack > 0 && timeToAttack <= PARRY_CONFIG.WINDOW) {
                        // Perfect parry!
                        mob.userData.stunned = true;
                        mob.userData.stunEnd = now + PARRY_CONFIG.STUN_DURATION;
                        mob.userData.telegraphing = false;

                        // Visual feedback
                        mob.material.emissive.setHex(0xffff00); // Yellow stun
                        mob.scale.setScalar(1);
                        spawnFloater(mob.position, 'âš¡ PARRY!', '#ffd700');

                        parried = true;
                    }
                }
            });

            if (parried) {
                // Grant crit window
                parryState.critWindowEnd = now + PARRY_CONFIG.CRIT_WINDOW;
                parryState.lastParryTime = now;

                // Audio feedback
                AudioSystem.levelUp();

                // Screen effect
                screenShake(0.3);
                if (particles) particles.emit(worldState.player.position, 25, 0xffd700, { spread: 4, lifetime: 500 });

                showNotification('PERFECT PARRY! Critical hits enabled!');
            }
        }

        // v4.6: Check if in crit window from parry
        function isInCritWindow() {
            return performance.now() < parryState.critWindowEnd;
        }

        // --- ENGINE CORE ---
        const CONFIG = {
            GALAXY_SIZE: 3000,
            NUM_CIVS: 60,
            WORLD_SIZE: 100,
            TILE_SIZE: 2,
            PLAYER_MAX_HP: 100,
            MOB_DAMAGE: 5,
            AUTOSAVE_INTERVAL: 30000, // 30 seconds
            // New v4.0 constants
            MOB_AGGRO_RANGE: 15,
            MOB_ATTACK_RANGE: 2,
            MOB_ATTACK_COOLDOWN: 1500,
            INTERACTION_RANGE: 3.5,
            INTERACTION_COOLDOWN: 400, // ms between actions
            MOVEMENT_THRESHOLD: 0.5,
            SCREEN_SHAKE_INTENSITY: 0.5,
            SCREEN_SHAKE_DURATION: 150
        };

        // v4.7: Player state for status effects
        const playerState = {
            chilled: false,
            chilledEnd: 0,
            moveSpeedMult: 1.0
        };

        // --- PRE-ALLOCATED REUSABLE OBJECTS ---
        const _tempVec3A = new THREE.Vector3();
        const _tempVec3B = new THREE.Vector3();
        // v5.11: Cinematic camera offset - player higher in frame, more environment visible
        const _camOffset = new THREE.Vector3(0, 38, 32);
        const _camLookOffset = new THREE.Vector3(0, -5, -8); // Look ahead/below player for cinematic framing

        // --- SCREEN EFFECTS ---
        let screenShakeIntensity = 0;
        let screenShakeDecay = 0;
        let originalCameraPos = null;

        function screenShake(intensity = CONFIG.SCREEN_SHAKE_INTENSITY) {
            // v4.6: Check settings
            if (gameData.settings && !gameData.settings.screenShakeEnabled) return;
            screenShakeIntensity = intensity;
            screenShakeDecay = intensity / (CONFIG.SCREEN_SHAKE_DURATION / 16);
            if (!originalCameraPos) originalCameraPos = new THREE.Vector3();
        }

        function updateScreenShake() {
            if (screenShakeIntensity > 0 && mode === 'world') {
                camera.position.x += (Math.random() - 0.5) * screenShakeIntensity;
                camera.position.y += (Math.random() - 0.5) * screenShakeIntensity;
                screenShakeIntensity -= screenShakeDecay;
                if (screenShakeIntensity < 0) screenShakeIntensity = 0;
            }
        }

        // Damage flash overlay
        function flashDamageOverlay() {
            const overlay = document.getElementById('damage-overlay');
            if (overlay) {
                overlay.style.opacity = '0.4';
                setTimeout(() => overlay.style.opacity = '0', 150);
            }
        }

        // v5.15: Robot Animation Trigger System
        // Triggers special animations on the explorer robot
        function triggerRobotAnimation(animType) {
            if (!worldState.player || !worldState.player.userData.animation) return;
            const anim = worldState.player.userData.animation;

            switch (animType) {
                case 'attack':
                    anim.attackPhase = 1;
                    break;
                case 'damage':
                    anim.damageFlash = 1;
                    break;
                case 'wave':
                    anim.wavePhase = 1;
                    break;
                case 'jump':
                    anim.jumpPhase = 1;
                    break;
                case 'celebrate':
                    // Celebrate is a wave + jump combo
                    anim.wavePhase = 1;
                    anim.jumpPhase = 0.8;
                    break;
            }
        }

        // v4.1: Create nebula clouds for galaxy atmosphere
        function createNebulae() {
            const nebulaColors = [0xff3366, 0x3366ff, 0x66ff33, 0xff6633, 0x9933ff, 0x33ffff];
            const nebulaCount = 6;

            for (let i = 0; i < nebulaCount; i++) {
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 256;
                const ctx = canvas.getContext('2d');

                // Create procedural nebula with radial gradients
                const color = nebulaColors[i % nebulaColors.length];
                const r = (color >> 16) & 255;
                const g = (color >> 8) & 255;
                const b = color & 255;

                // Multiple overlapping gradients for organic look
                for (let j = 0; j < 3; j++) {
                    const cx = 80 + Math.random() * 96;
                    const cy = 80 + Math.random() * 96;
                    const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, 100 + Math.random() * 56);
                    gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, 0.25)`);
                    gradient.addColorStop(0.4, `rgba(${r}, ${g}, ${b}, 0.1)`);
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, 256, 256);
                }

                const texture = new THREE.CanvasTexture(canvas);
                const material = new THREE.MeshBasicMaterial({
                    map: texture,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    side: THREE.DoubleSide,
                    depthWrite: false,
                    opacity: 0.6
                });

                const geometry = new THREE.PlaneGeometry(600, 600);
                const nebula = new THREE.Mesh(geometry, material);

                // Position nebulae around the galaxy
                const angle = (i / nebulaCount) * Math.PI * 2;
                const dist = 400 + Math.random() * 600;
                nebula.position.set(
                    Math.cos(angle) * dist,
                    (Math.random() - 0.5) * 300,
                    Math.sin(angle) * dist
                );

                // Random rotation
                nebula.rotation.set(
                    Math.random() * Math.PI,
                    Math.random() * Math.PI,
                    Math.random() * Math.PI
                );

                scene.add(nebula);
            }
        }

        const BIOMES = {
            Terra: { sky: 0x87ceeb, ground: 0x33aa33, tree: 0x228b22, rock: 0x888888, water: 0x2244aa, name: 'Terra' },
            Desert: { sky: 0xffcc99, ground: 0xeeddaa, tree: 0xccbb99, rock: 0xaa5522, water: 0x446688, name: 'Desert' },
            Ice: { sky: 0xddeeff, ground: 0xffffff, tree: 0xaaccff, rock: 0x99aabb, water: 0x88aadd, name: 'Tundra' },
            Alien: { sky: 0x220044, ground: 0x440066, tree: 0xff00ff, rock: 0x00ffcc, water: 0x8800ff, name: 'Xeno' },
            Volcanic: { sky: 0x330000, ground: 0x221111, tree: 0x552222, rock: 0x111111, water: 0xff4400, name: 'Magma' }
        };

        // v4.2: Enemy Variety System - Biome-specific enemies
        // v4.5: Added attack telegraphing parameters
        const ENEMY_TYPES = {
            Slime: {
                hp: 10, damage: 5, speed: 4, color: 0x44ff44, emissive: 0x003300,
                drops: ['Slime'], xp: 100, biomes: ['Terra', 'Alien'],
                attackWindup: 800, attackRange: 2.5  // v4.5: Telegraph timing
            },
            Scorpion: {
                hp: 15, damage: 8, speed: 5, color: 0xdd9944, emissive: 0x442200,
                drops: ['Chitin'], xp: 150, biomes: ['Desert'],
                attackWindup: 600, attackRange: 3.0
            },
            IceWisp: {
                hp: 8, damage: 6, speed: 7, color: 0x88ccff, emissive: 0x002244,
                drops: ['Frost Shard'], xp: 120, biomes: ['Ice'],
                attackWindup: 500, attackRange: 4.0  // Fast ranged
            },
            MagmaCore: {
                hp: 20, damage: 10, speed: 3, color: 0xff4400, emissive: 0x440000,
                drops: ['Magma Gem'], xp: 180, biomes: ['Volcanic'],
                attackWindup: 1200, attackRange: 3.5  // Slow heavy
            },
            VoidSpawn: {
                hp: 25, damage: 12, speed: 5, color: 0x8800ff, emissive: 0x220044,
                drops: ['Void Fragment'], xp: 250, biomes: ['Alien'],
                attackWindup: 700, attackRange: 3.0
            },
            // v5.12: Hypnotist - Special enemy that takes control of the player
            Hypnotist: {
                hp: 35, damage: 8, speed: 2, color: 0xff00ff, emissive: 0x660066,
                drops: ['Void Fragment', 'Psychic Shard'], xp: 400, biomes: ['Alien', 'Volcanic'],
                attackWindup: 2000, attackRange: 15.0,  // Long range hypnosis
                isHypnotist: true,
                hypnosisRange: 12,
                hypnosisDuration: 8000,
                hypnosisCooldown: 15000
            }
        };

        // v4.6: Elemental Status Effects System
        const STATUS_EFFECTS = {
            ice: {
                name: 'Frozen',
                duration: 3000,
                color: 0x88ccff,
                icon: 'â„ï¸',
                speedMod: 0.3  // Slows to 30% speed
            },
            fire: {
                name: 'Burning',
                duration: 4000,
                color: 0xff4400,
                icon: 'ðŸ”¥',
                tickRate: 500,
                tickDamage: 2
            },
            void: {
                name: 'Weakened',
                duration: 5000,
                color: 0x8800ff,
                icon: 'ðŸ’œ',
                damageMod: 0.5  // Enemy deals 50% damage
            },
            cosmic: {
                name: 'Annihilated',
                duration: 3000,
                color: 0xffd700,
                icon: 'âœ¨',
                tickRate: 250,
                tickDamage: 5,
                speedMod: 0.5
            }
        };

        // ============================================
        // v5.12: HYPNOTIST SYSTEM
        // Eye animation, trance effects, and break-free mechanics
        // ============================================
        const HYPNOSIS_STATE = {
            active: false,
            hypnotistMob: null,
            startTime: 0,
            duration: 0,
            spiralAngle: 0,
            eyePhase: 0,
            breakAttempts: 0,
            maxBreakAttempts: 3,
            breakDamage: 25,
            tranceOverlay: null,
            spiralRings: [],
            companionEyeOffset: { x: 0, y: 0 }
        };

        // Autopilot mode flag (disables player control during certain states)
        let autopilotEnabled = false;

        // Eye animation patterns for hypnosis
        const HYPNO_EYE_PATTERNS = [
            { name: 'spiral', fn: (t) => ({ x: Math.cos(t * 3) * 0.3, y: Math.sin(t * 3) * 0.15 }) },
            { name: 'figure8', fn: (t) => ({ x: Math.sin(t * 2) * 0.4, y: Math.sin(t * 4) * 0.2 }) },
            { name: 'pendulum', fn: (t) => ({ x: Math.sin(t * 2.5) * 0.5, y: 0 }) },
            { name: 'erratic', fn: (t) => ({ x: Math.sin(t * 7) * 0.3 + Math.cos(t * 11) * 0.2, y: Math.cos(t * 5) * 0.2 }) }
        ];

        let hypnoVisualGroup = null;
        let hypnoEyePattern = 0;

        // Initialize hypnosis visual effects
        function initHypnosisEffects() {
            // Create overlay for trance effect
            const overlay = document.createElement('div');
            overlay.id = 'hypnosis-overlay';
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                pointer-events: none; z-index: 48;
                background: radial-gradient(ellipse at center,
                    transparent 20%,
                    rgba(138, 43, 226, 0.1) 40%,
                    rgba(255, 0, 255, 0.2) 60%,
                    rgba(138, 43, 226, 0.4) 100%);
                opacity: 0;
                transition: opacity 0.5s;
            `;
            document.body.appendChild(overlay);
            HYPNOSIS_STATE.tranceOverlay = overlay;

            // Create spiral rings container in 3D
            hypnoVisualGroup = new THREE.Group();
        }

        // Start hypnosis effect on player
        function startHypnosis(hypnotistMob, duration = 8000) {
            if (HYPNOSIS_STATE.active) return;

            HYPNOSIS_STATE.active = true;
            HYPNOSIS_STATE.hypnotistMob = hypnotistMob;
            HYPNOSIS_STATE.startTime = performance.now();
            HYPNOSIS_STATE.duration = duration;
            HYPNOSIS_STATE.spiralAngle = 0;
            HYPNOSIS_STATE.eyePhase = 0;
            HYPNOSIS_STATE.breakAttempts = 0;

            // Random eye pattern
            hypnoEyePattern = Math.floor(Math.random() * HYPNO_EYE_PATTERNS.length);

            // Show overlay
            if (HYPNOSIS_STATE.tranceOverlay) {
                HYPNOSIS_STATE.tranceOverlay.style.opacity = '1';
            }

            // Create 3D spiral rings around player
            createHypnoSpirals();

            // Show UI notification
            showHypnosisUI();

            // Notification
            if (typeof showNotification === 'function') {
                showNotification('ðŸ‘ï¸ You are being hypnotized! Press SPACE rapidly to break free!', 'warning');
            }

            console.log('Hypnosis started - break free with SPACE!');
        }

        // Create swirling spiral rings effect
        function createHypnoSpirals() {
            if (!scene || !worldState.player) return;

            // Clear existing
            HYPNOSIS_STATE.spiralRings.forEach(ring => {
                if (ring.parent) ring.parent.remove(ring);
                ring.geometry?.dispose();
                ring.material?.dispose();
            });
            HYPNOSIS_STATE.spiralRings = [];

            // Create multiple concentric spiral rings
            for (let i = 0; i < 5; i++) {
                const radius = 3 + i * 2;
                const ringGeo = new THREE.TorusGeometry(radius, 0.15, 8, 64);
                const ringMat = new THREE.MeshBasicMaterial({
                    color: i % 2 === 0 ? 0xff00ff : 0x8a2be2,
                    transparent: true,
                    opacity: 0.6 - i * 0.1,
                    side: THREE.DoubleSide
                });
                const ring = new THREE.Mesh(ringGeo, ringMat);
                ring.rotation.x = Math.PI / 2;
                ring.position.y = 1 + i * 0.5;
                ring.userData.baseY = ring.position.y;
                ring.userData.index = i;

                scene.add(ring);
                HYPNOSIS_STATE.spiralRings.push(ring);
            }
        }

        // Update hypnosis effects each frame
        function updateHypnosis(dt) {
            if (!HYPNOSIS_STATE.active) return;

            const elapsed = performance.now() - HYPNOSIS_STATE.startTime;
            const progress = elapsed / HYPNOSIS_STATE.duration;

            // Check if hypnosis ended naturally
            if (progress >= 1) {
                endHypnosis(false);
                return;
            }

            // Update spiral angle
            HYPNOSIS_STATE.spiralAngle += dt * 2;
            HYPNOSIS_STATE.eyePhase += dt;

            // Move spiral rings around player
            if (worldState.player) {
                const playerPos = worldState.player.position;

                HYPNOSIS_STATE.spiralRings.forEach((ring, i) => {
                    ring.position.x = playerPos.x;
                    ring.position.z = playerPos.z;
                    ring.position.y = playerPos.y + ring.userData.baseY + Math.sin(HYPNOSIS_STATE.spiralAngle + i) * 0.5;
                    ring.rotation.z = HYPNOSIS_STATE.spiralAngle * (i % 2 === 0 ? 1 : -1) * 0.5;

                    // Pulsing opacity
                    ring.material.opacity = (0.4 + Math.sin(HYPNOSIS_STATE.spiralAngle * 2 + i) * 0.2) * (1 - progress * 0.3);
                });
            }

            // Update companion eye animation
            updateHypnoEyeAnimation();

            // Move player in trance pattern (toward hypnotist slowly)
            if (worldState.player && HYPNOSIS_STATE.hypnotistMob && !autopilotEnabled) {
                const hypnotistPos = HYPNOSIS_STATE.hypnotistMob.position;
                const playerPos = worldState.player.position;

                // Spiral movement toward hypnotist
                const angle = HYPNOSIS_STATE.spiralAngle * 0.3;
                const spiralRadius = 2 + Math.sin(HYPNOSIS_STATE.spiralAngle * 0.5) * 1;

                const targetX = hypnotistPos.x + Math.cos(angle) * spiralRadius;
                const targetZ = hypnotistPos.z + Math.sin(angle) * spiralRadius;

                // Very slow drift toward hypnotist
                playerPos.x += (targetX - playerPos.x) * dt * 0.3;
                playerPos.z += (targetZ - playerPos.z) * dt * 0.3;
            }

            // Overlay pulsing
            if (HYPNOSIS_STATE.tranceOverlay) {
                const pulse = 0.7 + Math.sin(HYPNOSIS_STATE.spiralAngle * 3) * 0.3;
                HYPNOSIS_STATE.tranceOverlay.style.opacity = pulse.toString();
            }
        }

        // Update the "eye" animation on the companion orb
        function updateHypnoEyeAnimation() {
            if (!copilotMesh || !HYPNOSIS_STATE.active) return;

            const pattern = HYPNO_EYE_PATTERNS[hypnoEyePattern];
            const offset = pattern.fn(HYPNOSIS_STATE.eyePhase);

            HYPNOSIS_STATE.companionEyeOffset = offset;

            // Move the companion's inner orb to create "eye looking around" effect
            const orb = copilotMesh.userData?.orb;
            const core = copilotMesh.userData?.core;

            if (orb) {
                orb.position.x = offset.x;
                orb.position.y = offset.y;
            }
            if (core) {
                core.position.x = offset.x * 0.5;
                core.position.y = offset.y * 0.5;
            }

            // Also make the companion face the hypnotist
            if (HYPNOSIS_STATE.hypnotistMob) {
                copilotMesh.lookAt(HYPNOSIS_STATE.hypnotistMob.position);
            }
        }

        // Show hypnosis UI
        function showHypnosisUI() {
            // Create or show the break-free UI
            let hypnoUI = document.getElementById('hypnosis-ui');
            if (!hypnoUI) {
                hypnoUI = document.createElement('div');
                hypnoUI.id = 'hypnosis-ui';
                hypnoUI.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: rgba(0, 0, 0, 0.8);
                    border: 3px solid #ff00ff;
                    border-radius: 15px;
                    padding: 20px 40px;
                    color: #fff;
                    font-family: Georgia, serif;
                    text-align: center;
                    z-index: 1005;
                    animation: hypnoPulse 1s ease-in-out infinite;
                `;
                hypnoUI.innerHTML = `
                    <div style="font-size: 48px; margin-bottom: 10px;">ðŸ‘ï¸</div>
                    <div style="font-size: 18px; color: #ff00ff; margin-bottom: 15px;">HYPNOTIZED</div>
                    <div style="font-size: 14px; color: #aaa;">Press <span style="color: #0ff; font-weight: bold;">SPACE</span> rapidly to break free!</div>
                    <div style="margin-top: 15px;">
                        <div id="hypno-break-bar" style="width: 200px; height: 10px; background: #333; border-radius: 5px; overflow: hidden;">
                            <div id="hypno-break-fill" style="width: 0%; height: 100%; background: linear-gradient(90deg, #ff00ff, #0ff); transition: width 0.1s;"></div>
                        </div>
                        <div id="hypno-break-text" style="font-size: 12px; color: #888; margin-top: 5px;">0 / ${HYPNOSIS_STATE.maxBreakAttempts}</div>
                    </div>
                `;
                document.body.appendChild(hypnoUI);

                // Add pulse animation
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes hypnoPulse {
                        0%, 100% { box-shadow: 0 0 20px rgba(255, 0, 255, 0.5); transform: translate(-50%, -50%) scale(1); }
                        50% { box-shadow: 0 0 40px rgba(255, 0, 255, 0.8); transform: translate(-50%, -50%) scale(1.02); }
                    }
                `;
                document.head.appendChild(style);
            }
            hypnoUI.style.display = 'block';
        }

        // Handle break attempt (called when player presses SPACE during hypnosis)
        function attemptBreakHypnosis() {
            if (!HYPNOSIS_STATE.active) return;

            HYPNOSIS_STATE.breakAttempts++;

            // Update UI
            const fill = document.getElementById('hypno-break-fill');
            const text = document.getElementById('hypno-break-text');
            if (fill) {
                fill.style.width = (HYPNOSIS_STATE.breakAttempts / HYPNOSIS_STATE.maxBreakAttempts * 100) + '%';
            }
            if (text) {
                text.textContent = `${HYPNOSIS_STATE.breakAttempts} / ${HYPNOSIS_STATE.maxBreakAttempts}`;
            }

            // Screen flash on attempt
            if (HYPNOSIS_STATE.tranceOverlay) {
                HYPNOSIS_STATE.tranceOverlay.style.background = 'radial-gradient(ellipse at center, rgba(0,255,255,0.3) 0%, rgba(138,43,226,0.4) 100%)';
                setTimeout(() => {
                    if (HYPNOSIS_STATE.tranceOverlay) {
                        HYPNOSIS_STATE.tranceOverlay.style.background = 'radial-gradient(ellipse at center, transparent 20%, rgba(138, 43, 226, 0.1) 40%, rgba(255, 0, 255, 0.2) 60%, rgba(138, 43, 226, 0.4) 100%)';
                    }
                }, 100);
            }

            // Check if broken free
            if (HYPNOSIS_STATE.breakAttempts >= HYPNOSIS_STATE.maxBreakAttempts) {
                endHypnosis(true);
            }
        }

        // End hypnosis effect
        function endHypnosis(brokeFreeBySelf) {
            if (!HYPNOSIS_STATE.active) return;

            HYPNOSIS_STATE.active = false;

            // Hide overlay
            if (HYPNOSIS_STATE.tranceOverlay) {
                HYPNOSIS_STATE.tranceOverlay.style.opacity = '0';
            }

            // Remove spiral rings
            HYPNOSIS_STATE.spiralRings.forEach(ring => {
                if (ring.parent) ring.parent.remove(ring);
                ring.geometry?.dispose();
                ring.material?.dispose();
            });
            HYPNOSIS_STATE.spiralRings = [];

            // Reset companion eye position
            if (copilotMesh) {
                const orb = copilotMesh.userData?.orb;
                const core = copilotMesh.userData?.core;
                if (orb) { orb.position.x = 0; orb.position.y = 0; }
                if (core) { core.position.x = 0; core.position.y = 0; }
            }

            // Hide UI
            const hypnoUI = document.getElementById('hypnosis-ui');
            if (hypnoUI) hypnoUI.style.display = 'none';

            // If broke free, damage the hypnotist!
            if (brokeFreeBySelf && HYPNOSIS_STATE.hypnotistMob) {
                const damage = HYPNOSIS_STATE.breakDamage;
                HYPNOSIS_STATE.hypnotistMob.userData.hp -= damage;

                // Show damage effect
                if (typeof createDamageNumber === 'function') {
                    createDamageNumber(HYPNOSIS_STATE.hypnotistMob.position.clone(), damage, 0x00ffff);
                }

                // Notification
                if (typeof showNotification === 'function') {
                    showNotification(`ðŸ”® You broke free! Dealt ${damage} psychic damage to the Hypnotist!`, 'success');
                }

                // Screen shake
                if (typeof screenShake === 'function') {
                    screenShake(0.5);
                }

                // Check if hypnotist died
                if (HYPNOSIS_STATE.hypnotistMob.userData.hp <= 0) {
                    // Handle death
                    const xpReward = HYPNOSIS_STATE.hypnotistMob.userData.xpReward || 400;
                    if (typeof addXp === 'function') addXp('combat', xpReward);
                    gameData.statistics.mobsKilled++;

                    if (typeof showNotification === 'function') {
                        showNotification('ðŸ‘ï¸ Hypnotist defeated by psychic backlash!', 'success');
                    }

                    // Remove from scene
                    if (HYPNOSIS_STATE.hypnotistMob.parent) {
                        scene.remove(HYPNOSIS_STATE.hypnotistMob);
                    }
                    const idx = worldState.mobs.indexOf(HYPNOSIS_STATE.hypnotistMob);
                    if (idx > -1) worldState.mobs.splice(idx, 1);
                }
            } else if (!brokeFreeBySelf) {
                // Hypnosis wore off naturally - player takes some damage
                if (worldState.player) {
                    const damage = 10;
                    gameData.hp = Math.max(1, gameData.hp - damage);
                    if (typeof updateHealthUI === 'function') updateHealthUI();
                    if (typeof showNotification === 'function') {
                        showNotification('ðŸ‘ï¸ Hypnosis wore off. You feel drained...', 'warning');
                    }
                }
            }

            HYPNOSIS_STATE.hypnotistMob = null;
        }

        // v4.7: Elite Enemy System - Affixes that modify enemy behavior
        const ELITE_AFFIXES = {
            swift: {
                name: 'Swift',
                prefix: 'âš¡',
                color: 0x00ffff,
                speedMult: 1.8,
                hpMult: 1.2,
                damageMult: 1.0,
                description: 'Moves much faster'
            },
            armored: {
                name: 'Armored',
                prefix: 'ðŸ›¡ï¸',
                color: 0x888888,
                speedMult: 0.8,
                hpMult: 3.0,
                damageMult: 1.0,
                description: 'Extremely tough'
            },
            vampiric: {
                name: 'Vampiric',
                prefix: 'ðŸ¦‡',
                color: 0x990000,
                speedMult: 1.0,
                hpMult: 1.5,
                damageMult: 1.2,
                lifesteal: 0.3,
                description: 'Heals on hit'
            },
            explosive: {
                name: 'Explosive',
                prefix: 'ðŸ’¥',
                color: 0xff6600,
                speedMult: 1.0,
                hpMult: 1.5,
                damageMult: 0.8,
                explodeOnDeath: true,
                description: 'Explodes on death'
            },
            berserker: {
                name: 'Berserker',
                prefix: 'ðŸ˜¤',
                color: 0xff0000,
                speedMult: 1.2,
                hpMult: 1.0,
                damageMult: 2.0,
                description: 'Deals double damage'
            },
            regenerating: {
                name: 'Regenerating',
                prefix: 'ðŸ’š',
                color: 0x00ff00,
                speedMult: 1.0,
                hpMult: 1.8,
                damageMult: 1.0,
                regenRate: 0.02,
                description: 'Regenerates health'
            },
            teleporter: {
                name: 'Teleporter',
                prefix: 'ðŸŒ€',
                color: 0x9900ff,
                speedMult: 0.9,
                hpMult: 1.3,
                damageMult: 1.3,
                canTeleport: true,
                description: 'Blinks around'
            },
            frozen: {
                name: 'Frozen',
                prefix: 'â„ï¸',
                color: 0x88ddff,
                speedMult: 0.7,
                hpMult: 2.0,
                damageMult: 1.1,
                chillingAura: true,
                description: 'Slows nearby player'
            }
        };

        const ELITE_CONFIG = {
            spawnChance: 0.15,        // 15% chance for elite
            minWorldLevel: 2,         // Only spawn in world level 2+
            essenceDropChance: 0.8,   // 80% chance to drop elite essence
            bonusXpMult: 2.5,         // 2.5x XP from elites
            bonusDropMult: 2          // Double drops from elites
        };

        // v4.7: Session Rewards - Welcome back bonuses
        const SESSION_REWARDS = {
            tiers: [
                { minHours: 1, xpBonus: 50, resources: { 'Slime': 2 }, message: 'Quick break bonus!' },
                { minHours: 4, xpBonus: 150, resources: { 'Ore': 3, 'Log': 3 }, message: 'Gone a while bonus!' },
                { minHours: 12, xpBonus: 400, resources: { 'Ore': 8, 'Log': 8, 'Health Potion': 2 }, message: 'Half-day bonus!' },
                { minHours: 24, xpBonus: 1000, resources: { 'Crystal': 2, 'Mystic Orb': 1, 'Health Potion': 3 }, message: 'Daily login bonus!' },
                { minHours: 72, xpBonus: 3000, resources: { 'Elite Essence': 5, 'Legendary Core': 1, 'Super Potion': 2 }, message: 'We missed you bonus!' }
            ],
            maxOfflineHours: 168 // Cap at 1 week
        };

        // v4.6: Get equipped weapon element
        function getEquippedElement() {
            const weapons = ['Legendary Blade', 'Void Dagger', 'Magma Sword', 'Frost Blade'];
            for (const weapon of weapons) {
                if (hasItem(weapon)) {
                    return ITEMS[weapon].element || null;
                }
            }
            return null;
        }

        // v4.6: Apply status effect to mob
        function applyStatusEffect(mob, element) {
            const effect = STATUS_EFFECTS[element];
            if (!effect) return;

            const data = mob.userData;
            data.statusEffects = data.statusEffects || {};

            // Only apply if not already affected by this element
            if (data.statusEffects[element]) return;

            data.statusEffects[element] = {
                endTime: performance.now() + effect.duration,
                lastTick: performance.now()
            };

            // Apply immediate effects
            if (effect.speedMod) {
                data.speedMultiplier = (data.speedMultiplier || 1) * effect.speedMod;
            }
            if (effect.damageMod) {
                data.damageMultiplier = (data.damageMultiplier || 1) * effect.damageMod;
            }

            // Visual feedback
            mob.material.emissive.setHex(effect.color);
            spawnFloater(mob.position, effect.icon + ' ' + effect.name, '#' + effect.color.toString(16).padStart(6, '0'));
            AudioSystem.hit();
        }

        // v4.6: Update status effects for mob
        function updateMobStatusEffects(mob, time) {
            const data = mob.userData;
            if (!data.statusEffects) return;

            for (const [element, state] of Object.entries(data.statusEffects)) {
                const effect = STATUS_EFFECTS[element];
                if (!effect) continue;

                // Apply DoT
                if (effect.tickDamage && time - state.lastTick >= effect.tickRate) {
                    data.hp -= effect.tickDamage;
                    state.lastTick = time;
                    spawnFloater(mob.position, `-${effect.tickDamage}`, '#' + effect.color.toString(16).padStart(6, '0'));

                    // Check for death by status effect
                    if (data.hp <= 0) {
                        // Will be handled in main mob loop
                    }
                }

                // Check expiration
                if (time >= state.endTime) {
                    // Clear effects
                    if (effect.speedMod) {
                        data.speedMultiplier = (data.speedMultiplier || 1) / effect.speedMod;
                    }
                    if (effect.damageMod) {
                        data.damageMultiplier = (data.damageMultiplier || 1) / effect.damageMod;
                    }
                    delete data.statusEffects[element];

                    // Restore emissive color if no more effects
                    if (Object.keys(data.statusEffects).length === 0) {
                        const originalEmissive = ENEMY_TYPES[data.name]?.emissive || 0x003300;
                        mob.material.emissive.setHex(originalEmissive);
                    }
                }
            }
        }

        // v4.3: Boss Encounter System
        // v4.5: Added gear check requirements and increased mob kill thresholds
        const BOSS_TYPES = {
            'Terra_Boss': {
                name: 'Ancient Guardian',
                hp: 100, damage: 15, speed: 2, scale: 2.5,
                color: 0x228b22, emissive: 0x114411,
                drops: [{ item: 'Boss Trophy', count: 1 }, { item: 'Ancient Artifact', count: 3 }],
                xp: 1000, biome: 'Terra',
                spawnCondition: { mobsKilled: 8, minCombatLevel: 2 },
                attackWindup: 1000, attackRange: 4
            },
            'Desert_Boss': {
                name: 'Sandstorm Titan',
                hp: 120, damage: 18, speed: 3, scale: 2.8,
                color: 0xcc8844, emissive: 0x664422,
                drops: [{ item: 'Boss Trophy', count: 1 }, { item: 'Chitin', count: 10 }],
                xp: 1200, biome: 'Desert',
                spawnCondition: { mobsKilled: 10, minCombatLevel: 3, requiredItem: 'Sword' },
                attackWindup: 900, attackRange: 4.5
            },
            'Ice_Boss': {
                name: 'Frost Monarch',
                hp: 90, damage: 20, speed: 4, scale: 2.2,
                color: 0x88ddff, emissive: 0x4488aa,
                drops: [{ item: 'Boss Trophy', count: 1 }, { item: 'Frost Shard', count: 10 }],
                xp: 1100, biome: 'Ice',
                spawnCondition: { mobsKilled: 10, minCombatLevel: 4 },
                attackWindup: 700, attackRange: 5
            },
            'Volcanic_Boss': {
                name: 'Magma Colossus',
                hp: 150, damage: 25, speed: 1.5, scale: 3,
                color: 0xff4400, emissive: 0xaa2200,
                drops: [{ item: 'Boss Trophy', count: 1 }, { item: 'Magma Gem', count: 10 }],
                xp: 1500, biome: 'Volcanic',
                spawnCondition: { mobsKilled: 12, minCombatLevel: 5, requiredItem: 'Frost Blade' },
                attackWindup: 1500, attackRange: 5
            },
            'Alien_Boss': {
                name: 'Void Leviathan',
                hp: 200, damage: 30, speed: 3, scale: 3.5,
                color: 0x8800ff, emissive: 0x440088,
                drops: [{ item: 'Boss Trophy', count: 2 }, { item: 'Void Fragment', count: 15 }, { item: 'Legendary Core', count: 1 }],
                xp: 2500, biome: 'Alien',
                spawnCondition: { mobsKilled: 15, minCombatLevel: 7, requiredItem: 'Magma Sword' },
                attackWindup: 800, attackRange: 6
            }
        };

        // v4.2: Points of Interest System
        const POI_TYPES = {
            'ancient_ruins': {
                name: 'Ancient Ruins', icon: 'ðŸ›ï¸', rarity: 0.12,
                rewards: [{ item: 'Ancient Artifact', count: 1 }],
                xpBonus: 200, biomes: null
            },
            'crystal_cave': {
                name: 'Crystal Cavern', icon: 'ðŸ’Ž', rarity: 0.10,
                rewards: [{ item: 'Crystal', count: [2, 5] }],
                xpBonus: 150, biomes: ['Ice', 'Alien']
            },
            'oasis': {
                name: 'Hidden Oasis', icon: 'ðŸŒ´', rarity: 0.15,
                rewards: [{ item: 'Healing Spring', count: 1 }],
                xpBonus: 100, biomes: ['Desert']
            },
            'volcano_vent': {
                name: 'Volcanic Vent', icon: 'ðŸŒ‹', rarity: 0.12,
                rewards: [{ item: 'Obsidian', count: [1, 3] }],
                xpBonus: 175, biomes: ['Volcanic']
            },
            'crashed_ship': {
                name: 'Crashed Vessel', icon: 'ðŸ›¸', rarity: 0.06,
                rewards: [{ item: 'Tech Fragment', count: 1 }, { item: 'Power Cell', count: 1 }],
                xpBonus: 300, biomes: null
            },
            'mystic_shrine': {
                name: 'Mystic Shrine', icon: 'â›©ï¸', rarity: 0.08,
                rewards: [{ item: 'Mystic Orb', count: 1 }],
                xpBonus: 250, biomes: ['Terra', 'Alien']
            }
        };

        // v4.2: Player Ranks and Titles
        const PLAYER_RANKS = [
            { points: 0, title: 'Novice Explorer', color: '#888888' },
            { points: 100, title: 'Wanderer', color: '#44ff44' },
            { points: 500, title: 'Pathfinder', color: '#4488ff' },
            { points: 1500, title: 'Star Scout', color: '#ff8844' },
            { points: 5000, title: 'Galaxy Ranger', color: '#ff44ff' },
            { points: 15000, title: 'Cosmic Legend', color: '#ffd700' }
        ];

        const SPECIAL_TITLES = {
            'Slime Bane': { condition: (s, sk) => s.mobsKilled >= 100, color: '#ff4444' },
            'Master Lumberjack': { condition: (s, sk) => sk.wood.level >= 10, color: '#44aa44' },
            'Deep Miner': { condition: (s, sk) => sk.mining.level >= 10, color: '#888888' },
            'Cosmic Wanderer': { condition: (s, sk) => gameData.visitedPlanets.length >= 50, color: '#00ffff' },
            'Combat Master': { condition: (s, sk) => sk.combat.level >= 10, color: '#ff6644' },
            'Master Angler': { condition: (s, sk) => sk.fishing.level >= 10, color: '#4488ff' }
        };

        const ITEMS = {
            // Base resources
            'Log': { icon: 'ðŸªµ', stackable: true, maxStack: 99 },
            'Ore': { icon: 'ðŸª¨', stackable: true, maxStack: 99 },
            'Slime': { icon: 'ðŸŸ¢', stackable: true, maxStack: 99 },
            'Raw Fish': { icon: 'ðŸŸ', stackable: true, maxStack: 99 },
            'Cooked Fish': { icon: 'ðŸ–', stackable: true, maxStack: 99, heal: 20 },
            // v4.2: Biome-specific enemy drops
            'Chitin': { icon: 'ðŸ¦‚', stackable: true, maxStack: 99 },
            'Frost Shard': { icon: 'â„ï¸', stackable: true, maxStack: 99 },
            'Magma Gem': { icon: 'ðŸ”¥', stackable: true, maxStack: 99 },
            'Void Fragment': { icon: 'ðŸŒ€', stackable: true, maxStack: 99 },
            // v4.2: POI rewards
            'Ancient Artifact': { icon: 'ðŸº', stackable: true, maxStack: 20 },
            'Crystal': { icon: 'ðŸ’ ', stackable: true, maxStack: 50 },
            'Healing Spring': { icon: 'ðŸ’§', stackable: true, maxStack: 10, heal: 100 },
            'Obsidian': { icon: 'ðŸ–¤', stackable: true, maxStack: 50 },
            'Tech Fragment': { icon: 'ðŸ”§', stackable: true, maxStack: 20 },
            'Power Cell': { icon: 'ðŸ”‹', stackable: true, maxStack: 10 },
            'Mystic Orb': { icon: 'ðŸ”®', stackable: true, maxStack: 10 },
            // Tools
            'Pickaxe': { icon: 'â›ï¸', stackable: false, miningBonus: 2 },
            'Sword': { icon: 'ðŸ—¡ï¸', stackable: false, combatBonus: 5 },
            'Fishing Rod': { icon: 'ðŸŽ£', stackable: false, fishingBonus: 2 },
            'Health Potion': { icon: 'ðŸ§ª', stackable: true, maxStack: 10, heal: 50 },
            // v4.2: New craftables
            'Frost Blade': { icon: 'ðŸ—¡ï¸', stackable: false, combatBonus: 8, element: 'ice' },
            'Magma Sword': { icon: 'ðŸ—¡ï¸', stackable: false, combatBonus: 10, element: 'fire' },
            'Void Dagger': { icon: 'ðŸ—¡ï¸', stackable: false, combatBonus: 12, element: 'void' },
            'Crystal Pickaxe': { icon: 'â›ï¸', stackable: false, miningBonus: 3 },
            'Super Potion': { icon: 'ðŸ§ª', stackable: true, maxStack: 10, heal: 100 },
            'Chitin Armor': { icon: 'ðŸ›¡ï¸', stackable: false, defenseBonus: 5 },
            // v4.3: Boss rewards
            'Boss Trophy': { icon: 'ðŸ†', stackable: true, maxStack: 20 },
            'Legendary Core': { icon: 'ðŸ’Ž', stackable: true, maxStack: 5 },
            // v4.3: Legendary gear (requires boss materials)
            'Legendary Blade': { icon: 'âš”ï¸', stackable: false, combatBonus: 20, element: 'cosmic' },
            'Guardian Armor': { icon: 'ðŸ›¡ï¸', stackable: false, defenseBonus: 15 },
            // v4.7: Elite enemy drops
            'Elite Essence': { icon: 'ðŸ’ ', stackable: true, maxStack: 99 },
            'Berserker Badge': { icon: 'ðŸ”´', stackable: false, combatBonus: 15, attackSpeedMult: 1.3 },
            'Vampiric Fang': { icon: 'ðŸ¦·', stackable: false, combatBonus: 10, lifesteal: 0.15 },
            'Frost Heart': { icon: 'ðŸ’™', stackable: false, defenseBonus: 10, element: 'ice' },
            // v5.1: New craftable equipment
            'Iron Armor': { icon: 'ðŸ›¡ï¸', stackable: false, defenseBonus: 3 },
            'Steel Armor': { icon: 'ðŸ›¡ï¸', stackable: false, defenseBonus: 8 },
            'Lucky Charm': { icon: 'ðŸ€', stackable: false },
            'Swift Boots': { icon: 'ðŸ‘¢', stackable: false },
            'Power Ring': { icon: 'ðŸ’', stackable: false },
            'Master Rod': { icon: 'ðŸŽ£', stackable: false, fishingBonus: 4 },
            // v5.1: Enchantment materials
            'Enchant Shard': { icon: 'âœ¨', stackable: true, maxStack: 50 },
            'Arcane Dust': { icon: 'ðŸ’«', stackable: true, maxStack: 99 },
            // v5.3: Portal realm rewards
            'Shadow Essence': { icon: 'ðŸŒ‘', stackable: true, maxStack: 50 },
            'Dark Crystal': { icon: 'ðŸ”®', stackable: true, maxStack: 30 },
            'Frozen Heart': { icon: 'ðŸ’™', stackable: true, maxStack: 30 },
            'Permafrost Shard': { icon: 'â„ï¸', stackable: true, maxStack: 50 },
            'Infernal Core': { icon: 'ðŸ”¥', stackable: true, maxStack: 30 },
            'Magma Heart': { icon: 'â¤ï¸â€ðŸ”¥', stackable: true, maxStack: 30 },
            'Void Core': { icon: 'ðŸŒ€', stackable: true, maxStack: 20 },
            'Dimension Shard': { icon: 'ðŸ’ ', stackable: true, maxStack: 30 },
            'Celestial Essence': { icon: 'âœ¨', stackable: true, maxStack: 10 },
            'Star Fragment': { icon: 'â­', stackable: true, maxStack: 20 },
            'Mythic Orb': { icon: 'ðŸ”®', stackable: false, combatBonus: 25, element: 'cosmic', defenseBonus: 10 },
            // v5.4: World Event items
            'Meteor Ore': { icon: 'â˜„ï¸', stackable: true, maxStack: 30, description: 'Rare ore from a meteor shower' },
            'Cosmic Dust': { icon: 'ðŸŒŸ', stackable: true, maxStack: 99, description: 'Glittering cosmic particles' },
            'Gold Chest': { icon: 'ðŸ“¦', stackable: true, maxStack: 10, description: 'A treasure chest filled with gold' },
            'Silver Chest': { icon: 'ðŸ“¦', stackable: true, maxStack: 20, description: 'A treasure chest with silver' },
            'Ancient Relic': { icon: 'ðŸ—¿', stackable: true, maxStack: 10, description: 'An ancient relic of power' },
            'Rune Stone': { icon: 'ðŸª¨', stackable: true, maxStack: 20, description: 'Stone inscribed with ancient runes' },
            'Lost Technology': { icon: 'ðŸ”§', stackable: true, maxStack: 10, description: 'Advanced technology from a lost civilization' },
            'Rainbow Crystal': { icon: 'ðŸ’Ž', stackable: true, maxStack: 15, description: 'A crystal that shimmers with all colors' },
            'Pure Crystal': { icon: 'ðŸ’ ', stackable: true, maxStack: 20, description: 'A perfectly pure crystal' },
            'Crystal Shard': { icon: 'ðŸ”¹', stackable: true, maxStack: 50, description: 'A small crystal fragment' }
        };

        const RECIPES = {
            'pickaxe': { result: 'Pickaxe', requires: { 'Ore': 3, 'Log': 2 } },
            'sword': { result: 'Sword', requires: { 'Ore': 5, 'Log': 1 } },
            'rod': { result: 'Fishing Rod', requires: { 'Log': 2 } },
            'cookedFish': { result: 'Cooked Fish', requires: { 'Raw Fish': 1 } },
            'potion': { result: 'Health Potion', requires: { 'Slime': 2 } },
            // v4.2: New recipes using biome materials
            'frostBlade': { result: 'Frost Blade', requires: { 'Ore': 8, 'Frost Shard': 5 }, craftingLevel: 5 },
            'magmaSword': { result: 'Magma Sword', requires: { 'Ore': 10, 'Magma Gem': 5 }, craftingLevel: 7 },
            'voidDagger': { result: 'Void Dagger', requires: { 'Ore': 12, 'Void Fragment': 5 }, craftingLevel: 10 },
            'crystalPickaxe': { result: 'Crystal Pickaxe', requires: { 'Ore': 6, 'Crystal': 3 }, craftingLevel: 6 },
            'superPotion': { result: 'Super Potion', requires: { 'Slime': 3, 'Mystic Orb': 1 }, craftingLevel: 8 },
            'chitinArmor': { result: 'Chitin Armor', requires: { 'Chitin': 10, 'Log': 5 }, craftingLevel: 4 },
            // v4.3: Legendary recipes (requires boss materials)
            'legendaryBlade': { result: 'Legendary Blade', requires: { 'Boss Trophy': 5, 'Legendary Core': 1, 'Ore': 20 }, craftingLevel: 15 },
            'guardianArmor': { result: 'Guardian Armor', requires: { 'Boss Trophy': 3, 'Chitin': 20, 'Crystal': 5 }, craftingLevel: 12 },
            // v4.7: Elite gear recipes
            'berserkerBadge': { result: 'Berserker Badge', requires: { 'Elite Essence': 10, 'Magma Gem': 3 }, craftingLevel: 10 },
            'vampiricFang': { result: 'Vampiric Fang', requires: { 'Elite Essence': 15, 'Void Fragment': 5 }, craftingLevel: 12 },
            'frostHeart': { result: 'Frost Heart', requires: { 'Elite Essence': 12, 'Frost Shard': 8, 'Crystal': 3 }, craftingLevel: 11 },
            // v5.1: New equipment recipes
            'ironArmor': { result: 'Iron Armor', requires: { 'Ore': 8, 'Log': 3 }, craftingLevel: 2 },
            'steelArmor': { result: 'Steel Armor', requires: { 'Ore': 15, 'Crystal': 2 }, craftingLevel: 8 },
            'luckyCharm': { result: 'Lucky Charm', requires: { 'Crystal': 5, 'Mystic Orb': 2 }, craftingLevel: 6 },
            'swiftBoots': { result: 'Swift Boots', requires: { 'Chitin': 8, 'Slime': 5 }, craftingLevel: 5 },
            'powerRing': { result: 'Power Ring', requires: { 'Ore': 10, 'Magma Gem': 3 }, craftingLevel: 7 },
            'masterRod': { result: 'Master Rod', requires: { 'Log': 10, 'Crystal': 3, 'Frost Shard': 2 }, craftingLevel: 9 },
            // v5.1: Enchantment material crafting
            'enchantShard': { result: 'Enchant Shard', requires: { 'Crystal': 3, 'Mystic Orb': 1 }, craftingLevel: 8 },
            'arcaneDust': { result: 'Arcane Dust', requires: { 'Slime': 5, 'Void Fragment': 1 }, craftingLevel: 6 }
        };

        // v5.1: Equipment System
        const EQUIPMENT_SLOTS = {
            weapon: { name: 'Weapon', icon: 'âš”ï¸', statKey: 'combatBonus' },
            armor: { name: 'Armor', icon: 'ðŸ›¡ï¸', statKey: 'defenseBonus' },
            accessory: { name: 'Accessory', icon: 'ðŸ’', statKey: 'special' },
            tool: { name: 'Tool', icon: 'ðŸ”§', statKey: 'toolBonus' }
        };

        // v5.1: Map items to equipment slots
        const EQUIPMENT_MAP = {
            // Weapons
            'Sword': { slot: 'weapon', stats: { damage: 5 } },
            'Frost Blade': { slot: 'weapon', stats: { damage: 8, element: 'ice' } },
            'Magma Sword': { slot: 'weapon', stats: { damage: 10, element: 'fire' } },
            'Void Dagger': { slot: 'weapon', stats: { damage: 12, element: 'void' } },
            'Legendary Blade': { slot: 'weapon', stats: { damage: 20, element: 'cosmic', critChance: 0.15 } },
            // Armor (tiered)
            'Iron Armor': { slot: 'armor', stats: { defense: 3 } },
            'Chitin Armor': { slot: 'armor', stats: { defense: 5 } },
            'Steel Armor': { slot: 'armor', stats: { defense: 8 } },
            'Guardian Armor': { slot: 'armor', stats: { defense: 15, maxHpBonus: 50 } },
            // Accessories
            'Berserker Badge': { slot: 'accessory', stats: { damage: 15, attackSpeed: 1.3 } },
            'Vampiric Fang': { slot: 'accessory', stats: { damage: 10, lifesteal: 0.15 } },
            'Frost Heart': { slot: 'accessory', stats: { defense: 10, element: 'ice' } },
            'Lucky Charm': { slot: 'accessory', stats: { critChance: 0.10, lootBonus: 0.15 } },
            'Swift Boots': { slot: 'accessory', stats: { moveSpeed: 1.15, dodgeBonus: 0.1 } },
            'Power Ring': { slot: 'accessory', stats: { damage: 8, critChance: 0.05 } },
            // Tools
            'Pickaxe': { slot: 'tool', stats: { miningBonus: 2 } },
            'Crystal Pickaxe': { slot: 'tool', stats: { miningBonus: 3 } },
            'Fishing Rod': { slot: 'tool', stats: { fishingBonus: 2 } },
            'Master Rod': { slot: 'tool', stats: { fishingBonus: 4 } }
        };

        // v5.1: Equipment state getter (uses gameData for persistence)
        function getEquippedGear() {
            if (!gameData.equipment) {
                gameData.equipment = { weapon: null, armor: null, accessory: null, tool: null };
            }
            return gameData.equipment;
        }

        // v5.1: Equipment functions
        function isEquippable(itemName) {
            return EQUIPMENT_MAP.hasOwnProperty(itemName);
        }

        function getEquipmentSlot(itemName) {
            return EQUIPMENT_MAP[itemName]?.slot || null;
        }

        function equipItem(itemName) {
            if (!isEquippable(itemName)) {
                showNotification('Cannot equip this item!', 'error');
                return false;
            }

            const slot = getEquipmentSlot(itemName);
            const equipData = EQUIPMENT_MAP[itemName];
            const gear = getEquippedGear();

            // Unequip current item in slot (return to inventory)
            if (gear[slot]) {
                addItem(gear[slot]);
                showNotification(`Unequipped ${gear[slot]}`, 'info');
            }

            // Remove from inventory
            if (!removeItem(itemName, 1)) {
                showNotification('Item not in inventory!', 'error');
                return false;
            }

            // Equip new item
            gear[slot] = itemName;
            showNotification(`Equipped ${itemName}!`, 'success');
            AudioSystem.collect();
            updateEquipmentUI();
            saveGameData();
            return true;
        }

        function unequipItem(slot) {
            const gear = getEquippedGear();
            if (!gear[slot]) return;

            const itemName = gear[slot];
            if (gameData.inventory.length >= 20) {
                showNotification('Inventory full!', 'error');
                return;
            }

            addItem(itemName);
            gear[slot] = null;
            showNotification(`Unequipped ${itemName}`, 'info');
            updateEquipmentUI();
            saveGameData();
        }

        function getEquipmentStats() {
            const stats = {
                damage: 0,
                defense: 0,
                miningBonus: 0,
                fishingBonus: 0,
                attackSpeed: 1.0,
                lifesteal: 0,
                critChance: 0,
                maxHpBonus: 0,
                element: null,
                // v5.1: New stats
                moveSpeed: 1.0,
                lootBonus: 0,
                dodgeBonus: 0
            };

            const gear = getEquippedGear();
            for (const slot of Object.keys(gear)) {
                const itemName = gear[slot];
                if (!itemName) continue;

                const equipData = EQUIPMENT_MAP[itemName];
                if (!equipData) continue;

                for (const [stat, value] of Object.entries(equipData.stats)) {
                    if (stat === 'element') {
                        stats.element = value;
                    } else if (stat === 'attackSpeed' || stat === 'moveSpeed') {
                        // Multiplicative stats
                        stats[stat] *= value;
                    } else {
                        stats[stat] = (stats[stat] || 0) + value;
                    }
                }

                // v5.1: Add enchantment bonuses
                const enchantBonuses = getEnchantmentBonuses(itemName);
                for (const [stat, value] of Object.entries(enchantBonuses)) {
                    if (stat === 'moveSpeed') {
                        stats[stat] *= value; // Multiplicative for move speed enchants
                    } else {
                        stats[stat] = (stats[stat] || 0) + value;
                    }
                }
            }

            return stats;
        }

        function updateEquipmentUI() {
            const gear = getEquippedGear();
            for (const [slot, slotInfo] of Object.entries(EQUIPMENT_SLOTS)) {
                const slotEl = document.getElementById(`equip-slot-${slot}`);
                if (!slotEl) continue;

                const itemName = gear[slot];
                const iconEl = slotEl.querySelector('.equip-icon');
                const nameEl = slotEl.querySelector('.equip-name');

                if (itemName) {
                    const itemDef = ITEMS[itemName];
                    iconEl.textContent = itemDef?.icon || '?';
                    nameEl.textContent = itemName;
                    slotEl.classList.add('equipped');
                } else {
                    iconEl.textContent = slotInfo.icon;
                    nameEl.textContent = 'Empty';
                    slotEl.classList.remove('equipped');
                }
            }

            // Update stats display
            const stats = getEquipmentStats();
            const statsEl = document.getElementById('equipment-stats');
            if (statsEl) {
                let html = `
                    <div style="color: #f44;">âš”ï¸ +${stats.damage} DMG</div>
                    <div style="color: #4af;">ðŸ›¡ï¸ +${stats.defense} DEF</div>
                `;
                if (stats.critChance > 0) html += `<div style="color: #fa4;">ðŸŽ¯ +${Math.round(stats.critChance * 100)}% Crit</div>`;
                if (stats.lifesteal > 0) html += `<div style="color: #4f4;">ðŸ’š ${Math.round(stats.lifesteal * 100)}% Lifesteal</div>`;
                if (stats.attackSpeed !== 1.0) html += `<div style="color: #ff4;">âš¡ ${Math.round(stats.attackSpeed * 100)}% ATK Spd</div>`;
                if (stats.moveSpeed !== 1.0) html += `<div style="color: #8ff;">ðŸ‘¢ ${Math.round(stats.moveSpeed * 100)}% Move Spd</div>`;
                if (stats.lootBonus > 0) html += `<div style="color: #8f8;">ðŸ€ +${Math.round(stats.lootBonus * 100)}% Loot</div>`;
                if (stats.dodgeBonus > 0) html += `<div style="color: #88f;">ðŸ’¨ +${Math.round(stats.dodgeBonus * 100)}% Dodge</div>`;
                statsEl.innerHTML = html;
            }
        }

        // v5.1: Enchantment System
        const ENCHANTMENTS = {
            sharpness: { name: 'Sharpness', icon: 'ðŸ”ª', stat: 'damage', bonus: 3, slots: ['weapon'], cost: { 'Enchant Shard': 2, 'Arcane Dust': 5 } },
            fortify: { name: 'Fortify', icon: 'ðŸ°', stat: 'defense', bonus: 2, slots: ['armor'], cost: { 'Enchant Shard': 2, 'Arcane Dust': 5 } },
            swiftness: { name: 'Swiftness', icon: 'ðŸ’¨', stat: 'moveSpeed', bonus: 0.05, slots: ['accessory'], cost: { 'Enchant Shard': 1, 'Arcane Dust': 3 }, multiplicative: true },
            luck: { name: 'Luck', icon: 'ðŸ€', stat: 'lootBonus', bonus: 0.05, slots: ['accessory'], cost: { 'Enchant Shard': 3, 'Arcane Dust': 8 } },
            efficiency: { name: 'Efficiency', icon: 'âš¡', stat: 'miningBonus', bonus: 1, slots: ['tool'], cost: { 'Enchant Shard': 2, 'Arcane Dust': 4 } },
            lure: { name: 'Lure', icon: 'ðŸŽ£', stat: 'fishingBonus', bonus: 1, slots: ['tool'], cost: { 'Enchant Shard': 2, 'Arcane Dust': 4 } },
            critical: { name: 'Critical', icon: 'ðŸŽ¯', stat: 'critChance', bonus: 0.05, slots: ['weapon', 'accessory'], cost: { 'Enchant Shard': 4, 'Arcane Dust': 10 } },
            vampiric: { name: 'Vampiric', icon: 'ðŸ¦‡', stat: 'lifesteal', bonus: 0.05, slots: ['weapon'], cost: { 'Enchant Shard': 5, 'Arcane Dust': 15 } }
        };

        // v5.1: Get enchantments for an item
        function getItemEnchantments(itemName) {
            if (!gameData.enchantments) gameData.enchantments = {};
            return gameData.enchantments[itemName] || [];
        }

        // v5.1: Check if enchantment can be applied
        function canEnchant(itemName, enchantId) {
            const equipData = EQUIPMENT_MAP[itemName];
            if (!equipData) return false;

            const enchant = ENCHANTMENTS[enchantId];
            if (!enchant) return false;

            // Check slot compatibility
            if (!enchant.slots.includes(equipData.slot)) return false;

            // Check if already has this enchantment
            const currentEnchants = getItemEnchantments(itemName);
            if (currentEnchants.includes(enchantId)) return false;

            // Check max enchantments (3 per item)
            if (currentEnchants.length >= 3) return false;

            // Check materials
            for (const [mat, count] of Object.entries(enchant.cost)) {
                if (!hasItem(mat, count)) return false;
            }

            return true;
        }

        // v5.1: Apply enchantment to item
        function applyEnchantment(itemName, enchantId) {
            if (!canEnchant(itemName, enchantId)) {
                showNotification('Cannot apply this enchantment!', 'error');
                return false;
            }

            const enchant = ENCHANTMENTS[enchantId];

            // Consume materials
            for (const [mat, count] of Object.entries(enchant.cost)) {
                removeItem(mat, count);
            }

            // Apply enchantment
            if (!gameData.enchantments) gameData.enchantments = {};
            if (!gameData.enchantments[itemName]) gameData.enchantments[itemName] = [];
            gameData.enchantments[itemName].push(enchantId);

            showNotification(`Applied ${enchant.icon} ${enchant.name} to ${itemName}!`, 'success');
            AudioSystem.levelUp();
            saveGameData();
            updateEnchantModal();
            updateEquipmentUI();
            return true;
        }

        // v5.1: Get total stats including enchantments
        function getEnchantmentBonuses(itemName) {
            const bonuses = {};
            const enchants = getItemEnchantments(itemName);

            for (const enchantId of enchants) {
                const enchant = ENCHANTMENTS[enchantId];
                if (!enchant) continue;

                if (enchant.multiplicative) {
                    bonuses[enchant.stat] = (bonuses[enchant.stat] || 1) * (1 + enchant.bonus);
                } else {
                    bonuses[enchant.stat] = (bonuses[enchant.stat] || 0) + enchant.bonus;
                }
            }

            return bonuses;
        }

        // v5.1: Show enchant modal
        function showEnchantModal() {
            document.getElementById('enchant-modal').style.display = 'flex';
            updateEnchantModal();
        }

        function closeEnchantModal() {
            document.getElementById('enchant-modal').style.display = 'none';
        }

        function updateEnchantModal() {
            const gear = getEquippedGear();
            const itemsDiv = document.getElementById('enchant-items');
            const enchantsDiv = document.getElementById('enchant-options');

            // List equipped items
            let itemsHtml = '';
            for (const [slot, itemName] of Object.entries(gear)) {
                if (!itemName) continue;
                const itemDef = ITEMS[itemName];
                const enchants = getItemEnchantments(itemName);
                const enchantIcons = enchants.map(e => ENCHANTMENTS[e]?.icon || '?').join('');
                itemsHtml += `
                    <div class="enchant-item" onclick="selectEnchantItem('${itemName}')" data-item="${itemName}"
                         style="display: flex; justify-content: space-between; padding: 8px; border: 1px solid #444;
                                border-radius: 4px; cursor: pointer; margin-bottom: 5px;">
                        <span>${itemDef?.icon || '?'} ${itemName}</span>
                        <span style="color: #8af;">${enchantIcons || 'No enchants'}</span>
                    </div>
                `;
            }
            itemsDiv.innerHTML = itemsHtml || '<div style="color: #888;">Equip items first!</div>';

            // Default: no item selected
            enchantsDiv.innerHTML = '<div style="color: #888;">Select an item to enchant</div>';
        }

        let selectedEnchantItem = null;

        function selectEnchantItem(itemName) {
            selectedEnchantItem = itemName;
            const equipData = EQUIPMENT_MAP[itemName];
            const enchantsDiv = document.getElementById('enchant-options');

            // Highlight selected item
            document.querySelectorAll('.enchant-item').forEach(el => {
                el.style.background = el.dataset.item === itemName ? 'rgba(68, 136, 255, 0.2)' : '';
                el.style.borderColor = el.dataset.item === itemName ? '#4af' : '#444';
            });

            // Show available enchantments
            let html = '<div style="font-weight: bold; margin-bottom: 10px;">Available Enchantments:</div>';

            for (const [id, enchant] of Object.entries(ENCHANTMENTS)) {
                if (!enchant.slots.includes(equipData.slot)) continue;

                const canApply = canEnchant(itemName, id);
                const hasIt = getItemEnchantments(itemName).includes(id);
                const costStr = Object.entries(enchant.cost).map(([m, c]) => `${c}x ${m}`).join(', ');

                html += `
                    <div style="padding: 8px; border: 1px solid ${hasIt ? '#4a4' : canApply ? '#448' : '#333'};
                                border-radius: 4px; margin-bottom: 5px; background: ${hasIt ? 'rgba(68,170,68,0.15)' : 'rgba(0,0,0,0.3)'};">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <span>${enchant.icon} ${enchant.name}</span>
                            ${hasIt ? '<span style="color: #4f4;">âœ“ Applied</span>' :
                              canApply ? `<button onclick="applyEnchantment('${itemName}', '${id}')" style="padding: 4px 8px; cursor: pointer;">Apply</button>` :
                              '<span style="color: #666;">Need materials</span>'}
                        </div>
                        <div style="font-size: 11px; color: #888; margin-top: 4px;">+${enchant.bonus}${enchant.multiplicative ? '%' : ''} ${enchant.stat} | Cost: ${costStr}</div>
                    </div>
                `;
            }

            enchantsDiv.innerHTML = html;
        }

        // v5.2: Talent Tree System
        const TALENT_TREES = {
            combat: {
                name: 'Combat Mastery', icon: 'âš”ï¸', color: '#ff4444',
                talents: {
                    brutality: { name: 'Brutality', desc: '+5% damage per rank', maxRank: 5, effect: { damage: 0.05 } },
                    toughness: { name: 'Toughness', desc: '+10 max HP per rank', maxRank: 5, effect: { maxHp: 10 } },
                    precision: { name: 'Precision', desc: '+2% crit chance per rank', maxRank: 5, effect: { critChance: 0.02 }, requires: 'brutality' },
                    bloodlust: { name: 'Bloodlust', desc: '+1% lifesteal per rank', maxRank: 3, effect: { lifesteal: 0.01 }, requires: 'precision' },
                    warlord: { name: 'Warlord', desc: '+10% ability damage', maxRank: 1, effect: { abilityDamage: 0.10 }, requires: 'bloodlust' }
                }
            },
            survival: {
                name: 'Survival Instinct', icon: 'ðŸ›¡ï¸', color: '#44aaff',
                talents: {
                    thick_skin: { name: 'Thick Skin', desc: '+2 defense per rank', maxRank: 5, effect: { defense: 2 } },
                    evasion: { name: 'Evasion', desc: '+3% dodge chance per rank', maxRank: 5, effect: { dodgeChance: 0.03 } },
                    second_wind: { name: 'Second Wind', desc: '+5% HP regen per rank', maxRank: 3, effect: { hpRegen: 0.05 }, requires: 'thick_skin' },
                    fortress: { name: 'Fortress', desc: '+20% shield duration', maxRank: 3, effect: { shieldDuration: 0.20 }, requires: 'evasion' },
                    immortal: { name: 'Immortal', desc: 'Survive fatal blow once/world', maxRank: 1, effect: { deathSave: true }, requires: 'second_wind' }
                }
            },
            fortune: {
                name: 'Fortune Seeker', icon: 'ðŸ€', color: '#44ff44',
                talents: {
                    lucky: { name: 'Lucky', desc: '+3% loot drop per rank', maxRank: 5, effect: { lootBonus: 0.03 } },
                    harvester: { name: 'Harvester', desc: '+10% resource yield per rank', maxRank: 5, effect: { resourceYield: 0.10 } },
                    treasure_sense: { name: 'Treasure Sense', desc: '+5% rare find per rank', maxRank: 3, effect: { rareFind: 0.05 }, requires: 'lucky' },
                    midas_touch: { name: 'Midas Touch', desc: '+15% XP gain per rank', maxRank: 3, effect: { xpBonus: 0.15 }, requires: 'harvester' },
                    jackpot: { name: 'Jackpot', desc: 'Double boss loot chance', maxRank: 1, effect: { doubleBossLoot: true }, requires: 'treasure_sense' }
                }
            }
        };

        // v5.2: Get talent points available
        function getTalentPoints() {
            const totalLevels = Object.values(gameData.skills).reduce((sum, s) => sum + s.level, 0);
            const pointsEarned = Math.floor(totalLevels / 5); // 1 point per 5 total skill levels
            const pointsSpent = getSpentTalentPoints();
            return { earned: pointsEarned, spent: pointsSpent, available: pointsEarned - pointsSpent };
        }

        function getSpentTalentPoints() {
            if (!gameData.talents) gameData.talents = {};
            let spent = 0;
            for (const treeId of Object.keys(TALENT_TREES)) {
                const treeTalents = gameData.talents[treeId] || {};
                for (const [talentId, rank] of Object.entries(treeTalents)) {
                    spent += rank;
                }
            }
            return spent;
        }

        function getTalentRank(treeId, talentId) {
            if (!gameData.talents) gameData.talents = {};
            if (!gameData.talents[treeId]) gameData.talents[treeId] = {};
            return gameData.talents[treeId][talentId] || 0;
        }

        function canUnlockTalent(treeId, talentId) {
            const tree = TALENT_TREES[treeId];
            const talent = tree.talents[talentId];
            const currentRank = getTalentRank(treeId, talentId);

            // Check max rank
            if (currentRank >= talent.maxRank) return false;

            // Check points available
            if (getTalentPoints().available <= 0) return false;

            // Check prerequisite
            if (talent.requires) {
                const reqRank = getTalentRank(treeId, talent.requires);
                const reqTalent = tree.talents[talent.requires];
                if (reqRank < reqTalent.maxRank) return false;
            }

            return true;
        }

        function unlockTalent(treeId, talentId) {
            if (!canUnlockTalent(treeId, talentId)) {
                showNotification('Cannot unlock this talent!', 'error');
                return false;
            }

            if (!gameData.talents) gameData.talents = {};
            if (!gameData.talents[treeId]) gameData.talents[treeId] = {};
            gameData.talents[treeId][talentId] = (gameData.talents[treeId][talentId] || 0) + 1;

            const tree = TALENT_TREES[treeId];
            const talent = tree.talents[talentId];
            showNotification(`Unlocked ${talent.name}!`, 'success');
            AudioSystem.levelUp();
            saveGameData();
            updateTalentModal();
            return true;
        }

        function getTalentBonuses() {
            const bonuses = {
                damage: 0, maxHp: 0, critChance: 0, lifesteal: 0, abilityDamage: 0,
                defense: 0, dodgeChance: 0, hpRegen: 0, shieldDuration: 0, deathSave: false,
                lootBonus: 0, resourceYield: 0, rareFind: 0, xpBonus: 0, doubleBossLoot: false
            };

            for (const [treeId, tree] of Object.entries(TALENT_TREES)) {
                for (const [talentId, talent] of Object.entries(tree.talents)) {
                    const rank = getTalentRank(treeId, talentId);
                    if (rank > 0) {
                        for (const [stat, value] of Object.entries(talent.effect)) {
                            if (typeof value === 'boolean') {
                                bonuses[stat] = value;
                            } else {
                                bonuses[stat] = (bonuses[stat] || 0) + (value * rank);
                            }
                        }
                    }
                }
            }

            return bonuses;
        }

        // ============================================
        // v5.13: SHIP DEFENSE SYSTEM
        // Visible ship on world map with defensive laser
        // ============================================
        const SHIP_STATE = {
            mesh: null,
            landingPad: null,
            hp: 100,
            maxHp: 100,
            position: new THREE.Vector3(0, 0, 0),
            laser: {
                active: false,
                target: null,
                beam: null,
                cooldown: 0,
                lastFire: 0,
                damage: 15,
                range: 35,
                fireRate: 800,  // ms between shots
                autoDefend: true
            },
            propellers: [],
            thrustLight: null,
            damaged: false,
            repairCost: 50,  // gold to repair
            // v5.15: Defense tracking system
            defenseLog: {
                // Statistics
                totalEngagements: 0,        // Times laser fired
                totalKills: 0,              // Enemies killed by ship
                totalDamageDealt: 0,        // Total damage output
                entitiesDeterred: 0,        // Enemies that fled after being hit
                timesAttacked: 0,           // Times ship was attacked
                totalDamageTaken: 0,        // Total damage received
                repairsPerformed: 0,        // Times repaired
                totalRepairCost: 0,         // Gold spent on repairs
                timesDestroyed: 0,          // Times ship was destroyed
                // Recent events log (rolling buffer of last 50)
                events: [],
                maxEvents: 50
            }
        };

        // v5.15: Log a defense event
        function logDefenseEvent(eventType, data = {}) {
            const log = SHIP_STATE.defenseLog;
            const timestamp = Date.now();
            const event = {
                type: eventType,
                timestamp: timestamp,
                time: new Date(timestamp).toLocaleTimeString(),
                ...data
            };

            // Add to events array (rolling buffer)
            log.events.push(event);
            if (log.events.length > log.maxEvents) {
                log.events.shift();
            }

            // Update statistics based on event type
            switch (eventType) {
                case 'laser_fired':
                    log.totalEngagements++;
                    log.totalDamageDealt += data.damage || 0;
                    break;
                case 'enemy_killed':
                    log.totalKills++;
                    break;
                case 'enemy_deterred':
                    log.entitiesDeterred++;
                    break;
                case 'ship_attacked':
                    log.timesAttacked++;
                    log.totalDamageTaken += data.damage || 0;
                    break;
                case 'ship_repaired':
                    log.repairsPerformed++;
                    log.totalRepairCost += data.cost || 0;
                    break;
                case 'ship_destroyed':
                    log.timesDestroyed++;
                    break;
            }

            // Update defense log UI if open
            updateDefenseLogUI();

            return event;
        }

        // Get formatted defense statistics
        function getDefenseStats() {
            const log = SHIP_STATE.defenseLog;
            return {
                engagements: log.totalEngagements,
                kills: log.totalKills,
                damageDealt: log.totalDamageDealt,
                deterred: log.entitiesDeterred,
                attacked: log.timesAttacked,
                damageTaken: log.totalDamageTaken,
                repairs: log.repairsPerformed,
                repairCost: log.totalRepairCost,
                destroyed: log.timesDestroyed,
                killRatio: log.totalEngagements > 0 ? (log.totalKills / log.totalEngagements * 100).toFixed(1) : 0,
                recentEvents: log.events.slice(-10).reverse()
            };
        }

        // v5.15: Toggle defense log panel visibility
        function toggleDefenseLog() {
            const panel = document.getElementById('defense-stats');
            if (panel) {
                const isVisible = panel.style.display !== 'none';
                panel.style.display = isVisible ? 'none' : 'block';
                if (!isVisible) {
                    updateDefenseLogUI();
                }
            }
        }

        // v5.15: Update defense log UI with current stats and events
        function updateDefenseLogUI() {
            const stats = getDefenseStats();

            // Update stat displays
            const updateElement = (id, value) => {
                const el = document.getElementById(id);
                if (el) el.textContent = value;
            };

            updateElement('stat-engagements', stats.engagements);
            updateElement('stat-kills', stats.kills);
            updateElement('stat-damage-dealt', stats.damageDealt);
            updateElement('stat-deterred', stats.deterred);
            updateElement('stat-attacked', stats.attacked);
            updateElement('stat-damage-taken', stats.damageTaken);
            updateElement('stat-kill-rate', stats.killRatio + '%');
            updateElement('stat-repairs', stats.repairs);

            // Update events log
            const eventsLog = document.getElementById('defense-events-log');
            if (!eventsLog) return;

            const events = SHIP_STATE.defenseLog.events;
            if (events.length === 0) {
                eventsLog.innerHTML = '<div style="color: #666; text-align: center; padding: 10px;">No events yet</div>';
                return;
            }

            // Format events (newest first)
            const eventHTML = events.slice().reverse().map(event => {
                let icon = 'ðŸ“';
                let color = '#888';
                let text = '';

                switch (event.type) {
                    case 'laser_fired':
                        icon = 'ðŸ”«';
                        color = '#ff8800';
                        text = `Fired at ${event.targetName || 'enemy'} (${event.damage} dmg)`;
                        break;
                    case 'enemy_killed':
                        icon = 'ðŸ’€';
                        color = '#ff4444';
                        text = `Killed ${event.enemyName || 'enemy'} (+${event.threat || 0} threat neutralized)`;
                        break;
                    case 'enemy_deterred':
                        icon = 'ðŸƒ';
                        color = '#88ff88';
                        text = `${event.enemyName || 'Enemy'} fled after sustaining damage`;
                        break;
                    case 'ship_attacked':
                        icon = 'âš ï¸';
                        color = '#ff6666';
                        text = `Attacked by ${event.attackerName || 'enemy'} (${event.damage} dmg)`;
                        break;
                    case 'ship_repaired':
                        icon = 'ðŸ”§';
                        color = '#ffff88';
                        text = `Repaired hull (+${event.hpRestored} HP, -${event.cost}g)`;
                        break;
                    case 'ship_destroyed':
                        icon = 'ðŸ’¥';
                        color = '#ff0000';
                        text = `SHIP DESTROYED by ${event.finalBlow || 'enemy'}!`;
                        break;
                }

                return `<div style="padding: 3px 0; border-bottom: 1px solid rgba(255,255,255,0.1); color: ${color};">
                    <span style="opacity: 0.6;">${event.time}</span> ${icon} ${text}
                </div>`;
            }).join('');

            eventsLog.innerHTML = eventHTML;
        }

        // Create ship mesh for world map
        function createWorldShip(spawnPosition) {
            const shipGroup = new THREE.Group();

            // Main body - sleek fuselage
            const bodyGeometry = new THREE.BoxGeometry(4, 1.5, 5);
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: 0x2a2a3a,
                metalness: 0.7,
                roughness: 0.3
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = true;
            body.receiveShadow = true;
            shipGroup.add(body);

            // Cockpit dome
            const cockpitGeometry = new THREE.SphereGeometry(1.2, 16, 16);
            const cockpitMaterial = new THREE.MeshStandardMaterial({
                color: 0x00ffff,
                metalness: 0.9,
                roughness: 0.1,
                emissive: 0x004444,
                emissiveIntensity: 0.5
            });
            const cockpit = new THREE.Mesh(cockpitGeometry, cockpitMaterial);
            cockpit.position.set(0, 0.8, 0.5);
            cockpit.scale.set(1, 0.5, 1.2);
            shipGroup.add(cockpit);

            // Wings
            const wingGeometry = new THREE.BoxGeometry(8, 0.2, 2);
            const wingMaterial = new THREE.MeshStandardMaterial({
                color: 0x3a3a4a,
                metalness: 0.6,
                roughness: 0.4
            });
            const wings = new THREE.Mesh(wingGeometry, wingMaterial);
            wings.position.set(0, 0.3, -0.5);
            wings.castShadow = true;
            shipGroup.add(wings);

            // Wing tips with lights
            const tipGeometry = new THREE.BoxGeometry(0.5, 0.3, 0.5);
            const tipMaterialL = new THREE.MeshStandardMaterial({
                color: 0xff0000,
                emissive: 0xff0000,
                emissiveIntensity: 1
            });
            const tipMaterialR = new THREE.MeshStandardMaterial({
                color: 0x00ff00,
                emissive: 0x00ff00,
                emissiveIntensity: 1
            });
            const tipL = new THREE.Mesh(tipGeometry, tipMaterialL);
            const tipR = new THREE.Mesh(tipGeometry, tipMaterialR);
            tipL.position.set(-4, 0.3, -0.5);
            tipR.position.set(4, 0.3, -0.5);
            shipGroup.add(tipL, tipR);

            // Tail fin
            const tailGeometry = new THREE.BoxGeometry(0.3, 2, 1);
            const tail = new THREE.Mesh(tailGeometry, wingMaterial);
            tail.position.set(0, 1, -2);
            tail.castShadow = true;
            shipGroup.add(tail);

            // Engine pods
            const engineGeometry = new THREE.CylinderGeometry(0.4, 0.5, 2, 8);
            const engineMaterial = new THREE.MeshStandardMaterial({
                color: 0x1a1a2a,
                metalness: 0.8,
                roughness: 0.2
            });
            [-2, 2].forEach(x => {
                const engine = new THREE.Mesh(engineGeometry, engineMaterial);
                engine.rotation.x = Math.PI / 2;
                engine.position.set(x, 0, -2);
                engine.castShadow = true;
                shipGroup.add(engine);

                // Engine glow
                const glowGeometry = new THREE.CircleGeometry(0.4, 16);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ff88,
                    transparent: true,
                    opacity: 0.8
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                glow.rotation.x = -Math.PI / 2;
                glow.position.set(x, 0, -3);
                shipGroup.add(glow);
            });

            // Laser turret on top
            const turretBaseGeo = new THREE.CylinderGeometry(0.5, 0.6, 0.4, 8);
            const turretMaterial = new THREE.MeshStandardMaterial({
                color: 0x444455,
                metalness: 0.8
            });
            const turretBase = new THREE.Mesh(turretBaseGeo, turretMaterial);
            turretBase.position.set(0, 1.1, -0.5);
            shipGroup.add(turretBase);

            const turretBarrelGeo = new THREE.CylinderGeometry(0.15, 0.15, 1.5, 8);
            const turretBarrel = new THREE.Mesh(turretBarrelGeo, turretMaterial);
            turretBarrel.rotation.z = Math.PI / 2;
            turretBarrel.position.set(0, 1.5, -0.5);
            shipGroup.add(turretBarrel);
            shipGroup.userData.turretBarrel = turretBarrel;

            // Laser beam (initially invisible)
            const laserGeometry = new THREE.CylinderGeometry(0.05, 0.05, 1, 8);
            const laserMaterial = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                transparent: true,
                opacity: 0.9
            });
            const laserBeam = new THREE.Mesh(laserGeometry, laserMaterial);
            laserBeam.visible = false;
            shipGroup.add(laserBeam);
            SHIP_STATE.laser.beam = laserBeam;

            // Landing gear
            const gearGeometry = new THREE.BoxGeometry(0.3, 0.8, 0.3);
            const gearMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
            [[-1.5, -1, 1], [1.5, -1, 1], [0, -1, -2]].forEach(pos => {
                const gear = new THREE.Mesh(gearGeometry, gearMaterial);
                gear.position.set(...pos);
                gear.castShadow = true;
                shipGroup.add(gear);
            });

            // Position ship at spawn point (landing zone)
            shipGroup.position.copy(spawnPosition);
            shipGroup.position.y = spawnPosition.y + 2;  // Slightly above ground
            shipGroup.rotation.y = Math.random() * Math.PI * 2;

            SHIP_STATE.mesh = shipGroup;
            SHIP_STATE.position.copy(spawnPosition);

            return shipGroup;
        }

        // Create landing pad/zone marker
        function createLandingZone(position) {
            const padGroup = new THREE.Group();

            // Landing pad - circular platform
            const padGeometry = new THREE.CylinderGeometry(10, 10, 0.3, 32);
            const padMaterial = new THREE.MeshStandardMaterial({
                color: 0x333344,
                metalness: 0.5,
                roughness: 0.5
            });
            const pad = new THREE.Mesh(padGeometry, padMaterial);
            pad.receiveShadow = true;
            padGroup.add(pad);

            // Landing markings - concentric rings
            [8, 6, 4].forEach((r, i) => {
                const ringGeo = new THREE.RingGeometry(r - 0.2, r, 32);
                const ringMat = new THREE.MeshBasicMaterial({
                    color: i === 0 ? 0xffff00 : 0x00ff00,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.7
                });
                const ring = new THREE.Mesh(ringGeo, ringMat);
                ring.rotation.x = -Math.PI / 2;
                ring.position.y = 0.2;
                padGroup.add(ring);
            });

            // Corner beacons
            for (let i = 0; i < 4; i++) {
                const angle = (i / 4) * Math.PI * 2;
                const beaconGeo = new THREE.CylinderGeometry(0.3, 0.4, 2, 8);
                const beaconMat = new THREE.MeshStandardMaterial({
                    color: 0x444444,
                    metalness: 0.6
                });
                const beacon = new THREE.Mesh(beaconGeo, beaconMat);
                beacon.position.set(Math.cos(angle) * 9, 1, Math.sin(angle) * 9);
                padGroup.add(beacon);

                // Beacon light
                const lightGeo = new THREE.SphereGeometry(0.35, 8, 8);
                const lightMat = new THREE.MeshBasicMaterial({
                    color: 0x00ff88,
                    transparent: true,
                    opacity: 0.9
                });
                const light = new THREE.Mesh(lightGeo, lightMat);
                light.position.set(Math.cos(angle) * 9, 2.2, Math.sin(angle) * 9);
                light.userData.isBeacon = true;
                light.userData.phase = i * Math.PI / 2;
                padGroup.add(light);
            }

            // HP shield dome (visible when damaged)
            const shieldGeo = new THREE.SphereGeometry(12, 32, 32);
            const shieldMat = new THREE.MeshBasicMaterial({
                color: 0x00aaff,
                transparent: true,
                opacity: 0,
                side: THREE.DoubleSide,
                wireframe: true
            });
            const shield = new THREE.Mesh(shieldGeo, shieldMat);
            shield.position.y = 5;
            padGroup.add(shield);
            padGroup.userData.shield = shield;

            padGroup.position.copy(position);

            SHIP_STATE.landingPad = padGroup;
            return padGroup;
        }

        // Update ship defense system
        function updateShipDefense(dt, time) {
            if (!SHIP_STATE.mesh || mode !== 'world') return;

            // Animate beacon lights
            if (SHIP_STATE.landingPad) {
                SHIP_STATE.landingPad.children.forEach(child => {
                    if (child.userData.isBeacon) {
                        const pulse = (Math.sin(time * 0.003 + child.userData.phase) + 1) / 2;
                        child.material.opacity = 0.5 + pulse * 0.5;
                    }
                });

                // Shield visibility based on recent damage
                const shield = SHIP_STATE.landingPad.userData.shield;
                if (shield) {
                    if (SHIP_STATE.damaged) {
                        shield.material.opacity = Math.min(0.3, shield.material.opacity + dt * 0.5);
                        shield.rotation.y += dt * 0.5;
                    } else {
                        shield.material.opacity = Math.max(0, shield.material.opacity - dt * 0.2);
                    }
                }
            }

            // Auto-defend: Find and shoot nearby mobs
            if (SHIP_STATE.laser.autoDefend && time - SHIP_STATE.laser.lastFire > SHIP_STATE.laser.fireRate) {
                let nearestMob = null;
                let nearestDist = SHIP_STATE.laser.range;

                worldState.mobs.forEach(mob => {
                    if (!mob.parent || mob.userData.hp <= 0) return;
                    const dist = SHIP_STATE.mesh.position.distanceTo(mob.position);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearestMob = mob;
                    }
                });

                if (nearestMob) {
                    fireShipLaser(nearestMob, time);
                }
            }

            // Update laser beam visual
            updateLaserBeam(dt, time);

            // Mobs attacking ship
            worldState.mobs.forEach(mob => {
                if (!mob.parent || mob.userData.hp <= 0) return;

                const distToShip = mob.position.distanceTo(SHIP_STATE.mesh.position);

                // Mobs occasionally target ship if player is far away
                if (distToShip < 20 && !mob.userData.targetingPlayer) {
                    const distToPlayer = worldState.player ? mob.position.distanceTo(worldState.player.position) : Infinity;
                    if (distToPlayer > 30 && Math.random() < 0.01) {  // Small chance to attack ship
                        mob.userData.targetingShip = true;
                        mob.userData.targetPos.copy(SHIP_STATE.mesh.position);
                    }
                }

                // Damage ship when in melee range
                if (mob.userData.targetingShip && distToShip < 5) {
                    const now = performance.now();
                    if (!mob.userData.lastShipAttack || now - mob.userData.lastShipAttack > 2000) {
                        // v5.15: Pass mob as attacker for tracking
                        damageShip(mob.userData.damage || 5, mob);
                        mob.userData.lastShipAttack = now;
                    }
                }
            });

            // Gentle hover animation for ship
            if (SHIP_STATE.mesh) {
                SHIP_STATE.mesh.position.y = SHIP_STATE.position.y + 2 + Math.sin(time * 0.002) * 0.2;
                SHIP_STATE.mesh.rotation.z = Math.sin(time * 0.001) * 0.02;
            }
        }

        // Fire ship's defensive laser
        function fireShipLaser(target, time) {
            if (!SHIP_STATE.mesh || !target) return;

            const enemyName = target.userData.name || 'Unknown Entity';
            const enemyHpBefore = target.userData.hp;
            const damage = SHIP_STATE.laser.damage;
            const distance = SHIP_STATE.mesh.position.distanceTo(target.position);

            SHIP_STATE.laser.lastFire = time;
            SHIP_STATE.laser.target = target;
            SHIP_STATE.laser.active = true;

            // Rotate turret toward target
            const turret = SHIP_STATE.mesh.userData.turretBarrel;
            if (turret) {
                const dir = new THREE.Vector3().subVectors(target.position, SHIP_STATE.mesh.position).normalize();
                turret.lookAt(target.position);
            }

            // Deal damage
            target.userData.hp -= damage;

            // v5.15: Log the laser engagement
            logDefenseEvent('laser_fired', {
                enemy: enemyName,
                damage: damage,
                distance: Math.round(distance),
                enemyHpBefore: enemyHpBefore,
                enemyHpAfter: target.userData.hp,
                wasTargetingShip: target.userData.targetingShip || false
            });

            // Visual feedback
            if (particles) {
                particles.emit(target.position, 10, 0xff0000, { spread: 2, lifetime: 300 });
            }

            spawnFloater(target.position, `-${damage}`, '#ff4444');

            // Sound effect placeholder
            AudioSystem.play('spell');

            // Check if killed
            if (target.userData.hp <= 0) {
                const xpReward = target.userData.xpReward || 50;
                addXp('combat', Math.floor(xpReward * 0.5));  // Half XP for ship kills
                spawnFloater(target.position, `SHIP KILL! +${Math.floor(xpReward * 0.5)}XP`, '#ff8800');

                // v5.15: Log the kill
                logDefenseEvent('enemy_killed', {
                    enemy: enemyName,
                    totalDamageDealt: enemyHpBefore,
                    xpAwarded: Math.floor(xpReward * 0.5),
                    wasTargetingShip: target.userData.targetingShip || false,
                    outcome: 'destroyed'
                });
            } else if (target.userData.targetingShip && target.userData.hp < enemyHpBefore * 0.5) {
                // v5.15: Check if enemy might flee (deterred) - below 50% HP after being hit
                // Enemies have a chance to be deterred when significantly damaged
                if (Math.random() < 0.3) {
                    target.userData.targetingShip = false;
                    target.userData.deterredByShip = true;
                    logDefenseEvent('enemy_deterred', {
                        enemy: enemyName,
                        hpRemaining: target.userData.hp,
                        reason: 'significant_damage',
                        outcome: 'fled'
                    });
                    spawnFloater(target.position, 'DETERRED!', '#ffaa00');
                }
            }
        }

        // Update laser beam visual effect
        function updateLaserBeam(dt, time) {
            const beam = SHIP_STATE.laser.beam;
            if (!beam) return;

            if (SHIP_STATE.laser.active && SHIP_STATE.laser.target) {
                beam.visible = true;

                const start = SHIP_STATE.mesh.position.clone();
                start.y += 1.5;
                const end = SHIP_STATE.laser.target.position.clone();
                end.y += 1;

                const dir = new THREE.Vector3().subVectors(end, start);
                const length = dir.length();

                beam.scale.set(1, length, 1);
                beam.position.copy(start).add(dir.multiplyScalar(0.5));
                beam.lookAt(end);
                beam.rotateX(Math.PI / 2);

                // Flash effect
                beam.material.opacity = 0.9;

                // Deactivate after short duration
                setTimeout(() => {
                    SHIP_STATE.laser.active = false;
                    beam.visible = false;
                }, 100);
            } else {
                beam.visible = false;
            }
        }

        // Damage the ship
        // v5.15: Added attacker parameter for tracking
        function damageShip(amount, attacker = null) {
            const hpBefore = SHIP_STATE.hp;
            SHIP_STATE.hp = Math.max(0, SHIP_STATE.hp - amount);
            SHIP_STATE.damaged = true;

            // v5.15: Log the attack
            const attackerName = attacker?.userData?.name || 'Unknown Attacker';
            logDefenseEvent('ship_attacked', {
                attacker: attackerName,
                damage: amount,
                shipHpBefore: hpBefore,
                shipHpAfter: SHIP_STATE.hp,
                attackerHp: attacker?.userData?.hp || null,
                critical: amount >= 10
            });

            // Clear damaged flag after 2 seconds
            setTimeout(() => { SHIP_STATE.damaged = false; }, 2000);

            // Visual feedback
            if (SHIP_STATE.mesh) {
                // Flash red
                SHIP_STATE.mesh.children.forEach(child => {
                    if (child.material && child.material.emissive) {
                        const originalColor = child.material.emissive.getHex();
                        child.material.emissive.setHex(0xff0000);
                        setTimeout(() => {
                            child.material.emissive.setHex(originalColor);
                        }, 200);
                    }
                });
            }

            // Particles
            if (particles && SHIP_STATE.mesh) {
                particles.emit(SHIP_STATE.mesh.position, 15, 0xff4400, { spread: 3, lifetime: 500 });
            }

            spawnFloater(SHIP_STATE.mesh.position, `-${amount}`, '#ff0000');
            showNotification(`Ship taking damage! (${SHIP_STATE.hp}/${SHIP_STATE.maxHp} HP)`, 'warning');

            // Update UI
            updateShipHPUI();

            // Ship destroyed
            if (SHIP_STATE.hp <= 0) {
                shipDestroyed(attackerName);
            }
        }

        // Handle ship destruction
        // v5.15: Added finalBlow parameter
        function shipDestroyed(finalBlow = 'Unknown') {
            // v5.15: Log destruction event
            logDefenseEvent('ship_destroyed', {
                finalBlow: finalBlow,
                totalDamageTaken: SHIP_STATE.defenseLog.totalDamageTaken,
                totalEngagements: SHIP_STATE.defenseLog.totalEngagements,
                totalKills: SHIP_STATE.defenseLog.totalKills
            });

            showNotification('SHIP DESTROYED! Repair required to leave planet.', 'error');

            // Disable ship mesh
            if (SHIP_STATE.mesh) {
                SHIP_STATE.mesh.children.forEach(child => {
                    if (child.material) {
                        child.material.opacity = 0.3;
                        child.material.transparent = true;
                    }
                });
            }

            // Large explosion
            if (particles && SHIP_STATE.mesh) {
                particles.emit(SHIP_STATE.mesh.position, 50, 0xff4400, { spread: 8, lifetime: 1500 });
                particles.emit(SHIP_STATE.mesh.position, 30, 0xffff00, { spread: 6, lifetime: 1000 });
            }
        }

        // Repair ship (costs gold)
        function repairShip() {
            if (SHIP_STATE.hp >= SHIP_STATE.maxHp) {
                showNotification('Ship is already at full health!', 'info');
                return;
            }

            if (gameData.currency >= SHIP_STATE.repairCost) {
                const hpBefore = SHIP_STATE.hp;
                const hpRestored = SHIP_STATE.maxHp - hpBefore;

                gameData.currency -= SHIP_STATE.repairCost;
                SHIP_STATE.hp = SHIP_STATE.maxHp;

                // v5.15: Log repair event
                logDefenseEvent('ship_repaired', {
                    cost: SHIP_STATE.repairCost,
                    hpBefore: hpBefore,
                    hpAfter: SHIP_STATE.maxHp,
                    hpRestored: hpRestored,
                    wasDestroyed: hpBefore === 0
                });

                // Restore ship visuals
                if (SHIP_STATE.mesh) {
                    SHIP_STATE.mesh.children.forEach(child => {
                        if (child.material) {
                            child.material.opacity = 1;
                            child.material.transparent = false;
                        }
                    });
                }

                showNotification(`Ship repaired! -${SHIP_STATE.repairCost} Gold`, 'success');
                updateShipHPUI();
                saveGame();
            } else {
                showNotification(`Need ${SHIP_STATE.repairCost} Gold to repair ship!`, 'warning');
            }
        }

        // Update ship HP UI
        function updateShipHPUI() {
            const bar = document.getElementById('ship-hp-fill');
            const text = document.getElementById('ship-hp-text');
            if (bar) {
                const percent = (SHIP_STATE.hp / SHIP_STATE.maxHp) * 100;
                bar.style.width = `${percent}%`;
                bar.style.background = percent > 50 ? '#00ff88' : percent > 25 ? '#ffaa00' : '#ff4444';
            }
            if (text) {
                text.textContent = `${SHIP_STATE.hp}/${SHIP_STATE.maxHp}`;
            }
        }

        // Toggle ship auto-defend
        function toggleShipAutoDefend() {
            SHIP_STATE.laser.autoDefend = !SHIP_STATE.laser.autoDefend;
            showNotification(`Ship Auto-Defense: ${SHIP_STATE.laser.autoDefend ? 'ENABLED' : 'DISABLED'}`, 'info');
            const btn = document.getElementById('ship-defense-btn');
            if (btn) {
                btn.textContent = SHIP_STATE.laser.autoDefend ? 'ðŸ›¡ï¸ Defense: ON' : 'ðŸ›¡ï¸ Defense: OFF';
                btn.style.background = SHIP_STATE.laser.autoDefend ? 'rgba(0, 255, 136, 0.2)' : 'rgba(255, 68, 68, 0.2)';
            }
        }

        // v5.11: RTS Panel Toggle System
        const rtsPanelState = {
            skills: false,
            crafting: false,
            inventory: false,
            equipment: false
        };

        function toggleRTSPanel(panelName) {
            rtsPanelState[panelName] = !rtsPanelState[panelName];

            const panelIds = {
                skills: 'skills-panel',
                crafting: 'crafting-panel',
                inventory: 'inventory-panel',
                equipment: 'equipment-panel'
            };

            const panel = document.getElementById(panelIds[panelName]);
            const toggleBtn = document.getElementById(`toggle-${panelName}`);

            if (panel) {
                if (rtsPanelState[panelName]) {
                    panel.classList.add('visible');
                } else {
                    panel.classList.remove('visible');
                }
            }

            if (toggleBtn) {
                if (rtsPanelState[panelName]) {
                    toggleBtn.classList.add('active');
                } else {
                    toggleBtn.classList.remove('active');
                }
            }
        }

        // v5.11: Keyboard shortcuts for RTS panels
        function handleRTSPanelHotkeys(e) {
            if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') return;

            switch(e.key.toLowerCase()) {
                case 'k': toggleRTSPanel('skills'); break;
                case 'i': toggleRTSPanel('inventory'); break;
                case 'e': toggleRTSPanel('equipment'); break;
                // 'c' is often used for crafting but may conflict with other controls
            }
        }

        // v5.2: Talent Modal UI
        function showTalentModal() {
            document.getElementById('talent-modal').style.display = 'flex';
            updateTalentModal();
        }

        function closeTalentModal() {
            document.getElementById('talent-modal').style.display = 'none';
        }

        function updateTalentModal() {
            const points = getTalentPoints();
            document.getElementById('talent-points-display').textContent = `Talent Points: ${points.available}/${points.earned}`;

            for (const [treeId, tree] of Object.entries(TALENT_TREES)) {
                const treeDiv = document.getElementById(`talent-tree-${treeId}`);
                if (!treeDiv) continue;

                let html = '';
                for (const [talentId, talent] of Object.entries(tree.talents)) {
                    const rank = getTalentRank(treeId, talentId);
                    const canUnlock = canUnlockTalent(treeId, talentId);
                    const isMaxed = rank >= talent.maxRank;
                    const isLocked = talent.requires && getTalentRank(treeId, talent.requires) < TALENT_TREES[treeId].talents[talent.requires].maxRank;

                    html += `
                        <div style="padding: 8px; margin-bottom: 5px; border: 1px solid ${isMaxed ? tree.color : isLocked ? '#333' : '#555'};
                                    border-radius: 4px; background: ${isMaxed ? `${tree.color}22` : 'rgba(0,0,0,0.3)'};
                                    opacity: ${isLocked ? 0.5 : 1}; cursor: ${canUnlock ? 'pointer' : 'default'};"
                             onclick="${canUnlock ? `unlockTalent('${treeId}', '${talentId}')` : ''}">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <span style="color: ${isMaxed ? tree.color : '#fff'};">${talent.name}</span>
                                <span style="color: ${isMaxed ? '#4f4' : '#888'};">${rank}/${talent.maxRank}</span>
                            </div>
                            <div style="font-size: 10px; color: #888; margin-top: 3px;">${talent.desc}</div>
                        </div>
                    `;
                }
                treeDiv.innerHTML = html;
            }
        }

        // ============================================
        // v5.3: MASTERY SYSTEM
        // ============================================
        const MASTERY_MILESTONES = {
            mining: {
                name: 'Mining', icon: 'â›ï¸', color: '#888888',
                milestones: [
                    { level: 5, reward: { type: 'bonus', stat: 'miningYield', value: 0.1 }, desc: '+10% ore yield' },
                    { level: 10, reward: { type: 'bonus', stat: 'miningYield', value: 0.15 }, desc: '+15% ore yield' },
                    { level: 15, reward: { type: 'unlock', item: 'Miner\'s Blessing' }, desc: 'Unlock Miner\'s Blessing buff' },
                    { level: 20, reward: { type: 'bonus', stat: 'miningYield', value: 0.25 }, desc: '+25% ore yield' },
                    { level: 25, reward: { type: 'title', title: 'Grandmaster Miner' }, desc: 'Earn Grandmaster title' }
                ]
            },
            wood: {
                name: 'Woodcutting', icon: 'ðŸª“', color: '#da5500',
                milestones: [
                    { level: 5, reward: { type: 'bonus', stat: 'woodYield', value: 0.1 }, desc: '+10% wood yield' },
                    { level: 10, reward: { type: 'bonus', stat: 'woodYield', value: 0.15 }, desc: '+15% wood yield' },
                    { level: 15, reward: { type: 'unlock', item: 'Lumberjack\'s Spirit' }, desc: 'Unlock Lumberjack buff' },
                    { level: 20, reward: { type: 'bonus', stat: 'woodYield', value: 0.25 }, desc: '+25% wood yield' },
                    { level: 25, reward: { type: 'title', title: 'Grandmaster Lumberjack' }, desc: 'Earn Grandmaster title' }
                ]
            },
            combat: {
                name: 'Combat', icon: 'âš”ï¸', color: '#ff4444',
                milestones: [
                    { level: 5, reward: { type: 'bonus', stat: 'combatDamage', value: 0.05 }, desc: '+5% damage' },
                    { level: 10, reward: { type: 'bonus', stat: 'combatDamage', value: 0.1 }, desc: '+10% damage' },
                    { level: 15, reward: { type: 'unlock', ability: 'Veteran Strike' }, desc: 'Unlock Veteran Strike' },
                    { level: 20, reward: { type: 'bonus', stat: 'combatCrit', value: 0.05 }, desc: '+5% crit chance' },
                    { level: 25, reward: { type: 'title', title: 'Warlord' }, desc: 'Earn Warlord title' }
                ]
            },
            fishing: {
                name: 'Fishing', icon: 'ðŸŽ£', color: '#4488ff',
                milestones: [
                    { level: 5, reward: { type: 'bonus', stat: 'fishChance', value: 0.1 }, desc: '+10% catch rate' },
                    { level: 10, reward: { type: 'bonus', stat: 'rareFind', value: 0.05 }, desc: '+5% rare fish' },
                    { level: 15, reward: { type: 'unlock', item: 'Golden Lure' }, desc: 'Unlock Golden Lure' },
                    { level: 20, reward: { type: 'bonus', stat: 'fishChance', value: 0.2 }, desc: '+20% catch rate' },
                    { level: 25, reward: { type: 'title', title: 'Master Angler' }, desc: 'Earn Master title' }
                ]
            },
            cooking: {
                name: 'Cooking', icon: 'ðŸ³', color: '#ff8800',
                milestones: [
                    { level: 5, reward: { type: 'bonus', stat: 'healBonus', value: 0.1 }, desc: '+10% heal amount' },
                    { level: 10, reward: { type: 'bonus', stat: 'healBonus', value: 0.15 }, desc: '+15% heal amount' },
                    { level: 15, reward: { type: 'unlock', recipe: 'Feast' }, desc: 'Unlock Feast recipe' },
                    { level: 20, reward: { type: 'bonus', stat: 'foodDuration', value: 0.3 }, desc: '+30% buff duration' },
                    { level: 25, reward: { type: 'title', title: 'Master Chef' }, desc: 'Earn Master title' }
                ]
            },
            crafting: {
                name: 'Crafting', icon: 'ðŸ”¨', color: '#aa44ff',
                milestones: [
                    { level: 5, reward: { type: 'bonus', stat: 'craftBonus', value: 0.1 }, desc: '+10% craft success' },
                    { level: 10, reward: { type: 'bonus', stat: 'materialSave', value: 0.1 }, desc: '10% material savings' },
                    { level: 15, reward: { type: 'unlock', recipe: 'Masterwork Forge' }, desc: 'Unlock Masterwork crafts' },
                    { level: 20, reward: { type: 'bonus', stat: 'rarityBoost', value: 0.15 }, desc: '+15% rarity chance' },
                    { level: 25, reward: { type: 'title', title: 'Artisan Supreme' }, desc: 'Earn Artisan title' }
                ]
            }
        };

        function getMasteryBonuses() {
            const bonuses = {
                miningYield: 0, woodYield: 0, combatDamage: 0, combatCrit: 0,
                fishChance: 0, rareFind: 0, healBonus: 0, foodDuration: 0,
                craftBonus: 0, materialSave: 0, rarityBoost: 0
            };

            for (const [skillId, mastery] of Object.entries(MASTERY_MILESTONES)) {
                const skillLevel = gameData.skills[skillId]?.level || 1;
                for (const milestone of mastery.milestones) {
                    if (skillLevel >= milestone.level && milestone.reward.type === 'bonus') {
                        bonuses[milestone.reward.stat] = (bonuses[milestone.reward.stat] || 0) + milestone.reward.value;
                    }
                }
            }

            return bonuses;
        }

        function getUnlockedMasteryTitles() {
            const titles = [];
            for (const [skillId, mastery] of Object.entries(MASTERY_MILESTONES)) {
                const skillLevel = gameData.skills[skillId]?.level || 1;
                for (const milestone of mastery.milestones) {
                    if (skillLevel >= milestone.level && milestone.reward.type === 'title') {
                        titles.push(milestone.reward.title);
                    }
                }
            }
            return titles;
        }

        function openMasteryModal() {
            document.getElementById('mastery-modal').style.display = 'flex';
            updateMasteryModal();
        }

        function closeMasteryModal() {
            document.getElementById('mastery-modal').style.display = 'none';
        }

        function updateMasteryModal() {
            const listDiv = document.getElementById('mastery-list');
            let html = '';

            for (const [skillId, mastery] of Object.entries(MASTERY_MILESTONES)) {
                const skillLevel = gameData.skills[skillId]?.level || 1;
                const maxMilestone = mastery.milestones[mastery.milestones.length - 1].level;
                const progress = Math.min(100, (skillLevel / maxMilestone) * 100);
                const isMastered = skillLevel >= maxMilestone;

                html += `
                    <div class="mastery-card ${isMastered ? 'mastered' : ''}">
                        <div class="mastery-header">
                            <span class="mastery-skill" style="color: ${mastery.color};">${mastery.icon} ${mastery.name}</span>
                            <span class="mastery-level">Lv ${skillLevel}</span>
                        </div>
                        <div class="mastery-progress-bar">
                            <div class="mastery-progress-fill" style="width: ${progress}%;"></div>
                        </div>
                        <div class="mastery-milestones">
                `;

                for (const milestone of mastery.milestones) {
                    const achieved = skillLevel >= milestone.level;
                    const isNext = !achieved && mastery.milestones.find(m => skillLevel < m.level)?.level === milestone.level;
                    html += `
                        <div class="milestone ${achieved ? 'achieved' : ''} ${isNext ? 'next' : ''}" title="${milestone.desc}">
                            Lv${milestone.level}: ${achieved ? 'âœ“' : milestone.desc.substring(0, 15)}...
                        </div>
                    `;
                }

                html += `
                        </div>
                    </div>
                `;
            }

            listDiv.innerHTML = html;
        }

        // ============================================
        // v5.3: REALM PORTAL SYSTEM
        // ============================================
        const REALM_PORTALS = {
            shadow_realm: {
                name: 'Shadow Realm',
                icon: 'ðŸŒ‘',
                tier: 1,
                desc: 'A realm of darkness where shadows come alive. Enhanced enemy spawn rates.',
                requirements: { combatLevel: 10, bossesDefeated: 1 },
                modifiers: { enemyDamage: 1.5, enemyHp: 1.3, spawnRate: 2.0 },
                rewards: ['Shadow Essence', 'Dark Crystal'],
                xpMultiplier: 1.5,
                duration: 300 // 5 minutes
            },
            frost_dimension: {
                name: 'Frost Dimension',
                icon: 'â„ï¸',
                tier: 2,
                desc: 'An eternally frozen world. All enemies inflict chill. Ice enemies are empowered.',
                requirements: { combatLevel: 15, bossesDefeated: 3 },
                modifiers: { enemyDamage: 1.8, enemyHp: 1.5, allEnemiesChill: true },
                rewards: ['Frozen Heart', 'Permafrost Shard', 'Frost Blade'],
                xpMultiplier: 2.0,
                duration: 300
            },
            inferno_pit: {
                name: 'Inferno Pit',
                icon: 'ðŸ”¥',
                tier: 2,
                desc: 'Volcanic realm of eternal flame. Fire damage over time. Magma enemies empowered.',
                requirements: { combatLevel: 15, bossesDefeated: 3 },
                modifiers: { enemyDamage: 2.0, enemyHp: 1.5, environmentalDamage: 2 },
                rewards: ['Infernal Core', 'Magma Heart', 'Magma Sword'],
                xpMultiplier: 2.0,
                duration: 300
            },
            void_nexus: {
                name: 'Void Nexus',
                icon: 'ðŸŒ€',
                tier: 3,
                desc: 'The space between dimensions. Reality warps around you. Elite enemies guaranteed.',
                requirements: { combatLevel: 20, bossesDefeated: 5, elitesKilled: 20 },
                modifiers: { enemyDamage: 2.5, enemyHp: 2.0, allElites: true },
                rewards: ['Void Core', 'Dimension Shard', 'Void Dagger', 'Legendary Core'],
                xpMultiplier: 3.0,
                duration: 300
            },
            celestial_ascent: {
                name: 'Celestial Ascent',
                icon: 'âœ¨',
                tier: 4,
                desc: 'The ultimate challenge. Face the Celestial Guardians in their domain.',
                requirements: { combatLevel: 25, bossesDefeated: 10, portalClears: 5 },
                modifiers: { enemyDamage: 3.0, enemyHp: 3.0, bossOnly: true },
                rewards: ['Celestial Essence', 'Star Fragment', 'Legendary Blade', 'Mythic Orb'],
                xpMultiplier: 5.0,
                duration: 600 // 10 minutes
            }
        };

        function initPortalSystem() {
            if (!gameData.portals) {
                gameData.portals = {
                    clears: {},
                    currentPortal: null,
                    portalStartTime: 0,
                    totalClears: 0
                };
            }
        }

        function canEnterPortal(portalId) {
            const portal = REALM_PORTALS[portalId];
            if (!portal) return false;

            const reqs = portal.requirements;
            const combatLevel = gameData.skills?.combat?.level || 1;
            const bossesDefeated = gameData.statistics?.bossesDefeated || 0;
            const elitesKilled = gameData.statistics?.elitesKilled || 0;
            const portalClears = gameData.portals?.totalClears || 0;

            if (combatLevel < reqs.combatLevel) return false;
            if (bossesDefeated < reqs.bossesDefeated) return false;
            if (reqs.elitesKilled && elitesKilled < reqs.elitesKilled) return false;
            if (reqs.portalClears && portalClears < reqs.portalClears) return false;

            return true;
        }

        function getPortalRequirementText(portalId) {
            const portal = REALM_PORTALS[portalId];
            const reqs = portal.requirements;
            const parts = [];

            parts.push(`Combat Lv ${reqs.combatLevel}`);
            parts.push(`${reqs.bossesDefeated} bosses`);
            if (reqs.elitesKilled) parts.push(`${reqs.elitesKilled} elites`);
            if (reqs.portalClears) parts.push(`${reqs.portalClears} portal clears`);

            return parts.join(' | ');
        }

        function enterPortal(portalId) {
            if (!canEnterPortal(portalId)) {
                showNotification('Requirements not met!', 'error');
                return false;
            }

            if (gameData.portals.currentPortal) {
                showNotification('Already in a portal realm!', 'warning');
                return false;
            }

            if (mode !== 'world') {
                showNotification('Must be on a planet to enter portals!', 'warning');
                return false;
            }

            const portal = REALM_PORTALS[portalId];
            gameData.portals.currentPortal = portalId;
            gameData.portals.portalStartTime = Date.now();
            gameData.portals.killProgress = 0; // v5.3: Reset kill counter

            showNotification(`Entered ${portal.name}! ${portal.duration / 60} minutes to clear.`, 'success');
            AudioSystem.bossSpawn();

            if (particles && worldState.player) {
                particles.emit(worldState.player.position, 50, parseInt(portal.icon === 'ðŸŒ‘' ? '0x440088' : portal.icon === 'â„ï¸' ? '0x88ddff' : portal.icon === 'ðŸ”¥' ? '0xff4400' : '0x8844ff'), { spread: 8, lifetime: 1500 });
            }

            closePortalModal();
            updatePortalUI();
            saveGameData();
            return true;
        }

        function exitPortal(completed = false) {
            if (!gameData.portals.currentPortal) return;

            const portalId = gameData.portals.currentPortal;
            const portal = REALM_PORTALS[portalId];

            if (completed) {
                // Grant rewards
                gameData.portals.clears[portalId] = (gameData.portals.clears[portalId] || 0) + 1;
                gameData.portals.totalClears++;

                // Give a random reward
                const rewardItem = portal.rewards[Math.floor(Math.random() * portal.rewards.length)];
                addItem(rewardItem);

                showNotification(`Portal cleared! Received ${rewardItem}!`, 'success');
                AudioSystem.levelUp();

                if (particles && worldState.player) {
                    particles.emit(worldState.player.position, 60, 0xffd700, { spread: 10, lifetime: 2000 });
                }
            } else {
                showNotification('Portal expired. Try again!', 'warning');
            }

            gameData.portals.currentPortal = null;
            gameData.portals.portalStartTime = 0;
            updatePortalUI();
            saveGameData();
        }

        function getPortalModifiers() {
            if (!gameData.portals?.currentPortal) return null;
            return REALM_PORTALS[gameData.portals.currentPortal]?.modifiers || null;
        }

        function getPortalXpMultiplier() {
            if (!gameData.portals?.currentPortal) return 1;
            return REALM_PORTALS[gameData.portals.currentPortal]?.xpMultiplier || 1;
        }

        function checkPortalTimeout() {
            if (!gameData.portals?.currentPortal) return;

            const portal = REALM_PORTALS[gameData.portals.currentPortal];
            const elapsed = (Date.now() - gameData.portals.portalStartTime) / 1000;

            if (elapsed >= portal.duration) {
                exitPortal(false);
            }
        }

        function getPortalTimeRemaining() {
            if (!gameData.portals?.currentPortal) return 0;

            const portal = REALM_PORTALS[gameData.portals.currentPortal];
            const elapsed = (Date.now() - gameData.portals.portalStartTime) / 1000;
            return Math.max(0, portal.duration - elapsed);
        }

        function openPortalModal() {
            initPortalSystem();
            document.getElementById('portal-modal').style.display = 'flex';
            updatePortalModal();
        }

        function closePortalModal() {
            document.getElementById('portal-modal').style.display = 'none';
        }

        function updatePortalModal() {
            const currentPortal = gameData.portals?.currentPortal;
            document.getElementById('current-realm').textContent = currentPortal ? REALM_PORTALS[currentPortal].name : 'None';

            const listDiv = document.getElementById('portal-list');
            let html = '';

            for (const [portalId, portal] of Object.entries(REALM_PORTALS)) {
                const canEnter = canEnterPortal(portalId);
                const isActive = currentPortal === portalId;
                const clears = gameData.portals?.clears?.[portalId] || 0;

                html += `
                    <div class="portal-card ${!canEnter ? 'locked' : ''} ${isActive ? 'active' : ''}"
                         onclick="${canEnter && !currentPortal ? `enterPortal('${portalId}')` : ''}">
                        <div class="portal-header">
                            <span class="portal-name">${portal.icon} ${portal.name}</span>
                            <span class="portal-tier">Tier ${portal.tier}</span>
                        </div>
                        <div class="portal-desc">${portal.desc}</div>
                        <div class="portal-rewards">
                            ${portal.rewards.map(r => `<span class="portal-reward">${ITEMS[r]?.icon || 'ðŸ“¦'} ${r}</span>`).join('')}
                        </div>
                        <div class="portal-requirement">
                            ${canEnter ? `âœ“ Unlocked | Cleared: ${clears}x | ${portal.xpMultiplier}x XP` : `ðŸ”’ ${getPortalRequirementText(portalId)}`}
                        </div>
                        ${isActive ? `<div style="color: #ff8844; margin-top: 8px; text-align: center;">â±ï¸ Active - ${Math.floor(getPortalTimeRemaining())}s remaining</div>` : ''}
                    </div>
                `;
            }

            listDiv.innerHTML = html;
        }

        function updatePortalUI() {
            // This would update any in-game portal indicators
            if (document.getElementById('portal-modal').style.display === 'flex') {
                updatePortalModal();
            }
        }

        // ============================================
        // v5.3: LOOT RARITY SYSTEM
        // ============================================
        const LOOT_RARITIES = {
            common: { name: 'Common', color: '#aaaaaa', chance: 0.60, statMult: 1.0 },
            uncommon: { name: 'Uncommon', color: '#44ff44', chance: 0.25, statMult: 1.15 },
            rare: { name: 'Rare', color: '#4488ff', chance: 0.10, statMult: 1.35 },
            epic: { name: 'Epic', color: '#aa44ff', chance: 0.04, statMult: 1.6 },
            legendary: { name: 'Legendary', color: '#ff8800', chance: 0.0095, statMult: 2.0 },
            mythic: { name: 'Mythic', color: '#ff4488', chance: 0.0005, statMult: 3.0 }
        };

        const ITEM_MODIFIERS = {
            // Offensive modifiers
            sharp: { name: 'Sharp', stat: 'damage', value: 3, desc: '+3 Damage' },
            keen: { name: 'Keen', stat: 'critChance', value: 0.05, desc: '+5% Crit' },
            brutal: { name: 'Brutal', stat: 'damage', value: 5, desc: '+5 Damage' },
            deadly: { name: 'Deadly', stat: 'critDamage', value: 0.25, desc: '+25% Crit Damage' },
            vampiric: { name: 'Vampiric', stat: 'lifesteal', value: 0.05, desc: '+5% Lifesteal' },

            // Defensive modifiers
            sturdy: { name: 'Sturdy', stat: 'defense', value: 2, desc: '+2 Defense' },
            fortified: { name: 'Fortified', stat: 'defense', value: 4, desc: '+4 Defense' },
            vital: { name: 'Vital', stat: 'maxHp', value: 15, desc: '+15 Max HP' },
            resilient: { name: 'Resilient', stat: 'damageReduction', value: 0.05, desc: '+5% DR' },

            // Utility modifiers
            swift: { name: 'Swift', stat: 'moveSpeed', value: 0.1, desc: '+10% Speed' },
            lucky: { name: 'Lucky', stat: 'lootBonus', value: 0.1, desc: '+10% Loot' },
            wise: { name: 'Wise', stat: 'xpBonus', value: 0.1, desc: '+10% XP' },
            efficient: { name: 'Efficient', stat: 'resourceYield', value: 0.15, desc: '+15% Yield' }
        };

        function rollItemRarity(baseLuckBonus = 0) {
            const masteryBonuses = getMasteryBonuses();
            const talentBonuses = getTalentBonuses();
            const totalLuck = baseLuckBonus + (masteryBonuses.rarityBoost || 0) + (talentBonuses.rareFind || 0);

            let roll = Math.random();
            // Luck improves rare+ chances
            roll = roll * (1 - totalLuck);

            let cumulative = 0;
            for (const [rarityId, rarity] of Object.entries(LOOT_RARITIES)) {
                cumulative += rarity.chance;
                if (roll < cumulative) {
                    return rarityId;
                }
            }
            return 'common';
        }

        function rollItemModifiers(rarity) {
            const numModifiers = {
                common: 0,
                uncommon: 1,
                rare: 1,
                epic: 2,
                legendary: 2,
                mythic: 3
            };

            const count = numModifiers[rarity] || 0;
            if (count === 0) return [];

            const modifierKeys = Object.keys(ITEM_MODIFIERS);
            const selected = [];

            for (let i = 0; i < count; i++) {
                const availableModifiers = modifierKeys.filter(m => !selected.includes(m));
                if (availableModifiers.length === 0) break;

                const modId = availableModifiers[Math.floor(Math.random() * availableModifiers.length)];
                selected.push(modId);
            }

            return selected;
        }

        function createRarityItem(baseItemName, forcedRarity = null) {
            const rarity = forcedRarity || rollItemRarity();
            const modifiers = rollItemModifiers(rarity);
            const rarityData = LOOT_RARITIES[rarity];

            return {
                baseName: baseItemName,
                rarity: rarity,
                modifiers: modifiers,
                statMultiplier: rarityData.statMult
            };
        }

        function getRarityItemName(rarityItem) {
            if (!rarityItem || !rarityItem.rarity || rarityItem.rarity === 'common') {
                return rarityItem?.baseName || rarityItem;
            }

            const modNames = rarityItem.modifiers?.map(m => ITEM_MODIFIERS[m]?.name).filter(Boolean) || [];
            const prefix = modNames.length > 0 ? modNames.join(' ') + ' ' : '';
            const rarityData = LOOT_RARITIES[rarityItem.rarity];

            return `${prefix}${rarityItem.baseName}`;
        }

        function getRarityItemStats(rarityItem) {
            if (!rarityItem || typeof rarityItem === 'string') return {};

            const stats = {};
            const mult = rarityItem.statMultiplier || 1;

            // Apply modifier stats
            for (const modId of (rarityItem.modifiers || [])) {
                const mod = ITEM_MODIFIERS[modId];
                if (mod) {
                    stats[mod.stat] = (stats[mod.stat] || 0) + mod.value;
                }
            }

            return stats;
        }

        function showRarityDropPopup(rarityItem) {
            if (!rarityItem || rarityItem.rarity === 'common') return;

            const rarityData = LOOT_RARITIES[rarityItem.rarity];
            const itemData = ITEMS[rarityItem.baseName] || {};
            const displayName = getRarityItemName(rarityItem);
            const modifierStats = getRarityItemStats(rarityItem);

            // Create popup
            const popup = document.createElement('div');
            popup.className = 'loot-drop-popup';
            popup.innerHTML = `
                <div style="font-size: 24px; margin-bottom: 10px;">${itemData.icon || 'ðŸ“¦'}</div>
                <div class="rarity-${rarityItem.rarity}" style="font-size: 16px; font-weight: bold; margin-bottom: 5px;">
                    ${rarityData.name} Drop!
                </div>
                <div style="color: ${rarityData.color}; font-size: 14px; margin-bottom: 10px;">
                    ${displayName}
                </div>
                ${Object.keys(modifierStats).length > 0 ? `
                    <div class="item-modifiers">
                        ${rarityItem.modifiers.map(m => ITEM_MODIFIERS[m]?.desc).join(' | ')}
                    </div>
                ` : ''}
                <button onclick="this.parentElement.remove()" style="margin-top: 15px; padding: 8px 20px; cursor: pointer;
                    background: linear-gradient(135deg, ${rarityData.color}, #333); border: none; border-radius: 4px; color: #fff;">
                    Collect
                </button>
            `;

            document.body.appendChild(popup);

            // Auto-remove after 5 seconds
            setTimeout(() => {
                if (popup.parentElement) {
                    popup.remove();
                }
            }, 5000);

            // Play appropriate sound
            if (rarityItem.rarity === 'legendary' || rarityItem.rarity === 'mythic') {
                AudioSystem.levelUp();
            } else {
                AudioSystem.collect();
            }
        }

        // Enhanced item drop function that uses rarity system
        function dropRarityItem(baseItemName, luckBonus = 0) {
            const rarityItem = createRarityItem(baseItemName, null);

            // Store rarity items in a special format
            if (!gameData.rarityItems) gameData.rarityItems = [];

            if (rarityItem.rarity !== 'common') {
                gameData.rarityItems.push(rarityItem);
                showRarityDropPopup(rarityItem);
            }

            // Add the base item to inventory (rarity tracked separately)
            addItem(baseItemName);

            return rarityItem;
        }

        // Get total bonus stats from all rarity items
        function getRarityBonuses() {
            const bonuses = {};

            for (const item of (gameData.rarityItems || [])) {
                // Only count equipped items (check if base item is in equipment)
                const gear = getEquippedGear();
                const isEquipped = Object.values(gear).some(g => g === item.baseName);

                if (isEquipped) {
                    const stats = getRarityItemStats(item);
                    for (const [stat, value] of Object.entries(stats)) {
                        bonuses[stat] = (bonuses[stat] || 0) + value;
                    }
                }
            }

            return bonuses;
        }

        // v5.5: 3D Ship Landing Mini-Game System (Drone-style)
        let landingGame = {
            active: false,
            targetCiv: null,
            scene: null,
            camera: null,
            renderer: null,
            ship: null,
            landingPad: null,
            animFrame: null,
            lastTime: 0,
            isManual: false,
            fuel: 100,
            velocity: null,
            targetPosition: null,
            propellers: [],
            thrustLight: null,
            environmentObjects: []
        };

        const LANDING_CONFIG = {
            startAltitude: 60,
            maxSpeed: 8,
            safeSpeed: 2.5,
            gravity: 0.02,          // Much slower gravity
            thrustPower: 0.06,      // Gentler thrust
            manualControl: 0.25,    // Slower manual movement
            fuelConsumption: 0.02,  // Slower fuel drain
            landingPadSize: 18,     // Bigger landing pad
            bounds: 100,
            biomeColors: {
                Terra: { sky: 0x87CEEB, ground: 0x3a8c3a, fog: 0x87CEEB },
                Desert: { sky: 0xffcc99, ground: 0xc2a060, fog: 0xffcc99 },
                Ice: { sky: 0xddeeff, ground: 0xe8f4f8, fog: 0xddeeff },
                Volcanic: { sky: 0x330000, ground: 0x2a1a1a, fog: 0x330000 },
                Alien: { sky: 0x220044, ground: 0x440066, fog: 0x220044 }
            }
        };

        function startLandingGame(civ) {
            // Cleanup any existing landing game
            if (landingGame.animFrame) {
                cancelAnimationFrame(landingGame.animFrame);
            }
            if (landingGame.renderer) {
                landingGame.renderer.dispose();
            }

            landingGame.active = true;
            landingGame.targetCiv = civ;
            landingGame.isManual = false;
            landingGame.fuel = 100;
            landingGame.velocity = new THREE.Vector3(0, -0.1, 0);  // Very slow initial descent
            landingGame.targetPosition = new THREE.Vector3(0, 20, 0);
            landingGame.lastTime = 0;
            mode = 'landing';

            // Show landing UI
            const overlay = document.getElementById('landing-overlay');
            overlay.style.display = 'block';
            document.getElementById('landing-planet-name').textContent = `Landing on ${civ.name} (${civ.biomeName})`;
            document.getElementById('landing-mode').textContent = 'Autonomous';
            document.getElementById('landing-mode-btn').textContent = 'Switch to Manual';

            // Get biome colors
            const biomeColors = LANDING_CONFIG.biomeColors[civ.biome] || LANDING_CONFIG.biomeColors.Terra;

            // Create separate Three.js scene for landing
            landingGame.scene = new THREE.Scene();
            landingGame.scene.fog = new THREE.Fog(biomeColors.fog, 100, 500);

            // Isometric camera
            const container = document.getElementById('landing-scene-container');
            const aspect = container.clientWidth / container.clientHeight;
            const d = 50;
            landingGame.camera = new THREE.OrthographicCamera(
                -d * aspect, d * aspect, d, -d, 1, 1000
            );
            landingGame.camera.position.set(100, 100, 100);
            landingGame.camera.lookAt(0, 0, 0);

            // Renderer
            landingGame.renderer = new THREE.WebGLRenderer({ antialias: true });
            landingGame.renderer.setSize(container.clientWidth, container.clientHeight);
            landingGame.renderer.shadowMap.enabled = true;
            landingGame.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            landingGame.renderer.setClearColor(biomeColors.sky);
            container.innerHTML = '';
            container.appendChild(landingGame.renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            landingGame.scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            landingGame.scene.add(directionalLight);

            // Ground
            const groundGeometry = new THREE.PlaneGeometry(300, 300);
            const groundMaterial = new THREE.MeshLambertMaterial({ color: biomeColors.ground });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            landingGame.scene.add(ground);

            // Create landing pad
            createLandingPad();

            // Create environment based on biome
            createLandingEnvironment(civ.biome);

            // Create ship
            createLandingShip();

            // Start animation loop
            landingGameLoop(0);

            // Simple short blip sound instead of ringing tone
            AudioSystem.click();
            showNotification(`Approaching ${civ.name}... Land on the green pad!`, 'info');
        }

        function createLandingPad() {
            const padGroup = new THREE.Group();

            // Main pad
            const padGeometry = new THREE.CylinderGeometry(LANDING_CONFIG.landingPadSize, LANDING_CONFIG.landingPadSize, 1, 32);
            const padMaterial = new THREE.MeshLambertMaterial({ color: 0x44ff44 });
            const pad = new THREE.Mesh(padGeometry, padMaterial);
            pad.position.y = 0.5;
            pad.receiveShadow = true;
            padGroup.add(pad);

            // Center marker
            const markerGeometry = new THREE.CylinderGeometry(3, 3, 0.5, 32);
            const markerMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff });
            const marker = new THREE.Mesh(markerGeometry, markerMaterial);
            marker.position.y = 1.2;
            padGroup.add(marker);

            // Beacon light
            const beaconGeometry = new THREE.CylinderGeometry(1, 1, 5, 8);
            const beaconMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });
            const beacon = new THREE.Mesh(beaconGeometry, beaconMaterial);
            beacon.position.set(LANDING_CONFIG.landingPadSize - 2, 3, 0);
            beacon.castShadow = true;
            padGroup.add(beacon);

            // Beacon light
            const lightGeometry = new THREE.SphereGeometry(1.5, 16, 16);
            const lightMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            landingGame.beaconLight = new THREE.Mesh(lightGeometry, lightMaterial);
            landingGame.beaconLight.position.set(LANDING_CONFIG.landingPadSize - 2, 6, 0);
            padGroup.add(landingGame.beaconLight);

            landingGame.landingPad = padGroup;
            landingGame.scene.add(padGroup);
        }

        function createLandingEnvironment(biome) {
            landingGame.environmentObjects = [];

            // Add trees/structures based on biome
            if (biome === 'Terra' || biome === 'Alien') {
                for (let i = 0; i < 15; i++) {
                    const x = (Math.random() - 0.5) * 250;
                    const z = (Math.random() - 0.5) * 250;
                    if (Math.abs(x) > 30 || Math.abs(z) > 30) {
                        const tree = createLandingTree(biome);
                        tree.position.set(x, 0, z);
                        landingGame.scene.add(tree);
                        landingGame.environmentObjects.push(tree);
                    }
                }
            }

            // Add rocks/obstacles for all biomes
            for (let i = 0; i < 8; i++) {
                const x = (Math.random() - 0.5) * 200;
                const z = (Math.random() - 0.5) * 200;
                if (Math.abs(x) > 25 || Math.abs(z) > 25) {
                    const rock = createLandingRock(biome);
                    rock.position.set(x, 0, z);
                    landingGame.scene.add(rock);
                    landingGame.environmentObjects.push(rock);
                }
            }
        }

        function createLandingTree(biome) {
            const group = new THREE.Group();

            // Trunk
            const trunkGeometry = new THREE.CylinderGeometry(2, 3, 15);
            const trunkColor = biome === 'Alien' ? 0x8800ff : 0x8B4513;
            const trunkMaterial = new THREE.MeshLambertMaterial({ color: trunkColor });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 7.5;
            trunk.castShadow = true;
            group.add(trunk);

            // Foliage
            const foliageGeometry = new THREE.SphereGeometry(8, 8, 6);
            const foliageColor = biome === 'Alien' ? 0xff00ff : 0x228B22;
            const foliageMaterial = new THREE.MeshLambertMaterial({ color: foliageColor });
            const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
            foliage.position.y = 18;
            foliage.castShadow = true;
            group.add(foliage);

            return group;
        }

        function createLandingRock(biome) {
            const rockColors = {
                Terra: 0x888888,
                Desert: 0xaa5522,
                Ice: 0xaaccff,
                Volcanic: 0x333333,
                Alien: 0x00ffcc
            };
            const height = 5 + Math.random() * 15;
            const geometry = new THREE.DodecahedronGeometry(3 + Math.random() * 5, 0);
            const material = new THREE.MeshLambertMaterial({ color: rockColors[biome] || 0x888888 });
            const rock = new THREE.Mesh(geometry, material);
            rock.position.y = height / 2;
            rock.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
            rock.scale.y = height / 10;
            rock.castShadow = true;
            rock.receiveShadow = true;
            return rock;
        }

        function createLandingShip() {
            const shipGroup = new THREE.Group();

            // Body
            const bodyGeometry = new THREE.BoxGeometry(6, 2, 6);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = true;
            shipGroup.add(body);

            // Cockpit
            const cockpitGeometry = new THREE.SphereGeometry(2, 16, 16);
            const cockpitMaterial = new THREE.MeshLambertMaterial({ color: 0x00ffff });
            const cockpit = new THREE.Mesh(cockpitGeometry, cockpitMaterial);
            cockpit.position.y = 1.5;
            cockpit.scale.y = 0.6;
            shipGroup.add(cockpit);

            // Propeller arms and propellers
            landingGame.propellers = [];
            const propPositions = [
                [-4, 0.5, -4], [4, 0.5, -4],
                [-4, 0.5, 4], [4, 0.5, 4]
            ];

            propPositions.forEach(pos => {
                // Arm
                const armGeometry = new THREE.BoxGeometry(1, 0.5, 1);
                const armMaterial = new THREE.MeshLambertMaterial({ color: 0x666666 });
                const arm = new THREE.Mesh(armGeometry, armMaterial);
                arm.position.set(pos[0] * 0.6, pos[1], pos[2] * 0.6);
                shipGroup.add(arm);

                // Propeller
                const propGeometry = new THREE.CylinderGeometry(0.2, 0.2, 4);
                const propMaterial = new THREE.MeshLambertMaterial({ color: 0xaaaaaa });
                const propeller = new THREE.Mesh(propGeometry, propMaterial);
                propeller.rotation.z = Math.PI / 2;
                propeller.position.set(...pos);
                propeller.castShadow = true;
                landingGame.propellers.push(propeller);
                shipGroup.add(propeller);
            });

            // Engine light
            landingGame.thrustLight = new THREE.PointLight(0x00ff00, 1, 15);
            landingGame.thrustLight.position.y = -1;
            shipGroup.add(landingGame.thrustLight);

            // Position ship at start
            shipGroup.position.set(
                (Math.random() - 0.5) * 40,
                LANDING_CONFIG.startAltitude,
                (Math.random() - 0.5) * 40
            );

            landingGame.ship = shipGroup;
            landingGame.scene.add(shipGroup);
        }

        function landingGameLoop(currentTime) {
            if (!landingGame.active) return;

            const deltaTime = (currentTime - landingGame.lastTime) / 1000;
            landingGame.lastTime = currentTime;

            if (deltaTime > 0 && deltaTime < 0.1) {
                updateLandingShip(deltaTime);
                checkLandingConditions();
                updateLandingUI();
            }

            // Rotate propellers
            landingGame.propellers.forEach(prop => {
                prop.rotation.y += deltaTime * 50;
            });

            // Blink beacon
            const blinkOn = Math.floor(currentTime / 500) % 2 === 0;
            if (landingGame.beaconLight) {
                landingGame.beaconLight.material.color.setHex(blinkOn ? 0xff0000 : 0x440000);
            }

            // Camera follow
            const cameraTarget = new THREE.Vector3(
                landingGame.ship.position.x * 0.3,
                0,
                landingGame.ship.position.z * 0.3
            );
            landingGame.camera.position.x = 100 + cameraTarget.x;
            landingGame.camera.position.z = 100 + cameraTarget.z;
            landingGame.camera.lookAt(cameraTarget);

            landingGame.renderer.render(landingGame.scene, landingGame.camera);
            landingGame.animFrame = requestAnimationFrame(landingGameLoop);
        }

        function updateLandingShip(deltaTime) {
            const ship = landingGame.ship;

            // Slow fuel drain
            landingGame.fuel = Math.max(0, landingGame.fuel - deltaTime * LANDING_CONFIG.fuelConsumption * 3);

            if (!landingGame.isManual && landingGame.fuel > 0) {
                // Autonomous flight - navigate to landing pad
                runLandingAutopilot(deltaTime);
            } else if (landingGame.isManual && landingGame.fuel > 0) {
                // Manual controls via keyboard
                applyManualLandingControls(deltaTime);
            }

            // Apply gentle gravity
            landingGame.velocity.y -= LANDING_CONFIG.gravity * deltaTime * 20;

            // Apply velocity (slower multiplier)
            ship.position.add(landingGame.velocity.clone().multiplyScalar(deltaTime * 25));

            // Tilt based on velocity
            ship.rotation.z = landingGame.velocity.x * 0.05;
            ship.rotation.x = -landingGame.velocity.z * 0.05;

            // Strong damping for smoother movement
            landingGame.velocity.multiplyScalar(0.96);

            // Keep within bounds
            ship.position.clamp(
                new THREE.Vector3(-LANDING_CONFIG.bounds, 2, -LANDING_CONFIG.bounds),
                new THREE.Vector3(LANDING_CONFIG.bounds, 100, LANDING_CONFIG.bounds)
            );

            // Update thrust light color based on mode
            if (landingGame.thrustLight) {
                landingGame.thrustLight.color.setHex(landingGame.isManual ? 0xff8800 : 0x00ff88);
                landingGame.thrustLight.intensity = 1 + Math.sin(Date.now() * 0.005) * 0.3;
            }
        }

        function runLandingAutopilot(deltaTime) {
            const ship = landingGame.ship;
            const padPos = new THREE.Vector3(0, 4, 0); // Target slightly above pad

            // Calculate direction to landing pad
            const direction = new THREE.Vector3().subVectors(padPos, ship.position);
            const horizontalDist = Math.sqrt(direction.x * direction.x + direction.z * direction.z);
            const verticalDist = ship.position.y;

            // Desired velocity based on position - MUCH slower and gentler
            const desiredVelocity = new THREE.Vector3();

            // Horizontal movement - very gentle drift toward pad
            if (horizontalDist > 3) {
                desiredVelocity.x = direction.x * 0.015;  // Very slow horizontal
                desiredVelocity.z = direction.z * 0.015;
            }

            // Vertical movement - very controlled slow descent
            const slowDescent = -0.15;  // Very slow descent speed
            if (verticalDist > 25) {
                // High altitude - still slow descent
                desiredVelocity.y = slowDescent * 1.5;
            } else if (horizontalDist > 8) {
                // Not over pad yet - hover and drift
                desiredVelocity.y = -0.05;
            } else {
                // Over pad - very slow final descent
                desiredVelocity.y = slowDescent * 0.5;
            }

            // Very gentle lerp toward desired velocity
            landingGame.velocity.lerp(desiredVelocity, deltaTime * 0.8);

            // Counter gravity gently when needed
            if (landingGame.velocity.y < desiredVelocity.y - 0.05) {
                landingGame.velocity.y += LANDING_CONFIG.thrustPower * deltaTime * 30;
                landingGame.fuel -= LANDING_CONFIG.fuelConsumption * 0.5;
            }
        }

        function applyManualLandingControls(deltaTime) {
            const controlForce = LANDING_CONFIG.manualControl * deltaTime * 60;

            if (landingKeys['ArrowUp'] || landingKeys['w']) {
                landingGame.velocity.z -= controlForce;
            }
            if (landingKeys['ArrowDown'] || landingKeys['s']) {
                landingGame.velocity.z += controlForce;
            }
            if (landingKeys['ArrowLeft'] || landingKeys['a']) {
                landingGame.velocity.x -= controlForce;
            }
            if (landingKeys['ArrowRight'] || landingKeys['d']) {
                landingGame.velocity.x += controlForce;
            }
            if (landingKeys[' ']) {
                landingGame.velocity.y += controlForce * 1.5;
                landingGame.fuel -= LANDING_CONFIG.fuelConsumption * 2;
            }
            if (landingKeys['Shift']) {
                landingGame.velocity.y -= controlForce * 0.5;
            }
        }

        const landingKeys = {};

        function handleLandingKeyDown(e) {
            if (!landingGame.active) return;
            landingKeys[e.key] = true;

            if (e.key === 'Escape') {
                abortLanding();
            }
            if (e.key === 'm' || e.key === 'M') {
                toggleLandingMode();
            }

            // Auto-switch to manual if keys pressed
            if (!landingGame.isManual && ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' ', 'w', 'a', 's', 'd'].includes(e.key)) {
                landingGame.isManual = true;
                updateLandingModeUI();
                showNotification('MANUAL OVERRIDE - Autopilot disengaged', 'info');
            }

            e.preventDefault();
        }

        function handleLandingKeyUp(e) {
            landingKeys[e.key] = false;
        }

        function toggleLandingMode() {
            landingGame.isManual = !landingGame.isManual;
            updateLandingModeUI();
            showNotification(landingGame.isManual ? 'MANUAL CONTROL' : 'AUTOPILOT ENGAGED', 'info');
        }

        function updateLandingModeUI() {
            document.getElementById('landing-mode').textContent = landingGame.isManual ? 'Manual' : 'Autonomous';
            document.getElementById('landing-mode-btn').textContent = landingGame.isManual ? 'Switch to Autonomous' : 'Switch to Manual';
        }

        function updateLandingUI() {
            const ship = landingGame.ship;
            const altitude = Math.max(0, ship.position.y - 1).toFixed(1);
            const speed = landingGame.velocity.length().toFixed(1);
            const padPos = new THREE.Vector3(0, 0, 0);
            const distance = Math.sqrt(
                Math.pow(ship.position.x - padPos.x, 2) +
                Math.pow(ship.position.z - padPos.z, 2)
            ).toFixed(1);

            document.getElementById('landing-altitude').textContent = altitude;
            document.getElementById('landing-speed').textContent = speed;
            document.getElementById('landing-fuel').textContent = Math.floor(landingGame.fuel);
            document.getElementById('landing-distance').textContent = distance;
        }

        function checkLandingConditions() {
            const ship = landingGame.ship;
            const altitude = ship.position.y;
            const speed = landingGame.velocity.length();
            const horizontalDist = Math.sqrt(ship.position.x * ship.position.x + ship.position.z * ship.position.z);

            // Check if landed
            if (altitude <= 3) {
                const onPad = horizontalDist < LANDING_CONFIG.landingPadSize;
                const slowEnough = speed < LANDING_CONFIG.safeSpeed;

                if (onPad && slowEnough) {
                    landingSuccess();
                } else if (!slowEnough) {
                    landingCrash('Too fast! Reduce speed before landing.');
                } else {
                    landingCrash('Missed the landing pad!');
                }
            }

            // Out of fuel
            if (landingGame.fuel <= 0 && altitude > 10) {
                landingCrash('Out of fuel!');
            }
        }

        function landingSuccess() {
            landingGame.active = false;
            cancelAnimationFrame(landingGame.animFrame);

            const civ = landingGame.targetCiv;
            const bonusXp = Math.floor(landingGame.fuel * 2);

            cleanupLandingGame();

            showNotification(`Perfect landing on ${civ.name}! +${bonusXp} XP bonus!`, 'success');
            AudioSystem.levelUp();

            // Grant landing bonus XP
            Object.keys(gameData.skills).forEach(skill => {
                addXp(skill, Math.floor(bonusXp / 6));
            });

            // Track successful landings
            gameData.statistics.successfulLandings = (gameData.statistics.successfulLandings || 0) + 1;

            // Now actually enter the world
            initWorld(civ);
        }

        function landingCrash(reason) {
            landingGame.active = false;
            cancelAnimationFrame(landingGame.animFrame);

            cleanupLandingGame();

            showNotification(`Crash landing! ${reason}`, 'error');
            AudioSystem.error();

            // Take damage
            gameData.player.hp = Math.max(1, gameData.player.hp - 20);
            updateHealthUI();

            // Track crashes
            gameData.statistics.crashLandings = (gameData.statistics.crashLandings || 0) + 1;

            mode = 'galaxy';
        }

        function abortLanding() {
            landingGame.active = false;
            cancelAnimationFrame(landingGame.animFrame);
            cleanupLandingGame();
            mode = 'galaxy';
            showNotification('Landing aborted. Returning to orbit.', 'info');
        }

        function cleanupLandingGame() {
            document.getElementById('landing-overlay').style.display = 'none';
            if (landingGame.renderer) {
                landingGame.renderer.dispose();
                const container = document.getElementById('landing-scene-container');
                if (container) container.innerHTML = '';
            }
            // Reset keys
            Object.keys(landingKeys).forEach(k => landingKeys[k] = false);
        }

        // Math Utils
        class SeededRNG {
            constructor(seed) { this.seed = this.hash(seed); }
            hash(str) {
                let h = 0; for(let i=0;i<str.length;i++) h = Math.imul(31,h)+str.charCodeAt(i)|0;
                return Math.abs(h);
            }
            next() { this.seed = (this.seed * 16807) % 2147483647; return (this.seed - 1) / 2147483646; }
            range(min, max) { return min + this.next() * (max - min); }
            int(min, max) { return Math.floor(this.range(min, max+1)); }
            pick(arr) { return arr[Math.floor(this.next() * arr.length)]; }
        }

        // Simple noise for terrain
        function noise(x, z) {
            return Math.sin(x * 0.1) * Math.cos(z * 0.1) + Math.sin(x*0.3 + z*0.2)*0.5;
        }

        // --- GLOBAL STATE ---
        let scene, camera, renderer;
        let mode = 'galaxy';
        let activeCiv = null;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let isTouchDevice = 'ontouchstart' in window;

        // Galaxy State
        let civilizations = [];
        let galaxyGroup = new THREE.Group();
        let selectionRing;
        let lastTime = 0;
        let cycle = 0;

        // Floater pool for performance
        const floaterPool = [];
        const MAX_FLOATERS = 20;

        // RPG State
        let worldState = {
            player: null,
            terrain: [],
            interactables: [],
            fishingSpots: [],
            mobs: [],
            pois: [], // v4.2: Points of Interest
            structures: [], // v5.18: Battery chargers and built structures
            terraformedAreas: [], // v5.18: Flattened terrain zones
            sun: null,
            ambient: null,
            timeOfDay: 0,
            target: null,
            interactTarget: null,
            lastActionTime: 0, // v4.0: Cooldown-based interactions
            lastPlayerPos: null // v4.2: For distance tracking
        };

        // v5.18: Robot Energy System
        let robotEnergy = {
            current: 100,
            max: 100,
            drainRate: 0.02, // Energy drain per second when moving
            chargeRate: 5,   // Energy gain per second when on charger
            lowEnergyThreshold: 20,
            isCharging: false
        };

        // v5.18: P2P Spectator Streaming System
        let p2pStreaming = {
            peer: null,
            peerId: null,
            isHost: true,           // Host (player) or spectator
            connections: [],        // Active spectator connections
            hostConnection: null,   // Connection to host (when spectator)
            qrCodeVisible: false,
            lastFrameTime: 0,
            frameInterval: 100,     // Send frame every 100ms (10 FPS for efficiency)
            spectatorCount: 0,
            streamCanvas: null,     // Offscreen canvas for capturing
            isSpectating: false,
            spectatorData: null,    // Received data when spectating
            // v5.20: Simple stream controls
            streamPaused: false,    // When true, camera stops syncing
            hostGameMode: null      // Track host's current mode
        };

        // v5.5: Autonomous Exploration System
        let autoExplore = {
            enabled: true,  // Start in auto mode
            currentTarget: null,
            lastTargetTime: 0,
            targetCooldown: 3000,  // Time between target switches
            idleTime: 0,
            state: 'exploring',  // exploring, gathering, combat, idle
            combatTarget: null
        };

        function toggleAutoExplore() {
            autoExplore.enabled = !autoExplore.enabled;
            autoExplore.currentTarget = null;
            updateAutoExploreUI();
            showNotification(autoExplore.enabled ? 'AUTOPILOT: Exploring automatically' : 'MANUAL: You have control', 'info');
        }

        function updateAutoExploreUI() {
            const btn = document.getElementById('auto-explore-btn');
            const indicator = document.getElementById('auto-explore-indicator');
            if (btn) {
                btn.textContent = autoExplore.enabled ? 'Take Manual Control' : 'Enable Autopilot';
                btn.style.background = autoExplore.enabled ? '#00ff88' : '#ff8844';
            }
            if (indicator) {
                indicator.textContent = autoExplore.enabled ? 'ðŸ¤– AUTOPILOT' : 'ðŸŽ® MANUAL';
                indicator.style.color = autoExplore.enabled ? '#00ff88' : '#ff8844';
            }
        }

        function runAutoExplore(dt) {
            if (!autoExplore.enabled || mode !== 'world' || !worldState.player) return false;

            const player = worldState.player;
            const now = performance.now();

            // Priority 1: Combat - attack nearby enemies
            if (worldState.mobs.length > 0) {
                let nearestMob = null;
                let nearestDist = Infinity;

                worldState.mobs.forEach(mob => {
                    if (!mob.parent) return;
                    const dist = player.position.distanceTo(mob.position);
                    if (dist < 25 && dist < nearestDist) {
                        nearestDist = dist;
                        nearestMob = mob;
                    }
                });

                if (nearestMob) {
                    autoExplore.state = 'combat';
                    autoExplore.combatTarget = nearestMob;

                    // Move toward mob if not in range
                    if (nearestDist > CONFIG.INTERACTION_RANGE) {
                        worldState.target = nearestMob.position.clone();
                        worldState.interactTarget = nearestMob;
                    } else {
                        // Attack!
                        worldState.target = null;
                        if (now - worldState.lastActionTime > CONFIG.INTERACTION_COOLDOWN) {
                            performAction(nearestMob);
                            worldState.lastActionTime = now;
                        }
                    }
                    return true;
                }
            }

            // Priority 2: Gather resources - only target actual harvestable resources
            let bestResource = null;
            let bestResourceDist = Infinity;

            // Check interactables for actual resources (trees, rocks, ores)
            worldState.interactables.forEach(obj => {
                if (!obj.parent) return;
                const name = obj.userData.name || '';
                // Only target actual resources, not decorations
                const isResource = name.includes('Tree') || name.includes('Rock') ||
                                   name.includes('Ore') || name.includes('Crystal') ||
                                   name.includes('Bush') || name.includes('Plant') ||
                                   name.includes('Mushroom') || name.includes('Herb');
                if (!isResource) return;

                const dist = player.position.distanceTo(obj.position);
                if (dist < 50 && dist < bestResourceDist) {
                    bestResourceDist = dist;
                    bestResource = obj;
                }
            });

            // Also check fishing spots
            if (!bestResource && worldState.fishingSpots) {
                worldState.fishingSpots.forEach(spot => {
                    if (!spot.parent) return;
                    const dist = player.position.distanceTo(spot.position);
                    if (dist < 50 && dist < bestResourceDist) {
                        bestResourceDist = dist;
                        bestResource = spot;
                    }
                });
            }

            if (bestResource) {
                autoExplore.state = 'gathering';
                autoExplore.currentTarget = null; // Clear random exploration target

                if (bestResourceDist > CONFIG.INTERACTION_RANGE) {
                    worldState.target = bestResource.position.clone();
                    worldState.interactTarget = bestResource;
                } else {
                    worldState.target = null;
                    if (now - worldState.lastActionTime > CONFIG.INTERACTION_COOLDOWN) {
                        performAction(bestResource);
                        worldState.lastActionTime = now;
                    }
                }
                return true;
            }

            // Priority 3: Explore - find new resources
            autoExplore.state = 'exploring';

            // Pick a new random target periodically or if stuck
            const stuckCheck = autoExplore.currentTarget &&
                player.position.distanceTo(autoExplore.currentTarget) === autoExplore.lastDistToTarget;

            if (stuckCheck) {
                autoExplore.stuckCounter = (autoExplore.stuckCounter || 0) + 1;
            } else {
                autoExplore.stuckCounter = 0;
            }
            autoExplore.lastDistToTarget = autoExplore.currentTarget ?
                player.position.distanceTo(autoExplore.currentTarget) : 0;

            // Pick new target if: no target, timeout, or stuck
            if (!autoExplore.currentTarget ||
                now - autoExplore.lastTargetTime > autoExplore.targetCooldown ||
                autoExplore.stuckCounter > 60) {

                // Try to find an unexplored area with resources
                let foundTarget = false;

                // Search for any resource in a wider area
                let anyResource = null;
                let anyResourceDist = Infinity;

                worldState.interactables.forEach(obj => {
                    if (!obj.parent) return;
                    const dist = player.position.distanceTo(obj.position);
                    if (dist > 10 && dist < anyResourceDist) { // Not too close, not too far
                        anyResourceDist = dist;
                        anyResource = obj;
                    }
                });

                if (anyResource && anyResourceDist < 100) {
                    autoExplore.currentTarget = anyResource.position.clone();
                    foundTarget = true;
                }

                // If no resources found, pick a random direction
                if (!foundTarget) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 20 + Math.random() * 20;
                    autoExplore.currentTarget = new THREE.Vector3(
                        player.position.x + Math.cos(angle) * distance,
                        0,
                        player.position.z + Math.sin(angle) * distance
                    );
                }

                // Clamp to world bounds
                autoExplore.currentTarget.x = Math.max(-45, Math.min(45, autoExplore.currentTarget.x));
                autoExplore.currentTarget.z = Math.max(-45, Math.min(45, autoExplore.currentTarget.z));
                autoExplore.lastTargetTime = now;
                autoExplore.stuckCounter = 0;
            }

            worldState.target = autoExplore.currentTarget;

            // Check if reached target
            if (autoExplore.currentTarget && player.position.distanceTo(autoExplore.currentTarget) < 3) {
                autoExplore.currentTarget = null;
            }

            return true;
        }

        // WASD Keyboard controls
        const keys = { w: false, a: false, s: false, d: false };

        // Persistent Game Data (saved to localStorage)
        let gameData = {
            version: VERSION,
            playtime: 0,
            lastPlayed: null,
            hasSeenTutorial: false, // v4.0: Tutorial tracking
            inventory: [],
            skills: {
                mining: { level: 1, xp: 0 },
                wood: { level: 1, xp: 0 },
                combat: { level: 1, xp: 0 },
                fishing: { level: 1, xp: 0 },
                cooking: { level: 1, xp: 0 },
                crafting: { level: 1, xp: 0 }
            },
            player: {
                hp: CONFIG.PLAYER_MAX_HP,
                maxHp: CONFIG.PLAYER_MAX_HP
            },
            visitedPlanets: [],
            statistics: {
                treesChopped: 0,
                oresMined: 0,
                mobsKilled: 0,
                fishCaught: 0,
                itemsCrafted: 0,
                fishCooked: 0,
                // v4.2: New stats
                poisDiscovered: 0,
                totalDamageDealt: 0,
                bossesDefeated: 0,
                distanceTraveled: 0
            },
            // v4.2: Player rank tracking
            playerRank: { points: 0, lastTitle: 'Novice Explorer' },
            // v4.2: Discovered POIs by planet
            discoveredPOIs: {},
            // v4.1: Achievement System
            achievements: {},
            // v4.1: Daily Challenge System
            dailyChallenge: {
                lastGenerated: null,
                completed: false,
                current: null,
                streak: 0,
                bestStreak: 0
            },
            // v4.4: Prestige System
            prestige: {
                level: 0,
                totalLifetimePoints: 0,
                bonuses: {
                    xpMultiplier: 1.0,
                    startingSkillBonus: 0
                }
            },
            // v4.4: Fog of War exploration tracking per planet
            exploredTiles: {},
            // v4.6: Settings
            settings: {
                masterVolume: 30,
                sfxEnabled: true,
                ambientEnabled: true,
                particleQuality: 'high',
                shadowsEnabled: true,
                screenShakeEnabled: true,
                hintsEnabled: true
            },
            // v5.1: Equipment slots
            equipment: {
                weapon: null,
                armor: null,
                accessory: null,
                tool: null
            },
            // v5.1: Item enchantments
            enchantments: {},
            // v5.2: Talent tree points
            talents: {}
        };

        // v4.4: Simulated Leaderboard Players for local comparison
        const SIMULATED_PLAYERS = [
            { name: 'StarSeeker_X', points: 500, rank: 'Pathfinder' },
            { name: 'CosmicNova', points: 2500, rank: 'Star Scout' },
            { name: 'VoidWalker99', points: 8000, rank: 'Galaxy Ranger' },
            { name: 'AstroLegend', points: 12000, rank: 'Void Hunter' },
            { name: 'NebulaKing', points: 18000, rank: 'Cosmic Legend' },
            { name: 'Explorer42', points: 150, rank: 'Wanderer' },
            { name: 'SpaceCadet', points: 350, rank: 'Wanderer' },
            { name: 'Starlight', points: 1200, rank: 'Pathfinder' }
        ];

        // v4.4: Prestige requirements and rewards
        const PRESTIGE_LEVELS = {
            1: { required: 15000, xpBonus: 0.10, skillBonus: 0 },
            2: { required: 20000, xpBonus: 0.10, skillBonus: 1 },
            3: { required: 30000, xpBonus: 0.15, skillBonus: 1 },
            4: { required: 50000, xpBonus: 0.20, skillBonus: 2 },
            5: { required: 100000, xpBonus: 0.25, skillBonus: 3 }
        };

        function canPrestige() {
            const currentLevel = gameData.prestige?.level || 0;
            const nextLevel = PRESTIGE_LEVELS[currentLevel + 1];
            if (!nextLevel) return false;
            return calculatePlayerPoints() >= nextLevel.required;
        }

        function performPrestige() {
            if (!canPrestige()) return false;

            const currentLevel = gameData.prestige?.level || 0;
            const newLevel = currentLevel + 1;
            const reward = PRESTIGE_LEVELS[newLevel];

            // Store lifetime stats
            const lifetimePoints = (gameData.prestige?.totalLifetimePoints || 0) + calculatePlayerPoints();

            // Calculate cumulative bonuses
            const newXpMultiplier = 1.0 + Object.entries(PRESTIGE_LEVELS)
                .filter(([lvl]) => parseInt(lvl) <= newLevel)
                .reduce((sum, [, data]) => sum + data.xpBonus, 0);
            const newSkillBonus = Object.entries(PRESTIGE_LEVELS)
                .filter(([lvl]) => parseInt(lvl) <= newLevel)
                .reduce((sum, [, data]) => sum + data.skillBonus, 0);

            // Keep achievements and daily challenge
            const keepData = {
                achievements: { ...gameData.achievements },
                dailyChallenge: { ...gameData.dailyChallenge },
                hasSeenTutorial: true,
                prestige: {
                    level: newLevel,
                    totalLifetimePoints: lifetimePoints,
                    bonuses: {
                        xpMultiplier: newXpMultiplier,
                        startingSkillBonus: newSkillBonus
                    }
                }
            };

            // Reset everything else
            gameData.version = VERSION;
            gameData.playtime = 0;
            gameData.inventory = [];
            gameData.visitedPlanets = [];
            gameData.discoveredPOIs = {};
            gameData.exploredTiles = {};
            gameData.playerRank = { points: 0, lastTitle: 'Novice Explorer' };

            // Reset skills with prestige bonus
            for (const skill of Object.keys(gameData.skills)) {
                gameData.skills[skill] = { level: 1 + newSkillBonus, xp: 0 };
            }

            // Reset statistics
            for (const stat of Object.keys(gameData.statistics)) {
                gameData.statistics[stat] = 0;
            }

            gameData.player = { hp: CONFIG.PLAYER_MAX_HP, maxHp: CONFIG.PLAYER_MAX_HP };

            // Restore kept data
            Object.assign(gameData, keepData);

            saveGameData();
            showNotification(`PRESTIGE ${newLevel}! XP +${Math.round((newXpMultiplier - 1) * 100)}%`, 'success');
            AudioSystem.levelUp();
            return true;
        }

        function getLeaderboardPosition() {
            const myPoints = calculatePlayerPoints();
            const allPlayers = [...SIMULATED_PLAYERS, { name: 'YOU', points: myPoints, rank: getPlayerRank().title }]
                .sort((a, b) => b.points - a.points);
            const myIndex = allPlayers.findIndex(p => p.name === 'YOU');
            return {
                position: myIndex + 1,
                total: allPlayers.length,
                nearby: allPlayers.slice(Math.max(0, myIndex - 2), myIndex + 3)
            };
        }

        // --- ACHIEVEMENT DEFINITIONS ---
        const ACHIEVEMENTS = {
            'first_landing': { name: 'First Contact', desc: 'Land on your first planet', icon: 'ðŸŒ' },
            'explorer_10': { name: 'Star Hopper', desc: 'Visit 10 different planets', icon: 'âœ¨' },
            'explorer_30': { name: 'Galaxy Wanderer', desc: 'Visit 30 planets', icon: 'ðŸš€' },
            'lumberjack_25': { name: 'Woodcutter', desc: 'Chop 25 trees', icon: 'ðŸª“' },
            'lumberjack_100': { name: 'Lumberjack', desc: 'Chop 100 trees', icon: 'ðŸŒ²' },
            'miner_25': { name: 'Prospector', desc: 'Mine 25 ore veins', icon: 'â›ï¸' },
            'miner_100': { name: 'Master Miner', desc: 'Mine 100 ore veins', icon: 'ðŸ’Ž' },
            'angler_10': { name: 'Fisherman', desc: 'Catch 10 fish', icon: 'ðŸŸ' },
            'angler_50': { name: 'Master Angler', desc: 'Catch 50 fish', icon: 'ðŸŽ£' },
            'slayer_10': { name: 'Slime Slayer', desc: 'Defeat 10 slimes', icon: 'âš”ï¸' },
            'slayer_50': { name: 'Exterminator', desc: 'Defeat 50 slimes', icon: 'ðŸ’€' },
            'crafter_10': { name: 'Apprentice', desc: 'Craft 10 items', icon: 'ðŸ”¨' },
            'crafter_50': { name: 'Master Craftsman', desc: 'Craft 50 items', icon: 'ðŸ†' },
            'max_skill': { name: 'Specialist', desc: 'Reach level 10 in any skill', icon: 'ðŸ“ˆ' },
            'playtime_1h': { name: 'Dedicated', desc: 'Play for 1 hour', icon: 'â°' },
            'survivor': { name: 'Survivor', desc: 'Heal 500 HP total', icon: 'â¤ï¸' },
            'daily_3': { name: 'Consistent', desc: 'Complete 3 daily challenges', icon: 'ðŸ“…' },
            'daily_7': { name: 'Weekly Warrior', desc: 'Complete 7 daily challenges', icon: 'ðŸ”¥' }
        };

        // --- DAILY CHALLENGE DEFINITIONS ---
        const DAILY_CHALLENGES = [
            { type: 'gather_logs', amount: 15, desc: 'Gather 15 logs', reward: { skill: 'wood', xp: 150 } },
            { type: 'gather_ore', amount: 12, desc: 'Mine 12 ore', reward: { skill: 'mining', xp: 150 } },
            { type: 'kill_mobs', amount: 5, desc: 'Defeat 5 slimes', reward: { skill: 'combat', xp: 200 } },
            { type: 'catch_fish', amount: 8, desc: 'Catch 8 fish', reward: { skill: 'fishing', xp: 150 } },
            { type: 'craft_items', amount: 3, desc: 'Craft 3 items', reward: { skill: 'crafting', xp: 100 } },
            { type: 'visit_planets', amount: 2, desc: 'Explore 2 new planets', reward: { skill: 'combat', xp: 200 } },
            { type: 'cook_fish', amount: 3, desc: 'Cook 3 fish', reward: { skill: 'cooking', xp: 120 } }
        ];

        // Tutorial functions
        function showTutorial() {
            document.getElementById('tutorial-overlay').style.display = 'flex';
        }

        function closeTutorial() {
            document.getElementById('tutorial-overlay').style.display = 'none';
            gameData.hasSeenTutorial = true;
            saveGameData();
            AudioSystem.click();
        }

        // --- ACHIEVEMENT SYSTEM ---
        function checkAchievements() {
            const s = gameData.statistics;
            const sk = gameData.skills;

            const checks = {
                'first_landing': () => gameData.visitedPlanets.length >= 1,
                'explorer_10': () => gameData.visitedPlanets.length >= 10,
                'explorer_30': () => gameData.visitedPlanets.length >= 30,
                'lumberjack_25': () => s.treesChopped >= 25,
                'lumberjack_100': () => s.treesChopped >= 100,
                'miner_25': () => s.oresMined >= 25,
                'miner_100': () => s.oresMined >= 100,
                'angler_10': () => s.fishCaught >= 10,
                'angler_50': () => s.fishCaught >= 50,
                'slayer_10': () => s.mobsKilled >= 10,
                'slayer_50': () => s.mobsKilled >= 50,
                'crafter_10': () => s.itemsCrafted >= 10,
                'crafter_50': () => s.itemsCrafted >= 50,
                'max_skill': () => Object.values(sk).some(skill => skill.level >= 10),
                'playtime_1h': () => gameData.playtime >= 3600,
                'survivor': () => (s.totalHealed || 0) >= 500,
                'daily_3': () => (gameData.dailyChallenge.completedCount || 0) >= 3,
                'daily_7': () => (gameData.dailyChallenge.completedCount || 0) >= 7
            };

            for (const [id, check] of Object.entries(checks)) {
                if (!gameData.achievements[id] && check()) {
                    unlockAchievement(id);
                }
            }
        }

        function unlockAchievement(id) {
            if (gameData.achievements[id]) return;

            const ach = ACHIEVEMENTS[id];
            if (!ach) return;

            gameData.achievements[id] = { unlockedAt: new Date().toISOString() };

            // Show achievement popup
            showAchievementPopup(ach.icon, ach.name, ach.desc);
            AudioSystem.levelUp();

            if (particles && worldState.player) {
                particles.emit(worldState.player.position, 25, 0xffd700, { spread: 6, lifetime: 1500 });
            }

            saveGameData();
        }

        function showAchievementPopup(icon, name, desc) {
            const popup = document.createElement('div');
            popup.className = 'achievement-popup';
            popup.innerHTML = `
                <div class="ach-icon">${icon}</div>
                <div class="ach-text">
                    <div class="ach-title">Achievement Unlocked!</div>
                    <div class="ach-name">${name}</div>
                    <div class="ach-desc">${desc}</div>
                </div>
            `;
            document.body.appendChild(popup);
            setTimeout(() => popup.remove(), 4000);
        }

        // --- DAILY CHALLENGE SYSTEM ---
        function generateDailyChallenge() {
            const today = new Date().toDateString();

            if (gameData.dailyChallenge.lastGenerated === today && gameData.dailyChallenge.current) {
                return gameData.dailyChallenge.current;
            }

            // Reset streak if missed a day
            if (gameData.dailyChallenge.lastGenerated) {
                const lastDate = new Date(gameData.dailyChallenge.lastGenerated);
                const now = new Date();
                const diffDays = Math.floor((now - lastDate) / (1000 * 60 * 60 * 24));
                if (diffDays > 1) {
                    gameData.dailyChallenge.streak = 0;
                }
            }

            // Use date as seed for consistent daily challenge
            const seed = new SeededRNG(today);
            const template = seed.pick(DAILY_CHALLENGES);
            const challenge = {
                ...template,
                progress: 0,
                startStats: { ...gameData.statistics },
                startPlanets: gameData.visitedPlanets.length
            };

            gameData.dailyChallenge.lastGenerated = today;
            gameData.dailyChallenge.current = challenge;
            gameData.dailyChallenge.completed = false;
            saveGameData();

            return challenge;
        }

        function updateDailyChallengeProgress() {
            if (!gameData.dailyChallenge.current || gameData.dailyChallenge.completed) return;

            const c = gameData.dailyChallenge.current;
            const start = c.startStats || {};
            const now = gameData.statistics;

            switch (c.type) {
                case 'gather_logs': c.progress = (now.treesChopped || 0) - (start.treesChopped || 0); break;
                case 'gather_ore': c.progress = (now.oresMined || 0) - (start.oresMined || 0); break;
                case 'kill_mobs': c.progress = (now.mobsKilled || 0) - (start.mobsKilled || 0); break;
                case 'catch_fish': c.progress = (now.fishCaught || 0) - (start.fishCaught || 0); break;
                case 'craft_items': c.progress = (now.itemsCrafted || 0) - (start.itemsCrafted || 0); break;
                case 'cook_fish': c.progress = (now.fishCooked || 0) - (start.fishCooked || 0); break;
                case 'visit_planets': c.progress = gameData.visitedPlanets.length - (c.startPlanets || 0); break;
            }

            if (c.progress >= c.amount && !gameData.dailyChallenge.completed) {
                completeDailyChallenge();
            }

            updateDailyChallengeUI();
        }

        function completeDailyChallenge() {
            gameData.dailyChallenge.completed = true;
            gameData.dailyChallenge.streak++;
            gameData.dailyChallenge.completedCount = (gameData.dailyChallenge.completedCount || 0) + 1;
            gameData.dailyChallenge.bestStreak = Math.max(gameData.dailyChallenge.bestStreak || 0, gameData.dailyChallenge.streak);

            // Apply reward with streak bonus
            const reward = gameData.dailyChallenge.current.reward;
            const streakMultiplier = 1 + (gameData.dailyChallenge.streak * 0.1);
            const xpReward = Math.floor(reward.xp * streakMultiplier);

            addXp(reward.skill, xpReward);

            showNotification(`Daily Challenge Complete! +${xpReward} ${reward.skill} XP (Streak: ${gameData.dailyChallenge.streak})`);
            AudioSystem.levelUp();

            checkAchievements();
            saveGameData();
        }

        function updateDailyChallengeUI() {
            const el = document.getElementById('daily-challenge');
            if (!el) return;

            const c = gameData.dailyChallenge.current;
            if (!c) {
                el.style.display = 'none';
                return;
            }

            el.style.display = 'block';
            document.getElementById('daily-desc').textContent = c.desc;
            document.getElementById('daily-progress-text').textContent = `${Math.min(c.progress || 0, c.amount)}/${c.amount}`;
            document.getElementById('daily-progress-fill').style.width = `${Math.min(100, ((c.progress || 0) / c.amount) * 100)}%`;
            document.getElementById('daily-streak').textContent = `Streak: ${gameData.dailyChallenge.streak} days`;

            if (gameData.dailyChallenge.completed) {
                el.classList.add('completed');
            } else {
                el.classList.remove('completed');
            }
        }

        // --- v4.2: PLAYER RANK SYSTEM ---
        function calculatePlayerPoints() {
            const s = gameData.statistics;
            const sk = gameData.skills;
            return (
                gameData.visitedPlanets.length * 50 +
                s.treesChopped * 2 +
                s.oresMined * 2 +
                s.mobsKilled * 10 +
                s.fishCaught * 3 +
                s.itemsCrafted * 5 +
                (s.poisDiscovered || 0) * 100 +
                Object.values(sk).reduce((sum, skill) => sum + skill.level * 20, 0) +
                Math.floor(gameData.playtime / 60)
            );
        }

        function getPlayerRank() {
            const points = calculatePlayerPoints();
            let rank = PLAYER_RANKS[0];
            for (const r of PLAYER_RANKS) {
                if (points >= r.points) rank = r;
            }
            return { ...rank, points };
        }

        function getSpecialTitles() {
            const s = gameData.statistics;
            const sk = gameData.skills;
            const titles = [];
            for (const [name, data] of Object.entries(SPECIAL_TITLES)) {
                if (data.condition(s, sk)) {
                    titles.push({ name, color: data.color });
                }
            }
            return titles;
        }

        function updatePlayerRank() {
            const rank = getPlayerRank();
            const oldTitle = gameData.playerRank?.lastTitle || 'Novice Explorer';

            gameData.playerRank = {
                points: rank.points,
                lastTitle: rank.title
            };

            // Show rank up notification
            if (rank.title !== oldTitle) {
                showNotification(`RANK UP! You are now: ${rank.title}`, 'success');
                AudioSystem.levelUp();
            }

            saveGameData();
        }

        // --- STATISTICS PANEL ---
        function showStatsPanel() {
            updateStatsDisplay();
            document.getElementById('stats-modal').style.display = 'flex';
        }

        function closeStatsModal() {
            document.getElementById('stats-modal').style.display = 'none';
        }

        // v4.9: Collection Codex System
        const CODEX_DATA = {
            creatures: [
                { id: 'wolf', name: 'Wolf', icon: 'ðŸº', biome: 'forest', description: 'A fierce forest predator' },
                { id: 'bear', name: 'Bear', icon: 'ðŸ»', biome: 'forest', description: 'Massive and dangerous' },
                { id: 'snake', name: 'Snake', icon: 'ðŸ', biome: 'desert', description: 'Venomous desert dweller' },
                { id: 'scorpion', name: 'Scorpion', icon: 'ðŸ¦‚', biome: 'desert', description: 'Deadly desert creature' },
                { id: 'yeti', name: 'Yeti', icon: 'ðŸ¦', biome: 'arctic', description: 'Legendary snow beast' },
                { id: 'penguin', name: 'Penguin', icon: 'ðŸ§', biome: 'arctic', description: 'Hardy arctic bird' },
                { id: 'shark', name: 'Shark', icon: 'ðŸ¦ˆ', biome: 'ocean', description: 'Apex ocean predator' },
                { id: 'octopus', name: 'Octopus', icon: 'ðŸ™', biome: 'ocean', description: 'Intelligent sea creature' },
                { id: 'dragon', name: 'Dragon', icon: 'ðŸ‰', biome: 'volcanic', description: 'Ancient fire-breathing beast' },
                { id: 'phoenix', name: 'Phoenix', icon: 'ðŸ”¥', biome: 'volcanic', description: 'Immortal flame bird' },
                { id: 'alien', name: 'Alien', icon: 'ðŸ‘½', biome: 'alien', description: 'Extraterrestrial lifeform' },
                { id: 'robot', name: 'Robot', icon: 'ðŸ¤–', biome: 'crystal', description: 'Mechanical guardian' },
                { id: 'elite', name: 'Elite Monster', icon: 'ðŸ‘¹', biome: 'any', description: 'Powerful elite creature' },
                { id: 'boss', name: 'World Boss', icon: 'ðŸ’€', biome: 'any', description: 'Legendary boss creature' }
            ],
            biomes: [
                { id: 'forest', name: 'Forest World', icon: 'ðŸŒ²', color: '#228B22' },
                { id: 'desert', name: 'Desert World', icon: 'ðŸœï¸', color: '#DEB887' },
                { id: 'arctic', name: 'Arctic World', icon: 'â„ï¸', color: '#87CEEB' },
                { id: 'ocean', name: 'Ocean World', icon: 'ðŸŒŠ', color: '#1E90FF' },
                { id: 'volcanic', name: 'Volcanic World', icon: 'ðŸŒ‹', color: '#FF4500' },
                { id: 'alien', name: 'Alien World', icon: 'ðŸ›¸', color: '#9400D3' },
                { id: 'crystal', name: 'Crystal World', icon: 'ðŸ’Ž', color: '#00CED1' },
                { id: 'mushroom', name: 'Mushroom World', icon: 'ðŸ„', color: '#FF69B4' }
            ]
        };

        function initCodexTracking() {
            if (!gameData.codex) {
                gameData.codex = {
                    creatures: {},
                    items: {},
                    biomes: {}
                };
            }
        }

        function trackCreatureKill(creatureType) {
            initCodexTracking();
            if (!gameData.codex.creatures[creatureType]) {
                gameData.codex.creatures[creatureType] = { count: 0, firstKill: Date.now() };
                showNotification(`New Codex Entry: ${creatureType}!`, 'success');
            }
            gameData.codex.creatures[creatureType].count++;
        }

        function trackItemDiscovery(itemName) {
            initCodexTracking();
            if (!gameData.codex.items[itemName]) {
                gameData.codex.items[itemName] = { count: 0, firstFound: Date.now() };
            }
            gameData.codex.items[itemName].count++;
        }

        function trackBiomeVisit(biomeType) {
            initCodexTracking();
            if (!gameData.codex.biomes[biomeType]) {
                gameData.codex.biomes[biomeType] = { visited: true, firstVisit: Date.now() };
                showNotification(`New Biome Discovered: ${biomeType}!`, 'success');
            }
        }

        function openCodexModal() {
            initCodexTracking();
            updateCodexDisplay();
            document.getElementById('codex-modal').style.display = 'flex';
        }

        function closeCodexModal() {
            document.getElementById('codex-modal').style.display = 'none';
        }

        function switchCodexTab(tab) {
            document.querySelectorAll('.codex-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.codex-content').forEach(c => c.style.display = 'none');
            document.querySelector(`.codex-tab[data-tab="${tab}"]`).classList.add('active');
            document.getElementById(`codex-${tab}`).style.display = 'block';
        }

        function updateCodexDisplay() {
            // Creatures
            const creaturesGrid = document.getElementById('codex-creatures-grid');
            let creaturesHtml = '';
            let discoveredCreatures = 0;
            CODEX_DATA.creatures.forEach(c => {
                const discovered = gameData.codex?.creatures?.[c.id];
                if (discovered) discoveredCreatures++;
                creaturesHtml += `
                    <div class="codex-entry ${discovered ? 'discovered' : 'undiscovered'}" title="${discovered ? c.description : '???'}">
                        <span class="entry-icon">${c.icon}</span>
                        <span class="entry-name">${discovered ? c.name : '???'}</span>
                        ${discovered ? `<span class="entry-count">Defeated: ${discovered.count}</span>` : ''}
                    </div>
                `;
            });
            creaturesGrid.innerHTML = creaturesHtml;
            document.getElementById('codex-creatures-count').textContent = discoveredCreatures;
            document.getElementById('codex-creatures-total').textContent = CODEX_DATA.creatures.length;

            // Items
            const itemsGrid = document.getElementById('codex-items-grid');
            let itemsHtml = '';
            let discoveredItems = 0;
            const allItems = Object.keys(ITEMS);
            allItems.forEach(itemName => {
                const item = ITEMS[itemName];
                const discovered = gameData.codex?.items?.[itemName];
                if (discovered) discoveredItems++;
                itemsHtml += `
                    <div class="codex-entry ${discovered ? 'discovered' : 'undiscovered'}" title="${discovered ? (item.description || itemName) : '???'}">
                        <span class="entry-icon">${item.icon || 'ðŸ“¦'}</span>
                        <span class="entry-name">${discovered ? itemName : '???'}</span>
                        ${discovered ? `<span class="entry-count">Found: ${discovered.count}</span>` : ''}
                    </div>
                `;
            });
            itemsGrid.innerHTML = itemsHtml;
            document.getElementById('codex-items-count').textContent = discoveredItems;
            document.getElementById('codex-items-total').textContent = allItems.length;

            // Biomes
            const biomesGrid = document.getElementById('codex-biomes-grid');
            let biomesHtml = '';
            let discoveredBiomes = 0;
            CODEX_DATA.biomes.forEach(b => {
                const discovered = gameData.codex?.biomes?.[b.id];
                if (discovered) discoveredBiomes++;
                biomesHtml += `
                    <div class="codex-entry ${discovered ? 'discovered' : 'undiscovered'}" style="${discovered ? `border-color: ${b.color}` : ''}">
                        <span class="entry-icon">${b.icon}</span>
                        <span class="entry-name">${discovered ? b.name : '???'}</span>
                    </div>
                `;
            });
            biomesGrid.innerHTML = biomesHtml;
            document.getElementById('codex-biomes-count').textContent = discoveredBiomes;
            document.getElementById('codex-biomes-total').textContent = CODEX_DATA.biomes.length;

            // Abilities
            const abilitiesGrid = document.getElementById('codex-abilities-grid');
            let abilitiesHtml = '';
            let unlockedAbilities = 0;
            const combatLevel = gameData.skills?.combat?.level || 1;
            Object.entries(COMBAT_ABILITIES).forEach(([key, ability]) => {
                const unlocked = combatLevel >= ability.unlockLevel;
                if (unlocked) unlockedAbilities++;
                abilitiesHtml += `
                    <div class="codex-entry ${unlocked ? 'discovered' : 'undiscovered'}" title="${unlocked ? ability.description : `Unlocks at Combat Lv ${ability.unlockLevel}`}">
                        <span class="entry-icon">${ability.icon}</span>
                        <span class="entry-name">${unlocked ? ability.name : '???'}</span>
                        <span class="entry-count">${unlocked ? `[${ability.key}]` : `Lv ${ability.unlockLevel}`}</span>
                    </div>
                `;
            });
            abilitiesGrid.innerHTML = abilitiesHtml;
            document.getElementById('codex-abilities-count').textContent = unlockedAbilities;
            document.getElementById('codex-abilities-total').textContent = Object.keys(COMBAT_ABILITIES).length;

            // v5.0: Pets
            initPetSystem();
            const petsGrid = document.getElementById('codex-pets-grid');
            let petsHtml = '';
            let collectedPets = 0;
            const ownedPets = gameData.pets?.owned || [];
            const activePet = gameData.pets?.active;

            Object.entries(PET_TYPES).forEach(([petId, pet]) => {
                const owned = ownedPets.includes(petId);
                const isActive = activePet === petId;
                if (owned) collectedPets++;

                petsHtml += `
                    <div class="codex-entry ${owned ? 'discovered' : 'undiscovered'} ${isActive ? 'active-pet' : ''}"
                         style="${owned ? `border-color: ${RARITY_COLORS[pet.rarity]}` : ''}; ${isActive ? 'box-shadow: 0 0 10px ' + RARITY_COLORS[pet.rarity] : ''}"
                         title="${owned ? pet.abilityDesc : '???'}"
                         onclick="${owned ? `setActivePet('${isActive ? '' : petId}')` : ''}">
                        <span class="entry-icon" style="font-size: 32px;">${pet.icon}</span>
                        <span class="entry-name" style="color: ${owned ? RARITY_COLORS[pet.rarity] : '#666'}">${owned ? pet.name : '???'}</span>
                        ${owned ? `<span class="entry-count" style="color: ${RARITY_COLORS[pet.rarity]}">${pet.rarity.toUpperCase()}</span>` : ''}
                        ${owned ? `<span style="font-size: 10px; color: #aaa;">${pet.abilityDesc}</span>` : ''}
                        ${isActive ? '<span style="color: #ff8c00; font-size: 10px;">ACTIVE</span>' : ''}
                    </div>
                `;
            });
            petsGrid.innerHTML = petsHtml;
            document.getElementById('codex-pets-count').textContent = collectedPets;
            document.getElementById('codex-pets-total').textContent = Object.keys(PET_TYPES).length;
            document.getElementById('active-pet-name').textContent = activePet ? PET_TYPES[activePet].name : 'None';
        }

        // v5.0: Quest System
        const QUEST_TEMPLATES = {
            daily: [
                { id: 'kill_mobs', name: 'Monster Hunter', desc: 'Defeat enemies', icon: 'âš”ï¸', target: 10, reward: { xp: 500, item: 'Health Potion' }, stat: 'mobsKilled' },
                { id: 'gather_wood', name: 'Lumberjack', desc: 'Chop down trees', icon: 'ðŸª“', target: 15, reward: { xp: 300 }, stat: 'treesChopped' },
                { id: 'mine_ore', name: 'Prospector', desc: 'Mine ore deposits', icon: 'â›ï¸', target: 10, reward: { xp: 400, item: 'Iron Ore' }, stat: 'oresMined' },
                { id: 'catch_fish', name: 'Angler', desc: 'Catch fish', icon: 'ðŸŽ£', target: 8, reward: { xp: 350 }, stat: 'fishCaught' },
                { id: 'visit_planets', name: 'Explorer', desc: 'Visit different planets', icon: 'ðŸŒ', target: 3, reward: { xp: 600 }, stat: 'planetsVisited' },
                { id: 'craft_items', name: 'Artisan', desc: 'Craft items', icon: 'ðŸ”¨', target: 5, reward: { xp: 400, item: 'Super Potion' }, stat: 'itemsCrafted' },
                { id: 'use_abilities', name: 'Ability Master', desc: 'Use combat abilities', icon: 'âœ¨', target: 20, reward: { xp: 450 }, stat: 'abilitiesUsed' },
                { id: 'kill_elites', name: 'Elite Slayer', desc: 'Defeat elite enemies', icon: 'ðŸ‘¹', target: 2, reward: { xp: 800, item: 'Void Fragment' }, stat: 'elitesKilled' }
            ],
            weekly: [
                { id: 'w_kill_mobs', name: 'Monster Massacre', desc: 'Defeat many enemies', icon: 'ðŸ’€', target: 100, reward: { xp: 5000, item: 'Legendary Blade' }, stat: 'mobsKilled' },
                { id: 'w_bosses', name: 'Boss Hunter', desc: 'Defeat world bosses', icon: 'ðŸ‰', target: 5, reward: { xp: 8000 }, stat: 'bossesDefeated' },
                { id: 'w_explore', name: 'Galactic Explorer', desc: 'Visit many planets', icon: 'ðŸš€', target: 15, reward: { xp: 6000 }, stat: 'planetsVisited' },
                { id: 'w_gather', name: 'Resource Mogul', desc: 'Gather total resources', icon: 'ðŸ“¦', target: 200, reward: { xp: 4000, item: 'Super Potion' }, stat: 'totalGathered' },
                { id: 'w_combat', name: 'Combat Veteran', desc: 'Deal damage with abilities', icon: 'âš¡', target: 50, reward: { xp: 5500 }, stat: 'abilitiesUsed' }
            ],
            story: [
                { id: 's_first_kill', name: 'First Blood', desc: 'Defeat your first enemy', icon: 'ðŸ©¸', target: 1, reward: { xp: 100 }, stat: 'mobsKilled', oneTime: true },
                { id: 's_first_planet', name: 'First Steps', desc: 'Visit your first planet', icon: 'ðŸ‘£', target: 1, reward: { xp: 200 }, stat: 'planetsVisited', oneTime: true },
                { id: 's_craft_weapon', name: 'Armed and Ready', desc: 'Craft a weapon', icon: 'ðŸ—¡ï¸', target: 1, reward: { xp: 300, item: 'Health Potion' }, stat: 'weaponsCrafted', oneTime: true },
                { id: 's_level_combat', name: 'Warrior\'s Path', desc: 'Reach Combat Level 5', icon: 'âš”ï¸', target: 5, reward: { xp: 500 }, stat: 'combatLevel', oneTime: true },
                { id: 's_first_boss', name: 'Giant Slayer', desc: 'Defeat a world boss', icon: 'ðŸ†', target: 1, reward: { xp: 1000, item: 'Magma Sword' }, stat: 'bossesDefeated', oneTime: true },
                { id: 's_master_combat', name: 'Combat Master', desc: 'Reach Combat Level 15', icon: 'ðŸŽ–ï¸', target: 15, reward: { xp: 2000 }, stat: 'combatLevel', oneTime: true },
                { id: 's_explore_all', name: 'Galaxy Conqueror', desc: 'Visit 30 planets', icon: 'ðŸŒŒ', target: 30, reward: { xp: 5000, item: 'Legendary Blade' }, stat: 'planetsVisited', oneTime: true },
                { id: 's_ultimate', name: 'Legendary Hero', desc: 'Reach Combat Level 20', icon: 'ðŸ‘‘', target: 20, reward: { xp: 10000 }, stat: 'combatLevel', oneTime: true }
            ]
        };

        function initQuestSystem() {
            if (!gameData.quests) {
                gameData.quests = {
                    daily: { quests: [], lastReset: 0, sessionStart: {} },
                    weekly: { quests: [], lastReset: 0, sessionStart: {} },
                    story: { completed: [], claimed: [] }
                };
            }
            checkQuestResets();
        }

        function checkQuestResets() {
            const now = Date.now();
            const dayMs = 24 * 60 * 60 * 1000;
            const weekMs = 7 * dayMs;

            // Daily reset (every 24 hours from first play)
            if (now - gameData.quests.daily.lastReset > dayMs) {
                generateDailyQuests();
            }

            // Weekly reset (every 7 days)
            if (now - gameData.quests.weekly.lastReset > weekMs) {
                generateWeeklyQuests();
            }
        }

        function generateDailyQuests() {
            const shuffled = [...QUEST_TEMPLATES.daily].sort(() => Math.random() - 0.5);
            const selected = shuffled.slice(0, 3);

            gameData.quests.daily = {
                quests: selected.map(q => ({ ...q, progress: 0, claimed: false })),
                lastReset: Date.now(),
                sessionStart: captureQuestStats()
            };
            saveGameData();
        }

        function generateWeeklyQuests() {
            const shuffled = [...QUEST_TEMPLATES.weekly].sort(() => Math.random() - 0.5);
            const selected = shuffled.slice(0, 2);

            gameData.quests.weekly = {
                quests: selected.map(q => ({ ...q, progress: 0, claimed: false })),
                lastReset: Date.now(),
                sessionStart: captureQuestStats()
            };
            saveGameData();
        }

        function captureQuestStats() {
            const s = gameData.statistics;
            return {
                mobsKilled: s.mobsKilled || 0,
                treesChopped: s.treesChopped || 0,
                oresMined: s.oresMined || 0,
                fishCaught: s.fishCaught || 0,
                planetsVisited: gameData.visitedPlanets.length,
                itemsCrafted: s.itemsCrafted || 0,
                bossesDefeated: s.bossesDefeated || 0,
                elitesKilled: s.elitesKilled || 0,
                abilitiesUsed: s.abilitiesUsed || 0,
                totalGathered: (s.treesChopped || 0) + (s.oresMined || 0) + (s.fishCaught || 0),
                combatLevel: gameData.skills?.combat?.level || 1,
                weaponsCrafted: s.weaponsCrafted || 0
            };
        }

        function getQuestProgress(quest, type) {
            const current = captureQuestStats();
            const start = gameData.quests[type]?.sessionStart || {};

            if (quest.oneTime) {
                return current[quest.stat] || 0;
            }

            const startVal = start[quest.stat] || 0;
            const currentVal = current[quest.stat] || 0;
            return Math.max(0, currentVal - startVal);
        }

        function openQuestModal() {
            initQuestSystem();
            updateQuestDisplay();
            document.getElementById('quest-modal').style.display = 'flex';
            startQuestTimers();
        }

        function closeQuestModal() {
            document.getElementById('quest-modal').style.display = 'none';
        }

        function switchQuestTab(tab) {
            document.querySelectorAll('#quest-modal .codex-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.quest-content').forEach(c => c.style.display = 'none');
            document.querySelector(`#quest-modal .codex-tab[data-tab="${tab}"]`).classList.add('active');
            document.getElementById(`quest-${tab}`).style.display = 'block';
        }

        let questTimerInterval = null;
        function startQuestTimers() {
            if (questTimerInterval) clearInterval(questTimerInterval);
            questTimerInterval = setInterval(updateQuestTimers, 1000);
            updateQuestTimers();
        }

        function updateQuestTimers() {
            const now = Date.now();
            const dayMs = 24 * 60 * 60 * 1000;
            const weekMs = 7 * dayMs;

            const dailyReset = (gameData.quests?.daily?.lastReset || now) + dayMs;
            const weeklyReset = (gameData.quests?.weekly?.lastReset || now) + weekMs;

            document.getElementById('daily-reset-timer').textContent = formatTimeRemaining(dailyReset - now);
            document.getElementById('weekly-reset-timer').textContent = formatTimeRemaining(weeklyReset - now);
        }

        function formatTimeRemaining(ms) {
            if (ms <= 0) return 'Resetting...';
            const hours = Math.floor(ms / (60 * 60 * 1000));
            const mins = Math.floor((ms % (60 * 60 * 1000)) / (60 * 1000));
            const secs = Math.floor((ms % (60 * 1000)) / 1000);
            return `${hours}h ${mins}m ${secs}s`;
        }

        function updateQuestDisplay() {
            // Daily quests
            const dailyList = document.getElementById('daily-quests-list');
            dailyList.innerHTML = renderQuestList(gameData.quests.daily.quests, 'daily');

            // Weekly quests
            const weeklyList = document.getElementById('weekly-quests-list');
            weeklyList.innerHTML = renderQuestList(gameData.quests.weekly.quests, 'weekly');

            // Story quests
            const storyList = document.getElementById('story-quests-list');
            storyList.innerHTML = renderStoryQuests();
        }

        function renderQuestList(quests, type) {
            return quests.map((quest, idx) => {
                const progress = getQuestProgress(quest, type);
                const percent = Math.min(100, (progress / quest.target) * 100);
                const completed = progress >= quest.target;
                const claimed = quest.claimed;

                return `
                    <div class="quest-item ${completed ? 'completed' : ''} ${claimed ? 'claimed' : ''}">
                        <div class="quest-header">
                            <span class="quest-title">${quest.icon} ${quest.name}</span>
                            <span class="quest-reward">+${quest.reward.xp} XP${quest.reward.item ? ` + ${quest.reward.item}` : ''}</span>
                        </div>
                        <div class="quest-desc">${quest.desc}</div>
                        <div class="quest-progress-bar">
                            <div class="quest-progress-fill" style="width: ${percent}%"></div>
                        </div>
                        <div class="quest-progress-text">${Math.min(progress, quest.target)} / ${quest.target}</div>
                        ${completed && !claimed ? `<button class="quest-claim-btn" onclick="claimQuest('${type}', ${idx})">Claim Reward</button>` : ''}
                        ${claimed ? '<div style="text-align: center; color: #4a4; font-size: 12px; margin-top: 8px;">âœ“ Claimed</div>' : ''}
                    </div>
                `;
            }).join('');
        }

        function renderStoryQuests() {
            return QUEST_TEMPLATES.story.map((quest, idx) => {
                const progress = captureQuestStats()[quest.stat] || 0;
                const percent = Math.min(100, (progress / quest.target) * 100);
                const completed = progress >= quest.target;
                const claimed = gameData.quests.story.claimed.includes(quest.id);

                return `
                    <div class="quest-item ${completed ? 'completed' : ''} ${claimed ? 'claimed' : ''}">
                        <div class="quest-header">
                            <span class="quest-title">${quest.icon} ${quest.name}</span>
                            <span class="quest-reward">+${quest.reward.xp} XP${quest.reward.item ? ` + ${quest.reward.item}` : ''}</span>
                        </div>
                        <div class="quest-desc">${quest.desc}</div>
                        <div class="quest-progress-bar">
                            <div class="quest-progress-fill" style="width: ${percent}%"></div>
                        </div>
                        <div class="quest-progress-text">${Math.min(progress, quest.target)} / ${quest.target}</div>
                        ${completed && !claimed ? `<button class="quest-claim-btn" onclick="claimStoryQuest('${quest.id}')">Claim Reward</button>` : ''}
                        ${claimed ? '<div style="text-align: center; color: #4a4; font-size: 12px; margin-top: 8px;">âœ“ Completed</div>' : ''}
                    </div>
                `;
            }).join('');
        }

        function claimQuest(type, idx) {
            const quest = gameData.quests[type].quests[idx];
            if (!quest || quest.claimed) return;

            quest.claimed = true;

            // Grant rewards
            addXp('combat', quest.reward.xp);
            if (quest.reward.item) {
                addItem(quest.reward.item);
            }

            showNotification(`Quest Complete: ${quest.name}! +${quest.reward.xp} XP`, 'success');
            AudioSystem.levelUp();

            if (worldState.player && particles) {
                particles.emit(worldState.player.position, 30, 0xffd700, { spread: 5, lifetime: 1000 });
            }

            saveGameData();
            updateQuestDisplay();
        }

        function claimStoryQuest(questId) {
            if (gameData.quests.story.claimed.includes(questId)) return;

            const quest = QUEST_TEMPLATES.story.find(q => q.id === questId);
            if (!quest) return;

            gameData.quests.story.claimed.push(questId);

            // Grant rewards
            addXp('combat', quest.reward.xp);
            if (quest.reward.item) {
                addItem(quest.reward.item);
            }

            showNotification(`Story Quest Complete: ${quest.name}!`, 'success');
            AudioSystem.levelUp();

            if (worldState.player && particles) {
                particles.emit(worldState.player.position, 40, 0xffd700, { spread: 6, lifetime: 1200 });
            }

            saveGameData();
            updateQuestDisplay();
        }

        // Track ability usage for quests
        function trackAbilityUsage() {
            if (!gameData.statistics.abilitiesUsed) gameData.statistics.abilitiesUsed = 0;
            gameData.statistics.abilitiesUsed++;
        }

        // v5.0: Pet Companion System
        const PET_TYPES = {
            slime: {
                name: 'Slime Buddy',
                icon: 'ðŸŸ¢',
                color: 0x44ff44,
                rarity: 'common',
                dropChance: 0.05,
                ability: 'regen',
                abilityDesc: '+1 HP/5s',
                speed: 3
            },
            firefly: {
                name: 'Firefly',
                icon: 'âœ¨',
                color: 0xffff00,
                rarity: 'common',
                dropChance: 0.04,
                ability: 'light',
                abilityDesc: 'Reveals hidden items',
                speed: 5
            },
            crystal: {
                name: 'Crystal Sprite',
                icon: 'ðŸ’Ž',
                color: 0x00ffff,
                rarity: 'uncommon',
                dropChance: 0.02,
                ability: 'luck',
                abilityDesc: '+10% drop rate',
                speed: 4
            },
            shadow: {
                name: 'Shadow Wisp',
                icon: 'ðŸ‘»',
                color: 0x8800ff,
                rarity: 'uncommon',
                dropChance: 0.02,
                ability: 'dodge',
                abilityDesc: '+5% dodge chance',
                speed: 6
            },
            phoenix: {
                name: 'Mini Phoenix',
                icon: 'ðŸ”¥',
                color: 0xff4400,
                rarity: 'rare',
                dropChance: 0.008,
                ability: 'damage',
                abilityDesc: '+15% damage',
                speed: 5
            },
            dragon: {
                name: 'Baby Dragon',
                icon: 'ðŸ²',
                color: 0xff0088,
                rarity: 'rare',
                dropChance: 0.005,
                ability: 'attack',
                abilityDesc: 'Attacks nearby enemies',
                speed: 4
            },
            void: {
                name: 'Void Entity',
                icon: 'ðŸŒ€',
                color: 0x4400ff,
                rarity: 'legendary',
                dropChance: 0.002,
                ability: 'absorb',
                abilityDesc: '+25% XP gain',
                speed: 3
            },
            celestial: {
                name: 'Celestial Star',
                icon: 'â­',
                color: 0xffd700,
                rarity: 'legendary',
                dropChance: 0.001,
                ability: 'allStats',
                abilityDesc: '+10% all stats',
                speed: 7
            }
        };

        const RARITY_COLORS = {
            common: '#aaaaaa',
            uncommon: '#00ff00',
            rare: '#0088ff',
            legendary: '#ff8800'
        };

        let activePetMesh = null;
        let petAnimTime = 0;

        function initPetSystem() {
            if (!gameData.pets) {
                gameData.pets = {
                    owned: [],
                    active: null
                };
            }
        }

        function tryDropPet(mobType) {
            initPetSystem();
            // Each mob kill has a chance to drop a random pet
            for (const [petId, pet] of Object.entries(PET_TYPES)) {
                if (Math.random() < pet.dropChance) {
                    if (!gameData.pets.owned.includes(petId)) {
                        gameData.pets.owned.push(petId);
                        showNotification(`NEW PET: ${pet.icon} ${pet.name}!`, 'success');
                        AudioSystem.levelUp();
                        if (worldState.player && particles) {
                            particles.emit(worldState.player.position, 40, pet.color, { spread: 6, lifetime: 1500 });
                        }
                        saveGameData();
                        return true;
                    }
                }
            }
            return false;
        }

        function setActivePet(petId) {
            initPetSystem();
            if (petId && !gameData.pets.owned.includes(petId)) return;

            gameData.pets.active = petId;
            updatePetMesh();
            saveGameData();

            if (petId) {
                const pet = PET_TYPES[petId];
                showNotification(`${pet.icon} ${pet.name} is now your companion!`);
            } else {
                showNotification('Pet dismissed');
            }
        }

        function updatePetMesh() {
            // Remove existing pet
            if (activePetMesh) {
                scene.remove(activePetMesh);
                activePetMesh = null;
            }

            if (!gameData.pets?.active || mode !== 'world') return;

            const pet = PET_TYPES[gameData.pets.active];
            if (!pet) return;

            // Create pet mesh
            const geometry = new THREE.SphereGeometry(0.4, 8, 8);
            const material = new THREE.MeshStandardMaterial({
                color: pet.color,
                emissive: pet.color,
                emissiveIntensity: 0.5
            });
            activePetMesh = new THREE.Mesh(geometry, material);
            activePetMesh.castShadow = true;

            // Add glow
            const glowGeo = new THREE.SphereGeometry(0.6, 8, 8);
            const glowMat = new THREE.MeshBasicMaterial({
                color: pet.color,
                transparent: true,
                opacity: 0.3
            });
            const glow = new THREE.Mesh(glowGeo, glowMat);
            activePetMesh.add(glow);

            scene.add(activePetMesh);
        }

        function updatePet(dt, time) {
            if (!activePetMesh || !worldState.player) return;

            const pet = PET_TYPES[gameData.pets?.active];
            if (!pet) return;

            petAnimTime += dt;

            // Follow player with offset
            const targetX = worldState.player.position.x + Math.sin(petAnimTime * 2) * 1.5;
            const targetZ = worldState.player.position.z + Math.cos(petAnimTime * 2) * 1.5;
            const targetY = worldState.player.position.y + 2 + Math.sin(petAnimTime * 3) * 0.3;

            // Smooth follow
            activePetMesh.position.x += (targetX - activePetMesh.position.x) * dt * pet.speed;
            activePetMesh.position.z += (targetZ - activePetMesh.position.z) * dt * pet.speed;
            activePetMesh.position.y += (targetY - activePetMesh.position.y) * dt * pet.speed;

            // Rotate
            activePetMesh.rotation.y += dt * 2;

            // Dragon attack ability
            if (pet.ability === 'attack' && Math.random() < 0.01) {
                const nearestMob = findNearestMob(activePetMesh.position, 8);
                if (nearestMob) {
                    const damage = Math.max(1, Math.floor(getPlayerDamage() * 0.3));
                    nearestMob.userData.hp -= damage;
                    spawnFloater(nearestMob.position, `ðŸ² -${damage}`, '#ff0088');
                    if (particles) particles.emit(nearestMob.position, 5, 0xff0088);
                    if (nearestMob.userData.hp <= 0) {
                        performAction(nearestMob);
                    }
                }
            }
        }

        function findNearestMob(position, range) {
            let nearest = null;
            let minDist = range;
            worldState.mobs.forEach(mob => {
                const dist = mob.position.distanceTo(position);
                if (dist < minDist) {
                    minDist = dist;
                    nearest = mob;
                }
            });
            return nearest;
        }

        function getPetBonuses() {
            const bonuses = {
                regen: 0,
                luck: 0,
                dodge: 0,
                damage: 0,
                xp: 0,
                allStats: 0
            };

            if (!gameData.pets?.active) return bonuses;

            const pet = PET_TYPES[gameData.pets.active];
            if (!pet) return bonuses;

            switch (pet.ability) {
                case 'regen': bonuses.regen = 1; break;
                case 'luck': bonuses.luck = 0.1; break;
                case 'dodge': bonuses.dodge = 0.05; break;
                case 'damage': bonuses.damage = 0.15; break;
                case 'absorb': bonuses.xp = 0.25; break;
                case 'allStats': bonuses.allStats = 0.1; break;
            }

            return bonuses;
        }

        // Pet regen tick
        let lastPetRegenTick = 0;
        function updatePetRegen(time) {
            const bonuses = getPetBonuses();
            if (bonuses.regen > 0 && time - lastPetRegenTick > 5000) {
                lastPetRegenTick = time;
                if (gameData.player.hp < gameData.player.maxHp) {
                    gameData.player.hp = Math.min(gameData.player.maxHp, gameData.player.hp + bonuses.regen);
                    updateHealthUI();
                    if (worldState.player) {
                        spawnFloater(worldState.player.position, `+${bonuses.regen}`, '#88ff88');
                    }
                }
            }
        }

        // ============================================
        // v5.6: COPILOT COMPANION SYSTEM
        // Follows the player with advice and assistance
        // ============================================
        let copilotMesh = null;
        let copilotAnimTime = 0;
        let copilotChatOpen = false;
        let copilotConversationHistory = [];
        let copilotVoiceRecognition = null;
        let copilotIsListening = false;
        let copilotSynthesis = window.speechSynthesis;
        let speechRecognizer = null; // v5.9: Azure Speech SDK recognizer

        // v5.10: Star Wars 3D Text Crawl System
        let copilotTextFont = null;
        let copilotTextGroup = null;        // Group for scrolling text
        let copilotTextMeshes = [];         // Individual text line meshes
        let copilotActiveTextAnimation = null;
        let copilotPersistentTextGroup = null; // Stays after scroll completes

        const COPILOT_CONFIG = {
            followDistance: 3,      // Distance behind player
            floatHeight: 2.5,       // Height above ground
            floatAmplitude: 0.4,    // Bobbing amount
            floatSpeed: 2,          // Bobbing speed
            orbitSpeed: 0.5,        // Circling speed
            followSmoothing: 4,     // How quickly it catches up
            color: 0x8a2be2,        // Primary color (purple)
            glowColor: 0x06ffa5,    // Glow color (cyan/green)
            particleCount: 30
        };

        // ============================================
        // v5.9: COPILOT TASK SYSTEM
        // Allows Copilot to perform autonomous tasks
        // ============================================
        const COPILOT_TASK_TYPES = {
            gather: {
                name: 'Gathering Resources',
                icon: 'ðŸªµ',
                duration: 12000,
                statusMessages: ['Searching for resources...', 'Found something!', 'Collecting materials...'],
                progressClass: ''
            },
            hunt: {
                name: 'Hunting Enemies',
                icon: 'âš”ï¸',
                duration: 15000,
                statusMessages: ['Scanning for targets...', 'Engaging enemy!', 'Combat in progress...'],
                progressClass: 'hunting'
            },
            scout: {
                name: 'Scouting Area',
                icon: 'ðŸ”',
                duration: 10000,
                statusMessages: ['Flying ahead...', 'Surveying the area...', 'Analyzing terrain...'],
                progressClass: 'scouting'
            },
            protect: {
                name: 'Protection Mode',
                icon: 'ðŸ›¡ï¸',
                duration: 0, // Continuous
                continuous: true,
                statusMessages: ['Guarding you...', 'Watching for threats...', 'Standing ready...'],
                progressClass: 'protecting'
            },
            heal: {
                name: 'Healing Support',
                icon: 'ðŸ’š',
                duration: 8000,
                statusMessages: ['Channeling healing energy...', 'Restoring your health...'],
                progressClass: ''
            },
            fish: {
                name: 'Fishing',
                icon: 'ðŸŽ£',
                duration: 15000,
                statusMessages: ['Finding a good spot...', 'Casting line...', 'Waiting for a bite...', 'Got one!'],
                progressClass: ''
            },
            mine: {
                name: 'Mining Ore',
                icon: 'â›ï¸',
                duration: 14000,
                statusMessages: ['Looking for ore veins...', 'Mining deposit...', 'Extracting minerals...'],
                progressClass: ''
            }
        };

        // Task state
        let copilotTask = {
            active: null,
            type: null,
            startTime: 0,
            progress: 0,
            results: [],
            targetPosition: null,
            continuous: false
        };

        // Assign a task to the Copilot
        function assignCopilotTask(taskType, params = {}) {
            const taskConfig = COPILOT_TASK_TYPES[taskType];
            if (!taskConfig) {
                addCopilotMessage(`I don't know how to do that task.`, 'ai');
                return false;
            }

            // Check if already on a task
            if (copilotTask.active) {
                addCopilotMessage(`I'm currently busy with ${COPILOT_TASK_TYPES[copilotTask.type].name}. Say "recall" or "come back" to cancel it first.`, 'ai');
                return false;
            }

            // Start the task
            copilotTask = {
                active: true,
                type: taskType,
                startTime: performance.now(),
                progress: 0,
                results: [],
                params: params,
                continuous: taskConfig.continuous || false
            };

            // Show task panel
            showTaskPanel(taskType);

            // Update copilot button indicator
            document.getElementById('copilot-button').classList.add('has-task');

            // Announce task start
            const startMessages = [
                `On it! I'll start ${taskConfig.name.toLowerCase()} now.`,
                `Understood! Beginning ${taskConfig.name.toLowerCase()}.`,
                `Leave it to me! ${taskConfig.name} in progress.`
            ];
            addCopilotMessage(startMessages[Math.floor(Math.random() * startMessages.length)], 'ai');

            // Speak if Azure TTS available
            if (rappidSettings.azureTTSKey) {
                speakWithAzureTTS(`Starting ${taskConfig.name.toLowerCase()}.`);
            }

            return true;
        }

        // Show the task panel UI
        function showTaskPanel(taskType) {
            const taskConfig = COPILOT_TASK_TYPES[taskType];
            const panel = document.getElementById('copilot-task-panel');

            document.getElementById('task-icon').textContent = taskConfig.icon;
            document.getElementById('task-name').textContent = taskConfig.name;
            document.getElementById('task-status').textContent = taskConfig.statusMessages[0];
            document.getElementById('task-progress-bar').style.width = '0%';
            document.getElementById('task-progress-bar').className = 'copilot-task-progress-bar ' + taskConfig.progressClass;
            document.getElementById('task-results').style.display = 'none';
            document.getElementById('task-results').innerHTML = '';

            panel.classList.add('active');
        }

        // Hide task panel
        function hideTaskPanel() {
            document.getElementById('copilot-task-panel').classList.remove('active');
        }

        // Recall the Copilot (cancel current task)
        function recallCopilot() {
            if (!copilotTask.active) return;

            const taskConfig = COPILOT_TASK_TYPES[copilotTask.type];

            // Partial results if any progress was made
            if (copilotTask.progress > 0.3 && copilotTask.results.length > 0) {
                completeTask(true); // Partial completion
            } else {
                addCopilotMessage(`Returning to you! Task cancelled.`, 'ai');
                if (rappidSettings.azureTTSKey) {
                    speakWithAzureTTS(`Coming back!`);
                }
            }

            // Reset task state
            copilotTask = {
                active: false,
                type: null,
                startTime: 0,
                progress: 0,
                results: [],
                continuous: false
            };

            hideTaskPanel();
            document.getElementById('copilot-button').classList.remove('has-task');
        }

        // Update task progress (called in game loop)
        function updateCopilotTask(deltaTime) {
            if (!copilotTask.active) return;

            const taskConfig = COPILOT_TASK_TYPES[copilotTask.type];
            const elapsed = performance.now() - copilotTask.startTime;

            // Continuous tasks (like protect) don't have progress
            if (copilotTask.continuous) {
                // Update status message periodically
                const msgIndex = Math.floor((elapsed / 3000) % taskConfig.statusMessages.length);
                document.getElementById('task-status').textContent = taskConfig.statusMessages[msgIndex];
                document.getElementById('task-progress-bar').style.width = '100%';

                // Continuous task effects
                handleContinuousTaskEffect(copilotTask.type, deltaTime);
                return;
            }

            // Calculate progress
            copilotTask.progress = Math.min(1, elapsed / taskConfig.duration);
            document.getElementById('task-progress-bar').style.width = (copilotTask.progress * 100) + '%';

            // Update status message based on progress
            const msgIndex = Math.floor(copilotTask.progress * taskConfig.statusMessages.length);
            const clampedIndex = Math.min(msgIndex, taskConfig.statusMessages.length - 1);
            document.getElementById('task-status').textContent = taskConfig.statusMessages[clampedIndex];

            // Generate results during task
            generateTaskResults(copilotTask.type, copilotTask.progress);

            // Check if task is complete
            if (copilotTask.progress >= 1) {
                completeTask(false);
            }
        }

        // Generate results based on task type and progress
        function generateTaskResults(taskType, progress) {
            // Only generate at certain thresholds
            const thresholds = [0.3, 0.6, 0.9];
            const currentThreshold = thresholds.find(t => progress >= t && !copilotTask.results.some(r => r.threshold === t));

            if (!currentThreshold) return;

            let result = { threshold: currentThreshold };

            switch (taskType) {
                case 'gather':
                    const gatherItems = ['Logs', 'Fiber', 'Stone', 'Herbs'];
                    result.item = gatherItems[Math.floor(Math.random() * gatherItems.length)];
                    result.amount = Math.floor(Math.random() * 3) + 1;
                    break;

                case 'hunt':
                    result.xp = Math.floor(Math.random() * 30) + 20;
                    result.gold = Math.floor(Math.random() * 15) + 5;
                    if (Math.random() < 0.3) {
                        result.loot = ['Raw Meat', 'Monster Fang', 'Beast Hide'][Math.floor(Math.random() * 3)];
                    }
                    break;

                case 'scout':
                    const discoveries = [
                        'Found a resource node nearby!',
                        'Spotted enemy patrol to the east.',
                        'Discovered a safe area ahead.',
                        'Located a point of interest.',
                        'Mapped the surrounding terrain.'
                    ];
                    result.discovery = discoveries[Math.floor(Math.random() * discoveries.length)];
                    break;

                case 'heal':
                    result.healAmount = Math.floor(Math.random() * 15) + 10;
                    break;

                case 'fish':
                    if (Math.random() < 0.7) {
                        result.item = 'Raw Fish';
                        result.amount = Math.floor(Math.random() * 2) + 1;
                    }
                    break;

                case 'mine':
                    const oreTypes = ['Iron Ore', 'Copper Ore', 'Stone'];
                    result.item = oreTypes[Math.floor(Math.random() * oreTypes.length)];
                    result.amount = Math.floor(Math.random() * 2) + 1;
                    break;
            }

            copilotTask.results.push(result);
            updateTaskResultsUI();
        }

        // Handle continuous task effects
        function handleContinuousTaskEffect(taskType, deltaTime) {
            switch (taskType) {
                case 'protect':
                    // Protect mode: automatically attack nearby enemies
                    // (visual effect - enemies near player take slight damage)
                    if (worldState.mobs) {
                        worldState.mobs.forEach(mob => {
                            if (mob.mesh && worldState.player) {
                                const dist = mob.mesh.position.distanceTo(worldState.player.position);
                                if (dist < 8 && Math.random() < 0.02) {
                                    // Copilot attacks enemy
                                    mob.hp -= 5;
                                    spawnFloater(mob.mesh.position, '-5', '#ff88ff');
                                    if (mob.hp <= 0) {
                                        addCopilotMessage(`I took care of that enemy for you!`, 'ai');
                                    }
                                }
                            }
                        });
                    }
                    break;
            }
        }

        // Update the results UI
        function updateTaskResultsUI() {
            const resultsDiv = document.getElementById('task-results');
            if (copilotTask.results.length === 0) {
                resultsDiv.style.display = 'none';
                return;
            }

            resultsDiv.style.display = 'block';
            let html = '';

            copilotTask.results.forEach(result => {
                if (result.item) {
                    html += `<div class="result-item positive">+${result.amount} ${result.item}</div>`;
                }
                if (result.xp) {
                    html += `<div class="result-item positive">+${result.xp} XP</div>`;
                }
                if (result.gold) {
                    html += `<div class="result-item positive">+${result.gold} Gold</div>`;
                }
                if (result.loot) {
                    html += `<div class="result-item positive">+1 ${result.loot}</div>`;
                }
                if (result.discovery) {
                    html += `<div class="result-item">${result.discovery}</div>`;
                }
                if (result.healAmount) {
                    html += `<div class="result-item positive">+${result.healAmount} HP</div>`;
                }
            });

            resultsDiv.innerHTML = html;
        }

        // Complete the task and apply rewards
        function completeTask(partial = false) {
            const taskConfig = COPILOT_TASK_TYPES[copilotTask.type];

            // Apply all results to game state
            copilotTask.results.forEach(result => {
                if (result.item && result.amount) {
                    // Add items to inventory
                    addToInventory(result.item, result.amount);
                }
                if (result.xp) {
                    gainSkillXP('combat', result.xp);
                }
                if (result.gold) {
                    gameData.gold = (gameData.gold || 0) + result.gold;
                }
                if (result.loot) {
                    addToInventory(result.loot, 1);
                }
                if (result.healAmount) {
                    gameData.player.hp = Math.min(gameData.player.maxHp, gameData.player.hp + result.healAmount);
                    updateHealthUI();
                }
            });

            // Completion message
            const completeMessages = partial ? [
                `I'm back! I managed to get some things done before returning.`,
                `Returning with partial results. Here's what I gathered.`
            ] : [
                `Task complete! Here's what I found.`,
                `All done! The ${taskConfig.name.toLowerCase()} was successful.`,
                `Mission accomplished! I've returned with the results.`
            ];

            addCopilotMessage(completeMessages[Math.floor(Math.random() * completeMessages.length)], 'ai');

            if (rappidSettings.azureTTSKey) {
                speakWithAzureTTS(partial ? `I'm back with some results.` : `Task complete!`);
            }

            // Show final results
            document.getElementById('task-status').textContent = partial ? 'Recalled - Partial results' : 'Complete!';
            document.getElementById('task-progress-bar').style.width = '100%';

            // Keep panel visible briefly to show results
            setTimeout(() => {
                hideTaskPanel();
                document.getElementById('copilot-button').classList.remove('has-task');

                // Reset task state
                copilotTask = {
                    active: false,
                    type: null,
                    startTime: 0,
                    progress: 0,
                    results: [],
                    continuous: false
                };
            }, 3000);

            saveGameData();
        }

        // Helper: Add item to inventory
        function addToInventory(itemName, amount) {
            if (!gameData.inventory) gameData.inventory = [];

            // Find existing stack or empty slot
            let existingIdx = gameData.inventory.findIndex(item => item && item.name === itemName);
            if (existingIdx >= 0) {
                gameData.inventory[existingIdx].amount = (gameData.inventory[existingIdx].amount || 1) + amount;
            } else {
                // Find empty slot
                let emptyIdx = gameData.inventory.findIndex(item => !item);
                if (emptyIdx < 0) {
                    emptyIdx = gameData.inventory.length;
                }
                gameData.inventory[emptyIdx] = { name: itemName, amount: amount };
            }

            updateInventoryUI();
        }

        // Parse natural language for task commands
        function parseCopilotTaskCommand(message) {
            const lowerMsg = message.toLowerCase();

            // Recall commands
            if (lowerMsg.includes('recall') || lowerMsg.includes('come back') || lowerMsg.includes('return') ||
                lowerMsg.includes('stop task') || lowerMsg.includes('cancel task') || lowerMsg.includes('abort')) {
                if (copilotTask.active) {
                    recallCopilot();
                    return true;
                }
                return false;
            }

            // Gather/collect resources
            if (lowerMsg.includes('gather') || lowerMsg.includes('collect') ||
                (lowerMsg.includes('get') && (lowerMsg.includes('wood') || lowerMsg.includes('logs') || lowerMsg.includes('materials') || lowerMsg.includes('resources')))) {
                return assignCopilotTask('gather');
            }

            // Hunt/kill enemies
            if (lowerMsg.includes('hunt') || lowerMsg.includes('kill') ||
                lowerMsg.includes('fight') || lowerMsg.includes('attack enemies')) {
                return assignCopilotTask('hunt');
            }

            // Scout/explore
            if (lowerMsg.includes('scout') || lowerMsg.includes('explore') ||
                lowerMsg.includes('look around') || lowerMsg.includes('survey') ||
                lowerMsg.includes('check the area') || lowerMsg.includes('what\'s nearby')) {
                return assignCopilotTask('scout');
            }

            // Protect/guard
            if (lowerMsg.includes('protect') || lowerMsg.includes('guard') ||
                lowerMsg.includes('defend') || lowerMsg.includes('watch my back')) {
                return assignCopilotTask('protect');
            }

            // Heal
            if (lowerMsg.includes('heal me') || lowerMsg.includes('restore health') ||
                lowerMsg.includes('patch me up') || lowerMsg.includes('healing')) {
                return assignCopilotTask('heal');
            }

            // Fish
            if (lowerMsg.includes('fish') || lowerMsg.includes('catch fish') ||
                lowerMsg.includes('go fishing')) {
                return assignCopilotTask('fish');
            }

            // Mine
            if (lowerMsg.includes('mine') || lowerMsg.includes('get ore') ||
                lowerMsg.includes('dig') || lowerMsg.includes('excavate')) {
                return assignCopilotTask('mine');
            }

            // Task status
            if (lowerMsg.includes('what are you doing') || lowerMsg.includes('task status') ||
                lowerMsg.includes('current task')) {
                if (copilotTask.active) {
                    const taskConfig = COPILOT_TASK_TYPES[copilotTask.type];
                    addCopilotMessage(`I'm currently ${taskConfig.name.toLowerCase()}. Progress: ${Math.floor(copilotTask.progress * 100)}%`, 'ai');
                    return true;
                } else {
                    addCopilotMessage(`I'm not working on any task right now. Ask me to gather, hunt, scout, fish, mine, or protect you!`, 'ai');
                    return true;
                }
            }

            return false; // Not a task command
        }

        // ============================================
        // v5.10: MULTI-AGENT FLEET SYSTEM
        // Spawn up to 10 AI-driven autonomous agents
        // Each driven by RAPPID API with canned transcripts
        // ============================================
        const MAX_AGENTS = 10;
        const AGENT_NAMES = ['Alpha', 'Beta', 'Gamma', 'Delta', 'Epsilon', 'Zeta', 'Eta', 'Theta', 'Iota', 'Kappa'];

        // v5.12.1: Endpoint configuration registry - allows different AI providers per agent
        const ENDPOINT_REGISTRY = {
            default: {
                name: 'RAPPID (Default)',
                urlKey: 'rappid-agent-url',  // localStorage key for URL
                apiKeyKey: 'rappid-api-key', // localStorage key for API key
                headerStyle: 'x-functions-key',
                bodyFormat: 'rappid' // rappid | openai | anthropic | custom
            },
            openai: {
                name: 'OpenAI',
                urlKey: 'openai-agent-url',
                apiKeyKey: 'openai-api-key',
                headerStyle: 'Authorization',
                headerPrefix: 'Bearer ',
                bodyFormat: 'openai'
            },
            anthropic: {
                name: 'Anthropic',
                urlKey: 'anthropic-agent-url',
                apiKeyKey: 'anthropic-api-key',
                headerStyle: 'x-api-key',
                bodyFormat: 'anthropic'
            },
            azure: {
                name: 'Azure OpenAI',
                urlKey: 'azure-agent-url',
                apiKeyKey: 'azure-api-key',
                headerStyle: 'api-key',
                bodyFormat: 'openai'
            },
            local: {
                name: 'Local LLM',
                urlKey: 'local-agent-url',
                apiKeyKey: 'local-api-key',
                headerStyle: 'Authorization',
                headerPrefix: 'Bearer ',
                bodyFormat: 'openai' // Most local servers use OpenAI-compatible format
            },
            custom: {
                name: 'Custom Endpoint',
                urlKey: 'custom-agent-url',
                apiKeyKey: 'custom-api-key',
                headerStyle: 'Authorization',
                bodyFormat: 'custom'
            }
        };

        // ============================================
        // v5.14: ENDPOINT PROFILES SYSTEM
        // Configurable endpoint profiles for agent fleet
        // ============================================
        const ENDPOINT_PROFILES_KEY = 'leviathan-endpoint-profiles';
        const DEFAULT_PROFILE_KEY = 'leviathan-default-agent-profile';

        // Load endpoint profiles from localStorage
        function loadEndpointProfiles() {
            try {
                return JSON.parse(localStorage.getItem(ENDPOINT_PROFILES_KEY) || '[]');
            } catch (e) {
                return [];
            }
        }

        // Save endpoint profiles to localStorage
        function saveEndpointProfiles(profiles) {
            localStorage.setItem(ENDPOINT_PROFILES_KEY, JSON.stringify(profiles));
            refreshProfileSelects();
        }

        // Get profile by ID (handles both custom profiles and RAPPID endpoints)
        function getEndpointProfile(profileId) {
            if (!profileId) return null;

            // v5.14: Check if it's a RAPPID endpoint (prefixed with "rappid:")
            if (profileId.startsWith('rappid:')) {
                const rappidId = profileId.replace('rappid:', '');
                const rappidEndpoint = rappidSettings.endpoints?.[rappidId];
                if (rappidEndpoint) {
                    return {
                        id: profileId,
                        name: rappidEndpoint.name,
                        url: rappidEndpoint.url,
                        apiKey: rappidEndpoint.key,
                        headerStyle: 'x-functions-key',
                        headerPrefix: '',
                        bodyFormat: 'rappid',
                        model: null,
                        isRappid: true
                    };
                }
                return null;
            }

            // Check custom profiles
            const profiles = loadEndpointProfiles();
            return profiles.find(p => p.id === profileId);
        }

        // Get default profile ID
        function getDefaultAgentProfileId() {
            return localStorage.getItem(DEFAULT_PROFILE_KEY) || '';
        }

        // Set default profile
        function setDefaultAgentProfile(profileId) {
            localStorage.setItem(DEFAULT_PROFILE_KEY, profileId);
            showNotification(`Default agent profile ${profileId ? 'updated' : 'cleared'}`, 'success');
        }

        // Generate unique profile ID
        function generateProfileId() {
            return 'profile_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }

        // Show add profile form
        function showAddProfileForm() {
            document.getElementById('endpoint-profile-form').style.display = 'block';
            document.getElementById('profile-form-title').textContent = 'Add Endpoint Profile';
            document.getElementById('profile-edit-id').value = '';
            document.getElementById('profile-name').value = '';
            document.getElementById('profile-type').value = 'rappid';
            document.getElementById('profile-url').value = '';
            document.getElementById('profile-api-key').value = '';
            document.getElementById('profile-model').value = '';
            updateProfileFormFields();
        }

        // Edit existing profile
        function editEndpointProfile(profileId) {
            const profile = getEndpointProfile(profileId);
            if (!profile) return;

            document.getElementById('endpoint-profile-form').style.display = 'block';
            document.getElementById('profile-form-title').textContent = 'Edit Endpoint Profile';
            document.getElementById('profile-edit-id').value = profile.id;
            document.getElementById('profile-name').value = profile.name || '';
            document.getElementById('profile-type').value = profile.type || 'rappid';
            document.getElementById('profile-url').value = profile.url || '';
            document.getElementById('profile-api-key').value = profile.apiKey || '';
            document.getElementById('profile-model').value = profile.model || '';
            if (profile.headerName) {
                document.getElementById('profile-header-name').value = profile.headerName;
            }
            updateProfileFormFields();
        }

        // Hide profile form
        function hideProfileForm() {
            document.getElementById('endpoint-profile-form').style.display = 'none';
        }

        // Update form fields based on provider type
        function updateProfileFormFields() {
            const type = document.getElementById('profile-type').value;
            const modelGroup = document.getElementById('profile-model-group');
            const headerGroup = document.getElementById('profile-header-group');
            const urlInput = document.getElementById('profile-url');
            const modelInput = document.getElementById('profile-model');

            // Show model field for most providers
            modelGroup.style.display = type === 'rappid' ? 'none' : 'block';

            // Show custom header field only for custom type
            headerGroup.style.display = type === 'custom' ? 'block' : 'none';

            // Set placeholder based on type
            const placeholders = {
                rappid: { url: 'http://localhost:7071/api/businessinsightbot_function', model: '' },
                openai: { url: 'https://api.openai.com/v1/chat/completions', model: 'gpt-4o-mini' },
                anthropic: { url: 'https://api.anthropic.com/v1/messages', model: 'claude-3-5-sonnet-20241022' },
                azure: { url: 'https://YOUR-RESOURCE.openai.azure.com/openai/deployments/YOUR-DEPLOYMENT/chat/completions?api-version=2024-02-01', model: 'gpt-4o' },
                local: { url: 'http://localhost:11434/v1/chat/completions', model: 'llama3.2' },
                custom: { url: 'https://your-api.com/endpoint', model: 'model-name' }
            };
            urlInput.placeholder = placeholders[type]?.url || '';
            modelInput.placeholder = placeholders[type]?.model || '';
        }

        // Save endpoint profile
        function saveEndpointProfile() {
            const editId = document.getElementById('profile-edit-id').value;
            const name = document.getElementById('profile-name').value.trim();
            const type = document.getElementById('profile-type').value;
            const url = document.getElementById('profile-url').value.trim();
            const apiKey = document.getElementById('profile-api-key').value.trim();
            const model = document.getElementById('profile-model').value.trim();
            const headerName = document.getElementById('profile-header-name')?.value?.trim();

            if (!name) {
                showNotification('Please enter a profile name', 'warning');
                return;
            }
            if (!url) {
                showNotification('Please enter an API endpoint URL', 'warning');
                return;
            }

            const profiles = loadEndpointProfiles();

            // Get endpoint registry info for this type
            const registryEntry = ENDPOINT_REGISTRY[type] || ENDPOINT_REGISTRY.default;

            const profile = {
                id: editId || generateProfileId(),
                name,
                type,
                url,
                apiKey,
                model: model || registryEntry.defaultModel || '',
                headerStyle: type === 'custom' ? (headerName || 'Authorization') : registryEntry.headerStyle,
                headerPrefix: registryEntry.headerPrefix || '',
                bodyFormat: registryEntry.bodyFormat,
                createdAt: editId ? (getEndpointProfile(editId)?.createdAt || Date.now()) : Date.now(),
                updatedAt: Date.now()
            };

            if (editId) {
                // Update existing
                const idx = profiles.findIndex(p => p.id === editId);
                if (idx !== -1) {
                    profiles[idx] = profile;
                }
            } else {
                // Add new
                profiles.push(profile);
            }

            saveEndpointProfiles(profiles);
            hideProfileForm();
            renderEndpointProfilesList();
            showNotification(`Profile "${name}" ${editId ? 'updated' : 'created'}!`, 'success');
        }

        // Delete endpoint profile
        function deleteEndpointProfile(profileId) {
            if (!confirm('Delete this endpoint profile?')) return;

            let profiles = loadEndpointProfiles();
            profiles = profiles.filter(p => p.id !== profileId);
            saveEndpointProfiles(profiles);
            renderEndpointProfilesList();

            // Clear default if this was it
            if (getDefaultAgentProfileId() === profileId) {
                localStorage.removeItem(DEFAULT_PROFILE_KEY);
            }

            showNotification('Profile deleted', 'info');
        }

        // Render profiles list in settings
        function renderEndpointProfilesList() {
            const container = document.getElementById('endpoint-profiles-list');
            if (!container) return;

            const profiles = loadEndpointProfiles();

            if (profiles.length === 0) {
                container.innerHTML = `
                    <div style="color: #666; text-align: center; padding: 20px; font-size: 12px;">
                        No endpoint profiles yet.<br>Add a profile to assign different AI providers to agents.
                    </div>
                `;
                return;
            }

            const icons = {
                rappid: 'âš¡', openai: 'ðŸ¤–', anthropic: 'ðŸ§ ', azure: 'â˜ï¸', local: 'ðŸ’»', custom: 'ðŸ”§'
            };

            container.innerHTML = profiles.map(p => `
                <div class="ai-endpoint-card" style="display: flex; align-items: center; justify-content: space-between; padding: 12px; margin-bottom: 8px;">
                    <div style="flex: 1;">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <span style="font-size: 18px;">${icons[p.type] || 'ðŸ”Œ'}</span>
                            <div>
                                <div class="ai-endpoint-name">${p.name}</div>
                                <div class="ai-endpoint-url">${p.type.toUpperCase()}${p.model ? ' â€¢ ' + p.model : ''}</div>
                            </div>
                        </div>
                    </div>
                    <div style="display: flex; gap: 5px;">
                        <button onclick="editEndpointProfile('${p.id}')" style="padding: 5px 10px; background: rgba(6, 255, 165, 0.1); border: 1px solid #06ffa5; color: #06ffa5; border-radius: 5px; cursor: pointer; font-size: 11px;">Edit</button>
                        <button onclick="deleteEndpointProfile('${p.id}')" style="padding: 5px 10px; background: rgba(255, 68, 68, 0.1); border: 1px solid #f44; color: #f44; border-radius: 5px; cursor: pointer; font-size: 11px;">Ã—</button>
                    </div>
                </div>
            `).join('');
        }

        // Refresh all profile select dropdowns
        function refreshProfileSelects() {
            const profiles = loadEndpointProfiles();
            const defaultProfileId = getDefaultAgentProfileId();

            // Get RAPPID endpoints that are configured
            const rappidEndpoints = rappidSettings.endpoints ? Object.values(rappidSettings.endpoints) : [];

            // Build option groups
            const rappidOptions = rappidEndpoints.length > 0 ?
                `<optgroup label="RAPPID Endpoints">` +
                rappidEndpoints.map(e => `<option value="rappid:${e.id}">${e.name}${e.active ? ' (Active)' : ''}</option>`).join('') +
                `</optgroup>` : '';

            const customProfileOptions = profiles.length > 0 ?
                `<optgroup label="Custom Profiles">` +
                profiles.map(p => `<option value="${p.id}">${p.name}</option>`).join('') +
                `</optgroup>` : '';

            // Update default profile select
            const defaultSelect = document.getElementById('default-agent-profile');
            if (defaultSelect) {
                defaultSelect.innerHTML = '<option value="">Use Global RAPPID Settings</option>' +
                    rappidOptions + customProfileOptions;
                // Re-select default
                if (defaultProfileId) {
                    defaultSelect.value = defaultProfileId;
                }
            }

            // Update test profile select
            const testSelect = document.getElementById('test-profile-select');
            if (testSelect) {
                testSelect.innerHTML = '<option value="">Select a profile to test...</option>' +
                    rappidOptions + customProfileOptions;
            }

            // Update agent spawn profile select
            const spawnSelect = document.getElementById('agent-spawn-profile');
            if (spawnSelect) {
                spawnSelect.innerHTML = '<option value="">Default</option>' +
                    rappidOptions + customProfileOptions;
            }
        }

        // Test endpoint profile connectivity
        async function testEndpointProfile() {
            const profileId = document.getElementById('test-profile-select').value;
            const resultDiv = document.getElementById('profile-test-result');

            if (!profileId) {
                showNotification('Select a profile to test', 'warning');
                return;
            }

            const profile = getEndpointProfile(profileId);
            if (!profile) {
                showNotification('Profile not found', 'error');
                return;
            }

            resultDiv.style.display = 'block';
            resultDiv.innerHTML = '<span style="color: #888;">Testing connection...</span>';

            try {
                const headers = {};
                if (profile.headerStyle === 'Authorization') {
                    headers['Authorization'] = (profile.headerPrefix || 'Bearer ') + profile.apiKey;
                } else if (profile.headerStyle === 'x-api-key') {
                    headers['x-api-key'] = profile.apiKey;
                } else if (profile.headerStyle === 'api-key') {
                    headers['api-key'] = profile.apiKey;
                } else if (profile.headerStyle === 'x-functions-key') {
                    headers['x-functions-key'] = profile.apiKey;
                }
                headers['Content-Type'] = 'application/json';

                // Make a minimal test request
                const testBody = profile.bodyFormat === 'anthropic' ? {
                    model: profile.model || 'claude-3-5-sonnet-20241022',
                    max_tokens: 10,
                    messages: [{ role: 'user', content: 'Hi' }]
                } : profile.bodyFormat === 'rappid' ? {
                    conversation_history: [{ role: 'user', content: 'Hi' }],
                    session_id: 'test-' + Date.now()
                } : {
                    model: profile.model || 'gpt-4o-mini',
                    max_tokens: 10,
                    messages: [{ role: 'user', content: 'Hi' }]
                };

                const response = await fetch(profile.url, {
                    method: 'POST',
                    headers,
                    body: JSON.stringify(testBody)
                });

                if (response.ok) {
                    resultDiv.innerHTML = `<span style="color: #06ffa5;">âœ“ Connection successful! (${response.status})</span>`;
                } else {
                    const errorText = await response.text().catch(() => '');
                    resultDiv.innerHTML = `<span style="color: #f44;">âœ— Error ${response.status}: ${errorText.substring(0, 100)}</span>`;
                }
            } catch (err) {
                resultDiv.innerHTML = `<span style="color: #f44;">âœ— Connection failed: ${err.message}</span>`;
            }
        }

        // Get endpoint configuration for an agent
        function getAgentEndpoint(agent) {
            // v5.14: Check if agent has assigned profile (could be custom or RAPPID endpoint)
            if (agent.profileId) {
                // Check if it's a RAPPID endpoint (prefixed with "rappid:")
                if (agent.profileId.startsWith('rappid:')) {
                    const rappidId = agent.profileId.replace('rappid:', '');
                    const rappidEndpoint = rappidSettings.endpoints?.[rappidId];
                    if (rappidEndpoint) {
                        return {
                            url: rappidEndpoint.url,
                            key: rappidEndpoint.key,
                            headerStyle: 'x-functions-key',
                            headerPrefix: '',
                            bodyFormat: 'rappid',
                            model: null,
                            name: rappidEndpoint.name,
                            profileId: agent.profileId
                        };
                    }
                }

                // Check custom profile
                const profile = getEndpointProfile(agent.profileId);
                if (profile) {
                    return {
                        url: profile.url,
                        key: profile.apiKey,
                        headerStyle: profile.headerStyle,
                        headerPrefix: profile.headerPrefix || '',
                        bodyFormat: profile.bodyFormat,
                        model: profile.model,
                        name: profile.name,
                        profileId: profile.id
                    };
                }
            }

            // Check if agent has custom endpoint from transcript
            if (agent.endpointConfig) {
                const config = agent.endpointConfig;
                return {
                    url: config.url || localStorage.getItem(config.urlKey) || '',
                    key: config.apiKey || localStorage.getItem(config.apiKeyKey) || '',
                    headerStyle: config.headerStyle || 'x-functions-key',
                    headerPrefix: config.headerPrefix || '',
                    bodyFormat: config.bodyFormat || 'rappid',
                    model: config.model,
                    name: config.name || 'Custom'
                };
            }

            // v5.14: Check for default agent profile
            const defaultProfileId = getDefaultAgentProfileId();
            if (defaultProfileId) {
                const profile = getEndpointProfile(defaultProfileId);
                if (profile) {
                    return {
                        url: profile.url,
                        key: profile.apiKey,
                        headerStyle: profile.headerStyle,
                        headerPrefix: profile.headerPrefix || '',
                        bodyFormat: profile.bodyFormat,
                        model: profile.model,
                        name: profile.name,
                        profileId: profile.id
                    };
                }
            }

            // Check if agent type has default endpoint
            const typeConfig = AGENT_TYPES[agent.type];
            if (typeConfig?.endpoint) {
                const registryEntry = ENDPOINT_REGISTRY[typeConfig.endpoint] || ENDPOINT_REGISTRY.default;
                return {
                    url: localStorage.getItem(registryEntry.urlKey) || '',
                    key: localStorage.getItem(registryEntry.apiKeyKey) || '',
                    headerStyle: registryEntry.headerStyle,
                    headerPrefix: registryEntry.headerPrefix || '',
                    bodyFormat: registryEntry.bodyFormat,
                    name: registryEntry.name
                };
            }

            // Fall back to global RAPPID endpoint
            const globalEndpoint = getActiveEndpoint();
            // v5.15: If no active endpoint, try to get any available RAPPID endpoint
            const fallbackEndpoint = globalEndpoint ||
                (rappidSettings.endpoints ? Object.values(rappidSettings.endpoints)[0] : null);
            return {
                url: fallbackEndpoint?.url || '',
                key: fallbackEndpoint?.key || '',
                headerStyle: 'x-functions-key',
                headerPrefix: '',
                bodyFormat: 'rappid',
                name: fallbackEndpoint?.name || 'RAPPID'
            };
        }

        // Format request body based on endpoint type
        function formatAgentRequestBody(endpoint, contextMessage, conversationHistory, agent) {
            switch (endpoint.bodyFormat) {
                case 'openai':
                    return JSON.stringify({
                        model: endpoint.model || agent.endpointConfig?.model || 'gpt-4o-mini',
                        messages: conversationHistory,
                        max_tokens: 500,
                        temperature: 0.7
                    });

                case 'anthropic':
                    // Anthropic uses 'human' and 'assistant' roles
                    const anthropicMessages = conversationHistory.slice(1).map(m => ({
                        role: m.role === 'user' ? 'human' : m.role,
                        content: m.content
                    }));
                    return JSON.stringify({
                        model: endpoint.model || agent.endpointConfig?.model || 'claude-3-haiku-20240307',
                        messages: anthropicMessages,
                        system: conversationHistory[0]?.content || '',
                        max_tokens: 500
                    });

                case 'custom':
                    // Allow custom body format from transcript config
                    if (agent.endpointConfig?.customBody) {
                        const body = { ...agent.endpointConfig.customBody };
                        body.messages = conversationHistory;
                        body.input = contextMessage.content;
                        return JSON.stringify(body);
                    }
                    // Fall through to default

                case 'rappid':
                default:
                    return JSON.stringify({
                        user_input: contextMessage.content,
                        conversation_history: conversationHistory,
                        user_guid: `agent-${agent.id}`
                    });
            }
        }

        // Parse response based on endpoint type
        function parseAgentResponse(endpoint, data) {
            switch (endpoint.bodyFormat) {
                case 'openai':
                    return data.choices?.[0]?.message?.content || data.response || '';

                case 'anthropic':
                    return data.content?.[0]?.text || data.completion || '';

                case 'rappid':
                default:
                    return data.assistant_response || data.response || '';
            }
        }

        // Agent type definitions with canned transcript templates
        const AGENT_TYPES = {
            gatherer: {
                icon: 'ðŸªµ',
                name: 'Gatherer',
                color: 0x44ff88,
                colorClass: 'agent-color-gatherer',
                baseTranscript: [
                    { role: 'system', content: `You are an autonomous resource-gathering AI agent in the game LEVIATHAN. Your sole purpose is to efficiently gather resources (logs, fiber, stone, herbs) for the player. You operate independently and report back with what you find. Keep responses brief (1-2 sentences). Always analyze the situation and decide: continue gathering, return with resources, or adjust strategy. Output JSON with: {"action": "gather|return|move", "target": "resource type", "message": "brief status", "results": [{"item": "name", "amount": num}]}` },
                ],
                decisionInterval: 4000, // ms between API calls
                taskType: 'gather'
            },
            hunter: {
                icon: 'âš”ï¸',
                name: 'Hunter',
                color: 0xff4444,
                colorClass: 'agent-color-hunter',
                baseTranscript: [
                    { role: 'system', content: `You are an autonomous combat AI agent in LEVIATHAN. Your mission is to hunt and defeat enemies to earn XP and loot for the player. You fight strategically and retreat if overwhelmed. Keep responses brief. Analyze: enemy count, difficulty, your health. Output JSON: {"action": "attack|retreat|patrol", "target": "enemy type or direction", "message": "brief status", "results": [{"xp": num, "gold": num, "loot": "item name"}]}` },
                ],
                decisionInterval: 3000,
                taskType: 'hunt'
            },
            scout: {
                icon: 'ðŸ”',
                name: 'Scout',
                color: 0x44aaff,
                colorClass: 'agent-color-scout',
                baseTranscript: [
                    { role: 'system', content: `You are an autonomous reconnaissance AI agent in LEVIATHAN. Your role is to explore, map terrain, and report discoveries (resources, enemies, points of interest). Stay mobile and avoid combat. Output JSON: {"action": "explore|report|mark", "direction": "N/S/E/W or area name", "message": "brief discovery", "discoveries": [{"type": "resource|enemy|poi", "description": "what you found"}]}` },
                ],
                decisionInterval: 5000,
                taskType: 'scout'
            },
            protector: {
                icon: 'ðŸ›¡ï¸',
                name: 'Protector',
                color: 0xffcc00,
                colorClass: 'agent-color-protector',
                baseTranscript: [
                    { role: 'system', content: `You are an autonomous defense AI agent in LEVIATHAN. Your duty is to guard the player, intercept threats, and maintain a protective perimeter. You stay close to the player and engage any enemy that approaches. Output JSON: {"action": "guard|intercept|alert", "threat_level": "low|medium|high", "message": "security status", "enemies_engaged": num}` },
                ],
                decisionInterval: 2000,
                taskType: 'protect'
            },
            healer: {
                icon: 'ðŸ’š',
                name: 'Healer',
                color: 0xff88ff,
                colorClass: 'agent-color-healer',
                baseTranscript: [
                    { role: 'system', content: `You are an autonomous healing AI agent in LEVIATHAN. Monitor the player's health and provide healing support. Prioritize keeping the player alive. You channel healing energy periodically. Output JSON: {"action": "heal|monitor|recover", "target": "player or self", "heal_amount": num, "message": "healing status", "player_health_pct": num}` },
                ],
                decisionInterval: 3500,
                taskType: 'heal'
            },
            fisher: {
                icon: 'ðŸŽ£',
                name: 'Fisher',
                color: 0x44ffff,
                colorClass: 'agent-color-fisher',
                baseTranscript: [
                    { role: 'system', content: `You are an autonomous fishing AI agent in LEVIATHAN. Find water sources and catch fish for food. You're patient and methodical. Report catches and move to better fishing spots when needed. Output JSON: {"action": "fish|move|return", "location": "current spot description", "message": "fishing status", "catch": [{"item": "fish type", "amount": num}]}` },
                ],
                decisionInterval: 6000,
                taskType: 'fish'
            },
            miner: {
                icon: 'â›ï¸',
                name: 'Miner',
                color: 0xffaa44,
                colorClass: 'agent-color-miner',
                baseTranscript: [
                    { role: 'system', content: `You are an autonomous mining AI agent in LEVIATHAN. Locate ore veins, extract minerals, and report finds. You're thorough and efficient. Move to new deposits when current one is depleted. Output JSON: {"action": "mine|prospect|return", "deposit": "ore type", "message": "mining status", "ore": [{"item": "ore type", "amount": num}]}` },
                ],
                decisionInterval: 5000,
                taskType: 'mine'
            },
            explorer: {
                icon: 'ðŸ§­',
                name: 'Explorer',
                color: 0xaa88ff,
                colorClass: 'agent-color-explorer',
                baseTranscript: [
                    { role: 'system', content: `You are an autonomous exploration AI agent in LEVIATHAN. Push into uncharted territory, discover new areas, and expand the known map. You're brave and curious. Report unusual phenomena and mark important locations. Output JSON: {"action": "venture|document|beacon", "area": "location name", "message": "exploration log", "findings": [{"type": "biome|landmark|secret", "description": "discovery"}]}` },
                ],
                decisionInterval: 7000,
                taskType: 'scout'
            },
            // v5.18: Terraformer - flattens terrain for construction
            terraformer: {
                icon: 'ðŸšœ',
                name: 'Terraformer',
                color: 0x8b4513,
                colorClass: 'agent-color-terraformer',
                baseTranscript: [
                    { role: 'system', content: `You are an autonomous terraforming AI agent in LEVIATHAN. Your mission is to analyze terrain, identify uneven areas, and flatten them for construction. You prepare building sites by leveling the ground. Flat surfaces allow for efficient battery charger placement. Output JSON: {"action": "scan|flatten|prepare", "area": "coordinates or description", "message": "terraforming status", "flatness": 0-100}` },
                ],
                decisionInterval: 5000,
                taskType: 'terraform'
            },
            // v5.18: Builder - constructs battery chargers and structures
            builder: {
                icon: 'ðŸ”§',
                name: 'Builder',
                color: 0x00bfff,
                colorClass: 'agent-color-builder',
                baseTranscript: [
                    { role: 'system', content: `You are an autonomous construction AI agent in LEVIATHAN. Your mission is to build battery chargers and infrastructure for the robot fleet. You require flat terrain for optimal charger efficiency - place chargers on terraformed land when possible. Battery chargers allow robots to recharge their energy. Output JSON: {"action": "build|repair|upgrade", "structure": "battery_charger|beacon|platform", "message": "construction status", "efficiency": 0-100}` },
                ],
                decisionInterval: 6000,
                taskType: 'build'
            }
        };

        // Fleet state
        let agentFleet = [];
        let agentFleetPanelOpen = false;
        let agentUpdateTimers = {};

        // Toggle fleet panel
        function toggleAgentFleetPanel() {
            agentFleetPanelOpen = !agentFleetPanelOpen;
            const panel = document.getElementById('agent-fleet-panel');
            panel.classList.toggle('active', agentFleetPanelOpen);

            // v5.14: Refresh profile dropdown when opening
            if (agentFleetPanelOpen) {
                refreshProfileSelects();
            }
        }

        // v5.14: Wrapper to spawn agent with selected profile
        function spawnAgentWithProfile(agentType) {
            const profileSelect = document.getElementById('agent-spawn-profile');
            const profileId = profileSelect?.value || '';
            spawnAgent(agentType, profileId ? { profileId } : null);
        }

        // v5.12.1: Spawn a new agent with optional custom transcript and endpoint config
        // customConfig: { transcript: [...], endpoint: {...}, name: 'Custom Name', profileId: 'profile_xxx' }
        function spawnAgent(agentType, customConfig = null) {
            if (agentFleet.length >= MAX_AGENTS) {
                addCopilotMessage(`Fleet capacity reached (${MAX_AGENTS} agents). Recall an agent first.`, 'ai');
                return null;
            }

            const typeConfig = AGENT_TYPES[agentType];
            if (!typeConfig) return null;

            // Find next available name
            const usedNames = agentFleet.map(a => a.name);
            const availableName = customConfig?.name ||
                                  AGENT_NAMES.find(n => !usedNames.includes(n)) ||
                                  `Agent-${agentFleet.length + 1}`;

            // Merge custom transcript with base if provided
            let transcript = [...typeConfig.baseTranscript];
            if (customConfig?.transcript) {
                transcript = customConfig.transcript;
            }

            // Extract endpoint config from transcript if present
            let endpointConfig = customConfig?.endpoint || null;
            if (!endpointConfig && transcript.length > 0) {
                // Check if first message contains endpoint config
                const systemMsg = transcript[0];
                if (systemMsg.endpoint) {
                    endpointConfig = systemMsg.endpoint;
                }
            }

            const agent = {
                id: Date.now().toString(36) + Math.random().toString(36).substr(2, 9),
                name: availableName,
                type: agentType,
                typeConfig: typeConfig,
                status: 'initializing',
                statusMessage: 'Preparing to deploy...',
                progress: 0,
                conversationHistory: transcript,
                results: [],
                lastDecisionTime: 0,
                mesh: null,
                position: worldState.player ? worldState.player.position.clone() : new THREE.Vector3(0, 0, 0),
                targetPosition: null,
                totalEarnings: { xp: 0, gold: 0, items: [] },
                spawnTime: performance.now(),
                // v5.12.1: Endpoint configuration
                endpointConfig: endpointConfig,
                activeEndpoint: null,
                // v5.14: Assigned endpoint profile
                profileId: customConfig?.profileId || null,
                // v5.15.2: Try Again replay system - store full interaction history
                interactionHistory: [],  // Full request/response pairs with context
                replayState: null,       // Current replay comparison if active
                // v5.17: Agent experience and efficiency system
                agentXP: 0,
                agentLevel: 1,
                efficiency: 1.0,         // Multiplier for action success rate
                combo: 0,                // Consecutive successful actions
                maxCombo: 0,             // Best combo achieved
                lastActionSuccess: false,
                actionsPerformed: 0,
                successfulActions: 0,
                lastHealthRegen: performance.now()
            };

            // Create 3D mesh for the agent
            createAgentMesh(agent);

            // Add to fleet
            agentFleet.push(agent);

            // Update UI
            updateFleetUI();
            updateFleetButton();

            // Start autonomous loop for this agent
            startAgentLoop(agent);

            // Announce
            addCopilotMessage(`${typeConfig.icon} ${availableName} (${typeConfig.name}) deployed! They'll work autonomously and report back.`, 'ai');

            return agent;
        }

        // v5.16: Create distinct 3D mesh for each agent type (mini-robots)
        function createAgentMesh(agent) {
            if (!worldState.scene) return;

            const color = agent.typeConfig.color;
            const agentGroup = new THREE.Group();

            // Create mini-robot body based on agent type
            const bodyHeight = 0.8;
            const bodyWidth = 0.5;

            // Body (cylinder with rounded appearance)
            const bodyGeom = new THREE.CylinderGeometry(bodyWidth * 0.4, bodyWidth * 0.5, bodyHeight, 8);
            const bodyMat = new THREE.MeshStandardMaterial({
                color: 0x334455,
                metalness: 0.7,
                roughness: 0.3
            });
            const body = new THREE.Mesh(bodyGeom, bodyMat);
            body.position.y = bodyHeight / 2;
            body.castShadow = true;
            agentGroup.add(body);

            // Head (sphere with type-specific color visor)
            const headGeom = new THREE.SphereGeometry(0.25, 12, 12);
            const headMat = new THREE.MeshStandardMaterial({
                color: 0x445566,
                metalness: 0.6,
                roughness: 0.4
            });
            const head = new THREE.Mesh(headGeom, headMat);
            head.position.y = bodyHeight + 0.2;
            agentGroup.add(head);

            // Visor/Eye (type-colored, glowing)
            const visorGeom = new THREE.BoxGeometry(0.3, 0.08, 0.15);
            const visorMat = new THREE.MeshStandardMaterial({
                color: color,
                emissive: color,
                emissiveIntensity: 0.8,
                metalness: 0.9,
                roughness: 0.1
            });
            const visor = new THREE.Mesh(visorGeom, visorMat);
            visor.position.set(0, bodyHeight + 0.2, 0.2);
            agentGroup.add(visor);
            agent.visor = visor;

            // Type-specific tool/accessory
            const toolGroup = new THREE.Group();
            switch (agent.type) {
                case 'gatherer':
                    // Pickaxe
                    const pickHandle = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.03, 0.03, 0.4, 6),
                        new THREE.MeshStandardMaterial({ color: 0x8B4513 })
                    );
                    pickHandle.rotation.z = Math.PI / 4;
                    const pickHead = new THREE.Mesh(
                        new THREE.BoxGeometry(0.2, 0.08, 0.05),
                        new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.8 })
                    );
                    pickHead.position.y = 0.2;
                    pickHandle.add(pickHead);
                    toolGroup.add(pickHandle);
                    break;
                case 'hunter':
                    // Sword
                    const swordBlade = new THREE.Mesh(
                        new THREE.BoxGeometry(0.05, 0.5, 0.02),
                        new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.9 })
                    );
                    const swordHilt = new THREE.Mesh(
                        new THREE.BoxGeometry(0.15, 0.08, 0.03),
                        new THREE.MeshStandardMaterial({ color: 0x8B4513 })
                    );
                    swordHilt.position.y = -0.25;
                    swordBlade.add(swordHilt);
                    toolGroup.add(swordBlade);
                    break;
                case 'miner':
                    // Mining drill
                    const drill = new THREE.Mesh(
                        new THREE.ConeGeometry(0.1, 0.4, 8),
                        new THREE.MeshStandardMaterial({ color: 0x666666, metalness: 0.8 })
                    );
                    drill.rotation.z = -Math.PI / 2;
                    toolGroup.add(drill);
                    break;
                case 'healer':
                    // Medical cross
                    const crossH = new THREE.Mesh(
                        new THREE.BoxGeometry(0.25, 0.08, 0.04),
                        new THREE.MeshStandardMaterial({ color: 0xff4444, emissive: 0xff0000, emissiveIntensity: 0.3 })
                    );
                    const crossV = new THREE.Mesh(
                        new THREE.BoxGeometry(0.08, 0.25, 0.04),
                        new THREE.MeshStandardMaterial({ color: 0xff4444, emissive: 0xff0000, emissiveIntensity: 0.3 })
                    );
                    toolGroup.add(crossH, crossV);
                    break;
                case 'scout':
                case 'explorer':
                    // Antenna
                    const antenna = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.02, 0.02, 0.3, 6),
                        new THREE.MeshStandardMaterial({ color: 0x888888 })
                    );
                    const antennaTip = new THREE.Mesh(
                        new THREE.SphereGeometry(0.05, 8, 8),
                        new THREE.MeshStandardMaterial({ color: color, emissive: color, emissiveIntensity: 0.5 })
                    );
                    antennaTip.position.y = 0.15;
                    antenna.add(antennaTip);
                    antenna.position.y = bodyHeight + 0.45;
                    agentGroup.add(antenna);
                    agent.antenna = antennaTip;
                    break;
                case 'protector':
                    // Shield
                    const shield = new THREE.Mesh(
                        new THREE.BoxGeometry(0.05, 0.35, 0.25),
                        new THREE.MeshStandardMaterial({ color: 0x4488ff, metalness: 0.7 })
                    );
                    toolGroup.add(shield);
                    break;
                case 'fisher':
                    // Fishing rod
                    const rod = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.02, 0.015, 0.6, 6),
                        new THREE.MeshStandardMaterial({ color: 0x8B4513 })
                    );
                    rod.rotation.z = Math.PI / 6;
                    toolGroup.add(rod);
                    break;
            }
            toolGroup.position.set(0.35, bodyHeight * 0.6, 0);
            agentGroup.add(toolGroup);
            agent.tool = toolGroup;

            // Legs (simple cylinders)
            [-0.12, 0.12].forEach(xOff => {
                const leg = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.06, 0.08, 0.3, 6),
                    new THREE.MeshStandardMaterial({ color: 0x333344, metalness: 0.5 })
                );
                leg.position.set(xOff, 0.15, 0);
                agentGroup.add(leg);
            });

            // Alert indicator (hidden by default)
            const alertGeom = new THREE.SphereGeometry(0.15, 8, 8);
            const alertMat = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                transparent: true,
                opacity: 0
            });
            const alertIndicator = new THREE.Mesh(alertGeom, alertMat);
            alertIndicator.position.y = bodyHeight + 0.6;
            agentGroup.add(alertIndicator);
            agent.alertIndicator = alertIndicator;

            // Glow effect (type color)
            const glowGeom = new THREE.SphereGeometry(0.7, 8, 8);
            const glowMat = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.1
            });
            const glow = new THREE.Mesh(glowGeom, glowMat);
            glow.position.y = bodyHeight / 2;
            agentGroup.add(glow);
            agent.glow = glow;

            // Scale down the whole agent
            agentGroup.scale.setScalar(0.7);

            // Position near player
            const offset = new THREE.Vector3(
                (Math.random() - 0.5) * 10,
                0,
                (Math.random() - 0.5) * 10
            );
            if (worldState.player) {
                agentGroup.position.copy(worldState.player.position).add(offset);
                agentGroup.position.y = 0; // Ground level
            }

            agent.mesh = agentGroup;
            agent.position = agentGroup.position.clone();

            // v5.16: Initialize autonomous task state
            agent.taskState = {
                currentTask: null,       // Current task type
                targetObject: null,      // Target resource/enemy
                targetPosition: null,    // Movement target
                state: 'idle',          // idle, moving, working, combat, stuck, alert
                stuckCounter: 0,
                lastPosition: null,
                lastTaskTime: 0,
                alert: null,            // Alert message if needs help
                actionCooldown: 0,
                hp: 50,                 // Agent HP
                maxHp: 50,
                taskLog: []             // Recent task actions for troubleshooting
            };

            worldState.scene.add(agentGroup);
        }

        // Start autonomous decision loop for an agent
        function startAgentLoop(agent) {
            const loop = async () => {
                if (!agent || !agentFleet.includes(agent)) return;

                const now = performance.now();
                if (now - agent.lastDecisionTime >= agent.typeConfig.decisionInterval) {
                    agent.lastDecisionTime = now;
                    await makeAgentDecision(agent);
                }

                // Continue loop
                agentUpdateTimers[agent.id] = setTimeout(loop, 500);
            };

            // Initial delay before first decision
            setTimeout(() => {
                agent.status = 'working';
                agent.statusMessage = 'Starting task...';
                updateAgentCardUI(agent);
                loop();
            }, 1500);
        }

        // v5.12.1: Make an autonomous decision for an agent via configurable API endpoint
        async function makeAgentDecision(agent) {
            // Get agent-specific endpoint (may differ from global)
            const endpoint = getAgentEndpoint(agent);

            // Build real-time context
            const gameContext = buildGameContextForAgent(agent);

            // Inject context into a user message
            const contextMessage = {
                role: 'user',
                content: `Current situation: ${JSON.stringify(gameContext)}. What's your next action?`
            };

            // Build conversation for API
            const conversationForApi = [...agent.conversationHistory, contextMessage];

            // If no endpoint configured, use simulated local decisions
            if (!endpoint || !endpoint.url || !endpoint.key) {
                // v5.15: Log why we're falling back to simulation
                if (!endpoint) {
                    console.log(`Agent ${agent.name}: No endpoint configured, using simulation`);
                } else if (!endpoint.url) {
                    console.log(`Agent ${agent.name}: Missing endpoint URL, using simulation`);
                } else if (!endpoint.key) {
                    console.log(`Agent ${agent.name}: Missing API key for ${endpoint.name}, using simulation. Check RAPPID settings.`);
                    agent.statusMessage = 'API key missing - using simulation';
                }
                simulateAgentDecision(agent, gameContext);
                return;
            }

            try {
                agent.status = 'thinking';
                agent.activeEndpoint = endpoint.name; // Track which endpoint is being used
                updateAgentCardUI(agent);

                // Build headers based on endpoint configuration
                const headers = {
                    'Content-Type': 'application/json'
                };

                // Add auth header based on endpoint style
                if (endpoint.headerPrefix) {
                    headers[endpoint.headerStyle] = endpoint.headerPrefix + endpoint.key;
                } else {
                    headers[endpoint.headerStyle] = endpoint.key;
                }

                // Format body based on endpoint type
                const requestBody = formatAgentRequestBody(endpoint, contextMessage, conversationForApi, agent);

                const response = await fetch(endpoint.url, {
                    method: 'POST',
                    headers: headers,
                    body: requestBody
                });

                if (response.ok) {
                    const data = await response.json();

                    // Parse response based on endpoint type
                    const textResponse = parseAgentResponse(endpoint, data);

                    // v5.15.2: Store full interaction for Try Again replay
                    const interactionRecord = {
                        id: Date.now().toString(36) + Math.random().toString(36).substr(2, 5),
                        timestamp: Date.now(),
                        contextMessage: { ...contextMessage },
                        gameContext: { ...gameContext },
                        endpoint: { name: endpoint.name, url: endpoint.url },
                        request: JSON.parse(requestBody),
                        response: textResponse,
                        rawResponse: data,
                        conversationIndexBefore: agent.conversationHistory.length,
                        executed: false  // Will be set true after execution
                    };
                    agent.interactionHistory.push(interactionRecord);
                    // Keep last 20 interactions
                    if (agent.interactionHistory.length > 20) {
                        agent.interactionHistory.shift();
                    }

                    // Add to conversation history (keep last 20 messages to avoid token overflow)
                    agent.conversationHistory.push(contextMessage);
                    agent.conversationHistory.push({ role: 'assistant', content: textResponse });
                    if (agent.conversationHistory.length > 22) {
                        // Keep system message + last 20
                        agent.conversationHistory = [
                            agent.conversationHistory[0],
                            ...agent.conversationHistory.slice(-20)
                        ];
                    }

                    // Parse and execute the decision
                    parseAndExecuteAgentDecision(agent, textResponse);

                    // v5.15.2: Mark interaction as executed
                    interactionRecord.executed = true;
                    interactionRecord.conversationIndexAfter = agent.conversationHistory.length;
                } else {
                    // v5.15: Better error logging
                    const errorText = await response.text().catch(() => '');
                    console.warn(`Agent ${agent.name} API error (${endpoint.name}): HTTP ${response.status}`, errorText.substring(0, 200));
                    if (response.status === 401 || response.status === 403) {
                        agent.statusMessage = `Auth failed (${response.status}) - check API key`;
                    } else {
                        agent.statusMessage = `API error ${response.status} - using fallback`;
                    }
                    simulateAgentDecision(agent, gameContext);
                }
            } catch (error) {
                console.error(`Agent ${agent.name} decision error (${endpoint.name}):`, error);
                agent.statusMessage = 'Network error - using fallback';
                simulateAgentDecision(agent, gameContext);
            }

            agent.status = 'working';
            updateAgentCardUI(agent);
        }

        // Build game context for agent decision
        function buildGameContextForAgent(agent) {
            const elapsed = (performance.now() - agent.spawnTime) / 1000;

            return {
                agent_name: agent.name,
                agent_type: agent.type,
                mission_time_seconds: Math.floor(elapsed),
                player_hp: gameData.player?.hp || 100,
                player_max_hp: gameData.player?.maxHp || 100,
                player_position: worldState.player ? {
                    x: Math.floor(worldState.player.position.x),
                    z: Math.floor(worldState.player.position.z)
                } : { x: 0, z: 0 },
                current_biome: worldState?.currentCiv?.biomeName || 'Unknown',
                nearby_enemies: countNearbyEnemies(agent),
                items_gathered: agent.totalEarnings.items.length,
                xp_earned: agent.totalEarnings.xp,
                gold_earned: agent.totalEarnings.gold
            };
        }

        // Count enemies near an agent
        function countNearbyEnemies(agent) {
            if (!worldState.mobs || !agent.position) return 0;
            return worldState.mobs.filter(mob => {
                if (!mob.mesh) return false;
                return mob.mesh.position.distanceTo(agent.position) < 15;
            }).length;
        }

        // Parse API response and execute agent action
        function parseAndExecuteAgentDecision(agent, response) {
            try {
                // Try to extract JSON from response
                const jsonMatch = response.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                    const decision = JSON.parse(jsonMatch[0]);
                    executeAgentAction(agent, decision);
                } else {
                    // No JSON, use response as status message
                    agent.statusMessage = response.substring(0, 100);
                }
            } catch (e) {
                // Parse failed, treat as status update
                agent.statusMessage = response.substring(0, 100);
            }
            updateAgentCardUI(agent);
        }

        // Execute an agent action based on decision
        function executeAgentAction(agent, decision) {
            agent.statusMessage = decision.message || 'Working...';

            // Process results
            if (decision.results) {
                decision.results.forEach(result => {
                    if (result.item && result.amount) {
                        addToInventory(result.item, result.amount);
                        agent.totalEarnings.items.push({ item: result.item, amount: result.amount });
                        agent.results.push({ item: result.item, amount: result.amount });
                    }
                    if (result.xp) {
                        gainSkillXP('combat', result.xp);
                        agent.totalEarnings.xp += result.xp;
                    }
                    if (result.gold) {
                        gameData.gold = (gameData.gold || 0) + result.gold;
                        agent.totalEarnings.gold += result.gold;
                    }
                    if (result.loot) {
                        addToInventory(result.loot, 1);
                        agent.totalEarnings.items.push({ item: result.loot, amount: 1 });
                    }
                });
            }

            // Process discoveries (for scouts/explorers)
            if (decision.discoveries) {
                decision.discoveries.forEach(d => {
                    agent.results.push({ discovery: d.description });
                });
            }

            // Process healing
            if (decision.heal_amount) {
                gameData.player.hp = Math.min(gameData.player.maxHp, gameData.player.hp + decision.heal_amount);
                updateHealthUI();
                agent.results.push({ heal: decision.heal_amount });
            }

            // Process catch (fishing)
            if (decision.catch) {
                decision.catch.forEach(c => {
                    if (c.item && c.amount) {
                        addToInventory(c.item, c.amount);
                        agent.totalEarnings.items.push({ item: c.item, amount: c.amount });
                        agent.results.push({ item: c.item, amount: c.amount });
                    }
                });
            }

            // Process ore (mining)
            if (decision.ore) {
                decision.ore.forEach(o => {
                    if (o.item && o.amount) {
                        addToInventory(o.item, o.amount);
                        agent.totalEarnings.items.push({ item: o.item, amount: o.amount });
                        agent.results.push({ item: o.item, amount: o.amount });
                    }
                });
            }

            // Update progress based on time
            const elapsed = performance.now() - agent.spawnTime;
            agent.progress = Math.min(100, (elapsed / 60000) * 100); // 100% at 1 minute

            saveGameData();
        }

        // v5.17: Simulate agent decision with efficiency system (fallback when no API)
        function simulateAgentDecision(agent, context) {
            const taskType = agent.typeConfig.taskType;

            // v5.17: Use efficiency-modified success rates
            const rand = Math.random();
            let result = {};
            let success = false;

            switch (taskType) {
                case 'gather':
                    // v5.17: Base rate 0.4, modified by efficiency
                    const gatherRate = getAgentSuccessRate(agent, 0.4);
                    if (rand < gatherRate) {
                        const items = ['Logs', 'Fiber', 'Stone', 'Herbs'];
                        // v5.17: Amount scales with agent level
                        const bonusAmount = Math.floor(agent.agentLevel / 3);
                        result = { item: items[Math.floor(Math.random() * items.length)], amount: Math.floor(Math.random() * 2) + 1 + bonusAmount };
                        addToInventory(result.item, result.amount);
                        agent.totalEarnings.items.push(result);
                        agent.results.push(result);
                        success = true;
                        if (agent.mesh) spawnAgentParticleEffect(agent, 'success');
                    }
                    agent.statusMessage = success ? `Found ${result.amount} ${result.item}!` : 'Searching for resources...';
                    trackAgentAction(agent, success, 5);
                    break;

                case 'hunt':
                    // v5.17: Base rate 0.3, modified by efficiency
                    const huntRate = getAgentSuccessRate(agent, 0.3);
                    if (rand < huntRate) {
                        // v5.17: XP and gold scale with agent level
                        result.xp = Math.floor(Math.random() * 20) + 10 + agent.agentLevel * 2;
                        result.gold = Math.floor(Math.random() * 10) + 3 + agent.agentLevel;
                        gainSkillXP('combat', result.xp);
                        gameData.gold = (gameData.gold || 0) + result.gold;
                        agent.totalEarnings.xp += result.xp;
                        agent.totalEarnings.gold += result.gold;
                        agent.results.push(result);
                        success = true;
                        if (agent.mesh) spawnAgentParticleEffect(agent, 'success');
                    }
                    agent.statusMessage = success ? `Defeated enemy! +${result.xp} XP` : 'Hunting enemies...';
                    trackAgentAction(agent, success, 8);
                    break;

                case 'scout':
                    // v5.17: Base rate 0.25, modified by efficiency
                    const scoutRate = getAgentSuccessRate(agent, 0.25);
                    if (rand < scoutRate) {
                        const discoveries = ['Found a resource deposit', 'Spotted enemy camp', 'Discovered safe path', 'Located point of interest'];
                        const disc = discoveries[Math.floor(Math.random() * discoveries.length)];
                        agent.results.push({ discovery: disc });
                        agent.statusMessage = disc;
                        success = true;
                        if (agent.mesh) spawnAgentParticleEffect(agent, 'success');
                    } else {
                        agent.statusMessage = 'Surveying the area...';
                    }
                    trackAgentAction(agent, success, 4);
                    break;

                case 'protect':
                    const nearbyEnemies = countNearbyEnemies(agent);
                    // v5.17: Base rate 0.5, modified by efficiency
                    const protectRate = getAgentSuccessRate(agent, 0.5);
                    if (nearbyEnemies > 0 && rand < protectRate) {
                        agent.statusMessage = `Engaging ${nearbyEnemies} threat(s)!`;
                        // v5.17: Damage scales with agent level
                        const damage = 8 + agent.agentLevel * 2;
                        if (worldState.mobs) {
                            const nearMob = worldState.mobs.find(m => m.mesh && m.mesh.position.distanceTo(agent.position) < 15);
                            if (nearMob) {
                                nearMob.hp -= damage;
                                if (agent.mesh) {
                                    spawnFloater(agent.mesh.position, `-${damage}`, agent.typeConfig.color.toString(16));
                                    spawnAgentParticleEffect(agent, 'success');
                                }
                                success = true;
                            }
                        }
                    } else {
                        agent.statusMessage = nearbyEnemies > 0 ? 'Alert! Enemies nearby.' : 'Area secure.';
                    }
                    trackAgentAction(agent, success, 6);
                    break;

                case 'heal':
                    // v5.17: Base rate 0.5, modified by efficiency
                    const healRate = getAgentSuccessRate(agent, 0.5);
                    if (gameData.player.hp < gameData.player.maxHp && rand < healRate) {
                        // v5.17: Heal amount scales with agent level
                        const healAmt = Math.floor(Math.random() * 8) + 5 + agent.agentLevel * 2;
                        gameData.player.hp = Math.min(gameData.player.maxHp, gameData.player.hp + healAmt);
                        updateHealthUI();
                        agent.results.push({ heal: healAmt });
                        agent.statusMessage = `Healed player for ${healAmt} HP!`;
                        success = true;
                        if (agent.mesh) spawnAgentParticleEffect(agent, 'heal');
                    } else {
                        agent.statusMessage = gameData.player.hp < gameData.player.maxHp ? 'Channeling healing energy...' : 'Player at full health.';
                    }
                    trackAgentAction(agent, success, 5);
                    break;

                case 'fish':
                    // v5.17: Base rate 0.3, modified by efficiency
                    const fishRate = getAgentSuccessRate(agent, 0.3);
                    if (rand < fishRate) {
                        // v5.17: Chance for rare fish at higher levels
                        const fishTypes = ['Raw Fish', 'Raw Fish', 'Raw Fish'];
                        if (agent.agentLevel >= 3) fishTypes.push('Large Fish');
                        if (agent.agentLevel >= 5) fishTypes.push('Golden Fish');
                        result = { item: fishTypes[Math.floor(Math.random() * fishTypes.length)], amount: 1 };
                        addToInventory(result.item, result.amount);
                        agent.totalEarnings.items.push(result);
                        agent.results.push(result);
                        success = true;
                        agent.statusMessage = result.item === 'Golden Fish' ? 'ðŸŒŸ Caught a Golden Fish!' : 'Caught a fish!';
                        if (agent.mesh) spawnAgentParticleEffect(agent, 'success');
                    } else {
                        agent.statusMessage = rand < 0.5 ? 'Waiting for a bite...' : 'Casting line...';
                    }
                    trackAgentAction(agent, success, 4);
                    break;

                case 'mine':
                    // v5.17: Base rate 0.35, modified by efficiency
                    const mineRate = getAgentSuccessRate(agent, 0.35);
                    if (rand < mineRate) {
                        // v5.17: Better ores at higher levels
                        const ores = ['Iron Ore', 'Copper Ore', 'Stone'];
                        if (agent.agentLevel >= 3) ores.push('Silver Ore');
                        if (agent.agentLevel >= 5) ores.push('Gold Ore');
                        if (agent.agentLevel >= 7) ores.push('Crystal');
                        const bonusAmount = Math.floor(agent.agentLevel / 4);
                        result = { item: ores[Math.floor(Math.random() * ores.length)], amount: Math.floor(Math.random() * 2) + 1 + bonusAmount };
                        addToInventory(result.item, result.amount);
                        agent.totalEarnings.items.push(result);
                        agent.results.push(result);
                        success = true;
                        agent.statusMessage = `Mined ${result.amount} ${result.item}!`;
                        if (agent.mesh) spawnAgentParticleEffect(agent, 'success');
                    } else {
                        agent.statusMessage = 'Mining deposit...';
                    }
                    trackAgentAction(agent, success, 6);
                    break;

                // v5.18: Terraformer - flattens terrain for construction
                case 'terraform':
                    const terraformRate = getAgentSuccessRate(agent, 0.4);
                    if (rand < terraformRate && agent.mesh) {
                        // Find nearby unflat terrain and flatten it
                        const agentX = Math.floor((agent.mesh.position.x / CONFIG.TILE_SIZE) + CONFIG.WORLD_SIZE / 2);
                        const agentZ = Math.floor((agent.mesh.position.z / CONFIG.TILE_SIZE) + CONFIG.WORLD_SIZE / 2);

                        // Check 3x3 area around agent for terrain variance
                        let maxHeight = -Infinity, minHeight = Infinity;
                        let totalHeight = 0, count = 0;
                        for (let dx = -1; dx <= 1; dx++) {
                            for (let dz = -1; dz <= 1; dz++) {
                                const tx = agentX + dx, tz = agentZ + dz;
                                if (worldState.terrain[tx] && worldState.terrain[tx][tz] !== undefined && worldState.terrain[tx][tz] > 0) {
                                    const h = worldState.terrain[tx][tz];
                                    maxHeight = Math.max(maxHeight, h);
                                    minHeight = Math.min(minHeight, h);
                                    totalHeight += h;
                                    count++;
                                }
                            }
                        }

                        if (count > 0) {
                            const avgHeight = totalHeight / count;
                            const variance = maxHeight - minHeight;

                            if (variance > 1) {
                                // Flatten the area to average height
                                for (let dx = -1; dx <= 1; dx++) {
                                    for (let dz = -1; dz <= 1; dz++) {
                                        const tx = agentX + dx, tz = agentZ + dz;
                                        if (worldState.terrain[tx] && worldState.terrain[tx][tz] !== undefined && worldState.terrain[tx][tz] > 0) {
                                            worldState.terrain[tx][tz] = avgHeight;
                                        }
                                    }
                                }

                                // Record terraformed area
                                const existingArea = worldState.terraformedAreas.find(a =>
                                    Math.abs(a.x - agentX) < 3 && Math.abs(a.z - agentZ) < 3);
                                if (!existingArea) {
                                    worldState.terraformedAreas.push({
                                        x: agentX, z: agentZ,
                                        flatness: 100,
                                        createdAt: Date.now(),
                                        createdBy: agent.name
                                    });
                                }

                                success = true;
                                agent.statusMessage = `ðŸšœ Flattened terrain at (${agentX}, ${agentZ})!`;
                                agent.results.push({ terraformed: { x: agentX, z: agentZ, flatness: 100 } });
                                if (agent.mesh) spawnAgentParticleEffect(agent, 'success');
                            } else {
                                agent.statusMessage = 'Area already flat, scanning for uneven terrain...';
                                // Move to find uneven terrain
                                moveAgentToRandomPosition(agent);
                            }
                        } else {
                            agent.statusMessage = 'Scanning terrain...';
                        }
                    } else {
                        agent.statusMessage = 'Analyzing terrain topology...';
                    }
                    trackAgentAction(agent, success, 8);
                    break;

                // v5.18: Builder - constructs battery chargers
                case 'build':
                    const buildRate = getAgentSuccessRate(agent, 0.35);
                    if (rand < buildRate && agent.mesh) {
                        const agentX = Math.floor((agent.mesh.position.x / CONFIG.TILE_SIZE) + CONFIG.WORLD_SIZE / 2);
                        const agentZ = Math.floor((agent.mesh.position.z / CONFIG.TILE_SIZE) + CONFIG.WORLD_SIZE / 2);

                        // Check if on terraformed/flat area for efficiency bonus
                        const onFlatArea = worldState.terraformedAreas.some(a =>
                            Math.abs(a.x - agentX) < 2 && Math.abs(a.z - agentZ) < 2);

                        // Check if charger already exists nearby
                        const nearbyCharger = worldState.structures.find(s =>
                            s.type === 'battery_charger' &&
                            Math.abs(s.x - agentX) < 5 && Math.abs(s.z - agentZ) < 5);

                        if (!nearbyCharger) {
                            // Build a new battery charger
                            const efficiency = onFlatArea ? 100 : 60 + Math.floor(Math.random() * 20);
                            const charger = createBatteryCharger(
                                agent.mesh.position.x,
                                agent.mesh.position.y,
                                agent.mesh.position.z,
                                efficiency
                            );

                            if (charger) {
                                success = true;
                                agent.statusMessage = `ðŸ”§ Built Battery Charger (${efficiency}% efficiency)!`;
                                agent.results.push({ built: { type: 'battery_charger', efficiency: efficiency, flat: onFlatArea } });
                                if (agent.mesh) spawnAgentParticleEffect(agent, 'success');

                                // Bonus message if on flat terrain
                                if (onFlatArea) {
                                    addCopilotMessage(`âš¡ ${agent.name} built an optimal charger on flat terrain!`, 'ai');
                                }
                            }
                        } else {
                            // Repair/upgrade existing charger
                            if (nearbyCharger.efficiency < 100 && onFlatArea) {
                                nearbyCharger.efficiency = Math.min(100, nearbyCharger.efficiency + 10);
                                success = true;
                                agent.statusMessage = `ðŸ”§ Upgraded charger to ${nearbyCharger.efficiency}%!`;
                            } else {
                                agent.statusMessage = 'Charger nearby, relocating...';
                                moveAgentToRandomPosition(agent);
                            }
                        }
                    } else {
                        agent.statusMessage = rand < 0.5 ? 'Surveying for build site...' : 'Gathering construction materials...';
                    }
                    trackAgentAction(agent, success, 10);
                    break;
            }

            const elapsed = performance.now() - agent.spawnTime;
            agent.progress = Math.min(100, (elapsed / 60000) * 100);

            saveGameData();
            updateAgentCardUI(agent);
        }

        // v5.17: Agent Experience and Efficiency System
        // XP required for each level (exponential curve)
        function getAgentXPForLevel(level) {
            return Math.floor(50 * Math.pow(1.5, level - 1));
        }

        // Grant XP to an agent and handle level ups
        function grantAgentXP(agent, amount) {
            if (!agent) return;
            agent.agentXP += amount;

            // Check for level up
            let xpNeeded = getAgentXPForLevel(agent.agentLevel);
            while (agent.agentXP >= xpNeeded && agent.agentLevel < 10) {
                agent.agentXP -= xpNeeded;
                agent.agentLevel++;
                agent.efficiency = 1.0 + (agent.agentLevel - 1) * 0.1; // +10% efficiency per level

                // Level up effects
                if (agent.mesh) {
                    spawnAgentParticleEffect(agent, 'levelup');
                }
                addCopilotMessage(`ðŸŽ‰ ${agent.typeConfig.icon} ${agent.name} reached Level ${agent.agentLevel}! Efficiency: ${Math.round(agent.efficiency * 100)}%`, 'ai');

                xpNeeded = getAgentXPForLevel(agent.agentLevel);
            }
        }

        // Track action success and update combo
        function trackAgentAction(agent, success, xpAmount = 5) {
            agent.actionsPerformed++;

            if (success) {
                agent.successfulActions++;
                agent.combo++;
                agent.maxCombo = Math.max(agent.maxCombo, agent.combo);
                agent.lastActionSuccess = true;

                // Combo XP bonus: +1 XP per combo level (max +10)
                const comboBonus = Math.min(agent.combo, 10);
                grantAgentXP(agent, xpAmount + comboBonus);

                // Spawn combo particle effect at milestones
                if (agent.combo === 5 || agent.combo === 10 || agent.combo === 25 || agent.combo % 50 === 0) {
                    if (agent.mesh) {
                        spawnAgentParticleEffect(agent, 'combo');
                    }
                    if (agent.combo >= 10) {
                        addCopilotMessage(`ðŸ”¥ ${agent.typeConfig.icon} ${agent.name} ${agent.combo}x COMBO!`, 'ai');
                    }
                }
            } else {
                // Reset combo on failure
                if (agent.combo >= 5) {
                    // Lost significant combo - notify player
                    agent.statusMessage = `Combo lost at ${agent.combo}x`;
                }
                agent.combo = 0;
                agent.lastActionSuccess = false;
                // Still grant minimal XP for effort
                grantAgentXP(agent, 1);
            }
        }

        // Get effective success rate based on agent efficiency and combo
        function getAgentSuccessRate(agent, baseRate) {
            // Efficiency from level
            let rate = baseRate * agent.efficiency;

            // Combo bonus: up to +20% at 10+ combo
            const comboBonus = Math.min(agent.combo, 10) * 0.02;
            rate += comboBonus;

            // v5.17: Synergy bonus when agents work near each other
            const synergyBonus = getAgentSynergyBonus(agent);
            rate += synergyBonus;

            // Cap at 95%
            return Math.min(0.95, rate);
        }

        // v5.17: Calculate synergy bonus based on nearby allied agents
        function getAgentSynergyBonus(agent) {
            if (!agent.mesh) return 0;

            let nearbyAgents = 0;
            const synergyRange = 15; // Units

            agentFleet.forEach(other => {
                if (other.id === agent.id || !other.mesh) return;
                const dist = agent.mesh.position.distanceTo(other.mesh.position);
                if (dist <= synergyRange) {
                    nearbyAgents++;
                }
            });

            // +5% per nearby agent, max +15% (3 agents)
            return Math.min(nearbyAgents, 3) * 0.05;
        }

        // v5.17: Particle effects for agent actions
        function spawnAgentParticleEffect(agent, effectType) {
            if (!agent.mesh || !worldState.scene) return;

            const particleCount = effectType === 'levelup' ? 20 : (effectType === 'combo' ? 12 : 8);
            const particleGroup = new THREE.Group();

            // Choose color based on effect type
            let color;
            switch (effectType) {
                case 'levelup':
                    color = 0xffd700; // Gold
                    break;
                case 'combo':
                    color = 0xff8800; // Orange
                    break;
                case 'success':
                    color = agent.typeConfig.color;
                    break;
                case 'heal':
                    color = 0x00ff88;
                    break;
                default:
                    color = 0xffffff;
            }

            // Create particles
            for (let i = 0; i < particleCount; i++) {
                const size = 0.05 + Math.random() * 0.1;
                const geom = new THREE.SphereGeometry(size, 4, 4);
                const mat = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.9
                });
                const particle = new THREE.Mesh(geom, mat);

                // Random spread
                particle.position.set(
                    (Math.random() - 0.5) * 0.5,
                    0.5 + Math.random() * 0.5,
                    (Math.random() - 0.5) * 0.5
                );

                // Store velocity for animation
                particle.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 2,
                    1 + Math.random() * 2,
                    (Math.random() - 0.5) * 2
                );

                particleGroup.add(particle);
            }

            particleGroup.position.copy(agent.mesh.position);
            worldState.scene.add(particleGroup);

            // Animate and remove
            let elapsed = 0;
            const duration = effectType === 'levelup' ? 1500 : 800;

            function animateParticles() {
                elapsed += 16;
                const progress = elapsed / duration;

                if (progress >= 1) {
                    worldState.scene.remove(particleGroup);
                    particleGroup.children.forEach(p => {
                        p.geometry.dispose();
                        p.material.dispose();
                    });
                    return;
                }

                particleGroup.children.forEach(p => {
                    p.position.add(p.userData.velocity.clone().multiplyScalar(0.016));
                    p.userData.velocity.y -= 3 * 0.016; // Gravity
                    p.material.opacity = 0.9 * (1 - progress);
                    p.scale.setScalar(1 - progress * 0.5);
                });

                requestAnimationFrame(animateParticles);
            }

            requestAnimationFrame(animateParticles);
        }

        // v5.17: Agent health regeneration (passive)
        function updateAgentHealthRegen(agent) {
            if (!agent || !agent.taskState) return;

            const now = performance.now();
            const regenInterval = 5000; // Regen every 5 seconds

            if (now - agent.lastHealthRegen >= regenInterval) {
                agent.lastHealthRegen = now;

                const task = agent.taskState;
                if (task.hp < task.maxHp) {
                    // Regen rate: 2 HP base + 1 HP per level
                    const regenAmount = 2 + agent.agentLevel;
                    task.hp = Math.min(task.maxHp, task.hp + regenAmount);

                    // Show heal effect for significant heals
                    if (regenAmount >= 3 && agent.mesh) {
                        spawnAgentParticleEffect(agent, 'heal');
                    }
                }
            }
        }

        // Recall an agent
        function recallAgent(agentId) {
            const agentIndex = agentFleet.findIndex(a => a.id === agentId);
            if (agentIndex === -1) return;

            const agent = agentFleet[agentIndex];

            // Stop the update loop
            if (agentUpdateTimers[agent.id]) {
                clearTimeout(agentUpdateTimers[agent.id]);
                delete agentUpdateTimers[agent.id];
            }

            // Remove mesh from scene
            if (agent.mesh && worldState.scene) {
                worldState.scene.remove(agent.mesh);
            }

            // Generate summary
            const summary = [];
            // v5.17: Include level and stats in summary
            summary.push(`Lv.${agent.agentLevel}`);
            if (agent.maxCombo > 0) summary.push(`Best combo: ${agent.maxCombo}x`);
            if (agent.totalEarnings.xp > 0) summary.push(`+${agent.totalEarnings.xp} XP`);
            if (agent.totalEarnings.gold > 0) summary.push(`+${agent.totalEarnings.gold} Gold`);
            if (agent.totalEarnings.items.length > 0) {
                const itemCounts = {};
                agent.totalEarnings.items.forEach(i => {
                    itemCounts[i.item] = (itemCounts[i.item] || 0) + (i.amount || 1);
                });
                Object.entries(itemCounts).forEach(([item, count]) => {
                    summary.push(`+${count} ${item}`);
                });
            }

            // Remove from fleet
            agentFleet.splice(agentIndex, 1);

            // Announce
            // v5.17: Enhanced recall message with agent performance stats
            const successRate = agent.actionsPerformed > 0 ? Math.round((agent.successfulActions / agent.actionsPerformed) * 100) : 0;
            const statsStr = `[${successRate}% success rate, ${agent.actionsPerformed} actions]`;
            const summaryStr = summary.length > 0 ? ` ${summary.join(', ')}` : '';
            addCopilotMessage(`${agent.typeConfig.icon} ${agent.name} recalled! ${statsStr}${summaryStr}`, 'ai');

            updateFleetUI();
            updateFleetButton();
        }

        // Update the fleet button indicator
        function updateFleetButton() {
            const btn = document.getElementById('fleet-button');
            if (agentFleet.length > 0) {
                btn.classList.add('has-agents');
                btn.setAttribute('data-count', agentFleet.length);
            } else {
                btn.classList.remove('has-agents');
            }
        }

        // Update the fleet panel UI
        function updateFleetUI() {
            document.getElementById('fleet-count').textContent = `${agentFleet.length}/${MAX_AGENTS}`;

            // Update spawn buttons disabled state
            const spawnBtns = document.querySelectorAll('.agent-spawn-btn');
            spawnBtns.forEach(btn => {
                btn.disabled = agentFleet.length >= MAX_AGENTS;
            });

            // Update agent list
            const listContainer = document.getElementById('agent-fleet-list');

            if (agentFleet.length === 0) {
                listContainer.innerHTML = `
                    <div style="color: #666; text-align: center; padding: 20px; font-size: 12px;">
                        No agents deployed yet.<br>Click an agent type above to spawn.
                    </div>
                `;
                return;
            }

            listContainer.innerHTML = agentFleet.map(agent => {
                const colorHex = '#' + agent.typeConfig.color.toString(16).padStart(6, '0');
                const statusDotClass = agent.status === 'thinking' ? 'thinking' : (agent.status === 'idle' ? 'idle' : '');

                // v5.14: Get endpoint/profile info
                const agentEndpoint = getAgentEndpoint(agent);
                const endpointBadge = agent.profileId ?
                    `<span style="font-size: 9px; color: #06ffa5; background: rgba(6,255,165,0.1); padding: 2px 6px; border-radius: 3px; margin-left: 5px;">${agentEndpoint.name}</span>` : '';

                const recentResults = agent.results.slice(-3).map(r => {
                    if (r.item) return `+${r.amount} ${r.item}`;
                    if (r.xp) return `+${r.xp} XP`;
                    if (r.gold) return `+${r.gold} Gold`;
                    if (r.heal) return `+${r.heal} HP`;
                    if (r.discovery) return r.discovery.substring(0, 20);
                    return '';
                }).filter(Boolean);

                return `
                    <div class="agent-card" data-agent-id="${agent.id}">
                        <div class="agent-card-header">
                            <div class="agent-identity">
                                <div class="agent-avatar ${agent.typeConfig.colorClass}" style="background: ${colorHex}22;">
                                    ${agent.typeConfig.icon}
                                </div>
                                <div class="agent-info">
                                    <div class="agent-name">${agent.name}${endpointBadge}</div>
                                    <div class="agent-role">${agent.typeConfig.name}</div>
                                </div>
                            </div>
                            <div class="agent-actions">
                                <button class="agent-action-btn export" onclick="exportAgentTranscript('${agent.id}')" title="Export transcript">ðŸ“‹</button>
                                <button class="agent-action-btn recall" onclick="recallAgent('${agent.id}')" title="Recall agent">âœ•</button>
                            </div>
                        </div>
                        <div class="agent-card-status">
                            <div class="agent-status-dot ${statusDotClass}"></div>
                            <span class="status-text">${agent.statusMessage}</span>
                        </div>
                        <div class="agent-card-progress">
                            <div class="agent-progress-bar" style="width: ${agent.progress}%; background: ${colorHex};"></div>
                        </div>
                        ${recentResults.length > 0 ? `
                            <div class="agent-results-mini">
                                ${recentResults.map(r => `<span class="agent-result-tag">${r}</span>`).join('')}
                            </div>
                        ` : ''}
                        <!-- v5.15: Expandable Real-Time Transcript Viewer -->
                        <div class="agent-transcript-toggle" onclick="toggleAgentTranscript('${agent.id}')">
                            <span class="expand-icon">â–¶</span>
                            <span>Live Transcript</span>
                            <span class="transcript-message-count">${agent.conversationHistory.length} msgs</span>
                            ${agent.status === 'thinking' ? '<span class="transcript-live-indicator"></span>' : ''}
                        </div>
                        <div class="agent-transcript-viewer" id="transcript-viewer-${agent.id}">
                            ${buildAgentTranscriptHTML(agent)}
                        </div>
                    </div>
                `;
            }).join('');
        }

        // Update a single agent card UI
        // v5.16.3: Enhanced to show actual task state from autonomous system
        function updateAgentCardUI(agent) {
            const card = document.querySelector(`.agent-card[data-agent-id="${agent.id}"]`);
            if (!card) return;

            const statusDot = card.querySelector('.agent-status-dot');
            const statusText = card.querySelector('.status-text');
            const progressBar = card.querySelector('.agent-progress-bar');

            if (statusDot) {
                statusDot.className = 'agent-status-dot';
                if (agent.status === 'thinking') statusDot.classList.add('thinking');
                if (agent.status === 'idle') statusDot.classList.add('idle');
            }

            // v5.16.3: Show actual task state from autonomous system
            let displayStatus = agent.statusMessage;
            if (agent.mesh && agent.taskState) {
                const task = agent.taskState;
                const stateDescriptions = {
                    'idle': 'Scanning for targets...',
                    'moving': `Moving to target`,
                    'working': 'Working...',
                    'combat': 'In combat!',
                    'alert': task.alert || 'Alert!',
                    'manual_control': 'Manual control',
                    'stuck': 'Repositioning...'
                };
                const stateMsg = stateDescriptions[task.state] || task.state;
                const pos = agent.mesh.position;
                displayStatus = `${stateMsg} (${Math.floor(pos.x)}, ${Math.floor(pos.z)})`;
            } else if (!agent.mesh) {
                displayStatus = 'Waiting to spawn...';
            }
            if (statusText) statusText.textContent = displayStatus;
            if (progressBar) progressBar.style.width = `${agent.progress}%`;

            // v5.17: Update level and combo display
            let levelComboDiv = card.querySelector('.agent-level-combo');
            if (!levelComboDiv) {
                levelComboDiv = document.createElement('div');
                levelComboDiv.className = 'agent-level-combo';
                levelComboDiv.style.cssText = 'display: flex; gap: 8px; margin: 4px 0; font-size: 10px;';
                const statusContainer = card.querySelector('.agent-card-status');
                if (statusContainer) statusContainer.after(levelComboDiv);
            }
            const xpNeeded = getAgentXPForLevel(agent.agentLevel);
            const xpPercent = Math.min(100, Math.round((agent.agentXP / xpNeeded) * 100));
            const comboColor = agent.combo >= 10 ? '#ff8800' : (agent.combo >= 5 ? '#ffcc00' : '#888');
            const levelColor = agent.agentLevel >= 5 ? '#ffd700' : (agent.agentLevel >= 3 ? '#00ff88' : '#0ff');
            levelComboDiv.innerHTML = `
                <span style="color: ${levelColor}; font-weight: bold;">Lv.${agent.agentLevel}</span>
                <span style="color: #666;">(${xpPercent}%)</span>
                ${agent.combo > 0 ? `<span style="color: ${comboColor}; font-weight: bold;">ðŸ”¥ ${agent.combo}x</span>` : ''}
                <span style="color: #888; margin-left: auto;">âš¡${Math.round(agent.efficiency * 100)}%</span>
            `;

            // Update results
            const recentResults = agent.results.slice(-3).map(r => {
                if (r.item) return `+${r.amount} ${r.item}`;
                if (r.xp) return `+${r.xp} XP`;
                if (r.gold) return `+${r.gold} Gold`;
                if (r.heal) return `+${r.heal} HP`;
                if (r.discovery) return r.discovery.substring(0, 20);
                return '';
            }).filter(Boolean);

            let resultsDiv = card.querySelector('.agent-results-mini');
            if (recentResults.length > 0) {
                if (!resultsDiv) {
                    resultsDiv = document.createElement('div');
                    resultsDiv.className = 'agent-results-mini';
                    card.appendChild(resultsDiv);
                }
                resultsDiv.innerHTML = recentResults.map(r => `<span class="agent-result-tag">${r}</span>`).join('');
            }

            // v5.15: Update transcript toggle and viewer
            const transcriptToggle = card.querySelector('.agent-transcript-toggle');
            if (transcriptToggle) {
                const msgCount = transcriptToggle.querySelector('.transcript-message-count');
                if (msgCount) msgCount.textContent = `${agent.conversationHistory.length} msgs`;

                // Update live indicator
                let liveIndicator = transcriptToggle.querySelector('.transcript-live-indicator');
                if (agent.status === 'thinking') {
                    if (!liveIndicator) {
                        liveIndicator = document.createElement('span');
                        liveIndicator.className = 'transcript-live-indicator';
                        transcriptToggle.appendChild(liveIndicator);
                    }
                } else if (liveIndicator) {
                    liveIndicator.remove();
                }
            }

            // Update transcript viewer if expanded
            const transcriptViewer = card.querySelector('.agent-transcript-viewer.expanded');
            if (transcriptViewer) {
                updateAgentTranscriptUI(agent);
            }
        }

        // v5.15: Toggle agent transcript viewer expansion
        // v5.16.1: Added body cam rendering when expanded
        function toggleAgentTranscript(agentId) {
            const card = document.querySelector(`.agent-card[data-agent-id="${agentId}"]`);
            if (!card) return;

            const toggle = card.querySelector('.agent-transcript-toggle');
            const viewer = card.querySelector('.agent-transcript-viewer');

            if (toggle && viewer) {
                const isExpanded = viewer.classList.contains('expanded');
                toggle.classList.toggle('expanded', !isExpanded);
                viewer.classList.toggle('expanded', !isExpanded);

                // If opening, update the content and render body cam
                if (!isExpanded) {
                    const agent = agentFleet.find(a => a.id === agentId);
                    if (agent) {
                        viewer.innerHTML = buildAgentTranscriptHTML(agent);
                        // Scroll to bottom to show latest messages
                        viewer.scrollTop = viewer.scrollHeight;
                        // v5.16.1: Render body cam after DOM update
                        setTimeout(() => renderAgentBodyCam(agent), 100);
                    }
                }
            }
        }

        // v5.15: Build HTML for agent transcript messages
        // v5.15.2: Enhanced with Try Again replay buttons
        // v5.16.1: Added body cam preview
        function buildAgentTranscriptHTML(agent) {
            const history = agent.conversationHistory;

            if (history.length === 0) {
                return '<div class="transcript-empty">No messages yet - agent is initializing...</div>';
            }

            const agentEndpoint = getAgentEndpoint(agent);
            const endpointInfo = agentEndpoint.name || 'Local Simulation';
            const interactions = agent.interactionHistory || [];

            // v5.16.1: Get agent position and status for body cam overlay
            const agentPos = agent.mesh ? agent.mesh.position : { x: 0, y: 0, z: 0 };
            const taskState = agent.taskState || {};
            const stateText = taskState.state || 'initializing';
            const currentAction = taskState.currentTask || stateText;

            let html = `
                <!-- v5.16.1: Body Cam Preview + v5.16.2: Takeover Controls -->
                <!-- v5.16.3: Enhanced with streaming pattern for real-time view -->
                <div class="agent-bodycam-container" title="Agent Body Cam - Click to Locate">
                    <canvas class="agent-bodycam-canvas" id="bodycam-${agent.id}" width="320" height="150"></canvas>
                    <div class="agent-bodycam-overlay">
                        <div class="agent-bodycam-label">
                            <span class="rec-dot"></span>
                            <span>BODY CAM</span>
                        </div>
                        <div class="agent-bodycam-status">${stateText.toUpperCase()}</div>
                    </div>
                    <div class="agent-bodycam-bottom">
                        <div class="agent-bodycam-coords">X:${Math.floor(agentPos.x)} Z:${Math.floor(agentPos.z)}</div>
                        <div class="agent-bodycam-action">${agent.typeConfig.icon} ${agent.statusMessage?.substring(0, 25) || 'Working...'}</div>
                    </div>
                    <!-- v5.16.2: Control buttons overlay -->
                    <!-- v5.17.1: Added POP OUT button for independent agent control window -->
                    <div class="agent-bodycam-controls">
                        <button class="agent-pov-btn locate" onclick="event.stopPropagation(); focusOnAgent('${agent.id}')" title="Navigate to agent">
                            ðŸ“ LOCATE
                        </button>
                        <button class="agent-pov-btn takeover" onclick="event.stopPropagation(); openAgentTakeover('${agent.id}')" title="Take remote control of this agent">
                            ðŸŽ® TAKEOVER
                        </button>
                        <button class="agent-pov-btn popout" onclick="event.stopPropagation(); popOutAgentWindow('${agent.id}')" title="Open agent control in separate window">
                            ðŸªŸ POP OUT
                        </button>
                    </div>
                </div>

                <div class="transcript-header">
                    <span class="transcript-header-title">ðŸ“¡ ${endpointInfo}</span>
                    <span class="transcript-message-count">${history.length} msgs | ${interactions.length} interactions</span>
                </div>
                <div class="transcript-messages">
            `;

            // Show messages (system first, then alternating user/assistant)
            history.forEach((msg, idx) => {
                const roleClass = msg.role === 'system' ? 'system' : (msg.role === 'user' ? 'user' : 'assistant');
                const roleIcon = msg.role === 'system' ? 'âš™ï¸' : (msg.role === 'user' ? 'ðŸ“¤' : 'ðŸ¤–');
                const roleLabel = msg.role === 'system' ? 'System' : (msg.role === 'user' ? 'Context' : 'Response');

                // Truncate long content for display
                let content = msg.content;
                const isTruncated = content.length > 500;
                if (isTruncated) {
                    content = content.substring(0, 500) + '... [truncated]';
                }

                // Escape HTML entities
                content = content.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');

                // v5.15.2: Find matching interaction for assistant responses
                let tryAgainBtn = '';
                if (msg.role === 'assistant') {
                    // Find the interaction that produced this response
                    const interaction = interactions.find(i =>
                        i.response === msg.content ||
                        (i.conversationIndexAfter && i.conversationIndexAfter > idx)
                    );
                    if (interaction) {
                        const isReplaying = agent.replayState?.interactionId === interaction.id;
                        tryAgainBtn = `
                            <button class="try-again-btn ${isReplaying ? 'replaying' : ''}"
                                    onclick="event.stopPropagation(); tryAgainInteraction('${agent.id}', '${interaction.id}')"
                                    title="Replay this interaction with current game state">
                                ðŸ”„ Try Again
                            </button>
                        `;
                    }
                }

                html += `
                    <div class="transcript-msg ${roleClass}">
                        <div class="transcript-msg-role" style="display: flex; justify-content: space-between; align-items: center;">
                            <span>${roleIcon} ${roleLabel} #${idx + 1}</span>
                            ${tryAgainBtn}
                        </div>
                        <div class="transcript-msg-content ${isTruncated ? 'truncated' : ''}">${content}</div>
                    </div>
                `;
            });

            // v5.15.2: Show replay comparison if active
            if (agent.replayState) {
                html += buildReplayComparisonHTML(agent);
            }

            html += '</div>';
            return html;
        }

        // v5.15.2: Build HTML for replay comparison view
        function buildReplayComparisonHTML(agent) {
            const replay = agent.replayState;
            if (!replay) return '';

            const originalContent = (replay.originalResponse || '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
            const retryContent = (replay.retryResponse || 'Waiting for response...').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');

            const isSame = replay.retryResponse && replay.originalResponse === replay.retryResponse;
            const isDifferent = replay.retryResponse && replay.originalResponse !== replay.retryResponse;

            return `
                <div class="replay-comparison">
                    <div class="replay-comparison-header">
                        <span class="replay-comparison-title">ðŸ”„ Try Again Comparison</span>
                        ${replay.retryResponse ? `
                            <span class="replay-branch-indicator ${isSame ? 'same' : ''}">
                                ${isSame ? 'âœ“ Same Result' : 'âš¡ Different Result'}
                            </span>
                        ` : '<span class="replay-branch-indicator">â³ Replaying...</span>'}
                    </div>
                    <div class="replay-side-by-side">
                        <div class="replay-column original">
                            <div class="replay-column-label">ðŸ“œ Original Response</div>
                            <div class="replay-content">${originalContent.substring(0, 300)}${originalContent.length > 300 ? '...' : ''}</div>
                        </div>
                        <div class="replay-column retry ${isDifferent ? 'replay-diff' : ''}">
                            <div class="replay-column-label">ðŸ†• Retry Response</div>
                            <div class="replay-content">${retryContent.substring(0, 300)}${retryContent.length > 300 ? '...' : ''}</div>
                        </div>
                    </div>
                    ${replay.retryResponse ? `
                        <div class="replay-actions">
                            <button class="replay-action-btn use-original" onclick="dismissReplayComparison('${agent.id}')">
                                Keep Original
                            </button>
                            ${isDifferent ? `
                                <button class="replay-action-btn use-retry" onclick="applyRetryResponse('${agent.id}')">
                                    Use Retry & Branch
                                </button>
                            ` : ''}
                        </div>
                    ` : ''}
                </div>
            `;
        }

        // v5.15.2: Try Again - replay an interaction with current game state
        async function tryAgainInteraction(agentId, interactionId) {
            const agent = agentFleet.find(a => a.id === agentId);
            if (!agent) return;

            const interaction = agent.interactionHistory.find(i => i.id === interactionId);
            if (!interaction) {
                console.warn('Interaction not found:', interactionId);
                return;
            }

            // Set replay state
            agent.replayState = {
                interactionId: interactionId,
                originalResponse: interaction.response,
                originalContext: interaction.gameContext,
                retryResponse: null,
                retryContext: null,
                status: 'replaying'
            };

            // Update UI to show replaying state
            updateAgentTranscriptUI(agent);

            // Get endpoint
            const endpoint = getAgentEndpoint(agent);
            if (!endpoint || !endpoint.url || !endpoint.key) {
                agent.replayState.retryResponse = '[ERROR: No endpoint configured]';
                agent.replayState.status = 'error';
                updateAgentTranscriptUI(agent);
                return;
            }

            try {
                // Build NEW context with current game state
                const newGameContext = buildGameContextForAgent(agent);
                agent.replayState.retryContext = newGameContext;

                // Build new context message
                const newContextMessage = {
                    role: 'user',
                    content: `Current situation: ${JSON.stringify(newGameContext)}. What's your next action?`
                };

                // Use original conversation history up to that point
                const originalConversation = agent.conversationHistory.slice(0, interaction.conversationIndexBefore);
                const conversationForApi = [...originalConversation, newContextMessage];

                // Build headers
                const headers = { 'Content-Type': 'application/json' };
                if (endpoint.headerPrefix) {
                    headers[endpoint.headerStyle] = endpoint.headerPrefix + endpoint.key;
                } else {
                    headers[endpoint.headerStyle] = endpoint.key;
                }

                // Format request body
                const requestBody = formatAgentRequestBody(endpoint, newContextMessage, conversationForApi, agent);

                // Make API call
                const response = await fetch(endpoint.url, {
                    method: 'POST',
                    headers: headers,
                    body: requestBody
                });

                if (response.ok) {
                    const data = await response.json();
                    const textResponse = parseAgentResponse(endpoint, data);

                    agent.replayState.retryResponse = textResponse;
                    agent.replayState.status = 'complete';
                    agent.replayState.retryRawResponse = data;
                } else {
                    const errorText = await response.text().catch(() => '');
                    agent.replayState.retryResponse = `[API Error ${response.status}: ${errorText.substring(0, 100)}]`;
                    agent.replayState.status = 'error';
                }
            } catch (error) {
                console.error('Try Again error:', error);
                agent.replayState.retryResponse = `[Network Error: ${error.message}]`;
                agent.replayState.status = 'error';
            }

            // Update UI with comparison
            updateAgentTranscriptUI(agent);
        }

        // v5.15.2: Dismiss replay comparison without changes
        function dismissReplayComparison(agentId) {
            const agent = agentFleet.find(a => a.id === agentId);
            if (!agent) return;

            agent.replayState = null;
            updateAgentTranscriptUI(agent);
        }

        // v5.15.2: Apply retry response and branch off with new conversation
        function applyRetryResponse(agentId) {
            const agent = agentFleet.find(a => a.id === agentId);
            if (!agent || !agent.replayState) return;

            const replay = agent.replayState;
            const interaction = agent.interactionHistory.find(i => i.id === replay.interactionId);

            if (!interaction || !replay.retryResponse) {
                dismissReplayComparison(agentId);
                return;
            }

            // Branch: Keep conversation up to original interaction point
            agent.conversationHistory = agent.conversationHistory.slice(0, interaction.conversationIndexBefore);

            // Add new context message with current game state
            const newContextMessage = {
                role: 'user',
                content: `Current situation: ${JSON.stringify(replay.retryContext)}. What's your next action?`
            };
            agent.conversationHistory.push(newContextMessage);

            // Add retry response
            agent.conversationHistory.push({ role: 'assistant', content: replay.retryResponse });

            // Create new interaction record for the branch
            const branchInteraction = {
                id: Date.now().toString(36) + Math.random().toString(36).substr(2, 5),
                timestamp: Date.now(),
                contextMessage: newContextMessage,
                gameContext: replay.retryContext,
                endpoint: interaction.endpoint,
                response: replay.retryResponse,
                rawResponse: replay.retryRawResponse,
                conversationIndexBefore: interaction.conversationIndexBefore,
                conversationIndexAfter: agent.conversationHistory.length,
                executed: false,
                branchedFrom: interaction.id  // Track branch origin
            };
            agent.interactionHistory.push(branchInteraction);

            // Execute the new decision
            parseAndExecuteAgentDecision(agent, replay.retryResponse);
            branchInteraction.executed = true;

            // Clear replay state
            agent.replayState = null;

            // Notify
            addCopilotMessage(`ðŸ”„ ${agent.name} branched off with new response from Try Again!`, 'ai');

            // Update UI
            updateAgentCardUI(agent);
            updateAgentTranscriptUI(agent);
        }

        // v5.15: Update agent transcript UI (when new messages arrive)
        function updateAgentTranscriptUI(agent) {
            const viewer = document.getElementById(`transcript-viewer-${agent.id}`);
            if (!viewer || !viewer.classList.contains('expanded')) return;

            // Store scroll position
            const wasScrolledToBottom = viewer.scrollHeight - viewer.clientHeight <= viewer.scrollTop + 10;

            // Update content
            viewer.innerHTML = buildAgentTranscriptHTML(agent);

            // Auto-scroll to bottom if user was at bottom
            if (wasScrolledToBottom) {
                viewer.scrollTop = viewer.scrollHeight;
            }

            // v5.16.1: Render body cam after DOM update
            setTimeout(() => renderAgentBodyCam(agent), 50);
        }

        // v5.16.1: Agent body cam renderer and camera system
        // v5.16.3: Rewritten using streaming pattern from AI Companion Hub
        let agentBodyCamCamera = null;
        let agentBodyCamRenderer = null;
        let bodyCamInitialized = false;

        // Body cam streaming state (similar to Show Mode pattern)
        const bodyCamState = {
            activeStreams: new Map(), // agentId -> { lastRender: timestamp, canvas: element }
            updateInterval: 100, // ms between frame updates
            isRendering: false
        };

        // Initialize body cam rendering system (streaming pattern)
        function initAgentBodyCamSystem() {
            if (bodyCamInitialized) return true;
            if (!worldState.scene) {
                console.log('Body cam init: waiting for scene...');
                return false;
            }

            try {
                // Create a dedicated camera for body cam views
                agentBodyCamCamera = new THREE.PerspectiveCamera(70, 320/150, 0.1, 150);

                // Create a dedicated renderer with preserveDrawingBuffer for canvas copy
                // This is the key fix - similar to AI Companion Hub's renderer setup
                agentBodyCamRenderer = new THREE.WebGLRenderer({
                    alpha: true,
                    antialias: false,
                    powerPreference: 'low-power',
                    preserveDrawingBuffer: true // Critical for canvas streaming!
                });
                agentBodyCamRenderer.setSize(320, 150);
                agentBodyCamRenderer.setPixelRatio(1);
                agentBodyCamRenderer.setClearColor(0x000000, 1);

                bodyCamInitialized = true;
                console.log('Body cam system initialized successfully');
                return true;
            } catch (error) {
                console.error('Failed to initialize body cam system:', error);
                return false;
            }
        }

        // v5.16.3: Stream agent's POV to body cam canvas (AI Companion Hub pattern)
        function renderAgentBodyCam(agent) {
            if (!agent || !agent.mesh) {
                renderBodyCamPlaceholder(agent);
                return;
            }

            if (!worldState.scene) {
                renderBodyCamPlaceholder(agent, 'Waiting for world...');
                return;
            }

            const canvas = document.getElementById(`bodycam-${agent.id}`);
            if (!canvas) return;

            // Initialize body cam system if needed
            if (!bodyCamInitialized && !initAgentBodyCamSystem()) {
                renderBodyCamPlaceholder(agent, 'Initializing...');
                return;
            }

            if (!agentBodyCamRenderer || !agentBodyCamCamera) {
                renderBodyCamPlaceholder(agent, 'Renderer unavailable');
                return;
            }

            try {
                // Position camera at agent's head level, looking in their facing direction
                const agentPos = agent.mesh.position;
                const agentRotation = agent.mesh.rotation.y || 0;

                // Camera position: at agent's eye level, looking forward
                agentBodyCamCamera.position.set(
                    agentPos.x + Math.sin(agentRotation) * 0.3,
                    agentPos.y + 1.5, // Eye level
                    agentPos.z + Math.cos(agentRotation) * 0.3
                );

                // Look in the direction the agent is facing
                const lookTarget = new THREE.Vector3(
                    agentPos.x + Math.sin(agentRotation) * 10,
                    agentPos.y + 1.0,
                    agentPos.z + Math.cos(agentRotation) * 10
                );
                agentBodyCamCamera.lookAt(lookTarget);

                // Render the scene from agent's perspective
                agentBodyCamRenderer.render(worldState.scene, agentBodyCamCamera);

                // Stream to the canvas element (AI Companion Hub pattern)
                const ctx = canvas.getContext('2d');
                if (ctx) {
                    // Clear and draw the rendered frame
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(agentBodyCamRenderer.domElement, 0, 0, canvas.width, canvas.height);

                    // Add scan line effect for retro feel
                    ctx.strokeStyle = 'rgba(0, 255, 255, 0.03)';
                    for (let y = 0; y < canvas.height; y += 3) {
                        ctx.beginPath();
                        ctx.moveTo(0, y);
                        ctx.lineTo(canvas.width, y);
                        ctx.stroke();
                    }

                    // Add vignette effect
                    const gradient = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 30, canvas.width/2, canvas.height/2, 180);
                    gradient.addColorStop(0, 'rgba(0,0,0,0)');
                    gradient.addColorStop(1, 'rgba(0,0,0,0.4)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    // v5.17: Add level and combo HUD overlay
                    ctx.font = 'bold 10px monospace';
                    // Level badge (top-left)
                    const levelColor = agent.agentLevel >= 5 ? '#ffd700' : (agent.agentLevel >= 3 ? '#00ff88' : '#0ff');
                    ctx.fillStyle = 'rgba(0,0,0,0.6)';
                    ctx.fillRect(4, 4, 36, 14);
                    ctx.fillStyle = levelColor;
                    ctx.fillText(`Lv.${agent.agentLevel}`, 8, 14);

                    // Combo indicator (top-right, if active)
                    if (agent.combo >= 3) {
                        const comboText = `${agent.combo}x`;
                        const comboColor = agent.combo >= 10 ? '#ff8800' : (agent.combo >= 5 ? '#ffcc00' : '#fff');
                        const comboWidth = ctx.measureText(comboText).width + 16;
                        ctx.fillStyle = 'rgba(0,0,0,0.6)';
                        ctx.fillRect(canvas.width - comboWidth - 4, 4, comboWidth, 14);
                        ctx.fillStyle = comboColor;
                        ctx.fillText(`ðŸ”¥${comboText}`, canvas.width - comboWidth, 14);
                    }

                    // Efficiency bar (bottom-left)
                    const effPercent = agent.efficiency * 100;
                    const barWidth = 50;
                    const barHeight = 4;
                    ctx.fillStyle = 'rgba(0,0,0,0.6)';
                    ctx.fillRect(4, canvas.height - 10, barWidth + 4, barHeight + 4);
                    ctx.fillStyle = '#333';
                    ctx.fillRect(6, canvas.height - 8, barWidth, barHeight);
                    ctx.fillStyle = effPercent >= 150 ? '#ffd700' : (effPercent >= 120 ? '#00ff88' : '#0ff');
                    ctx.fillRect(6, canvas.height - 8, barWidth * (effPercent / 200), barHeight);

                    // Update stream state
                    bodyCamState.activeStreams.set(agent.id, {
                        lastRender: performance.now(),
                        canvas: canvas
                    });
                }
            } catch (error) {
                console.error(`Body cam render error for ${agent.name}:`, error);
                renderBodyCamPlaceholder(agent, 'Render error');
            }
        }

        // v5.16.3: Render placeholder when body cam can't display real view
        function renderBodyCamPlaceholder(agent, message = 'No signal') {
            if (!agent) return;
            const canvas = document.getElementById(`bodycam-${agent.id}`);
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            if (!ctx) return;

            // Dark background with noise effect
            ctx.fillStyle = '#0a0a0f';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Add static noise effect
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                if (Math.random() < 0.05) {
                    const noise = Math.random() * 30;
                    data[i] = noise;     // R
                    data[i + 1] = noise; // G
                    data[i + 2] = noise; // B
                }
            }
            ctx.putImageData(imageData, 0, 0);

            // Draw status text
            ctx.fillStyle = '#0af';
            ctx.font = 'bold 14px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(message, canvas.width/2, canvas.height/2);

            // Draw agent info if available
            if (agent.taskState) {
                ctx.font = '10px monospace';
                ctx.fillStyle = '#888';
                const state = agent.taskState.state || 'initializing';
                ctx.fillText(`State: ${state}`, canvas.width/2, canvas.height/2 + 20);
            }

            // Draw border
            ctx.strokeStyle = '#0af';
            ctx.lineWidth = 2;
            ctx.strokeRect(2, 2, canvas.width - 4, canvas.height - 4);
        }

        // v5.16.1: Focus camera on an agent (click to locate)
        // v5.16.3: Enhanced - teleport player directly to agent location
        function focusOnAgent(agentId) {
            const agent = agentFleet.find(a => a.id === agentId);
            if (!agent || !agent.mesh) {
                // v5.16.3: Try to create mesh if scene is ready
                if (agent && !agent.mesh && worldState.scene) {
                    createAgentMesh(agent);
                }
                if (!agent || !agent.mesh) {
                    addCopilotMessage(`Cannot locate agent - agent may not be spawned yet. Wait for world to load.`, 'ai');
                    return;
                }
            }

            const agentPos = agent.mesh.position;

            // v5.16.3: Teleport player directly to agent location
            if (worldState.player) {
                // Calculate position near the agent (offset slightly so we don't overlap)
                const offsetAngle = Math.random() * Math.PI * 2;
                const offsetDist = 2 + Math.random();
                const targetPos = new THREE.Vector3(
                    agentPos.x + Math.cos(offsetAngle) * offsetDist,
                    0,
                    agentPos.z + Math.sin(offsetAngle) * offsetDist
                );

                // Teleport player directly
                worldState.player.position.copy(targetPos);
                if (typeof snapToGround === 'function') {
                    snapToGround(worldState.player);
                }

                // Clear any navigation target
                worldState.target = null;

                // Visual feedback
                spawnFloater(agentPos, `ðŸ“ ${agent.name}`, '#0af');
                spawnFloater(worldState.player.position, 'âœ¨ Teleported!', '#fff');

                // Announce
                addCopilotMessage(`ðŸ“ Teleported to ${agent.typeConfig.icon} ${agent.name} at (${Math.floor(agentPos.x)}, ${Math.floor(agentPos.z)})`, 'ai');
            }

            // Option 2: Highlight agent on minimap
            highlightAgentOnMinimap(agent);

            // Option 3: Draw a beacon/path to agent
            createAgentBeacon(agent);
        }

        // v5.16.1: Highlight agent on minimap
        function highlightAgentOnMinimap(agent) {
            // The minimap is redrawn each frame, so we'll add a temporary highlight flag
            agent.minimapHighlight = true;
            setTimeout(() => {
                agent.minimapHighlight = false;
            }, 5000); // Highlight for 5 seconds
        }

        // v5.16.1: Create a beacon to guide player to agent
        function createAgentBeacon(agent) {
            if (!worldState.scene || !agent.mesh) return;

            // Create a vertical beam of light at agent's position
            const beaconGeom = new THREE.CylinderGeometry(0.1, 0.5, 15, 8, 1, true);
            const beaconMat = new THREE.MeshBasicMaterial({
                color: agent.typeConfig.color,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            const beacon = new THREE.Mesh(beaconGeom, beaconMat);
            beacon.position.copy(agent.mesh.position);
            beacon.position.y = 7.5;

            worldState.scene.add(beacon);

            // Animate and remove after 5 seconds
            let elapsed = 0;
            const animateBeacon = () => {
                elapsed += 16;
                if (elapsed > 5000) {
                    worldState.scene.remove(beacon);
                    return;
                }

                // Pulse effect
                const pulse = Math.sin(elapsed / 200) * 0.2 + 0.8;
                beacon.scale.set(pulse, 1, pulse);
                beaconMat.opacity = 0.3 * (1 - elapsed / 5000);

                // Follow agent if they move
                beacon.position.x = agent.mesh.position.x;
                beacon.position.z = agent.mesh.position.z;

                requestAnimationFrame(animateBeacon);
            };
            animateBeacon();
        }

        // v5.16.1: Update body cams for all expanded agent viewers
        function updateAllAgentBodyCams() {
            agentFleet.forEach(agent => {
                const viewer = document.getElementById(`transcript-viewer-${agent.id}`);
                if (viewer && viewer.classList.contains('expanded')) {
                    renderAgentBodyCam(agent);
                }
            });
        }

        // ============================================
        // v5.16.2: AGENT TAKEOVER / REMOTE CONTROL SYSTEM
        // Allows full remote control of any agent in real-time
        // ============================================

        // Takeover state
        let agentTakeoverState = {
            active: false,
            controlledAgentId: null,
            flyoutOpen: false,
            takeoverRenderer: null,
            takeoverCamera: null,
            takeoverKeys: { w: false, a: false, s: false, d: false },
            lastRenderTime: 0
        };

        // Initialize takeover renderer (higher quality for flyout)
        function initTakeoverRenderer() {
            if (agentTakeoverState.takeoverRenderer) return;

            agentTakeoverState.takeoverCamera = new THREE.PerspectiveCamera(75, 400/300, 0.1, 200);
            agentTakeoverState.takeoverRenderer = new THREE.WebGLRenderer({
                alpha: true,
                antialias: true,
                powerPreference: 'high-performance'
            });
            agentTakeoverState.takeoverRenderer.setSize(400, 300);
            agentTakeoverState.takeoverRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        }

        // Open takeover flyout for an agent
        function openAgentTakeover(agentId) {
            const agent = agentFleet.find(a => a.id === agentId);
            if (!agent || !agent.mesh) {
                addCopilotMessage('Cannot takeover - agent not found or has no physical presence.', 'ai');
                return;
            }

            // Initialize renderer if needed
            initTakeoverRenderer();

            // Set takeover state
            agentTakeoverState.active = true;
            agentTakeoverState.controlledAgentId = agentId;
            agentTakeoverState.flyoutOpen = true;

            // Pause agent's autonomous behavior
            if (agent.taskState) {
                agent.taskState.previousState = agent.taskState.state;
                agent.taskState.state = 'manual_control';
            }

            // Create flyout UI
            createTakeoverFlyout(agent);

            // Notify
            addCopilotMessage(`ðŸŽ® TAKEOVER ACTIVE: Now controlling ${agent.typeConfig.icon} ${agent.name}. Use WASD to move.`, 'ai');
            AudioSystem.play('powerup');
        }

        // Create the takeover flyout UI
        function createTakeoverFlyout(agent) {
            // Remove any existing flyout
            const existing = document.getElementById('agent-takeover-flyout');
            if (existing) existing.remove();

            const taskState = agent.taskState || {};
            const hp = taskState.hp || 50;
            const maxHp = taskState.maxHp || 50;
            const hpPercent = (hp / maxHp) * 100;
            const hpClass = hpPercent <= 25 ? 'critical' : (hpPercent <= 50 ? 'low' : '');

            const flyout = document.createElement('div');
            flyout.id = 'agent-takeover-flyout';
            flyout.className = 'agent-takeover-flyout';
            flyout.innerHTML = `
                <div class="takeover-header">
                    <div class="takeover-title">
                        <span class="agent-icon">${agent.typeConfig.icon}</span>
                        <span>REMOTE CONTROL: ${agent.name}</span>
                    </div>
                    <button class="takeover-close-btn" onclick="closeAgentTakeover()">âœ• EXIT</button>
                </div>

                <div class="takeover-viewport">
                    <canvas id="takeover-canvas" width="400" height="300"></canvas>

                    <div class="takeover-hud">
                        <div class="takeover-hud-top">
                            <div class="takeover-agent-stats">
                                <div class="takeover-hp-bar">
                                    <div class="takeover-hp-fill ${hpClass}" id="takeover-hp-fill" style="width: ${hpPercent}%"></div>
                                </div>
                                <div class="takeover-hp-text" id="takeover-hp-text">${Math.floor(hp)} / ${maxHp} HP</div>
                                <div class="takeover-agent-info">${agent.typeConfig.name}</div>
                            </div>
                            <div class="takeover-target-info ${taskState.targetObject ? '' : 'resource'}" id="takeover-target-info">
                                ${taskState.targetObject ? 'ðŸŽ¯ ' + (taskState.targetObject.name || 'Target') : 'ðŸ” No Target'}
                            </div>
                        </div>

                        <div class="takeover-crosshair"></div>

                        <div class="takeover-status-badge" id="takeover-status">${taskState.currentTask || 'MANUAL CONTROL'}</div>
                    </div>
                </div>

                <div class="takeover-controls">
                    <div class="takeover-controls-row">
                        <div class="takeover-wasd">
                            <div class="takeover-wasd-spacer"></div>
                            <div class="takeover-wasd-key" id="takeover-key-w">W</div>
                            <div class="takeover-wasd-spacer"></div>
                            <div class="takeover-wasd-key" id="takeover-key-a">A</div>
                            <div class="takeover-wasd-key" id="takeover-key-s">S</div>
                            <div class="takeover-wasd-key" id="takeover-key-d">D</div>
                        </div>
                    </div>
                    <div class="takeover-controls-row">
                        <button class="takeover-control-btn action" onclick="takeoverAgentAction()">
                            âš¡ ACTION <span class="takeover-keybind">E</span>
                        </button>
                        <button class="takeover-control-btn secondary" onclick="focusOnControlledAgent()">
                            ðŸ“ LOCATE <span class="takeover-keybind">L</span>
                        </button>
                    </div>
                    <div class="takeover-controls-row">
                        <button class="takeover-control-btn primary" onclick="toggleTakeoverAutoMode()">
                            ðŸ¤– AUTO MODE <span class="takeover-keybind">M</span>
                        </button>
                        <button class="takeover-control-btn danger" onclick="closeAgentTakeover()">
                            ðŸ”™ RETURN TO ROBOT <span class="takeover-keybind">ESC</span>
                        </button>
                    </div>
                </div>
            `;

            document.body.appendChild(flyout);

            // Add active indicator at top of screen
            const indicator = document.createElement('div');
            indicator.id = 'takeover-active-indicator';
            indicator.className = 'takeover-active-indicator';
            indicator.innerHTML = `
                <span class="pulse"></span>
                <span>ðŸŽ® CONTROLLING: ${agent.typeConfig.icon} ${agent.name}</span>
                <span style="font-size:10px;opacity:0.7">[ESC to exit]</span>
            `;
            document.body.appendChild(indicator);

            // Start rendering loop
            requestAnimationFrame(renderTakeoverView);

            // Add keyboard listener for takeover controls
            window.addEventListener('keydown', handleTakeoverKeyDown);
            window.addEventListener('keyup', handleTakeoverKeyUp);
        }

        // Handle keyboard input for takeover mode
        function handleTakeoverKeyDown(e) {
            if (!agentTakeoverState.active) return;

            const key = e.key.toLowerCase();

            // WASD movement
            if (key === 'w') { agentTakeoverState.takeoverKeys.w = true; e.preventDefault(); }
            if (key === 'a') { agentTakeoverState.takeoverKeys.a = true; e.preventDefault(); }
            if (key === 's') { agentTakeoverState.takeoverKeys.s = true; e.preventDefault(); }
            if (key === 'd') { agentTakeoverState.takeoverKeys.d = true; e.preventDefault(); }

            // Update WASD indicator UI
            updateTakeoverWASDUI();

            // Action key
            if (key === 'e') {
                takeoverAgentAction();
                e.preventDefault();
            }

            // Locate key
            if (key === 'l') {
                focusOnControlledAgent();
                e.preventDefault();
            }

            // Auto mode toggle
            if (key === 'm') {
                toggleTakeoverAutoMode();
                e.preventDefault();
            }

            // Escape to exit
            if (key === 'escape') {
                closeAgentTakeover();
                e.preventDefault();
            }
        }

        // Handle keyboard release for takeover mode
        function handleTakeoverKeyUp(e) {
            if (!agentTakeoverState.active) return;

            const key = e.key.toLowerCase();

            if (key === 'w') agentTakeoverState.takeoverKeys.w = false;
            if (key === 'a') agentTakeoverState.takeoverKeys.a = false;
            if (key === 's') agentTakeoverState.takeoverKeys.s = false;
            if (key === 'd') agentTakeoverState.takeoverKeys.d = false;

            updateTakeoverWASDUI();
        }

        // Update WASD visual indicator
        function updateTakeoverWASDUI() {
            const keys = agentTakeoverState.takeoverKeys;
            const wKey = document.getElementById('takeover-key-w');
            const aKey = document.getElementById('takeover-key-a');
            const sKey = document.getElementById('takeover-key-s');
            const dKey = document.getElementById('takeover-key-d');

            if (wKey) wKey.classList.toggle('active', keys.w);
            if (aKey) aKey.classList.toggle('active', keys.a);
            if (sKey) sKey.classList.toggle('active', keys.s);
            if (dKey) dKey.classList.toggle('active', keys.d);
        }

        // Render the takeover POV view
        function renderTakeoverView() {
            if (!agentTakeoverState.active || !agentTakeoverState.flyoutOpen) return;

            const agent = agentFleet.find(a => a.id === agentTakeoverState.controlledAgentId);
            if (!agent || !agent.mesh || !worldState.scene) {
                closeAgentTakeover();
                return;
            }

            const now = performance.now();
            const deltaTime = (now - agentTakeoverState.lastRenderTime) / 1000;
            agentTakeoverState.lastRenderTime = now;

            // Process movement input
            processAgentTakeoverMovement(agent, deltaTime);

            // Update HUD
            updateTakeoverHUD(agent);

            // Position camera at agent's POV
            const agentPos = agent.mesh.position;
            const agentRotation = agent.mesh.rotation.y;

            // First-person camera position
            const cameraOffset = new THREE.Vector3(
                Math.sin(agentRotation) * 0.3,
                1.5, // Eye level
                Math.cos(agentRotation) * 0.3
            );
            agentTakeoverState.takeoverCamera.position.copy(agentPos).add(cameraOffset);

            // Look in the direction the agent is facing
            const lookTarget = new THREE.Vector3(
                agentPos.x + Math.sin(agentRotation) * 10,
                agentPos.y + 1.2,
                agentPos.z + Math.cos(agentRotation) * 10
            );
            agentTakeoverState.takeoverCamera.lookAt(lookTarget);

            // Render to canvas
            const canvas = document.getElementById('takeover-canvas');
            if (canvas && agentTakeoverState.takeoverRenderer) {
                // Update renderer size to match canvas
                const rect = canvas.parentElement.getBoundingClientRect();
                const width = Math.floor(rect.width);
                const height = Math.floor(rect.height);

                if (width > 0 && height > 0) {
                    agentTakeoverState.takeoverCamera.aspect = width / height;
                    agentTakeoverState.takeoverCamera.updateProjectionMatrix();
                    agentTakeoverState.takeoverRenderer.setSize(width, height);
                }

                agentTakeoverState.takeoverRenderer.render(worldState.scene, agentTakeoverState.takeoverCamera);

                // Copy to visible canvas
                const ctx = canvas.getContext('2d');
                if (ctx) {
                    canvas.width = width;
                    canvas.height = height;
                    ctx.drawImage(agentTakeoverState.takeoverRenderer.domElement, 0, 0);

                    // Add scan line overlay for visual effect
                    ctx.strokeStyle = 'rgba(255, 136, 0, 0.02)';
                    for (let y = 0; y < height; y += 4) {
                        ctx.beginPath();
                        ctx.moveTo(0, y);
                        ctx.lineTo(width, y);
                        ctx.stroke();
                    }
                }
            }

            // Continue render loop
            requestAnimationFrame(renderTakeoverView);
        }

        // Process movement input for controlled agent
        function processAgentTakeoverMovement(agent, deltaTime) {
            const keys = agentTakeoverState.takeoverKeys;
            const hasInput = keys.w || keys.a || keys.s || keys.d;

            if (!hasInput) return;

            const speed = 8 * deltaTime; // Agent movement speed
            const moveDir = new THREE.Vector3(0, 0, 0);

            // Calculate movement relative to agent's facing direction
            const agentRotation = agent.mesh.rotation.y;

            if (keys.w) {
                moveDir.x += Math.sin(agentRotation) * speed;
                moveDir.z += Math.cos(agentRotation) * speed;
            }
            if (keys.s) {
                moveDir.x -= Math.sin(agentRotation) * speed;
                moveDir.z -= Math.cos(agentRotation) * speed;
            }
            if (keys.a) {
                moveDir.x += Math.cos(agentRotation) * speed;
                moveDir.z -= Math.sin(agentRotation) * speed;
            }
            if (keys.d) {
                moveDir.x -= Math.cos(agentRotation) * speed;
                moveDir.z += Math.sin(agentRotation) * speed;
            }

            // Apply movement
            agent.mesh.position.add(moveDir);

            // Update facing direction based on movement
            if (moveDir.length() > 0.01) {
                const newRotation = Math.atan2(moveDir.x, moveDir.z);
                agent.mesh.rotation.y = newRotation;
            }

            // Snap to ground
            if (typeof snapToGround === 'function') {
                snapToGround(agent.mesh);
            }

            // Update task state position tracking
            if (agent.taskState) {
                agent.taskState.lastPosition = agent.mesh.position.clone();
            }
        }

        // Update takeover HUD elements
        function updateTakeoverHUD(agent) {
            const taskState = agent.taskState || {};
            const hp = taskState.hp || 50;
            const maxHp = taskState.maxHp || 50;
            const hpPercent = (hp / maxHp) * 100;

            // Update HP bar
            const hpFill = document.getElementById('takeover-hp-fill');
            const hpText = document.getElementById('takeover-hp-text');
            if (hpFill) {
                hpFill.style.width = hpPercent + '%';
                hpFill.className = 'takeover-hp-fill' + (hpPercent <= 25 ? ' critical' : (hpPercent <= 50 ? ' low' : ''));
            }
            if (hpText) {
                hpText.textContent = `${Math.floor(hp)} / ${maxHp} HP`;
            }

            // Update target info
            const targetInfo = document.getElementById('takeover-target-info');
            if (targetInfo) {
                if (taskState.targetObject) {
                    targetInfo.textContent = 'ðŸŽ¯ ' + (taskState.targetObject.name || taskState.targetObject.type || 'Target');
                    targetInfo.className = 'takeover-target-info';
                } else {
                    targetInfo.textContent = 'ðŸ” No Target';
                    targetInfo.className = 'takeover-target-info resource';
                }
            }

            // Update status badge
            const statusBadge = document.getElementById('takeover-status');
            if (statusBadge) {
                statusBadge.textContent = taskState.state === 'manual_control' ? 'MANUAL CONTROL' : (taskState.currentTask || taskState.state || 'ACTIVE').toUpperCase();
            }
        }

        // Perform agent action (interact with nearby objects)
        function takeoverAgentAction() {
            const agent = agentFleet.find(a => a.id === agentTakeoverState.controlledAgentId);
            if (!agent || !agent.mesh) return;

            const agentPos = agent.mesh.position;

            // Find nearest interactable object
            let nearestDist = Infinity;
            let nearestObject = null;

            // Check resources
            if (worldState.resources) {
                worldState.resources.forEach(resource => {
                    if (!resource.position) return;
                    const dist = agentPos.distanceTo(resource.position);
                    if (dist < 3 && dist < nearestDist) {
                        nearestDist = dist;
                        nearestObject = resource;
                    }
                });
            }

            // Check mobs
            if (worldState.mobs) {
                worldState.mobs.forEach(mob => {
                    if (!mob.mesh || mob.isDead) return;
                    const dist = agentPos.distanceTo(mob.mesh.position);
                    if (dist < 3 && dist < nearestDist) {
                        nearestDist = dist;
                        nearestObject = { type: 'mob', mob: mob };
                    }
                });
            }

            if (nearestObject) {
                if (nearestObject.type === 'mob') {
                    // Attack mob
                    const mob = nearestObject.mob;
                    const damage = 15 + Math.random() * 10;
                    mob.hp -= damage;
                    spawnFloater(mob.mesh.position, `-${Math.floor(damage)}`, '#f44');
                    AudioSystem.play('hit');

                    if (mob.hp <= 0) {
                        mob.isDead = true;
                        addCopilotMessage(`${agent.typeConfig.icon} ${agent.name} defeated ${mob.type}!`, 'ai');
                    }
                } else {
                    // Harvest resource
                    if (typeof performAgentAction === 'function') {
                        performAgentAction(agent, nearestObject);
                    } else {
                        spawnFloater(agentPos, '+1 Resource', '#0f0');
                    }
                    AudioSystem.play('collect');
                }
            } else {
                spawnFloater(agentPos, 'Nothing nearby', '#888');
            }
        }

        // Focus main camera on the controlled agent
        function focusOnControlledAgent() {
            if (!agentTakeoverState.controlledAgentId) return;
            focusOnAgent(agentTakeoverState.controlledAgentId);
        }

        // Toggle auto mode (return agent to autonomous behavior)
        function toggleTakeoverAutoMode() {
            const agent = agentFleet.find(a => a.id === agentTakeoverState.controlledAgentId);
            if (!agent) return;

            if (agent.taskState && agent.taskState.state === 'manual_control') {
                // Switch to auto mode
                agent.taskState.state = agent.taskState.previousState || 'idle';
                const statusBadge = document.getElementById('takeover-status');
                if (statusBadge) statusBadge.textContent = 'AUTO MODE';
                addCopilotMessage(`${agent.typeConfig.icon} ${agent.name} switched to AUTO MODE - watching only`, 'ai');
            } else if (agent.taskState) {
                // Switch back to manual
                agent.taskState.previousState = agent.taskState.state;
                agent.taskState.state = 'manual_control';
                const statusBadge = document.getElementById('takeover-status');
                if (statusBadge) statusBadge.textContent = 'MANUAL CONTROL';
                addCopilotMessage(`${agent.typeConfig.icon} ${agent.name} switched to MANUAL CONTROL`, 'ai');
            }
        }

        // Close takeover and return to robot
        function closeAgentTakeover() {
            const agent = agentFleet.find(a => a.id === agentTakeoverState.controlledAgentId);

            // Restore agent's autonomous state
            if (agent && agent.taskState) {
                if (agent.taskState.state === 'manual_control') {
                    agent.taskState.state = agent.taskState.previousState || 'idle';
                }
            }

            // Reset takeover state
            agentTakeoverState.active = false;
            agentTakeoverState.controlledAgentId = null;
            agentTakeoverState.flyoutOpen = false;
            agentTakeoverState.takeoverKeys = { w: false, a: false, s: false, d: false };

            // Remove UI elements
            const flyout = document.getElementById('agent-takeover-flyout');
            if (flyout) flyout.remove();

            const indicator = document.getElementById('takeover-active-indicator');
            if (indicator) indicator.remove();

            // Remove keyboard listeners
            window.removeEventListener('keydown', handleTakeoverKeyDown);
            window.removeEventListener('keyup', handleTakeoverKeyUp);

            // Notify
            if (agent) {
                addCopilotMessage(`ðŸ”™ Returned control to main robot. ${agent.typeConfig.icon} ${agent.name} resuming autonomous operations.`, 'ai');
            }
            AudioSystem.play('ui');
        }

        // Check if any agent is being controlled (for game loop)
        function isAgentTakeoverActive() {
            return agentTakeoverState.active && agentTakeoverState.controlledAgentId !== null;
        }

        // v5.17.1: Pop-out Agent Control Window System
        // Allows controlling agents in separate windows without interrupting main game
        const agentPopOutWindows = new Map(); // agentId -> window reference

        function popOutAgentWindow(agentId) {
            const agent = agentFleet.find(a => a.id === agentId);
            if (!agent || !agent.mesh) {
                addCopilotMessage('Cannot open pop-out - agent not found or has no physical presence.', 'ai');
                return;
            }

            // Check if window already exists
            if (agentPopOutWindows.has(agentId)) {
                const existingWindow = agentPopOutWindows.get(agentId);
                if (existingWindow && !existingWindow.closed) {
                    existingWindow.focus();
                    return;
                }
            }

            // Create the pop-out window
            const windowWidth = 500;
            const windowHeight = 450;
            const left = window.screenX + 50 + (agentPopOutWindows.size * 30);
            const top = window.screenY + 50 + (agentPopOutWindows.size * 30);

            const popOutWindow = window.open('', `agent_${agentId}`,
                `width=${windowWidth},height=${windowHeight},left=${left},top=${top},resizable=yes`
            );

            if (!popOutWindow) {
                addCopilotMessage('Pop-up blocked! Please allow pop-ups for this site.', 'ai');
                return;
            }

            agentPopOutWindows.set(agentId, popOutWindow);

            // Get the HTML components from generateAgentPopOutHTML
            const htmlParts = generateAgentPopOutHTML(agent);

            // Build complete HTML document using blob URL approach to avoid script tag parsing issues
            // Use unicode escape for the script tag to avoid HTML parser issues
            const htmlContent = '<!DOCTYPE html>\n<html lang="en">\n<head>\n' +
                '<meta charset="UTF-8">\n' +
                '<meta name="viewport" content="width=device-width, initial-scale=1.0">\n' +
                '<title>' + htmlParts.title + '<\/title>\n' +
                '<style>\n' + htmlParts.css + '\n<\/style>\n' +
                '<\/head>\n<body>\n' +
                htmlParts.body + '\n' +
                '<scr' + 'ipt>\n' + htmlParts.js + '\n<\/scr' + 'ipt>\n' +
                '<\/body>\n<\/html>';

            // Create blob URL and navigate to it
            const blob = new Blob([htmlContent], { type: 'text/html' });
            const blobUrl = URL.createObjectURL(blob);
            popOutWindow.location.href = blobUrl;

            // Set up communication bridge after a small delay to ensure page loads
            setTimeout(() => {
                if (popOutWindow && !popOutWindow.closed) {
                    popOutWindow.agentId = agentId;
                    popOutWindow.parentGame = window;
                }
            }, 100);

            // Handle window close and cleanup blob URL
            const checkClosed = setInterval(() => {
                if (popOutWindow.closed) {
                    clearInterval(checkClosed);
                    agentPopOutWindows.delete(agentId);
                    URL.revokeObjectURL(blobUrl);
                }
            }, 1000);

            addCopilotMessage(`ðŸªŸ ${agent.typeConfig.icon} ${agent.name} control window opened! Main game continues independently.`, 'ai');
            AudioSystem.play('ui');
        }

        function generateAgentPopOutHTML(agent) {
            const colorHex = '#' + agent.typeConfig.color.toString(16).padStart(6, '0');
            const taskState = agent.taskState || {};
            const hp = taskState.hp || 50;
            const maxHp = taskState.maxHp || 50;
            const hpPercent = (hp / maxHp) * 100;

            // Build CSS
            const css = `
                * { margin: 0; padding: 0; box-sizing: border-box; }
                body { font-family: 'Consolas', 'Monaco', monospace; background: #0a0a0f; color: #fff; overflow: hidden; user-select: none; }
                .header { background: linear-gradient(135deg, #1a1a2e 0%, #0d0d15 100%); border-bottom: 1px solid ${colorHex}44; padding: 8px 12px; display: flex; justify-content: space-between; align-items: center; }
                .agent-title { display: flex; align-items: center; gap: 8px; }
                .agent-icon { font-size: 24px; }
                .agent-name { font-size: 14px; font-weight: bold; color: ${colorHex}; }
                .agent-type { font-size: 11px; color: #888; }
                .status-badge { background: ${colorHex}33; border: 1px solid ${colorHex}; color: ${colorHex}; padding: 3px 8px; border-radius: 4px; font-size: 10px; text-transform: uppercase; }
                .viewport { position: relative; width: 100%; height: 280px; background: #000; border-bottom: 1px solid #333; }
                #agent-canvas { width: 100%; height: 100%; display: block; }
                .hud-overlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; pointer-events: none; }
                .hud-top { position: absolute; top: 8px; left: 8px; right: 8px; display: flex; justify-content: space-between; }
                .hp-container { background: rgba(0,0,0,0.7); padding: 6px 10px; border-radius: 4px; border: 1px solid #333; }
                .hp-bar { width: 120px; height: 8px; background: #222; border-radius: 4px; overflow: hidden; margin-bottom: 4px; }
                .hp-fill { height: 100%; background: linear-gradient(90deg, #f44 0%, #ff8800 50%, #4f4 100%); transition: width 0.3s; }
                .hp-fill.critical { background: #f44; animation: critical-pulse 0.5s infinite; }
                @keyframes critical-pulse { 0%,100%{opacity:1} 50%{opacity:0.5} }
                .hp-text { font-size: 10px; color: #aaa; }
                .stats-container { background: rgba(0,0,0,0.7); padding: 6px 10px; border-radius: 4px; border: 1px solid #333; text-align: right; }
                .stat-row { font-size: 10px; color: #aaa; margin: 2px 0; }
                .stat-value { color: ${colorHex}; font-weight: bold; }
                .stat-combo { color: #ff8800; }
                .hud-bottom { position: absolute; bottom: 8px; left: 8px; right: 8px; display: flex; justify-content: space-between; align-items: flex-end; }
                .coords { font-size: 10px; color: #0ff; font-family: monospace; }
                .action-text { font-size: 11px; color: #fff; }
                .controls { background: linear-gradient(180deg, #0d0d15 0%, #1a1a2e 100%); padding: 12px; display: flex; flex-direction: column; gap: 10px; }
                .control-row { display: flex; justify-content: center; gap: 8px; }
                .wasd-container { display: grid; grid-template-columns: repeat(3, 40px); grid-template-rows: repeat(2, 40px); gap: 4px; }
                .wasd-key { width: 40px; height: 40px; background: #222; border: 1px solid #444; border-radius: 6px; display: flex; align-items: center; justify-content: center; font-size: 14px; font-weight: bold; color: #888; transition: all 0.1s; }
                .wasd-key.active { background: ${colorHex}44; border-color: ${colorHex}; color: ${colorHex}; box-shadow: 0 0 10px ${colorHex}66; }
                .action-btn { flex: 1; padding: 12px; background: #222; border: 1px solid #444; border-radius: 6px; color: #fff; font-size: 12px; font-weight: bold; cursor: pointer; transition: all 0.2s; display: flex; align-items: center; justify-content: center; gap: 6px; }
                .action-btn:hover { background: #333; border-color: #666; }
                .action-btn:active { transform: scale(0.97); }
                .action-btn.primary { border-color: ${colorHex}; color: ${colorHex}; }
                .action-btn.primary:hover { background: ${colorHex}22; }
                .keybind { font-size: 9px; color: #666; margin-left: 4px; }
                .mode-toggle { display: flex; align-items: center; gap: 8px; font-size: 11px; color: #888; }
                .mode-switch { width: 40px; height: 20px; background: #333; border-radius: 10px; position: relative; cursor: pointer; }
                .mode-switch::after { content: ''; position: absolute; width: 16px; height: 16px; background: #666; border-radius: 50%; top: 2px; left: 2px; transition: all 0.2s; }
                .mode-switch.auto::after { left: 22px; background: ${colorHex}; }
                .mode-switch.auto { background: ${colorHex}44; }
            `;

            // Build HTML body
            const body = `
                <div class="header">
                    <div class="agent-title">
                        <span class="agent-icon">${agent.typeConfig.icon}</span>
                        <div>
                            <div class="agent-name">${agent.name}</div>
                            <div class="agent-type">${agent.typeConfig.name}</div>
                        </div>
                    </div>
                    <div class="status-badge" id="status-badge">AUTONOMOUS</div>
                </div>
                <div class="viewport">
                    <canvas id="agent-canvas"></canvas>
                    <div class="hud-overlay">
                        <div class="hud-top">
                            <div class="hp-container">
                                <div class="hp-bar"><div class="hp-fill" id="hp-fill" style="width: ${hpPercent}%"></div></div>
                                <div class="hp-text" id="hp-text">${Math.floor(hp)} / ${maxHp} HP</div>
                            </div>
                            <div class="stats-container">
                                <div class="stat-row">Level: <span class="stat-value" id="stat-level">${agent.agentLevel}</span></div>
                                <div class="stat-row">Combo: <span class="stat-combo" id="stat-combo">${agent.combo}x</span></div>
                                <div class="stat-row">Efficiency: <span class="stat-value" id="stat-eff">${Math.round(agent.efficiency * 100)}%</span></div>
                            </div>
                        </div>
                        <div class="hud-bottom">
                            <div class="coords" id="coords">X: 0 Z: 0</div>
                            <div class="action-text" id="action-text">${agent.statusMessage || 'Working...'}</div>
                        </div>
                    </div>
                </div>
                <div class="controls">
                    <div class="control-row">
                        <div class="wasd-container">
                            <div></div><div class="wasd-key" id="key-w">W</div><div></div>
                            <div class="wasd-key" id="key-a">A</div><div class="wasd-key" id="key-s">S</div><div class="wasd-key" id="key-d">D</div>
                        </div>
                    </div>
                    <div class="control-row">
                        <button class="action-btn primary" id="action-btn">âš¡ ACTION <span class="keybind">E</span></button>
                        <button class="action-btn" id="locate-btn">ðŸ“ LOCATE <span class="keybind">L</span></button>
                    </div>
                    <div class="control-row">
                        <div class="mode-toggle">
                            <span>Manual</span>
                            <div class="mode-switch auto" id="mode-switch"></div>
                            <span>Auto</span>
                        </div>
                    </div>
                </div>
            `;

            // Build JS - using array join to avoid script tag issues
            const js = [
                'const agentId = "' + agent.id + '";',
                'let keys = { w: false, a: false, s: false, d: false };',
                'let isAutoMode = true;',
                'let canvas, ctx;',
                'let updateInterval;',
                '',
                'window.onload = function() {',
                '    canvas = document.getElementById("agent-canvas");',
                '    ctx = canvas.getContext("2d");',
                '    resizeCanvas();',
                '    window.onresize = resizeCanvas;',
                '    updateInterval = setInterval(updateView, 50);',
                '    document.addEventListener("keydown", handleKeyDown);',
                '    document.addEventListener("keyup", handleKeyUp);',
                '    document.getElementById("action-btn").onclick = performAction;',
                '    document.getElementById("locate-btn").onclick = locateAgent;',
                '    document.getElementById("mode-switch").onclick = toggleMode;',
                '};',
                '',
                'function resizeCanvas() {',
                '    const viewport = canvas.parentElement;',
                '    canvas.width = viewport.clientWidth;',
                '    canvas.height = viewport.clientHeight;',
                '}',
                '',
                'function updateView() {',
                '    if (!window.opener || window.opener.closed) {',
                '        clearInterval(updateInterval);',
                '        document.body.innerHTML = "<div style=\\"padding:40px;text-align:center;color:#f44;\\">Main game window closed</div>";',
                '        return;',
                '    }',
                '    try {',
                '        const parent = window.opener;',
                '        const agent = parent.agentFleet && parent.agentFleet.find(function(a) { return a.id === agentId; });',
                '        if (!agent) {',
                '            ctx.fillStyle = "#111";',
                '            ctx.fillRect(0, 0, canvas.width, canvas.height);',
                '            ctx.fillStyle = "#f44";',
                '            ctx.font = "14px monospace";',
                '            ctx.fillText("Agent recalled", canvas.width/2 - 50, canvas.height/2);',
                '            return;',
                '        }',
                '        if (parent.renderPopOutAgentView) {',
                '            parent.renderPopOutAgentView(agentId, canvas);',
                '        }',
                '        updateHUD(agent);',
                '        if (!isAutoMode && (keys.w || keys.a || keys.s || keys.d)) {',
                '            moveAgent(agent);',
                '        }',
                '    } catch (e) { console.error("Update error:", e); }',
                '}',
                '',
                'function updateHUD(agent) {',
                '    var taskState = agent.taskState || {};',
                '    var hp = taskState.hp || 50;',
                '    var maxHp = taskState.maxHp || 50;',
                '    var hpPercent = (hp / maxHp) * 100;',
                '    document.getElementById("hp-fill").style.width = hpPercent + "%";',
                '    document.getElementById("hp-fill").className = "hp-fill" + (hpPercent <= 25 ? " critical" : "");',
                '    document.getElementById("hp-text").textContent = Math.floor(hp) + " / " + maxHp + " HP";',
                '    document.getElementById("stat-level").textContent = agent.agentLevel;',
                '    document.getElementById("stat-combo").textContent = agent.combo + "x";',
                '    document.getElementById("stat-eff").textContent = Math.round(agent.efficiency * 100) + "%";',
                '    if (agent.mesh) {',
                '        var pos = agent.mesh.position;',
                '        document.getElementById("coords").textContent = "X: " + Math.floor(pos.x) + " Z: " + Math.floor(pos.z);',
                '    }',
                '    document.getElementById("action-text").textContent = agent.statusMessage || "Working...";',
                '    document.getElementById("status-badge").textContent = isAutoMode ? "AUTONOMOUS" : "MANUAL CONTROL";',
                '}',
                '',
                'function moveAgent(agent) {',
                '    if (!agent.mesh || !window.opener) return;',
                '    var speed = 0.15;',
                '    var rotation = agent.mesh.rotation.y;',
                '    var dx = 0, dz = 0;',
                '    if (keys.w) { dx += Math.sin(rotation); dz += Math.cos(rotation); }',
                '    if (keys.s) { dx -= Math.sin(rotation); dz -= Math.cos(rotation); }',
                '    if (keys.a) { dx += Math.cos(rotation); dz -= Math.sin(rotation); }',
                '    if (keys.d) { dx -= Math.cos(rotation); dz += Math.sin(rotation); }',
                '    if (dx !== 0 || dz !== 0) {',
                '        var len = Math.sqrt(dx*dx + dz*dz);',
                '        dx = (dx / len) * speed;',
                '        dz = (dz / len) * speed;',
                '        agent.mesh.position.x += dx;',
                '        agent.mesh.position.z += dz;',
                '        agent.position.copy(agent.mesh.position);',
                '        agent.mesh.rotation.y = Math.atan2(dx, dz);',
                '    }',
                '}',
                '',
                'function handleKeyDown(e) {',
                '    var key = e.key.toLowerCase();',
                '    if (["w","a","s","d"].indexOf(key) >= 0) {',
                '        keys[key] = true;',
                '        document.getElementById("key-" + key).classList.add("active");',
                '        if (isAutoMode) {',
                '            isAutoMode = false;',
                '            setAgentManualMode(true);',
                '            document.getElementById("mode-switch").classList.remove("auto");',
                '        }',
                '        e.preventDefault();',
                '    } else if (key === "e") { performAction(); }',
                '    else if (key === "l") { locateAgent(); }',
                '    else if (key === "m") { toggleMode(); }',
                '}',
                '',
                'function handleKeyUp(e) {',
                '    var key = e.key.toLowerCase();',
                '    if (["w","a","s","d"].indexOf(key) >= 0) {',
                '        keys[key] = false;',
                '        document.getElementById("key-" + key).classList.remove("active");',
                '    }',
                '}',
                '',
                'function toggleMode() {',
                '    isAutoMode = !isAutoMode;',
                '    document.getElementById("mode-switch").classList.toggle("auto", isAutoMode);',
                '    setAgentManualMode(!isAutoMode);',
                '}',
                '',
                'function setAgentManualMode(isManual) {',
                '    try {',
                '        var parent = window.opener;',
                '        var agent = parent.agentFleet && parent.agentFleet.find(function(a) { return a.id === agentId; });',
                '        if (agent && agent.taskState) {',
                '            if (isManual) {',
                '                agent.taskState.previousState = agent.taskState.state;',
                '                agent.taskState.state = "manual_control";',
                '            } else {',
                '                agent.taskState.state = agent.taskState.previousState || "idle";',
                '            }',
                '        }',
                '    } catch (e) {}',
                '}',
                '',
                'function performAction() {',
                '    try {',
                '        var parent = window.opener;',
                '        if (parent.popOutAgentAction) { parent.popOutAgentAction(agentId); }',
                '    } catch (e) {}',
                '}',
                '',
                'function locateAgent() {',
                '    try {',
                '        var parent = window.opener;',
                '        if (parent.focusOnAgent) { parent.focusOnAgent(agentId); }',
                '    } catch (e) {}',
                '}',
                '',
                'window.onbeforeunload = function() {',
                '    clearInterval(updateInterval);',
                '    setAgentManualMode(false);',
                '};'
            ].join('\n');

            return { css, body, js, title: agent.typeConfig.icon + ' ' + agent.name + ' - Agent Control' };
        }

        // Render function called by pop-out windows to get agent view
        function renderPopOutAgentView(agentId, targetCanvas) {
            const agent = agentFleet.find(a => a.id === agentId);
            if (!agent || !agent.mesh || !worldState.scene) return;

            const ctx = targetCanvas.getContext('2d');

            // Use the existing body cam renderer
            if (!bodyCamInitialized) initAgentBodyCamSystem();
            if (!agentBodyCamRenderer || !agentBodyCamCamera) {
                ctx.fillStyle = '#111';
                ctx.fillRect(0, 0, targetCanvas.width, targetCanvas.height);
                return;
            }

            try {
                // Position camera at agent's POV
                const agentPos = agent.mesh.position;
                const agentRotation = agent.mesh.rotation.y || 0;

                agentBodyCamCamera.position.set(
                    agentPos.x + Math.sin(agentRotation) * 0.3,
                    agentPos.y + 1.5,
                    agentPos.z + Math.cos(agentRotation) * 0.3
                );

                const lookTarget = new THREE.Vector3(
                    agentPos.x + Math.sin(agentRotation) * 10,
                    agentPos.y + 1.0,
                    agentPos.z + Math.cos(agentRotation) * 10
                );
                agentBodyCamCamera.lookAt(lookTarget);

                // Adjust renderer for pop-out size
                const origWidth = agentBodyCamRenderer.domElement.width;
                const origHeight = agentBodyCamRenderer.domElement.height;
                agentBodyCamRenderer.setSize(targetCanvas.width, targetCanvas.height);

                agentBodyCamRenderer.render(worldState.scene, agentBodyCamCamera);

                // Copy to target canvas
                ctx.drawImage(agentBodyCamRenderer.domElement, 0, 0);

                // Reset renderer size
                agentBodyCamRenderer.setSize(origWidth, origHeight);
            } catch (e) {
                ctx.fillStyle = '#111';
                ctx.fillRect(0, 0, targetCanvas.width, targetCanvas.height);
            }
        }

        // Action function called by pop-out windows
        function popOutAgentAction(agentId) {
            const agent = agentFleet.find(a => a.id === agentId);
            if (!agent || !agent.mesh) return;

            const agentPos = agent.mesh.position;
            let nearestDist = Infinity;
            let nearestObject = null;

            // Check resources
            worldState.interactables?.forEach(obj => {
                if (!obj.parent) return;
                const dist = agentPos.distanceTo(obj.position);
                if (dist < 3 && dist < nearestDist) {
                    nearestDist = dist;
                    nearestObject = { type: 'resource', obj: obj };
                }
            });

            // Check mobs
            worldState.mobs?.forEach(mob => {
                if (!mob.mesh || mob.isDead) return;
                const dist = agentPos.distanceTo(mob.mesh.position);
                if (dist < 3 && dist < nearestDist) {
                    nearestDist = dist;
                    nearestObject = { type: 'mob', mob: mob };
                }
            });

            if (nearestObject) {
                if (nearestObject.type === 'mob') {
                    const damage = 15 + agent.agentLevel * 2;
                    nearestObject.mob.hp -= damage;
                    spawnFloater(nearestObject.mob.mesh.position, '-' + Math.floor(damage), '#f44');
                    trackAgentAction(agent, true, 8);
                    if (nearestObject.mob.hp <= 0) {
                        nearestObject.mob.isDead = true;
                    }
                } else {
                    performAgentAction(agent, nearestObject.obj);
                }
                AudioSystem.play('hit');
            }
        }

        // v5.16: Update all agent meshes and run autonomous task behaviors
        // v5.16.3: Fixed - create mesh if agent was spawned before scene was ready
        function updateAgentFleetMeshes(deltaTime) {
            const now = performance.now();

            agentFleet.forEach(agent => {
                // v5.16.3: If agent has no mesh but scene is now ready, create it
                if (!agent.mesh && worldState.scene) {
                    createAgentMesh(agent);
                    if (agent.mesh) {
                        logAgentTask(agent, 'Spawned into world');
                        agent.statusMessage = 'Ready for duty!';
                        updateAgentCardUI(agent);
                    }
                }
                if (!agent.mesh) return;
                if (!agent.taskState) {
                    // Initialize task state if missing (for older agents)
                    agent.taskState = {
                        currentTask: null, targetObject: null, targetPosition: null,
                        state: 'idle', stuckCounter: 0, lastPosition: null, lastTaskTime: 0,
                        alert: null, actionCooldown: 0, hp: 50, maxHp: 50, taskLog: []
                    };
                }

                const task = agent.taskState;
                const time = now / 1000;

                // Visual animations
                updateAgentVisuals(agent, deltaTime, time);

                // Run autonomous task behavior (every 100ms for performance)
                if (now - task.lastTaskTime > 100) {
                    task.lastTaskTime = now;
                    runAgentAutonomousTask(agent, deltaTime);
                }

                // v5.17: Agent health regeneration
                updateAgentHealthRegen(agent);

                // Check if stuck
                if (task.lastPosition) {
                    const moved = agent.mesh.position.distanceTo(task.lastPosition);
                    if (moved < 0.01 && task.state === 'moving') {
                        task.stuckCounter++;
                        if (task.stuckCounter > 50) {
                            logAgentTask(agent, 'Got stuck, picking new target');
                            task.targetObject = null;
                            task.targetPosition = null;
                            task.state = 'idle';
                            task.stuckCounter = 0;
                        }
                    } else {
                        task.stuckCounter = 0;
                    }
                }
                task.lastPosition = agent.mesh.position.clone();
            });
        }

        // v5.16: Update agent visual animations
        function updateAgentVisuals(agent, deltaTime, time) {
            // Idle bobbing (subtle)
            const bobOffset = Math.sin(time * 2 + agent.id.charCodeAt(0)) * 0.05;
            agent.mesh.position.y = bobOffset;

            // Glow pulse
            if (agent.glow) {
                agent.glow.material.opacity = 0.08 + Math.sin(time * 3) * 0.04;
            }

            // Visor blink
            if (agent.visor && Math.random() < 0.002) {
                agent.visor.material.emissiveIntensity = 0.2;
                setTimeout(() => {
                    if (agent.visor) agent.visor.material.emissiveIntensity = 0.8;
                }, 100);
            }

            // Alert indicator pulsing
            if (agent.alertIndicator && agent.taskState.alert) {
                agent.alertIndicator.material.opacity = 0.5 + Math.sin(time * 6) * 0.5;
                agent.alertIndicator.scale.setScalar(1 + Math.sin(time * 6) * 0.3);
            } else if (agent.alertIndicator) {
                agent.alertIndicator.material.opacity = 0;
            }

            // Tool animation when working
            if (agent.tool && agent.taskState.state === 'working') {
                agent.tool.rotation.x = Math.sin(time * 8) * 0.3;
            }

            // Face movement direction
            if (agent.taskState.targetPosition) {
                const dir = new THREE.Vector3().subVectors(agent.taskState.targetPosition, agent.mesh.position);
                if (dir.length() > 0.5) {
                    const targetAngle = Math.atan2(dir.x, dir.z);
                    agent.mesh.rotation.y = THREE.MathUtils.lerp(agent.mesh.rotation.y, targetAngle, deltaTime * 5);
                }
            }
        }

        // v5.16: Run autonomous task behavior for an agent
        function runAgentAutonomousTask(agent, deltaTime) {
            const task = agent.taskState;
            const agentPos = agent.mesh.position;

            // Don't run tasks if alerted (waiting for player)
            if (task.alert && task.state === 'alert') {
                return;
            }

            // Decrement action cooldown
            if (task.actionCooldown > 0) {
                task.actionCooldown -= 100;
                return;
            }

            // Task behavior based on agent type
            switch (agent.type) {
                case 'gatherer':
                case 'miner':
                    runGathererTask(agent);
                    break;
                case 'hunter':
                case 'protector':
                    runHunterTask(agent);
                    break;
                case 'scout':
                case 'explorer':
                    runScoutTask(agent);
                    break;
                case 'healer':
                    runHealerTask(agent);
                    break;
                case 'fisher':
                    runFisherTask(agent);
                    break;
                default:
                    runGathererTask(agent); // Default behavior
            }

            // Move towards target if we have one
            if (task.targetPosition && task.state === 'moving') {
                moveAgentTowards(agent, task.targetPosition, deltaTime);
            }
        }

        // v5.16: Gatherer/Miner task - find and harvest resources
        function runGathererTask(agent) {
            const task = agent.taskState;
            const agentPos = agent.mesh.position;
            const isMiner = agent.type === 'miner';

            // If we have a target, check if we're close enough to interact
            if (task.targetObject && task.targetObject.parent) {
                const dist = agentPos.distanceTo(task.targetObject.position);
                if (dist < 2) {
                    // Close enough to interact
                    task.state = 'working';
                    performAgentAction(agent, task.targetObject);
                    return;
                } else {
                    // Move towards target
                    task.state = 'moving';
                    task.targetPosition = task.targetObject.position.clone();
                    return;
                }
            }

            // Find a new resource target
            let bestTarget = null;
            let bestDist = 30; // Max search range

            worldState.interactables.forEach(obj => {
                if (!obj.parent) return;
                const name = obj.userData?.name || '';
                const type = obj.userData?.type || '';

                // Filter by agent type
                const isValidTarget = isMiner
                    ? (type === 'rock' || name.includes('Ore') || name.includes('Crystal'))
                    : (type === 'tree' || name.includes('Tree') || name.includes('Bush') || name.includes('Plant'));

                if (!isValidTarget) return;

                const dist = agentPos.distanceTo(obj.position);
                if (dist < bestDist) {
                    bestDist = dist;
                    bestTarget = obj;
                }
            });

            if (bestTarget) {
                task.targetObject = bestTarget;
                task.targetPosition = bestTarget.position.clone();
                task.state = 'moving';
                logAgentTask(agent, `Found ${bestTarget.userData?.name || 'resource'} at distance ${Math.floor(bestDist)}`);
            } else {
                // No resources found, wander
                if (!task.targetPosition || agentPos.distanceTo(task.targetPosition) < 2) {
                    task.targetPosition = getRandomWanderPosition(agentPos);
                    task.state = 'moving';
                    logAgentTask(agent, 'No resources nearby, wandering...');
                }
            }
        }

        // v5.16: Hunter task - find and attack enemies
        function runHunterTask(agent) {
            const task = agent.taskState;
            const agentPos = agent.mesh.position;

            // Check agent HP - alert if low
            if (task.hp < task.maxHp * 0.3 && !task.alert) {
                triggerAgentAlert(agent, 'Low HP! Need healing assistance.');
                return;
            }

            // If we have a target enemy, attack it
            if (task.targetObject && task.targetObject.parent && task.targetObject.userData?.hp > 0) {
                const dist = agentPos.distanceTo(task.targetObject.position);
                if (dist < 2.5) {
                    task.state = 'combat';
                    performAgentCombat(agent, task.targetObject);
                    return;
                } else {
                    task.state = 'moving';
                    task.targetPosition = task.targetObject.position.clone();
                    return;
                }
            }

            // Find a new enemy target
            let bestTarget = null;
            let bestDist = 25;

            worldState.mobs.forEach(mob => {
                if (!mob.mesh || !mob.mesh.parent) return;
                if (mob.userData?.hp <= 0) return;

                // Avoid bosses unless protector
                const isBoss = mob.userData?.type === 'boss' || mob.userData?.isBoss;
                if (isBoss && agent.type !== 'protector') {
                    // Alert about boss!
                    if (!task.alert) {
                        triggerAgentAlert(agent, `Found BOSS: ${mob.userData?.name || 'Unknown'}! Need backup!`);
                    }
                    return;
                }

                const dist = agentPos.distanceTo(mob.mesh.position);
                if (dist < bestDist) {
                    bestDist = dist;
                    bestTarget = mob;
                }
            });

            if (bestTarget) {
                task.targetObject = bestTarget.mesh;
                task.targetPosition = bestTarget.mesh.position.clone();
                task.state = 'moving';
                logAgentTask(agent, `Engaging ${bestTarget.userData?.name || 'enemy'}`);
            } else {
                // No enemies, patrol near player
                if (!task.targetPosition || agentPos.distanceTo(task.targetPosition) < 2) {
                    if (worldState.player) {
                        const offset = new THREE.Vector3(
                            (Math.random() - 0.5) * 15,
                            0,
                            (Math.random() - 0.5) * 15
                        );
                        task.targetPosition = worldState.player.position.clone().add(offset);
                    } else {
                        task.targetPosition = getRandomWanderPosition(agentPos);
                    }
                    task.state = 'moving';
                }
            }
        }

        // v5.16: Scout/Explorer task - explore and discover
        function runScoutTask(agent) {
            const task = agent.taskState;
            const agentPos = agent.mesh.position;

            // Scouts move faster and explore wider
            if (!task.targetPosition || agentPos.distanceTo(task.targetPosition) < 3) {
                // Pick a distant unexplored area
                const angle = Math.random() * Math.PI * 2;
                const distance = 20 + Math.random() * 25;
                task.targetPosition = new THREE.Vector3(
                    agentPos.x + Math.cos(angle) * distance,
                    0,
                    agentPos.z + Math.sin(angle) * distance
                );

                // Clamp to world bounds
                task.targetPosition.x = Math.max(-45, Math.min(45, task.targetPosition.x));
                task.targetPosition.z = Math.max(-45, Math.min(45, task.targetPosition.z));
                task.state = 'moving';

                logAgentTask(agent, `Scouting towards (${Math.floor(task.targetPosition.x)}, ${Math.floor(task.targetPosition.z)})`);
            }

            // Report nearby discoveries
            worldState.interactables.forEach(obj => {
                if (!obj.parent) return;
                const dist = agentPos.distanceTo(obj.position);
                if (dist < 5 && obj.userData?.type === 'poi' && !obj.userData?.discovered) {
                    logAgentTask(agent, `Discovered POI: ${obj.userData?.name || 'Unknown'}`);
                    agent.statusMessage = `Found ${obj.userData?.name}!`;
                    updateAgentCardUI(agent);
                }
            });
        }

        // v5.16: Healer task - follow player and heal
        function runHealerTask(agent) {
            const task = agent.taskState;
            const agentPos = agent.mesh.position;

            // Check if player needs healing
            if (gameData.player && gameData.player.hp < gameData.player.maxHp * 0.7) {
                if (worldState.player) {
                    const distToPlayer = agentPos.distanceTo(worldState.player.position);
                    if (distToPlayer < 3) {
                        // Heal player
                        task.state = 'working';
                        const healAmount = 5;
                        gameData.player.hp = Math.min(gameData.player.maxHp, gameData.player.hp + healAmount);
                        spawnFloater(worldState.player.position, `+${healAmount} HP`, '#44ff44');
                        updateHealthUI();
                        task.actionCooldown = 2000; // 2 second cooldown
                        logAgentTask(agent, `Healed player for ${healAmount} HP`);
                        agent.statusMessage = 'Healing player...';
                        updateAgentCardUI(agent);
                        return;
                    } else {
                        // Move to player
                        task.targetPosition = worldState.player.position.clone();
                        task.state = 'moving';
                        return;
                    }
                }
            }

            // Check if any other agent needs healing
            for (const otherAgent of agentFleet) {
                if (otherAgent.id === agent.id) continue;
                if (!otherAgent.taskState || otherAgent.taskState.hp >= otherAgent.taskState.maxHp) continue;

                const dist = agentPos.distanceTo(otherAgent.mesh.position);
                if (dist < 3) {
                    otherAgent.taskState.hp = Math.min(otherAgent.taskState.maxHp, otherAgent.taskState.hp + 10);
                    spawnFloater(otherAgent.mesh.position, '+10 HP', '#44ff44');
                    task.actionCooldown = 2000;
                    logAgentTask(agent, `Healed ${otherAgent.name}`);
                    return;
                } else if (dist < 20) {
                    task.targetPosition = otherAgent.mesh.position.clone();
                    task.state = 'moving';
                    return;
                }
            }

            // No one needs healing, follow player loosely
            if (worldState.player) {
                const distToPlayer = agentPos.distanceTo(worldState.player.position);
                if (distToPlayer > 8) {
                    task.targetPosition = worldState.player.position.clone();
                    task.state = 'moving';
                }
            }
        }

        // v5.16: Fisher task - find and use fishing spots
        function runFisherTask(agent) {
            const task = agent.taskState;
            const agentPos = agent.mesh.position;

            // Find fishing spot
            if (worldState.fishingSpots) {
                let bestSpot = null;
                let bestDist = 50;

                worldState.fishingSpots.forEach(spot => {
                    if (!spot.parent) return;
                    const dist = agentPos.distanceTo(spot.position);
                    if (dist < bestDist) {
                        bestDist = dist;
                        bestSpot = spot;
                    }
                });

                if (bestSpot) {
                    if (bestDist < 2) {
                        // Fish!
                        task.state = 'working';
                        if (Math.random() < 0.1) { // 10% chance per tick
                            const fishTypes = ['Small Fish', 'Medium Fish', 'Large Fish'];
                            const fish = fishTypes[Math.floor(Math.random() * fishTypes.length)];
                            addItem(fish);
                            agent.totalEarnings.items.push(fish);
                            spawnFloater(agentPos, `+1 ${fish}`, '#4488ff');
                            logAgentTask(agent, `Caught ${fish}!`);
                            agent.statusMessage = `Caught ${fish}!`;
                            updateAgentCardUI(agent);
                        }
                        task.actionCooldown = 500;
                        return;
                    } else {
                        task.targetPosition = bestSpot.position.clone();
                        task.state = 'moving';
                        return;
                    }
                }
            }

            // No fishing spots, wander
            if (!task.targetPosition || agentPos.distanceTo(task.targetPosition) < 2) {
                task.targetPosition = getRandomWanderPosition(agentPos);
                task.state = 'moving';
            }
        }

        // v5.16: Move agent towards a position
        function moveAgentTowards(agent, targetPos, deltaTime) {
            const direction = new THREE.Vector3().subVectors(targetPos, agent.mesh.position);
            direction.y = 0;

            if (direction.length() > 0.3) {
                direction.normalize();
                const speed = agent.type === 'scout' || agent.type === 'explorer' ? 4 : 3;
                agent.mesh.position.x += direction.x * deltaTime * speed;
                agent.mesh.position.z += direction.z * deltaTime * speed;
                agent.position.copy(agent.mesh.position);
            }
        }

        // v5.16: Get random wander position
        function getRandomWanderPosition(currentPos) {
            const angle = Math.random() * Math.PI * 2;
            const distance = 8 + Math.random() * 12;
            const pos = new THREE.Vector3(
                currentPos.x + Math.cos(angle) * distance,
                0,
                currentPos.z + Math.sin(angle) * distance
            );
            pos.x = Math.max(-45, Math.min(45, pos.x));
            pos.z = Math.max(-45, Math.min(45, pos.z));
            return pos;
        }

        // v5.16: Agent performs action on target (gathering)
        function performAgentAction(agent, target) {
            const task = agent.taskState;
            const data = target.userData;

            if (!data || data.hp === undefined) return;

            // Deal "damage" to resource
            const damage = 2;
            data.hp -= damage;

            // Visual feedback
            target.scale.setScalar(0.9);
            setTimeout(() => { if (target.parent) target.scale.setScalar(1); }, 100);

            // Particles
            if (particles) {
                const particleColor = data.type === 'tree' ? 0x885522 : 0x888888;
                particles.emit(target.position, 3, particleColor, { spread: 1.5, lifetime: 400, size: 0.1 });
            }

            // Check if destroyed
            if (data.hp <= 0) {
                let itemName = 'Resource';
                let itemCount = 1;

                if (data.type === 'tree') {
                    itemName = 'Log';
                    itemCount = 2;
                } else if (data.type === 'rock') {
                    itemName = 'Ore';
                    itemCount = 2;
                }

                for (let i = 0; i < itemCount; i++) addItem(itemName);
                agent.totalEarnings.items.push(itemName);
                spawnFloater(target.position, `+${itemCount} ${itemName}`, '#ffdd00');
                AudioSystem.collect();

                logAgentTask(agent, `Harvested ${itemCount} ${itemName}`);
                agent.statusMessage = `Got ${itemCount} ${itemName}!`;
                agent.progress = Math.min(100, agent.progress + 5);
                updateAgentCardUI(agent);

                // Remove from world
                worldState.scene.remove(target);
                worldState.interactables = worldState.interactables.filter(x => x !== target);

                // Clear target
                task.targetObject = null;
                task.targetPosition = null;
                task.state = 'idle';
            }

            task.actionCooldown = 500; // Half second between hits
        }

        // v5.16: Agent performs combat
        function performAgentCombat(agent, targetMesh) {
            const task = agent.taskState;
            const data = targetMesh.userData;

            if (!data || data.hp === undefined || data.hp <= 0) {
                task.targetObject = null;
                task.state = 'idle';
                return;
            }

            // Deal damage
            const damage = 8;
            data.hp -= damage;
            spawnFloater(targetMesh.position, `-${damage}`, '#ff4444');

            // Visual feedback
            targetMesh.scale.setScalar(0.85);
            setTimeout(() => { if (targetMesh.parent) targetMesh.scale.setScalar(1); }, 100);

            // Particles
            if (particles) {
                particles.emit(targetMesh.position, 5, 0xff4444, { spread: 2, lifetime: 500 });
            }

            // Agent takes damage from enemy
            const enemyDamage = Math.floor(Math.random() * 5) + 2;
            task.hp -= enemyDamage;

            // Check if agent died
            if (task.hp <= 0) {
                triggerAgentAlert(agent, 'Agent down! Need revival!');
                task.hp = 1; // Keep alive but alert
                task.state = 'alert';
                return;
            }

            // Check if enemy killed
            if (data.hp <= 0) {
                const xpReward = data.xp || 20;
                const goldReward = Math.floor(Math.random() * 10) + 5;

                addXp('combat', xpReward);
                agent.totalEarnings.xp += xpReward;
                agent.totalEarnings.gold += goldReward;

                spawnFloater(targetMesh.position, `+${xpReward} XP`, '#ffff00');
                AudioSystem.levelUp();

                logAgentTask(agent, `Defeated ${data.name || 'enemy'}! +${xpReward} XP`);
                agent.statusMessage = `Killed ${data.name}!`;
                agent.progress = Math.min(100, agent.progress + 10);
                updateAgentCardUI(agent);

                // Remove mob
                worldState.scene.remove(targetMesh);
                worldState.mobs = worldState.mobs.filter(m => m.mesh !== targetMesh);

                task.targetObject = null;
                task.state = 'idle';
            }

            task.actionCooldown = 800;
        }

        // v5.16: Trigger agent alert
        function triggerAgentAlert(agent, message) {
            const task = agent.taskState;
            task.alert = message;
            task.state = 'alert';

            logAgentTask(agent, `ALERT: ${message}`);
            agent.statusMessage = `NEEDS HELP: ${message}`;
            updateAgentCardUI(agent);

            // Notify player
            addCopilotMessage(`âš ï¸ ${agent.typeConfig.icon} ${agent.name} needs help: ${message}`, 'ai');

            // Visual: make alert indicator visible
            if (agent.alertIndicator) {
                agent.alertIndicator.material.color.setHex(0xff0000);
            }
        }

        // v5.16: Log agent task action (for troubleshooting)
        function logAgentTask(agent, message) {
            if (!agent.taskState) return;
            const log = agent.taskState.taskLog;
            log.push({
                time: new Date().toLocaleTimeString(),
                message: message
            });
            // Keep last 20 log entries
            if (log.length > 20) log.shift();
        }

        // v5.16: Check if player is near an alerted agent (for troubleshooting)
        function checkAgentTroubleshooting() {
            if (!worldState.player) return;

            agentFleet.forEach(agent => {
                if (!agent.mesh || !agent.taskState?.alert) return;

                const dist = worldState.player.position.distanceTo(agent.mesh.position);
                if (dist < 3) {
                    // Player is close to alerted agent - show troubleshooting UI
                    showAgentTroubleshootingUI(agent);
                }
            });
        }

        // v5.16: Show troubleshooting UI for agent
        function showAgentTroubleshootingUI(agent) {
            // Create or update troubleshooting tooltip
            let tooltip = document.getElementById('agent-troubleshoot-tooltip');
            if (!tooltip) {
                tooltip = document.createElement('div');
                tooltip.id = 'agent-troubleshoot-tooltip';
                tooltip.style.cssText = `
                    position: fixed; bottom: 200px; left: 50%; transform: translateX(-50%);
                    background: rgba(10, 20, 30, 0.95); padding: 15px; border-radius: 10px;
                    border: 2px solid #ff4444; max-width: 400px; z-index: 1000;
                    font-size: 12px; color: #fff; backdrop-filter: blur(5px);
                `;
                document.body.appendChild(tooltip);
            }

            const task = agent.taskState;
            const logs = task.taskLog.slice(-5).reverse();

            tooltip.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <span style="font-size: 14px; font-weight: bold; color: #ff4444;">
                        âš ï¸ ${agent.typeConfig.icon} ${agent.name} - NEEDS HELP
                    </span>
                    <button onclick="dismissAgentAlert('${agent.id}')" style="background: #444; border: none; color: #fff; padding: 4px 8px; border-radius: 4px; cursor: pointer;">Dismiss</button>
                </div>
                <div style="color: #ff8888; margin-bottom: 10px;">${task.alert}</div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 10px;">
                    <div style="background: rgba(255,255,255,0.1); padding: 6px; border-radius: 4px;">
                        <div style="color: #888; font-size: 10px;">Agent HP</div>
                        <div style="color: ${task.hp < task.maxHp * 0.3 ? '#ff4444' : '#44ff44'};">${task.hp}/${task.maxHp}</div>
                    </div>
                    <div style="background: rgba(255,255,255,0.1); padding: 6px; border-radius: 4px;">
                        <div style="color: #888; font-size: 10px;">State</div>
                        <div>${task.state}</div>
                    </div>
                </div>
                <div style="font-size: 10px; color: #888; margin-bottom: 5px;">Recent Activity:</div>
                <div style="background: rgba(0,0,0,0.3); padding: 8px; border-radius: 4px; max-height: 100px; overflow-y: auto;">
                    ${logs.map(l => `<div style="margin-bottom: 4px;"><span style="color: #666;">${l.time}</span> ${l.message}</div>`).join('')}
                </div>
                <div style="display: flex; gap: 8px; margin-top: 10px;">
                    <button onclick="healAgentFromPlayer('${agent.id}')" style="flex: 1; padding: 8px; background: #44ff44; border: none; color: #000; border-radius: 4px; cursor: pointer;">ðŸ’š Heal Agent</button>
                    <button onclick="resetAgentTask('${agent.id}')" style="flex: 1; padding: 8px; background: #4488ff; border: none; color: #fff; border-radius: 4px; cursor: pointer;">ðŸ”„ Reset Task</button>
                </div>
            `;
            tooltip.style.display = 'block';

            // Auto-hide when player moves away
            setTimeout(() => {
                if (worldState.player && agent.mesh) {
                    const dist = worldState.player.position.distanceTo(agent.mesh.position);
                    if (dist > 5) {
                        tooltip.style.display = 'none';
                    }
                }
            }, 500);
        }

        // v5.16: Dismiss agent alert
        function dismissAgentAlert(agentId) {
            const agent = agentFleet.find(a => a.id === agentId);
            if (agent && agent.taskState) {
                agent.taskState.alert = null;
                agent.taskState.state = 'idle';
                agent.statusMessage = 'Alert dismissed, resuming...';
                updateAgentCardUI(agent);
            }
            const tooltip = document.getElementById('agent-troubleshoot-tooltip');
            if (tooltip) tooltip.style.display = 'none';
        }

        // v5.16: Heal agent from player
        function healAgentFromPlayer(agentId) {
            const agent = agentFleet.find(a => a.id === agentId);
            if (agent && agent.taskState) {
                agent.taskState.hp = agent.taskState.maxHp;
                agent.taskState.alert = null;
                agent.taskState.state = 'idle';
                spawnFloater(agent.mesh.position, 'FULLY HEALED', '#44ff44');
                agent.statusMessage = 'Healed and ready!';
                updateAgentCardUI(agent);
                logAgentTask(agent, 'Healed by player');
            }
            const tooltip = document.getElementById('agent-troubleshoot-tooltip');
            if (tooltip) tooltip.style.display = 'none';
        }

        // v5.16: Reset agent task
        function resetAgentTask(agentId) {
            const agent = agentFleet.find(a => a.id === agentId);
            if (agent && agent.taskState) {
                agent.taskState.targetObject = null;
                agent.taskState.targetPosition = null;
                agent.taskState.alert = null;
                agent.taskState.state = 'idle';
                agent.taskState.stuckCounter = 0;
                agent.statusMessage = 'Task reset, finding new objective...';
                updateAgentCardUI(agent);
                logAgentTask(agent, 'Task reset by player');
            }
            const tooltip = document.getElementById('agent-troubleshoot-tooltip');
            if (tooltip) tooltip.style.display = 'none';
        }

        // Parse natural language commands for agent fleet
        function parseAgentFleetCommand(message) {
            const lowerMsg = message.toLowerCase();

            // Spawn commands
            const spawnPatterns = [
                { pattern: /spawn\s+(a\s+)?(\d+\s+)?gatherer/i, type: 'gatherer' },
                { pattern: /spawn\s+(a\s+)?(\d+\s+)?hunter/i, type: 'hunter' },
                { pattern: /spawn\s+(a\s+)?(\d+\s+)?scout/i, type: 'scout' },
                { pattern: /spawn\s+(a\s+)?(\d+\s+)?protector/i, type: 'protector' },
                { pattern: /spawn\s+(a\s+)?(\d+\s+)?healer/i, type: 'healer' },
                { pattern: /spawn\s+(a\s+)?(\d+\s+)?fisher/i, type: 'fisher' },
                { pattern: /spawn\s+(a\s+)?(\d+\s+)?miner/i, type: 'miner' },
                { pattern: /spawn\s+(a\s+)?(\d+\s+)?explorer/i, type: 'explorer' },
                { pattern: /send\s+(a\s+)?(\d+\s+)?agent/i, type: null },
                { pattern: /deploy\s+(a\s+)?(\d+\s+)?agent/i, type: null },
            ];

            for (const { pattern, type } of spawnPatterns) {
                const match = lowerMsg.match(pattern);
                if (match) {
                    if (type) {
                        const count = parseInt(match[2]) || 1;
                        for (let i = 0; i < Math.min(count, MAX_AGENTS - agentFleet.length); i++) {
                            spawnAgent(type);
                        }
                        return true;
                    } else {
                        // Generic spawn - suggest opening the fleet panel
                        toggleAgentFleetPanel();
                        addCopilotMessage(`Fleet panel opened! Select an agent type to spawn.`, 'ai');
                        return true;
                    }
                }
            }

            // Alternative spawn phrases
            if (lowerMsg.includes('send agent') || lowerMsg.includes('send out') || lowerMsg.includes('deploy agent')) {
                toggleAgentFleetPanel();
                addCopilotMessage(`Fleet panel opened! Choose an agent type to deploy.`, 'ai');
                return true;
            }

            // Recall all agents
            if (lowerMsg.includes('recall all') || lowerMsg.includes('bring back all') || lowerMsg.includes('return all agents')) {
                if (agentFleet.length > 0) {
                    const count = agentFleet.length;
                    [...agentFleet].forEach(agent => recallAgent(agent.id));
                    addCopilotMessage(`Recalled all ${count} agents!`, 'ai');
                    return true;
                } else {
                    addCopilotMessage(`No agents are currently deployed.`, 'ai');
                    return true;
                }
            }

            // Fleet status
            if (lowerMsg.includes('fleet status') || lowerMsg.includes('agent status') || lowerMsg.includes('how many agents')) {
                if (agentFleet.length === 0) {
                    addCopilotMessage(`No agents deployed. Open the fleet panel (ðŸ¤– button) to spawn agents!`, 'ai');
                } else {
                    const summary = agentFleet.map(a => `${a.typeConfig.icon} ${a.name} (${a.typeConfig.name})`).join(', ');
                    addCopilotMessage(`${agentFleet.length}/${MAX_AGENTS} agents deployed: ${summary}`, 'ai');
                }
                return true;
            }

            // Open fleet panel
            if (lowerMsg.includes('open fleet') || lowerMsg.includes('show agents') || lowerMsg.includes('agent panel')) {
                toggleAgentFleetPanel();
                return true;
            }

            return false;
        }

        // ============================================
        // v5.10: TRANSCRIPT EXPORT SYSTEM
        // Export agent transcripts for debugging
        // ============================================
        let currentTranscriptAgentId = null;

        // v5.12.1: Build a standard transcript JSON for an agent (includes endpoint config)
        function buildAgentTranscript(agent) {
            const elapsed = (performance.now() - agent.spawnTime) / 1000;
            const agentEndpoint = getAgentEndpoint(agent);

            return {
                transcript_version: "1.1",
                export_timestamp: new Date().toISOString(),
                application: "LEVIATHAN: OMNIVERSE",
                application_version: VERSION,
                agent: {
                    id: agent.id,
                    name: agent.name,
                    type: agent.type,
                    type_config: {
                        icon: agent.typeConfig.icon,
                        name: agent.typeConfig.name,
                        decision_interval_ms: agent.typeConfig.decisionInterval,
                        task_type: agent.typeConfig.taskType
                    },
                    status: agent.status,
                    status_message: agent.statusMessage,
                    progress_percent: Math.round(agent.progress),
                    spawn_time: new Date(Date.now() - elapsed * 1000).toISOString(),
                    runtime_seconds: Math.floor(elapsed)
                },
                // v5.12.1: Endpoint configuration for spawning agents with different AI providers
                // v5.14: Now includes profile reference
                endpoint_config: {
                    name: agentEndpoint.name,
                    profile_id: agent.profileId || null,
                    profile_name: agent.profileId ? getEndpointProfile(agent.profileId)?.name : null,
                    url: agent.endpointConfig?.url || agentEndpoint.url || '${URL_PLACEHOLDER}',
                    // v5.15: Check all possible key sources (profile, config, or global fallback)
                    apiKey: (agent.endpointConfig?.apiKey || agent.profileId || agentEndpoint.key) ? '${API_KEY_PLACEHOLDER}' : null,
                    urlKey: agent.endpointConfig?.urlKey || null,
                    apiKeyKey: agent.endpointConfig?.apiKeyKey || null,
                    headerStyle: agentEndpoint.headerStyle,
                    headerPrefix: agentEndpoint.headerPrefix || '',
                    bodyFormat: agentEndpoint.bodyFormat,
                    model: agentEndpoint.model || agent.endpointConfig?.model || null,
                    active_endpoint: agent.activeEndpoint || 'default'
                },
                game_context: {
                    player_hp: gameData.player?.hp || 100,
                    player_max_hp: gameData.player?.maxHp || 100,
                    current_biome: worldState?.currentCiv?.biomeName || 'Unknown',
                    planet_name: worldState?.currentCiv?.name || 'Unknown',
                    player_position: worldState.player ? {
                        x: Math.floor(worldState.player.position.x),
                        z: Math.floor(worldState.player.position.z)
                    } : null
                },
                earnings: {
                    total_xp: agent.totalEarnings.xp,
                    total_gold: agent.totalEarnings.gold,
                    items_collected: agent.totalEarnings.items
                },
                results_log: agent.results,
                conversation_history: agent.conversationHistory.map((msg, idx) => ({
                    index: idx,
                    role: msg.role,
                    content: msg.content,
                    // Include endpoint in first message for transcript re-import
                    endpoint: idx === 0 && agent.endpointConfig ? {
                        url: agent.endpointConfig.url || '${URL_PLACEHOLDER}',
                        apiKey: '${API_KEY_PLACEHOLDER}',
                        headerStyle: agent.endpointConfig.headerStyle,
                        bodyFormat: agent.endpointConfig.bodyFormat,
                        model: agent.endpointConfig.model
                    } : undefined,
                    timestamp: null
                })),
                system_prompt: agent.conversationHistory.length > 0 ? agent.conversationHistory[0].content : null,
                total_messages: agent.conversationHistory.length,
                api_endpoint: agentEndpoint.url || 'local-simulation'
            };
        }

        // Build transcript for all agents
        function buildAllAgentTranscripts() {
            // v5.15: Include ship defense statistics
            const defenseStats = getDefenseStats();

            return {
                transcript_version: "1.1",
                export_timestamp: new Date().toISOString(),
                application: "LEVIATHAN: OMNIVERSE",
                application_version: VERSION,
                fleet_summary: {
                    total_agents: agentFleet.length,
                    max_agents: MAX_AGENTS,
                    agent_types: agentFleet.reduce((acc, a) => {
                        acc[a.type] = (acc[a.type] || 0) + 1;
                        return acc;
                    }, {}),
                    total_xp_earned: agentFleet.reduce((sum, a) => sum + a.totalEarnings.xp, 0),
                    total_gold_earned: agentFleet.reduce((sum, a) => sum + a.totalEarnings.gold, 0),
                    total_items_collected: agentFleet.reduce((sum, a) => sum + a.totalEarnings.items.length, 0)
                },
                // v5.15: Ship defense summary
                ship_defense: {
                    hull_hp: SHIP_STATE.currentHP,
                    hull_max_hp: SHIP_STATE.maxHP,
                    auto_defense_enabled: SHIP_STATE.autoDefend,
                    statistics: {
                        total_engagements: defenseStats.engagements,
                        total_kills: defenseStats.kills,
                        total_damage_dealt: defenseStats.damageDealt,
                        entities_deterred: defenseStats.deterred,
                        times_attacked: defenseStats.attacked,
                        total_damage_taken: defenseStats.damageTaken,
                        kill_rate_percent: defenseStats.killRatio,
                        repairs_performed: defenseStats.repairs,
                        repair_costs_total: defenseStats.repairCost,
                        times_destroyed: defenseStats.destroyed
                    },
                    recent_events: SHIP_STATE.defenseLog.events.slice(-20).map(e => ({
                        type: e.type,
                        time: e.time,
                        details: { ...e, type: undefined, timestamp: undefined, time: undefined }
                    }))
                },
                game_context: {
                    player_hp: gameData.player?.hp || 100,
                    player_max_hp: gameData.player?.maxHp || 100,
                    current_biome: worldState?.currentCiv?.biomeName || 'Unknown',
                    planet_name: worldState?.currentCiv?.name || 'Unknown'
                },
                agents: agentFleet.map(agent => buildAgentTranscript(agent)),
                copilot_conversation_history: copilotConversationHistory
            };
        }

        // Open transcript viewer modal
        function openTranscriptViewer() {
            const modal = document.getElementById('transcript-modal');
            modal.classList.add('active');

            // Build tabs
            const tabsContainer = document.getElementById('transcript-tabs');
            let tabsHtml = `<button class="transcript-tab active" onclick="selectTranscriptTab('all')">ðŸ“¦ All Agents</button>`;

            agentFleet.forEach(agent => {
                tabsHtml += `<button class="transcript-tab" onclick="selectTranscriptTab('${agent.id}')">${agent.typeConfig.icon} ${agent.name}</button>`;
            });

            // Add copilot main chat
            tabsHtml += `<button class="transcript-tab" onclick="selectTranscriptTab('copilot')">â­ Main Copilot</button>`;

            tabsContainer.innerHTML = tabsHtml;

            // Show all agents by default
            selectTranscriptTab('all');
        }

        // Close transcript viewer
        function closeTranscriptViewer() {
            document.getElementById('transcript-modal').classList.remove('active');
        }

        // Select a transcript tab
        function selectTranscriptTab(agentId) {
            currentTranscriptAgentId = agentId;

            // Update tab active state
            document.querySelectorAll('.transcript-tab').forEach(tab => tab.classList.remove('active'));
            event.target.classList.add('active');

            const infoContainer = document.getElementById('transcript-agent-info');
            const jsonView = document.getElementById('transcript-json-view');

            if (agentId === 'all') {
                // Show all agents summary
                const transcript = buildAllAgentTranscripts();
                infoContainer.innerHTML = `
                    <div class="transcript-info-item">
                        <div class="transcript-info-label">Total Agents</div>
                        <div class="transcript-info-value">${transcript.fleet_summary.total_agents}/${MAX_AGENTS}</div>
                    </div>
                    <div class="transcript-info-item">
                        <div class="transcript-info-label">Total XP</div>
                        <div class="transcript-info-value">${transcript.fleet_summary.total_xp_earned}</div>
                    </div>
                    <div class="transcript-info-item">
                        <div class="transcript-info-label">Total Gold</div>
                        <div class="transcript-info-value">${transcript.fleet_summary.total_gold_earned}</div>
                    </div>
                    <div class="transcript-info-item">
                        <div class="transcript-info-label">Items Collected</div>
                        <div class="transcript-info-value">${transcript.fleet_summary.total_items_collected}</div>
                    </div>
                `;
                jsonView.innerHTML = syntaxHighlightJSON(JSON.stringify(transcript, null, 2));
            } else if (agentId === 'copilot') {
                // Show main copilot conversation
                const transcript = {
                    transcript_version: "1.0",
                    export_timestamp: new Date().toISOString(),
                    application: "LEVIATHAN: OMNIVERSE",
                    type: "main_copilot",
                    conversation_history: copilotConversationHistory.map((msg, idx) => ({
                        index: idx,
                        role: msg.role,
                        content: msg.content
                    })),
                    total_messages: copilotConversationHistory.length,
                    rappid_settings: {
                        enabled: rappidSettings.rappid,
                        endpoint: getActiveEndpoint()?.name || 'none',
                        tts_enabled: !!rappidSettings.azureTTSKey
                    }
                };
                infoContainer.innerHTML = `
                    <div class="transcript-info-item">
                        <div class="transcript-info-label">Type</div>
                        <div class="transcript-info-value">Main Copilot</div>
                    </div>
                    <div class="transcript-info-item">
                        <div class="transcript-info-label">Messages</div>
                        <div class="transcript-info-value">${copilotConversationHistory.length}</div>
                    </div>
                    <div class="transcript-info-item">
                        <div class="transcript-info-label">RAPPID</div>
                        <div class="transcript-info-value">${rappidSettings.rappid ? 'Enabled' : 'Disabled'}</div>
                    </div>
                `;
                jsonView.innerHTML = syntaxHighlightJSON(JSON.stringify(transcript, null, 2));
            } else {
                // Show specific agent
                const agent = agentFleet.find(a => a.id === agentId);
                if (!agent) {
                    jsonView.innerHTML = '<span style="color: #ff4444;">Agent not found</span>';
                    return;
                }

                const transcript = buildAgentTranscript(agent);
                const elapsed = Math.floor((performance.now() - agent.spawnTime) / 1000);

                infoContainer.innerHTML = `
                    <div class="transcript-info-item">
                        <div class="transcript-info-label">Agent</div>
                        <div class="transcript-info-value">${agent.typeConfig.icon} ${agent.name}</div>
                    </div>
                    <div class="transcript-info-item">
                        <div class="transcript-info-label">Type</div>
                        <div class="transcript-info-value">${agent.typeConfig.name}</div>
                    </div>
                    <div class="transcript-info-item">
                        <div class="transcript-info-label">Status</div>
                        <div class="transcript-info-value">${agent.status}</div>
                    </div>
                    <div class="transcript-info-item">
                        <div class="transcript-info-label">Runtime</div>
                        <div class="transcript-info-value">${elapsed}s</div>
                    </div>
                    <div class="transcript-info-item">
                        <div class="transcript-info-label">Messages</div>
                        <div class="transcript-info-value">${agent.conversationHistory.length}</div>
                    </div>
                    <div class="transcript-info-item">
                        <div class="transcript-info-label">XP Earned</div>
                        <div class="transcript-info-value">${agent.totalEarnings.xp}</div>
                    </div>
                `;
                jsonView.innerHTML = syntaxHighlightJSON(JSON.stringify(transcript, null, 2));
            }
        }

        // Syntax highlight JSON for display
        function syntaxHighlightJSON(json) {
            return json
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g, (match) => {
                    let cls = 'number';
                    if (/^"/.test(match)) {
                        if (/:$/.test(match)) {
                            cls = 'key';
                        } else {
                            cls = 'string';
                        }
                    } else if (/true|false/.test(match)) {
                        cls = 'boolean';
                    } else if (/null/.test(match)) {
                        cls = 'null';
                    }
                    return `<span class="${cls}">${match}</span>`;
                });
        }

        // Copy current transcript to clipboard
        function copyTranscriptToClipboard() {
            let transcript;
            if (currentTranscriptAgentId === 'all') {
                transcript = buildAllAgentTranscripts();
            } else if (currentTranscriptAgentId === 'copilot') {
                transcript = {
                    transcript_version: "1.0",
                    export_timestamp: new Date().toISOString(),
                    application: "LEVIATHAN: OMNIVERSE",
                    type: "main_copilot",
                    conversation_history: copilotConversationHistory
                };
            } else {
                const agent = agentFleet.find(a => a.id === currentTranscriptAgentId);
                if (!agent) return;
                transcript = buildAgentTranscript(agent);
            }

            navigator.clipboard.writeText(JSON.stringify(transcript, null, 2)).then(() => {
                showNotification('Transcript copied to clipboard!', 'success');
            }).catch(err => {
                console.error('Copy failed:', err);
                showNotification('Failed to copy transcript', 'error');
            });
        }

        // Download current transcript as JSON file
        function downloadCurrentTranscript() {
            let transcript;
            let filename;

            if (currentTranscriptAgentId === 'all') {
                transcript = buildAllAgentTranscripts();
                filename = `leviathan-fleet-transcript-${new Date().toISOString().split('T')[0]}.json`;
            } else if (currentTranscriptAgentId === 'copilot') {
                transcript = {
                    transcript_version: "1.0",
                    export_timestamp: new Date().toISOString(),
                    application: "LEVIATHAN: OMNIVERSE",
                    type: "main_copilot",
                    conversation_history: copilotConversationHistory
                };
                filename = `leviathan-copilot-transcript-${new Date().toISOString().split('T')[0]}.json`;
            } else {
                const agent = agentFleet.find(a => a.id === currentTranscriptAgentId);
                if (!agent) return;
                transcript = buildAgentTranscript(agent);
                filename = `leviathan-agent-${agent.name.toLowerCase()}-transcript-${new Date().toISOString().split('T')[0]}.json`;
            }

            downloadJSON(transcript, filename);
        }

        // Download all transcripts as a single JSON file
        function downloadAllTranscripts() {
            const transcript = buildAllAgentTranscripts();
            const filename = `leviathan-full-fleet-export-${new Date().toISOString().split('T')[0]}.json`;
            downloadJSON(transcript, filename);
        }

        // Helper to download JSON
        function downloadJSON(data, filename) {
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            link.click();
            URL.revokeObjectURL(url);
            showNotification(`Downloaded: ${filename}`, 'success');
        }

        // Export single agent transcript (for agent card button)
        function exportAgentTranscript(agentId) {
            const agent = agentFleet.find(a => a.id === agentId);
            if (!agent) return;

            const transcript = buildAgentTranscript(agent);
            const filename = `leviathan-agent-${agent.name.toLowerCase()}-transcript-${new Date().toISOString().split('T')[0]}.json`;
            downloadJSON(transcript, filename);
        }

        // Import transcript file (for replaying/debugging)
        function importTranscriptFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const transcript = JSON.parse(e.target.result);
                    console.log('Imported transcript:', transcript);

                    // Validate transcript structure
                    if (!transcript.transcript_version) {
                        showNotification('Invalid transcript format', 'error');
                        return;
                    }

                    // Show in console for debugging
                    console.log('=== IMPORTED TRANSCRIPT ===');
                    console.log('Version:', transcript.transcript_version);
                    console.log('Application:', transcript.application);

                    if (transcript.agents) {
                        console.log('Fleet with', transcript.agents.length, 'agents');
                        transcript.agents.forEach(agent => {
                            console.log(`  - ${agent.agent.name} (${agent.agent.type}): ${agent.total_messages} messages`);
                        });
                    } else if (transcript.agent) {
                        console.log('Single agent:', transcript.agent.name);
                        console.log('Messages:', transcript.total_messages);
                    } else if (transcript.type === 'main_copilot') {
                        console.log('Main copilot conversation');
                        console.log('Messages:', transcript.conversation_history?.length);
                    }

                    showNotification('Transcript imported - check console for details', 'success');

                    // Open transcript viewer with imported data
                    // (Could add more functionality here to replay transcripts)

                } catch (error) {
                    console.error('Import failed:', error);
                    showNotification('Failed to parse transcript file', 'error');
                }
            };
            reader.readAsText(file);
            event.target.value = ''; // Reset input
        }

        // Context-aware responses based on game state
        const COPILOT_RESPONSES = {
            greeting: [
                "Hello, Explorer! Ready for adventure?",
                "Greetings! I'm here to help you on your journey.",
                "Welcome back! What shall we explore today?"
            ],
            lowHealth: [
                "Careful! Your health is low. Consider using a health potion or retreating.",
                "You're wounded! Look for healing items or rest at a safe spot.",
                "Warning: Low HP! Maybe craft some health potions?"
            ],
            nearEnemy: [
                "Enemy spotted nearby! Prepare for combat.",
                "Be cautious, there's a hostile creature close by.",
                "I sense danger ahead. Ready your weapon!"
            ],
            afterKill: [
                "Well done! That was impressive combat.",
                "Excellent work, Explorer!",
                "Another victory! Your skills are improving."
            ],
            exploration: [
                "This area looks interesting. Let's explore!",
                "I wonder what secrets this place holds...",
                "Keep your eyes open for resources and treasures."
            ],
            tips: [
                "Tip: Use WASD to move and click to attack enemies.",
                "Tip: Collect resources to craft better equipment.",
                "Tip: Your combat skill increases as you defeat enemies.",
                "Tip: Look for points of interest marked on the minimap.",
                "Tip: Different biomes have different resources and enemies.",
                "Tip: Pets can help you in combat and provide bonuses."
            ],
            whatNext: [
                "Try exploring new areas to find resources and level up.",
                "You could hunt some enemies to gain XP and loot.",
                "Check your inventory - maybe craft some new equipment.",
                "Have you discovered all the points of interest on this planet?"
            ],
            getStronger: [
                "Fight enemies to gain combat XP and level up your skills.",
                "Craft better weapons and armor from the resources you gather.",
                "Find and bond with a pet companion for stat bonuses.",
                "Complete daily challenges for bonus rewards.",
                "Unlock talents in the talent tree as you level up."
            ],
            enemies: [
                "Enemies respawn periodically throughout the world.",
                "Look for the red markers on your minimap.",
                "Elite enemies (marked with special effects) drop better loot.",
                "Different biomes have different enemy types."
            ]
        };

        function initCopilotCompanion() {
            // Initialize speech recognition if available (browser fallback)
            if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                copilotVoiceRecognition = new SpeechRecognition();
                copilotVoiceRecognition.continuous = false;
                copilotVoiceRecognition.interimResults = true; // v5.9: Enable interim results
                copilotVoiceRecognition.lang = 'en-US';

                copilotVoiceRecognition.onresult = (event) => {
                    let interimTranscript = '';
                    let finalTranscript = '';

                    for (let i = event.resultIndex; i < event.results.length; i++) {
                        const transcript = event.results[i][0].transcript;
                        if (event.results[i].isFinal) {
                            finalTranscript += transcript;
                        } else {
                            interimTranscript += transcript;
                        }
                    }

                    // Update overlay with real-time transcription
                    if (finalTranscript) {
                        updateSTTTranscript(finalTranscript, true);
                    } else if (interimTranscript) {
                        updateSTTTranscript(interimTranscript, false);
                    }
                };

                copilotVoiceRecognition.onend = () => {
                    copilotIsListening = false;
                    document.getElementById('copilot-voice-btn').classList.remove('recording');
                };

                copilotVoiceRecognition.onerror = (event) => {
                    copilotIsListening = false;
                    document.getElementById('copilot-voice-btn').classList.remove('recording');
                    showSTTOverlay(false);
                    console.error('Browser STT error:', event.error);
                };
            }
        }

        function createCopilotMesh() {
            if (copilotMesh) {
                scene.remove(copilotMesh);
                copilotMesh = null;
            }

            if (mode !== 'world' || !worldState.player) return;

            const companionGroup = new THREE.Group();

            // Main orb
            const orbGeometry = new THREE.SphereGeometry(0.5, 24, 24);
            const orbMaterial = new THREE.MeshStandardMaterial({
                color: COPILOT_CONFIG.color,
                emissive: COPILOT_CONFIG.color,
                emissiveIntensity: 0.6,
                metalness: 0.8,
                roughness: 0.2,
                transparent: true,
                opacity: 0.9
            });
            const orb = new THREE.Mesh(orbGeometry, orbMaterial);
            companionGroup.add(orb);

            // Inner glow core
            const coreGeometry = new THREE.SphereGeometry(0.3, 16, 16);
            const coreMaterial = new THREE.MeshBasicMaterial({
                color: COPILOT_CONFIG.glowColor,
                transparent: true,
                opacity: 0.8
            });
            const core = new THREE.Mesh(coreGeometry, coreMaterial);
            companionGroup.add(core);

            // Outer glow
            const glowGeometry = new THREE.SphereGeometry(0.7, 16, 16);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: COPILOT_CONFIG.glowColor,
                transparent: true,
                opacity: 0.2,
                side: THREE.BackSide
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            companionGroup.add(glow);

            // Point light for illumination
            const light = new THREE.PointLight(COPILOT_CONFIG.glowColor, 1.5, 8);
            companionGroup.add(light);

            // Particle ring
            const particleGeometry = new THREE.BufferGeometry();
            const particleCount = COPILOT_CONFIG.particleCount;
            const positions = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount * 3; i += 3) {
                const angle = (i / 3) * (Math.PI * 2 / particleCount);
                const radius = 0.8 + Math.random() * 0.3;
                positions[i] = Math.cos(angle) * radius;
                positions[i + 1] = (Math.random() - 0.5) * 0.4;
                positions[i + 2] = Math.sin(angle) * radius;
            }

            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            const particleMaterial = new THREE.PointsMaterial({
                color: COPILOT_CONFIG.glowColor,
                size: 0.08,
                transparent: true,
                opacity: 0.7,
                blending: THREE.AdditiveBlending
            });

            const particles = new THREE.Points(particleGeometry, particleMaterial);
            companionGroup.add(particles);

            // Store references for animation
            companionGroup.userData = {
                orb: orb,
                core: core,
                glow: glow,
                light: light,
                particles: particles,
                isClickable: true,
                isCopilot: true
            };

            // v5.11: Create text groups for Star Wars crawl - optimized for cinematic camera
            copilotTextGroup = new THREE.Group();
            copilotTextGroup.position.set(0, 8, 6); // Higher and forward toward camera
            copilotTextGroup.rotation.x = THREE.MathUtils.degToRad(-55); // Steeper tilt to face down-looking camera
            companionGroup.add(copilotTextGroup);

            copilotPersistentTextGroup = new THREE.Group();
            copilotPersistentTextGroup.position.set(0, 12, 4); // Much higher, toward camera
            copilotPersistentTextGroup.rotation.x = THREE.MathUtils.degToRad(-45); // Tilt to face camera
            companionGroup.add(copilotPersistentTextGroup);

            // Load font for 3D text
            loadCopilotTextFont();

            // Position initially near player
            if (worldState.player) {
                companionGroup.position.copy(worldState.player.position);
                companionGroup.position.y += COPILOT_CONFIG.floatHeight;
                companionGroup.position.z += COPILOT_CONFIG.followDistance;
            }

            scene.add(companionGroup);
            copilotMesh = companionGroup;
        }

        // v5.10: Load font for 3D text rendering
        function loadCopilotTextFont() {
            if (copilotTextFont) return; // Already loaded

            const loader = new THREE.FontLoader();
            loader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', (font) => {
                copilotTextFont = font;
                console.log('Copilot 3D text font loaded');
            }, undefined, (err) => {
                console.warn('Failed to load 3D text font:', err);
            });
        }

        // v5.10: Animate voice response as Star Wars text crawl
        function animateCopilotTextCrawl(text) {
            if (!copilotTextFont || !copilotTextGroup || !copilotMesh) {
                console.log('Text crawl not ready - font or groups not initialized');
                return;
            }

            // Cancel any existing animation
            if (copilotActiveTextAnimation) {
                cancelAnimationFrame(copilotActiveTextAnimation);
                copilotActiveTextAnimation = null;
            }

            // Clear existing text meshes
            copilotTextMeshes.forEach(mesh => {
                if (mesh.geometry) mesh.geometry.dispose();
                if (mesh.material) mesh.material.dispose();
                copilotTextGroup.remove(mesh);
            });
            copilotTextMeshes = [];
            copilotTextGroup.position.y = 8; // v5.11: Reset to cinematic position

            // v5.11: Word wrap text into lines - larger text for visibility
            const maxCharsPerLine = 20; // Shorter lines for larger text
            const words = text.split(' ');
            const lines = [];
            let currentLine = '';

            words.forEach(word => {
                if ((currentLine + word).length > maxCharsPerLine) {
                    if (currentLine) {
                        lines.push(currentLine.trim());
                        currentLine = '';
                    }
                }
                currentLine += word + ' ';
            });
            if (currentLine) {
                lines.push(currentLine.trim());
            }

            // v5.11: Create 3D text for each line - MUCH LARGER for camera distance visibility
            const lineHeight = 2.2; // Increased from 0.6 for larger text
            const textMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                emissive: 0x06ffa5,
                emissiveIntensity: 0.8, // Brighter glow
                metalness: 0.4,
                roughness: 0.3,
                transparent: true,
                opacity: 1
            });

            lines.forEach((line, index) => {
                try {
                    const textGeometry = new THREE.TextGeometry(line, {
                        font: copilotTextFont,
                        size: 1.2, // v5.11: Increased from 0.25 - much larger for visibility
                        height: 0.1, // Increased depth
                        curveSegments: 8,
                        bevelEnabled: true,
                        bevelThickness: 0.02,
                        bevelSize: 0.015,
                        bevelSegments: 4
                    });

                    textGeometry.center();

                    const textMesh = new THREE.Mesh(textGeometry, textMaterial.clone());
                    textMesh.position.y = -index * lineHeight;

                    copilotTextGroup.add(textMesh);
                    copilotTextMeshes.push(textMesh);
                } catch (e) {
                    console.warn('Failed to create text geometry for line:', line, e);
                }
            });

            const totalHeight = lines.length * lineHeight;
            animateStarWarsScroll(totalHeight, text);
        }

        // v5.11: Animate the scrolling like Star Wars - adjusted for larger text
        function animateStarWarsScroll(totalHeight, fullText) {
            const scrollSpeed = 0.04; // Faster scroll for larger text
            const startY = 0;
            const endY = totalHeight + 15; // More distance for larger text
            let currentY = startY;

            const animate = () => {
                if (!copilotTextGroup || copilotTextMeshes.length === 0) return;

                currentY += scrollSpeed;
                copilotTextGroup.position.y = 8 + currentY; // v5.11: Match cinematic starting position

                // Fade based on Y position for depth effect
                copilotTextMeshes.forEach((mesh, index) => {
                    const meshWorldY = currentY - index * 2.2; // Match new lineHeight

                    // Fade in from bottom
                    if (meshWorldY < 0) {
                        mesh.material.opacity = Math.max(0, 1 + meshWorldY * 0.3);
                    }
                    // Fade out at top
                    else if (meshWorldY > totalHeight - 5) {
                        mesh.material.opacity = Math.max(0, 1 - (meshWorldY - (totalHeight - 5)) / 5);
                    }
                    else {
                        mesh.material.opacity = 1;
                    }
                });

                // Check if scroll is complete
                if (currentY > endY) {
                    createPersistentCopilotText(fullText);
                    fadeOutCopilotText();
                    return;
                }

                copilotActiveTextAnimation = requestAnimationFrame(animate);
            };

            animate();
        }

        // v5.11: Create persistent abbreviated text after scroll completes - larger for visibility
        function createPersistentCopilotText(text) {
            // Clear existing persistent text
            if (copilotPersistentTextGroup) {
                copilotPersistentTextGroup.children.forEach(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                });
                copilotPersistentTextGroup.clear();
            }

            if (!copilotTextFont || !copilotPersistentTextGroup) return;

            // Truncate text for persistent display
            const maxLength = 50;
            const displayText = text.length > maxLength ? text.substring(0, maxLength) + '...' : text;

            // Word wrap - shorter lines for larger text
            const lines = [];
            const maxCharsPerLine = 18;
            const words = displayText.split(' ');
            let currentLine = '';

            words.forEach(word => {
                if ((currentLine + word).length > maxCharsPerLine) {
                    if (currentLine) {
                        lines.push(currentLine.trim());
                        currentLine = '';
                    }
                }
                currentLine += word + ' ';
            });
            if (currentLine) {
                lines.push(currentLine.trim());
            }

            const displayLines = lines.slice(0, 2); // Only first 2 lines

            const lineHeight = 1.4; // v5.11: Increased for larger text
            const persistentMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                emissive: 0x8a2be2,
                emissiveIntensity: 0.5, // Brighter
                metalness: 0.3,
                roughness: 0.5,
                transparent: true,
                opacity: 0.85
            });

            displayLines.forEach((line, index) => {
                try {
                    const textGeometry = new THREE.TextGeometry(line, {
                        font: copilotTextFont,
                        size: 0.7, // v5.11: Much larger for visibility
                        height: 0.06,
                        curveSegments: 6,
                        bevelEnabled: true,
                        bevelThickness: 0.012,
                        bevelSize: 0.008,
                        bevelSegments: 3
                    });

                    textGeometry.center();

                    const textMesh = new THREE.Mesh(textGeometry, persistentMaterial.clone());
                    textMesh.position.y = -index * lineHeight;

                    copilotPersistentTextGroup.add(textMesh);
                } catch (e) {
                    console.warn('Failed to create persistent text:', e);
                }
            });
        }

        // v5.10: Fade out scrolling text after animation completes
        function fadeOutCopilotText() {
            let opacity = 1;
            const fadeSpeed = 0.03;

            const fade = () => {
                opacity -= fadeSpeed;

                if (opacity <= 0) {
                    copilotTextMeshes.forEach(mesh => {
                        if (mesh.geometry) mesh.geometry.dispose();
                        if (mesh.material) mesh.material.dispose();
                        copilotTextGroup.remove(mesh);
                    });
                    copilotTextMeshes = [];
                    copilotTextGroup.position.y = 8; // v5.11: Cinematic reset position
                    return;
                }

                copilotTextMeshes.forEach(mesh => {
                    mesh.material.opacity = opacity;
                });

                requestAnimationFrame(fade);
            };

            fade();
        }

        function updateCopilotCompanion(dt, time) {
            if (!copilotMesh || !worldState.player || mode !== 'world') return;

            copilotAnimTime += dt;

            // Calculate target position (behind and above player)
            const playerPos = worldState.player.position;
            const playerRotY = worldState.player.rotation.y;

            // Orbit slightly around the player
            const orbitAngle = copilotAnimTime * COPILOT_CONFIG.orbitSpeed;
            const offsetX = Math.sin(playerRotY + orbitAngle + Math.PI) * COPILOT_CONFIG.followDistance;
            const offsetZ = Math.cos(playerRotY + orbitAngle + Math.PI) * COPILOT_CONFIG.followDistance;

            const targetX = playerPos.x + offsetX;
            const targetZ = playerPos.z + offsetZ;
            const targetY = playerPos.y + COPILOT_CONFIG.floatHeight +
                           Math.sin(copilotAnimTime * COPILOT_CONFIG.floatSpeed) * COPILOT_CONFIG.floatAmplitude;

            // Smooth follow
            const smoothing = COPILOT_CONFIG.followSmoothing * dt;
            copilotMesh.position.x += (targetX - copilotMesh.position.x) * smoothing;
            copilotMesh.position.z += (targetZ - copilotMesh.position.z) * smoothing;
            copilotMesh.position.y += (targetY - copilotMesh.position.y) * smoothing;

            // Rotate particles
            if (copilotMesh.userData.particles) {
                copilotMesh.userData.particles.rotation.y += dt * 1.5;
            }

            // Pulse glow effect
            const pulse = 0.5 + Math.sin(time * 0.003) * 0.3;
            if (copilotMesh.userData.glow) {
                copilotMesh.userData.glow.material.opacity = 0.15 + pulse * 0.1;
            }
            if (copilotMesh.userData.light) {
                copilotMesh.userData.light.intensity = 1 + pulse;
            }
            if (copilotMesh.userData.orb) {
                copilotMesh.userData.orb.material.emissiveIntensity = 0.4 + pulse * 0.4;
            }

            // Make copilot face camera
            copilotMesh.lookAt(camera.position);
        }

        function toggleCopilotChat() {
            copilotChatOpen = !copilotChatOpen;
            const chatInterface = document.getElementById('copilot-chat-interface');
            const button = document.getElementById('copilot-button');

            if (copilotChatOpen) {
                chatInterface.classList.add('active');
                button.classList.add('active');
                document.getElementById('copilot-chat-input').focus();
            } else {
                chatInterface.classList.remove('active');
                button.classList.remove('active');
            }
        }

        async function sendCopilotMessage() {
            const input = document.getElementById('copilot-chat-input');
            const message = input.value.trim();
            if (!message) return;

            // Add user message to chat
            addCopilotMessage(message, 'user');
            input.value = '';

            // v5.9: Check for task commands first (gather, hunt, scout, etc.)
            if (parseCopilotTaskCommand(message)) {
                // Task command handled - skip normal response flow
                return;
            }

            // v5.10: Check for agent fleet commands
            if (parseAgentFleetCommand(message)) {
                // Fleet command handled
                return;
            }

            // Add to history
            copilotConversationHistory.push({ role: 'user', content: message });

            // Show typing indicator
            showCopilotTyping();

            // Check if RAPPID is configured for AI-powered responses
            const hasRappid = rappidSettings.rappid && getActiveEndpoint();

            if (hasRappid) {
                // Use RAPPID API for response
                try {
                    // v5.9: Response now contains { text, voice } - text for display, voice for TTS
                    const response = await generateCopilotResponseWithRappid(message);
                    hideCopilotTyping();
                    // Display the full text response in chat
                    addCopilotMessage(response.text, 'ai');
                    copilotConversationHistory.push({ role: 'assistant', content: response.text });
                    animateCopilotResponse();

                    // v5.9: Use voice_response for TTS (concise, no formatting)
                    // v5.10: Also trigger Star Wars 3D text crawl
                    animateCopilotTextCrawl(response.voice);

                    if (rappidSettings.azureTTSKey && rappidSettings.azureRegion) {
                        speakWithAzureTTS(response.voice);
                    } else {
                        speakCopilotResponse(response.voice);
                    }
                } catch (error) {
                    console.error('RAPPID response error:', error);
                    hideCopilotTyping();
                    const fallbackResponse = generateCopilotResponse(message);
                    addCopilotMessage(fallbackResponse, 'ai');
                    speakCopilotResponse(fallbackResponse);
                    animateCopilotTextCrawl(fallbackResponse); // v5.10: Text crawl for fallback
                }
            } else {
                // Use local responses
                setTimeout(() => {
                    hideCopilotTyping();
                    const response = generateCopilotResponse(message);
                    addCopilotMessage(response, 'ai');
                    copilotConversationHistory.push({ role: 'assistant', content: response });

                    // Animate copilot when responding
                    animateCopilotResponse();

                    // v5.10: Star Wars 3D text crawl
                    animateCopilotTextCrawl(response);

                    // Optionally speak the response
                    speakCopilotResponse(response);
                }, 800 + Math.random() * 700);
            }
        }

        function sendCopilotQuickMessage(message) {
            document.getElementById('copilot-chat-input').value = message;
            sendCopilotMessage();
        }

        function generateCopilotResponse(message) {
            const lowerMessage = message.toLowerCase();

            // Context-aware responses
            if (lowerMessage.includes('health') || lowerMessage.includes('hp') || lowerMessage.includes('hurt')) {
                if (gameData.player.hp < gameData.player.maxHp * 0.3) {
                    return getRandomResponse(COPILOT_RESPONSES.lowHealth);
                }
                return `Your health is ${gameData.player.hp}/${gameData.player.maxHp}. ${gameData.player.hp < gameData.player.maxHp * 0.5 ? 'Consider healing up!' : 'You\'re in good shape!'}`;
            }

            if (lowerMessage.includes('tip') || lowerMessage.includes('help') || lowerMessage.includes('advice')) {
                return getRandomResponse(COPILOT_RESPONSES.tips);
            }

            if (lowerMessage.includes('what') && (lowerMessage.includes('next') || lowerMessage.includes('do'))) {
                return getRandomResponse(COPILOT_RESPONSES.whatNext);
            }

            if (lowerMessage.includes('strong') || lowerMessage.includes('level') || lowerMessage.includes('power')) {
                return getRandomResponse(COPILOT_RESPONSES.getStronger);
            }

            if (lowerMessage.includes('enemy') || lowerMessage.includes('enemies') || lowerMessage.includes('monster')) {
                return getRandomResponse(COPILOT_RESPONSES.enemies);
            }

            if (lowerMessage.includes('hello') || lowerMessage.includes('hi') || lowerMessage.includes('hey')) {
                return getRandomResponse(COPILOT_RESPONSES.greeting);
            }

            if (lowerMessage.includes('explore') || lowerMessage.includes('where')) {
                return getRandomResponse(COPILOT_RESPONSES.exploration);
            }

            if (lowerMessage.includes('stats') || lowerMessage.includes('status')) {
                return `Stats: Combat Lvl ${gameData.skills.combat.level}, HP: ${gameData.player.hp}/${gameData.player.maxHp}, XP: ${gameData.skills.combat.xp}/${gameData.skills.combat.xpNeeded}`;
            }

            if (lowerMessage.includes('pet') || lowerMessage.includes('companion')) {
                const activePet = gameData.pets?.active;
                if (activePet) {
                    const pet = PET_TYPES[activePet];
                    return `You have ${pet.name} (${pet.icon}) as your pet companion. ${pet.abilityDesc}. You can find more pets by defeating enemies!`;
                }
                return "You don't have an active pet. Defeat enemies to find pet companions that can help you!";
            }

            // Default response
            const defaults = [
                "I'm here to help! Try asking about tips, enemies, or how to get stronger.",
                "Interesting question! I can help with game tips, enemy locations, and advice.",
                "Let me think... Try asking 'What should I do next?' or 'Give me a tip' for guidance.",
                "I'm your Copilot! Ask me about your health, enemies, or exploration tips."
            ];
            return getRandomResponse(defaults);
        }

        function getRandomResponse(responses) {
            return responses[Math.floor(Math.random() * responses.length)];
        }

        // v5.9: Simple markdown parser for chat messages
        function parseMarkdown(text) {
            if (!text) return '';

            // First, protect markdown links from URL matching
            const linkPlaceholders = [];
            let processedText = text.replace(/\[([^\]]+)\]\(([^)]+)\)/g, (match, linkText, url) => {
                const placeholder = `__LINK_${linkPlaceholders.length}__`;
                linkPlaceholders.push({ text: linkText, url: url });
                return placeholder;
            });

            // Convert plain URLs to markdown links (before escaping)
            processedText = processedText.replace(/(^|[\s(])(https?:\/\/[^\s)<]+)/g, (match, prefix, url) => {
                // Shorten URL for display
                let displayUrl = url;
                try {
                    const urlObj = new URL(url);
                    displayUrl = urlObj.hostname + (urlObj.pathname.length > 20 ? urlObj.pathname.substring(0, 20) + '...' : urlObj.pathname);
                } catch (e) {
                    displayUrl = url.length > 40 ? url.substring(0, 40) + '...' : url;
                }
                const placeholder = `__LINK_${linkPlaceholders.length}__`;
                linkPlaceholders.push({ text: displayUrl, url: url });
                return prefix + placeholder;
            });

            let html = processedText
                // Escape HTML first
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')

                // Code blocks (``` ... ```)
                .replace(/```(\w*)\n?([\s\S]*?)```/g, '<pre><code>$2</code></pre>')

                // Inline code (`code`)
                .replace(/`([^`]+)`/g, '<code>$1</code>')

                // Headers (### ## #)
                .replace(/^### (.+)$/gm, '<h3>$1</h3>')
                .replace(/^## (.+)$/gm, '<h2>$1</h2>')
                .replace(/^# (.+)$/gm, '<h1>$1</h1>')

                // Bold (**text** or __text__) - but not our placeholders
                .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')

                // Italic (*text* or _text_) - but not underscores in placeholders
                .replace(/\*([^*]+)\*/g, '<em>$1</em>')

                // Horizontal rule (---)
                .replace(/^---$/gm, '<hr>')

                // Blockquotes (> text)
                .replace(/^&gt; (.+)$/gm, '<blockquote>$1</blockquote>')

                // Unordered lists (- item)
                .replace(/^- (.+)$/gm, '<li>$1</li>')

                // Numbered lists (1. item)
                .replace(/^\d+\. (.+)$/gm, '<li>$1</li>')

                // Line breaks
                .replace(/\n\n/g, '</p><p>')
                .replace(/\n/g, '<br>');

            // Restore link placeholders
            linkPlaceholders.forEach((link, index) => {
                const placeholder = `__LINK_${index}__`;
                html = html.replace(placeholder, `<a href="${link.url}" target="_blank" rel="noopener noreferrer">${link.text}</a>`);
            });

            // Wrap consecutive <li> elements in <ul>
            html = html.replace(/(<li>.*?<\/li>)(\s*<br>)?/g, '$1');
            html = html.replace(/(<li>[\s\S]*?<\/li>)+/g, '<ul>$&</ul>');

            // Wrap in paragraph if not already wrapped
            if (!html.startsWith('<h') && !html.startsWith('<ul') && !html.startsWith('<pre') && !html.startsWith('<blockquote')) {
                html = '<p>' + html + '</p>';
            }

            // Clean up empty paragraphs
            html = html.replace(/<p><\/p>/g, '');
            html = html.replace(/<p><br><\/p>/g, '');

            return html;
        }

        function addCopilotMessage(text, sender) {
            const messagesContainer = document.getElementById('copilot-chat-messages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `copilot-message ${sender}`;

            if (sender === 'ai') {
                // Parse markdown for AI responses
                messageDiv.innerHTML = parseMarkdown(text);

                // Make sure all links open in new tab
                messageDiv.querySelectorAll('a').forEach(link => {
                    link.setAttribute('target', '_blank');
                    link.setAttribute('rel', 'noopener noreferrer');
                });
            } else {
                // Plain text for user messages
                messageDiv.textContent = text;
            }

            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        function showCopilotTyping() {
            const messagesContainer = document.getElementById('copilot-chat-messages');
            const typingDiv = document.createElement('div');
            typingDiv.id = 'copilot-typing';
            typingDiv.className = 'copilot-typing';
            typingDiv.innerHTML = '<div class="copilot-typing-dot"></div><div class="copilot-typing-dot"></div><div class="copilot-typing-dot"></div>';
            messagesContainer.appendChild(typingDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        function hideCopilotTyping() {
            const typing = document.getElementById('copilot-typing');
            if (typing) typing.remove();
        }

        function animateCopilotResponse() {
            if (!copilotMesh || !copilotMesh.userData.orb) return;

            const orb = copilotMesh.userData.orb;
            const originalScale = 1;
            let progress = 0;

            const animate = () => {
                progress += 0.08;
                if (progress > 1) return;

                const scale = originalScale + Math.sin(progress * Math.PI) * 0.3;
                orb.scale.setScalar(scale);

                if (copilotMesh.userData.light) {
                    copilotMesh.userData.light.intensity = 2 + Math.sin(progress * Math.PI * 2) * 1.5;
                }

                requestAnimationFrame(animate);
            };
            animate();
        }

        function speakCopilotResponse(text) {
            if (!copilotSynthesis) return;

            // Cancel any ongoing speech
            copilotSynthesis.cancel();

            const utterance = new SpeechSynthesisUtterance(text);
            utterance.rate = 1.0;
            utterance.pitch = 1.1;
            utterance.volume = 0.8;

            // Try to use a female voice
            const voices = copilotSynthesis.getVoices();
            const preferredVoice = voices.find(v => v.name.includes('Female') || v.name.includes('Samantha') || v.name.includes('Google'));
            if (preferredVoice) utterance.voice = preferredVoice;

            utterance.onstart = () => {
                document.getElementById('copilot-voice-indicator').classList.add('active');
            };

            utterance.onend = () => {
                document.getElementById('copilot-voice-indicator').classList.remove('active');
            };

            copilotSynthesis.speak(utterance);
        }

        // v5.9: Toggle voice input - click to start/stop
        let sttFinalTranscript = '';
        let sttAutoSend = localStorage.getItem('leviathan-stt-autosend') === 'true';

        // Initialize auto-send toggle state on load
        function initAutoSendToggle() {
            const toggle = document.getElementById('stt-auto-send-toggle');
            if (toggle) {
                toggle.checked = sttAutoSend;
            }
        }

        // Toggle auto-send setting
        function toggleAutoSend(enabled) {
            sttAutoSend = enabled;
            localStorage.setItem('leviathan-stt-autosend', enabled ? 'true' : 'false');
            console.log('Auto-send ' + (enabled ? 'enabled' : 'disabled'));
        }

        async function toggleCopilotVoice() {
            if (copilotIsListening) {
                stopCopilotVoice();
                return;
            }

            // Check if Azure Speech SDK should be used
            if (rappidSettings.azureTTSKey && rappidSettings.azureRegion) {
                await startAzureSTT();
            } else if (copilotVoiceRecognition) {
                // Fall back to browser speech recognition
                startBrowserSTT();
            } else {
                console.warn('No speech recognition available');
                alert('Speech recognition not available. Please configure Azure Speech key in RAPPID settings.');
            }
        }

        // Show/hide transcription overlay
        function showSTTOverlay(show) {
            const overlay = document.getElementById('stt-transcription-overlay');
            if (show) {
                overlay.classList.add('active');
                document.getElementById('stt-transcript-text').textContent = 'Speak now...';
                document.getElementById('stt-transcript-text').className = 'stt-transcript-text interim';
                document.getElementById('stt-status').textContent = 'Listening...';
                document.getElementById('stt-waveform').style.display = 'flex';
                document.getElementById('stt-actions').style.display = 'none';
                // Sync auto-send toggle state
                initAutoSendToggle();
            } else {
                overlay.classList.remove('active');
            }
        }

        // Update transcription display
        function updateSTTTranscript(text, isFinal) {
            const textEl = document.getElementById('stt-transcript-text');
            textEl.textContent = text || 'Speak now...';
            textEl.className = 'stt-transcript-text ' + (isFinal ? 'final' : 'interim');

            if (isFinal && text) {
                sttFinalTranscript = text;

                // Check if auto-send is enabled
                if (sttAutoSend) {
                    // Auto-send: show brief confirmation then send
                    document.getElementById('stt-status').textContent = 'Sending...';
                    document.getElementById('stt-waveform').style.display = 'none';
                    // Brief delay so user sees what was transcribed
                    setTimeout(() => {
                        sendSTTMessage();
                    }, 500);
                } else {
                    // Manual confirm: show action buttons
                    document.getElementById('stt-status').textContent = 'Ready to send';
                    document.getElementById('stt-waveform').style.display = 'none';
                    document.getElementById('stt-actions').style.display = 'flex';
                }
            }
        }

        // Send the transcribed message
        function sendSTTMessage() {
            if (sttFinalTranscript) {
                document.getElementById('copilot-chat-input').value = sttFinalTranscript;
                sendCopilotMessage();
            }
            showSTTOverlay(false);
            sttFinalTranscript = '';
        }

        // Cancel STT message
        function cancelSTTMessage() {
            showSTTOverlay(false);
            sttFinalTranscript = '';
            cleanupSTT();
        }

        // Retry STT
        function retrySTT() {
            sttFinalTranscript = '';
            showSTTOverlay(false);
            cleanupSTT();
            setTimeout(() => toggleCopilotVoice(), 200);
        }

        // Browser-based STT fallback
        function startBrowserSTT() {
            if (!copilotVoiceRecognition || copilotIsListening) return;

            try {
                copilotIsListening = true;
                document.getElementById('copilot-voice-btn').classList.add('recording');
                showSTTOverlay(true);
                copilotVoiceRecognition.start();
            } catch (e) {
                console.error('Browser STT error:', e);
                copilotIsListening = false;
                document.getElementById('copilot-voice-btn').classList.remove('recording');
                showSTTOverlay(false);
            }
        }

        // v5.9: Azure Speech-to-Text using Speech SDK with real-time transcription
        let sttInitializing = false;
        async function startAzureSTT() {
            // Prevent multiple simultaneous initializations
            if (sttInitializing || copilotIsListening) {
                console.log('STT already initializing or listening');
                return;
            }

            sttInitializing = true;
            sttFinalTranscript = '';

            try {
                // Load Speech SDK if not already loaded
                await loadSpeechSdk();

                if (!window.SpeechSDK) {
                    console.warn('Speech SDK not available, falling back to browser STT');
                    sttInitializing = false;
                    startBrowserSTT();
                    return;
                }

                // Clean up any existing recognizer first
                if (speechRecognizer) {
                    try {
                        speechRecognizer.close();
                    } catch (e) {
                        // Ignore cleanup errors
                    }
                    speechRecognizer = null;
                    // Small delay to ensure cleanup
                    await new Promise(resolve => setTimeout(resolve, 100));
                }

                // Request microphone permission first
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    // Stop the test stream immediately
                    stream.getTracks().forEach(track => track.stop());
                } catch (permError) {
                    console.error('Microphone permission denied:', permError);
                    alert('Microphone access denied. Please allow microphone access to use voice input.');
                    sttInitializing = false;
                    return;
                }

                // Show the overlay
                showSTTOverlay(true);

                // Create speech config
                const speechConfig = window.SpeechSDK.SpeechConfig.fromSubscription(
                    rappidSettings.azureTTSKey,
                    rappidSettings.azureRegion
                );
                speechConfig.speechRecognitionLanguage = 'en-US';

                // Use default microphone
                const audioConfig = window.SpeechSDK.AudioConfig.fromDefaultMicrophoneInput();

                // Create recognizer
                speechRecognizer = new window.SpeechSDK.SpeechRecognizer(speechConfig, audioConfig);

                // Set up event handlers for real-time transcription
                let interimTranscript = '';

                // Recognizing event - fires with interim results
                speechRecognizer.recognizing = (s, e) => {
                    if (e.result.reason === window.SpeechSDK.ResultReason.RecognizingSpeech) {
                        interimTranscript = e.result.text;
                        console.log('Azure STT interim:', interimTranscript);
                        updateSTTTranscript(interimTranscript, false);
                    }
                };

                // Recognized event - fires with final result
                speechRecognizer.recognized = (s, e) => {
                    if (e.result.reason === window.SpeechSDK.ResultReason.RecognizedSpeech) {
                        const finalText = e.result.text;
                        console.log('Azure STT final:', finalText);
                        if (finalText && finalText.trim()) {
                            updateSTTTranscript(finalText, true);
                            // Stop continuous recognition after getting result
                            speechRecognizer.stopContinuousRecognitionAsync();
                        }
                    } else if (e.result.reason === window.SpeechSDK.ResultReason.NoMatch) {
                        console.log('Azure STT: No speech recognized');
                        updateSTTTranscript('No speech detected. Try again.', false);
                    }
                };

                // Canceled event
                speechRecognizer.canceled = (s, e) => {
                    console.warn('Azure STT canceled:', e.reason);
                    if (e.errorDetails) {
                        console.warn('Error details:', e.errorDetails);
                    }
                    cleanupSTT();
                    showSTTOverlay(false);
                };

                // Session stopped event
                speechRecognizer.sessionStopped = (s, e) => {
                    console.log('Azure STT session stopped');
                    copilotIsListening = false;
                    document.getElementById('copilot-voice-btn').classList.remove('recording');
                };

                copilotIsListening = true;
                sttInitializing = false;
                document.getElementById('copilot-voice-btn').classList.add('recording');

                console.log('Azure STT: Starting continuous recognition...');

                // Start continuous recognition for real-time transcription
                speechRecognizer.startContinuousRecognitionAsync(
                    () => {
                        console.log('Azure STT: Continuous recognition started');
                    },
                    (error) => {
                        console.error('Azure STT start error:', error);
                        cleanupSTT();
                        showSTTOverlay(false);
                    }
                );
            } catch (error) {
                console.error('Azure STT initialization error:', error);
                sttInitializing = false;
                cleanupSTT();
                showSTTOverlay(false);

                // Fall back to browser STT
                startBrowserSTT();
            }
        }

        // Clean up STT resources
        function cleanupSTT() {
            copilotIsListening = false;
            sttInitializing = false;
            document.getElementById('copilot-voice-btn').classList.remove('recording');

            if (speechRecognizer) {
                try {
                    speechRecognizer.stopContinuousRecognitionAsync(
                        () => {
                            try { speechRecognizer.close(); } catch(e) {}
                            speechRecognizer = null;
                        },
                        () => {
                            try { speechRecognizer.close(); } catch(e) {}
                            speechRecognizer = null;
                        }
                    );
                } catch (e) {
                    try { speechRecognizer.close(); } catch(e2) {}
                    speechRecognizer = null;
                }
            }
        }

        function stopCopilotVoice() {
            // Stop Azure STT if active
            cleanupSTT();
            showSTTOverlay(false);

            // Stop browser STT if active
            if (copilotVoiceRecognition) {
                try {
                    copilotVoiceRecognition.stop();
                } catch (e) {
                    // Ignore
                }
            }
        }

        // Check for 3D copilot click
        function checkCopilotClick(event) {
            if (!copilotMesh || mode !== 'world') return false;

            const rect = renderer.domElement.getBoundingClientRect();
            const mouse = new THREE.Vector2(
                ((event.clientX - rect.left) / rect.width) * 2 - 1,
                -((event.clientY - rect.top) / rect.height) * 2 + 1
            );

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObject(copilotMesh, true);
            if (intersects.length > 0) {
                toggleCopilotChat();
                return true;
            }
            return false;
        }

        // Contextual notifications from copilot
        let lastCopilotNotification = 0;
        function triggerCopilotContextualHelp(context) {
            const now = performance.now();
            if (now - lastCopilotNotification < 30000) return; // 30 second cooldown

            let message = '';
            switch (context) {
                case 'lowHealth':
                    message = getRandomResponse(COPILOT_RESPONSES.lowHealth);
                    break;
                case 'nearEnemy':
                    if (Math.random() < 0.3) message = getRandomResponse(COPILOT_RESPONSES.nearEnemy);
                    break;
                case 'afterKill':
                    if (Math.random() < 0.2) message = getRandomResponse(COPILOT_RESPONSES.afterKill);
                    break;
            }

            if (message) {
                lastCopilotNotification = now;
                addCopilotMessage(message, 'ai');
                if (copilotChatOpen) {
                    speakCopilotResponse(message);
                }
            }
        }

        // ============================================
        // v5.7: RAPPID INTEGRATION SYSTEM
        // AI-powered responses via external endpoints
        // ============================================
        const RAPPID_STORAGE_KEY = 'leviathan-rappid-settings';
        let rappidSettings = {
            rappid: false,
            endpoints: {},
            azureTTSKey: '',
            azureRegion: '',
            ttsVoiceName: 'en-US-JennyNeural',
            version: '1.0'
        };

        function loadRappidSettings() {
            try {
                const saved = localStorage.getItem(RAPPID_STORAGE_KEY);
                if (saved) {
                    rappidSettings = JSON.parse(saved);
                    console.log('RAPPID settings loaded');
                    updateRappidUI();
                }
            } catch (e) {
                console.error('Failed to load RAPPID settings:', e);
            }
        }

        function saveRappidSettings() {
            try {
                localStorage.setItem(RAPPID_STORAGE_KEY, JSON.stringify(rappidSettings));
                console.log('RAPPID settings saved');
            } catch (e) {
                console.error('Failed to save RAPPID settings:', e);
            }
        }

        // v5.7: AI Settings Modal Functions
        function openRappidModal() {
            document.getElementById('ai-settings-modal').classList.add('active');
            updateAISettingsUI();
            // v5.14: Initialize endpoint profiles UI
            renderEndpointProfilesList();
            refreshProfileSelects();
        }

        function closeAISettingsModal() {
            document.getElementById('ai-settings-modal').classList.remove('active');
        }

        // Alias for backwards compatibility
        function closeRappidModal() {
            closeAISettingsModal();
        }

        function switchAITab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.ai-settings-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            event.target.classList.add('active');

            // Update tab content
            document.querySelectorAll('.ai-tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById('ai-tab-' + tabName).classList.add('active');
        }

        function updateAISettingsUI() {
            // Update General tab - API fields
            const activeEndpoint = getActiveEndpoint();
            if (activeEndpoint) {
                document.getElementById('ai-api-key').value = activeEndpoint.key || '';
                document.getElementById('ai-api-endpoint').value = activeEndpoint.url || '';
            }

            // Update endpoints list in General tab
            const endpointsList = document.getElementById('ai-endpoints-list');
            if (endpointsList && rappidSettings.endpoints && Object.keys(rappidSettings.endpoints).length > 0) {
                endpointsList.innerHTML = '<label style="display:block; margin: 15px 0 10px; font-size: 12px; color: #aaa;">Available Endpoints</label>';
                Object.values(rappidSettings.endpoints).forEach(endpoint => {
                    const div = document.createElement('div');
                    div.className = `ai-endpoint-card ${endpoint.active ? 'active' : ''}`;
                    div.onclick = () => { setActiveEndpoint(endpoint.id); updateAISettingsUI(); };
                    div.innerHTML = `
                        <div class="ai-endpoint-name">${endpoint.name}</div>
                        <div class="ai-endpoint-url">${endpoint.url}</div>
                        <span class="ai-endpoint-badge ${endpoint.active ? 'active' : 'inactive'}">
                            ${endpoint.active ? 'ACTIVE' : 'INACTIVE'}
                        </span>
                    `;
                    endpointsList.appendChild(div);
                });
            } else if (endpointsList) {
                endpointsList.innerHTML = '';
            }

            // Update Voice tab - TTS settings
            if (rappidSettings.azureTTSKey) {
                document.getElementById('ai-tts-key').value = rappidSettings.azureTTSKey;
            }
            if (rappidSettings.azureRegion) {
                document.getElementById('ai-tts-region').value = rappidSettings.azureRegion;
            }
            if (rappidSettings.ttsVoiceName) {
                document.getElementById('ai-tts-voice').value = rappidSettings.ttsVoiceName;
            }

            // Update Import/Export tab - endpoints preview
            const endpointsPreview = document.getElementById('ai-endpoints-preview');
            if (endpointsPreview && rappidSettings.endpoints && Object.keys(rappidSettings.endpoints).length > 0) {
                endpointsPreview.innerHTML = '';
                Object.values(rappidSettings.endpoints).forEach(endpoint => {
                    const div = document.createElement('div');
                    div.className = `ai-endpoint-card ${endpoint.active ? 'active' : ''}`;
                    div.onclick = () => { setActiveEndpoint(endpoint.id); updateAISettingsUI(); };
                    div.innerHTML = `
                        <div class="ai-endpoint-name">${endpoint.name}</div>
                        <div class="ai-endpoint-url">${endpoint.url}</div>
                        <span class="ai-endpoint-badge ${endpoint.active ? 'active' : 'inactive'}">
                            ${endpoint.active ? 'ACTIVE' : 'INACTIVE'}
                        </span>
                    `;
                    endpointsPreview.appendChild(div);
                });
            } else if (endpointsPreview) {
                endpointsPreview.innerHTML = '<div style="padding: 15px; background: rgba(0,0,0,0.3); border-radius: 8px; text-align: center; color: #888;">No endpoints configured yet</div>';
            }

            // Update connection status
            const statusDiv = document.getElementById('ai-connection-status');
            if (statusDiv) {
                if (activeEndpoint) {
                    statusDiv.innerHTML = `
                        <div style="color: #06ffa5; margin-bottom: 5px;">Connected to: ${activeEndpoint.name}</div>
                        <div style="font-size: 11px; color: #666;">${activeEndpoint.url}</div>
                    `;
                } else {
                    statusDiv.innerHTML = '<span style="color: #888;">No endpoint configured</span>';
                }
            }
        }

        function saveAISettings() {
            // Save API settings from General tab
            const apiKey = document.getElementById('ai-api-key').value;
            const apiEndpoint = document.getElementById('ai-api-endpoint').value;

            // If user entered new endpoint details, create/update a custom endpoint
            if (apiKey && apiEndpoint) {
                const customId = 'custom-' + Date.now();
                rappidSettings.endpoints = rappidSettings.endpoints || {};

                // Check if updating existing or adding new
                const activeEndpoint = getActiveEndpoint();
                if (activeEndpoint) {
                    activeEndpoint.key = apiKey;
                    activeEndpoint.url = apiEndpoint;
                } else {
                    rappidSettings.endpoints[customId] = {
                        id: customId,
                        name: 'Custom Endpoint',
                        url: apiEndpoint,
                        key: apiKey,
                        guid: 'custom-guid',
                        active: true
                    };
                }
                rappidSettings.rappid = true;
            }

            // Save Voice settings
            rappidSettings.azureTTSKey = document.getElementById('ai-tts-key').value;
            rappidSettings.azureRegion = document.getElementById('ai-tts-region').value;
            rappidSettings.ttsVoiceName = document.getElementById('ai-tts-voice').value;

            // Save companion settings
            rappidSettings.companionName = document.getElementById('ai-companion-name').value;
            rappidSettings.companionPersonality = document.getElementById('ai-companion-personality').value;
            rappidSettings.voiceEnabled = document.getElementById('ai-voice-enabled').checked;
            rappidSettings.autoSpeak = document.getElementById('ai-auto-speak').checked;
            rappidSettings.voiceInputEnabled = document.getElementById('ai-voice-input-enabled').checked;
            rappidSettings.continuousMode = document.getElementById('ai-continuous-mode').checked;
            rappidSettings.pttKey = document.getElementById('ai-ptt-key').value;

            // Save 3D view settings
            rappidSettings.primaryColor = document.getElementById('ai-primary-color').value;
            rappidSettings.glowColor = document.getElementById('ai-glow-color').value;
            rappidSettings.companionSize = document.getElementById('ai-companion-size').value;
            rappidSettings.showParticles = document.getElementById('ai-show-particles').checked;
            rappidSettings.enableGlow = document.getElementById('ai-enable-glow').checked;
            rappidSettings.followDistance = parseFloat(document.getElementById('ai-follow-distance').value);
            rappidSettings.floatHeight = parseFloat(document.getElementById('ai-float-height').value);

            saveRappidSettings();
            showAIStatusMessage('Settings saved successfully!', 'success');
            showNotification('AI Companion settings saved!');

            // Apply 3D settings immediately if companion exists
            applyCompanionSettings();
        }

        function applyCompanionSettings() {
            // Update COPILOT_CONFIG with new settings
            if (rappidSettings.followDistance) COPILOT_CONFIG.followDistance = rappidSettings.followDistance;
            if (rappidSettings.floatHeight) COPILOT_CONFIG.floatHeight = rappidSettings.floatHeight;
            if (rappidSettings.primaryColor) COPILOT_CONFIG.color = parseInt(rappidSettings.primaryColor.replace('#', '0x'));
            if (rappidSettings.glowColor) COPILOT_CONFIG.glowColor = parseInt(rappidSettings.glowColor.replace('#', '0x'));

            // Recreate mesh with new settings
            if (copilotMesh && mode === 'world') {
                createCopilotMesh();
            }
        }

        function showAIStatusMessage(message, type) {
            const statusEl = document.getElementById('ai-status-message');
            if (statusEl) {
                statusEl.textContent = message;
                statusEl.className = 'ai-status-msg ' + type;
                setTimeout(() => {
                    statusEl.textContent = '';
                    statusEl.className = 'ai-status-msg';
                }, 3000);
            }
        }

        // Alias for backwards compatibility
        function showRappidStatus(message, type) {
            showAIStatusMessage(message, type);
        }

        // Keep old updateRappidUI for backwards compatibility
        function updateRappidUI() {
            updateAISettingsUI();
        }

        // Color picker sync
        document.addEventListener('DOMContentLoaded', function() {
            // Primary color sync
            const primaryColor = document.getElementById('ai-primary-color');
            const primaryHex = document.getElementById('ai-primary-color-hex');
            if (primaryColor && primaryHex) {
                primaryColor.addEventListener('input', () => primaryHex.value = primaryColor.value);
                primaryHex.addEventListener('input', () => primaryColor.value = primaryHex.value);
            }

            // Glow color sync
            const glowColor = document.getElementById('ai-glow-color');
            const glowHex = document.getElementById('ai-glow-color-hex');
            if (glowColor && glowHex) {
                glowColor.addEventListener('input', () => glowHex.value = glowColor.value);
                glowHex.addEventListener('input', () => glowColor.value = glowHex.value);
            }
        });

        function setActiveEndpoint(endpointId) {
            Object.values(rappidSettings.endpoints).forEach(ep => {
                ep.active = ep.id === endpointId;
            });
            saveRappidSettings();
            updateRappidUI();
            showRappidStatus('Endpoint activated: ' + rappidSettings.endpoints[endpointId]?.name, 'success');
        }

        function getActiveEndpoint() {
            return Object.values(rappidSettings.endpoints).find(ep => ep.active);
        }

        function importRappidSettings(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const imported = JSON.parse(e.target.result);

                    // Validate it's a RAPPID settings file
                    if (imported.rappid === true && imported.backupType === 'RAPPID Settings Backup') {
                        rappidSettings = {
                            rappid: true,
                            backupType: imported.backupType,
                            endpoints: imported.endpoints || {},
                            azureTTSKey: imported.azureTTSKey || '',
                            azureRegion: imported.azureRegion || '',
                            ttsVoiceName: imported.ttsVoiceName || 'en-US-JennyNeural',
                            exportDate: imported.exportDate,
                            version: imported.version || '1.0'
                        };
                        saveRappidSettings();
                        updateRappidUI();
                        showRappidStatus('RAPPID settings imported successfully!', 'success');
                        showNotification('RAPPID settings imported! Copilot is now AI-powered.');
                    } else {
                        showRappidStatus('Invalid RAPPID settings file', 'error');
                    }
                } catch (error) {
                    console.error('RAPPID import error:', error);
                    showRappidStatus('Failed to import: Invalid JSON file', 'error');
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        function exportRappidSettings() {
            if (!rappidSettings.rappid) {
                showRappidStatus('No RAPPID settings to export', 'error');
                return;
            }

            const exportData = {
                rappid: true,
                backupType: 'RAPPID Settings Backup',
                endpoints: rappidSettings.endpoints,
                azureTTSKey: rappidSettings.azureTTSKey,
                azureRegion: rappidSettings.azureRegion,
                ttsVoiceName: rappidSettings.ttsVoiceName,
                exportDate: new Date().toISOString(),
                version: rappidSettings.version
            };

            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `leviathan-rappid-backup-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);
            showRappidStatus('RAPPID settings exported!', 'success');
        }

        async function testRappidConnection() {
            const endpoint = getActiveEndpoint();
            if (!endpoint) {
                showRappidStatus('No active endpoint selected', 'error');
                return;
            }

            showRappidStatus('Testing connection...', '');

            try {
                const response = await fetch(endpoint.url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-functions-key': endpoint.key
                    },
                    body: JSON.stringify({
                        message: 'Hello, this is a connection test from LEVIATHAN game.',
                        guid: endpoint.guid
                    })
                });

                if (response.ok) {
                    const data = await response.json();
                    showRappidStatus('Connection successful! Endpoint is responding.', 'success');
                    showNotification('RAPPID connection test passed!');
                } else {
                    showRappidStatus(`Connection failed: HTTP ${response.status}`, 'error');
                }
            } catch (error) {
                console.error('RAPPID connection test error:', error);
                showRappidStatus('Connection failed: Network error', 'error');
            }
        }

        function clearRappidSettings() {
            if (confirm('Are you sure you want to clear all RAPPID settings?')) {
                rappidSettings = {
                    rappid: false,
                    endpoints: {},
                    azureTTSKey: '',
                    azureRegion: '',
                    ttsVoiceName: 'en-US-JennyNeural',
                    version: '1.0'
                };
                localStorage.removeItem(RAPPID_STORAGE_KEY);
                updateRappidUI();
                showRappidStatus('RAPPID settings cleared', 'success');
            }
        }

        function showRappidStatus(message, type) {
            const statusEl = document.getElementById('rappid-status-message');
            statusEl.textContent = message;
            statusEl.className = 'rappid-status ' + type;
        }

        // v5.9: Enhanced generateCopilotResponse with RAPPID API integration
        // Uses correct API format: user_input, conversation_history, user_guid
        // Returns object with { text, voice } - text for display, voice for TTS
        async function generateCopilotResponseWithRappid(message) {
            const endpoint = getActiveEndpoint();

            // If no active RAPPID endpoint, fall back to local responses
            if (!endpoint || !endpoint.url || !endpoint.key) {
                const localResponse = generateCopilotResponse(message);
                return { text: localResponse, voice: localResponse };
            }

            try {
                // Build context from game state
                const gameContext = {
                    playerHP: gameData.player?.hp || 100,
                    playerMaxHP: gameData.player?.maxHp || 100,
                    combatLevel: gameData.skills?.combat?.level || 1,
                    currentBiome: worldState?.currentCiv?.biomeName || 'Unknown',
                    planetName: worldState?.currentCiv?.name || 'Unknown',
                    activePet: gameData.pets?.active || null,
                    inventoryItems: Object.keys(gameData.inventory || {}).length
                };

                // Build conversation history with system context
                // v5.14: Updated to reflect explorer robot probe
                const systemMessage = {
                    role: 'system',
                    content: `You are an AI companion assisting an autonomous Explorer Probe (designation: LEVIATHAN) in the game LEVIATHAN: OMNIVERSE. The probe was deployed from a spacecraft to explore alien worlds and gather resources. Current probe status: Integrity ${gameContext.playerHP}/${gameContext.playerMaxHP}, Combat Systems Level ${gameContext.combatLevel}, currently deployed on planet "${gameContext.planetName}" (${gameContext.currentBiome} biome). ${gameContext.activePet ? `A ${gameContext.activePet} drone companion is also deployed.` : 'No companion drones deployed.'} Keep responses brief, technical, and helpful (1-3 sentences). Refer to the probe as "you" or "the probe" - it is a robot, not a living being.`
                };

                // Build conversation history for API
                const conversationForApi = [systemMessage, ...copilotConversationHistory];

                const response = await fetch(endpoint.url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-functions-key': endpoint.key
                    },
                    body: JSON.stringify({
                        user_input: message,
                        conversation_history: conversationForApi,
                        user_guid: endpoint.guid || 'leviathan-game-user'
                    })
                });

                if (response.ok) {
                    const data = await response.json();
                    // v5.9: Extract both assistant_response (for display) and voice_response (for TTS)
                    const textResponse = data.assistant_response || data.response || data.message || data.reply || generateCopilotResponse(message);
                    // Use voice_response for TTS if available, otherwise fall back to text response
                    const voiceResponse = data.voice_response || textResponse;
                    return { text: textResponse, voice: voiceResponse };
                } else {
                    console.warn('RAPPID API error (status ' + response.status + '), falling back to local response');
                    const localResponse = generateCopilotResponse(message);
                    return { text: localResponse, voice: localResponse };
                }
            } catch (error) {
                console.error('RAPPID request failed:', error);
                const localResponse = generateCopilotResponse(message);
                return { text: localResponse, voice: localResponse };
            }
        }

        // Azure TTS integration using Microsoft Speech SDK
        let speechSdkLoaded = false;
        let speechSynthesizer = null;

        function loadSpeechSdk() {
            return new Promise((resolve, reject) => {
                if (speechSdkLoaded && window.SpeechSDK) {
                    resolve();
                    return;
                }

                const script = document.createElement('script');
                script.src = 'https://aka.ms/csspeech/jsbrowserpackageraw';
                script.onload = () => {
                    speechSdkLoaded = true;
                    console.log('Microsoft Speech SDK loaded');
                    resolve();
                };
                script.onerror = () => {
                    console.error('Failed to load Speech SDK');
                    reject(new Error('Speech SDK failed to load'));
                };
                document.head.appendChild(script);
            });
        }

        async function speakWithAzureTTS(text) {
            if (!rappidSettings.azureTTSKey || !rappidSettings.azureRegion) {
                // Fall back to browser TTS
                speakCopilotResponse(text);
                return;
            }

            try {
                // Load Speech SDK if not already loaded
                await loadSpeechSdk();

                if (!window.SpeechSDK) {
                    console.warn('Speech SDK not available, falling back to browser TTS');
                    speakCopilotResponse(text);
                    return;
                }

                // Cancel any existing speech
                if (speechSynthesizer) {
                    speechSynthesizer.close();
                    speechSynthesizer = null;
                }

                // Create speech config
                const speechConfig = window.SpeechSDK.SpeechConfig.fromSubscription(
                    rappidSettings.azureTTSKey,
                    rappidSettings.azureRegion
                );
                speechConfig.speechSynthesisVoiceName = rappidSettings.ttsVoiceName || 'en-US-JennyNeural';

                // Use default speaker output
                const audioConfig = window.SpeechSDK.AudioConfig.fromDefaultSpeakerOutput();

                // Create synthesizer
                speechSynthesizer = new window.SpeechSDK.SpeechSynthesizer(speechConfig, audioConfig);

                // Truncate text if too long (SDK has limits)
                const maxLength = 5000;
                const truncatedText = text.length > maxLength ? text.substring(0, maxLength) + '...' : text;

                // Show voice indicator
                const voiceIndicator = document.getElementById('copilot-voice-indicator');
                if (voiceIndicator) voiceIndicator.classList.add('active');

                // Speak the text
                speechSynthesizer.speakTextAsync(
                    truncatedText,
                    (result) => {
                        // Hide voice indicator on completion
                        if (voiceIndicator) voiceIndicator.classList.remove('active');

                        if (result.reason === window.SpeechSDK.ResultReason.SynthesizingAudioCompleted) {
                            console.log('Azure TTS completed successfully');
                        } else {
                            console.warn('Azure TTS synthesis ended with reason:', result.reason);
                        }

                        // Clean up
                        if (speechSynthesizer) {
                            speechSynthesizer.close();
                            speechSynthesizer = null;
                        }
                    },
                    (error) => {
                        console.error('Azure TTS error:', error);
                        if (voiceIndicator) voiceIndicator.classList.remove('active');

                        // Clean up
                        if (speechSynthesizer) {
                            speechSynthesizer.close();
                            speechSynthesizer = null;
                        }

                        // Fall back to browser TTS
                        speakCopilotResponse(text);
                    }
                );
            } catch (error) {
                console.error('Azure TTS error:', error);
                speakCopilotResponse(text);
            }
        }

        // Function to stop Azure TTS
        function stopAzureTTS() {
            if (speechSynthesizer) {
                speechSynthesizer.close();
                speechSynthesizer = null;
            }
            const voiceIndicator = document.getElementById('copilot-voice-indicator');
            if (voiceIndicator) voiceIndicator.classList.remove('active');
        }

        // Override sendCopilotMessage to use RAPPID when available
        const originalSendCopilotMessage = typeof sendCopilotMessage === 'function' ? sendCopilotMessage : null;

        // ============================================
        // v5.4: COMPANION EVOLUTION SYSTEM
        // ============================================
        const PET_EVOLUTIONS = {
            slime: {
                stages: [
                    { name: 'Slime Hatchling', icon: 'ðŸŸ¢', bondRequired: 0, abilities: ['regen'], statMult: 1.0 },
                    { name: 'Gel Guardian', icon: 'ðŸ§ª', bondRequired: 50, abilities: ['regen', 'shield'], statMult: 1.5 },
                    { name: 'Slime Sovereign', icon: 'ðŸ‘‘', bondRequired: 150, abilities: ['regen', 'shield', 'absorb'], statMult: 2.5 }
                ]
            },
            wisp: {
                stages: [
                    { name: 'Tiny Wisp', icon: 'âœ¨', bondRequired: 0, abilities: ['luck'], statMult: 1.0 },
                    { name: 'Bright Spirit', icon: 'ðŸ’«', bondRequired: 60, abilities: ['luck', 'illuminate'], statMult: 1.6 },
                    { name: 'Radiant Beacon', icon: 'ðŸŒŸ', bondRequired: 180, abilities: ['luck', 'illuminate', 'fortune'], statMult: 2.8 }
                ]
            },
            bat: {
                stages: [
                    { name: 'Cave Bat', icon: 'ðŸ¦‡', bondRequired: 0, abilities: ['dodge'], statMult: 1.0 },
                    { name: 'Shadow Wing', icon: 'ðŸ–¤', bondRequired: 55, abilities: ['dodge', 'swoop'], statMult: 1.4 },
                    { name: 'Vampire Lord', icon: 'ðŸ§›', bondRequired: 165, abilities: ['dodge', 'swoop', 'lifesteal'], statMult: 2.4 }
                ]
            },
            phoenix: {
                stages: [
                    { name: 'Mini Phoenix', icon: 'ðŸ”¥', bondRequired: 0, abilities: ['damage'], statMult: 1.0 },
                    { name: 'Flame Herald', icon: 'ðŸŒ‹', bondRequired: 70, abilities: ['damage', 'burn'], statMult: 1.7 },
                    { name: 'Inferno Avatar', icon: 'â˜€ï¸', bondRequired: 200, abilities: ['damage', 'burn', 'rebirth'], statMult: 3.0 }
                ]
            },
            dragon: {
                stages: [
                    { name: 'Baby Dragon', icon: 'ðŸ²', bondRequired: 0, abilities: ['attack'], statMult: 1.0 },
                    { name: 'Drake Champion', icon: 'ðŸ‰', bondRequired: 80, abilities: ['attack', 'firebreath'], statMult: 1.8 },
                    { name: 'Elder Wyrm', icon: 'ðŸ”±', bondRequired: 250, abilities: ['attack', 'firebreath', 'devastation'], statMult: 3.5 }
                ]
            },
            void: {
                stages: [
                    { name: 'Void Entity', icon: 'ðŸŒ€', bondRequired: 0, abilities: ['absorb'], statMult: 1.0 },
                    { name: 'Void Walker', icon: 'ðŸ•³ï¸', bondRequired: 100, abilities: ['absorb', 'phase'], statMult: 2.0 },
                    { name: 'Void Sovereign', icon: 'âš«', bondRequired: 300, abilities: ['absorb', 'phase', 'annihilate'], statMult: 4.0 }
                ]
            },
            celestial: {
                stages: [
                    { name: 'Celestial Star', icon: 'â­', bondRequired: 0, abilities: ['allStats'], statMult: 1.0 },
                    { name: 'Constellation Spirit', icon: 'ðŸŒŒ', bondRequired: 120, abilities: ['allStats', 'blessing'], statMult: 2.2 },
                    { name: 'Cosmic Deity', icon: 'ðŸ’Ž', bondRequired: 400, abilities: ['allStats', 'blessing', 'transcendence'], statMult: 5.0 }
                ]
            }
        };

        const EVOLUTION_ABILITIES = {
            regen: { name: 'Regeneration', desc: '+1 HP/5s', icon: 'ðŸ’š' },
            shield: { name: 'Shield Aura', desc: '+5% damage reduction', icon: 'ðŸ›¡ï¸' },
            absorb: { name: 'Soul Absorb', desc: '+25% XP gain', icon: 'ðŸ‘»' },
            luck: { name: 'Lucky Charm', desc: '+10% loot bonus', icon: 'ðŸ€' },
            illuminate: { name: 'Illuminate', desc: 'Reveals hidden items', icon: 'ðŸ’¡' },
            fortune: { name: 'Fortune', desc: '+20% rare item chance', icon: 'ðŸ’°' },
            dodge: { name: 'Evasion', desc: '+5% dodge chance', icon: 'ðŸ’¨' },
            swoop: { name: 'Swoop Attack', desc: 'Pet deals bonus damage', icon: 'ðŸŽ¯' },
            lifesteal: { name: 'Lifesteal', desc: '+8% life on hit', icon: 'ðŸ©¸' },
            damage: { name: 'Power Boost', desc: '+15% damage', icon: 'âš”ï¸' },
            burn: { name: 'Burning Aura', desc: 'Enemies take fire damage', icon: 'ðŸ”¥' },
            rebirth: { name: 'Rebirth', desc: 'Revive once per fight', icon: 'ðŸŒ…' },
            attack: { name: 'Pet Attack', desc: 'Pet attacks enemies', icon: 'ðŸ‘Š' },
            firebreath: { name: 'Fire Breath', desc: 'AoE fire damage', icon: 'ðŸ²' },
            devastation: { name: 'Devastation', desc: '+50% boss damage', icon: 'ðŸ’€' },
            phase: { name: 'Phase Shift', desc: 'Ignore 10% damage', icon: 'ðŸŒ€' },
            annihilate: { name: 'Annihilate', desc: 'Execute low HP enemies', icon: 'âš«' },
            allStats: { name: 'All Stats', desc: '+10% all stats', icon: 'âœ¨' },
            blessing: { name: 'Blessing', desc: '+15% all bonuses', icon: 'ðŸ™' },
            transcendence: { name: 'Transcendence', desc: 'Ultimate power', icon: 'ðŸŒˆ' }
        };

        function initPetEvolutionSystem() {
            if (!gameData.petEvolution) {
                gameData.petEvolution = {};
            }
            // Initialize bond for each owned pet
            if (gameData.pets?.owned) {
                for (const petId of gameData.pets.owned) {
                    if (!gameData.petEvolution[petId]) {
                        gameData.petEvolution[petId] = {
                            bond: 0,
                            stage: 0
                        };
                    }
                }
            }
        }

        function getPetEvolutionStage(petId) {
            initPetEvolutionSystem();
            return gameData.petEvolution[petId]?.stage || 0;
        }

        function getPetBond(petId) {
            initPetEvolutionSystem();
            return gameData.petEvolution[petId]?.bond || 0;
        }

        function addPetBond(petId, amount) {
            initPetEvolutionSystem();
            if (!gameData.petEvolution[petId]) {
                gameData.petEvolution[petId] = { bond: 0, stage: 0 };
            }
            gameData.petEvolution[petId].bond += amount;
            saveGameData();
        }

        function canEvolvePet(petId) {
            const evolution = PET_EVOLUTIONS[petId];
            if (!evolution) return false;

            const currentStage = getPetEvolutionStage(petId);
            const nextStage = evolution.stages[currentStage + 1];
            if (!nextStage) return false;

            const currentBond = getPetBond(petId);
            return currentBond >= nextStage.bondRequired;
        }

        function evolvePet(petId) {
            if (!canEvolvePet(petId)) return false;

            const evolution = PET_EVOLUTIONS[petId];
            const currentStage = getPetEvolutionStage(petId);
            const nextStage = evolution.stages[currentStage + 1];

            gameData.petEvolution[petId].stage = currentStage + 1;
            saveGameData();

            // Show evolution popup
            showNotification(`${nextStage.icon} ${nextStage.name} EVOLVED!`, 'success');
            AudioSystem.levelUp();

            if (particles && worldState.player) {
                particles.emit(worldState.player.position, 60, 0xaa44ff, { spread: 8, lifetime: 2000 });
            }

            updateEvolutionDisplay();
            return true;
        }

        function getCurrentPetData(petId) {
            const basePet = PET_TYPES[petId];
            if (!basePet) return null;

            const evolution = PET_EVOLUTIONS[petId];
            if (!evolution) return basePet;

            const stage = getPetEvolutionStage(petId);
            const stageData = evolution.stages[stage];

            return {
                ...basePet,
                name: stageData.name,
                icon: stageData.icon,
                abilities: stageData.abilities,
                statMult: stageData.statMult
            };
        }

        function getEvolutionBonuses() {
            const bonuses = {
                damageReduction: 0,
                xpBonus: 0,
                lootBonus: 0,
                rareChance: 0,
                dodgeBonus: 0,
                lifesteal: 0,
                damageBonus: 0,
                burnDamage: false,
                canRevive: false,
                bossDamage: 0,
                phaseShift: 0,
                executeThreshold: 0,
                allStatsBonus: 0,
                blessingMult: 1.0
            };

            if (!gameData.pets?.active) return bonuses;

            const petData = getCurrentPetData(gameData.pets.active);
            if (!petData?.abilities) return bonuses;

            for (const ability of petData.abilities) {
                switch (ability) {
                    case 'shield': bonuses.damageReduction += 0.05; break;
                    case 'absorb': bonuses.xpBonus += 0.25; break;
                    case 'luck': bonuses.lootBonus += 0.1; break;
                    case 'fortune': bonuses.rareChance += 0.2; break;
                    case 'dodge': bonuses.dodgeBonus += 0.05; break;
                    case 'lifesteal': bonuses.lifesteal += 0.08; break;
                    case 'damage': bonuses.damageBonus += 0.15; break;
                    case 'burn': bonuses.burnDamage = true; break;
                    case 'rebirth': bonuses.canRevive = true; break;
                    case 'devastation': bonuses.bossDamage += 0.5; break;
                    case 'phase': bonuses.phaseShift += 0.1; break;
                    case 'annihilate': bonuses.executeThreshold = 0.15; break;
                    case 'allStats': bonuses.allStatsBonus += 0.1; break;
                    case 'blessing': bonuses.blessingMult = 1.15; break;
                    case 'transcendence':
                        bonuses.allStatsBonus += 0.2;
                        bonuses.blessingMult = 1.3;
                        break;
                }
            }

            // Apply blessing multiplier
            bonuses.damageBonus *= bonuses.blessingMult;
            bonuses.xpBonus *= bonuses.blessingMult;
            bonuses.lootBonus *= bonuses.blessingMult;

            return bonuses;
        }

        function openEvolutionModal() {
            initPetEvolutionSystem();
            updateEvolutionDisplay();
            document.getElementById('evolution-modal').style.display = 'flex';
            AudioSystem.click();
        }

        function closeEvolutionModal() {
            document.getElementById('evolution-modal').style.display = 'none';
        }

        function updateEvolutionDisplay() {
            const container = document.getElementById('evolution-list');
            if (!container) return;

            initPetEvolutionSystem();
            const ownedPets = gameData.pets?.owned || [];

            if (ownedPets.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: #888; padding: 20px;">No companions yet. Defeat enemies to find pets!</div>';
                return;
            }

            let html = '';
            for (const petId of ownedPets) {
                const evolution = PET_EVOLUTIONS[petId];
                if (!evolution) continue;

                const currentStage = getPetEvolutionStage(petId);
                const stageData = evolution.stages[currentStage];
                const nextStage = evolution.stages[currentStage + 1];
                const bond = getPetBond(petId);
                const canEvolve = canEvolvePet(petId);
                const isActive = gameData.pets?.active === petId;

                const bondForNext = nextStage ? nextStage.bondRequired : bond;
                const bondProgress = nextStage ? Math.min(100, (bond / bondForNext) * 100) : 100;

                html += `
                    <div class="evolution-card ${canEvolve ? 'can-evolve' : ''}" style="${isActive ? 'border-color: #ff8800;' : ''}">
                        <div class="evolution-header">
                            <div class="evolution-icon">${stageData.icon}</div>
                            <div class="evolution-info">
                                <div class="evolution-name">${stageData.name}</div>
                                <div class="evolution-stage">Stage ${currentStage + 1}/${evolution.stages.length} ${isActive ? '(ACTIVE)' : ''}</div>
                            </div>
                            <div style="text-align: right;">
                                <div style="color: #ffd700; font-size: 14px;">${bond} Bond</div>
                                <div style="color: #888; font-size: 11px;">x${stageData.statMult.toFixed(1)} Stats</div>
                            </div>
                        </div>
                        <div class="evolution-bond">
                            <div style="display: flex; justify-content: space-between; font-size: 11px; color: #888; margin-bottom: 4px;">
                                <span>Bond Progress</span>
                                <span>${bond}/${bondForNext}</span>
                            </div>
                            <div class="bond-bar">
                                <div class="bond-fill" style="width: ${bondProgress}%;"></div>
                            </div>
                        </div>
                        <div class="evolution-abilities">
                            ${stageData.abilities.map(ab => {
                                const abilityData = EVOLUTION_ABILITIES[ab];
                                return `<div class="evolution-ability" title="${abilityData?.desc || ''}">${abilityData?.icon || ''} ${abilityData?.name || ab}</div>`;
                            }).join('')}
                            ${nextStage ? nextStage.abilities.filter(ab => !stageData.abilities.includes(ab)).map(ab => {
                                const abilityData = EVOLUTION_ABILITIES[ab];
                                return `<div class="evolution-ability locked" title="Unlock at next evolution">${abilityData?.icon || ''} ???</div>`;
                            }).join('') : ''}
                        </div>
                        ${nextStage ? `
                            <button class="evolve-btn" onclick="evolvePet('${petId}')" ${canEvolve ? '' : 'disabled'}>
                                ${canEvolve ? `EVOLVE to ${nextStage.name}` : `Need ${bondForNext - bond} more bond`}
                            </button>
                        ` : '<div style="text-align: center; color: #ffd700; margin-top: 10px; font-size: 12px;">MAX EVOLUTION</div>'}
                    </div>
                `;
            }

            container.innerHTML = html;
        }

        // Gain bond from various activities
        function gainPetBond(amount) {
            if (!gameData.pets?.active) return;
            addPetBond(gameData.pets.active, amount);
        }

        // ============================================
        // v5.4: WORLD EVENTS SYSTEM
        // ============================================
        const WORLD_EVENTS = {
            meteorShower: {
                name: 'Meteor Shower',
                icon: 'â˜„ï¸',
                desc: 'Meteors rain from the sky! Collect rare ores.',
                duration: 120000, // 2 minutes
                minLevel: 3,
                spawnItems: ['Meteor Ore', 'Star Fragment', 'Cosmic Dust'],
                rewards: { xp: 500, lootBonus: 0.5 },
                color: 0xff4400
            },
            treasureHunt: {
                name: 'Treasure Hunt',
                icon: 'ðŸ—ºï¸',
                desc: 'Hidden treasure chests have appeared!',
                duration: 180000, // 3 minutes
                minLevel: 2,
                spawnItems: ['Gold Chest', 'Silver Chest', 'Ancient Relic'],
                rewards: { xp: 400, goldBonus: 2.0 },
                color: 0xffd700
            },
            invasionWave: {
                name: 'Monster Invasion',
                icon: 'ðŸ‘¹',
                desc: 'Powerful monsters are invading! Defend the area!',
                duration: 150000, // 2.5 minutes
                minLevel: 5,
                spawnMobs: true,
                mobMultiplier: 2.0,
                rewards: { xp: 800, combatXp: 300 },
                color: 0xff0044
            },
            harvestMoon: {
                name: 'Harvest Moon',
                icon: 'ðŸŒ•',
                desc: 'Resources yield double during the Harvest Moon!',
                duration: 240000, // 4 minutes
                minLevel: 1,
                resourceMultiplier: 2.0,
                rewards: { xp: 300 },
                color: 0xffcc00
            },
            ancientRuins: {
                name: 'Ancient Ruins Emerge',
                icon: 'ðŸ›ï¸',
                desc: 'Ancient ruins have surfaced! Explore for rare artifacts.',
                duration: 200000, // 3.33 minutes
                minLevel: 7,
                spawnItems: ['Ancient Artifact', 'Rune Stone', 'Lost Technology'],
                rewards: { xp: 1000, rareChance: 0.3 },
                color: 0x8844aa
            },
            crystalBloom: {
                name: 'Crystal Bloom',
                icon: 'ðŸ’Ž',
                desc: 'Rare crystals are blooming across the land!',
                duration: 160000, // 2.66 minutes
                minLevel: 4,
                spawnItems: ['Rainbow Crystal', 'Pure Crystal', 'Crystal Shard'],
                rewards: { xp: 600, craftBonus: 0.5 },
                color: 0x44ffff
            },
            bossRush: {
                name: 'Boss Rush',
                icon: 'ðŸ’€',
                desc: 'Multiple bosses have spawned! Great rewards await!',
                duration: 300000, // 5 minutes
                minLevel: 10,
                spawnBosses: true,
                rewards: { xp: 2000, rareLoot: true },
                color: 0xff00ff
            },
            peacefulDay: {
                name: 'Peaceful Day',
                icon: 'ðŸŒ¸',
                desc: 'A peaceful day with bonus XP and healing!',
                duration: 180000, // 3 minutes
                minLevel: 1,
                xpMultiplier: 1.5,
                healingBonus: 2.0,
                rewards: { xp: 200 },
                color: 0xff88aa
            }
        };

        let activeWorldEvent = null;
        let worldEventEndTime = 0;
        let worldEventProgress = { collected: 0, killed: 0, explored: 0 };
        let lastWorldEventCheck = 0;
        let worldEventSpawns = [];

        function initWorldEventSystem() {
            if (!gameData.worldEvents) {
                gameData.worldEvents = {
                    completed: {},
                    totalEventsCompleted: 0,
                    lastEventTime: 0
                };
            }
        }

        function canSpawnWorldEvent() {
            if (activeWorldEvent) return false;
            if (mode !== 'world') return false;

            const timeSinceLastEvent = performance.now() - (gameData.worldEvents?.lastEventTime || 0);
            return timeSinceLastEvent > 180000; // 3 minute cooldown between events
        }

        function trySpawnWorldEvent() {
            if (!canSpawnWorldEvent()) return false;

            // 2% chance per check (checked every ~5 seconds in game loop)
            if (Math.random() > 0.02) return false;

            const playerLevel = Math.max(...Object.values(gameData.skills).map(s => s.level));
            const eligibleEvents = Object.entries(WORLD_EVENTS).filter(([id, event]) => {
                return playerLevel >= event.minLevel;
            });

            if (eligibleEvents.length === 0) return false;

            const [eventId, eventData] = eligibleEvents[Math.floor(Math.random() * eligibleEvents.length)];
            startWorldEvent(eventId);
            return true;
        }

        function startWorldEvent(eventId) {
            const eventData = WORLD_EVENTS[eventId];
            if (!eventData) return;

            activeWorldEvent = { id: eventId, ...eventData };
            worldEventEndTime = performance.now() + eventData.duration;
            worldEventProgress = { collected: 0, killed: 0, explored: 0 };
            worldEventSpawns = [];

            // Show event notification
            showWorldEventNotification(eventData);

            // Spawn event-specific content
            if (eventData.spawnItems) {
                spawnEventItems(eventData);
            }
            if (eventData.spawnMobs) {
                spawnEventMobs(eventData);
            }
            if (eventData.spawnBosses) {
                spawnEventBosses();
            }

            // Update UI
            updateEventIndicator();

            gameData.worldEvents.lastEventTime = performance.now();
            saveGameData();
        }

        function showWorldEventNotification(eventData) {
            const notification = document.createElement('div');
            notification.className = 'event-notification';
            notification.innerHTML = `
                <div class="event-title">${eventData.icon} ${eventData.name}!</div>
                <div class="event-desc">${eventData.desc}</div>
                <div class="event-timer">Duration: ${Math.floor(eventData.duration / 1000)}s</div>
            `;
            document.body.appendChild(notification);

            AudioSystem.levelUp();
            if (particles && worldState.player) {
                particles.emit(worldState.player.position, 40, eventData.color, { spread: 10, lifetime: 2000 });
            }

            setTimeout(() => notification.remove(), 5000);
        }

        function spawnEventItems(eventData) {
            if (!worldState.player) return;

            const itemCount = 5 + Math.floor(Math.random() * 5);
            for (let i = 0; i < itemCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = 20 + Math.random() * 40;
                const x = worldState.player.position.x + Math.cos(angle) * dist;
                const z = worldState.player.position.z + Math.sin(angle) * dist;

                const itemType = eventData.spawnItems[Math.floor(Math.random() * eventData.spawnItems.length)];

                // Create visual marker
                const geometry = new THREE.SphereGeometry(0.5, 8, 8);
                const material = new THREE.MeshStandardMaterial({
                    color: eventData.color,
                    emissive: eventData.color,
                    emissiveIntensity: 0.5
                });
                const marker = new THREE.Mesh(geometry, material);
                marker.position.set(x, 1, z);
                marker.userData = { type: 'eventItem', itemType, eventId: activeWorldEvent.id, hp: 1, maxHp: 1 };
                scene.add(marker);
                worldEventSpawns.push(marker);
                // Add to interactables so player can target them
                worldState.interactables.push(marker);
            }
        }

        function spawnEventMobs(eventData) {
            // Spawn extra mobs during invasion
            const extraMobs = Math.floor(10 * (eventData.mobMultiplier || 1));
            for (let i = 0; i < extraMobs; i++) {
                if (typeof spawnMob === 'function') {
                    spawnMob(true); // Force spawn stronger mobs
                }
            }
        }

        function spawnEventBosses() {
            // Spawn multiple bosses during boss rush
            for (let i = 0; i < 3; i++) {
                if (typeof spawnBoss === 'function') {
                    setTimeout(() => spawnBoss(), i * 30000);
                }
            }
        }

        function updateWorldEvent(dt, time) {
            if (!activeWorldEvent) {
                // Check for new event every 5 seconds
                if (time - lastWorldEventCheck > 5000) {
                    lastWorldEventCheck = time;
                    trySpawnWorldEvent();
                }
                return;
            }

            // Check if event ended
            if (performance.now() >= worldEventEndTime) {
                endWorldEvent();
                return;
            }

            // Update event indicator
            updateEventIndicator();

            // Apply event bonuses
            applyEventBonuses();

            // Animate event spawns
            worldEventSpawns.forEach(spawn => {
                if (spawn && spawn.position) {
                    spawn.position.y = 1 + Math.sin(time * 0.003) * 0.3;
                    spawn.rotation.y += dt * 2;
                }
            });
        }

        function applyEventBonuses() {
            // Bonuses are applied in relevant game functions
            // This function tracks active bonuses
        }

        function getWorldEventBonuses() {
            if (!activeWorldEvent) return {};

            return {
                resourceMultiplier: activeWorldEvent.resourceMultiplier || 1,
                xpMultiplier: activeWorldEvent.xpMultiplier || 1,
                lootBonus: activeWorldEvent.rewards?.lootBonus || 0,
                healingBonus: activeWorldEvent.healingBonus || 1
            };
        }

        function collectEventItem(marker) {
            if (!marker.userData.itemType) return;

            const itemType = marker.userData.itemType;
            worldEventProgress.collected++;

            // Add item to inventory
            addItem(itemType);
            showNotification(`Collected: ${itemType}`, 'success');
            AudioSystem.collect();

            if (particles) {
                particles.emit(marker.position, 15, activeWorldEvent?.color || 0xffd700);
            }

            // Remove marker
            scene.remove(marker);
            worldEventSpawns = worldEventSpawns.filter(s => s !== marker);
            worldState.interactables = worldState.interactables.filter(i => i !== marker);

            // Gain pet bond
            gainPetBond(2);
        }

        function endWorldEvent() {
            if (!activeWorldEvent) return;

            initWorldEventSystem();

            // Apply completion rewards
            const rewards = activeWorldEvent.rewards;
            if (rewards.xp) {
                addXp('combat', rewards.xp);
            }
            if (rewards.combatXp) {
                addXp('combat', rewards.combatXp);
            }

            // Track completion
            if (!gameData.worldEvents.completed[activeWorldEvent.id]) {
                gameData.worldEvents.completed[activeWorldEvent.id] = 0;
            }
            gameData.worldEvents.completed[activeWorldEvent.id]++;
            gameData.worldEvents.totalEventsCompleted++;

            showNotification(`${activeWorldEvent.icon} Event Complete! +${rewards.xp || 0} XP`, 'success');

            // Clean up event spawns
            worldEventSpawns.forEach(spawn => {
                if (spawn && spawn.parent) scene.remove(spawn);
                // Remove from interactables
                worldState.interactables = worldState.interactables.filter(i => i !== spawn);
            });
            worldEventSpawns = [];

            // Gain pet bond for completion
            gainPetBond(10);

            activeWorldEvent = null;
            updateEventIndicator();
            saveGameData();
        }

        function updateEventIndicator() {
            const indicator = document.getElementById('event-indicator');
            if (!indicator) return;

            if (!activeWorldEvent) {
                indicator.classList.remove('active');
                return;
            }

            indicator.classList.add('active');

            const timeLeft = Math.max(0, worldEventEndTime - performance.now());
            const minutes = Math.floor(timeLeft / 60000);
            const seconds = Math.floor((timeLeft % 60000) / 1000);
            const progress = (timeLeft / activeWorldEvent.duration) * 100;

            document.getElementById('event-ind-icon').textContent = activeWorldEvent.icon;
            document.getElementById('event-ind-name').textContent = activeWorldEvent.name;
            document.getElementById('event-ind-time').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            document.getElementById('event-ind-fill').style.width = `${progress}%`;
        }

        // ============================================
        // v5.4: ACHIEVEMENT SHOWCASE SYSTEM
        // ============================================
        const ACHIEVEMENT_POINTS = {
            // Basic achievements
            'first_landing': { points: 10, tier: 'common' },
            'explorer_10': { points: 25, tier: 'common' },
            'explorer_30': { points: 50, tier: 'rare' },
            'lumberjack_25': { points: 15, tier: 'common' },
            'lumberjack_100': { points: 40, tier: 'rare' },
            'miner_25': { points: 15, tier: 'common' },
            'miner_100': { points: 40, tier: 'rare' },
            'angler_10': { points: 15, tier: 'common' },
            'angler_50': { points: 35, tier: 'rare' },
            'slayer_10': { points: 20, tier: 'common' },
            'slayer_50': { points: 50, tier: 'rare' },
            'crafter_10': { points: 15, tier: 'common' },
            'crafter_50': { points: 45, tier: 'rare' },
            'max_skill': { points: 75, tier: 'legendary' },
            'playtime_1h': { points: 30, tier: 'common' },
            'survivor': { points: 35, tier: 'rare' },
            'daily_3': { points: 25, tier: 'common' },
            'daily_7': { points: 60, tier: 'rare' }
        };

        const AP_MILESTONES = [
            { points: 50, name: 'Novice Achiever', reward: { type: 'cosmetic', id: 'sparkle' } },
            { points: 100, name: 'Rising Star', reward: { type: 'xpBonus', value: 0.05 } },
            { points: 200, name: 'Accomplished', reward: { type: 'cosmetic', id: 'aura_blue' } },
            { points: 350, name: 'Elite Achiever', reward: { type: 'lootBonus', value: 0.1 } },
            { points: 500, name: 'Master Achiever', reward: { type: 'cosmetic', id: 'aura_gold' } },
            { points: 750, name: 'Legendary Status', reward: { type: 'allBonus', value: 0.1 } },
            { points: 1000, name: 'Achievement God', reward: { type: 'cosmetic', id: 'aura_rainbow' } }
        ];

        const COSMETIC_EFFECTS = {
            sparkle: { name: 'Sparkle Trail', desc: 'Leave sparkles as you move', icon: 'âœ¨' },
            aura_blue: { name: 'Blue Aura', desc: 'Mystical blue glow around player', icon: 'ðŸ’™' },
            aura_gold: { name: 'Golden Aura', desc: 'Prestigious golden glow', icon: 'ðŸ’›' },
            aura_rainbow: { name: 'Rainbow Aura', desc: 'Ultimate rainbow effect', icon: 'ðŸŒˆ' }
        };

        function initAchievementShowcase() {
            if (!gameData.achievementShowcase) {
                gameData.achievementShowcase = {
                    activeCosmetic: null,
                    unlockedCosmetics: [],
                    bonuses: {
                        xpBonus: 0,
                        lootBonus: 0,
                        allBonus: 0
                    }
                };
            }
        }

        function calculateTotalAP() {
            let total = 0;
            for (const [achId, achPoints] of Object.entries(ACHIEVEMENT_POINTS)) {
                if (gameData.achievements[achId]) {
                    total += achPoints.points;
                }
            }
            return total;
        }

        function getCurrentMilestone() {
            const totalAP = calculateTotalAP();
            let current = null;
            let next = AP_MILESTONES[0];

            for (let i = 0; i < AP_MILESTONES.length; i++) {
                if (totalAP >= AP_MILESTONES[i].points) {
                    current = AP_MILESTONES[i];
                    next = AP_MILESTONES[i + 1] || null;
                } else {
                    break;
                }
            }

            return { current, next };
        }

        function checkMilestoneRewards() {
            initAchievementShowcase();
            const totalAP = calculateTotalAP();

            for (const milestone of AP_MILESTONES) {
                if (totalAP >= milestone.points) {
                    const reward = milestone.reward;

                    if (reward.type === 'cosmetic') {
                        if (!gameData.achievementShowcase.unlockedCosmetics.includes(reward.id)) {
                            gameData.achievementShowcase.unlockedCosmetics.push(reward.id);
                            showNotification(`Cosmetic Unlocked: ${COSMETIC_EFFECTS[reward.id]?.name}!`, 'success');
                        }
                    } else if (reward.type === 'xpBonus') {
                        gameData.achievementShowcase.bonuses.xpBonus = Math.max(
                            gameData.achievementShowcase.bonuses.xpBonus,
                            reward.value
                        );
                    } else if (reward.type === 'lootBonus') {
                        gameData.achievementShowcase.bonuses.lootBonus = Math.max(
                            gameData.achievementShowcase.bonuses.lootBonus,
                            reward.value
                        );
                    } else if (reward.type === 'allBonus') {
                        gameData.achievementShowcase.bonuses.allBonus = Math.max(
                            gameData.achievementShowcase.bonuses.allBonus,
                            reward.value
                        );
                    }
                }
            }

            saveGameData();
        }

        function getShowcaseBonuses() {
            initAchievementShowcase();
            return {
                xpBonus: gameData.achievementShowcase.bonuses?.xpBonus || 0,
                lootBonus: gameData.achievementShowcase.bonuses?.lootBonus || 0,
                allBonus: gameData.achievementShowcase.bonuses?.allBonus || 0
            };
        }

        function setActiveCosmetic(cosmeticId) {
            initAchievementShowcase();
            if (cosmeticId && !gameData.achievementShowcase.unlockedCosmetics.includes(cosmeticId)) {
                return false;
            }

            gameData.achievementShowcase.activeCosmetic = cosmeticId;
            saveGameData();
            updateShowcaseDisplay();

            if (cosmeticId) {
                const cosmetic = COSMETIC_EFFECTS[cosmeticId];
                showNotification(`Cosmetic equipped: ${cosmetic?.name}`, 'info');
            } else {
                showNotification('Cosmetic removed', 'info');
            }

            return true;
        }

        function openShowcaseModal() {
            initAchievementShowcase();
            checkMilestoneRewards();
            updateShowcaseDisplay();
            document.getElementById('showcase-modal').style.display = 'flex';
            AudioSystem.click();
        }

        function closeShowcaseModal() {
            document.getElementById('showcase-modal').style.display = 'none';
        }

        function updateShowcaseDisplay() {
            const totalAP = calculateTotalAP();
            const milestones = getCurrentMilestone();

            document.getElementById('total-ap').textContent = totalAP;

            if (milestones.next) {
                document.getElementById('next-milestone-name').textContent =
                    `${milestones.next.name} (${milestones.next.points} AP)`;
                const progress = ((totalAP - (milestones.current?.points || 0)) /
                    (milestones.next.points - (milestones.current?.points || 0))) * 100;
                document.getElementById('milestone-progress').style.width = `${Math.min(100, progress)}%`;
            } else {
                document.getElementById('next-milestone-name').textContent = 'All milestones complete!';
                document.getElementById('milestone-progress').style.width = '100%';
            }

            // Active cosmetic
            const activeCosmetic = gameData.achievementShowcase?.activeCosmetic;
            document.getElementById('active-cosmetic').textContent =
                activeCosmetic ? COSMETIC_EFFECTS[activeCosmetic]?.name : 'None';

            // Render badges
            const container = document.getElementById('showcase-badges');
            let html = '';

            // Cosmetics section
            html += '<div style="grid-column: 1 / -1; font-weight: bold; color: #aa44ff; margin: 10px 0;">Cosmetics</div>';
            for (const [cosId, cosmetic] of Object.entries(COSMETIC_EFFECTS)) {
                const unlocked = gameData.achievementShowcase?.unlockedCosmetics?.includes(cosId);
                const isActive = activeCosmetic === cosId;
                html += `
                    <div class="showcase-badge ${unlocked ? 'earned' : ''} ${isActive ? 'legendary' : ''}"
                         onclick="${unlocked ? `setActiveCosmetic('${isActive ? '' : cosId}')` : ''}"
                         title="${unlocked ? cosmetic.desc : 'Locked - earn more AP!'}">
                        <div class="showcase-badge-icon">${cosmetic.icon}</div>
                        <div class="showcase-badge-name">${unlocked ? cosmetic.name : '???'}</div>
                    </div>
                `;
            }

            // Achievements section
            html += '<div style="grid-column: 1 / -1; font-weight: bold; color: #ffd700; margin: 10px 0;">Achievements</div>';
            for (const [achId, achData] of Object.entries(ACHIEVEMENT_POINTS)) {
                const achievement = ACHIEVEMENTS[achId];
                if (!achievement) continue;

                const unlocked = gameData.achievements[achId];
                const tierClass = achData.tier === 'legendary' ? 'legendary' :
                                 achData.tier === 'rare' ? 'rare' : '';

                html += `
                    <div class="showcase-badge ${unlocked ? 'earned' : ''} ${unlocked && tierClass}"
                         title="${achievement.desc} (${achData.points} AP)">
                        <div class="showcase-badge-icon">${achievement.icon}</div>
                        <div class="showcase-badge-name">${unlocked ? achievement.name : '???'}</div>
                        ${unlocked ? `<div style="font-size: 9px; color: #ffd700;">+${achData.points} AP</div>` : ''}
                    </div>
                `;
            }

            container.innerHTML = html;
        }

        // Apply cosmetic effect visuals
        let lastCosmeticUpdate = 0;
        function updateCosmeticEffects(time) {
            if (!worldState.player) return;

            const activeCosmetic = gameData.achievementShowcase?.activeCosmetic;
            if (!activeCosmetic) return;

            if (time - lastCosmeticUpdate < 100) return;
            lastCosmeticUpdate = time;

            if (activeCosmetic === 'sparkle' && particles) {
                particles.emit(worldState.player.position, 2, 0xffffff, { spread: 1, lifetime: 500 });
            } else if (activeCosmetic.startsWith('aura_') && particles) {
                const colors = {
                    aura_blue: 0x4488ff,
                    aura_gold: 0xffd700,
                    aura_rainbow: Math.random() > 0.5 ? 0xff4488 : (Math.random() > 0.5 ? 0x44ff88 : 0x4488ff)
                };
                particles.emit(worldState.player.position, 1, colors[activeCosmetic] || 0xffffff, { spread: 2, lifetime: 800 });
            }
        }

        // v5.0: Dynamic Weather System
        const WEATHER_TYPES = {
            clear: {
                name: 'Clear',
                icon: 'â˜€ï¸',
                fogDensity: 1.0,
                lightIntensity: 1.0,
                moveSpeedMod: 1.0,
                particleType: null
            },
            rain: {
                name: 'Rain',
                icon: 'ðŸŒ§ï¸',
                fogDensity: 0.7,
                lightIntensity: 0.6,
                moveSpeedMod: 0.9,
                particleType: 'rain',
                particleColor: 0x6688aa
            },
            storm: {
                name: 'Storm',
                icon: 'â›ˆï¸',
                fogDensity: 0.5,
                lightIntensity: 0.4,
                moveSpeedMod: 0.8,
                particleType: 'rain',
                particleColor: 0x445566,
                lightning: true
            },
            fog: {
                name: 'Fog',
                icon: 'ðŸŒ«ï¸',
                fogDensity: 0.3,
                lightIntensity: 0.7,
                moveSpeedMod: 0.95,
                particleType: null
            },
            snow: {
                name: 'Snow',
                icon: 'â„ï¸',
                fogDensity: 0.6,
                lightIntensity: 0.8,
                moveSpeedMod: 0.85,
                particleType: 'snow',
                particleColor: 0xffffff
            },
            sandstorm: {
                name: 'Sandstorm',
                icon: 'ðŸœï¸',
                fogDensity: 0.4,
                lightIntensity: 0.5,
                moveSpeedMod: 0.75,
                particleType: 'sand',
                particleColor: 0xddbb88
            }
        };

        const BIOME_WEATHER = {
            Terra: ['clear', 'rain', 'fog'],
            Forest: ['clear', 'rain', 'fog'],
            Desert: ['clear', 'sandstorm'],
            Ice: ['clear', 'snow', 'storm'],
            Volcanic: ['clear', 'fog'],
            Ocean: ['clear', 'rain', 'storm'],
            Alien: ['clear', 'fog', 'storm'],
            Crystal: ['clear', 'fog']
        };

        let currentWeather = 'clear';
        let weatherTransition = 0;
        let weatherParticles = [];
        let lastLightningTime = 0;
        let weatherChangeTime = 0;

        function initWeatherSystem() {
            currentWeather = 'clear';
            weatherParticles = [];
            weatherChangeTime = performance.now() + 60000 + Math.random() * 120000; // 1-3 min initial
        }

        function updateWeather(dt, time) {
            if (!activeCiv || mode !== 'world') return;

            // Check for weather change
            if (time > weatherChangeTime) {
                changeWeather();
                weatherChangeTime = time + 60000 + Math.random() * 180000; // 1-4 min between changes
            }

            const weather = WEATHER_TYPES[currentWeather];
            if (!weather) return;

            // Update fog based on weather
            if (scene.fog) {
                const targetNear = 20 * weather.fogDensity;
                const targetFar = 120 * weather.fogDensity;
                scene.fog.near += (targetNear - scene.fog.near) * dt * 0.5;
                scene.fog.far += (targetFar - scene.fog.far) * dt * 0.5;
            }

            // Update light intensity
            if (worldState.sun) {
                const baseIntensity = Math.max(0.1, Math.sin(worldState.timeOfDay * Math.PI * 2)) * 1.2;
                worldState.sun.intensity = baseIntensity * weather.lightIntensity;
            }

            // Spawn weather particles
            if (weather.particleType && worldState.player) {
                spawnWeatherParticles(weather, dt);
            }

            // Update weather particles
            updateWeatherParticles(dt);

            // Lightning effect
            if (weather.lightning && time - lastLightningTime > 3000 + Math.random() * 7000) {
                if (Math.random() < 0.3) {
                    triggerLightning();
                    lastLightningTime = time;
                }
            }
        }

        function changeWeather() {
            if (!activeCiv) return;

            const biomeWeathers = BIOME_WEATHER[activeCiv.biome] || ['clear'];
            const newWeather = biomeWeathers[Math.floor(Math.random() * biomeWeathers.length)];

            if (newWeather !== currentWeather) {
                currentWeather = newWeather;
                const weather = WEATHER_TYPES[newWeather];
                showNotification(`Weather: ${weather.icon} ${weather.name}`, 'info');
                updateWeatherUI();
            }
        }

        function updateWeatherUI() {
            const weather = WEATHER_TYPES[currentWeather];
            if (!weather) return;

            const iconEl = document.getElementById('weather-icon');
            const nameEl = document.getElementById('weather-name');
            const effectEl = document.getElementById('weather-effect');

            if (iconEl) iconEl.textContent = weather.icon;
            if (nameEl) nameEl.textContent = weather.name;

            // Show speed effect if not 100%
            if (effectEl) {
                const speedPct = Math.round(weather.moveSpeedMod * 100);
                effectEl.textContent = speedPct < 100 ? `Speed: ${speedPct}%` : '';
            }
        }

        function spawnWeatherParticles(weather, dt) {
            const spawnRate = weather.particleType === 'rain' ? 50 : 20;
            const spawnCount = Math.floor(spawnRate * dt);

            for (let i = 0; i < spawnCount; i++) {
                const x = worldState.player.position.x + (Math.random() - 0.5) * 40;
                const z = worldState.player.position.z + (Math.random() - 0.5) * 40;
                const y = worldState.player.position.y + 20 + Math.random() * 10;

                weatherParticles.push({
                    x, y, z,
                    vx: (Math.random() - 0.5) * (weather.particleType === 'sand' ? 5 : 0.5),
                    vy: weather.particleType === 'snow' ? -3 - Math.random() * 2 : -15 - Math.random() * 10,
                    vz: (Math.random() - 0.5) * (weather.particleType === 'sand' ? 5 : 0.5),
                    life: 3,
                    color: weather.particleColor,
                    type: weather.particleType
                });
            }

            // Limit particle count
            if (weatherParticles.length > 500) {
                weatherParticles = weatherParticles.slice(-400);
            }
        }

        function updateWeatherParticles(dt) {
            weatherParticles = weatherParticles.filter(p => {
                p.x += p.vx * dt;
                p.y += p.vy * dt;
                p.z += p.vz * dt;
                p.life -= dt;

                // Draw particle (simple point)
                if (p.life > 0 && particles && worldState.player) {
                    const dist = Math.sqrt(
                        Math.pow(p.x - worldState.player.position.x, 2) +
                        Math.pow(p.z - worldState.player.position.z, 2)
                    );
                    if (dist < 30 && Math.random() < 0.1) {
                        particles.emit(
                            { x: p.x, y: p.y, z: p.z },
                            1,
                            p.color,
                            { spread: 0.1, lifetime: 100, size: p.type === 'snow' ? 0.15 : 0.05 }
                        );
                    }
                }

                return p.life > 0 && p.y > -10;
            });
        }

        function triggerLightning() {
            // Flash screen white briefly
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                background: white; opacity: 0.8; pointer-events: none; z-index: 100;
            `;
            document.body.appendChild(overlay);

            setTimeout(() => {
                overlay.style.opacity = '0.3';
                setTimeout(() => {
                    overlay.remove();
                }, 100);
            }, 50);

            // Thunder sound
            if (AudioSystem.enabled && AudioSystem.ctx) {
                const osc = AudioSystem.ctx.createOscillator();
                const gain = AudioSystem.ctx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(80, AudioSystem.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(20, AudioSystem.ctx.currentTime + 0.5);
                gain.gain.setValueAtTime(0.3, AudioSystem.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, AudioSystem.ctx.currentTime + 0.8);
                osc.connect(gain);
                gain.connect(AudioSystem.ctx.destination);
                osc.start();
                osc.stop(AudioSystem.ctx.currentTime + 0.8);
            }

            screenShake(0.8);
        }

        function getWeatherSpeedMod() {
            const weather = WEATHER_TYPES[currentWeather];
            return weather ? weather.moveSpeedMod : 1.0;
        }

        function updateStatsDisplay() {
            const s = gameData.statistics;

            document.getElementById('stat-planets').textContent = `${gameData.visitedPlanets.length} / ${CONFIG.NUM_CIVS}`;

            const total = Math.floor(gameData.playtime);
            const hours = Math.floor(total / 3600);
            const mins = Math.floor((total % 3600) / 60);
            document.getElementById('stat-playtime').textContent = `${hours}h ${mins}m`;

            document.getElementById('stat-trees').textContent = s.treesChopped || 0;
            document.getElementById('stat-ore').textContent = s.oresMined || 0;
            document.getElementById('stat-fish').textContent = s.fishCaught || 0;
            document.getElementById('stat-mobs').textContent = s.mobsKilled || 0;
            document.getElementById('stat-crafted').textContent = s.itemsCrafted || 0;

            // v4.2: Display POIs discovered and player rank
            const poisEl = document.getElementById('stat-pois');
            if (poisEl) poisEl.textContent = s.poisDiscovered || 0;

            const rankEl = document.getElementById('stat-rank');
            if (rankEl) {
                const rank = getPlayerRank();
                rankEl.textContent = rank.title;
                rankEl.style.color = rank.color;
            }

            const pointsEl = document.getElementById('stat-points');
            if (pointsEl) pointsEl.textContent = calculatePlayerPoints();

            // v4.2: Display special titles
            const titlesEl = document.getElementById('special-titles');
            if (titlesEl) {
                const titles = getSpecialTitles();
                if (titles.length > 0) {
                    titlesEl.innerHTML = titles.map(t =>
                        `<span style="color:${t.color}">${t.name}</span>`
                    ).join(' | ');
                } else {
                    titlesEl.innerHTML = '<span style="color:#666">None yet</span>';
                }
            }

            // Render achievements
            const achList = document.getElementById('achievements-list');
            if (achList) {
                achList.innerHTML = '';
                for (const [id, ach] of Object.entries(ACHIEVEMENTS)) {
                    const unlocked = gameData.achievements[id];
                    const div = document.createElement('div');
                    div.className = `ach-item ${unlocked ? 'unlocked' : 'locked'}`;
                    div.innerHTML = `<span class="ach-badge">${ach.icon}</span><span>${ach.name}</span>`;
                    div.title = ach.desc;
                    achList.appendChild(div);
                }
            }

            // v4.4: Render leaderboard
            const lbList = document.getElementById('leaderboard-list');
            if (lbList) {
                const lb = getLeaderboardPosition();
                lbList.innerHTML = lb.nearby.map((p, i) => {
                    const isYou = p.name === 'YOU';
                    const bgColor = isYou ? 'rgba(255,215,0,0.2)' : 'transparent';
                    const textColor = isYou ? '#ffd700' : '#aaa';
                    const rank = lb.position - (lb.nearby.indexOf(lb.nearby.find(x => x.name === 'YOU'))) + i;
                    return `<div style="display: flex; justify-content: space-between; padding: 4px 8px; margin: 2px 0; background: ${bgColor}; border-radius: 4px;">
                        <span style="color: ${textColor};">#${rank} ${p.name}</span>
                        <span style="color: #888;">${p.points.toLocaleString()} pts</span>
                    </div>`;
                }).join('');
            }

            // v4.4: Render prestige info
            const prestigeLevel = gameData.prestige?.level || 0;
            const xpMult = gameData.prestige?.bonuses?.xpMultiplier || 1.0;
            const lifetimePoints = gameData.prestige?.totalLifetimePoints || 0;

            document.getElementById('prestige-level').textContent = prestigeLevel;
            document.getElementById('prestige-xp').textContent = `x${xpMult.toFixed(1)}`;
            document.getElementById('prestige-lifetime').textContent = lifetimePoints.toLocaleString();

            const progressEl = document.getElementById('prestige-progress');
            const prestigeBtn = document.getElementById('prestige-btn');
            const nextLevel = PRESTIGE_LEVELS[prestigeLevel + 1];

            if (nextLevel) {
                const currentPts = calculatePlayerPoints();
                const progress = Math.min(100, (currentPts / nextLevel.required) * 100);
                progressEl.innerHTML = `Next prestige: ${currentPts.toLocaleString()} / ${nextLevel.required.toLocaleString()} pts (${progress.toFixed(1)}%)`;

                if (canPrestige()) {
                    prestigeBtn.style.display = 'block';
                } else {
                    prestigeBtn.style.display = 'none';
                }
            } else {
                progressEl.innerHTML = `<span style="color: #aa44ff;">MAX PRESTIGE REACHED!</span>`;
                prestigeBtn.style.display = 'none';
            }
        }

        // --- DATA PERSISTENCE ---
        function loadGameData() {
            try {
                const saved = localStorage.getItem(APP_NAME);
                if (saved) {
                    const parsed = JSON.parse(saved);
                    // Merge with defaults to handle version updates
                    gameData = { ...gameData, ...parsed };
                    // Ensure nested objects exist
                    gameData.skills = { ...gameData.skills, ...parsed.skills };
                    gameData.player = { ...gameData.player, ...parsed.player };
                    gameData.statistics = { ...gameData.statistics, ...parsed.statistics };
                    console.log('Game data loaded successfully');
                }
            } catch (e) {
                console.error('Failed to load game data:', e);
            }
        }

        function saveGameData() {
            try {
                gameData.lastPlayed = new Date().toISOString();
                localStorage.setItem(APP_NAME, JSON.stringify(gameData));
                console.log('Game saved');
            } catch (e) {
                console.error('Failed to save game data:', e);
            }
        }

        function exportData() {
            const dataStr = JSON.stringify(gameData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `${APP_NAME}-save-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);
            showNotification('Game exported successfully!');
        }

        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const imported = JSON.parse(e.target.result);
                    if (imported.version) {
                        gameData = { ...gameData, ...imported };
                        saveGameData();
                        showNotification('Save imported! Refreshing...');
                        setTimeout(() => location.reload(), 1500);
                    } else {
                        alert('Invalid save file format');
                    }
                } catch (error) {
                    alert('Failed to import: Invalid JSON file');
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        // v4.6: Quick save function
        function quickSave() {
            saveGameData();
            document.getElementById('last-save-time').textContent = new Date().toLocaleString();
            showNotification('Game saved!');
        }

        // v4.7: Session Rewards System
        let pendingSessionReward = null;

        function checkSessionRewards() {
            if (!gameData.lastPlayed) return null;

            const lastPlayed = new Date(gameData.lastPlayed);
            const now = new Date();
            const hoursAway = Math.min(
                (now - lastPlayed) / (1000 * 60 * 60),
                SESSION_REWARDS.maxOfflineHours
            );

            // Find the best applicable tier
            let bestTier = null;
            for (const tier of SESSION_REWARDS.tiers) {
                if (hoursAway >= tier.minHours) {
                    bestTier = tier;
                }
            }

            if (bestTier) {
                return {
                    tier: bestTier,
                    hoursAway: Math.floor(hoursAway),
                    minutesAway: Math.floor((hoursAway % 1) * 60)
                };
            }
            return null;
        }

        function showWelcomeBackModal(reward) {
            pendingSessionReward = reward;

            document.getElementById('welcome-back-message').textContent = reward.tier.message;

            const timeText = reward.hoursAway > 0
                ? `You were away for ${reward.hoursAway}h ${reward.minutesAway}m`
                : `You were away for ${reward.minutesAway}m`;
            document.getElementById('welcome-back-time').textContent = timeText;

            // Build rewards list
            const rewardsList = document.getElementById('welcome-back-rewards-list');
            let html = '';
            html += `<div style="color: #ffd700; margin-bottom: 8px;">+${reward.tier.xpBonus} XP (all skills)</div>`;
            for (const [item, count] of Object.entries(reward.tier.resources)) {
                const icon = ITEMS[item]?.icon || 'ðŸ“¦';
                html += `<div style="color: #aaf; margin-bottom: 4px;">${icon} ${count}x ${item}</div>`;
            }
            rewardsList.innerHTML = html;

            document.getElementById('welcome-back-modal').style.display = 'flex';
            AudioSystem.levelUp();
        }

        function claimWelcomeBackRewards() {
            if (!pendingSessionReward) return;

            const reward = pendingSessionReward;

            // Grant XP to all skills
            Object.keys(gameData.skills).forEach(skill => {
                addXp(skill, Math.floor(reward.tier.xpBonus / Object.keys(gameData.skills).length));
            });

            // Grant resources
            for (const [item, count] of Object.entries(reward.tier.resources)) {
                for (let i = 0; i < count; i++) {
                    addItem(item);
                }
            }

            // Track the claim
            gameData.statistics.sessionRewardsClaimed = (gameData.statistics.sessionRewardsClaimed || 0) + 1;

            document.getElementById('welcome-back-modal').style.display = 'none';
            showNotification('Rewards claimed! Welcome back!', 'success');
            AudioSystem.collect();

            pendingSessionReward = null;
            saveGameData();
        }

        // v5.7: Secondary menu toggle
        function toggleSecondaryMenu() {
            const menu = document.getElementById('menu-secondary');
            menu.classList.toggle('show');
        }

        // Close secondary menu when clicking outside
        document.addEventListener('click', function(e) {
            const menu = document.getElementById('menu-secondary');
            const toggle = document.querySelector('.menu-toggle');
            if (menu && toggle && !menu.contains(e.target) && !toggle.contains(e.target)) {
                menu.classList.remove('show');
            }
        });

        // v4.6: Settings Modal Functions
        function showSettingsModal() {
            // Sync UI with current settings
            const s = gameData.settings || {};
            document.getElementById('volume-slider').value = s.masterVolume || 30;
            document.getElementById('volume-display').textContent = (s.masterVolume || 30) + '%';
            updateToggleBtn('sfx-toggle', s.sfxEnabled !== false);
            updateToggleBtn('ambient-toggle', s.ambientEnabled !== false);
            updateToggleBtn('shadow-toggle', s.shadowsEnabled !== false);
            updateToggleBtn('shake-toggle', s.screenShakeEnabled !== false);
            updateToggleBtn('hints-toggle', s.hintsEnabled !== false);
            document.getElementById('particle-quality').value = s.particleQuality || 'high';
            document.getElementById('last-save-time').textContent = gameData.lastPlayed ? new Date(gameData.lastPlayed).toLocaleString() : 'Never';
            document.getElementById('settings-modal').style.display = 'flex';
        }

        function closeSettingsModal() {
            document.getElementById('settings-modal').style.display = 'none';
            saveGameData();
        }

        function updateToggleBtn(id, isOn) {
            const btn = document.getElementById(id);
            if (isOn) {
                btn.textContent = 'ON';
                btn.classList.remove('off');
            } else {
                btn.textContent = 'OFF';
                btn.classList.add('off');
            }
        }

        function setMasterVolume(val) {
            gameData.settings = gameData.settings || {};
            gameData.settings.masterVolume = parseInt(val);
            AudioSystem.masterVolume = val / 100;
            document.getElementById('volume-display').textContent = val + '%';
        }

        function toggleSFX() {
            gameData.settings = gameData.settings || {};
            gameData.settings.sfxEnabled = !gameData.settings.sfxEnabled;
            AudioSystem.enabled = gameData.settings.sfxEnabled;
            updateToggleBtn('sfx-toggle', gameData.settings.sfxEnabled);
        }

        function toggleAmbient() {
            gameData.settings = gameData.settings || {};
            gameData.settings.ambientEnabled = !gameData.settings.ambientEnabled;
            if (gameData.settings.ambientEnabled) {
                if (mode === 'world' && activeCiv) AudioSystem.startAmbient(activeCiv.biome);
            } else {
                AudioSystem.stopAmbient();
            }
            updateToggleBtn('ambient-toggle', gameData.settings.ambientEnabled);
        }

        function setParticleQuality(quality) {
            gameData.settings = gameData.settings || {};
            gameData.settings.particleQuality = quality;
            // Adjust particle limits
            if (particles) {
                particles.maxParticles = quality === 'high' ? 100 : quality === 'medium' ? 50 : 25;
            }
            if (envParticles) {
                envParticles.maxParticles = quality === 'high' ? 60 : quality === 'medium' ? 30 : 15;
            }
        }

        function toggleShadows() {
            gameData.settings = gameData.settings || {};
            gameData.settings.shadowsEnabled = !gameData.settings.shadowsEnabled;
            renderer.shadowMap.enabled = gameData.settings.shadowsEnabled;
            updateToggleBtn('shadow-toggle', gameData.settings.shadowsEnabled);
        }

        function toggleScreenShake() {
            gameData.settings = gameData.settings || {};
            gameData.settings.screenShakeEnabled = !gameData.settings.screenShakeEnabled;
            updateToggleBtn('shake-toggle', gameData.settings.screenShakeEnabled);
        }

        function toggleHints() {
            gameData.settings = gameData.settings || {};
            gameData.settings.hintsEnabled = !gameData.settings.hintsEnabled;
            updateToggleBtn('hints-toggle', gameData.settings.hintsEnabled);
        }

        // v4.6: Apply settings on load
        function applySettings() {
            const s = gameData.settings || {};
            AudioSystem.masterVolume = (s.masterVolume || 30) / 100;
            AudioSystem.enabled = s.sfxEnabled !== false;
            if (particles) {
                particles.maxParticles = s.particleQuality === 'high' ? 100 : s.particleQuality === 'medium' ? 50 : 25;
            }
            if (envParticles) {
                envParticles.maxParticles = s.particleQuality === 'high' ? 60 : s.particleQuality === 'medium' ? 30 : 15;
            }
        }

        function closeModal() {
            document.getElementById('settings-modal').style.display = 'none';
        }

        // v4.3: Notification queue to prevent stacking
        const notificationQueue = [];
        let notificationActive = false;
        const MAX_VISIBLE_NOTIFICATIONS = 3;
        let visibleNotifications = [];

        function showNotification(message, type = 'success') {
            // Add to queue
            notificationQueue.push({ message, type });
            processNotificationQueue();
        }

        function processNotificationQueue() {
            // Remove expired notifications
            visibleNotifications = visibleNotifications.filter(n => n.element.parentNode);

            // Process queue while under limit
            while (notificationQueue.length > 0 && visibleNotifications.length < MAX_VISIBLE_NOTIFICATIONS) {
                const { message, type } = notificationQueue.shift();
                displayNotification(message, type);
            }
        }

        function displayNotification(message, type) {
            const notif = document.createElement('div');
            notif.className = 'notification';
            notif.textContent = message;

            // Position based on how many are currently visible
            const offset = visibleNotifications.length * 50;
            notif.style.top = (100 + offset) + 'px';

            if (type === 'error') {
                notif.style.background = 'rgba(100, 0, 0, 0.9)';
                notif.style.borderColor = '#f00';
                notif.style.color = '#f00';
            } else if (type === 'warning') {
                notif.style.background = 'rgba(100, 80, 0, 0.9)';
                notif.style.borderColor = '#fa0';
                notif.style.color = '#fa0';
            }

            document.body.appendChild(notif);
            const notifObj = { element: notif, expires: Date.now() + 2500 };
            visibleNotifications.push(notifObj);

            setTimeout(() => {
                notif.style.opacity = '0';
                notif.style.transition = 'opacity 0.3s';
                setTimeout(() => {
                    notif.remove();
                    processNotificationQueue();
                }, 300);
            }, 2500);
        }

        // --- INITIALIZATION ---
        function init() {
            loadGameData();

            // v5.7: Load RAPPID settings for AI-powered Copilot
            loadRappidSettings();

            // v5.3: Initialize portal system
            initPortalSystem();

            // v4.7: Check for welcome back rewards
            const sessionReward = checkSessionRewards();
            if (sessionReward) {
                // Delay modal to let game initialize
                setTimeout(() => showWelcomeBackModal(sessionReward), 1500);
            }

            // v4.0: Initialize audio and particle systems
            AudioSystem.init();
            particles = new ParticleSystem();
            envParticles = new EnvironmentParticles(); // v4.4

            // v4.6: Apply saved settings
            applySettings();

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 5000);
            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('container').appendChild(renderer.domElement);

            // Initialize floater pool
            for (let i = 0; i < MAX_FLOATERS; i++) {
                const el = document.createElement('div');
                el.className = 'floater';
                el.style.display = 'none';
                document.body.appendChild(el);
                floaterPool.push({ el, active: false });
            }

            // Inputs
            window.addEventListener('resize', onResize);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mousedown', onMouseDown);

            // Touch events
            if (isTouchDevice) {
                document.getElementById('touch-controls').style.display = 'flex';
                renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
                renderer.domElement.addEventListener('touchmove', onTouchMove, { passive: false });
                renderer.domElement.addEventListener('touchend', onTouchEnd, { passive: false });
                document.getElementById('touch-action').addEventListener('touchstart', onTouchAction);

                // v4.3: Virtual Joystick setup
                const joystick = document.getElementById('virtual-joystick');
                const joystickKnob = document.getElementById('joystick-knob');
                const actionBtn = document.getElementById('touch-action-btn');

                joystick.style.display = 'block';
                actionBtn.style.display = 'flex';

                joystick.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    const rect = joystick.getBoundingClientRect();
                    joystickCenter = { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
                    joystickActive = true;
                    updateJoystick(e.touches[0].clientX, e.touches[0].clientY);
                }, { passive: false });

                joystick.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (joystickActive) {
                        updateJoystick(e.touches[0].clientX, e.touches[0].clientY);
                    }
                }, { passive: false });

                joystick.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    joystickActive = false;
                    joystickInput = { x: 0, y: 0 };
                    joystickKnob.style.transform = 'translate(-50%, -50%)';
                }, { passive: false });

                actionBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (mode === 'world' && worldState.interactTarget) {
                        performAction(worldState.interactTarget);
                    }
                }, { passive: false });

                // v4.5: Dodge button setup
                const dodgeBtn = document.getElementById('touch-dodge-btn');
                dodgeBtn.style.display = 'flex';
                dodgeBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (mode === 'world') {
                        startDodge();
                    }
                }, { passive: false });

                function updateJoystick(touchX, touchY) {
                    let dx = touchX - joystickCenter.x;
                    let dy = touchY - joystickCenter.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist > joystickMaxDist) {
                        dx = (dx / dist) * joystickMaxDist;
                        dy = (dy / dist) * joystickMaxDist;
                    }

                    joystickKnob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
                    joystickInput = { x: dx / joystickMaxDist, y: dy / joystickMaxDist };
                }
            }

            // Keyboard events (including WASD)
            window.addEventListener('keydown', onKeyDown);
            window.addEventListener('keyup', onKeyUp);
            // v5.11: RTS Panel hotkeys
            window.addEventListener('keydown', handleRTSPanelHotkeys);

            initGalaxy();
            updateInventoryUI();
            updateSkillsUI();
            updateHealthUI();

            // v4.1: Initialize daily challenge system
            generateDailyChallenge();
            updateDailyChallengeUI();

            document.getElementById('loading').style.display = 'none';

            // v4.0: Show tutorial for first-time players
            if (!gameData.hasSeenTutorial) {
                setTimeout(showTutorial, 500);
            }

            // v4.1: Check achievements on load
            checkAchievements();

            // Autosave
            setInterval(() => {
                if (mode === 'world') {
                    saveGameData();
                    checkAchievements();
                    updateDailyChallengeProgress();
                    // v5.3: Check portal timeout
                    checkPortalTimeout();
                }
            }, CONFIG.AUTOSAVE_INTERVAL);

            requestAnimationFrame(loop);
        }

        // --- GALAXY MODE ---
        function initGalaxy() {
            mode = 'galaxy';

            // v4.3: Stop ambient audio when leaving planet
            AudioSystem.stopAmbient();

            // v4.4: Stop environmental particles
            if (envParticles) envParticles.stop();

            while(scene.children.length > 0) scene.remove(scene.children[0]);
            scene.fog = new THREE.FogExp2(0x000510, 0.0002);
            scene.background = new THREE.Color(0x000510);

            scene.add(new THREE.AmbientLight(0x444444));
            let sun = new THREE.PointLight(0xffffff, 1.5, 4000);
            scene.add(sun);

            // Starfield (optimized with BufferGeometry)
            const starGeo = new THREE.BufferGeometry();
            const starPos = [];
            const starColors = [];
            for(let i=0; i<8000; i++) {
                const r = 2000 * Math.cbrt(Math.random());
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2*Math.random()-1);
                starPos.push(r*Math.sin(phi)*Math.cos(theta), r*Math.sin(phi)*Math.sin(theta), r*Math.cos(phi));
                const c = new THREE.Color().setHSL(Math.random() * 0.2 + 0.55, 0.2, 0.8 + Math.random() * 0.2);
                starColors.push(c.r, c.g, c.b);
            }
            starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
            starGeo.setAttribute('color', new THREE.Float32BufferAttribute(starColors, 3));
            scene.add(new THREE.Points(starGeo, new THREE.PointsMaterial({ size: 2, vertexColors: true })));

            // v4.1: Nebula clouds for atmosphere
            createNebulae();

            // Civilizations
            const rng = new SeededRNG('OMNIVERSE');
            civilizations = [];
            galaxyGroup = new THREE.Group();

            for(let i=0; i<CONFIG.NUM_CIVS; i++) {
                const angle = rng.next() * Math.PI * 2;
                const dist = rng.range(200, 1200);
                const x = Math.cos(angle) * dist;
                const z = Math.sin(angle) * dist;
                const y = rng.range(-100, 100);

                const color = new THREE.Color().setHSL(rng.next(), 0.8, 0.5);
                const biomeKey = rng.pick(Object.keys(BIOMES));
                const civ = {
                    id: i, x, y, z, color,
                    name: `System-${rng.int(100,999)}`,
                    biome: biomeKey,
                    biomeName: BIOMES[biomeKey].name,
                    pop: rng.int(1, 100),
                    visited: gameData.visitedPlanets.includes(i)
                };
                civilizations.push(civ);

                const sysGroup = new THREE.Group();
                sysGroup.position.set(x,y,z);

                const star = new THREE.Mesh(
                    new THREE.SphereGeometry(8, 16, 16),
                    new THREE.MeshBasicMaterial({color: color})
                );
                sysGroup.add(star);

                const glow = new THREE.Mesh(
                    new THREE.SphereGeometry(16, 16, 16),
                    new THREE.MeshBasicMaterial({color: color, transparent: true, opacity: 0.2})
                );
                sysGroup.add(glow);

                // Mark visited planets
                if (civ.visited) {
                    const ring = new THREE.Mesh(
                        new THREE.RingGeometry(18, 20, 16),
                        new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide, transparent: true, opacity: 0.5 })
                    );
                    ring.rotation.x = Math.PI / 2;
                    sysGroup.add(ring);
                }

                sysGroup.userData = { type: 'civ', data: civ };
                galaxyGroup.add(sysGroup);
            }
            scene.add(galaxyGroup);

            selectionRing = new THREE.Mesh(
                new THREE.RingGeometry(12, 14, 32),
                new THREE.MeshBasicMaterial({color: 0x00ffff, side: THREE.DoubleSide})
            );
            selectionRing.rotation.x = Math.PI/2;
            selectionRing.visible = false;
            scene.add(selectionRing);

            camera.position.set(0, 1000, 1500);
            camera.lookAt(0,0,0);

            document.getElementById('galaxy-controls').style.display = 'flex';
            document.getElementById('world-controls').style.display = 'none';
            document.getElementById('rpg-ui').style.display = 'none';
            document.getElementById('player-health-bar').style.display = 'none';
            document.getElementById('minimap-container').style.display = 'none';
            document.getElementById('ability-bar').style.display = 'none';
            document.getElementById('weather-indicator').style.display = 'none';
            document.getElementById('ship-status').style.display = 'none';  // v5.13: Hide ship UI
            document.getElementById('civ-count').innerText = CONFIG.NUM_CIVS;

            updatePlaytimeDisplay();
        }

        // --- WORLD MODE ---
        function initWorld(civ) {
            activeCiv = civ;
            mode = 'world';

            // Mark as visited
            if (!gameData.visitedPlanets.includes(civ.id)) {
                gameData.visitedPlanets.push(civ.id);
                showNotification(`First visit to ${civ.name}!`);
                // v4.1: Check achievements after planet discovery
                checkAchievements();
                updateDailyChallengeProgress();
            }

            // v4.9: Track biome in codex
            trackBiomeVisit(civ.biome.toLowerCase());

            while(scene.children.length > 0) scene.remove(scene.children[0]);

            // v4.3: Reset boss spawn tracking for new world
            worldMobKillCount = 0;
            bossSpawned = false;

            const biome = BIOMES[civ.biome];
            scene.background = new THREE.Color(biome.sky);
            scene.fog = new THREE.Fog(biome.sky, 20, 120);

            worldState.ambient = new THREE.AmbientLight(0x404040);
            scene.add(worldState.ambient);

            worldState.sun = new THREE.DirectionalLight(0xffffff, 1);
            worldState.sun.castShadow = true;
            worldState.sun.shadow.camera.left = -50;
            worldState.sun.shadow.camera.right = 50;
            worldState.sun.shadow.camera.top = 50;
            worldState.sun.shadow.camera.bottom = -50;
            worldState.sun.shadow.mapSize.width = 1024;
            worldState.sun.shadow.mapSize.height = 1024;
            scene.add(worldState.sun);

            const rng = new SeededRNG(civ.name);
            worldState.terrain = [];
            worldState.interactables = [];
            worldState.fishingSpots = [];
            worldState.mobs = [];

            // Merged geometry for better performance
            const groundGeo = new THREE.BoxGeometry(CONFIG.TILE_SIZE, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE);
            const groundMat = new THREE.MeshLambertMaterial({ color: biome.ground });
            const waterMat = new THREE.MeshLambertMaterial({ color: biome.water, transparent: true, opacity: 0.8 });

            const worldGroup = new THREE.Group();

            for(let x=0; x<CONFIG.WORLD_SIZE; x++) {
                worldState.terrain[x] = [];
                for(let z=0; z<CONFIG.WORLD_SIZE; z++) {
                    const hVal = noise(x + civ.id, z + civ.id);
                    const height = Math.floor((hVal + 1) * 3);
                    const realY = height * CONFIG.TILE_SIZE/2;

                    const isWater = height < 1;

                    const mesh = new THREE.Mesh(groundGeo, isWater ? waterMat : groundMat);
                    mesh.position.set(
                        (x - CONFIG.WORLD_SIZE/2) * CONFIG.TILE_SIZE,
                        realY,
                        (z - CONFIG.WORLD_SIZE/2) * CONFIG.TILE_SIZE
                    );
                    mesh.receiveShadow = true;
                    worldGroup.add(mesh);

                    worldState.terrain[x][z] = isWater ? -99 : (height * CONFIG.TILE_SIZE/2) + CONFIG.TILE_SIZE/2;

                    // Fishing spots in water
                    if(isWater && rng.next() > 0.95) {
                        createFishingSpot(mesh.position.x, mesh.position.y + 1, mesh.position.z);
                    }

                    // Trees/Rocks
                    if(!isWater && rng.next() > 0.85) {
                        const type = rng.next() > 0.5 ? 'tree' : 'rock';
                        createProp(type, mesh.position.x, mesh.position.y + CONFIG.TILE_SIZE/2, mesh.position.z, biome);
                    }
                }
            }
            scene.add(worldGroup);

            // v5.15: ANIMATED FRIENDLY EXPLORER ROBOT - Full skeletal animation system
            const playerGroup = new THREE.Group();

            // Materials - soft, friendly colors
            const bodyMat = new THREE.MeshStandardMaterial({
                color: 0xe8e8f0,  // Soft white/light gray
                metalness: 0.4,
                roughness: 0.6
            });
            const accentMat = new THREE.MeshStandardMaterial({
                color: 0x4a9fff,  // Friendly blue
                metalness: 0.5,
                roughness: 0.4
            });
            const faceMat = new THREE.MeshStandardMaterial({
                color: 0x2a2a3a,  // Dark face plate
                metalness: 0.3,
                roughness: 0.5
            });

            // === HIERARCHICAL BONE STRUCTURE FOR ANIMATION ===
            // Body core (pivot for whole body bob)
            const bodyCore = new THREE.Group();
            bodyCore.position.y = 0.75;
            playerGroup.add(bodyCore);

            // === TORSO attached to body core ===
            const torsoGeo = new THREE.CylinderGeometry(0.35, 0.4, 0.6, 16);
            const torso = new THREE.Mesh(torsoGeo, bodyMat);
            torso.position.y = 0.4;
            torso.castShadow = true;
            bodyCore.add(torso);

            // Hip section
            const hipGeo = new THREE.CylinderGeometry(0.4, 0.35, 0.3, 16);
            const hip = new THREE.Mesh(hipGeo, bodyMat);
            hip.position.y = 0;
            hip.castShadow = true;
            bodyCore.add(hip);

            // Chest accent panel
            const chestGeo = new THREE.BoxGeometry(0.3, 0.25, 0.08);
            const chest = new THREE.Mesh(chestGeo, accentMat);
            chest.position.set(0, 0.45, 0.35);
            bodyCore.add(chest);

            // Chest light/heart (status indicator)
            const heartGeo = new THREE.SphereGeometry(0.08, 12, 12);
            const heartMat = new THREE.MeshBasicMaterial({ color: 0x00ff88 });
            const heart = new THREE.Mesh(heartGeo, heartMat);
            heart.position.set(0, 0.45, 0.4);
            bodyCore.add(heart);
            playerGroup.userData.statusStrip = heart;

            // Backpack
            const backpackGeo = new THREE.BoxGeometry(0.3, 0.35, 0.15);
            const backpack = new THREE.Mesh(backpackGeo, accentMat);
            backpack.position.set(0, 0.35, -0.35);
            backpack.castShadow = true;
            bodyCore.add(backpack);

            // === HEAD GROUP (pivots for look/nod animations) ===
            const headGroup = new THREE.Group();
            headGroup.position.set(0, 0.95, 0);  // Neck position relative to body core
            bodyCore.add(headGroup);

            // Main head sphere
            const headGeo = new THREE.SphereGeometry(0.45, 24, 24);
            const head = new THREE.Mesh(headGeo, bodyMat);
            head.position.y = 0;
            head.scale.set(1, 0.9, 0.95);
            head.castShadow = true;
            headGroup.add(head);

            // Face plate
            const faceGeo = new THREE.SphereGeometry(0.42, 24, 12, 0, Math.PI, 0, Math.PI * 0.6);
            const face = new THREE.Mesh(faceGeo, faceMat);
            face.position.set(0, -0.02, 0.08);
            face.rotation.x = -0.3;
            headGroup.add(face);

            // Friendly eyes
            const eyeGeo = new THREE.SphereGeometry(0.12, 16, 16);
            const eyeMat = new THREE.MeshStandardMaterial({
                color: 0x00ddff,
                emissive: 0x00ddff,
                emissiveIntensity: 0.9
            });
            const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
            leftEye.position.set(-0.15, 0.02, 0.35);
            headGroup.add(leftEye);
            const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
            rightEye.position.set(0.15, 0.02, 0.35);
            headGroup.add(rightEye);
            playerGroup.userData.robotEye = rightEye;
            playerGroup.userData.leftEye = leftEye;

            // Eye pupils
            const pupilGeo = new THREE.SphereGeometry(0.05, 12, 12);
            const pupilMat = new THREE.MeshBasicMaterial({ color: 0x000022 });
            const leftPupil = new THREE.Mesh(pupilGeo, pupilMat);
            leftPupil.position.set(-0.15, 0.02, 0.44);
            headGroup.add(leftPupil);
            const rightPupil = new THREE.Mesh(pupilGeo, pupilMat);
            rightPupil.position.set(0.15, 0.02, 0.44);
            headGroup.add(rightPupil);
            playerGroup.userData.leftPupil = leftPupil;
            playerGroup.userData.rightPupil = rightPupil;

            // Eyebrow accent lights
            const browGeo = new THREE.BoxGeometry(0.08, 0.02, 0.02);
            const browMat = new THREE.MeshBasicMaterial({ color: 0x00ffaa });
            const leftBrow = new THREE.Mesh(browGeo, browMat);
            leftBrow.position.set(-0.15, 0.18, 0.32);
            leftBrow.rotation.z = 0.2;
            headGroup.add(leftBrow);
            const rightBrow = new THREE.Mesh(browGeo, browMat);
            rightBrow.position.set(0.15, 0.18, 0.32);
            rightBrow.rotation.z = -0.2;
            headGroup.add(rightBrow);
            playerGroup.userData.leftBrow = leftBrow;
            playerGroup.userData.rightBrow = rightBrow;

            // Antenna
            const antennaGeo = new THREE.CylinderGeometry(0.02, 0.02, 0.25, 8);
            const antenna = new THREE.Mesh(antennaGeo, accentMat);
            antenna.position.set(0, 0.5, -0.1);
            headGroup.add(antenna);
            playerGroup.userData.antenna = antenna;

            // Antenna ball
            const antBallGeo = new THREE.SphereGeometry(0.06, 12, 12);
            const antBallMat = new THREE.MeshBasicMaterial({ color: 0x00ff88 });
            const antBall = new THREE.Mesh(antBallGeo, antBallMat);
            antBall.position.set(0, 0.65, -0.1);
            headGroup.add(antBall);
            playerGroup.userData.antennaLight = antBall;

            // === ARM GROUPS (hierarchical for proper joint rotation) ===
            const armData = { left: {}, right: {} };
            [-1, 1].forEach(side => {
                const sideName = side === -1 ? 'left' : 'right';

                // Upper arm group (pivots at shoulder)
                const upperArmGroup = new THREE.Group();
                upperArmGroup.position.set(side * 0.48, 0.55, 0);  // Shoulder position
                bodyCore.add(upperArmGroup);

                // Shoulder ball
                const shoulderGeo = new THREE.SphereGeometry(0.12, 12, 12);
                const shoulder = new THREE.Mesh(shoulderGeo, accentMat);
                shoulder.position.set(0, 0, 0);
                upperArmGroup.add(shoulder);

                // Upper arm
                const upperArmGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.35, 12);
                const upperArm = new THREE.Mesh(upperArmGeo, bodyMat);
                upperArm.position.set(0, -0.2, 0);
                upperArm.castShadow = true;
                upperArmGroup.add(upperArm);

                // Lower arm group (pivots at elbow)
                const lowerArmGroup = new THREE.Group();
                lowerArmGroup.position.set(0, -0.4, 0);  // Elbow position relative to upper arm
                upperArmGroup.add(lowerArmGroup);

                // Elbow joint
                const elbowGeo = new THREE.SphereGeometry(0.08, 10, 10);
                const elbow = new THREE.Mesh(elbowGeo, accentMat);
                elbow.position.set(0, 0, 0);
                lowerArmGroup.add(elbow);

                // Lower arm
                const lowerArmGeo = new THREE.CylinderGeometry(0.06, 0.07, 0.3, 12);
                const lowerArm = new THREE.Mesh(lowerArmGeo, bodyMat);
                lowerArm.position.set(0, -0.18, 0);
                lowerArm.castShadow = true;
                lowerArmGroup.add(lowerArm);

                // Hand
                const handGeo = new THREE.SphereGeometry(0.09, 12, 12);
                const hand = new THREE.Mesh(handGeo, accentMat);
                hand.position.set(0, -0.35, 0);
                hand.scale.set(1, 0.8, 1.2);
                lowerArmGroup.add(hand);

                armData[sideName] = { upperGroup: upperArmGroup, lowerGroup: lowerArmGroup };
            });

            // === LEG GROUPS (hierarchical for walking animation) ===
            const legData = { left: {}, right: {} };
            [-1, 1].forEach(side => {
                const sideName = side === -1 ? 'left' : 'right';

                // Upper leg group (pivots at hip)
                const upperLegGroup = new THREE.Group();
                upperLegGroup.position.set(side * 0.18, -0.17, 0);  // Hip joint position
                bodyCore.add(upperLegGroup);

                // Hip joint
                const hipJointGeo = new THREE.SphereGeometry(0.1, 10, 10);
                const hipJoint = new THREE.Mesh(hipJointGeo, accentMat);
                hipJoint.position.set(0, 0, 0);
                upperLegGroup.add(hipJoint);

                // Upper leg
                const upperLegGeo = new THREE.CylinderGeometry(0.1, 0.09, 0.3, 12);
                const upperLeg = new THREE.Mesh(upperLegGeo, bodyMat);
                upperLeg.position.set(0, -0.18, 0);
                upperLeg.castShadow = true;
                upperLegGroup.add(upperLeg);

                // Lower leg group (pivots at knee)
                const lowerLegGroup = new THREE.Group();
                lowerLegGroup.position.set(0, -0.34, 0);  // Knee position relative to upper leg
                upperLegGroup.add(lowerLegGroup);

                // Knee joint
                const kneeGeo = new THREE.SphereGeometry(0.09, 10, 10);
                const knee = new THREE.Mesh(kneeGeo, accentMat);
                knee.position.set(0, 0, 0);
                lowerLegGroup.add(knee);

                // Lower leg
                const lowerLegGeo = new THREE.CylinderGeometry(0.08, 0.1, 0.25, 12);
                const lowerLeg = new THREE.Mesh(lowerLegGeo, bodyMat);
                lowerLeg.position.set(0, -0.14, 0);
                lowerLeg.castShadow = true;
                lowerLegGroup.add(lowerLeg);

                // Foot
                const footGeo = new THREE.BoxGeometry(0.14, 0.06, 0.22);
                const footMat = new THREE.MeshStandardMaterial({
                    color: 0x3a3a4a,
                    metalness: 0.5,
                    roughness: 0.6
                });
                const foot = new THREE.Mesh(footGeo, footMat);
                foot.position.set(0, -0.27, 0.04);
                foot.castShadow = true;
                lowerLegGroup.add(foot);

                legData[sideName] = { upperGroup: upperLegGroup, lowerGroup: lowerLegGroup };
            });

            // === ANIMATION STATE SYSTEM ===
            playerGroup.userData.animation = {
                state: 'idle',        // idle, walking, running, jumping, attacking, waving, damage
                prevState: 'idle',
                stateTime: 0,         // Time in current state
                blendTime: 0,         // For smooth state transitions
                walkCycle: 0,         // Walk cycle phase (0 to 2*PI)
                blinkTimer: 0,        // For random blinks
                nextBlink: 2000 + Math.random() * 3000,
                isBlinking: false,
                lookTarget: null,     // Optional look-at target
                headBob: 0,           // Head bob phase
                breathPhase: 0,       // Breathing animation phase
                jumpPhase: 0,         // Jump animation phase
                attackPhase: 0,       // Attack animation phase
                wavePhase: 0,         // Wave animation phase
                damageFlash: 0,       // Damage flash timer
                idleVariation: 0,     // For idle animation variations
                speedMultiplier: 1    // Animation speed
            };

            // Store bone references for animation
            playerGroup.userData.bones = {
                bodyCore: bodyCore,
                headGroup: headGroup,
                leftArm: armData.left,
                rightArm: armData.right,
                leftLeg: legData.left,
                rightLeg: legData.right
            };

            worldState.player = playerGroup;
            worldState.player.position.set(0, 10, 0);
            worldState.player.userData.isRobot = true;

            // Selection/highlight ring
            const ring = new THREE.Mesh(
                new THREE.RingGeometry(1.0, 1.2, 16),
                new THREE.MeshBasicMaterial({ color: 0x00ffff, side: THREE.DoubleSide, transparent: true, opacity: 0.6 })
            );
            ring.rotation.x = -Math.PI/2;
            ring.position.y = 0.05;
            worldState.player.add(ring);

            scene.add(worldState.player);

            // Mobs
            const mobCount = 5 + Math.floor(rng.next() * 5);
            for(let i=0; i<mobCount; i++) {
                createMob(rng, biome);
            }

            // v4.2: Generate POIs based on biome
            worldState.pois = [];
            const biomeKey = civ.biome;
            for (const [poiType, poiData] of Object.entries(POI_TYPES)) {
                // Check if POI can spawn in this biome
                if (poiData.biomes && !poiData.biomes.includes(biomeKey)) continue;

                // Check rarity
                if (rng.next() < poiData.rarity) {
                    // Check if already discovered on this planet
                    const alreadyDiscovered = gameData.discoveredPOIs[civ.id]?.includes(poiType);
                    createPOI(rng, biome, poiType, poiData);
                    // Mark pre-discovered POIs
                    if (alreadyDiscovered && worldState.pois.length > 0) {
                        const poi = worldState.pois[worldState.pois.length - 1];
                        poi.userData.discovered = true;
                        if (poi.userData.beacon) poi.userData.beacon.material.emissiveIntensity = 0.1;
                        if (poi.userData.iconMesh) poi.userData.iconMesh.material.opacity = 0.3;
                    }
                }
            }

            // UI
            document.getElementById('galaxy-controls').style.display = 'none';
            document.getElementById('world-controls').style.display = 'flex';
            document.getElementById('world-name').textContent = civ.biomeName;
            document.getElementById('rpg-ui').style.display = 'flex';
            document.getElementById('player-health-bar').style.display = 'block';
            document.getElementById('minimap-container').style.display = 'block';
            document.getElementById('ability-bar').style.display = 'block';
            document.getElementById('weather-indicator').style.display = 'block';
            updateAbilityUI();
            updateWeatherUI();

            // v4.3: Start biome ambient audio
            AudioSystem.startAmbient(civ.biome);

            // v5.0: Spawn pet companion
            initPetSystem();
            updatePetMesh();

            // v5.6: Initialize and spawn Copilot Companion
            initCopilotCompanion();
            createCopilotMesh();

            // v5.12: Initialize hypnosis effects
            initHypnosisEffects();

            // v5.13: Create ship and landing zone
            const landingSpot = new THREE.Vector3(
                (CONFIG.WORLD_SIZE / 4 - CONFIG.WORLD_SIZE / 2) * CONFIG.TILE_SIZE,
                10,
                (CONFIG.WORLD_SIZE / 4 - CONFIG.WORLD_SIZE / 2) * CONFIG.TILE_SIZE
            );
            // Find ground height at landing spot
            const lx = Math.floor(CONFIG.WORLD_SIZE / 4);
            const lz = Math.floor(CONFIG.WORLD_SIZE / 4);
            if (worldState.terrain[lx] && worldState.terrain[lx][lz] !== undefined) {
                landingSpot.y = worldState.terrain[lx][lz] > 0 ? worldState.terrain[lx][lz] : 5;
            }
            const landingPad = createLandingZone(landingSpot);
            scene.add(landingPad);
            const ship = createWorldShip(landingSpot);
            scene.add(ship);
            SHIP_STATE.hp = SHIP_STATE.maxHp;  // Reset ship HP for new world
            updateShipHPUI();
            document.getElementById('ship-status').style.display = 'block';

            // v5.0: Initialize weather system
            initWeatherSystem();

            // v5.4: Initialize new systems
            initPetEvolutionSystem();
            initWorldEventSystem();
            initAchievementShowcase();

            // v4.4: Start environmental particles
            if (envParticles) envParticles.startBiome(civ.biome);

            worldState.target = null;
            worldState.interactTarget = null;

            updateInventoryUI();
            updateSkillsUI();
            updateHealthUI();
            updateCraftingUI();
            initMinimap();
        }

        function createProp(type, x, y, z, biome) {
            const group = new THREE.Group();
            group.position.set(x, y, z);

            if(type === 'tree') {
                const trunk = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.3, 0.5, 2, 6),
                    new THREE.MeshLambertMaterial({ color: 0x553311 })
                );
                trunk.position.y = 1;
                trunk.castShadow = true;
                group.add(trunk);

                const leaves = new THREE.Mesh(
                    new THREE.ConeGeometry(1.2, 2.5, 8),
                    new THREE.MeshLambertMaterial({ color: biome.tree })
                );
                leaves.position.y = 2.8;
                leaves.castShadow = true;
                group.add(leaves);
                group.userData = { type: 'tree', hp: 3, maxHp: 3, name: 'Ancient Tree' };
            } else {
                const rock = new THREE.Mesh(
                    new THREE.DodecahedronGeometry(1),
                    new THREE.MeshLambertMaterial({ color: biome.rock })
                );
                rock.position.y = 0.5;
                rock.rotation.set(Math.random(), Math.random(), Math.random());
                rock.castShadow = true;
                group.add(rock);
                group.userData = { type: 'rock', hp: 3, maxHp: 3, name: 'Ore Vein' };
            }

            scene.add(group);
            worldState.interactables.push(group);
        }

        function createFishingSpot(x, y, z) {
            const group = new THREE.Group();
            group.position.set(x, y, z);

            // Ripple effect
            const ripple = new THREE.Mesh(
                new THREE.RingGeometry(0.8, 1, 16),
                new THREE.MeshBasicMaterial({ color: 0x88ccff, transparent: true, opacity: 0.5, side: THREE.DoubleSide })
            );
            ripple.rotation.x = -Math.PI / 2;
            group.add(ripple);

            group.userData = { type: 'fishing', name: 'Fishing Spot', ripple };
            scene.add(group);
            worldState.fishingSpots.push(group);
            worldState.interactables.push(group);
        }

        // v5.18: Create Battery Charger structure
        function createBatteryCharger(x, y, z, efficiency = 100) {
            if (!worldState.scene) return null;

            const group = new THREE.Group();
            group.position.set(x, y + 0.1, z);

            // Base platform
            const baseMat = new THREE.MeshStandardMaterial({
                color: efficiency >= 90 ? 0x00ff88 : (efficiency >= 70 ? 0xffaa00 : 0xff4444),
                metalness: 0.6,
                roughness: 0.3
            });
            const base = new THREE.Mesh(
                new THREE.CylinderGeometry(1.2, 1.4, 0.3, 8),
                baseMat
            );
            group.add(base);

            // Central charging pillar
            const pillarMat = new THREE.MeshStandardMaterial({
                color: 0x333344,
                metalness: 0.8,
                roughness: 0.2
            });
            const pillar = new THREE.Mesh(
                new THREE.CylinderGeometry(0.3, 0.4, 2, 6),
                pillarMat
            );
            pillar.position.y = 1.15;
            group.add(pillar);

            // Energy ring (glowing)
            const ringMat = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.8
            });
            const ring = new THREE.Mesh(
                new THREE.TorusGeometry(0.5, 0.08, 8, 16),
                ringMat
            );
            ring.position.y = 1.8;
            ring.rotation.x = Math.PI / 2;
            group.add(ring);

            // Top beacon light
            const beaconMat = new THREE.MeshBasicMaterial({
                color: efficiency >= 90 ? 0x00ff00 : (efficiency >= 70 ? 0xffff00 : 0xff6600)
            });
            const beacon = new THREE.Mesh(
                new THREE.SphereGeometry(0.2, 8, 8),
                beaconMat
            );
            beacon.position.y = 2.3;
            group.add(beacon);

            // Add point light for glow effect
            const light = new THREE.PointLight(
                efficiency >= 90 ? 0x00ff88 : (efficiency >= 70 ? 0xffaa00 : 0xff4444),
                0.5,
                8
            );
            light.position.y = 2;
            group.add(light);

            const chargerData = {
                type: 'battery_charger',
                mesh: group,
                x: Math.floor((x / CONFIG.TILE_SIZE) + CONFIG.WORLD_SIZE / 2),
                z: Math.floor((z / CONFIG.TILE_SIZE) + CONFIG.WORLD_SIZE / 2),
                worldX: x,
                worldZ: z,
                efficiency: efficiency,
                chargeRadius: 3 + (efficiency / 25), // Better chargers have larger radius
                isActive: true,
                ring: ring,
                beacon: beacon,
                light: light,
                createdAt: Date.now()
            };

            group.userData = {
                type: 'structure',
                structureType: 'battery_charger',
                name: `Battery Charger (${efficiency}%)`,
                efficiency: efficiency,
                chargerData: chargerData
            };

            worldState.scene.add(group);
            worldState.structures.push(chargerData);
            worldState.interactables.push(group);

            return chargerData;
        }

        // v5.18: Move agent to random nearby position
        function moveAgentToRandomPosition(agent) {
            if (!agent.mesh) return;

            const angle = Math.random() * Math.PI * 2;
            const distance = 5 + Math.random() * 10;
            const newX = agent.mesh.position.x + Math.cos(angle) * distance;
            const newZ = agent.mesh.position.z + Math.sin(angle) * distance;

            // Clamp to world bounds
            const halfWorld = (CONFIG.WORLD_SIZE / 2) * CONFIG.TILE_SIZE;
            agent.targetPosition = new THREE.Vector3(
                Math.max(-halfWorld + 5, Math.min(halfWorld - 5, newX)),
                agent.mesh.position.y,
                Math.max(-halfWorld + 5, Math.min(halfWorld - 5, newZ))
            );

            agent.taskState.state = 'moving';
            agent.taskState.targetPosition = agent.targetPosition.clone();
        }

        // v5.18: Update robot energy and check for charging
        function updateRobotEnergy(delta) {
            if (!worldState.player) return;

            const playerPos = worldState.player.position;
            let isNearCharger = false;
            let bestEfficiency = 0;

            // Check if near any battery charger
            for (const structure of worldState.structures) {
                if (structure.type === 'battery_charger' && structure.isActive) {
                    const dist = Math.sqrt(
                        Math.pow(playerPos.x - structure.worldX, 2) +
                        Math.pow(playerPos.z - structure.worldZ, 2)
                    );
                    if (dist < structure.chargeRadius) {
                        isNearCharger = true;
                        bestEfficiency = Math.max(bestEfficiency, structure.efficiency);

                        // Animate the charger ring when charging
                        if (structure.ring) {
                            structure.ring.rotation.z += delta * 2;
                        }
                    }
                }
            }

            robotEnergy.isCharging = isNearCharger;

            if (isNearCharger) {
                // Charge based on efficiency
                const chargeAmount = robotEnergy.chargeRate * (bestEfficiency / 100) * delta;
                robotEnergy.current = Math.min(robotEnergy.max, robotEnergy.current + chargeAmount);
            } else {
                // Drain energy when moving (checked in movement code)
                // Small passive drain
                robotEnergy.current = Math.max(0, robotEnergy.current - robotEnergy.drainRate * delta * 0.1);
            }

            // Update energy UI
            updateEnergyUI();
        }

        // v5.18: Update energy UI display
        function updateEnergyUI() {
            const energyBar = document.getElementById('robot-energy-bar');
            const energyText = document.getElementById('robot-energy-text');

            if (energyBar) {
                const percent = (robotEnergy.current / robotEnergy.max) * 100;
                energyBar.style.width = percent + '%';
                energyBar.style.background = robotEnergy.isCharging ? '#00ff88' :
                    (percent > 50 ? '#00aaff' : (percent > 20 ? '#ffaa00' : '#ff4444'));
            }
            if (energyText) {
                energyText.textContent = `${Math.floor(robotEnergy.current)}/${robotEnergy.max}`;
                if (robotEnergy.isCharging) {
                    energyText.textContent += ' âš¡';
                }
            }
        }

        // v5.18: Animate structures (charger rings, etc)
        function updateStructures(delta) {
            for (const structure of worldState.structures) {
                if (structure.type === 'battery_charger' && structure.ring) {
                    // Slow rotation when idle
                    structure.ring.rotation.z += delta * 0.5;

                    // Pulse the beacon
                    if (structure.beacon) {
                        const pulse = Math.sin(performance.now() * 0.003) * 0.3 + 0.7;
                        structure.beacon.scale.setScalar(pulse);
                    }
                }
            }
        }

        // ==========================================
        // v5.18: P2P SPECTATOR STREAMING SYSTEM
        // QR Code minimap allows others to spectate
        // ==========================================

        // Initialize PeerJS connection as host
        function initP2PHost() {
            if (p2pStreaming.peer) return; // Already initialized

            try {
                // Create peer with random ID
                p2pStreaming.peer = new Peer();

                p2pStreaming.peer.on('open', (id) => {
                    p2pStreaming.peerId = id;
                    p2pStreaming.isHost = true;
                    console.log('P2P Host initialized with ID:', id);

                    // Generate QR code
                    generateSpectatorQRCode();
                    updateP2PStatusUI();
                });

                p2pStreaming.peer.on('connection', (conn) => {
                    console.log('Spectator connected:', conn.peer);
                    p2pStreaming.connections.push(conn);
                    p2pStreaming.spectatorCount = p2pStreaming.connections.length;

                    conn.on('open', () => {
                        showNotification(`ðŸ‘ï¸ Spectator joined! (${p2pStreaming.spectatorCount} watching)`, 'info');
                        updateP2PStatusUI();

                        // Send initial game state
                        sendGameStateToSpectator(conn);
                    });

                    conn.on('close', () => {
                        p2pStreaming.connections = p2pStreaming.connections.filter(c => c !== conn);
                        p2pStreaming.spectatorCount = p2pStreaming.connections.length;
                        updateP2PStatusUI();
                    });

                    conn.on('error', (err) => {
                        console.error('Connection error:', err);
                        p2pStreaming.connections = p2pStreaming.connections.filter(c => c !== conn);
                        p2pStreaming.spectatorCount = p2pStreaming.connections.length;
                    });
                });

                p2pStreaming.peer.on('error', (err) => {
                    console.error('PeerJS error:', err);
                    if (err.type === 'unavailable-id') {
                        // Retry with new ID
                        setTimeout(initP2PHost, 1000);
                    }
                });

            } catch (e) {
                console.error('Failed to initialize P2P:', e);
            }
        }

        // Connect as spectator to a host
        function connectAsSpectator(hostId) {
            if (!hostId) {
                showNotification('Invalid host ID', 'error');
                return;
            }

            try {
                p2pStreaming.peer = new Peer();

                p2pStreaming.peer.on('open', () => {
                    p2pStreaming.isHost = false;
                    p2pStreaming.isSpectating = true;

                    const conn = p2pStreaming.peer.connect(hostId, { reliable: true });

                    conn.on('open', () => {
                        p2pStreaming.hostConnection = conn;
                        showNotification('ðŸ”— Connected to host! Spectating...', 'info');
                        enterSpectatorMode();
                    });

                    conn.on('data', (data) => {
                        handleSpectatorData(data);
                    });

                    conn.on('close', () => {
                        showNotification('Host disconnected', 'error');
                        exitSpectatorMode();
                    });

                    conn.on('error', (err) => {
                        console.error('Connection error:', err);
                        showNotification('Failed to connect to host', 'error');
                    });
                });

                p2pStreaming.peer.on('error', (err) => {
                    console.error('PeerJS error:', err);
                    showNotification('Connection failed', 'error');
                });

            } catch (e) {
                console.error('Failed to connect as spectator:', e);
            }
        }

        // v5.19: QR Code Generator using QRious library with API fallback
        // Generates scannable QR codes for spectator links
        function loadQRiousLibrary() {
            return new Promise((resolve, reject) => {
                if (window.QRious) {
                    resolve();
                    return;
                }
                const script = document.createElement('script');
                script.src = 'https://cdnjs.cloudflare.com/ajax/libs/qrious/4.0.2/qrious.min.js';
                script.onload = resolve;
                script.onerror = reject;
                document.head.appendChild(script);
            });
        }

        // Generate QR code for spectator link
        function generateSpectatorQRCode() {
            if (!p2pStreaming.peerId) {
                console.log('No peer ID yet, will generate QR when ready');
                return;
            }

            const container = document.getElementById('qr-code-container');
            if (!container) return;

            // Show loading state
            container.innerHTML = '<div style="color: #333; font-size: 14px;">Generating QR code...</div>';

            const spectatorUrl = `${window.location.origin}${window.location.pathname}?spectate=${p2pStreaming.peerId}`;
            console.log('Generating QR code for:', spectatorUrl);

            // Try QRious library first, fall back to API
            loadQRiousLibrary().then(() => {
                container.innerHTML = ''; // Clear loading state
                const canvas = document.createElement('canvas');
                canvas.id = 'qr-canvas';
                container.appendChild(canvas);

                new window.QRious({
                    element: canvas,
                    value: spectatorUrl,
                    size: 200,
                    background: 'white',
                    foreground: 'black',
                    level: 'H' // High error correction for better scanning
                });

                console.log('QR code generated with QRious');
            }).catch((err) => {
                console.log('QRious failed, using API fallback:', err);
                container.innerHTML = ''; // Clear loading state
                // Fallback: Use QR Server API
                const img = document.createElement('img');
                img.src = `https://api.qrserver.com/v1/create-qr-code/?size=200x200&data=${encodeURIComponent(spectatorUrl)}`;
                img.alt = 'Scan to spectate';
                img.style.borderRadius = '10px';
                img.id = 'qr-canvas';
                img.onload = () => console.log('QR code loaded from API');
                img.onerror = () => {
                    container.innerHTML = '<div style="color: #c00; font-size: 12px; padding: 10px;">QR generation failed.<br>Copy the URL below instead.</div>';
                };
                container.appendChild(img);
                console.log('QR code generated with API fallback');
            });
        }

        // Send game state to spectators - now includes full 3D sync data
        function sendGameStateToSpectators() {
            if (!p2pStreaming.isHost || p2pStreaming.connections.length === 0) return;

            const now = performance.now();
            if (now - p2pStreaming.lastFrameTime < p2pStreaming.frameInterval) return;
            p2pStreaming.lastFrameTime = now;

            // Build full 3D sync state for spectators to render
            const gameState = {
                type: 'frame',
                timestamp: Date.now(),
                // Camera for 3D view sync
                camera: camera ? {
                    position: { x: camera.position.x, y: camera.position.y, z: camera.position.z },
                    rotation: { x: camera.rotation.x, y: camera.rotation.y, z: camera.rotation.z }
                } : null,
                // Player position for 3D rendering
                player: worldState.player ? {
                    x: worldState.player.position.x,
                    y: worldState.player.position.y,
                    z: worldState.player.position.z,
                    rotationY: worldState.player.rotation.y
                } : null,
                // Agent positions with full data
                agents: (agentFleet || []).map(a => ({
                    id: a.id,
                    name: a.name,
                    type: a.type,
                    x: a.mesh?.position.x || 0,
                    y: a.mesh?.position.y || 0,
                    z: a.mesh?.position.z || 0,
                    status: a.statusMessage
                })),
                // Structure data
                structures: (worldState.structures || []).map(s => ({
                    type: s.type,
                    x: s.worldX,
                    z: s.worldZ,
                    efficiency: s.efficiency
                })),
                // Mob positions (for showing enemies)
                mobs: (worldState.mobs || []).slice(0, 20).map(m => ({
                    x: m.position?.x || 0,
                    y: m.position?.y || 0,
                    z: m.position?.z || 0,
                    name: m.userData?.displayName || m.userData?.name || 'Enemy'
                })),
                // Stats
                hp: gameData.player?.hp || 100,
                maxHp: gameData.player?.maxHp || 100,
                energy: robotEnergy.current,
                civ: activeCiv?.name || 'Unknown',
                biome: activeCiv?.biome || 'Terra',
                // v5.20: Include current game mode so spectators can sync
                gameMode: mode
            };

            // Capture minimap as image
            const minimapCanvas = document.getElementById('minimap-canvas');
            if (minimapCanvas) {
                const smallCanvas = document.createElement('canvas');
                smallCanvas.width = 140;
                smallCanvas.height = 140;
                const ctx = smallCanvas.getContext('2d');
                ctx.drawImage(minimapCanvas, 0, 0, 140, 140);
                gameState.minimap = smallCanvas.toDataURL('image/jpeg', 0.7);
            }

            // Send to all spectators (only if connection is open)
            for (const conn of p2pStreaming.connections) {
                try {
                    if (conn.open) {
                        conn.send(gameState);
                    }
                } catch (e) {
                    console.error('Failed to send to spectator:', e);
                }
            }
        }

        // Send initial state to new spectator
        function sendGameStateToSpectator(conn) {
            const initialState = {
                type: 'init',
                civ: activeCiv ? { name: activeCiv.name, biome: activeCiv.biome } : null,
                playerName: 'Explorer Robot',
                version: VERSION
            };
            conn.send(initialState);
        }

        // Handle incoming data as spectator
        function handleSpectatorData(data) {
            if (!p2pStreaming.isSpectating) return;

            p2pStreaming.spectatorData = data;

            if (data.type === 'init') {
                // Initial connection data
                const civEl = document.getElementById('spectator-civ');
                const versionEl = document.getElementById('spectator-version');
                if (civEl) civEl.textContent = data.civ?.name || 'Unknown';
                if (versionEl) versionEl.textContent = data.version;
            } else if (data.type === 'frame') {
                // v5.20: Check if host changed modes and we need to sync
                const previousMode = p2pStreaming.hostGameMode;
                p2pStreaming.hostGameMode = data.gameMode;

                // Update banner to show host's current mode
                showSpectatorModeMessage(data.gameMode);

                // v5.20: Sync 3D camera for real view streaming (unless paused)
                // Only sync if we're in the same mode as host
                if (!p2pStreaming.streamPaused && data.camera && camera && mode === data.gameMode) {
                    syncCameraFromHost(data.camera);
                }

                // Update spectator view stats
                updateSpectatorView(data);
            }
        }

        // v5.20: Show mode sync message to spectator (only once per mode change)
        let lastModeMessage = '';
        function showSpectatorModeMessage(msg) {
            if (msg === lastModeMessage) return; // Don't spam
            lastModeMessage = msg;

            // Update the banner to show host's mode
            const hostNameEl = document.getElementById('spectator-host-name');
            if (hostNameEl && p2pStreaming.hostGameMode) {
                const modeIcon = p2pStreaming.hostGameMode === 'world' ? 'ðŸŒ' : 'ðŸŒŒ';
                hostNameEl.textContent = `Host (${modeIcon} ${p2pStreaming.hostGameMode})`;
            }
        }

        // v5.20: Smoothly sync camera from host data
        function syncCameraFromHost(cameraData) {
            if (!camera) return;

            const targetPos = new THREE.Vector3(
                cameraData.position.x,
                cameraData.position.y,
                cameraData.position.z
            );

            // Smooth interpolation (lerp) for fluid camera following
            camera.position.lerp(targetPos, 0.3);

            // Apply rotation directly for snappy look direction
            camera.rotation.x = cameraData.rotation.x;
            camera.rotation.y = cameraData.rotation.y;
            camera.rotation.z = cameraData.rotation.z;
        }

        // Spectator activity log
        let spectatorActivityLog = [];
        let lastSpectatorData = null;

        // Update spectator UI with received data
        function updateSpectatorView(data) {
            // Track latency
            const latencyEl = document.getElementById('spectator-latency');
            if (latencyEl && data.timestamp) {
                const latency = Date.now() - data.timestamp;
                latencyEl.textContent = latency;
            }

            // Update HP bar with color coding
            const hpFill = document.getElementById('spectator-hp-fill');
            const hpText = document.getElementById('spectator-hp-text');
            if (hpFill && data.hp !== undefined) {
                const hpPercent = (data.hp / data.maxHp) * 100;
                hpFill.style.width = hpPercent + '%';
                // Color based on health
                if (hpPercent < 25) {
                    hpFill.style.background = 'linear-gradient(90deg, #f44, #f66)';
                } else if (hpPercent < 50) {
                    hpFill.style.background = 'linear-gradient(90deg, #f80, #fa0)';
                } else {
                    hpFill.style.background = 'linear-gradient(90deg, #f44, #ff8800, #4f4)';
                }
                // Detect damage for activity feed
                if (lastSpectatorData && data.hp < lastSpectatorData.hp) {
                    addSpectatorActivity(`Probe took ${Math.floor(lastSpectatorData.hp - data.hp)} damage!`, 'danger');
                }
            }
            if (hpText) {
                hpText.textContent = `${Math.floor(data.hp)}/${data.maxHp}`;
            }

            // Update energy bar
            const energyFill = document.getElementById('spectator-energy-fill');
            const energyText = document.getElementById('spectator-energy-text');
            if (energyFill && data.energy !== undefined) {
                energyFill.style.width = data.energy + '%';
            }
            if (energyText) {
                energyText.textContent = `${Math.floor(data.energy)}/100`;
            }

            // Update minimap
            const spectatorMinimap = document.getElementById('spectator-minimap');
            if (spectatorMinimap && data.minimap) {
                spectatorMinimap.src = data.minimap;
            }

            // Update biome
            const biomeEl = document.getElementById('spectator-biome');
            if (biomeEl && data.biome) {
                biomeEl.textContent = data.biome;
            }

            // Update agent list with cards
            const agentList = document.getElementById('spectator-agents');
            const agentCount = document.getElementById('spectator-agent-count');
            if (agentList && data.agents) {
                if (data.agents.length === 0) {
                    agentList.innerHTML = '<div style="color: #666; font-size: 11px; font-style: italic; text-align: center; padding: 20px 0;">No agents deployed</div>';
                } else {
                    agentList.innerHTML = data.agents.map(a => {
                        const icon = a.type === 'gatherer' ? 'ðŸªµ' : a.type === 'hunter' ? 'âš”ï¸' : a.type === 'terraformer' ? 'ðŸšœ' : a.type === 'builder' ? 'ðŸ”§' : 'ðŸ¤–';
                        const typeColor = a.type === 'hunter' ? '#f44' : a.type === 'gatherer' ? '#4a4' : a.type === 'terraformer' ? '#84530' : '#0af';
                        return `<div class="spectator-agent-card">
                            <span style="font-size: 20px;">${icon}</span>
                            <div style="flex: 1;">
                                <div style="color: #fff; font-size: 11px; font-weight: bold;">${a.name}</div>
                                <div style="color: ${typeColor}; font-size: 9px; text-transform: uppercase;">${a.type}</div>
                                <div style="color: #888; font-size: 10px; margin-top: 2px;">${a.status || 'Idle'}</div>
                            </div>
                        </div>`;
                    }).join('');
                }
                if (agentCount) {
                    agentCount.textContent = data.agents.length;
                }
                // Detect new agents for activity feed
                if (lastSpectatorData && data.agents.length > (lastSpectatorData.agents?.length || 0)) {
                    const newAgent = data.agents[data.agents.length - 1];
                    addSpectatorActivity(`New agent deployed: ${newAgent.name}`, 'success');
                }
            }

            // Update structure count and types
            const structureCount = document.getElementById('spectator-structures');
            const structureTypes = document.getElementById('spectator-structure-types');
            if (structureCount && data.structures) {
                structureCount.textContent = data.structures.length;
                // Detect new structures for activity feed
                if (lastSpectatorData && data.structures.length > (lastSpectatorData.structures?.length || 0)) {
                    addSpectatorActivity('New structure built!', 'success');
                }
            }
            if (structureTypes && data.structures) {
                // Count structure types
                const typeCounts = {};
                data.structures.forEach(s => {
                    typeCounts[s.type] = (typeCounts[s.type] || 0) + 1;
                });
                structureTypes.innerHTML = Object.entries(typeCounts).map(([type, count]) =>
                    `<span style="background: rgba(0,255,255,0.15); color: #0ff; padding: 3px 8px; border-radius: 10px; font-size: 10px;">
                        ${type === 'battery_charger' ? 'ðŸ”‹' : 'ðŸ—ï¸'} ${count}
                    </span>`
                ).join('');
            }

            // Update coordinates
            const coordsDisplay = document.getElementById('spectator-coords');
            if (coordsDisplay && data.player) {
                coordsDisplay.textContent = `X: ${Math.floor(data.player.x)} Z: ${Math.floor(data.player.z)}`;
            }

            // Store for comparison
            lastSpectatorData = { ...data };
        }

        // Add activity to spectator feed
        function addSpectatorActivity(message, type = 'info') {
            const activityFeed = document.getElementById('spectator-activity');
            if (!activityFeed) return;

            const time = new Date().toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
            const typeClass = type === 'danger' ? 'danger' : type === 'warning' ? 'warning' : type === 'success' ? 'success' : '';

            const item = document.createElement('div');
            item.className = `activity-item ${typeClass}`;
            item.innerHTML = `<span style="color: #666; font-size: 9px;">[${time}]</span> ${message}`;

            // Clear placeholder if first real activity
            if (spectatorActivityLog.length === 0) {
                activityFeed.innerHTML = '';
            }

            activityFeed.insertBefore(item, activityFeed.firstChild);
            spectatorActivityLog.unshift({ time, message, type });

            // Keep only last 50 items
            if (spectatorActivityLog.length > 50) {
                spectatorActivityLog.pop();
                if (activityFeed.lastChild) {
                    activityFeed.removeChild(activityFeed.lastChild);
                }
            }
        }

        // Enter spectator mode - now shows real 3D world with synced view
        function enterSpectatorMode() {
            p2pStreaming.isSpectating = true;

            // Reset activity log
            spectatorActivityLog = [];
            lastSpectatorData = null;

            // Show spectator banner instead of full overlay
            showSpectatorBanner();

            // Add connected activity
            addSpectatorActivity('Connected to stream!', 'success');

            // Disable player controls but keep 3D rendering active
            // Player input will be ignored in spectator mode
            showNotification('ðŸ‘ï¸ SPECTATING - Following host\'s view', 'info');
        }

        // Show minimal spectator banner
        function showSpectatorBanner() {
            // Create spectator banner if not exists
            let banner = document.getElementById('spectator-banner');
            if (!banner) {
                banner = document.createElement('div');
                banner.id = 'spectator-banner';
                banner.innerHTML = `
                    <div id="spectator-banner-inner" style="position: fixed; top: 0; left: 0; right: 0; background: linear-gradient(180deg, rgba(255,68,68,0.9), rgba(200,0,0,0.7));
                        padding: 8px 20px; display: flex; justify-content: space-between; align-items: center; z-index: 10000; border-bottom: 2px solid #f44;">
                        <div style="display: flex; align-items: center; gap: 12px;">
                            <div id="mode-indicator" style="width: 10px; height: 10px; background: #fff; border-radius: 50%; animation: pulse-banner 1s infinite;"></div>
                            <span id="mode-label" style="font-weight: bold; color: #fff;">ðŸ‘ï¸ SPECTATOR MODE</span>
                            <span style="color: rgba(255,255,255,0.8); font-size: 12px;">Following: <span id="spectator-host-name">Host</span></span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 15px;">
                            <span id="spectator-latency-display" style="color: rgba(255,255,255,0.7); font-size: 11px;">Latency: --ms</span>
                            <button id="toggle-active-btn" style="background: linear-gradient(45deg, #06ffa5, #00ff88); border: none; color: #000;
                                padding: 6px 14px; border-radius: 15px; cursor: pointer; font-size: 11px; font-weight: bold; transition: all 0.3s;">â¸ï¸ PAUSE</button>
                            <button id="exit-spectator-btn" style="background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.5); color: #fff;
                                padding: 6px 16px; border-radius: 15px; cursor: pointer; font-size: 12px; font-weight: bold;">EXIT</button>
                        </div>
                    </div>
                    <style>
                        @keyframes pulse-banner { 0%, 100% { opacity: 1; } 50% { opacity: 0.4; } }
                        @keyframes pulse-active { 0%, 100% { box-shadow: 0 0 10px #0f0; } 50% { box-shadow: 0 0 20px #0f0, 0 0 30px #0f0; } }
                    </style>
                `;
                document.body.appendChild(banner);

                // Add exit button listener
                document.getElementById('exit-spectator-btn').addEventListener('click', exitSpectatorMode);

                // Add pause/play toggle listener
                document.getElementById('toggle-active-btn').addEventListener('click', toggleStreamPause);
            }
            banner.style.display = 'block';

            // Also show mini stats overlay at bottom
            showSpectatorStats();
        }

        // v5.20: Toggle stream pause/play
        function toggleStreamPause() {
            p2pStreaming.streamPaused = !p2pStreaming.streamPaused;

            const toggleBtn = document.getElementById('toggle-active-btn');

            if (p2pStreaming.streamPaused) {
                toggleBtn.innerHTML = 'â–¶ï¸ RESUME';
                toggleBtn.style.background = 'linear-gradient(45deg, #f44, #f80)';
                showNotification('â¸ï¸ Stream paused - camera frozen', 'info');
            } else {
                toggleBtn.innerHTML = 'â¸ï¸ PAUSE';
                toggleBtn.style.background = 'linear-gradient(45deg, #06ffa5, #00ff88)';
                showNotification('â–¶ï¸ Stream resumed - following host', 'info');
            }
        }

        // Show spectator stats overlay
        function showSpectatorStats() {
            let statsOverlay = document.getElementById('spectator-stats-overlay');
            if (!statsOverlay) {
                statsOverlay = document.createElement('div');
                statsOverlay.id = 'spectator-stats-overlay';
                statsOverlay.innerHTML = `
                    <div style="position: fixed; bottom: 20px; left: 20px; background: rgba(0,0,0,0.8); border: 1px solid rgba(0,255,255,0.3);
                        border-radius: 10px; padding: 15px; min-width: 200px; z-index: 9999;">
                        <div style="color: #0ff; font-size: 11px; font-weight: bold; margin-bottom: 10px;">ðŸ“Š HOST STATS</div>
                        <div style="display: flex; flex-direction: column; gap: 8px;">
                            <div>
                                <div style="display: flex; justify-content: space-between; font-size: 10px; margin-bottom: 3px;">
                                    <span style="color: #888;">INTEGRITY</span>
                                    <span id="spec-hp" style="color: #4f4;">100/100</span>
                                </div>
                                <div style="background: #222; height: 6px; border-radius: 3px; overflow: hidden;">
                                    <div id="spec-hp-bar" style="width: 100%; height: 100%; background: linear-gradient(90deg, #f44, #4f4);"></div>
                                </div>
                            </div>
                            <div>
                                <div style="display: flex; justify-content: space-between; font-size: 10px; margin-bottom: 3px;">
                                    <span style="color: #888;">âš¡ ENERGY</span>
                                    <span id="spec-energy" style="color: #0af;">100/100</span>
                                </div>
                                <div style="background: #222; height: 6px; border-radius: 3px; overflow: hidden;">
                                    <div id="spec-energy-bar" style="width: 100%; height: 100%; background: #0af;"></div>
                                </div>
                            </div>
                            <div style="display: flex; justify-content: space-between; font-size: 10px; color: #666; margin-top: 5px;">
                                <span>Coords:</span>
                                <span id="spec-coords" style="color: #0ff; font-family: monospace;">X: 0 Z: 0</span>
                            </div>
                        </div>
                    </div>
                `;
                document.body.appendChild(statsOverlay);
            }
            statsOverlay.style.display = 'block';
        }

        // Exit spectator mode
        function exitSpectatorMode() {
            p2pStreaming.isSpectating = false;

            if (p2pStreaming.hostConnection) {
                p2pStreaming.hostConnection.close();
                p2pStreaming.hostConnection = null;
            }

            // Hide spectator UI
            const banner = document.getElementById('spectator-banner');
            if (banner) banner.style.display = 'none';
            const statsOverlay = document.getElementById('spectator-stats-overlay');
            if (statsOverlay) statsOverlay.style.display = 'none';

            // Reload page to reset game state
            location.reload();
        }

        // Open Show Mode modal with QR code
        function openShowModeModal() {
            const modal = document.getElementById('show-mode-modal');
            modal.style.display = 'flex';
            p2pStreaming.qrCodeVisible = true;

            // Generate QR code
            generateSpectatorQRCode();

            // Update URL display
            if (p2pStreaming.peerId) {
                const spectatorUrl = `${window.location.origin}${window.location.pathname}?spectate=${p2pStreaming.peerId}`;
                document.getElementById('qr-url').textContent = spectatorUrl;
            } else {
                document.getElementById('qr-url').textContent = 'Connecting to P2P network...';
            }

            updateP2PStatusUI();
        }

        // Close Show Mode modal
        function closeShowModeModal() {
            const modal = document.getElementById('show-mode-modal');
            modal.style.display = 'none';
            p2pStreaming.qrCodeVisible = false;
            updateP2PStatusUI();
        }

        // Copy URL from Show Mode modal
        function copyShowModeUrl() {
            if (!p2pStreaming.peerId) {
                showNotification('Not connected yet', 'error');
                return;
            }

            const spectatorUrl = `${window.location.origin}${window.location.pathname}?spectate=${p2pStreaming.peerId}`;
            const btn = document.getElementById('copy-url-btn');

            navigator.clipboard.writeText(spectatorUrl).then(() => {
                showNotification('ðŸ“‹ Spectator link copied!', 'info');
                btn.textContent = 'COPIED!';
                btn.style.background = 'linear-gradient(45deg, #06ffa5, #00ff88)';
                setTimeout(() => {
                    btn.textContent = 'COPY URL';
                    btn.style.background = 'linear-gradient(45deg, #00ffff, #0088ff)';
                }, 2000);
            }).catch(() => {
                // Fallback for older browsers
                const textarea = document.createElement('textarea');
                textarea.value = spectatorUrl;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                showNotification('ðŸ“‹ Spectator link copied!', 'info');
                btn.textContent = 'COPIED!';
                btn.style.background = 'linear-gradient(45deg, #06ffa5, #00ff88)';
                setTimeout(() => {
                    btn.textContent = 'COPY URL';
                    btn.style.background = 'linear-gradient(45deg, #00ffff, #0088ff)';
                }, 2000);
            });
        }

        // Legacy function for compatibility
        function toggleMinimapShare() {
            if (p2pStreaming.qrCodeVisible) {
                closeShowModeModal();
            } else {
                openShowModeModal();
            }
        }

        // Legacy copy function
        function copyShareLink(event) {
            if (event) event.stopPropagation();
            copyShowModeUrl();
        }

        // Update P2P status UI
        function updateP2PStatusUI() {
            const statusEl = document.getElementById('p2p-status');
            const countEl = document.getElementById('spectator-count');

            if (statusEl) {
                statusEl.textContent = p2pStreaming.isHost ?
                    (p2pStreaming.qrCodeVisible ? 'ðŸ“¡ STREAMING' : 'ðŸ”’ PRIVATE') :
                    'ðŸ‘ï¸ SPECTATING';
                statusEl.style.color = p2pStreaming.qrCodeVisible ? '#00ff88' : '#888';
            }
            if (countEl) {
                countEl.textContent = p2pStreaming.spectatorCount > 0 ?
                    `${p2pStreaming.spectatorCount} ðŸ‘ï¸` : '';
            }
        }

        // Check URL for spectator mode on load
        function checkSpectatorMode() {
            const params = new URLSearchParams(window.location.search);
            const spectateId = params.get('spectate');

            if (spectateId) {
                // Connect as spectator
                setTimeout(() => connectAsSpectator(spectateId), 1000);
            } else {
                // Initialize as host
                setTimeout(initP2PHost, 2000);
            }
        }

        // Initialize Show Mode button event listeners (called after DOM ready)
        function initShowModeButtons() {
            const closeBtn = document.getElementById('close-show-mode-btn');
            const copyBtn = document.getElementById('copy-url-btn');
            const modal = document.getElementById('show-mode-modal');

            if (closeBtn) {
                closeBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    closeShowModeModal();
                });
                // Hover effects
                closeBtn.addEventListener('mouseover', function() {
                    this.style.color = '#ff006e';
                    this.style.transform = 'rotate(90deg)';
                });
                closeBtn.addEventListener('mouseout', function() {
                    this.style.color = '#fff';
                    this.style.transform = 'rotate(0deg)';
                });
            }

            if (copyBtn) {
                copyBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    copyShowModeUrl();
                });
                // Hover effects
                copyBtn.addEventListener('mouseover', function() {
                    this.style.transform = 'translateY(-2px)';
                    this.style.boxShadow = '0 4px 20px rgba(0,255,255,0.4)';
                });
                copyBtn.addEventListener('mouseout', function() {
                    this.style.transform = 'translateY(0)';
                    this.style.boxShadow = 'none';
                });
            }

            // Close modal when clicking outside content
            if (modal) {
                modal.addEventListener('click', function(e) {
                    if (e.target === modal) {
                        closeShowModeModal();
                    }
                });
            }

            console.log('Show Mode buttons initialized');
        }

        function createMob(rng, biome) {
            // v4.2: Select enemy type based on biome
            const biomeKey = biome.name === 'Terra' ? 'Terra' :
                            biome.name === 'Desert' ? 'Desert' :
                            biome.name === 'Tundra' ? 'Ice' :
                            biome.name === 'Xeno' ? 'Alien' :
                            biome.name === 'Magma' ? 'Volcanic' : 'Terra';

            const validEnemies = Object.entries(ENEMY_TYPES)
                .filter(([name, data]) => data.biomes.includes(biomeKey));

            const [enemyName, enemyData] = validEnemies.length > 0
                ? validEnemies[rng.int(0, validEnemies.length - 1)]
                : ['Slime', ENEMY_TYPES.Slime];

            // v4.7: Elite enemy roll
            const prestigeLevel = gameData.prestige?.level || 0;
            const isElite = prestigeLevel >= ELITE_CONFIG.minWorldLevel &&
                           rng.next() < ELITE_CONFIG.spawnChance;

            let eliteAffix = null;
            let eliteData = null;
            if (isElite) {
                const affixKeys = Object.keys(ELITE_AFFIXES);
                const affixKey = affixKeys[rng.int(0, affixKeys.length - 1)];
                eliteAffix = affixKey;
                eliteData = ELITE_AFFIXES[affixKey];
            }

            // Calculate stats with elite multipliers
            const baseHp = enemyData.hp * (eliteData ? eliteData.hpMult : 1);
            const baseDamage = enemyData.damage * (eliteData ? eliteData.damageMult : 1);
            const baseSpeed = enemyData.speed * (eliteData ? eliteData.speedMult : 1);

            const mobGeo = new THREE.SphereGeometry(isElite ? 1.0 : 0.8, 16, 16);
            const mobMat = new THREE.MeshStandardMaterial({
                color: eliteData ? eliteData.color : enemyData.color,
                roughness: 0.3,
                emissive: eliteData ? eliteData.color : enemyData.emissive,
                emissiveIntensity: isElite ? 0.5 : 0.2
            });
            const mob = new THREE.Mesh(mobGeo, mobMat);

            const rx = (rng.next() - 0.5) * 60;
            const rz = (rng.next() - 0.5) * 60;
            mob.position.set(rx, 10, rz);
            mob.castShadow = true;

            // v4.7: Add glowing aura ring for elite enemies
            if (isElite) {
                const auraGeo = new THREE.RingGeometry(1.2, 1.5, 32);
                const auraMat = new THREE.MeshBasicMaterial({
                    color: eliteData.color,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.6
                });
                const aura = new THREE.Mesh(auraGeo, auraMat);
                aura.rotation.x = -Math.PI / 2;
                aura.position.y = 0.1;
                mob.add(aura);
                mob.userData.auraRing = aura;
            }

            // v5.12: Hypnotist special eye appearance
            if (enemyData.isHypnotist) {
                // Create eye-like structure with iris and pupil
                const irisGeo = new THREE.CircleGeometry(0.5, 32);
                const irisMat = new THREE.MeshBasicMaterial({
                    color: 0x8800ff,
                    side: THREE.DoubleSide
                });
                const iris = new THREE.Mesh(irisGeo, irisMat);
                iris.position.z = 0.75;
                mob.add(iris);

                // Pupil (inner dark circle that moves)
                const pupilGeo = new THREE.CircleGeometry(0.25, 32);
                const pupilMat = new THREE.MeshBasicMaterial({
                    color: 0x000000,
                    side: THREE.DoubleSide
                });
                const pupil = new THREE.Mesh(pupilGeo, pupilMat);
                pupil.position.z = 0.76;
                mob.add(pupil);
                mob.userData.pupil = pupil;
                mob.userData.iris = iris;

                // Glowing concentric rings around the eye
                for (let i = 0; i < 3; i++) {
                    const ringGeo = new THREE.RingGeometry(0.9 + i * 0.3, 1.0 + i * 0.3, 32);
                    const ringMat = new THREE.MeshBasicMaterial({
                        color: i % 2 === 0 ? 0xff00ff : 0x8800ff,
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 0.5 - i * 0.1
                    });
                    const ring = new THREE.Mesh(ringGeo, ringMat);
                    ring.position.z = 0.74 - i * 0.02;
                    mob.add(ring);
                }

                // Give it a floating, creepy movement
                mob.userData.isHypnotist = true;
            }

            // Health bar above mob (larger for elites)
            const hpBar = new THREE.Mesh(
                new THREE.PlaneGeometry(isElite ? 2.0 : 1.5, 0.15),
                new THREE.MeshBasicMaterial({ color: isElite ? 0xffaa00 : 0x00ff00, side: THREE.DoubleSide })
            );
            hpBar.position.y = isElite ? 1.8 : 1.5;
            mob.add(hpBar);

            const hpBg = new THREE.Mesh(
                new THREE.PlaneGeometry(isElite ? 2.1 : 1.6, 0.2),
                new THREE.MeshBasicMaterial({ color: isElite ? 0x553300 : 0x333333, side: THREE.DoubleSide })
            );
            hpBg.position.y = isElite ? 1.8 : 1.5;
            hpBg.position.z = -0.01;
            mob.add(hpBg);

            // v5.3: Apply portal modifiers to mob stats
            const portalMods = getPortalModifiers();
            let finalHp = baseHp;
            let finalDamage = baseDamage;
            if (portalMods) {
                finalHp = Math.floor(baseHp * (portalMods.enemyHp || 1));
                finalDamage = Math.floor(baseDamage * (portalMods.enemyDamage || 1));
            }

            mob.userData = {
                type: 'mob',
                hp: finalHp,
                maxHp: finalHp,
                name: enemyName,
                damage: finalDamage,
                speed: baseSpeed,
                drops: enemyData.drops,
                xpReward: enemyData.xp * (isElite ? ELITE_CONFIG.bonusXpMult : 1),
                nextMove: 0,
                nextAttack: 0,
                targetPos: new THREE.Vector3(),
                hpBar,
                // v4.5: Attack telegraph properties
                attackWindup: enemyData.attackWindup || 600,
                attackRange: enemyData.attackRange || 2.5,
                telegraphing: false,
                // v4.7: Elite properties
                isElite: isElite,
                eliteAffix: eliteAffix,
                eliteData: eliteData,
                displayName: isElite ? `${eliteData.prefix} ${eliteData.name} ${enemyName}` : enemyName,
                // v5.3: Portal-modified flag
                portalBuffed: portalMods !== null
            };

            scene.add(mob);
            worldState.mobs.push(mob);

            // v4.7: Announce elite spawn
            if (isElite) {
                showNotification(`${eliteData.prefix} ELITE ${eliteData.name} ${enemyName} appeared!`, 'warning');
            }
        }

        // v4.2: Create Point of Interest
        function createPOI(rng, biome, poiType, poiData) {
            const group = new THREE.Group();

            // Create visual marker based on POI type
            const baseGeo = new THREE.CylinderGeometry(2, 2.5, 0.5, 8);
            const baseMat = new THREE.MeshStandardMaterial({
                color: 0x886644,
                roughness: 0.8
            });
            const base = new THREE.Mesh(baseGeo, baseMat);
            group.add(base);

            // Add glowing beacon
            const beaconGeo = new THREE.CylinderGeometry(0.3, 0.3, 4, 8);
            const beaconMat = new THREE.MeshStandardMaterial({
                color: 0xffdd00,
                emissive: 0xffaa00,
                emissiveIntensity: 0.5
            });
            const beacon = new THREE.Mesh(beaconGeo, beaconMat);
            beacon.position.y = 2.5;
            group.add(beacon);

            // Floating icon sphere
            const iconGeo = new THREE.SphereGeometry(0.6, 16, 16);
            const iconMat = new THREE.MeshStandardMaterial({
                color: 0x44ffff,
                emissive: 0x22aaaa,
                transparent: true,
                opacity: 0.8
            });
            const icon = new THREE.Mesh(iconGeo, iconMat);
            icon.position.y = 5;
            group.add(icon);

            const rx = (rng.next() - 0.5) * 50;
            const rz = (rng.next() - 0.5) * 50;
            group.position.set(rx, 0, rz);

            group.userData = {
                type: 'poi',
                poiType: poiType,
                name: poiData.name,
                icon: poiData.icon,
                rewards: poiData.rewards,
                xpBonus: poiData.xpBonus,
                discovered: false,
                beacon: beacon,
                iconMesh: icon
            };

            scene.add(group);
            worldState.pois.push(group);
            worldState.interactables.push(group);
        }

        // v4.3: Create Boss
        function createBoss(biomeKey) {
            const bossId = `${biomeKey}_Boss`;
            const bossData = BOSS_TYPES[bossId];
            if (!bossData) return;

            // Create larger, more intimidating boss mesh
            const bossGeo = new THREE.SphereGeometry(0.8 * bossData.scale, 24, 24);
            const bossMat = new THREE.MeshStandardMaterial({
                color: bossData.color,
                roughness: 0.2,
                emissive: bossData.emissive,
                emissiveIntensity: 0.5
            });
            const boss = new THREE.Mesh(bossGeo, bossMat);

            // Position boss away from spawn
            boss.position.set(
                (Math.random() - 0.5) * 40,
                15,
                (Math.random() - 0.5) * 40
            );
            boss.castShadow = true;

            // Boss health bar (larger)
            const hpBar = new THREE.Mesh(
                new THREE.PlaneGeometry(3, 0.3),
                new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide })
            );
            hpBar.position.y = 3;
            boss.add(hpBar);

            const hpBg = new THREE.Mesh(
                new THREE.PlaneGeometry(3.2, 0.4),
                new THREE.MeshBasicMaterial({ color: 0x333333, side: THREE.DoubleSide })
            );
            hpBg.position.y = 3;
            hpBg.position.z = -0.01;
            boss.add(hpBg);

            // Crown/indicator for boss
            const crownGeo = new THREE.ConeGeometry(0.5, 0.8, 4);
            const crownMat = new THREE.MeshStandardMaterial({ color: 0xffd700, emissive: 0xaa8800 });
            const crown = new THREE.Mesh(crownGeo, crownMat);
            crown.position.y = bossData.scale * 0.8 + 0.5;
            crown.rotation.y = Math.PI / 4;
            boss.add(crown);

            boss.userData = {
                type: 'boss',
                bossId: bossId,
                hp: bossData.hp,
                maxHp: bossData.hp,
                name: bossData.name,
                damage: bossData.damage,
                speed: bossData.speed,
                scale: bossData.scale,
                drops: bossData.drops,
                xpReward: bossData.xp,
                nextMove: 0,
                nextAttack: 0,
                targetPos: new THREE.Vector3(),
                hpBar,
                isBoss: true
            };

            scene.add(boss);
            worldState.mobs.push(boss);

            // Announce boss spawn
            showNotification(`BOSS APPEARED: ${bossData.name}!`, 'error');
            AudioSystem.bossSpawn();

            return boss;
        }

        // v4.3: Track world mob kills for boss spawning
        let worldMobKillCount = 0;
        let bossSpawned = false;

        function checkBossSpawn() {
            if (bossSpawned || !activeCiv) return;

            // Find the appropriate boss for this biome
            const biomeKey = activeCiv.biome;
            const bossId = `${biomeKey}_Boss`;
            const bossData = BOSS_TYPES[bossId];

            if (!bossData) return;

            const condition = bossData.spawnCondition;

            // v4.5: Check mob kill requirement
            if (worldMobKillCount < condition.mobsKilled) return;

            // v4.5: Check combat level requirement
            if (condition.minCombatLevel && gameData.skills.combat.level < condition.minCombatLevel) {
                // Show hint if close to spawning
                if (worldMobKillCount === condition.mobsKilled) {
                    showNotification(`Boss requires Combat Level ${condition.minCombatLevel}!`, 'warning');
                }
                return;
            }

            // v4.5: Check required item
            if (condition.requiredItem && !hasItem(condition.requiredItem)) {
                if (worldMobKillCount === condition.mobsKilled) {
                    showNotification(`Boss requires ${condition.requiredItem} equipped!`, 'warning');
                }
                return;
            }

            createBoss(biomeKey);
            bossSpawned = true;
        }

        // --- GAME LOOP ---
        // v4.7: Tab visibility handling
        let tabVisible = true;
        let lastFpsTime = 0;
        let frameCount = 0;
        let currentFps = 60;

        document.addEventListener('visibilitychange', () => {
            tabVisible = !document.hidden;
            if (tabVisible) {
                // Reset timing when tab becomes visible to prevent huge dt
                lastTime = performance.now();
                AudioSystem.resume();
            } else {
                // Pause audio when tab is hidden
                if (AudioSystem.ctx && AudioSystem.ctx.state === 'running') {
                    AudioSystem.ctx.suspend();
                }
            }
        });

        function loop(time) {
            requestAnimationFrame(loop);

            // v4.7: Skip updates when tab is not visible (save resources)
            if (!tabVisible) {
                return;
            }

            // v4.7: Track FPS for adaptive performance
            frameCount++;
            if (time - lastFpsTime >= 1000) {
                currentFps = frameCount;
                frameCount = 0;
                lastFpsTime = time;

                // Adaptive performance: reduce particles if FPS drops
                if (currentFps < 30 && particles && particles.maxParticles > 25) {
                    particles.maxParticles = Math.max(25, particles.maxParticles - 10);
                    console.log('Performance: Reduced particles to', particles.maxParticles);
                } else if (currentFps > 55 && particles && particles.maxParticles < 100) {
                    particles.maxParticles = Math.min(100, particles.maxParticles + 5);
                }
            }

            // v4.4: Hit-stop effect - skip game logic during freeze, still render
            if (performance.now() < hitStopUntil) {
                renderer.render(scene, camera);
                return;
            }

            const dt = Math.min((time - lastTime) / 1000, 0.1);
            lastTime = time;

            gameData.playtime += dt;

            if(mode === 'galaxy') {
                galaxyGroup.rotation.y += 0.0005;
                cycle = Math.floor(time / 1000);
                document.getElementById('cycle-count').innerText = cycle;

                if(activeCiv) {
                    selectionRing.rotation.z -= 0.01;
                    const pulse = 1 + Math.sin(time * 0.005) * 0.1;
                    selectionRing.scale.set(pulse, pulse, 1);
                }

                if (cycle % 10 === 0) updatePlaytimeDisplay();
            }
            else if(mode === 'world') {
                updateWorld(dt, time);
            }

            renderer.render(scene, camera);
        }

        function updateWorld(dt, time) {
            // Day/Night Cycle
            worldState.timeOfDay = (time * 0.00005) % 1;
            const angle = worldState.timeOfDay * Math.PI * 2;
            const radius = 80;

            worldState.sun.position.set(Math.cos(angle)*radius, Math.sin(angle)*radius, 50);
            worldState.sun.intensity = Math.max(0.1, Math.sin(angle)) * 1.2;

            const biome = BIOMES[activeCiv.biome];
            const dayColor = new THREE.Color(biome.sky);
            const nightColor = new THREE.Color(0x050510);
            scene.background.lerpColors(nightColor, dayColor, Math.max(0.1, Math.sin(angle)));
            scene.fog.color.copy(scene.background);

            // Player Movement
            const p = worldState.player;

            // v4.7: Check and clear chilled status
            if (playerState.chilled && time > playerState.chilledEnd) {
                playerState.chilled = false;
                playerState.moveSpeedMult = 1.0;
            }
            // v5.0: Apply weather speed modifier, v5.1: Apply equipment move speed
            const equipStats = getEquipmentStats();
            const speed = 12 * playerState.moveSpeedMult * getWeatherSpeedMod() * equipStats.moveSpeed;

            // v4.0: WASD keyboard movement + v4.3: Virtual joystick
            const hasKeyInput = keys.w || keys.a || keys.s || keys.d;
            const hasJoystickInput = joystickActive && (Math.abs(joystickInput.x) > 0.1 || Math.abs(joystickInput.y) > 0.1);

            // v5.5: Disable autopilot if player takes manual control
            if (hasKeyInput || hasJoystickInput) {
                if (autoExplore.enabled) {
                    autoExplore.enabled = false;
                    autoExplore.currentTarget = null;
                    updateAutoExploreUI();
                    showNotification('MANUAL OVERRIDE - Autopilot disengaged', 'info');
                }
            }

            // v5.5: Run autonomous exploration if enabled
            if (autoExplore.enabled) {
                runAutoExplore(dt);
            }

            if (hasKeyInput || hasJoystickInput) {
                _tempVec3A.set(0, 0, 0);
                if (hasKeyInput) {
                    if (keys.w) _tempVec3A.z -= 1;
                    if (keys.s) _tempVec3A.z += 1;
                    if (keys.a) _tempVec3A.x -= 1;
                    if (keys.d) _tempVec3A.x += 1;
                } else if (hasJoystickInput) {
                    // v4.3: Joystick input (x is left/right, y is up/down on screen = forward/back in 3D)
                    _tempVec3A.x = joystickInput.x;
                    _tempVec3A.z = joystickInput.y;
                }
                _tempVec3A.normalize().multiplyScalar(speed * dt);
                p.position.add(_tempVec3A);
                worldState.target = null;
                worldState.interactTarget = null;
                // Face movement direction
                if (_tempVec3A.length() > 0.01) {
                    p.rotation.y = Math.atan2(_tempVec3A.x, _tempVec3A.z);
                }
            }

            // Click-to-move (using pre-allocated vector)
            if(worldState.target) {
                _tempVec3A.subVectors(worldState.target, p.position);
                _tempVec3A.y = 0;
                const dist = _tempVec3A.length();

                if(dist > CONFIG.MOVEMENT_THRESHOLD) {
                    _tempVec3A.normalize();
                    p.position.add(_tempVec3A.multiplyScalar(speed * dt));
                    p.lookAt(worldState.target.x, p.position.y, worldState.target.z);
                } else {
                    worldState.target = null;
                }
            }

            snapToGround(p);

            // v4.0: Cooldown-based interaction (replaces random chance)
            if(worldState.interactTarget) {
                const t = worldState.interactTarget;
                const dist = p.position.distanceTo(t.position);

                if(dist < CONFIG.INTERACTION_RANGE) {
                    worldState.target = null;

                    const now = performance.now();
                    if(now - worldState.lastActionTime > CONFIG.INTERACTION_COOLDOWN) {
                        performAction(t);
                        worldState.lastActionTime = now;
                    }
                } else if (!worldState.target) {
                    worldState.target = t.position.clone();
                }
            }

            // v5.11: Cinematic Camera Follow - player higher in frame
            camera.position.lerp(p.position.clone().add(_camOffset), 0.08);
            camera.lookAt(p.position.clone().add(_camLookOffset)); // Look below/ahead for cinematic view

            // v5.15: COMPREHENSIVE ROBOT ANIMATION SYSTEM
            if (p.userData.isRobot && p.userData.bones && p.userData.animation) {
                const anim = p.userData.animation;
                const bones = p.userData.bones;
                const dtMs = dt * 1000;

                // === DETECT ANIMATION STATE ===
                const hasKeyInput = keys.w || keys.a || keys.s || keys.d;
                const hasJoystickInput = joystickActive && (Math.abs(joystickInput.x) > 0.1 || Math.abs(joystickInput.y) > 0.1);
                const isMoving = hasKeyInput || hasJoystickInput || worldState.target;
                const isRunning = isMoving && keys.shift;

                // State transitions
                let targetState = 'idle';
                if (anim.damageFlash > 0) {
                    targetState = 'damage';
                } else if (anim.attackPhase > 0) {
                    targetState = 'attacking';
                } else if (anim.wavePhase > 0) {
                    targetState = 'waving';
                } else if (anim.jumpPhase > 0) {
                    targetState = 'jumping';
                } else if (isRunning) {
                    targetState = 'running';
                } else if (isMoving) {
                    targetState = 'walking';
                }

                // Handle state change
                if (targetState !== anim.state) {
                    anim.prevState = anim.state;
                    anim.state = targetState;
                    anim.stateTime = 0;
                    anim.blendTime = 0;
                }

                anim.stateTime += dtMs;
                anim.blendTime = Math.min(anim.blendTime + dtMs / 200, 1); // 200ms blend

                // === UPDATE ANIMATION PHASES ===
                anim.breathPhase += dtMs * 0.002;
                anim.headBob += dtMs * 0.003;
                anim.idleVariation += dtMs * 0.0005;

                // Walk cycle speed based on state
                const walkSpeed = anim.state === 'running' ? 0.015 : 0.008;
                if (anim.state === 'walking' || anim.state === 'running') {
                    anim.walkCycle += dtMs * walkSpeed;
                } else {
                    // Smoothly return to neutral when stopped
                    anim.walkCycle *= 0.92;
                }

                // Decay special animation phases
                if (anim.attackPhase > 0) anim.attackPhase = Math.max(0, anim.attackPhase - dtMs * 0.004);
                if (anim.wavePhase > 0) anim.wavePhase = Math.max(0, anim.wavePhase - dtMs * 0.002);
                if (anim.jumpPhase > 0) anim.jumpPhase = Math.max(0, anim.jumpPhase - dtMs * 0.003);
                if (anim.damageFlash > 0) anim.damageFlash = Math.max(0, anim.damageFlash - dtMs * 0.005);

                // === BLINK TIMER ===
                anim.blinkTimer += dtMs;
                if (!anim.isBlinking && anim.blinkTimer > anim.nextBlink) {
                    anim.isBlinking = true;
                    anim.blinkTimer = 0;
                }
                if (anim.isBlinking && anim.blinkTimer > 150) {
                    anim.isBlinking = false;
                    anim.blinkTimer = 0;
                    anim.nextBlink = 2000 + Math.random() * 4000;
                }

                // === APPLY ANIMATIONS TO BONES ===

                // --- BODY CORE (breathing, walking bob) ---
                const breathOffset = Math.sin(anim.breathPhase) * 0.02;
                let bodyBob = 0;
                if (anim.state === 'walking') {
                    bodyBob = Math.abs(Math.sin(anim.walkCycle * 2)) * 0.04;
                } else if (anim.state === 'running') {
                    bodyBob = Math.abs(Math.sin(anim.walkCycle * 2)) * 0.08;
                }
                bones.bodyCore.position.y = 0.75 + breathOffset + bodyBob;

                // Slight forward lean when moving
                const leanForward = (anim.state === 'walking') ? 0.05 : (anim.state === 'running') ? 0.12 : 0;
                bones.bodyCore.rotation.x = leanForward;

                // --- HEAD (look, nod, idle sway) ---
                let headNod = Math.sin(anim.headBob) * 0.03;
                let headTilt = Math.sin(anim.idleVariation) * 0.02;

                if (anim.state === 'walking' || anim.state === 'running') {
                    // Head bobs opposite to body
                    headNod = -Math.sin(anim.walkCycle * 2) * 0.05;
                }

                bones.headGroup.rotation.x = headNod;
                bones.headGroup.rotation.z = headTilt;

                // Curious head tilt during idle
                if (anim.state === 'idle') {
                    bones.headGroup.rotation.y = Math.sin(anim.idleVariation * 0.7) * 0.1;
                } else {
                    bones.headGroup.rotation.y *= 0.9; // Return to center
                }

                // --- ARMS (walking swing, idle sway, special animations) ---
                const walkSwingL = Math.sin(anim.walkCycle) * (anim.state === 'running' ? 0.8 : 0.4);
                const walkSwingR = Math.sin(anim.walkCycle + Math.PI) * (anim.state === 'running' ? 0.8 : 0.4);

                // Idle arm positions - slightly bent, natural
                let leftArmRotX = 0.1 + Math.sin(anim.breathPhase * 0.5) * 0.03;
                let rightArmRotX = 0.1 + Math.sin(anim.breathPhase * 0.5 + 0.5) * 0.03;
                let leftElbowBend = -0.2;
                let rightElbowBend = -0.2;

                if (anim.state === 'walking' || anim.state === 'running') {
                    leftArmRotX = walkSwingL;
                    rightArmRotX = walkSwingR;
                    // Elbows bend more when arms swing back
                    leftElbowBend = -0.2 - Math.max(0, -walkSwingL) * 0.5;
                    rightElbowBend = -0.2 - Math.max(0, -walkSwingR) * 0.5;
                }

                // Wave animation (right arm)
                if (anim.wavePhase > 0) {
                    const waveT = anim.wavePhase;
                    rightArmRotX = -0.3; // Arm raised
                    bones.rightArm.upperGroup.rotation.z = -1.2 * waveT; // Arm out to side and up
                    bones.rightArm.lowerGroup.rotation.x = -1.5 + Math.sin(time * 0.015) * 0.4 * waveT; // Waving motion
                } else {
                    bones.rightArm.upperGroup.rotation.z = 0;
                }

                // Attack animation (both arms thrust forward)
                if (anim.attackPhase > 0) {
                    const attackT = anim.attackPhase;
                    leftArmRotX = -1.2 * attackT;
                    rightArmRotX = -1.2 * attackT;
                    leftElbowBend = -0.8 * attackT;
                    rightElbowBend = -0.8 * attackT;
                }

                bones.leftArm.upperGroup.rotation.x = leftArmRotX;
                bones.rightArm.upperGroup.rotation.x = rightArmRotX;
                bones.leftArm.lowerGroup.rotation.x = leftElbowBend;
                bones.rightArm.lowerGroup.rotation.x = rightElbowBend;

                // --- LEGS (walking, running, jumping) ---
                const legSwingL = Math.sin(anim.walkCycle) * (anim.state === 'running' ? 0.7 : 0.35);
                const legSwingR = Math.sin(anim.walkCycle + Math.PI) * (anim.state === 'running' ? 0.7 : 0.35);

                let leftLegRotX = 0;
                let rightLegRotX = 0;
                let leftKneeBend = 0;
                let rightKneeBend = 0;

                if (anim.state === 'walking' || anim.state === 'running') {
                    leftLegRotX = legSwingL;
                    rightLegRotX = legSwingR;
                    // Knees bend when leg swings back
                    leftKneeBend = Math.max(0, -legSwingL) * 0.8;
                    rightKneeBend = Math.max(0, -legSwingR) * 0.8;
                }

                // Jump animation
                if (anim.jumpPhase > 0) {
                    const jumpT = anim.jumpPhase;
                    // Crouch then extend
                    const crouchPhase = jumpT > 0.5 ? (1 - jumpT) * 2 : jumpT * 2;
                    leftLegRotX = -0.3 * crouchPhase;
                    rightLegRotX = -0.3 * crouchPhase;
                    leftKneeBend = 0.6 * crouchPhase;
                    rightKneeBend = 0.6 * crouchPhase;
                }

                bones.leftLeg.upperGroup.rotation.x = leftLegRotX;
                bones.rightLeg.upperGroup.rotation.x = rightLegRotX;
                bones.leftLeg.lowerGroup.rotation.x = leftKneeBend;
                bones.rightLeg.lowerGroup.rotation.x = rightKneeBend;

                // === VISUAL EFFECTS ===

                // Antenna sway
                if (p.userData.antenna) {
                    const sway = Math.sin(anim.breathPhase * 2) * 0.1 + (anim.state === 'running' ? Math.sin(anim.walkCycle * 2) * 0.15 : 0);
                    p.userData.antenna.rotation.z = sway;
                }

                // Antenna light pulse
                if (p.userData.antennaLight) {
                    const antPulse = (Math.sin(time * 0.003) + 1) / 2;
                    let r = antPulse * 0.2, g = 0.5 + antPulse * 0.5, b = antPulse * 0.4;
                    if (anim.state === 'running') { r = 0.8; g = 0.6; b = 0.1; } // Orange when running
                    if (anim.damageFlash > 0) { r = 1; g = 0.1; b = 0.1; } // Red when damaged
                    p.userData.antennaLight.material.color.setRGB(r, g, b);
                }

                // Heart/status light based on health
                if (p.userData.statusStrip) {
                    const hpPercent = (gameData.player?.hp || 100) / (gameData.player?.maxHp || 100);
                    const pulse = (Math.sin(time * 0.004) + 1) / 2;
                    let r, g, b;
                    if (anim.damageFlash > 0) {
                        r = 1; g = 0; b = 0; // Flash red on damage
                    } else if (hpPercent > 0.5) {
                        r = 0; g = 0.7 + pulse * 0.3; b = 0.5;
                    } else if (hpPercent > 0.25) {
                        r = 1; g = 0.5 + pulse * 0.2; b = 0;
                    } else {
                        r = 0.8 + pulse * 0.2; g = 0; b = 0;
                    }
                    p.userData.statusStrip.material.color.setRGB(r, g, b);
                }

                // Eye effects
                const eyePulse = 0.7 + Math.sin(time * 0.003) * 0.3;
                const blinkScale = anim.isBlinking ? 0.1 : 1;

                if (p.userData.robotEye) {
                    p.userData.robotEye.material.emissiveIntensity = eyePulse;
                    p.userData.robotEye.scale.y = blinkScale;
                }
                if (p.userData.leftEye) {
                    p.userData.leftEye.material.emissiveIntensity = eyePulse;
                    p.userData.leftEye.scale.y = blinkScale;
                }

                // Pupils follow slight movement (curious robot look)
                if (p.userData.leftPupil && p.userData.rightPupil) {
                    const pupilOffset = Math.sin(anim.idleVariation * 0.3) * 0.02;
                    p.userData.leftPupil.position.x = -0.15 + pupilOffset;
                    p.userData.rightPupil.position.x = 0.15 + pupilOffset;
                    p.userData.leftPupil.scale.y = blinkScale;
                    p.userData.rightPupil.scale.y = blinkScale;
                }

                // Eyebrow expressions
                if (p.userData.leftBrow && p.userData.rightBrow) {
                    let browAngle = 0.2; // Neutral friendly
                    if (anim.damageFlash > 0) browAngle = -0.3; // Concerned
                    if (anim.state === 'running') browAngle = 0.4; // Determined
                    p.userData.leftBrow.rotation.z = browAngle;
                    p.userData.rightBrow.rotation.z = -browAngle;
                }
            }

            // v4.0: Screen shake effect
            updateScreenShake();

            // v4.0: Update particles
            if (particles) particles.update(dt);

            // v4.4: Update environmental particles
            if (envParticles && worldState.player) {
                envParticles.update(dt, worldState.player.position);
            }

            // v4.5: Update dodge movement
            updateDodge(dt);

            // Mob AI with aggro (using CONFIG constants)
            worldState.mobs.forEach(mob => {
                if (!mob.parent) return;

                // v4.6: Update status effects
                updateMobStatusEffects(mob, time);

                // Check if mob died from status effect DoT
                if (mob.userData.hp <= 0) {
                    // Handle death - same as combat death but simplified
                    const xpReward = mob.userData.xpReward || 100;
                    addXp('combat', xpReward);
                    gameData.statistics.mobsKilled++;
                    worldMobKillCount++;
                    checkBossSpawn();
                    // v4.9: Track creature in codex
                    trackCreatureKill(mob.userData.name?.toLowerCase() || 'unknown');
                    spawnFloater(mob.position, `KILLED! +${xpReward}XP`, '#f00');
                    if (particles) particles.emit(mob.position, 20, ENEMY_TYPES[mob.userData.name]?.color || 0x44ff44);
                    scene.remove(mob);
                    worldState.mobs = worldState.mobs.filter(x => x !== mob);
                    return;
                }

                // v4.6: Handle stun state from parry
                if (mob.userData.stunned) {
                    if (time < mob.userData.stunEnd) {
                        // Still stunned - skip AI behavior, keep yellow glow
                        mob.userData.telegraphing = false;
                        // Update HP bar to face camera
                        if (mob.userData.hpBar) mob.userData.hpBar.lookAt(camera.position);
                        return;
                    } else {
                        // Stun ended
                        mob.userData.stunned = false;
                        // Restore original emissive
                        const originalEmissive = ENEMY_TYPES[mob.userData.name]?.emissive || 0x003300;
                        mob.material.emissive.setHex(originalEmissive);
                    }
                }

                const distToPlayer = mob.position.distanceTo(p.position);

                // Aggro range
                if (distToPlayer < CONFIG.MOB_AGGRO_RANGE && distToPlayer > CONFIG.MOB_ATTACK_RANGE) {
                    mob.userData.targetPos.copy(p.position);
                    mob.userData.nextMove = time + 500;
                } else if(time > mob.userData.nextMove) {
                    mob.userData.targetPos.set(
                        mob.position.x + (Math.random()-0.5)*10,
                        0,
                        mob.position.z + (Math.random()-0.5)*10
                    );
                    mob.userData.nextMove = time + 2000 + Math.random()*2000;
                }

                // Move mob (using temp vector) - v4.2: Use enemy-specific speed
                // v4.6: Apply status effect speed modifier
                _tempVec3B.subVectors(mob.userData.targetPos, mob.position);
                _tempVec3B.y = 0;
                if(_tempVec3B.length() > 0.1) {
                    _tempVec3B.normalize();
                    const mobSpeed = (mob.userData.speed || 4) * (mob.userData.speedMultiplier || 1);
                    mob.position.add(_tempVec3B.multiplyScalar(mobSpeed * dt));
                }
                snapToGround(mob);

                // v4.5: Attack telegraph system with windup
                const attackRange = mob.userData.attackRange || CONFIG.MOB_ATTACK_RANGE;
                const attackWindup = mob.userData.attackWindup || 600;

                // Start telegraph when in range and ready to attack
                if (distToPlayer < attackRange && time > mob.userData.nextAttack && !mob.userData.telegraphing) {
                    mob.userData.telegraphing = true;
                    mob.userData.telegraphStart = time;
                    mob.userData.telegraphEnd = time + attackWindup;
                    // Show telegraph visual - mob glows red
                    if (mob.material) {
                        mob.userData.originalEmissive = mob.material.emissive.getHex();
                        mob.material.emissive.setHex(0xff0000);
                    }
                    AudioSystem.telegraph();
                }

                // Update telegraph progress
                if (mob.userData.telegraphing) {
                    const telegraphProgress = (time - mob.userData.telegraphStart) / attackWindup;
                    // Pulse effect during windup
                    const pulseScale = 1 + Math.sin(telegraphProgress * Math.PI * 4) * 0.15;
                    mob.scale.setScalar(pulseScale);

                    // Execute attack when windup completes
                    if (time >= mob.userData.telegraphEnd) {
                        mob.userData.telegraphing = false;
                        mob.scale.setScalar(1);
                        // Restore original emissive
                        if (mob.material && mob.userData.originalEmissive !== undefined) {
                            mob.material.emissive.setHex(mob.userData.originalEmissive);
                        }
                        // Only deal damage if still in range
                        if (distToPlayer < attackRange * 1.2) {
                            // v4.6: Apply damage multiplier from status effects
                            const actualDamage = Math.floor(mob.userData.damage * (mob.userData.damageMultiplier || 1));
                            damagePlayer(actualDamage);
                            spawnFloater(p.position, `-${actualDamage} HP`, '#ff4444');

                            // v4.7: Vampiric elite heals on hit
                            if (mob.userData.isElite && mob.userData.eliteData?.lifesteal) {
                                const healAmount = Math.floor(actualDamage * mob.userData.eliteData.lifesteal);
                                mob.userData.hp = Math.min(mob.userData.maxHp, mob.userData.hp + healAmount);
                                spawnFloater(mob.position, `ðŸ¦‡ +${healAmount}`, '#ff00ff');
                                // Update health bar
                                if (mob.userData.hpBar) {
                                    const hpPercent = mob.userData.hp / mob.userData.maxHp;
                                    mob.userData.hpBar.scale.x = Math.max(0.01, hpPercent);
                                }
                            }
                        }
                        mob.userData.nextAttack = time + CONFIG.MOB_ATTACK_COOLDOWN;
                    }
                }

                // v4.7: Elite affix behaviors
                if (mob.userData.isElite && mob.userData.eliteData) {
                    const eliteData = mob.userData.eliteData;

                    // Regenerating: heal over time
                    if (eliteData.regenRate && mob.userData.hp < mob.userData.maxHp) {
                        const regenAmount = mob.userData.maxHp * eliteData.regenRate * dt;
                        mob.userData.hp = Math.min(mob.userData.maxHp, mob.userData.hp + regenAmount);
                        // Update health bar
                        if (mob.userData.hpBar) {
                            const hpPercent = mob.userData.hp / mob.userData.maxHp;
                            mob.userData.hpBar.scale.x = Math.max(0.01, hpPercent);
                        }
                    }

                    // Teleporter: blink towards player when in aggro range
                    if (eliteData.canTeleport && distToPlayer < CONFIG.MOB_AGGRO_RANGE && distToPlayer > 5) {
                        if (!mob.userData.lastTeleport || time - mob.userData.lastTeleport > 4000) {
                            // Teleport towards player
                            const teleportDist = Math.min(10, distToPlayer - 3);
                            const dir = _tempVec3B.subVectors(p.position, mob.position).normalize();
                            mob.position.add(dir.multiplyScalar(teleportDist));
                            mob.userData.lastTeleport = time;
                            spawnFloater(mob.position, 'ðŸŒ€', '#9900ff');
                            if (particles) particles.emit(mob.position, 15, 0x9900ff, { spread: 3, lifetime: 500 });
                        }
                    }

                    // Chilling Aura: slow player when nearby
                    if (eliteData.chillingAura && distToPlayer < 6) {
                        if (!playerState.chilled || time > playerState.chilledEnd) {
                            playerState.chilled = true;
                            playerState.chilledEnd = time + 500;
                            playerState.moveSpeedMult = 0.5;
                        }
                    }

                    // Animate elite aura ring
                    if (mob.userData.auraRing) {
                        mob.userData.auraRing.rotation.z += dt * 2;
                        const auraScale = 1 + Math.sin(time * 0.005) * 0.2;
                        mob.userData.auraRing.scale.set(auraScale, auraScale, 1);
                    }
                }

                // v5.12: Hypnotist special behavior - hypnotize player when in range
                const enemyType = ENEMY_TYPES[mob.userData.name];
                if (enemyType?.isHypnotist && !HYPNOSIS_STATE.active) {
                    const hypnosisRange = enemyType.hypnosisRange || 12;
                    const hypnosisCooldown = enemyType.hypnosisCooldown || 15000;

                    if (distToPlayer < hypnosisRange && distToPlayer > 3) {
                        // Check cooldown
                        if (!mob.userData.lastHypnosis || time - mob.userData.lastHypnosis > hypnosisCooldown) {
                            mob.userData.lastHypnosis = time;

                            // Start hypnosis!
                            const duration = enemyType.hypnosisDuration || 8000;
                            startHypnosis(mob, duration);

                            // Visual effect on hypnotist
                            spawnFloater(mob.position, 'ðŸ‘ï¸ HYPNOSIS', '#ff00ff');
                            if (particles) particles.emit(mob.position, 30, 0xff00ff, { spread: 5, lifetime: 1000 });

                            // Pulsing eye effect on the mob itself
                            mob.material.emissive.setHex(0xff00ff);
                            mob.userData.hypnotizing = true;
                        }
                    }
                }

                // Animate hypnotist while hypnotizing
                if (mob.userData.hypnotizing && HYPNOSIS_STATE.active && HYPNOSIS_STATE.hypnotistMob === mob) {
                    // Pulsing glow
                    const pulse = 0.3 + Math.sin(time * 0.01) * 0.2;
                    mob.material.emissiveIntensity = pulse;

                    // Slowly rotate
                    mob.rotation.y += dt * 0.5;
                } else if (mob.userData.hypnotizing && !HYPNOSIS_STATE.active) {
                    mob.userData.hypnotizing = false;
                    mob.material.emissive.setHex(enemyType?.emissive || 0x660066);
                    mob.material.emissiveIntensity = 0.2;
                }

                // v5.12: Animate hypnotist eye - pupil tracks player
                if (mob.userData.isHypnotist && mob.userData.pupil) {
                    // Make the eye look toward the player
                    const lookDir = _tempVec3A.subVectors(p.position, mob.position).normalize();

                    // Calculate pupil offset based on look direction (limited movement)
                    const maxOffset = 0.2;
                    mob.userData.pupil.position.x = lookDir.x * maxOffset;
                    mob.userData.pupil.position.y = Math.max(-maxOffset, lookDir.y * maxOffset + 0.1);

                    // Make the whole mob face the player
                    mob.lookAt(p.position.x, mob.position.y, p.position.z);

                    // Subtle creepy floating animation
                    mob.position.y += Math.sin(time * 0.003 + mob.id) * 0.002;
                }

                // Update HP bar rotation to face camera
                if (mob.userData.hpBar) {
                    mob.userData.hpBar.lookAt(camera.position);
                }
            });

            // Animate fishing spots
            worldState.fishingSpots.forEach(spot => {
                if (spot.userData.ripple) {
                    const scale = 1 + Math.sin(time * 0.003) * 0.2;
                    spot.userData.ripple.scale.set(scale, scale, 1);
                }
            });

            // Update minimap
            updateMinimap();

            // v4.8: Update ability cooldowns
            updateAbilityUI();

            // v5.0: Update pet companion
            updatePet(dt, time);
            updatePetRegen(time);

            // v5.6: Update Copilot Companion
            updateCopilotCompanion(dt, time);

            // v5.12: Update hypnosis effects
            updateHypnosis(dt);

            // v5.13: Update ship defense system
            updateShipDefense(dt, time);

            // v5.9: Update Copilot task progress
            updateCopilotTask(dt);

            // v5.10: Update Agent Fleet meshes
            updateAgentFleetMeshes(dt);

            // v5.18: Update robot energy and structures
            updateRobotEnergy(dt);
            updateStructures(dt);

            // v5.18: Stream to spectators
            sendGameStateToSpectators();

            // v5.16: Check for agent troubleshooting interactions
            checkAgentTroubleshooting();

            // v5.16.3: Update body cams more frequently for streaming effect (every ~100ms)
            // Similar to AI Companion Hub's broadcastCameraUpdate pattern
            if (Math.floor(time * 10) !== Math.floor((time - dt) * 10)) {
                updateAllAgentBodyCams();
            }

            // v5.0: Update weather system
            updateWeather(dt, time);

            // v5.4: Update world events
            updateWorldEvent(dt, time);

            // v5.4: Update cosmetic effects
            updateCosmeticEffects(time);
        }

        function snapToGround(obj) {
            const gx = Math.round(obj.position.x / CONFIG.TILE_SIZE) + CONFIG.WORLD_SIZE/2;
            const gz = Math.round(obj.position.z / CONFIG.TILE_SIZE) + CONFIG.WORLD_SIZE/2;

            if(gx >=0 && gx < CONFIG.WORLD_SIZE && gz >= 0 && gz < CONFIG.WORLD_SIZE) {
                const y = worldState.terrain[gx][gz];
                if(y > -50) {
                    const targetY = y + (obj === worldState.player ? 1.2 : 0.8);
                    obj.position.y = THREE.MathUtils.lerp(obj.position.y, targetY, 0.15);
                }
            }
        }

        // v4.2: Calculate player damage with weapon bonus and skill levels
        function getPlayerDamage() {
            let baseDamage = 1;

            // v5.1: Get damage from equipped gear
            const equipStats = getEquipmentStats();
            let weaponBonus = equipStats.damage;

            // Fallback: Check inventory for weapons if nothing equipped
            if (weaponBonus === 0) {
                const weapons = ['Legendary Blade', 'Void Dagger', 'Magma Sword', 'Frost Blade', 'Sword'];
                for (const weapon of weapons) {
                    if (hasItem(weapon)) {
                        weaponBonus = Math.max(weaponBonus, ITEMS[weapon].combatBonus || 0);
                        break;
                    }
                }
            }

            // Skill bonus: +1 damage every 3 combat levels
            const skillBonus = Math.floor(gameData.skills.combat.level / 3);

            let totalDamage = baseDamage + weaponBonus + skillBonus;

            // v5.1: Apply equipment crit chance
            if (equipStats.critChance > 0 && Math.random() < equipStats.critChance) {
                totalDamage = Math.floor(totalDamage * 2);
                if (worldState.player) {
                    spawnFloater(worldState.player.position, 'âš¡ CRIT!', '#ffaa00');
                }
            }

            // v4.6: Apply crit multiplier if in parry crit window
            if (isInCritWindow()) {
                totalDamage = Math.floor(totalDamage * PARRY_CONFIG.CRIT_MULTIPLIER);
            }

            // v4.8: Apply combo multiplier
            const comboMult = getComboMultiplier();
            if (comboMult > 1) {
                totalDamage = Math.floor(totalDamage * comboMult);
            }

            // v4.8: Apply War Cry damage boost
            if (isWarcryActive()) {
                totalDamage = Math.floor(totalDamage * COMBAT_ABILITIES.warcry.damageBoost);
            }

            // v4.9: Apply Berserker Rage damage boost
            if (isBerserkActive()) {
                totalDamage = Math.floor(totalDamage * COMBAT_ABILITIES.berserk.damageBoost);
            }

            // v5.0: Apply pet damage bonus
            const petBonuses = getPetBonuses();
            if (petBonuses.damage > 0) {
                totalDamage = Math.floor(totalDamage * (1 + petBonuses.damage));
            }
            if (petBonuses.allStats > 0) {
                totalDamage = Math.floor(totalDamage * (1 + petBonuses.allStats));
            }

            // v5.2: Apply talent bonuses
            const talentBonuses = getTalentBonuses();
            if (talentBonuses.damage > 0) {
                totalDamage = Math.floor(totalDamage * (1 + talentBonuses.damage));
            }
            // v5.2: Apply talent crit chance
            if (talentBonuses.critChance > 0 && Math.random() < talentBonuses.critChance) {
                totalDamage = Math.floor(totalDamage * 2);
                if (worldState.player) {
                    spawnFloater(worldState.player.position, 'ðŸŒŸ TALENT CRIT!', '#ffd700');
                }
            }

            // v5.3: Apply mastery combat bonuses
            const masteryBonuses = getMasteryBonuses();
            if (masteryBonuses.combatDamage > 0) {
                totalDamage = Math.floor(totalDamage * (1 + masteryBonuses.combatDamage));
            }
            if (masteryBonuses.combatCrit > 0 && Math.random() < masteryBonuses.combatCrit) {
                totalDamage = Math.floor(totalDamage * 2);
                if (worldState.player) {
                    spawnFloater(worldState.player.position, 'âœ¨ MASTERY CRIT!', '#ff44ff');
                }
            }

            // v5.3: Apply rarity item bonuses
            const rarityBonuses = getRarityBonuses();
            if (rarityBonuses.damage > 0) {
                totalDamage += rarityBonuses.damage;
            }
            if (rarityBonuses.critChance > 0 && Math.random() < rarityBonuses.critChance) {
                const critMult = 2 + (rarityBonuses.critDamage || 0);
                totalDamage = Math.floor(totalDamage * critMult);
                if (worldState.player) {
                    spawnFloater(worldState.player.position, 'ðŸ’Ž RARITY CRIT!', '#4488ff');
                }
            }

            // v5.4: Apply evolution damage bonus
            const evolutionBonuses = getEvolutionBonuses();
            if (evolutionBonuses.damageBonus > 0) {
                totalDamage = Math.floor(totalDamage * (1 + evolutionBonuses.damageBonus));
            }
            // v5.8: Boss damage bonus is now applied in performAction where isBoss is known

            return totalDamage;
        }

        // v4.2: Calculate skill bonus for gathering (multiplier)
        function getSkillBonus(skillName) {
            const level = gameData.skills[skillName]?.level || 1;
            return 1 + Math.floor(level / 5) * 0.25; // +25% every 5 levels
        }

        // v4.2: Calculate player defense from armor
        function getPlayerDefense() {
            let defense = 0;

            // v5.1: Get defense from equipped gear
            const equipStats = getEquipmentStats();
            defense += equipStats.defense;

            // Fallback: Check inventory for armor if nothing equipped
            if (equipStats.defense === 0 && hasItem('Chitin Armor')) {
                defense += ITEMS['Chitin Armor'].defenseBonus;
            }
            if (equipStats.defense === 0 && hasItem('Guardian Armor')) {
                defense += ITEMS['Guardian Armor'].defenseBonus;
            }

            defense += Math.floor(gameData.skills.combat.level / 5); // +1 defense every 5 combat levels

            // v5.2: Apply talent defense bonus
            const talentBonuses = getTalentBonuses();
            defense += talentBonuses.defense || 0;

            // v5.3: Apply rarity item defense bonus
            const rarityBonuses = getRarityBonuses();
            defense += rarityBonuses.defense || 0;

            return defense;
        }

        function performAction(target) {
            const data = target.userData;

            // v5.4: Handle event item collection
            if (data.type === 'eventItem') {
                collectEventItem(target);
                return;
            }

            // v4.2: Handle POI interactions differently
            if (data.type === 'poi') {
                if (!data.discovered) {
                    data.discovered = true;
                    gameData.statistics.poisDiscovered++;

                    // Mark as discovered for this planet
                    if (!gameData.discoveredPOIs[activeCiv.id]) {
                        gameData.discoveredPOIs[activeCiv.id] = [];
                    }
                    gameData.discoveredPOIs[activeCiv.id].push(data.poiType);

                    // Grant rewards
                    data.rewards.forEach(reward => {
                        const count = Array.isArray(reward.count)
                            ? Math.floor(Math.random() * (reward.count[1] - reward.count[0] + 1)) + reward.count[0]
                            : reward.count;
                        for (let i = 0; i < count; i++) {
                            addItem(reward.item);
                        }
                        spawnFloater(target.position, `+${count} ${reward.item}`, '#ffdd00');
                    });

                    // Grant XP bonus
                    addXp('combat', data.xpBonus);

                    spawnFloater(target.position.clone().add(new THREE.Vector3(0, 2, 0)), `${data.icon} ${data.name} DISCOVERED!`, '#ffdd00');
                    AudioSystem.levelUp();
                    if (particles) particles.emit(target.position, 30, 0xffdd00, { spread: 6, lifetime: 1500, size: 0.3 });

                    // Change POI appearance to show it's been discovered
                    if (data.beacon) data.beacon.material.emissiveIntensity = 0.1;
                    if (data.iconMesh) data.iconMesh.material.opacity = 0.3;

                    checkAchievements();
                    updateDailyChallengeProgress();
                    updatePlayerRank();
                } else {
                    spawnFloater(target.position, "Already discovered", '#888888');
                }
                return;
            }

            // v4.2: Calculate damage based on type
            let damage = 1;
            if (data.type === 'mob' || data.type === 'boss') {
                damage = getPlayerDamage();
                // v5.8: Apply evolution boss damage bonus here where isBoss is known
                const isBoss = data.type === 'boss' || data.isBoss;
                if (isBoss) {
                    const evolutionBonuses = getEvolutionBonuses();
                    if (evolutionBonuses.bossDamage > 0) {
                        damage = Math.floor(damage * (1 + evolutionBonuses.bossDamage));
                    }
                }
            }

            // v4.8: Update combo state on combat hit
            const isCombatHit = data.type === 'mob' || data.type === 'boss';
            let comboHit = 0;
            if (isCombatHit) {
                comboHit = updateCombo(performance.now());
            }

            // v4.6: Show crit feedback if in crit window, v4.8: combo feedback
            const isCrit = isInCritWindow() && isCombatHit;
            const isFinisher = comboHit >= COMBO_CONFIG.MAX_HITS - 1;

            let hitText, hitColor;
            if (isFinisher) {
                hitText = `ðŸ’¥ FINISHER x${comboHit + 1}! -${damage}`;
                hitColor = '#ff00ff';
            } else if (isCrit) {
                hitText = `âš”ï¸ CRIT! -${damage}`;
                hitColor = '#ffd700';
            } else if (comboHit > 0) {
                hitText = `x${comboHit + 1} COMBO! -${damage}`;
                hitColor = '#00ffff';
            } else {
                hitText = damage > 1 ? `HIT! -${damage}` : "HIT!";
                hitColor = undefined;
            }

            spawnFloater(target.position, hitText, hitColor);
            AudioSystem.hit();

            // v5.15: Trigger robot attack animation on combat
            if (isCombatHit) {
                triggerRobotAnimation('attack');
            }

            data.hp -= damage;
            gameData.statistics.totalDamageDealt += damage;

            // v5.1: Apply lifesteal from equipment
            const equipStats = getEquipmentStats();
            if (equipStats.lifesteal > 0) {
                const healAmount = Math.floor(damage * equipStats.lifesteal);
                if (healAmount > 0) {
                    gameData.player.hp = Math.min(CONFIG.PLAYER_MAX_HP + equipStats.maxHpBonus, gameData.player.hp + healAmount);
                    spawnFloater(worldState.player.position, `ðŸ’š +${healAmount}`, '#44ff44');
                    updateHealthUI();
                }
            }

            // v4.4: Hit-stop and flash for satisfying combat
            const isBossTarget = data.type === 'boss' || data.isBoss;
            const isMobTarget = data.type === 'mob';
            if (isBossTarget) {
                triggerHitStop(HIT_STOP_BOSS);
                flashTargetHit(target, 0xff4400);
            } else if (isMobTarget) {
                triggerHitStop(HIT_STOP_LIGHT);
                flashTargetHit(target, 0xff0000);
            }

            // v4.6: Apply elemental status effect on hit
            if (isMobTarget || isBossTarget) {
                const element = getEquippedElement();
                if (element) {
                    applyStatusEffect(target, element);
                }
            }

            // Visual feedback
            target.scale.setScalar(0.85);
            setTimeout(() => { if(target.parent) target.scale.setScalar(1); }, 100);

            // v4.0: Hit particles based on type
            if (particles) {
                const particleColor = data.type === 'tree' ? 0x885522 :
                                     data.type === 'rock' ? 0x888888 :
                                     data.type === 'mob' ? (ENEMY_TYPES[data.name]?.color || 0x44ff44) : 0x4488ff;
                particles.emit(target.position, 5, particleColor, { spread: 2, lifetime: 600, size: 0.15 });
            }

            // Update mob health bar
            if (data.type === 'mob' && data.hpBar) {
                const hpPercent = data.hp / data.maxHp;
                data.hpBar.scale.x = Math.max(0.01, hpPercent);
                data.hpBar.material.color.setHex(hpPercent > 0.5 ? 0x00ff00 : hpPercent > 0.25 ? 0xffff00 : 0xff0000);
            }

            if(data.hp <= 0) {
                if(data.type === 'tree') {
                    // v4.2: Apply skill bonus to gathering
                    const toolBonus = hasItem('Crystal Pickaxe') ? 3 : hasItem('Pickaxe') ? 2 : 1;
                    const skillMultiplier = getSkillBonus('wood');
                    const totalYield = Math.floor(toolBonus * skillMultiplier);
                    for (let i = 0; i < totalYield; i++) addItem('Log');
                    addXp('wood', 50);
                    gameData.statistics.treesChopped++;
                    gainPetBond(1); // v5.4: Pet bond from gathering
                    spawnFloater(target.position, `+${totalYield} LOG`, '#da5');
                    AudioSystem.collect();
                    if (particles) particles.emit(target.position, 12, 0xdd9955, { spread: 4, lifetime: 1000 });
                    scene.remove(target);
                    worldState.interactables = worldState.interactables.filter(x => x !== target);
                }
                else if(data.type === 'rock') {
                    // v4.2: Apply skill bonus to gathering
                    const toolBonus = hasItem('Crystal Pickaxe') ? 3 : hasItem('Pickaxe') ? 2 : 1;
                    const skillMultiplier = getSkillBonus('mining');
                    const totalYield = Math.floor(toolBonus * skillMultiplier);
                    for (let i = 0; i < totalYield; i++) addItem('Ore');
                    addXp('mining', 50);
                    gameData.statistics.oresMined++;
                    gainPetBond(1); // v5.4: Pet bond from gathering
                    spawnFloater(target.position, `+${totalYield} ORE`, '#888');
                    AudioSystem.collect();
                    if (particles) particles.emit(target.position, 15, 0x888888, { spread: 3, lifetime: 800 });
                    scene.remove(target);
                    worldState.interactables = worldState.interactables.filter(x => x !== target);
                }
                else if(data.type === 'mob' || data.type === 'boss') {
                    // v4.3: Handle both regular mobs and bosses
                    const isBoss = data.type === 'boss' || data.isBoss;

                    // v4.2/4.3: Drop items from enemy data
                    const drops = data.drops || ['Slime'];
                    // v4.7: Elite enemies drop more items
                    const dropMultiplier = data.isElite ? ELITE_CONFIG.bonusDropMult : 1;

                    drops.forEach(drop => {
                        // Handle boss drop format { item, count }
                        if (typeof drop === 'object') {
                            const count = drop.count * dropMultiplier;
                            for (let i = 0; i < count; i++) addItem(drop.item);
                            spawnFloater(target.position.clone().add(new THREE.Vector3(Math.random(), 1, Math.random())), `+${count} ${drop.item}`, '#ffd700');
                        } else {
                            for (let i = 0; i < dropMultiplier; i++) addItem(drop);
                        }
                    });

                    // v4.7: Elite essence drop
                    if (data.isElite && Math.random() < ELITE_CONFIG.essenceDropChance) {
                        const essenceCount = 1 + Math.floor(Math.random() * 3); // 1-3 essence
                        for (let i = 0; i < essenceCount; i++) addItem('Elite Essence');
                        spawnFloater(target.position.clone().add(new THREE.Vector3(0, 1.5, 0)), `+${essenceCount} Elite Essence`, '#aa00ff');
                    }

                    const xpReward = data.xpReward || 100;
                    addXp('combat', xpReward);

                    // v4.7: Handle explosive affix death
                    if (data.isElite && data.eliteData?.explodeOnDeath) {
                        const explosionDamage = Math.floor(data.damage * 2);
                        const explosionRange = 5;
                        const distToPlayer = target.position.distanceTo(p.position);
                        if (distToPlayer < explosionRange) {
                            damagePlayer(explosionDamage, 'explosion');
                            spawnFloater(p.position, `ðŸ’¥ EXPLOSION! -${explosionDamage}`, '#ff6600');
                        }
                        if (particles) particles.emit(target.position, 40, 0xff6600, { spread: 8, lifetime: 1000, size: 0.4 });
                        screenShake(1.2);
                        AudioSystem.explosion && AudioSystem.explosion();
                    }

                    if (isBoss) {
                        gameData.statistics.bossesDefeated++;
                        // v4.9: Track boss in codex
                        trackCreatureKill('boss');
                        spawnFloater(target.position.clone().add(new THREE.Vector3(0, 2, 0)), `BOSS DEFEATED! +${xpReward}XP`, '#ffd700');
                        showNotification(`${data.name} has been defeated!`, 'success');
                        // v4.4: Extra long hit-stop for boss kill
                        triggerHitStop(HIT_STOP_BOSS * 2);
                        screenShake(1.5);
                        // Extra celebration
                        if (particles) particles.emit(target.position, 50, 0xffd700, { spread: 8, lifetime: 2000, size: 0.4 });

                        // v5.3: Check portal clear on boss kill (portal realms require boss kills)
                        if (gameData.portals?.currentPortal) {
                            const portalMods = getPortalModifiers();
                            if (portalMods?.bossOnly) {
                                exitPortal(true);
                            }
                        }

                        // v5.3: Chance for rarity loot on boss kills
                        if (Math.random() < 0.4) {
                            const rareDrop = drops[0]?.item || drops[0] || 'Boss Trophy';
                            const rarityItem = createRarityItem(rareDrop);
                            if (rarityItem.rarity !== 'common') {
                                if (!gameData.rarityItems) gameData.rarityItems = [];
                                gameData.rarityItems.push(rarityItem);
                                showRarityDropPopup(rarityItem);
                            }
                        }
                    } else {
                        gameData.statistics.mobsKilled++;
                        // v4.9: Track creature in codex
                        if (data.isElite) {
                            trackCreatureKill('elite');
                        } else {
                            trackCreatureKill(data.name?.toLowerCase() || 'unknown');
                        }
                        // v5.0: Try to drop a pet
                        tryDropPet(data.name);
                        // v5.4: Gain pet bond from kills
                        gainPetBond(data.isElite ? 3 : 1);
                        // v4.7: Track elite kills
                        if (data.isElite) {
                            gameData.statistics.elitesKilled = (gameData.statistics.elitesKilled || 0) + 1;
                            spawnFloater(target.position.clone().add(new THREE.Vector3(0, 2, 0)), `${data.eliteData.prefix} ELITE SLAIN! +${xpReward}XP`, '#ffaa00');
                            showNotification(`Elite ${data.name} defeated!`, 'success');
                            triggerHitStop(HIT_STOP_BOSS);

                            // v5.3: Chance for rarity loot on elite kills
                            if (Math.random() < 0.2) {
                                const rareDrop = drops[0] || 'Elite Essence';
                                const rarityItem = createRarityItem(rareDrop);
                                if (rarityItem.rarity !== 'common') {
                                    if (!gameData.rarityItems) gameData.rarityItems = [];
                                    gameData.rarityItems.push(rarityItem);
                                    showRarityDropPopup(rarityItem);
                                }
                            }
                        } else {
                            spawnFloater(target.position, `KILLED! +${xpReward}XP`, '#f00');
                            triggerHitStop(HIT_STOP_HEAVY);
                        }
                        worldMobKillCount++; // v4.3: Track for boss spawning
                        checkBossSpawn(); // v4.3: Check if boss should spawn

                        // v5.3: Track portal kills - elites count more
                        if (gameData.portals?.currentPortal) {
                            const portalMods = getPortalModifiers();
                            // Portals without bossOnly can be cleared by killing enough enemies
                            if (!portalMods?.bossOnly && data.isElite) {
                                if (!gameData.portals.killProgress) gameData.portals.killProgress = 0;
                                gameData.portals.killProgress += 5; // Elite = 5 kills
                                if (gameData.portals.killProgress >= 25) { // Need 25 points (5 elites or 25 mobs)
                                    exitPortal(true);
                                }
                            } else if (!portalMods?.bossOnly) {
                                if (!gameData.portals.killProgress) gameData.portals.killProgress = 0;
                                gameData.portals.killProgress += 1;
                                if (gameData.portals.killProgress >= 25) {
                                    exitPortal(true);
                                }
                            }
                        }
                    }

                    AudioSystem.kill();
                    const mobColor = data.isElite ? (data.eliteData?.color || 0xffaa00) :
                                    isBoss ? (BOSS_TYPES[data.bossId]?.color || 0xffd700) :
                                    (ENEMY_TYPES[data.name]?.color || 0x44ff44);
                    if (particles && !isBoss) particles.emit(target.position, data.isElite ? 30 : 20, mobColor, { spread: data.isElite ? 7 : 5, lifetime: 1200, size: data.isElite ? 0.35 : 0.25 });
                    scene.remove(target);
                    worldState.mobs = worldState.mobs.filter(x => x !== target);
                }
                else if(data.type === 'fishing') {
                    if (hasItem('Fishing Rod')) {
                        // v4.2: Skill bonus for fishing
                        const skillMultiplier = getSkillBonus('fishing');
                        const fishCount = Math.floor(1 * skillMultiplier);
                        for (let i = 0; i < fishCount; i++) addItem('Raw Fish');
                        addXp('fishing', 40);
                        gameData.statistics.fishCaught += fishCount;
                        gainPetBond(1); // v5.4: Pet bond from fishing
                        spawnFloater(target.position, `+${fishCount} FISH`, '#44f');
                        AudioSystem.collect();
                        if (particles) particles.emit(target.position, 8, 0x4488ff, { spread: 2, lifetime: 800, gravity: 5 });
                    } else {
                        spawnFloater(target.position, "Need Rod!", '#f44');
                        AudioSystem.error();
                    }
                    data.hp = data.maxHp = 1;
                    return;
                }
                worldState.interactTarget = null;

                checkAchievements();
                updateDailyChallengeProgress();
                updatePlayerRank();
            }
        }

        function damagePlayer(amount) {
            // v4.5: Check for dodge i-frames
            if (isInvincible()) {
                spawnFloater(worldState.player.position, 'DODGE!', '#88ffff');
                return;
            }

            // v4.8: Break combo on taking damage
            if (COMBO_CONFIG.BREAK_ON_DAMAGE && comboState.active) {
                breakCombo();
            }

            // v4.9: Apply Shield Wall damage reduction
            let reducedAmount = amount;
            if (isShieldWallActive()) {
                reducedAmount = Math.floor(amount * (1 - COMBAT_ABILITIES.shieldWall.damageReduction));
                if (worldState.player) {
                    spawnFloater(worldState.player.position, `ðŸ›¡ï¸ BLOCKED!`, '#4488ff');
                }
            }

            // v5.4: Apply evolution damage reduction and phase shift
            const evolutionBonuses = getEvolutionBonuses();
            if (evolutionBonuses.damageReduction > 0) {
                reducedAmount = Math.floor(reducedAmount * (1 - evolutionBonuses.damageReduction));
            }
            if (evolutionBonuses.phaseShift > 0 && Math.random() < evolutionBonuses.phaseShift) {
                reducedAmount = Math.floor(reducedAmount * 0.5);
                if (worldState.player) {
                    spawnFloater(worldState.player.position, 'ðŸŒ€ PHASED!', '#4400ff');
                }
            }

            // v4.2: Apply defense reduction
            const defense = getPlayerDefense();
            const actualDamage = Math.max(1, reducedAmount - defense);
            gameData.player.hp = Math.max(0, gameData.player.hp - actualDamage);
            updateHealthUI();

            // v4.0: Enhanced damage feedback
            AudioSystem.damage();
            screenShake(amount * 0.1);
            flashDamageOverlay();

            // v5.15: Trigger robot damage animation
            triggerRobotAnimation('damage');

            if (gameData.player.hp <= 0) {
                playerDeath();
            }
        }

        function healPlayer(amount) {
            gameData.player.hp = Math.min(gameData.player.maxHp, gameData.player.hp + amount);
            updateHealthUI();
            spawnFloater(worldState.player.position, `+${amount} HP`, '#44ff44');
            AudioSystem.heal(); // v4.0
        }

        function playerDeath() {
            showNotification('You died! Respawning...', 'error');
            gameData.player.hp = gameData.player.maxHp;
            worldState.player.position.set(0, 10, 0);
            worldState.target = null;
            worldState.interactTarget = null;
            updateHealthUI();
        }

        function spawnFloater(pos, text, color='#fff') {
            // Use pool
            let floater = floaterPool.find(f => !f.active);
            if (!floater) {
                floater = floaterPool[0]; // Reuse oldest
            }

            floater.active = true;
            floater.el.textContent = text;
            floater.el.style.color = color;
            floater.el.style.display = 'block';
            floater.el.style.animation = 'none';
            floater.el.offsetHeight; // Trigger reflow
            floater.el.style.animation = 'floatUp 1.5s forwards';

            const v = pos.clone();
            v.y += 2;
            v.project(camera);

            const x = (v.x * .5 + .5) * window.innerWidth;
            const y = (-(v.y * .5) + .5) * window.innerHeight;

            floater.el.style.left = x + 'px';
            floater.el.style.top = y + 'px';

            setTimeout(() => {
                floater.el.style.display = 'none';
                floater.active = false;
            }, 1400);
        }

        // --- INPUT HANDLERS ---
        function onMouseMove(e) {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            const tooltip = document.getElementById('tooltip');

            if(mode === 'galaxy') {
                const intersects = raycaster.intersectObjects(galaxyGroup.children, true);
                if(intersects.length > 0) {
                    let obj = intersects[0].object;
                    while(obj.parent && obj.parent !== galaxyGroup) obj = obj.parent;

                    if(obj.userData.type === 'civ') {
                        const civ = obj.userData.data;
                        tooltip.style.display = 'block';
                        tooltip.style.left = e.clientX + 10 + 'px';
                        tooltip.style.top = e.clientY + 10 + 'px';
                        tooltip.innerHTML = `<strong>${civ.name}</strong><br>Biome: ${civ.biomeName}<br>Pop: ${civ.pop}M${civ.visited ? '<br><span style="color:#0f0">Visited</span>' : ''}<br><span style="color:#888">ðŸš€ Click to Begin Landing Sequence</span>`;
                        document.body.style.cursor = 'pointer';

                        selectionRing.visible = true;
                        selectionRing.position.copy(obj.position);
                        return;
                    }
                }
            } else if (mode === 'world') {
                // v5.6: Check for Copilot Companion hover
                if (copilotMesh) {
                    const copilotHits = raycaster.intersectObject(copilotMesh, true);
                    if (copilotHits.length > 0) {
                        const copilotTooltip = document.getElementById('copilot-3d-tooltip');
                        if (copilotTooltip) {
                            copilotTooltip.style.display = 'block';
                            copilotTooltip.style.left = e.clientX + 15 + 'px';
                            copilotTooltip.style.top = e.clientY - 30 + 'px';
                        }
                        document.body.style.cursor = 'pointer';
                        return;
                    } else {
                        const copilotTooltip = document.getElementById('copilot-3d-tooltip');
                        if (copilotTooltip) copilotTooltip.style.display = 'none';
                    }
                }

                const hits = raycaster.intersectObjects([...worldState.interactables, ...worldState.mobs], true);
                if(hits.length > 0) {
                    let obj = hits[0].object;
                    while(obj.parent && obj.parent.type !== 'Scene') obj = obj.parent;

                    if(obj.userData.name) {
                        tooltip.style.display = 'block';
                        tooltip.style.left = e.clientX + 10 + 'px';
                        tooltip.style.top = e.clientY + 10 + 'px';
                        const hpText = obj.userData.hp !== undefined ? `<br>HP: ${obj.userData.hp}/${obj.userData.maxHp}` : '';
                        tooltip.innerHTML = `<strong>${obj.userData.name}</strong>${hpText}<br><span style="color:#888">Click to Interact</span>`;
                        document.body.style.cursor = 'pointer';
                        return;
                    }
                }
            }

            tooltip.style.display = 'none';
            document.body.style.cursor = 'default';
            if(mode === 'galaxy') selectionRing.visible = false;
        }

        function onMouseDown(e) {
            raycaster.setFromCamera(mouse, camera);

            // v5.6: Check for Copilot Companion click first
            if (checkCopilotClick(e)) {
                return; // Copilot was clicked, don't process other clicks
            }

            if(mode === 'galaxy') {
                const intersects = raycaster.intersectObjects(galaxyGroup.children, true);
                if(intersects.length > 0) {
                    let obj = intersects[0].object;
                    while(obj.parent && obj.parent !== galaxyGroup) obj = obj.parent;
                    if(obj.userData.type === 'civ') {
                        // v5.5: Landing mini-game before entering world
                        startLandingGame(obj.userData.data);
                    }
                }
            }
            else if(mode === 'world') {
                const hits = raycaster.intersectObjects([...worldState.interactables, ...worldState.mobs], true);
                if(hits.length > 0) {
                    let obj = hits[0].object;
                    while(obj.parent && obj.parent.type !== 'Scene') obj = obj.parent;
                    worldState.interactTarget = obj;
                    spawnFloater(obj.position, "Targeting...", '#0ff');
                    return;
                }

                const groundHits = raycaster.intersectObjects(scene.children, true);
                if(groundHits.length > 0) {
                    const pt = groundHits[0].point;
                    worldState.target = pt;
                    worldState.interactTarget = null;

                    const m = new THREE.Mesh(
                        new THREE.RingGeometry(0.4, 0.5, 16),
                        new THREE.MeshBasicMaterial({ color: 0xffff00, side: THREE.DoubleSide })
                    );
                    m.rotation.x = -Math.PI/2;
                    m.position.copy(pt);
                    m.position.y += 0.2;
                    scene.add(m);
                    setTimeout(() => scene.remove(m), 400);
                }
            }
        }

        // Touch handlers
        let touchStartPos = null;

        // v4.3: Virtual Joystick state
        let joystickActive = false;
        let joystickCenter = { x: 0, y: 0 };
        let joystickInput = { x: 0, y: 0 };
        const joystickMaxDist = 40;

        function onTouchStart(e) {
            e.preventDefault();
            if (e.touches.length === 1) {
                touchStartPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                mouse.x = (e.touches[0].clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.touches[0].clientY / window.innerHeight) * 2 + 1;
            }
        }

        function onTouchMove(e) {
            e.preventDefault();
            if (e.touches.length === 1) {
                mouse.x = (e.touches[0].clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.touches[0].clientY / window.innerHeight) * 2 + 1;
            }
        }

        function onTouchEnd(e) {
            e.preventDefault();
            if (touchStartPos) {
                raycaster.setFromCamera(mouse, camera);
                onMouseDown({ clientX: touchStartPos.x, clientY: touchStartPos.y });
                touchStartPos = null;
            }
        }

        function onTouchAction() {
            // Quick action button - interact with nearest target
            if (mode === 'world' && worldState.interactTarget) {
                performAction(worldState.interactTarget);
            }
        }

        function onKeyDown(e) {
            // v5.8: Skip keyboard handling when typing in input fields
            const activeElement = document.activeElement;
            if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA' || activeElement.isContentEditable)) {
                return; // Don't capture keys when user is typing
            }

            // v5.9: Voice hotkeys
            // V key: Open Copilot chat and start voice listening
            if (e.key === 'v' || e.key === 'V') {
                e.preventDefault();
                if (!copilotChatOpen) {
                    toggleCopilotChat();
                }
                // Small delay to ensure chat is open before starting voice
                setTimeout(() => {
                    if (!copilotIsListening) {
                        toggleCopilotVoice();
                    }
                }, 100);
                return;
            }

            // Spacebar: If Copilot chat is open, trigger voice instead of dodge
            if (e.key === ' ') {
                if (copilotChatOpen) {
                    e.preventDefault();
                    if (!copilotIsListening) {
                        toggleCopilotVoice();
                    } else {
                        // If already listening, stop (toggle behavior)
                        stopCopilotVoice();
                    }
                    return;
                }
            }

            // Escape: Close Copilot chat if open
            if (e.key === 'Escape' && copilotChatOpen) {
                toggleCopilotChat();
                e.preventDefault();
                return;
            }

            // v5.5: Landing mini-game controls
            if (landingGame.active) {
                handleLandingKeyDown(e);
                return;
            }

            // WASD movement
            const key = e.key.toLowerCase();
            if (key in keys) {
                keys[key] = true;
                e.preventDefault();
            }

            // Number keys 1-9 to use inventory items
            if (mode === 'world' && e.key >= '1' && e.key <= '9') {
                const idx = parseInt(e.key) - 1;
                useInventoryItem(idx);
            }
            // E to eat food
            if (e.key === 'e' || e.key === 'E') {
                const foodIdx = gameData.inventory.findIndex(item =>
                    item && (item.name === 'Cooked Fish' || item.name === 'Health Potion')
                );
                if (foodIdx >= 0) useInventoryItem(foodIdx);
            }
            // H for help/tutorial
            if (e.key === 'h' || e.key === 'H') {
                showTutorial();
            }
            // v5.5: M to toggle autopilot exploration
            if ((e.key === 'm' || e.key === 'M') && mode === 'world') {
                toggleAutoExplore();
            }
            // v4.5: Space or Shift to dodge (space only if chat not open)
            // v5.12: Space also breaks hypnosis
            if (e.key === ' ' || e.key === 'Shift') {
                if (mode === 'world' && !copilotChatOpen) {
                    // Check if hypnotized - SPACE breaks hypnosis
                    if (HYPNOSIS_STATE.active && e.key === ' ') {
                        attemptBreakHypnosis();
                        e.preventDefault();
                        return;
                    }
                    startDodge();
                    e.preventDefault();
                }
            }
            // v4.8: Combat abilities Q/E/R (v4.9: Extended with Tier 2 T/F/Z/X/C)
            if (mode === 'world') {
                if (e.key === 'q' || e.key === 'Q') {
                    useAbility('powerStrike');
                    e.preventDefault();
                }
                if (e.key === 'e' || e.key === 'E') {
                    // E is now abilities, but keep food eating as fallback if no ability ready
                    if (!useAbility('whirlwind')) {
                        const foodIdx = gameData.inventory.findIndex(item =>
                            item && (item.name === 'Cooked Fish' || item.name === 'Health Potion' || item.name === 'Super Potion')
                        );
                        if (foodIdx >= 0) useInventoryItem(foodIdx);
                    }
                    e.preventDefault();
                }
                if (e.key === 'r' || e.key === 'R') {
                    useAbility('warcry');
                    e.preventDefault();
                }
                // v4.9: Tier 2 Abilities
                if (e.key === 't' || e.key === 'T') {
                    useAbility('heal');
                    e.preventDefault();
                }
                if (e.key === 'f' || e.key === 'F') {
                    useAbility('dash');
                    e.preventDefault();
                }
                if (e.key === 'z' || e.key === 'Z') {
                    useAbility('shieldWall');
                    e.preventDefault();
                }
                if (e.key === 'x' || e.key === 'X') {
                    useAbility('execute');
                    e.preventDefault();
                }
                if (e.key === 'c' || e.key === 'C') {
                    useAbility('berserk');
                    e.preventDefault();
                }
            }
        }

        function onKeyUp(e) {
            // v5.8: Skip keyboard handling when typing in input fields
            const activeElement = document.activeElement;
            if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA' || activeElement.isContentEditable)) {
                return; // Don't capture keys when user is typing
            }

            // v5.5: Landing mini-game controls
            if (landingGame.active) {
                handleLandingKeyUp(e);
                return;
            }

            const key = e.key.toLowerCase();
            if (key in keys) {
                keys[key] = false;
            }
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function returnToGalaxy() {
            saveGameData();
            initGalaxy();
            activeCiv = null;
        }

        // --- INVENTORY & RPG ---
        function addItem(name) {
            const itemDef = ITEMS[name];
            if (!itemDef) return false;

            // v4.9: Track item in codex
            trackItemDiscovery(name);

            // Find existing stack
            if (itemDef.stackable) {
                const existing = gameData.inventory.find(item =>
                    item && item.name === name && item.count < (itemDef.maxStack || 99)
                );
                if (existing) {
                    existing.count++;
                    updateInventoryUI();
                    return true;
                }
            }

            // Add new slot
            if (gameData.inventory.length < 20) {
                gameData.inventory.push({ name, count: 1 });
                updateInventoryUI();
                return true;
            }

            spawnFloater(worldState.player.position, "Inventory full!", '#f44');
            return false;
        }

        function removeItem(name, count = 1) {
            for (let i = 0; i < gameData.inventory.length; i++) {
                const item = gameData.inventory[i];
                if (item && item.name === name) {
                    item.count -= count;
                    if (item.count <= 0) {
                        gameData.inventory.splice(i, 1);
                    }
                    updateInventoryUI();
                    return true;
                }
            }
            return false;
        }

        function hasItem(name, count = 1) {
            const item = gameData.inventory.find(i => i && i.name === name);
            return item && item.count >= count;
        }

        function countItem(name) {
            const item = gameData.inventory.find(i => i && i.name === name);
            return item ? item.count : 0;
        }

        function useInventoryItem(idx) {
            const item = gameData.inventory[idx];
            if (!item) return;

            const def = ITEMS[item.name];

            // v5.1: Check if item is equippable
            if (isEquippable(item.name)) {
                equipItem(item.name);
                updateInventoryUI();
                return;
            }

            // Use consumables
            if (def && def.heal) {
                if (gameData.player.hp < gameData.player.maxHp) {
                    healPlayer(def.heal);
                    removeItem(item.name, 1);
                } else {
                    showNotification('Health is already full!');
                }
            }
        }

        function updateInventoryUI() {
            const grid = document.getElementById('inventory-grid');
            grid.innerHTML = '';

            gameData.inventory.forEach((item, idx) => {
                if (!item) return;
                const def = ITEMS[item.name] || { icon: '?' };
                const slot = document.createElement('div');
                slot.className = 'inv-slot';

                // v4.8: Build detailed tooltip
                const tooltip = buildItemTooltip(item.name, def, item.count);
                slot.title = tooltip;

                slot.innerHTML = `${def.icon}<div class="inv-count">${item.count}</div>`;
                slot.onclick = () => useInventoryItem(idx);
                grid.appendChild(slot);
            });

            // Fill empty slots
            for (let i = gameData.inventory.length; i < 20; i++) {
                const slot = document.createElement('div');
                slot.className = 'inv-slot';
                grid.appendChild(slot);
            }

            document.getElementById('inv-count').textContent = gameData.inventory.length;
        }

        // v4.8: Build detailed item tooltip
        function buildItemTooltip(name, def, count) {
            let lines = [name];

            // Add quantity for stackable items
            if (def.stackable && count > 1) {
                lines[0] += ` (x${count})`;
            }

            // Healing items
            if (def.heal) {
                lines.push(`Heals ${def.heal} HP`);
                lines.push('Click or press E to use');
            }

            // Combat bonuses
            if (def.combatBonus) {
                lines.push(`Combat: +${def.combatBonus} damage`);
            }

            // Defense
            if (def.defenseBonus) {
                lines.push(`Defense: +${def.defenseBonus}`);
            }

            // Mining/Tool bonuses
            if (def.miningBonus) {
                lines.push(`Mining: x${def.miningBonus} yield`);
            }
            if (def.fishingBonus) {
                lines.push(`Fishing: x${def.fishingBonus} yield`);
            }

            // Elemental
            if (def.element) {
                const elementNames = { ice: 'Ice (Slow)', fire: 'Fire (Burn)', void: 'Void (Weaken)', cosmic: 'Cosmic (All)' };
                lines.push(`Element: ${elementNames[def.element] || def.element}`);
            }

            // Lifesteal
            if (def.lifesteal) {
                lines.push(`Lifesteal: ${Math.floor(def.lifesteal * 100)}%`);
            }

            // Attack speed
            if (def.attackSpeedMult) {
                lines.push(`Attack Speed: +${Math.floor((def.attackSpeedMult - 1) * 100)}%`);
            }

            // Max stack info for materials
            if (def.stackable && def.maxStack) {
                lines.push(`Max Stack: ${def.maxStack}`);
            }

            return lines.join('\\n');
        }

        function addXp(skill, amt) {
            if (!gameData.skills[skill]) return;

            // v4.4: Apply prestige XP multiplier
            let multiplier = gameData.prestige?.bonuses?.xpMultiplier || 1.0;

            // v5.3: Apply portal XP multiplier
            multiplier *= getPortalXpMultiplier();

            // v5.3: Apply mastery XP bonus
            const masteryBonuses = getMasteryBonuses();
            // v5.3: Apply talent XP bonus
            const talentBonuses = getTalentBonuses();
            multiplier *= (1 + (talentBonuses.xpBonus || 0));

            // v5.3: Apply rarity item XP bonus
            const rarityBonuses = getRarityBonuses();
            multiplier *= (1 + (rarityBonuses.xpBonus || 0));

            // v5.4: Apply showcase milestone XP bonus
            const showcaseBonuses = getShowcaseBonuses();
            multiplier *= (1 + (showcaseBonuses.xpBonus || 0) + (showcaseBonuses.allBonus || 0));

            // v5.4: Apply world event XP bonus
            const eventBonuses = getWorldEventBonuses();
            multiplier *= (eventBonuses.xpMultiplier || 1);

            // v5.4: Apply evolution XP bonus
            const evolutionBonuses = getEvolutionBonuses();
            multiplier *= (1 + (evolutionBonuses.xpBonus || 0));

            const adjustedAmt = Math.round(amt * multiplier);

            const oldLevel = gameData.skills[skill].level;
            gameData.skills[skill].xp += adjustedAmt;

            // Check level up
            const newLevel = Math.floor(Math.sqrt(gameData.skills[skill].xp / 100)) + 1;
            gameData.skills[skill].level = newLevel;

            if (newLevel > oldLevel) {
                showNotification(`${skill.charAt(0).toUpperCase() + skill.slice(1)} leveled up to ${newLevel}!`);
                AudioSystem.levelUp(); // v4.0
                if (worldState.player) {
                    spawnFloater(worldState.player.position, `LEVEL UP!`, '#ffff00');
                    // v4.0: Level up particle burst
                    if (particles) particles.emit(worldState.player.position, 25, 0xffff00, { spread: 6, lifetime: 1500, gravity: 3 });
                    // v5.15: Robot celebrate animation
                    triggerRobotAnimation('celebrate');
                }
            }

            updateSkillsUI();
        }

        function updateSkillsUI() {
            const skills = ['mining', 'wood', 'combat', 'fishing', 'cooking', 'crafting'];

            skills.forEach(skill => {
                const data = gameData.skills[skill];
                if (!data) return;

                const level = data.level;
                const xp = data.xp;
                const nextLevelXp = Math.pow(level, 2) * 100;
                const prevLevelXp = Math.pow(level - 1, 2) * 100;
                const progress = ((xp - prevLevelXp) / (nextLevelXp - prevLevelXp)) * 100;

                const lvlEl = document.getElementById(`lvl-${skill}`);
                const barEl = document.getElementById(`bar-${skill}`);

                if (lvlEl) lvlEl.textContent = level;
                if (barEl) barEl.style.width = Math.min(100, progress) + '%';
            });

            // v5.2: Update talent points button
            const talentBtn = document.getElementById('talent-points-btn');
            if (talentBtn) {
                const points = getTalentPoints();
                talentBtn.textContent = points.available;
                talentBtn.parentElement.style.borderColor = points.available > 0 ? '#ff0' : '#ffd700';
                talentBtn.parentElement.style.animation = points.available > 0 ? 'ability-ready-pulse 2s infinite' : 'none';
            }
        }

        function updateHealthUI() {
            const hp = gameData.player.hp;
            const maxHp = gameData.player.maxHp;
            const percent = (hp / maxHp) * 100;

            const healthBar = document.getElementById('player-health-bar');
            const healthFill = document.getElementById('player-health-fill');
            const healthText = document.getElementById('health-text');

            if (healthFill) {
                healthFill.style.width = percent + '%';
                // v5.15.2: Update fill color based on health level
                healthFill.classList.remove('low', 'critical');
                if (percent <= 25) {
                    healthFill.classList.add('critical');
                } else if (percent <= 50) {
                    healthFill.classList.add('low');
                }
            }
            if (healthText) {
                healthText.textContent = `${Math.round(hp)} / ${maxHp}`;
            }
            // v5.15.2: Update bar border for critical state
            if (healthBar) {
                healthBar.classList.toggle('critical', percent <= 25);
            }
        }

        // v4.8: Update ability UI cooldowns and states (v4.9: Extended with Tier 2)
        function updateAbilityUI() {
            const abilities = [
                // Tier 1
                { key: 'q', id: 'powerStrike', slot: 'ability-q', cooldown: 'cooldown-q' },
                { key: 'e', id: 'whirlwind', slot: 'ability-e', cooldown: 'cooldown-e' },
                { key: 'r', id: 'warcry', slot: 'ability-r', cooldown: 'cooldown-r' },
                // v4.9: Tier 2
                { key: 't', id: 'heal', slot: 'ability-t', cooldown: 'cooldown-t' },
                { key: 'f', id: 'dash', slot: 'ability-f', cooldown: 'cooldown-f' },
                { key: 'z', id: 'shieldWall', slot: 'ability-z', cooldown: 'cooldown-z' },
                { key: 'x', id: 'execute', slot: 'ability-x', cooldown: 'cooldown-x' },
                { key: 'c', id: 'berserk', slot: 'ability-c', cooldown: 'cooldown-c' }
            ];

            abilities.forEach(({ key, id, slot, cooldown }) => {
                const slotEl = document.getElementById(slot);
                const cdEl = document.getElementById(cooldown);
                const ability = COMBAT_ABILITIES[id];

                if (!slotEl || !cdEl) return;

                // Check if unlocked
                const unlocked = isAbilityUnlocked(id);
                slotEl.classList.toggle('locked', !unlocked);

                // Check cooldown
                const cdRemaining = getAbilityCooldownRemaining(id);
                const onCooldown = cdRemaining > 0;
                slotEl.classList.toggle('on-cooldown', onCooldown);

                // Show cooldown overlay
                if (onCooldown) {
                    const cdPercent = (cdRemaining / ability.cooldown) * 100;
                    cdEl.style.height = cdPercent + '%';
                } else {
                    cdEl.style.height = '0%';
                }

                // Special: Buff active states
                if (id === 'warcry' && isWarcryActive()) {
                    slotEl.classList.add('active-buff');
                } else if (id === 'warcry') {
                    slotEl.classList.remove('active-buff');
                }
                // v4.9: Shield Wall active state
                if (id === 'shieldWall' && isShieldWallActive()) {
                    slotEl.classList.add('active-buff');
                    slotEl.style.borderColor = '#4488ff';
                    slotEl.style.boxShadow = '0 0 10px #4488ff';
                } else if (id === 'shieldWall') {
                    slotEl.classList.remove('active-buff');
                    slotEl.style.borderColor = '';
                    slotEl.style.boxShadow = '';
                }
                // v4.9: Berserk active state
                if (id === 'berserk' && isBerserkActive()) {
                    slotEl.classList.add('active-buff');
                    slotEl.style.borderColor = '#ff4400';
                    slotEl.style.boxShadow = '0 0 15px #ff4400';
                } else if (id === 'berserk') {
                    slotEl.classList.remove('active-buff');
                    slotEl.style.borderColor = '';
                    slotEl.style.boxShadow = '';
                }
            });

            // v4.9: Update buff overlays
            const berserkOverlay = document.getElementById('berserk-overlay');
            const shieldOverlay = document.getElementById('shield-overlay');
            if (berserkOverlay) {
                berserkOverlay.style.opacity = isBerserkActive() ? '1' : '0';
            }
            if (shieldOverlay) {
                shieldOverlay.style.opacity = isShieldWallActive() ? '1' : '0';
            }
        }

        function updatePlaytimeDisplay() {
            const total = Math.floor(gameData.playtime);
            const hours = Math.floor(total / 3600);
            const mins = Math.floor((total % 3600) / 60);
            document.getElementById('total-playtime').textContent = `${hours}:${mins.toString().padStart(2, '0')}`;
        }

        // --- CRAFTING ---
        function craft(recipeId) {
            const recipe = RECIPES[recipeId];
            if (!recipe) return;

            // v4.2: Check crafting level requirement
            if (recipe.craftingLevel && gameData.skills.crafting.level < recipe.craftingLevel) {
                showNotification(`Requires Crafting level ${recipe.craftingLevel}!`, 'error');
                AudioSystem.error();
                return;
            }

            // Check requirements
            for (const [item, count] of Object.entries(recipe.requires)) {
                if (!hasItem(item, count)) {
                    showNotification(`Need ${count}x ${item}!`, 'error');
                    AudioSystem.error(); // v4.0
                    return;
                }
            }

            // Consume materials
            for (const [item, count] of Object.entries(recipe.requires)) {
                removeItem(item, count);
            }

            // Add result
            addItem(recipe.result);
            addXp('crafting', 30);
            if (recipeId === 'cookedFish') {
                addXp('cooking', 25);
                gameData.statistics.fishCooked = (gameData.statistics.fishCooked || 0) + 1;
            }
            gameData.statistics.itemsCrafted++;

            // v4.1: Check achievements and daily progress
            checkAchievements();
            updateDailyChallengeProgress();

            showNotification(`Crafted ${recipe.result}!`);
            AudioSystem.craft(); // v4.0
            updateCraftingUI();
        }

        // v4.2: Enhanced crafting UI with level requirements and new recipes
        function updateCraftingUI() {
            const recipeDisplayNames = {
                'pickaxe': 'Pickaxe',
                'sword': 'Sword',
                'rod': 'Fishing Rod',
                'cookedFish': 'Cooked Fish',
                'potion': 'Health Potion',
                'frostBlade': 'Frost Blade',
                'magmaSword': 'Magma Sword',
                'voidDagger': 'Void Dagger',
                'crystalPickaxe': 'Crystal Pickaxe',
                'superPotion': 'Super Potion',
                'chitinArmor': 'Chitin Armor'
            };

            for (const [id, recipe] of Object.entries(RECIPES)) {
                const btn = document.getElementById(`craft-${id}`);
                if (!btn) continue;

                let canCraft = true;
                let reqParts = [];

                // v4.2: Check level requirement
                if (recipe.craftingLevel && gameData.skills.crafting.level < recipe.craftingLevel) {
                    canCraft = false;
                    reqParts.push(`Lvl ${recipe.craftingLevel} req`);
                }

                for (const [item, count] of Object.entries(recipe.requires)) {
                    const have = countItem(item);
                    if (have < count) canCraft = false;
                    reqParts.push(`${have}/${count} ${item}`);
                }
                btn.disabled = !canCraft;
                btn.innerHTML = `${recipeDisplayNames[id] || recipe.result}<br><small style="opacity:0.7">${reqParts.join(', ')}</small>`;
            }
        }

        // --- MINIMAP ---
        let minimapCtx;

        function initMinimap() {
            const canvas = document.getElementById('minimap-canvas');
            canvas.width = 100;
            canvas.height = 100;
            minimapCtx = canvas.getContext('2d');
        }

        // v4.4: Update fog of war exploration
        function updateExploration() {
            if (!worldState.player || !activeCiv) return;

            const planetId = activeCiv.id;
            if (!gameData.exploredTiles[planetId]) {
                gameData.exploredTiles[planetId] = {};
            }

            // Mark tiles within vision radius as explored
            const px = Math.floor(worldState.player.position.x / 10);
            const pz = Math.floor(worldState.player.position.z / 10);
            const visionRadius = 3;

            for (let dx = -visionRadius; dx <= visionRadius; dx++) {
                for (let dz = -visionRadius; dz <= visionRadius; dz++) {
                    if (dx * dx + dz * dz <= visionRadius * visionRadius) {
                        const key = `${px + dx},${pz + dz}`;
                        gameData.exploredTiles[planetId][key] = 1;
                    }
                }
            }
        }

        function isTileExplored(planetId, worldX, worldZ) {
            const tx = Math.floor(worldX / 10);
            const tz = Math.floor(worldZ / 10);
            const key = `${tx},${tz}`;
            return gameData.exploredTiles[planetId]?.[key] === 1;
        }

        function updateMinimap() {
            if (!minimapCtx || !worldState.player) return;

            // v4.4: Update exploration tracking
            updateExploration();

            const ctx = minimapCtx;
            const size = 100;
            const scale = size / (CONFIG.WORLD_SIZE * 2);
            const planetId = activeCiv?.id;

            // Clear with fog of war (darker)
            ctx.fillStyle = '#050505';
            ctx.fillRect(0, 0, size, size);

            // v4.4: Draw explored areas lighter
            if (planetId && gameData.exploredTiles[planetId]) {
                ctx.fillStyle = '#181818';
                for (const key in gameData.exploredTiles[planetId]) {
                    const [tx, tz] = key.split(',').map(Number);
                    const x = (tx * 10 + CONFIG.WORLD_SIZE) * scale;
                    const y = (tz * 10 + CONFIG.WORLD_SIZE) * scale;
                    ctx.fillRect(x - 5 * scale, y - 5 * scale, 10 * scale, 10 * scale);
                }
            }

            // Draw terrain bounds
            ctx.strokeStyle = '#333';
            ctx.strokeRect(0, 0, size, size);

            // Draw interactables (only in explored areas)
            ctx.fillStyle = '#0a0';
            worldState.interactables.forEach(obj => {
                if (obj.userData.type === 'tree') {
                    const x = (obj.position.x + CONFIG.WORLD_SIZE) * scale;
                    const y = (obj.position.z + CONFIG.WORLD_SIZE) * scale;
                    ctx.fillRect(x - 1, y - 1, 2, 2);
                }
            });

            ctx.fillStyle = '#888';
            worldState.interactables.forEach(obj => {
                if (obj.userData.type === 'rock') {
                    const x = (obj.position.x + CONFIG.WORLD_SIZE) * scale;
                    const y = (obj.position.z + CONFIG.WORLD_SIZE) * scale;
                    ctx.fillRect(x - 1, y - 1, 2, 2);
                }
            });

            // Draw mobs
            ctx.fillStyle = '#f00';
            worldState.mobs.forEach(mob => {
                const x = (mob.position.x + CONFIG.WORLD_SIZE) * scale;
                const y = (mob.position.z + CONFIG.WORLD_SIZE) * scale;
                ctx.beginPath();
                ctx.arc(x, y, 2, 0, Math.PI * 2);
                ctx.fill();
            });

            // v4.2: Draw POIs
            worldState.pois.forEach(poi => {
                const x = (poi.position.x + CONFIG.WORLD_SIZE) * scale;
                const y = (poi.position.z + CONFIG.WORLD_SIZE) * scale;
                ctx.fillStyle = poi.userData.discovered ? '#666' : '#ffd700';
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fill();
                if (!poi.userData.discovered) {
                    ctx.strokeStyle = '#ffa500';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            });

            // v5.13: Draw ship and landing zone
            if (SHIP_STATE.mesh) {
                const shipX = (SHIP_STATE.mesh.position.x + CONFIG.WORLD_SIZE) * scale;
                const shipY = (SHIP_STATE.mesh.position.z + CONFIG.WORLD_SIZE) * scale;

                // Landing zone circle
                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(shipX, shipY, 6, 0, Math.PI * 2);
                ctx.stroke();

                // Ship icon
                ctx.fillStyle = SHIP_STATE.hp > 0 ? '#00ffff' : '#444';
                ctx.beginPath();
                ctx.moveTo(shipX, shipY - 4);
                ctx.lineTo(shipX + 3, shipY + 3);
                ctx.lineTo(shipX - 3, shipY + 3);
                ctx.closePath();
                ctx.fill();

                // Defense range indicator (subtle)
                if (SHIP_STATE.laser.autoDefend) {
                    ctx.strokeStyle = 'rgba(0, 255, 136, 0.3)';
                    ctx.setLineDash([2, 2]);
                    ctx.beginPath();
                    ctx.arc(shipX, shipY, SHIP_STATE.laser.range * scale, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }

            // v5.16.1: Draw agents on minimap
            // v5.17: Enhanced with level indicators and combo effects
            agentFleet.forEach(agent => {
                if (!agent.mesh) return;
                const ax = (agent.mesh.position.x + CONFIG.WORLD_SIZE) * scale;
                const ay = (agent.mesh.position.z + CONFIG.WORLD_SIZE) * scale;

                // Get agent color
                const color = '#' + agent.typeConfig.color.toString(16).padStart(6, '0');

                // v5.17: Draw combo aura when agent has high combo
                if (agent.combo >= 5) {
                    const comboIntensity = Math.min(agent.combo / 20, 1);
                    const pulse = Math.sin(performance.now() / 150) * 0.3 + 0.7;
                    ctx.strokeStyle = `rgba(255, 136, 0, ${comboIntensity * pulse})`;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(ax, ay, 5 + agent.combo * 0.2, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Draw highlight ring if highlighted
                if (agent.minimapHighlight) {
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(ax, ay, 6, 0, Math.PI * 2);
                    ctx.stroke();

                    // Pulsing outer ring
                    const pulse = Math.sin(performance.now() / 200) * 0.5 + 0.5;
                    ctx.strokeStyle = `rgba(255, 255, 255, ${pulse * 0.5})`;
                    ctx.beginPath();
                    ctx.arc(ax, ay, 8 + pulse * 3, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Draw alert indicator
                if (agent.taskState?.alert) {
                    ctx.fillStyle = '#ff0000';
                    ctx.beginPath();
                    ctx.arc(ax, ay, 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#ff4444';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                } else if (agent.taskState?.state === 'working') {
                    // v5.17: Working indicator - pulsing glow
                    const workPulse = Math.sin(performance.now() / 300) * 0.5 + 0.5;
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.arc(ax, ay, 2.5 + workPulse, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 0.5;
                    ctx.stroke();
                } else if (agent.taskState?.state === 'combat') {
                    // v5.17: Combat indicator - red flash
                    const combatPulse = Math.sin(performance.now() / 100) * 0.5 + 0.5;
                    ctx.fillStyle = `rgba(255, 68, 68, ${combatPulse})`;
                    ctx.beginPath();
                    ctx.arc(ax, ay, 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.arc(ax, ay, 2, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // Normal agent dot - size scales with level
                    const levelSize = 2 + agent.agentLevel * 0.2;
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.arc(ax, ay, levelSize, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            // Draw player
            ctx.fillStyle = '#ff0';
            const px = (worldState.player.position.x + CONFIG.WORLD_SIZE) * scale;
            const py = (worldState.player.position.z + CONFIG.WORLD_SIZE) * scale;
            ctx.beginPath();
            ctx.arc(px, py, 3, 0, Math.PI * 2);
            ctx.fill();
        }

        // Start
        init();

        // v5.18: Initialize P2P spectator system
        checkSpectatorMode();

        // v5.19: Initialize Show Mode button listeners
        initShowModeButtons();
    </script>
</body>
</html>
